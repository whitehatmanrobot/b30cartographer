RECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pvInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateCancelAsyncOperation( pvInterface, hAsyncOp, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN( DPNERR_UNINITIALIZED );
    }    	

	pNTEntry = NULL;
	pConnection = NULL;
	pAsyncOp = NULL;
	pHandleParent = NULL;

	//
	//	If hAsyncOp is specified and it's not supposed to be a player ID, we will cancel the
	//	operation it represents.  Otherwise, we will rely on the flags to determine which operations
	//	to cancel.
	//
	if ((hAsyncOp) && (! (dwFlags & DPNCANCEL_PLAYER_SENDS)))
	{
		//
		//	Cancel single operation
		//
		pdnObject->HandleTable.Lock();
		if ((hResultCode = pdnObject->HandleTable.Find(hAsyncOp,(PVOID*)&pHandleParent)) != DPN_OK)
		{
			pdnObject->HandleTable.Unlock();
			DPFERR("Invalid USER Handle specified");
			hResultCode = DPNERR_INVALIDHANDLE;
			goto Failure;
		}
		else
		{
			pHandleParent->AddRef();
			pdnObject->HandleTable.Unlock();
		}
		if ( pHandleParent->GetOpType() != ASYNC_OP_USER_HANDLE )
		{
			DPFERR("Invalid USER Handle specified");
			hResultCode = DPNERR_INVALIDHANDLE;
			goto Failure;
		}

		//
		//	Some operations may be marked as CANNOT_CANCEL.  Return DPNERR_CANNOTCANCEL for these
		//
		if ( pHandleParent->IsCannotCancel() )
		{
			DPFERR("Operation not allowed to be cancelled");
			hResultCode = DPNERR_CANNOTCANCEL;
			goto Failure;
		}

		hResultCode = DNCancelChildren(pdnObject,pHandleParent);

		pHandleParent->Release();
		pHandleParent = NULL;
	}
	else
	{
		//
		//	Cancel many operations based on flags
		//
		DWORD	dwInternalFlags;
		HRESULT	hr;




		//
		//	Re-map flags
		//
		dwInternalFlags = 0;
		if (dwFlags & DPNCANCEL_ALL_OPERATIONS)
		{
#ifdef DPNBUILD_NOMULTICAST
			dwInternalFlags = ( DN_CANCEL_FLAG_CONNECT | DN_CANCEL_FLAG_ENUM_QUERY | DN_CANCEL_FLAG_USER_SEND );
#else // ! DPNBUILD_NOMULTICAST
			dwInternalFlags = ( DN_CANCEL_FLAG_CONNECT | DN_CANCEL_FLAG_ENUM_QUERY | DN_CANCEL_FLAG_USER_SEND | DN_CANCEL_FLAG_JOIN );
#endif // ! DPNBUILD_NOMULTICAST
		}
		else if (dwFlags & DPNCANCEL_CONNECT)
		{
			dwInternalFlags = DN_CANCEL_FLAG_CONNECT;
		}
		else if (dwFlags & DPNCANCEL_ENUM)
		{
			dwInternalFlags = DN_CANCEL_FLAG_ENUM_QUERY;
		}
		else if (dwFlags & DPNCANCEL_SEND)
		{
			dwInternalFlags = DN_CANCEL_FLAG_USER_SEND;
		}
#ifndef DPNBUILD_NOMULTICAST
		else if (dwFlags & DPNCANCEL_JOIN)
		{
			dwInternalFlags = DN_CANCEL_FLAG_JOIN;
		}
#endif // ! DPNBUILD_NOMULTICAST
#ifdef	DIRECTPLAYDIRECTX9
		else if (dwFlags & DPNCANCEL_PLAYER_SENDS)
		{
			//
			//	If the DPNCANCEL_PLAYER_SENDS flag is specified, then hAsyncOp is actually
			//	a player ID (except Client, where it must be 0, and it means the host player).
			//
			if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
			{
				if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pNTEntry)) != DPN_OK)
				{
					DPFERR("Unable to find host player");
					hResultCode = DPNERR_NOCONNECTION;
					goto Failure;
				}
			}
			else
			{
				if ((hResultCode = pdnObject->NameTable.FindEntry((DPNID) hAsyncOp,&pNTEntry)) != DPN_OK)
				{
					DPFERR("Unable to find specified player");
					hResultCode = DPNERR_INVALIDPLAYER;
					goto Failure;
				}

				if (pNTEntry->IsGroup())
				{
					DPFERR("Specified ID is not a player");
					hResultCode = DPNERR_INVALIDPLAYER;
					goto Failure;
				}
			}

			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
			{
				hResultCode = DPNERR_CONNECTIONLOST;
				goto Failure;
			}
			pNTEntry->Release();
			pNTEntry = NULL;


			//
			//	Re-map flags.
			//
			dwInternalFlags = DN_CANCEL_FLAG_USER_SEND;
			if (dwFlags & (DPNCANCEL_PLAYER_SENDS_PRIORITY_HIGH | DPNCANCEL_PLAYER_SENDS_PRIORITY_NORMAL | DPNCANCEL_PLAYER_SENDS_PRIORITY_LOW))
			{
				if (! (dwFlags & DPNCANCEL_PLAYER_SENDS_PRIORITY_HIGH))
				{
					dwInternalFlags |= DN_CANCEL_FLAG_USER_SEND_NOTHIGHPRI;
				}
				if (! (dwFlags & DPNCANCEL_PLAYER_SENDS_PRIORITY_NORMAL))
				{
					dwInternalFlags |= DN_CANCEL_FLAG_USER_SEND_NOTNORMALPRI;
				}
				if (! (dwFlags & DPNCANCEL_PLAYER_SENDS_PRIORITY_LOW))
				{
					dwInternalFlags |= DN_CANCEL_FLAG_USER_SEND_NOTLOWPRI;
				}
				
				//
				// We should have set at least one of the negation flags.
				//
				DNASSERT(dwInternalFlags & (DN_CANCEL_FLAG_USER_SEND_NOTHIGHPRI | DN_CANCEL_FLAG_USER_SEND_NOTNORMALPRI | DN_CANCEL_FLAG_USER_SEND_NOTLOWPRI));
			}
		}
#endif
		else
		{
			DNASSERT(FALSE);	// Should never get here
		}
		DPFX(DPFPREP, 3,"Re-mapped internal flags [0x%lx]",dwInternalFlags);

		//
		//	Pre-set error code
		hResultCode = DPN_OK;

		//
		//	To cancel a CONNECT, look at the DirectNetObject
		//
		if (dwInternalFlags & DN_CANCEL_FLAG_CONNECT)
		{
			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			if (pdnObject->pConnectParent)
			{
				if (pdnObject->pConnectParent->IsChild())
				{
					DNASSERT(pdnObject->pConnectParent->GetParent() != NULL);
					pdnObject->pConnectParent->GetParent()->AddRef();
					pAsyncOp = pdnObject->pConnectParent->GetParent();
				}
				else
				{
					pdnObject->pConnectParent->AddRef();
					pAsyncOp = pdnObject->pConnectParent;
				}
			}
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

			if (pAsyncOp)
			{
				DPFX(DPFPREP, 3,"Canceling CONNECT");
				hr = DNCancelChildren(pdnObject,pAsyncOp);
				if (hr != DPN_OK)
				{
					hResultCode = DPNERR_CANNOTCANCEL;
					DPFX(DPFPREP, 7,"Remapping: [0x%lx] returned by DNCancelChildren to: [0x%lx]",hr, hResultCode);
				}
				pAsyncOp->Release();
				pAsyncOp = NULL;
			}
		}

		//
		//	To cancel ENUMs and SENDs, cancel out of the active list
		//
		if (dwInternalFlags & (DN_CANCEL_FLAG_ENUM_QUERY | DN_CANCEL_FLAG_USER_SEND))
		{
			DPFX(DPFPREP, 3,"Canceling ENUMs or SENDs");
			hr = DNCancelActiveCommands(pdnObject,dwInternalFlags,pConnection,FALSE,0);
			if (hr != DPN_OK)
			{
				hResultCode = DPNERR_CANNOTCANCEL;
				DPFX(DPFPREP, 7,"Remapping: [0x%lx] returned by DNCancelActiveCommands to: [0x%lx]",hr, hResultCode);
			}
		}
	}

Exit:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Connect"

STDMETHODIMP DN_Connect( PVOID pInterface,
						 const DPN_APPLICATION_DESC *const pdnAppDesc,
						 IDirectPlay8Address *const pHostAddr,
						 IDirectPlay8Address *const pDeviceInfo,
						 const DPN_SECURITY_DESC *const pdnSecurity,
						 const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						 const void *const pvUserConnectData,
						 const DWORD dwUserConnectDataSize,
						 void *const pvPlayerContext,
						 void *const pvAsyncContext,
						 DPNHANDLE *const phAsyncHandle,
						 const DWORD dwFlags)
{
	CAsyncOp			*pHandleParent;
	CAsyncOp			*pConnectParent;
	CAsyncOp			*pAsyncOp;
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject;
	CSyncEvent			*pSyncEvent;
	HRESULT	volatile	hrOperation;
	IDirectPlay8Address	*pIHost;
	IDirectPlay8Address	*pIDevice;
	IDirectPlay8Address	*pIAdapter;
	DWORD				dwConnectFlags;
#ifndef DPNBUILD_ONLYONESP
	GUID				guidSP;
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
	GUID				guidAdapter;
#endif // ! DPNBUILD_ONLYONEADAPTER
	void				*pvConnectData;
	void				*pvAdapterBuffer;
	DPN_SP_CAPS			dnSPCaps;
#ifndef DPNBUILD_ONLYONEADAPTER
	BOOL				fEnumAdapters;
#endif // ! DPNBUILD_ONLYONEADAPTER
	CRefCountBuffer		*pReply;
	CServiceProvider	*pSP;
	DWORD				dwMultiplexFlag;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdnAppDesc [0x%p], pHostAddr [0x%p], pDeviceInfo [0x%p], pdnSecurity [0x%p], pdnCredentials [0x%p], pvUserConnectData [0x%p], dwUserConnectDataSize [%ld], pvPlayerContext [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
		pInterface,pdnAppDesc,pHostAddr,pDeviceInfo,pdnSecurity,pdnCredentials,pvUserConnectData,dwUserConnectDataSize,pvPlayerContext,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateConnect( pInterface, pdnAppDesc, pHostAddr, pDeviceInfo,
                                                      pdnSecurity, pdnCredentials, pvUserConnectData,
                                                      dwUserConnectDataSize,pvPlayerContext,
                                                      pvAsyncContext,phAsyncHandle,dwFlags ) ) )
    	{
    	    DPFERR( "Error validating connect params" );
    	    DPF_RETURN( hResultCode );
    	}
    }    	
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

	// Check to ensure not already connected/connecting
    if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING)
    {
    	DPFERR( "Object is already connecting" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }
    if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
    {
    	DPFERR( "Object is already connected" );
    	DPF_RETURN(DPNERR_ALREADYCONNECTED);
    }
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
    	DPFERR( "Object is closing or disconnecting" );
    	DPF_RETURN(DPNERR_ALREADYCLOSING);
	}

   	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
    pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTING;
    DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	// Preset these so that they are properly cleaned up
	pIHost = NULL;
	pIDevice = NULL;
	pIAdapter = NULL;
	pSyncEvent = NULL;
	pHandleParent = NULL;
	pConnectParent = NULL;
	pAsyncOp = NULL;
	pvConnectData = NULL;
	pvAdapterBuffer = NULL;
	hrOperation = DPNERR_GENERIC;
	pReply = NULL;
	pSP = NULL;
	dwMultiplexFlag = 0;

	if ((hResultCode = IDirectPlay8Address_Duplicate(pHostAddr,&pIHost)) != DPN_OK)
	{
		DPFERR("Could not duplicate host address");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Duplicate specified Device Address, or create a blank one if NULL
	//
	if (pDeviceInfo != NULL)
	{
		if ((hResultCode = IDirectPlay8Address_Duplicate(pDeviceInfo,&pIDevice)) != DPN_OK)
		{
			DPFERR("Could not duplicate device info");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
#ifdef DPNBUILD_LIBINTERFACE
		hResultCode = DP8ACF_CreateInstance(IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pIDevice));
#else // ! DPNBUILD_LIBINTERFACE
		hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pIDevice),
											FALSE);
#endif // ! DPNBUILD_LIBINTERFACE
		if (hResultCode != S_OK)
		{
			DPFERR("Could not create Device Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_LIBINTERFACE)))
	DNASSERT(pdnObject->pOnlySP != NULL);
	pdnObject->pOnlySP->AddRef();
	pSP = pdnObject->pOnlySP;
#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_ONLYONESP
	//
	//	If there is no SP on the device address, then steal it from the Host address
	//
	if ((hResultCode = IDirectPlay8Address_GetSP(pIDevice,&guidSP)) != DPN_OK)
	{
		if ((hResultCode = IDirectPlay8Address_GetSP(pIHost,&guidSP)) != DPN_OK)
		{
			DPFERR("Could not retrieve SP from Host Address");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		if ((hResultCode = IDirectPlay8Address_SetSP(pIDevice,&guidSP)) != DPN_OK)
		{
			DPFERR("Could not set SP on Device Address");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
#endif // ! DPNBUILD_ONLYONESP

	//
	//	Ensure SP is loaded
	//
	hResultCode = DN_SPEnsureLoaded(pdnObject,
#ifndef DPNBUILD_ONLYONESP
									&guidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
									NULL,
#endif // ! DPNBUILD_LIBINTERFACE
									&pSP);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not find or load SP");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE

	//
	//	Get SP caps
	//
	if ((hResultCode = DNGetActualSPCaps(pSP,&dnSPCaps)) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Update DirectNet Application Description
	//
	pdnObject->ApplicationDesc.Lock();
	hResultCode = pdnObject->ApplicationDesc.Update(pdnAppDesc,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA|DN_APPDESCINFO_FLAG_GUIDS);
	pdnObject->ApplicationDesc.Unlock();

	// Connect flags to Protocol
	dwConnectFlags = 0;
#ifndef DPNBUILD_NOSPUI
	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
	{
		dwConnectFlags |= DN_CONNECTFLAGS_OKTOQUERYFORADDRESSING;
	}
#endif // ! DPNBUILD_NOSPUI
	if (pdnObject->ApplicationDesc.GetReservedDataSize() > 0)
	{
		dwConnectFlags |= DN_CONNECTFLAGS_SESSIONDATA;
	}

	//
	//	Create parent async op, which will be released when the ENTIRE connection is finished
	//	including nametable transfer and installation on the local machine
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pConnectParent)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pConnectParent->SetOpType( ASYNC_OP_CONNECT );
	pConnectParent->MakeParent();
	pConnectParent->SetContext( pvPlayerContext );
	pConnectParent->SetResult( DPNERR_NOCONNECTION );
	pConnectParent->SetCompletion( DNCompleteConnectOperation );
	pConnectParent->SetReserved(1);

	if (dwFlags & DPNCONNECT_SYNC)
	{
		DPFX(DPFPREP, 5,"Sync operation - create sync event");
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not create synchronization event");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnectParent->SetSyncEvent( pSyncEvent );
		pConnectParent->SetResultPointer( &hrOperation );
		pConnectParent->SetOpData( &pReply );
	}
	else
	{
		DPFX(DPFPREP, 5,"Async operation - create handle parent");
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create handle parent");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pHandleParent->SetContext( pvAsyncContext );

		pHandleParent->Lock();
		if (pHandleParent->IsCancelled())
		{
			pHandleParent->Unlock();
			pConnectParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pConnectParent->MakeChild( pHandleParent );
		pHandleParent->Unlock();
	}

	//
	//	We will need a parent op for the CONNECTs to help with clean up when the initial CONNECT stage is done
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create CONNECT parent");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_CONNECT );
	pAsyncOp->MakeParent();
	pAsyncOp->SetResult( DPNERR_NOCONNECTION );
	pAsyncOp->SetCompletion( DNCompleteConnectToHost );
	pAsyncOp->SetOpFlags( dwConnectFlags );

	pConnectParent->Lock();
	if (pConnectParent->IsCancelled())
	{
		pConnectParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild( pConnectParent );
	pConnectParent->Unlock();

	//
	//	Save CONNECT data (if supplied)
	//
	if (pvUserConnectData && dwUserConnectDataSize)
	{
		if ((pvConnectData = DNMalloc(dwUserConnectDataSize)) == NULL)
		{
			DPFERR("Could not allocate CONNECT data buffer");
			DNASSERT(FALSE);
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(pvConnectData,pvUserConnectData,dwUserConnectDataSize);
	}

	//
	//	Update DirectNet object with relevant data
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pConnectParent->AddRef();
	pdnObject->pConnectParent = pConnectParent;
	if (pvConnectData)
	{
		if (pdnObject->pvConnectData)
		{
			DNFree(pdnObject->pvConnectData);
			pdnObject->pvConnectData = NULL;
		}
		pdnObject->pvConnectData = pvConnectData;
		pdnObject->dwConnectDataSize = dwUserConnectDataSize;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

#ifndef DPNBUILD_ONLYONEADAPTER
	//
	//	If there is no adapter specified in the device address,
	//	we will attempt to CONNECT on each individual adapter if the SP supports it
	//
	fEnumAdapters = FALSE;
	if ((hResultCode = IDirectPlay8Address_GetDevice( pIDevice, &guidAdapter )) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not determine adapter");
		DisplayDNError(1,hResultCode);

		if (dnSPCaps.dwFlags & DPNSPCAPS_SUPPORTSALLADAPTERS)
		{
			DPFX(DPFPREP, 3,"SP supports CONNECTing on all adapters");
			fEnumAdapters = TRUE;
		}
	}
	else
	{
		DPFX(DPFPREP, 7, "Device address contained adapter GUID.");
	}

	if(fEnumAdapters)
	{
		DWORD	dwNumAdapters;
		GUID	*pAdapterList = NULL;
		DN_CONNECT_OP_DATA	*pConnectOpData = NULL;

		if ((hResultCode = DNEnumAdapterGuids(	pdnObject,
#ifndef DPNBUILD_ONLYONESP
												&guidSP,
#endif // ! DPNBUILD_ONLYONESP
												0,
												&pAdapterList,
												&dwNumAdapters)) != DPN_OK)
		{
			DPFERR("Could not enum adapters for this SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		if (dwNumAdapters == 0)
		{
			DPFERR("No valid device adapters could be found");
			hResultCode = DPNERR_INVALIDDEVICEADDRESS;
			goto Failure;
		}

		pConnectOpData = pAsyncOp->GetLocalConnectOpData();
		pConnectOpData->dwNumAdapters = dwNumAdapters;
		pConnectOpData->dwCurrentAdapter = 0;

		if (dwNumAdapters > 1)
		{
			dwMultiplexFlag |= DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS;
		}

		//
		//	Choose first adapter for initial LISTEN call
		//
		if ((hResultCode = IDirectPlay8Address_SetDevice(pIDevice,pAdapterList)) != DPN_OK)
		{
			DPFERR("Could not set device adapter");
			DisplayDNError(0,hResultCode);
			MemoryBlockFree(pdnObject,pAdapterList);
			pAdapterList = NULL;
			goto Failure;
		}
		pConnectOpData->dwCurrentAdapter++;
		pAsyncOp->SetOpData( pAdapterList );
		pAdapterList = NULL;
		pConnectOpData = NULL;
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	pAsyncOp->SetSP( pSP );	// Set this for DNPerformNextConnect()

	//
	//	Save SP for future connects
	//
	pSP->AddRef();
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pConnectSP)
	{
		pdnObject->pConnectSP->Release();
		pdnObject->pConnectSP = NULL;
	}
	pdnObject->pConnectSP = pSP;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pdnObject->pConnectAddress = pIHost;
	IDirectPlay8Address_AddRef(pdnObject->pConnectAddress);

	//
	//	CONNECT !
	//
	hResultCode = DNPerformConnect(	pdnObject,
									NULL,
									pIDevice,
									pIHost,
									pSP,
									pAsyncOp->GetOpFlags() | dwMultiplexFlag,
									pAsyncOp);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not connect");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;
	pConnectParent->Release();
	pConnectParent = NULL;

	IDirectPlay8Address_Release(pIHost);
	pIHost = NULL;
	IDirectPlay8Address_Release(pIDevice);
	pIDevice = NULL;

	pSP->Release();
	pSP = NULL;

	if (dwFlags & DPNCONNECT_SYNC)
	{
		CNameTableEntry	*pHostPlayer;

		pHostPlayer = NULL;

		if ((hResultCode = pSyncEvent->WaitForEvent()) != DPN_OK)
		{
			DPFERR("DNSyncEventWait() terminated bizarrely");
			DNASSERT(FALSE);
		}
		else
		{
			hResultCode = hrOperation;
		}
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;

		//
		//	No longer connecting
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		//
		//	Clients need to release all sends from the server that were
		//	queued once the CONNECT_COMPLETE gets indicated.
		//	We prepare to do that now.
		//
		if ((hrOperation == DPN_OK) && (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
		{
			if (pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer ) == DPN_OK)
			{
				pHostPlayer->Lock();
				pHostPlayer->MakeAvailable();
				pHostPlayer->NotifyAddRef();
				pHostPlayer->SetInUse();
				pHostPlayer->Unlock();

				//
				//	We are now connected
				//
				DNEnterCriticalSection(&pdnObject->csDirectNetObject);
				pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
				DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			}
			else
			{
				//
				//	If we couldn't get a reference on the server (host player),
				//	then either the server has disconnected, or we are being shut down.
				//	In either case, we should return an error
				//
				DPFX(DPFPREP, 0, "Couldn't get host player reference, failing CONNECT!");
				hrOperation = DPNERR_NOCONNECTION;
				hResultCode = hrOperation;
				if (pReply)
				{
					pReply->Release();
					pReply = NULL;
				}
			}
		}
		else
		{
			//
			//	Connect failed, or this is a peer/server interface
			//
		}


		//
		//	Generate connect completion
		//
		DNUserConnectComplete(pdnObject,0,NULL,hrOperation,pReply);
		if (pReply)
		{
			pReply->Release();
			pReply = NULL;
		}

		//
		//	Cancel ENUMs if the CONNECT succeeded and unload SP's
		//
		if (hrOperation == DPN_OK)
		{
			DNCancelActiveCommands(pdnObject,DN_CANCEL_FLAG_ENUM_QUERY,NULL,TRUE,DPNERR_CONNECTING);

#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
			DN_SPReleaseAll(pdnObject);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP

		
			//
			//	Actually release queued messages if necessary
			//
			if (pHostPlayer != NULL)
			{
				pHostPlayer->PerformQueuedOperations();

				pHostPlayer->Release();
				pHostPlayer = NULL;
			}
		}

		DNASSERT( pHostPlayer == NULL );
	}
	else
	{
		pHandleParent->SetCompletion( DNCompleteUserConnect );
		if (phAsyncHandle)
		{
			*phAsyncHandle = pHandleParent->GetHandle();
		}
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;
	}

Exit:
	DNASSERT( pSP == NULL );

	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pConnectParent)
	{
		if (SUCCEEDED(pdnObject->HandleTable.Destroy( pConnectParent->GetHandle(), NULL )))
		{
			// Release the HandleTable reference
			pConnectParent->Release();
		}
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pIHost)
	{
		IDirectPlay8Address_Release(pIHost);
		pIHost = NULL;
	}
	if (pIDevice)
	{
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}
	if (pIAdapter)
	{
		IDirectPlay8Address_Release(pIAdapter);
		pIAdapter = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pvAdapterBuffer)
	{
		DNFree(pvAdapterBuffer);
		pvAdapterBuffer = NULL;
	}
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pIDP8ADevice)
	{
		IDirectPlay8Address_Release(pdnObject->pIDP8ADevice);
		pdnObject->pIDP8ADevice = NULL;
	}
	if (pdnObject->pvConnectData)
	{
		DNFree(pdnObject->pvConnectData);
		pdnObject->pvConnectData = NULL;
		pdnObject->dwConnectDataSize = 0;
	}
	if( pdnObject->pConnectAddress )
	{
		IDirectPlay8Address_Release( pdnObject->pConnectAddress );
		pdnObject->pConnectAddress = NULL;
	}
	if (pdnObject->pConnectSP)
	{
		pdnObject->pConnectSP->Release();
		pdnObject->pConnectSP = NULL;
	}
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	goto Exit;
}


//	DN_GetSendQueueInfo
//
//	Get info about the user send queue.
//	This will find the CConnection for a given player and extract the required queue infor from it.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetSendQueueInfo"

STDMETHODIMP DN_GetSendQueueInfo(PVOID pInterface,
								 const DPNID dpnid,
								 DWORD *const pdwNumMsgs,
								 DWORD *const pdwNumBytes,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	DWORD				dwQueueFlags;
	DWORD				dwNumMsgs;
	DWORD				dwNumBytes;
	CNameTableEntry     *pNTEntry;
	CConnection			*pConnection;
	HRESULT				hResultCode;

	DNASSERT(pInterface != NULL);

	DPFX(DPFPREP, 2,"Parameters : pInterface [0x%p], dpnid [0x%lx], pdwNumMsgs [0x%p], pdwNumBytes [0x%p], dwFlags [0x%lx]",
		pInterface,dpnid,pdwNumMsgs,pdwNumBytes,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	HRESULT hrResult;
    
    	if( FAILED( hrResult = DN_ValidateGetSendQueueInfo( pInterface, pdwNumMsgs, pdwNumBytes, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating params" );
    	    DPF_RETURN( hrResult );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR( "Object is already connecting" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED ) )
    {
    	DPFERR("Object is not connected" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }    	

	pNTEntry = NULL;
	pConnection = NULL;

	//
    //	Validate specified player ID and get CConnection
	//
	if((hResultCode = pdnObject->NameTable.FindEntry( dpnid, &pNTEntry )) != DPN_OK)
	{
		DPFX(DPFPREP, 0,"Could not find Player ID [0x%lx] in NameTable", dpnid );
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find entry in deleted list either");
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if (pNTEntry->IsLocal() || pNTEntry->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Determine required queues
	//
	dwQueueFlags = dwFlags & (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	if (dwQueueFlags == 0)
	{
		dwQueueFlags = (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	}

	//
	//	Extract required info
	//
	dwNumMsgs = 0;
	dwNumBytes = 0;
	pConnection->Lock();
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_HIGH)
	{
		dwNumMsgs += pConnection->GetHighQueueNum();
		dwNumBytes += pConnection->GetHighQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_NORMAL)
	{
		dwNumMsgs += pConnection->GetNormalQueueNum();
		dwNumBytes += pConnection->GetNormalQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_LOW)
	{
		dwNumMsgs += pConnection->GetLowQueueNum();
		dwNumBytes += pConnection->GetLowQueueBytes();
	}
	pConnection->Unlock();
	pConnection->Release();
	pConnection = NULL;

	if (pdwNumMsgs)
	{
		*pdwNumMsgs = dwNumMsgs;
		DPFX(DPFPREP, 3,"Setting: *pdwNumMsgs [%ld]",dwNumMsgs);
	}
	if (pdwNumBytes)
	{
		*pdwNumBytes = dwNumBytes;
		DPFX(DPFPREP, 3,"Setting: *pdwNumBytes [%ld]",dwNumBytes);
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetApplicationDesc"

STDMETHODIMP DN_GetApplicationDesc(PVOID pInterface,
								   DPN_APPLICATION_DESC *const pAppDescBuffer,
								   DWORD *const pcbDataSize,
								   const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	CPackedBuffer		packedBuffer;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pAppDescBuffer [0x%p], pcbDataSize [0x%p], dwFlags [0x%lx]",
			pInterface,pAppDescBuffer,pcbDataSize,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateGetApplicationDesc( pInterface, pAppDescBuffer, pcbDataSize, dwFlags ) ) )
    	{
    	    DPFERR( "Failed validation getappdesc" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("Object is not connected or hosting" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }    	

	//
	//	Initialize PackedBuffer
	//
	packedBuffer.Initialize(static_cast<void*>(pAppDescBuffer),*pcbDataSize);

	//
	//	Try to pack in the application description.
	//	If it won't fit, the required size will be in the PackedBuffer.
	//
	hResultCode = pdnObject->ApplicationDesc.Pack(&packedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	//
	//	Ensure we know what's going on
	//
	if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_BUFFERTOOSMALL))
	{
		DPFERR("Unknown error occurred packing application description");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Size of buffer
	//
	*pcbDataSize = packedBuffer.GetSizeRequired();

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetApplicationDesc"

STDMETHODIMP DN_SetApplicationDesc(PVOID pInterface,
								   const DPN_APPLICATION_DESC *const pdnApplicationDesc,
								   const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode = DPN_OK;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CWorkerJob			*pWorkerJob;
	DWORD				dwAppDescInfoSize;
	DWORD				dwEnumFrameSize;
	DWORD				dwUpdateFlags;
	CNameTableEntry     *pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdnApplicationDesc [0x%p], dwFlags [0x%lx]",
			pInterface,pdnApplicationDesc,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateSetApplicationDesc( pInterface, pdnApplicationDesc, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating setappdesc params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR( "Object has not yet completed connecting / hosting" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !DN_CHECK_LOCALHOST( pdnObject ) )
    {
    	DPFERR("Object is not connected or hosting" );
    	DPF_RETURN(DPNERR_NOTHOST);
    }

	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	//
	//	This can only be called by the host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry )) != DPN_OK)
	{
		DPFERR("Could not get local player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	if (!pNTEntry->IsHost())
	{
		DPFERR("Not Host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Use cached max enum frame size
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	dwEnumFrameSize = pdnObject->dwMaxFrameSize;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	
	DNASSERT( dwEnumFrameSize >= (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO)) );
	if (dwEnumFrameSize < (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO) + pdnApplicationDesc->dwApplicationReservedDataSize))
	{
		DPFERR("Not enough room for the application reserved data");
		hResultCode = DPNERR_DATATOOLARGE;
		goto Failure;
	}

	//
	//	Update Host player's application desc first
	//
	pdnObject->ApplicationDesc.Lock();
	if (pdnApplicationDesc->dwMaxPlayers > 0)
	{
		if (pdnApplicationDesc->dwMaxPlayers < pdnObject->ApplicationDesc.GetCurrentPlayers())
		{
			DPFERR("Cannot set max players to less than the current number of players");
			pdnObject->ApplicationDesc.Unlock();
			hResultCode = DPNERR_SESSIONFULL;
			goto Failure;
		}
	}
	hResultCode = pdnObject->ApplicationDesc.Update(pdnApplicationDesc,DN_APPDESCINFO_FLAG_SESSIONNAME|
			DN_APPDESCINFO_FLAG_PASSWORD|DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->ApplicationDesc.Unlock();
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not update Application Desciption");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

#ifdef	DIRECTPLAYDIRECTX9
	//
	//	Update Listen if enums allowed/disallowed
	//
	dwUpdateFlags = 0;
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_DISALLOW_ENUMS) && !(pdnApplicationDesc->dwFlags & DPNSESSION_NOENUMS))
	{
		dwUpdateFlags |= DN_UPDATE_LISTEN_FLAG_ALLOW_ENUMS;
		pdnObject->dwFlags &= ~DN_OBJECT_FLAG_DISALLOW_ENUMS;
	}
	else if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_DISALLOW_ENUMS) && (pdnApplicationDesc->dwFlags & DPNSESSION_NOENUMS))
	{
		dwUpdateFlags |= DN_UPDATE_LISTEN_FLAG_DISALLOW_ENUMS;
		pdnObject->dwFlags |= DN_OBJECT_FLAG_DISALLOW_ENUMS;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (dwUpdateFlags)
	{
		DNUpdateListens(pdnObject,dwUpdateFlags);
	}
#endif	// DIRECTPLAYDIRECTX9
	
	//
	//	Inform host application
	//
	hResultCode = DNUserUpdateAppDesc(pdnObject);

	//
	//	Get Application Description Info size
	//
	packedBuffer.Initialize(NULL,0);
	hResultCode = pdnObject->ApplicationDesc.PackInfo(&packedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	DNASSERT(hResultCode == DPNERR_BUFFERTOOSMALL);
	dwAppDescInfoSize = packedBuffer.GetSizeRequired();

	//
	//	Create packed buffer to send to other players
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,dwAppDescInfoSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create CountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	hResultCode = pdnObject->ApplicationDesc.PackInfo(&packedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not pack Application Description into buffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Notify other players
	//
	DPFX(DPFPREP, 5,"Adding UpdateApplicationDesc to Job Queue");
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) == DPN_OK)
	{
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC );
		pWorkerJob->SetSendNameTableOperationVersion( 0 );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;
	}
	else
	{
		DPFERR("Could not create worker job - ignore and continue");
		DisplayDNError(0,hResultCode);
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNTerminateSession"

HRESULT DNTerminateSession(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hrReason)
{
	HRESULT		hResultCode;
#ifndef DPNBUILD_NOLOBBY
	BOOL		fWasConnected;
#endif // ! DPNBUILD_NOLOBBY
#ifndef DPNBUILD_SINGLEPROCESS
	BOOL		fWasRegistered;
#endif // ! DPNBUILD_SINGLEPROCESS
	CAsyncOp	*pAsyncOp;

	DPFX(DPFPREP, 4,"Parameters: hrReason [0x%lx]",hrReason);

	DNASSERT(pdnObject != NULL);
	DNASSERT( (hrReason == DPN_OK) || (hrReason == DPNERR_HOSTTERMINATEDSESSION) || (hrReason == DPNERR_CONNECTIONLOST));

	pAsyncOp = NULL;

	//
	//	Shut down listen(s)
	//
	DPFX(DPFPREP, 3,"Checking LISTENs");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pAsyncOp = pdnObject->pListenParent;
	pdnObject->pListenParent = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pAsyncOp)
	{
		DPFX(DPFPREP, 3,"Canceling LISTENs");
		hResultCode = DNCancelChildren(pdnObject,pAsyncOp);
		DPFX(DPFPREP, 3,"Canceling LISTENs returned [0x%lx]",hResultCode);

		pAsyncOp->Release();
		pAsyncOp = NULL;
	}

#ifndef DPNBUILD_SINGLEPROCESS
	//
	//	Unregister from DPNSVR (if required)
	//
	fWasRegistered = FALSE;
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_DPNSVR_REGISTERED)
	{
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_DPNSVR_REGISTERED);
		fWasRegistered = TRUE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fWasRegistered)
	{
		pdnObject->ApplicationDesc.UnregisterWithDPNSVR();
	}
#endif // ! DPNBUILD_SINGLEPROCESS

	//
	//	Flag DirectNetObject as disconnecting.  This flag will be cleared when Close() finishes.
	//
#ifndef DPNBUILD_NOLOBBY
	fWasConnected = FALSE;
#endif // ! DPNBUILD_NOLOBBY
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
#ifndef DPNBUILD_NOLOBBY
		fWasConnected = TRUE;
#endif // ! DPNBUILD_NOLOBBY
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTED);
	}
#pragma BUGBUG( minara,"How usefull is this DN_OBJECT_FLAG_DISCONNECTING flag ?" )
	pdnObject->dwFlags |= DN_OBJECT_FLAG_DISCONNECTING;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

#ifndef DPNBUILD_NOLOBBY
	//
	//	Update Lobby status
	//
	if (fWasConnected)
	{
		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
	}
#endif // ! DPNBUILD_NOLOBBY

#ifndef DPNBUILD_NOVOICE
	//
	//	Notify Voice
	//
	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
#endif // DPNBUILD_NOVOICE

	//
	//	Remove host migration target
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pNewHost)
	{
		pdnObject->pNewHost->Release();
		pdnObject->pNewHost = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Delete all players from NameTable.  This will involve
	//	emptying the table and removing short-cut player pointers
	//
	DPFX(DPFPREP, 5,"Removing players from NameTable");
	pdnObject->NameTable.EmptyTable(hrReason);

	//
	//	Clean up NameTable operation list
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DPFX(DPFPREP, 5,"Cleaning up NameTable operation list");
		DNNTRemoveOperations(pdnObject,0,TRUE);
	}

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Clean up CONNECT parent
	//
	if (pdnObject->pConnectParent)
	{
		pAsyncOp = pdnObject->pConnectParent;
		pdnObject->pConnectParent = NULL;
	}

	//
	//	Clean up CONNECT info and address
	//
	if (pdnObject->pvConnectData)
	{
		DNFree(pdnObject->pvConnectData);
		pdnObject->pvConnectData = NULL;
		pdnObject->dwConnectDataSize = 0;
	}
	if (pdnObject->pConnectAddress)
	{
		IDirectPlay8Address_Release(pdnObject->pConnectAddress);
		pdnObject->pConnectAddress = NULL;
	}
	if (pdnObject->pIDP8ADevice)
	{
		IDirectPlay8Address_Release(pdnObject->pIDP8ADevice);
		pdnObject->pIDP8ADevice = NULL;
	}

	//
	//	Clear the DISCONNECTING and HOST_CONNECTED flag
	//	and clear connection info
	//
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_DISCONNECTING
							| DN_OBJECT_FLAG_HOST_CONNECTED));

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}

	hResultCode = DPN_OK;

	DNASSERT(pAsyncOp == NULL);

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SendTo"

STDMETHODIMP DN_SendTo( PVOID pv,
						const DPNID dpnid,
						const DPN_BUFFER_DESC *const prgBufferDesc,
						const DWORD cBufferDesc,
						const DWORD dwTimeOut,
						void *const pvAsyncContext,
						DPNHANDLE *const phAsyncHandle,
						const DWORD dwFlags)
{
	HRESULT				hResultCode;
	HRESULT				hrSend;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	DIRECTNETOBJECT		*pdnObject;
	DWORD				dwSendFlags;
	CSyncEvent			*pSyncEvent;
	const DPN_BUFFER_DESC		*pActualBufferDesc;
	DWORD				dwActualBufferDesc;
	CRefCountBuffer		*pRefCountBuffer;
	DPNHANDLE			handle;
	CAsyncOp			*pAsyncOp;
	CAsyncOp			*pParent;
	CAsyncOp			*pHandleParent;
	CConnection			*pConnection;

	DPFX(DPFPREP, 2,"Parameters: dpnid [0x%lx], prgBufferDesc [0x%p], dwTimeOut [%ld], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			dpnid,prgBufferDesc,dwTimeOut,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateSendParams( pv , prgBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating common send params hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR( "Object has not yet completed connecting / hosting" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("Object is not connected or hosting" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }

	pRefCountBuffer = NULL;
	pSyncEvent = NULL;
	pNTEntry = NULL;
	pLocalPlayer = NULL;
	pAsyncOp = NULL;
	pParent = NULL;
	pHandleParent = NULL;
	pConnection = NULL;
	handle = 0;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DPFERR("Could not find Host player");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
		
		if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get Connection reference");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_CONNECTIONLOST;	// re-map this
			goto Failure;
		}

		pNTEntry->Release();
		pNTEntry = NULL;
	}
#ifndef DPNBUILD_NOMULTICAST
	else if (pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST)
	{
		if (pdnObject->pMulticastSend == NULL)
		{
			DPFERR("Could not get multicast send connection");
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pdnObject->pMulticastSend->AddRef();
		pConnection = pdnObject->pMulticastSend;
	}
#endif // ! DPNBUILD_NOMULTICAST
	else
	{
		if (dpnid == DPNID_ALL_PLAYERS_GROUP)
		{
			if ((hResultCode = pdnObject->NameTable.GetAllPlayersGroupRef( &pNTEntry )) != DPN_OK)
			{
				DPFERR("Unable to get all players group");
				DisplayDNError(0,hResultCode);
				hResultCode = DPNERR_INVALIDGROUP;
				goto Failure;
			}
		}
		else
		{
			if (dwFlags & DPNSEND_NOLOOPBACK)
			{
				if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
				{
					DPFERR("Could not get local player reference");
					DisplayDNError(0,hResultCode);
					hResultCode = DPNERR_GENERIC;
					goto Failure;
				}
				if (dpnid == pLocalPlayer->GetDPNID())
				{
					hResultCode = DPNERR_INVALIDPARAM;
					goto Failure;
				}
				pLocalPlayer->Release();
				pLocalPlayer = NULL;
			}

			if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
			{
				DPFERR("Unable to find target player or group");
				DisplayDNError(0,hResultCode);
				//
				//	Try deleted list
				//
				if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
				{
					DPFERR("Could not find target in deleted list either");
					hResultCode = DPNERR_INVALIDPLAYER;
					goto Failure;
				}
				pNTEntry->Release();
				pNTEntry = NULL;

				//
				//	Target was found, but is not reachable
				//
				hResultCode = DPNERR_CONNECTIONLOST;
				goto Failure;
			}

			if (! pNTEntry->IsGroup())
			{
				if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
				{
					DPFERR("Could not get Connection reference");
					DisplayDNError(0,hResultCode);
					hResultCode = DPNERR_CONNECTIONLOST;	// re-map this
					goto Failure;
				}
				
				pNTEntry->Release();
				pNTEntry = NULL;
			}
		}
	}

	//
	//	Create copy of data in scatter-gather buffers
	//
	if (!(dwFlags & (DPNSEND_NOCOPY | DPNSEND_COMPLETEONPROCESS)))
	{
		DWORD	dw;
		DWORD	dwSize;

		dwSize = 0;
		for ( dw = 0 ; dw < cBufferDesc ; dw++ )
		{
			dwSize += prgBufferDesc[dw].dwBufferSize;
		}

		if ((hResultCode = RefCountBufferNew(pdnObject,dwSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not allocate buffer");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		pActualBufferDesc = pRefCountBuffer->BufferDescAddress();
		dwActualBufferDesc = 1;
		dwSize = 0;
		for ( dw = 0 ; dw < cBufferDesc ; dw++ )
		{
			memcpy(pActualBufferDesc->pBufferData + dwSize,prgBufferDesc[dw].pBufferData,prgBufferDesc[dw].dwBufferSize);
			dwSize += prgBufferDesc[dw].dwBufferSize;
		}
	}
	else
	{
		pRefCountBuffer = NULL;
		pActualBufferDesc = prgBufferDesc;
		dwActualBufferDesc = cBufferDesc;
	}

	dwSendFlags = 0;
	if (dwFlags & DPNSEND_GUARANTEED)
	{
		dwSendFlags |= DN_SENDFLAGS_RELIABLE;
	}
	if (dwFlags & DPNSEND_NONSEQUENTIAL)
	{
		dwSendFlags |= DN_SENDFLAGS_NON_SEQUENTIAL;
	}
	if (dwFlags & DPNSEND_PRIORITY_HIGH)
	{
		dwSendFlags |= DN_SENDFLAGS_HIGH_PRIORITY;
	}
	if (dwFlags & DPNSEND_PRIORITY_LOW)
	{
		dwSendFlags |= DN_SENDFLAGS_LOW_PRIORITY;
	}
#ifdef	DIRECTPLAYDIRECTX9
	if (dwFlags & DPNSEND_COALESCE)
	{
		dwSendFlags |= DN_SENDFLAGS_COALESCE;
	}
#endif	// DIRECTPLAYDIRECTX9
	if (dwFlags & DPNSEND_SYNC)
	{
		//
		//	Create SyncEvent for SYNC operation
		//
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not create sync event for group sends");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	else
	{
		//
		//	Create Handle for ASYNC operation
		//
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create AsyncOp");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		pHandleParent->SetContext( pvAsyncContext );
		pHandleParent->SetStartTime( GETTIMESTAMP() );
		handle = pHandleParent->GetHandle();
	}

	//
	// pNTEntry will be NULL if this is not a group send
	// pConnection will not be NULL if this is not a group send
	//
	if (pNTEntry != NULL)
	{
		BOOL	fRequest;
		BOOL	fNoLoopBack;


		DNASSERT(pConnection == NULL);
		//
		//	Perform group sends and get parent AsyncOp
		//
		if (dwFlags & DPNSEND_COMPLETEONPROCESS)
		{
			fRequest = TRUE;
		}
		else
		{
			fRequest = FALSE;
		}
		if (dwFlags & DPNSEND_NOLOOPBACK)
		{
			fNoLoopBack = TRUE;
		}
		else
		{
			fNoLoopBack = FALSE;
		}
		hResultCode = DNSendGroupMessage(	pdnObject,
											pNTEntry,
											DN_MSG_USER_SEND,
											pActualBufferDesc,
											dwActualBufferDesc,
											pRefCountBuffer,
											dwTimeOut,
											dwSendFlags,
											fNoLoopBack,
											fRequest,
											pHandleParent,
											&pParent);

		if (hResultCode != DPN_OK)
		{
			DPFERR("SEND failed");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		//
		//	Synchronous ?
		//
		if (dwFlags & DPNSEND_SYNC)
		{
			pParent->SetSyncEvent( pSyncEvent );
			pParent->SetResultPointer( &hrSend );
			hrSend = DPNERR_GENERIC;
		}
		else
		{
			//
			//	Set async completion (if required).  We will only need this if the SEND succeeded.
			//
			if (!(dwFlags & DPNSEND_NOCOMPLETE))
			{
				pHandleParent->SetCompletion( DNCompleteSendHandle );
			}
			pHandleParent->Release();
			pHandleParent = NULL;
		}

		pParent->Release();
		pParent = NULL;
		
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	else
	{
		DNASSERT(pConnection != NULL);
		
		if (dwFlags & DPNSEND_COMPLETEONPROCESS)
		{
			hResultCode = DNPerformRequest(	pdnObject,
											DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION,
											pActualBufferDesc,
											pConnection,
											pHandleParent,
											&pAsyncOp);
		}
		else
		{
			hResultCode = DNSendMessage(pdnObject,
										pConnection,
										DN_MSG_USER_SEND,
										dpnid,
										pActualBufferDesc,
										dwActualBufferDesc,
										pRefCountBuffer,
										dwTimeOut,
										dwSendFlags,
										pHandleParent,
										&pAsyncOp);
		}

		pConnection->Release();
		pConnection = NULL;

		if (hResultCode == DPN_OK)
		{
			//
			// If the caller wants asynchronous, we want to guarantee that we'll always
			// return DPNSUCCESS_PENDING, but since the send is already complete,
			// manually generate the completion now.
			// If the caller wanted synchronous, trigger the event so we drop out of
			// the wait below.
			//
			if (dwFlags & DPNSEND_SYNC)
			{
				pSyncEvent->Set();
				hrSend = DPN_OK;
			}
			else
			{
				//
				// Immediate completion should only happen for non-guaranteed sends
				// where we wouldn't be told of the RTT and retry count anyway.
				//
				DNASSERT(! (dwFlags & DPNSEND_GUARANTEED));
				DNUserSendComplete(	pdnObject,
									handle,
									pvAsyncContext,
									pHandleParent->GetStartTime(),
									DPN_OK,
									-1,
									0);
				pHandleParent->Release();
				pHandleParent = NULL;
			}
		}
		else
		{
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("SEND failed");
				DisplayDNError(0,hResultCode);
				if (hResultCode == DPNERR_INVALIDENDPOINT)
				{
					hResultCode = DPNERR_CONNECTIONLOST;
				}
				goto Failure;
			}

			//
			//	Synchronous ?
			//
			if (dwFlags & DPNSEND_SYNC)
			{
				pAsyncOp->SetSyncEvent( pSyncEvent );
				pAsyncOp->SetResultPointer( &hrSend );
				hrSend = DPNERR_GENERIC;
#pragma TODO( minara, "We can be smarter about passing back errors - at least better than this !" )
			}
			else
			{
				//
				//	Set async completion (if required).  We will only need this if the SEND succeeded.
				//
				if (!(dwFlags & DPNSEND_NOCOMPLETE))
				{
					pHandleParent->SetCompletion( DNCompleteSendHandle );
				}
				pHandleParent->Release();
				pHandleParent = NULL;
			}

			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
	}

	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	if (dwFlags & DPNSEND_SYNC)
	{
		pSyncEvent->WaitForEvent();
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
		hResultCode = hrSend;
	}
	else
	{
		if (phAsyncHandle != NULL)
		{
			*phAsyncHandle = handle;
		}
		hResultCode = DPNERR_PENDING;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (handle != 0)
	{
		if (SUCCEEDED(pdnObject->HandleTable.Destroy( handle, (PVOID*)&pAsyncOp )))
		{
			// Release the HandleTable reference
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
		handle = 0;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//	DN_Host

#undef DPF_MODNAME
#define DPF_MODNAME "DN_Host"

STDMETHODIMP DN_Host( PVOID pInterface,
					  const DPN_APPLICATION_DESC *const pdnAppDesc,
					  IDirectPlay8Address **const prgpDeviceInfo,
					  const DWORD cDeviceInfo,
					  const DPN_SECURITY_DESC *const pdnSecurity,
					  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
					  void *const pvPlayerContext,
					  const DWORD dwFlags)
{
	CNameTableEntry		*pHostPlayer;
	CNameTableEntry		*pAllPlayersGroup;
	DWORD				dwCurrentDevice;
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject;
	IDirectPlay8Address	*rgIDevice[MAX_HOST_ADDRESSES];
	DWORD				dwNumDeviceAddresses;
	DWORD				dwListensRunning;
	CConnection			*pConnection;
	CAsyncOp			*pListenParent;
	DWORD				dwEnumFrameSize;
	DWORD				dwListenFlags;
	DWORD				dwUpdateFlags;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdnAppDesc [0x%p], prgpDeviceInfo [0x%p], cDeviceInfo [%ld], pdnSecurity [0x%p], pdnCredentials [0x%p], dwFlags [0x%lx]",
		pInterface,pdnAppDesc,prgpDeviceInfo,cDeviceInfo,pdnSecurity,pdnCredentials,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateHost( pInterface, pdnAppDesc, prgpDeviceInfo, cDeviceInfo,
                                                      pdnSecurity, pdnCredentials, pvPlayerContext,
                                                      dwFlags ) ) )
    	{
    	    DPFERR( "Error validating host params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    // Check to ensure not already connected
    if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
    {
    	if( DN_CHECK_LOCALHOST( pdnObject ) )
    	{
    	    DPFERR("Object is already hosting" );
    	    DPF_RETURN(DPNERR_HOSTING);	
    	}
    	else
    	{
        	DPFERR("Object is already connected" );
            DPF_RETURN(DPNERR_ALREADYCONNECTED);
    	}
    }

#ifndef	DPNBUILD_NOPARAMVAL
	if((pdnObject->dwFlags & DN_OBJECT_FLAG_PEER) &&
       (pdnAppDesc->dwFlags & DPNSESSION_CLIENT_SERVER) )
    {
        DPFERR( "You cannot specify the clientserver flag in peer mode" );
        DPF_RETURN(DPNERR_INVALIDPARAM);
    }

#ifndef DPNBUILD_NOSERVER
	if((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER) &&
       !(pdnAppDesc->dwFlags & DPNSESSION_CLIENT_SERVER) )
    {
    	DPFERR( "You MUST specify the client/server flag for client/server mode" );
    	DPF_RETURN(DPNERR_INVALIDPARAM);
    }
#endif // !DPNBUILD_NOSERVER
#endif // !DPNBUILD_NOPARAMVAL

#ifdef	DIRECTPLAYDIRECTX9
		//ensure that both types of signing aren't specified
	if ((pdnAppDesc->dwFlags & DPNSESSION_FAST_SIGNED) && (pdnAppDesc->dwFlags & DPNSESSION_FULL_SIGNED))
	{
		DPFERR( "You cannot specify both fast and full signing" );
  	  	DPF_RETURN(DPNERR_INVALIDPARAM);
  	}
#endif	// DIRECTPLAYDIRECTX9

	dwNumDeviceAddresses = 0;
	pListenParent = NULL;
	pConnection = NULL;
	pHostPlayer = NULL;
	pAllPlayersGroup = NULL;

	//
	//	Flag as CONNECTING to prevent other operations here
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTING | DN_OBJECT_FLAG_CONNECTED))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_ALREADYCONNECTED;
		goto Failure;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTING;

	// Adding local host flag
	pdnObject->dwFlags |= DN_OBJECT_FLAG_LOCALHOST;
	
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	
	//
	//	Copy application description to DirectNet object
	//
	pdnObject->ApplicationDesc.Lock();
	hResultCode = pdnObject->ApplicationDesc.Update(pdnAppDesc,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA|DN_APPDESCINFO_FLAG_GUIDS);
	pdnObject->ApplicationDesc.Unlock();
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not update application description");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	// Create Instance GUID
	//
	if ((hResultCode = pdnObject->ApplicationDesc.CreateNewInstanceGuid()) != DPN_OK)
	{
		DPFERR("Could not create instance GUID - ignore and continue");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Set NameTable DPNID mask
	//
	DPFX(DPFPREP, 5,"DPNID Mask [0x%lx]",pdnObject->ApplicationDesc.GetDPNIDMask());
	pdnObject->NameTable.SetDPNIDMask( pdnObject->ApplicationDesc.GetDPNIDMask() );

	//
	// Create group "ALL PLAYERS"
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pAllPlayersGroup)) != DPN_OK)
	{
		DPFERR("Could not create NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAllPlayersGroup->MakeGroup();

	// This function takes the lock internally
	pdnObject->NameTable.MakeAllPlayersGroup(pAllPlayersGroup);

	//
	// Create local player
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pHostPlayer)) != DPN_OK)
	{
		DPFERR("Could not create NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// This function takes the lock internally
	pHostPlayer->UpdateEntryInfo(	pdnObject->NameTable.GetDefaultPlayer()->GetName(),
								pdnObject->NameTable.GetDefaultPlayer()->GetNameSize(),
								pdnObject->NameTable.GetDefaultPlayer()->GetData(),
								pdnObject->NameTable.GetDefaultPlayer()->GetDataSize(),
								DPNINFO_NAME|DPNINFO_DATA,
								FALSE);

	pHostPlayer->SetDNETVersion( DN_VERSION_CURRENT );

#ifndef DPNBUILD_NOSERVER
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
	{
		pHostPlayer->MakeServer();
	}
	else
#endif // !DPNBUILD_NOSERVER
	{
		DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_PEER);
		pHostPlayer->MakePeer();
	}

	pHostPlayer->SetContext(pvPlayerContext);
	pHostPlayer->StartConnecting();

	if ((hResultCode = pdnObject->NameTable.AddEntry(pHostPlayer)) != DPN_OK)
	{
		DPFERR("Could not add NameTableEntry to NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Create Host's connection (NULL end point)
	if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
	{
		DPFERR("Could not create new connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pConnection->SetStatus( CONNECTED );
	pConnection->MakeLocal();
	pConnection->SetEndPt(NULL);
	pConnection->SetDPNID(pHostPlayer->GetDPNID());

	pdnObject->NameTable.MakeLocalPlayer(pHostPlayer);
	pdnObject->NameTable.MakeHostPlayer(pHostPlayer);


	//
	//	Make ALL_PLAYERS group available (does not indicate anything to user).
	//
	pAllPlayersGroup->Lock();
	pAllPlayersGroup->MakeAvailable();
	pAllPlayersGroup->Unlock();
	pAllPlayersGroup->Release();
	pAllPlayersGroup = NULL;


	//
	// Don't notify user of CREATE_PLAYER yet in case starting listens fails.
	// This prevents them from having to handle CREATE_PLAYERs even in
	// the failure case.
	//
	
	//
	//	Start listens
	//

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_ONLYONEADAPTER)))
	if (cDeviceInfo == 0)
	{
		//
		//	Create a placeholder device address
		//
#ifdef DPNBUILD_LIBINTERFACE
		hResultCode = DP8ACF_CreateInstance(IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&rgIDevice[0]));
#else // ! DPNBUILD_LIBINTERFACE
		hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&rgIDevice[0]),
											FALSE);
#endif // ! DPNBUILD_LIBINTERFACE
		if (hResultCode != S_OK)
		{
			DPFERR("Could not create device address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		dwNumDeviceAddresses = 1;
	}
	else
#endif // DPNBUILD_ONLYONESP and DPNBUILD_ONLYONEADAPTER
	{
#ifdef DBG
		for (dwCurrentDevice = 0 ; dwCurrentDevice < cDeviceInfo ; dwCurrentDevice++)
		{
			DPFX(DPFPREP, 5,"Original Device: prgpDeviceInfo[%ld] [0x%p]",dwCurrentDevice,prgpDeviceInfo[dwCurrentDevice]);
		}
#endif // DBG

		// Duplicate address interfaces
		for (dwCurrentDevice = 0 ; dwCurrentDevice < cDeviceInfo ; dwCurrentDevice++)
		{
			if ((hResultCode = IDirectPlay8Address_Duplicate(prgpDeviceInfo[dwCurrentDevice],&rgIDevice[dwNumDeviceAddresses])) != DPN_OK)
			{
				DPFERR("Could not duplicate Host address info - skipping it");
				continue;
			}

			DPFX(DPFPREP, 5,"Duplicate Device: rgIDevice[%ld] [0x%p]",dwNumDeviceAddresses,rgIDevice[dwNumDeviceAddresses]);
			dwNumDeviceAddresses++;
		}
	}

	// Parent Async Op
	if ((hResultCode = AsyncOpNew(pdnObject,&pListenParent)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pListenParent->SetOpType( ASYNC_OP_LISTEN );
	pListenParent->MakeParent();
	pListenParent->SetCompletion( DNCompleteListen );

	dwListenFlags = 0;
#ifndef DPNBUILD_NOSPUI
	// Save query for addressing flag (if necessary)
	if (dwFlags & DPNHOST_OKTOQUERYFORADDRESSING)
	{
		dwListenFlags |= DN_LISTENFLAGS_OKTOQUERYFORADDRESSING;
	}
#endif // ! DPNBUILD_NOSPUI
	if (pdnObject->ApplicationDesc.GetReservedDataSize() > 0)
	{
		dwListenFlags |= DN_LISTENFLAGS_SESSIONDATA;
	}
#ifdef	DIRECTPLAYDIRECTX9
	// Disallow enums if required
	if (pdnAppDesc->dwFlags & DPNSESSION_NOENUMS)
	{
		dwListenFlags |= DN_LISTENFLAGS_DISALLOWENUMS;
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags |= DN_OBJECT_FLAG_DISALLOW_ENUMS;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}
	// turning signing on if required. N.B. We've already ensured that only one of these options is selected
	if (pdnAppDesc->dwFlags & DPNSESSION_FAST_SIGNED)
	{
		dwListenFlags|=DN_LISTENFLAGS_FASTSIGNED;
	}
	else if (pdnAppDesc->dwFlags & DPNSESSION_FULL_SIGNED)
	{
		dwListenFlags|=DN_LISTENFLAGS_FULLSIGNED;
	}
#endif	// DIRECTPLAYDIRECTX9
	pListenParent->SetOpFlags(dwListenFlags);

	// Children op's
	dwListensRunning = 0;
	for (dwCurrentDevice = 0 ; dwCurrentDevice < dwNumDeviceAddresses ; dwCurrentDevice++)
	{
		if (rgIDevice[dwCurrentDevice] != NULL)
		{
			hResultCode = DNPerformSPListen(pdnObject,
											rgIDevice[dwCurrentDevice],
											pListenParent,
											NULL);
			if (hResultCode == DPN_OK)
			{
				dwListensRunning++;
			}
		}
	}

	// Make sure at least 1 listen started
	if (dwListensRunning == 0)
	{
		DPFERR("Could not start any LISTENs");
		hResultCode = DPNERR_INVALIDDEVICEADDRESS;
		goto Failure;
	}

	// Store parent LISTEN on DirectNet object
	pListenParent->AddRef();
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->pListenParent = pListenParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pListenParent->Release();
	pListenParent = NULL;

	//
	//	Use cached max enum frame size
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	dwEnumFrameSize = pdnObject->dwMaxFrameSize;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	
	DNASSERT( dwEnumFrameSize >= (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO)) );
	if (dwEnumFrameSize < (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO) + pdnAppDesc->dwApplicationReservedDataSize))
	{
		DPFERR("Not enough room for the application reserved data");
		hResultCode = DPNERR_DATATOOLARGE;
		goto Failure;
	}

	//
	//	Register with DPNSVR
	//
	dwUpdateFlags = 0;
#ifndef DPNBUILD_SINGLEPROCESS
	if(pdnObject->ApplicationDesc.UseDPNSVR())
	{
		dwUpdateFlags |= DN_UPDATE_LISTEN_FLAG_DPNSVR;
	}
#endif // ! DPNBUILD_SINGLEPROCESS
	if (pdnObject->ApplicationDesc.DisallowEnums())
	{
		dwUpdateFlags |= DN_UPDATE_LISTEN_FLAG_DISALLOW_ENUMS;
	}
	if (dwUpdateFlags)
	{
		if ((hResultCode = DNUpdateListens(pdnObject,dwUpdateFlags)) != DPN_OK)
		{
			DPFERR("Could not update listens or register with DPNSVR");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	//
	//	Update DirectNet object to be connected
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING);
	pdnObject->dwFlags &= ~DN_OBJECT_FLAG_CONNECTING;
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

#ifndef DPNBUILD_NOLOBBY
	//
	//	Update Lobby status
	//
	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
#endif // ! DPNBUILD_NOLOBBY

	//
	// Now that Listens have been successfully started, indicate the local CREATE_PLAYER.
	//

	//
	//	One player in game (Local/Host player)
	//
	pdnObject->ApplicationDesc.IncPlayerCount(TRUE);

	//
	//	Populate local player's connection
	//
	pConnection->SetDPNID(pHostPlayer->GetDPNID());
	pdnObject->NameTable.PopulateConnection(pConnection);
	pConnection->Release();
	pConnection = NULL;

#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
	//
	//	Unload SP's
	//
	DN_SPReleaseAll(pdnObject);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP

	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	//
	//	Clean up copies of device address
	//
	for (dwCurrentDevice = 0 ; dwCurrentDevice < dwNumDeviceAddresses ; dwCurrentDevice++)
	{
		IDirectPlay8Address_Release(rgIDevice[dwCurrentDevice]);
		rgIDevice[dwCurrentDevice] = NULL;
	}

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pAllPlayersGroup)
	{
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;
	}
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pListenParent = pdnObject->pListenParent;
	pdnObject->pListenParent = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pListenParent)
	{
		DNCancelChildren(pdnObject,pListenParent);
		pListenParent->Release();
		pListenParent = NULL;
	}

	pdnObject->NameTable.EmptyTable(DPNERR_HOSTTERMINATEDSESSION);

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_LOCALHOST);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_CreateGroup"

STDMETHODIMP DN_CreateGroup(PVOID pInterface,
							const DPN_GROUP_INFO *const pdpnGroupInfo,
							void *const pvGroupContext,
							void *const pvAsyncContext,
							DPNHANDLE *const phAsyncHandle,
							const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdpnGroupInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,pdpnGroupInfo,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateCreateGroup( pInterface, pdpnGroupInfo, pvGroupContext,
    	                                                  pvAsyncContext,phAsyncHandle, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating create group params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to create a group" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }    	

	pLocalPlayer = NULL;

	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnGroupInfo->pwszName))
	{
		pwszName = pdpnGroupInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnGroupInfo->pvData) && (pdpnGroupInfo->dwDataSize))
	{
		pvData = pdpnGroupInfo->pvData;
		dwDataSize = pdpnGroupInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is creating group");
		hResultCode = DNHostCreateGroup(pdnObject,
										pwszName,
										dwNameSize,
										pvData,
										dwDataSize,
										pdpnGroupInfo->dwInfoFlags,
										pdpnGroupInfo->dwGroupFlags,
										pvGroupContext,
										pvAsyncContext,
										pLocalPlayer->GetDPNID(),
										0,
										&hAsyncOp,
										dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to create group");
		}
		else
		{
			if (!(dwFlags & DPNCREATEGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				CAsyncOp* pAsyncOp;
				if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOp, (PVOID*)&pAsyncOp )))
				{
					// Release the HandleTable reference
					pAsyncOp->Release();
					pAsyncOp = NULL;
				}
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to create group");

		hResultCode = DNRequestCreateGroup(	pdnObject,
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnGroupInfo->dwGroupFlags,
											pvGroupContext,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to create group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
			if (!(dwFlags & DPNCREATEGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_DestroyGroup"

STDMETHODIMP DN_DestroyGroup(PVOID pInterface,
							 const DPNID dpnidGroup,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dpnidGroup [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,dpnidGroup,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateDestroyGroup( pInterface, dpnidGroup, pvAsyncContext,
    	                                                  phAsyncHandle, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating destroy group params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to destroy a group" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Could not find specified group" );
		DisplayDNError(0,hResultCode);
		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;

	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is destroying group");
		hResultCode = DNHostDestroyGroup(	pdnObject,
											dpnidGroup,
											pvAsyncContext,
											pLocalPlayer->GetDPNID(),
											0,
											&hAsyncOp,
											dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to destroy group");
		}
		else
		{
			if (!(dwFlags & DPNDESTROYGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				CAsyncOp* pAsyncOp;
				if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOp, (PVOID*)&pAsyncOp )))
				{
					// Release the HandleTable reference
					pAsyncOp->Release();
					pAsyncOp = NULL;
				}
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to destroy group");

		hResultCode = DNRequestDestroyGroup(pdnObject,
											dpnidGroup,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to destroy group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
			if (!(dwFlags & DPNDESTROYGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_AddClientToGroup"

STDMETHODIMP DN_AddClientToGroup(PVOID pInterface,
								 const DPNID dpnidGroup,
								 const DPNID dpnidClient,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dpnidGroup [0x%lx], dpnidClient [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,dpnidGroup,dpnidClient,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateAddClientToGroup( pInterface, dpnidGroup, dpnidClient, pvAsyncContext,
    	                                                  phAsyncHandle, dwFlags ) ))
    	{
    	    DPFERR( "Error validating add client to group params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to add a player to a group" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }    	

	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
	{
        DPFERR( "Unable to find specified group" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Unable to specify client or all players group for group ID" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidClient,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Unable to find specified player" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if (pNTEntry->IsGroup())
	{
	    DPFERR( "Specified client is a group ID" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is adding player to group");
		hResultCode = DNHostAddPlayerToGroup(	pdnObject,
												dpnidGroup,
												dpnidClient,
												pvAsyncContext,
												pLocalPlayer->GetDPNID(),
												0,
												&hAsyncOp,
												dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to add player to group");
		}
		else
		{
			if (!(dwFlags & DPNADDPLAYERTOGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				CAsyncOp* pAsyncOp;
				if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOp, (PVOID*)&pAsyncOp )))
				{
					// Release the HandleTable reference
					pAsyncOp->Release();
					pAsyncOp = NULL;
				}
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to add player to group");

		hResultCode = DNRequestAddPlayerToGroup(pdnObject,
												dpnidGroup,
												dpnidClient,
												pvAsyncContext,
												&hAsyncOp,
												dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to add player to group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
			if (!(dwFlags & DPNADDPLAYERTOGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_RemoveClientFromGroup"

STDMETHODIMP DN_RemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dpnidGroup [0x%lx], dpnidClient [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,dpnidGroup,dpnidClient,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateRemoveClientFromGroup( pInterface, dpnidGroup, dpnidClient, pvAsyncContext, phAsyncHandle, dwFlags ) ))
    	{
    	    DPFERR( "Error validating remove client from group params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to remove a player from a group" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Could not find specified group in nametable" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Specified ID is not a valid group!" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidClient,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Specified client ID is not a valid client!" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if (pNTEntry->IsGroup())
	{
	    DPFERR( "Specified client ID is a group!" );	
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is deleting player from group");
		hResultCode = DNHostDeletePlayerFromGroup(	pdnObject,
													dpnidGroup,
													dpnidClient,
													pvAsyncContext,
													pLocalPlayer->GetDPNID(),
													0,
													&hAsyncOp,
													dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to delete player from group");
		}
		else
		{
			if (!(dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				CAsyncOp* pAsyncOp;
				if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOp, (PVOID*)&pAsyncOp )))
				{
					// Release the HandleTable reference
					pAsyncOp->Release();
					pAsyncOp = NULL;
				}
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to delete player from group");

		hResultCode = DNRequestDeletePlayerFromGroup(pdnObject,
													dpnidGroup,
													dpnidClient,
													pvAsyncContext,
													&hAsyncOp,
													dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to delete player from group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
			if (!(dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DN_SetGroupInfo

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetGroupInfo"

STDMETHODIMP DN_SetGroupInfo( PVOID pv,
							  const DPNID dpnid,
							  DPN_GROUP_INFO *const pdpnGroupInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pv [0x%p], dpnid [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pv,dpnid,pdpnGroupInfo,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateSetGroupInfo( pv, dpnid, pdpnGroupInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating set group info params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif	// DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to set group info" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	    	
	
	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Specified ID is not a group" );
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Specified ID is not a valid group" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnGroupInfo->pwszName))
	{
		pwszName = pdpnGroupInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnGroupInfo->pvData) && (pdpnGroupInfo->dwDataSize))
	{
		pvData = pdpnGroupInfo->pvData;
		dwDataSize = pdpnGroupInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is updating group info");
		hResultCode = DNHostUpdateInfo(	pdnObject,
										dpnid,
										pwszName,
										dwNameSize,
										pvData,
										dwDataSize,
										pdpnGroupInfo->dwInfoFlags,
										pvAsyncContext,
										pLocalPlayer->GetDPNID(),
										0,
										&hAsyncOp,
										dwFlags );
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to update info");
		}
		else
		{
			if (!(dwFlags & DPNSETGROUPINFO_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				// TODO: MASONB: Why does DNHostUpdateInfo do this?  This same code is duplicated
				// everywhere.
				CAsyncOp* pAsyncOp;
				if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOp, (PVOID*)&pAsyncOp )))
				{
					// Release the HandleTable reference
					pAsyncOp->Release();
					pAsyncOp = NULL;
				}
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to update group info");

		hResultCode = DNRequestUpdateInfo(	pdnObject,
											dpnid,
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnGroupInfo->dwInfoFlags,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to update info");
		}
		else
		{
			if (!(dwFlags & DPNSETGROUPINFO_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DN_GetGroupInfo
//
//	Retrieve group name and/or data from the local nametable.
//
//	lpwszGroupName may be NULL to avoid retrieving group name
//	pdwGroupFlags may be NULL to avoid retrieving group flags
//	pvGroupData may not by NULL if *pdwDataSize is non zero

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetGroupInfo"

STDMETHODIMP DN_GetGroupInfo(PVOID pv,
							 const DPNID dpnid,
							 DPN_GROUP_INFO *const pdpnGroupInfo,
							 DWORD *const pdwSize,
							 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	CPackedBuffer		packedBuffer;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters: dpnid [0x%lx], pdpnGroupInfo [0x%p], dwFlags [0x%lx]",
			dpnid,pdpnGroupInfo,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateGetGroupInfo( pv, dpnid, pdpnGroupInfo, pdwSize, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating get group info params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

	// Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING)) )
    {
    	DPFERR("You must be connected / hosting to get group info" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	    	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Specified group is not valid" );
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
	}
	packedBuffer.Initialize(pdpnGroupInfo,*pdwSize);

	pNTEntry->Lock();
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Specified ID is not a group" );
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	hResultCode = pNTEntry->PackInfo(&packedBuffer);

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumClientsAndGroups"

STDMETHODIMP DN_EnumClientsAndGroups(PVOID pInterface,
									 DPNID *const prgdpnid,
									 DWORD *const pcdpnid,
									 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CBilink				*pBilink;
	CNameTableEntry		*pNTEntry;
	DWORD				dwCount;
	DPNID				*pDPNID;
	BOOL				bEnum = TRUE;
	HRESULT             hResultCode;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], prgdpnid [0x%p], pcdpnid [0x%p], dwFlags [0x%lx]",
			pInterface,prgdpnid,pcdpnid,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateEnumClientsAndGroups( pInterface, prgdpnid, pcdpnid, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating enum clients and groups params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to enumerate players and groups" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	if (prgdpnid == NULL || *pcdpnid == 0)				// Don't enum if not asked to
	{
		bEnum = FALSE;
	}

	pdnObject->NameTable.ReadLock();

	dwCount = 0;
	pDPNID = prgdpnid;

	//
	//	Enum players
	//
	if (dwFlags & DPNENUM_PLAYERS)
	{
		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);

			pNTEntry->Lock();
			if (pNTEntry->IsAvailable())
			{
				dwCount++;
				if (bEnum && (dwCount <= *pcdpnid))
				{
					*pDPNID++ = pNTEntry->GetDPNID();
				}
				else
				{
					bEnum = FALSE;
				}
			}
			pNTEntry->Unlock();
			pBilink = pBilink->GetNext();
		}
	}

	//
	//	Enum groups
	//
	if (dwFlags & DPNENUM_GROUPS)
	{
		pBilink = pdnObject->NameTable.m_bilinkGroups.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);

			pNTEntry->Lock();
			if (pNTEntry->IsAvailable() && !pNTEntry->IsAllPlayersGroup())
			{
				dwCount++;
				if (bEnum && (dwCount <= *pcdpnid))
				{
					*pDPNID++ = pNTEntry->GetDPNID();
				}
				else
				{
					bEnum = FALSE;
				}
			}
			pNTEntry->Unlock();
			pBilink = pBilink->GetNext();
		}
	}

	pdnObject->NameTable.Unlock();

	//
	//	This will NOT include players/groups in the deleted list.
	//	i.e. removed from the NameTable but for whom DESTROY_PLAYER/GROUP notifications have yet to be posted
	//
	*pcdpnid = dwCount;
	if (!bEnum && dwCount)
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		hResultCode = DPN_OK;
	}

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumGroupMembers"

STDMETHODIMP DN_EnumGroupMembers(PVOID pInterface,
								 const DPNID dpnid,
								 DPNID *const prgdpnid,
								 DWORD *const pcdpnid,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	CGroupMember		*pGroupMember;
	CBilink				*pBilink;
	DWORD				dwCount;
	DPNID				*pDPNID;
	BOOL				bOutputBufferTooSmall = FALSE;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dpnid [0x%lx], prgdpnid [0x%p], pcdpnid [0x%p], dwFlags [0x%lx]",
			pInterface,dpnid,prgdpnid,pcdpnid,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateEnumGroupMembers( pInterface, dpnid, prgdpnid, pcdpnid, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating enum group params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to enumerate group members" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	pNTEntry = NULL;

	//
	// if the user didn't supply a buffer, assume that the
	// output buffer is too small
	//
	if ( ( prgdpnid == NULL ) || ( ( *pcdpnid ) == 0 ) )	
	{
		bOutputBufferTooSmall = TRUE;
	}

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}

	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
		DPFERR("Not a group dpnid!");
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	pNTEntry->Lock();

	dwCount = 0;
	pDPNID = prgdpnid;

	pBilink = pNTEntry->m_bilinkMembership.GetNext();
	while (pBilink != &pNTEntry->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		dwCount++;
		if ( ( bOutputBufferTooSmall == FALSE ) && (dwCount <= *pcdpnid))
		{
			*pDPNID++ = pGroupMember->GetPlayer()->GetDPNID();
		}
		else
		{
			bOutputBufferTooSmall = TRUE;
		}
		pBilink = pBilink->GetNext();
	}

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	*pcdpnid = dwCount;

	//
	// if the user's output buffer appears to be incapable receiving
	// output, double-check to make sure that the output size requirement
	// isn't zero (which is really OK), before telling them that the
	// output buffer is too small
	//
	if ( ( bOutputBufferTooSmall ) && ( dwCount != 0 ) )
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumHosts"

STDMETHODIMP DN_EnumHosts( PVOID pv,
						   DPN_APPLICATION_DESC *const pApplicationDesc,
                           IDirectPlay8Address *const pAddrHost,
						   IDirectPlay8Address *const pDeviceInfo,
						   PVOID const pUserEnumData,
						   const DWORD dwUserEnumDataSize,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   PVOID const pvAsyncContext,
						   DPNHANDLE *const pAsyncHandle,
						   const DWORD dwFlags )
{
	DIRECTNETOBJECT	*pdnObject;
	HRESULT		hResultCode;
	HRESULT		hrEnum;
#ifndef DPNBUILD_ONLYONESP
	GUID		guidSP;
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
	GUID		guidAdapter;
#endif // ! DPNBUILD_ONLYONEADAPTER
	CAsyncOp	*pParent;
	CAsyncOp	*pHandleParent;
	CSyncEvent	*pSyncEvent;
	CServiceProvider	*pSP;
	CRefCountBuffer		*pRCBuffer;
	DN_ENUM_QUERY_OP_DATA	*pEnumQueryOpData;
	IDirectPlay8Address	*pIHost;
	IDirectPlay8Address	*pIDevice;
	DPNHANDLE	handle;
	DPN_SP_CAPS	dnSPCaps;
#ifndef DPNBUILD_ONLYONEADAPTER
	BOOL		fEnumAdapters;
#endif // ! DPNBUILD_ONLYONEADAPTER
	BOOL		fHosting;
	DWORD		dwBufferCount;
	DWORD		dwEnumQueryFlags;
	DWORD		dwMultiplexFlag;
	GUID		guidnull;
#ifdef DBG
	TCHAR			DP8ABuffer[512] = {0};
	DWORD			DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 2,"Parameters: pApplicationDesc [0x%p], pAddrHost [0x%p], pDeviceInfo [0x%p], pUserEnumData [0x%p], dwUserEnumDataSize [%ld], dwRetryCount [%ld], dwRetryInterval [%ld], dwTimeOut [%ld], pvAsyncContext [0x%p], pAsyncHandle [0x%p], dwFlags [0x%lx]",
		pApplicationDesc,pAddrHost,pDeviceInfo,pUserEnumData,dwUserEnumDataSize,dwRetryCount,dwRetryInterval,dwTimeOut,pvAsyncContext,pAsyncHandle,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateEnumHosts( pv, pApplicationDesc, pAddrHost,
    	                                                pDeviceInfo, pUserEnumData, dwUserEnumDataSize,
    	                                                dwRetryCount, dwRetryInterval, dwTimeOut,
														pvAsyncContext, pAsyncHandle, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating enum hosts params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

	//
	// initialize
	//
	hResultCode = DPN_OK;
	pParent = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRCBuffer = NULL;
	pSP = NULL;
	pIHost = NULL;
	pIDevice = NULL;
	handle = 0;
	dwMultiplexFlag = 0;

#ifdef DBG
	if (pAddrHost)
	{
		DP8ASize = 512;
		IDirectPlay8Address_GetURL(pAddrHost,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 4,"Host address [%s]",DP8ABuffer);
	}

	if (pDeviceInfo)
	{
		DP8ASize = 512;
		IDirectPlay8Address_GetURL(pDeviceInfo,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 4,"Device address [%s]",DP8ABuffer);
	}
#endif // DBG

	//
	//	Cannot ENUM if Hosting - I have no idea why, but VanceO insisted on it
	//
	fHosting = FALSE;
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CONNECTING))
	{
		CNameTableEntry		*pLocalPlayer;

		pLocalPlayer = NULL;

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) == DPN_OK)
		{
			if (pLocalPlayer->IsHost())
			{
				fHosting = TRUE;
			}
			pLocalPlayer->Release();
			pLocalPlayer = NULL;
		}
	}
	else
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	if (fHosting)
	{
		hResultCode = DPNERR_HOSTING;
		goto Failure;
	}


#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_LIBINTERFACE)))
	DNASSERT(pdnObject->pOnlySP != NULL);
	pdnObject->pOnlySP->AddRef();
	pSP = pdnObject->pOnlySP;
#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_ONLYONESP
	//
	//	Extract SP guid as we will probably need it
	//
	hResultCode = IDirectPlay8Address_GetSP(pDeviceInfo,&guidSP);
	if ( hResultCode != DPN_OK)
	{
		DPFERR("SP not specified in Device address");
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONESP

	//
	//	Ensure SP specified in Device address is loaded
	//
	hResultCode = DN_SPEnsureLoaded(pdnObject,
#ifndef DPNBUILD_ONLYONESP
									&guidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
									NULL,
#endif // ! DPNBUILD_LIBINTERFACE
									&pSP);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not ensure SP is loaded!");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE

	//
	//	Get SP caps to ensure payload will fit
	//
	if ((hResultCode = DNGetActualSPCaps(pSP,&dnSPCaps)) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Ensure payload will fit
	//
	if (dwUserEnumDataSize > dnSPCaps.dwMaxEnumPayloadSize)
	{
		DPFERR("User enum data is too large");
		hResultCode = DPNERR_ENUMQUERYTOOLARGE;
		goto Failure;
	}

	//
	//	Duplicate addresses for local usage (so we can modify them if neccessary
	//
	if (pAddrHost)
	{
		// Use supplied Host address
		if ((hResultCode = IDirectPlay8Address_Duplicate(pAddrHost,&pIHost)) != DPN_OK)
		{
			DPFERR("Could not duplicate Host address");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDHOSTADDRESS;
			goto Failure;
		}
	}
	else
	{
		//
		//	Create new Host address and use Device SP guid
		//
#ifdef DPNBUILD_LIBINTERFACE
		hResultCode = DP8ACF_CreateInstance(IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pIHost));
#else // ! DPNBUILD_LIBINTERFACE
		hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pIHost),
											FALSE);
#endif // ! DPNBUILD_LIBINTERFACE
		if (hResultCode != S_OK)
		{
			DPFERR("Could not create Host address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

#ifndef DPNBUILD_ONLYONESP
		if ((hResultCode = IDirectPlay8Address_SetSP(pIHost,&guidSP)) != DPN_OK)
		{
			DPFERR("Could not set Host address SP");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
#endif // ! DPNBUILD_ONLYONESP
	}

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_ONLYONEADAPTER)))
	if (pDeviceInfo == NULL)
	{
		hResultCode = IDirectPlay8Address_Duplicate(pIHost,&pIDevice);
	}
	else
#endif // DPNBUILD_ONLYONESP and DPNBUILD_ONLYONEADAPTER
	{
		hResultCode = IDirectPlay8Address_Duplicate(pDeviceInfo,&pIDevice);
	}
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not duplicate Device address");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

#ifdef DBG
	DP8ASize = 512;
	IDirectPlay8Address_GetURL(pIHost,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 4,"Host address [%s]",DP8ABuffer);

	DP8ASize = 512;
	IDirectPlay8Address_GetURL(pIDevice,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 4,"Device address [%s]",DP8ABuffer);
#endif // DBG

	// Enum flags to Protocol
	dwEnumQueryFlags = 0;
#ifndef DPNBUILD_NOSPUI
	if (dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING)
	{
		dwEnumQueryFlags |= DN_ENUMQUERYFLAGS_OKTOQUERYFORADDRESSING;
	}
#endif // ! DPNBUILD_NOSPUI
	if (dwFlags & DPNENUMHOSTS_NOBROADCASTFALLBACK)
	{
		dwEnumQueryFlags |= DN_ENUMQUERYFLAGS_NOBROADCASTFALLBACK;
	}
	if (pApplicationDesc->dwReservedDataSize > 0)
	{
		dwEnumQueryFlags |= DN_ENUMQUERYFLAGS_SESSIONDATA;
	}

	//
	//	Parent for ENUMs
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pParent)) != DPN_OK)
	{
		DPFERR("Could not create ENUM parent AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pParent->MakeParent();
	pParent->SetOpType( ASYNC_OP_ENUM_QUERY );
	pParent->SetContext( pvAsyncContext );
	pParent->SetCompletion( DNCompleteEnumQuery );
	pParent->SetOpFlags( dwEnumQueryFlags );

	//
	//	Synchronous ?
	//
	if (dwFlags & DPNENUMHOSTS_SYNC)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not create SyncEvent");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pParent->SetSyncEvent( pSyncEvent );
		pParent->SetResultPointer( &hrEnum );
		hrEnum = DPNERR_GENERIC;
	}
	else
	{
		//
		//	Create Handle parent AsyncOp (if required)
		//
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pHandleParent->SetContext( pvAsyncContext );
		pHandleParent->Lock();
		if (pHandleParent->IsCancelled())
		{
			pHandleParent->Unlock();
			pParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pParent->MakeChild( pHandleParent );
		handle = pHandleParent->GetHandle();
		pHandleParent->Unlock();
	}

	//
	//	Keep SP on ENUM parent
	//
	pParent->SetSP( pSP );
	pSP->Release();
	pSP = NULL;

	pEnumQueryOpData = pParent->GetLocalEnumQueryOpData();
	
#ifndef DPNBUILD_ONLYONEADAPTER
	//
	//	If there is no adapter specified in the device address,
	//	we will attempt to enum on each individual adapter if the SP supports it
	//
	fEnumAdapters = FALSE;
	if ((hResultCode = IDirectPlay8Address_GetDevice( pIDevice, &guidAdapter )) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not determine adapter");
		DisplayDNError(1,hResultCode);

		if (dnSPCaps.dwFlags & DPNSPCAPS_SUPPORTSALLADAPTERS)
		{
			DPFX(DPFPREP, 3,"SP supports ENUMing on all adapters");
			fEnumAdapters = TRUE;
		}
	}

	if(fEnumAdapters)
	{
		DWORD	dwNumAdapters;
		GUID	*pAdapterList = NULL;

		if ((hResultCode = DNEnumAdapterGuids(	pdnObject,
#ifndef DPNBUILD_ONLYONESP
												&guidSP,
#endif // ! DPNBUILD_ONLYONESP
												0,
												&pAdapterList,
												&dwNumAdapters)) != DPN_OK)
		{
			DPFERR("Could not enum adapters for this SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		if (dwNumAdapters == 0)
		{
			DPFERR("No adapters were found for this SP");
			hResultCode = DPNERR_INVALIDDEVICEADDRESS;
			goto Failure;
		}

		pEnumQueryOpData->dwNumAdapters = dwNumAdapters;
		pEnumQueryOpData->dwCurrentAdapter = 0;

		if (dwNumAdapters > 1)
		{
			dwMultiplexFlag |= DN_ENUMQUERYFLAGS_ADDITIONALMULTIPLEXADAPTERS;
		}
		
		//
		//	Choose first adapter for initial ENUM call
		//
		if ((hResultCode = IDirectPlay8Address_SetDevice(pIDevice,pAdapterList)) != DPN_OK)
		{
			DPFERR("Could not set device adapter");
			DisplayDNError(0,hResultCode);
			MemoryBlockFree(pdnObject,pAdapterList);
			goto Failure;
		}
		pEnumQueryOpData->dwCurrentAdapter++;
		pParent->SetOpData( pAdapterList );
		pAdapterList = NULL;
	}
	else
#endif // ! DPNBUILD_ONLYONEADAPTER
	{
#ifndef DPNBUILD_ONLYONEADAPTER
		pEnumQueryOpData->dwNumAdapters = 0;
		pEnumQueryOpData->dwCurrentAdapter = 0;
#endif // ! DPNBUILD_ONLYONEADAPTER
	}

	//
	//	Set up EnumQuery BufferDescriptions
	//
	//
	// When filling out the enum structure the SP requires an extra BUFFERDESC
	// to exist immediately before the one were passing with the user data.  The
	// SP will be using that extra buffer to prepend an optional header
	//

	pEnumQueryOpData->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD].pBufferData = reinterpret_cast<BYTE*>(&pEnumQueryOpData->EnumQueryPayload);
	memset(&guidnull, 0, sizeof(guidnull));
	if (pApplicationDesc->guidApplication != guidnull)
	{
		DPFX(DPFPREP, 7, "Object 0x%p enumerating with application GUID {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}.",
			pdnObject,
			pApplicationDesc->guidApplication.Data1,
			pApplicationDesc->guidApplication.Data2,
			pApplicationDesc->guidApplication.Data3,
			pApplicationDesc->guidApplication.Data4[0],
			pApplicationDesc->guidApplication.Data4[1],
			pApplicationDesc->guidApplication.Data4[2],
			pApplicationDesc->guidApplication.Data4[3],
			pApplicationDesc->guidApplication.Data4[4],
			pApplicationDesc->guidApplication.Data4[5],
			pApplicationDesc->guidApplication.Data4[6],
			pApplicationDesc->guidApplication.Data4[7]);


		pEnumQueryOpData->EnumQueryPayload.QueryType = DN_ENUM_QUERY_WITH_APPLICATION_GUID;
		memcpy(&pEnumQueryOpData->EnumQueryPayload.guidApplication,&pApplicationDesc->guidApplication,sizeof(GUID));
		pEnumQueryOpData->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD].dwBufferSize = sizeof(DN_ENUM_QUERY_PAYLOAD);
	}
	else
	{
		pEnumQueryOpData->EnumQueryPayload.QueryType = DN_ENUM_QUERY_WITHOUT_APPLICATION_GUID;
		pEnumQueryOpData->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD].dwBufferSize = sizeof(DN_ENUM_QUERY_PAYLOAD) - sizeof(GUID);
	}

	//
	//	Copy user data (if any)
	//
	if (pUserEnumData && dwUserEnumDataSize)
	{
		DPFX(DPFPREP,3,"User enum data specified");
		if ((hResultCode = RefCountBufferNew(pdnObject,dwUserEnumDataSize,MemoryBlockAlloc,MemoryBlockFree,&pRCBuffer)) != DPN_OK)
		{
			DPFERR("Could not create RefCountBuffer");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		memcpy(pRCBuffer->GetBufferAddress(),pUserEnumData,dwUserEnumDataSize);
		pEnumQueryOpData->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].pBufferData = reinterpret_cast<BYTE*>(pRCBuffer->GetBufferAddress());
		pEnumQueryOpData->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].dwBufferSize = dwUserEnumDataSize;
		pParent->SetRefCountBuffer( pRCBuffer );
		dwBufferCount = DN_ENUM_BUFFERDESC_QUERY_COUNT;

		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	else
	{
		DPFX(DPFPREP,3,"User enum data not specified");
		pEnumQueryOpData->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].pBufferData = NULL;
		pEnumQueryOpData->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].dwBufferSize = 0;
		dwBufferCount = DN_ENUM_BUFFERDESC_QUERY_COUNT - 1;
	}


	//
	//	Set up EnumQuery misc fields
	//
	pEnumQueryOpData->dwRetryCount = dwRetryCount;
	pEnumQueryOpData->dwRetryInterval = dwRetryInterval;
	pEnumQueryOpData->dwTimeOut = dwTimeOut;
	pEnumQueryOpData->dwBufferCount = dwBufferCount;

	//
	// For reserved data we understand, we don't actually need all of the data we had the
	// user track.
	//
	if ((pApplicationDesc->dwReservedDataSize == DPN_MAX_APPDESC_RESERVEDDATA_SIZE) &&
		(*((DWORD*) pApplicationDesc->pvReservedData) == SPSESSIONDATAINFO_XNET))
	{
		pEnumQueryOpData->dwAppDescReservedDataSize = sizeof(SPSESSIONDATA_XNET);
		memcpy(pEnumQueryOpData->AppDescReservedData, &pApplicationDesc->pvReservedData, pEnumQueryOpData->dwAppDescReservedDataSize);
	}
	else
	{
		pEnumQueryOpData->dwAppDescReservedDataSize = 0;
	}

	DPFX(DPFPREP,3,"Number of buffers actually used [%ld]",dwBufferCount);
	hResultCode = DNPerformEnumQuery(	pdnObject,
										pIHost,
										pIDevice,
										pParent->GetSP()->GetHandle(),
										pParent->GetOpFlags() | dwMultiplexFlag,
										pParent->GetContext(),
										pParent );
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not start ENUM");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
											
	pParent->Release();
	pParent = NULL;

	//
	//	Wait for SyncEvent or return Async Handle
	//
	if (dwFlags & DPNENUMHOSTS_SYNC)
	{
		pSyncEvent->WaitForEvent();
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
		hResultCode = hrEnum;
	}
	else
	{
		//
		//	Blame vanceo if this EVER returns anything other than DPN_OK at this stage
		//
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->Release();
		pHandleParent = NULL;

		*pAsyncHandle = handle;
		hResultCode = DPNERR_PENDING;
	}

	IDirectPlay8Address_Release(pIDevice);
	pIDevice = NULL;

	IDirectPlay8Address_Release(pIHost);
	pIHost = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (handle != 0)
	{
		CAsyncOp* pAsyncOp;
		if (SUCCEEDED(pdnObject->HandleTable.Destroy( handle, (PVOID*)&pAsyncOp )))
		{
			// Release the HandleTable reference
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
		handle = 0;
	}
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pRCBuffer)
	{
		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pIHost)
	{
		IDirectPlay8Address_Release(pIHost);
		pIHost = NULL;
	}
	if (pIDevice)
	{
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}
	goto Exit;
}


//**********************************************************************



//	DN_DestroyPlayer
//
//	Remove a player from this DirectNet session
//	This will send a termination message to the player.
//	Both the host and the player will terminate.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_DestroyPlayer"

STDMETHODIMP DN_DestroyPlayer(PVOID pInterface,
							  const DPNID dpnid,
							  const void *const pvDestroyData,
							  const DWORD dwDestroyDataSize,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CNameTableEntry		*pNTEntry;
	CConnection			*pConnection;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pMsg;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], dpnid [0x%lx], pvDestroyData [0x%p], dwDestroyDataSize [%ld], dwFlags [0x%lx]",
			pInterface,dpnid,pvDestroyData,dwDestroyDataSize,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateDestroyPlayer( pInterface, dpnid, pvDestroyData, dwDestroyDataSize, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating destroy player params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to destroy a player" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pConnection = NULL;

	if (!DN_CHECK_LOCALHOST(pdnObject))
	{
	    DPFERR( "Object is not session host, cannot destroy players" );
		DPF_RETURN(DPNERR_NOTHOST);
	}

	// Ensure DNID specified is valid
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find player entry");
		DisplayDNError(0,hResultCode);
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if (pNTEntry->IsLocal() )
	{
		DPFERR( "Cannot destroy local player" );
		hResultCode = DPNERR_INVALIDPLAYER;		
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pNTEntry->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get connection ref");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Build terminate message
	//
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION) + dwDestroyDataSize,
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pRefCountBuffer->GetBufferAddress());
	if (dwDestroyDataSize)
	{
		memcpy(pMsg+1,pvDestroyData,dwDestroyDataSize);
		pMsg->dwTerminateDataOffset = sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION);
	}
	else
	{
		pMsg->dwTerminateDataOffset = 0;
	}
	pMsg->dwTerminateDataSize = dwDestroyDataSize;

	//
	//	Send message to player to exit
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_TERMINATE_SESSION,
								dpnid,
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send DESTROY_CLIENT message to player");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		if (hResultCode == DPNERR_INVALIDENDPOINT)
		{
			hResultCode = DPNERR_INVALIDPLAYER;
		}
		goto Failure;
	}

	pConnection->Release();
	pConnection = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Remove from NameTable and inform other players of disconnect
	//
	hResultCode = DNHostDisconnect(pdnObject,dpnid,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}



//	DN_ReturnBuffer
//
//	Return a receive buffer which is no longer in use

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ReturnBuffer"

STDMETHODIMP DN_ReturnBuffer(PVOID pv,
							 const DPNHANDLE hBufferHandle,
							 const DWORD dwFlags)
{
	DIRECTNETOBJECT	*pdnObject;
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;

	DPFX(DPFPREP, 2,"Parameters: hBufferHandle [0x%lx], dwFlags [0x%lx]",hBufferHandle,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateReturnBuffer( pv, hBufferHandle, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating return buffer params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to return a buffer" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	DNASSERT( pdnObject != NULL );

	pAsyncOp = NULL;

	//
	//	Find async op
	//
	pdnObject->HandleTable.Lock();
	if ((hResultCode = pdnObject->HandleTable.Find( hBufferHandle,(PVOID*)&pAsyncOp )) != DPN_OK)
	{
		pdnObject->HandleTable.Unlock();
		DPFERR("Could not find handle");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDHANDLE;
		goto Failure;
	}
	else
	{
		pAsyncOp->AddRef();
		pdnObject->HandleTable.Unlock();
	}

	//
	//	Ensure it's not already cancelled
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled() || pAsyncOp->IsComplete())
	{
		pAsyncOp->Unlock();
		hResultCode = DPNERR_INVALIDHANDLE;
		goto Failure;
	}
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	if (SUCCEEDED(pdnObject->HandleTable.Destroy( hBufferHandle, NULL )))
	{
		//
		//	Remove from active list
		//
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		// Release the HandleTable reference
		pAsyncOp->Release();
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DN_GetPlayerContext

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetPlayerContext"

STDMETHODIMP DN_GetPlayerContext(PVOID pv,
								 const DPNID dpnid,
								 PVOID *const ppvPlayerContext,
								 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	DIRECTNETOBJECT		*pdnObject;

	DPFX(DPFPREP, 2,"Parameters: pv [0x%p], dpnid [0x%lx], ppvPlayerContext [0x%p], dwFlags [0x%lx]",
			pv, dpnid,ppvPlayerContext,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateGetPlayerContext( pv, dpnid, ppvPlayerContext, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating getplayercontext params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    {
    	DPFERR("You must be connected / hosting to get player context" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve player entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}

	//
	//	Ensure this is not a group and that the player has been created
	//	There may be a period during which the player is "available" but the CREATE_PLAYER notification
	//	has not returned.  Return DPNERR_NOTREADY in this case.
	//
	pNTEntry->Lock();
	if (pNTEntry->IsGroup())
	{
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if (!pNTEntry->IsCreated())
	{
		if (pNTEntry->IsAvailable())
		{
			hResultCode = DPNERR_NOTREADY;
		}
		else
		{
			hResultCode = DPNERR_INVALIDPLAYER;
		}
		pNTEntry->Unlock();
		goto Failure;
	}

	*ppvPlayerContext = pNTEntry->GetContext();
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DN_GetGroupContext

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetGroupContext"

STDMETHODIMP DN_GetGroupContext(PVOID pv,
								const DPNID dpnid,
								PVOID *const ppvGroupContext,
								const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	DIRECTNETOBJECT		*pdnObject;

	DPFX(DPFPREP, 2,"Parameters: pv [0x%p], dpnid [0x%lx], ppvGroupContext [0x%p], dwFlags [0x%lx]",
			pv, dpnid,ppvGroupContext,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateGetGroupContext( pv, dpnid, ppvGroupContext,dwFlags ) ) )
    	{
    	    DPFERR( "Error validating getgroupcontext params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    {
    	DPFERR("You must be connected / hosting to get group context" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve group entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
	}

	//
	//	Ensure this is not a player and that the group has been created
	//	There may be a period during which the group is "available" but the CREATE_GROUP notification
	//	has not returned.  Return DPNERR_NOTREADY in this case.
	//
	pNTEntry->Lock();
	if (!pNTEntry->IsGroup())
	{
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (!pNTEntry->IsCreated())
	{
		if (pNTEntry->IsAvailable())
		{
			hResultCode = DPNERR_NOTREADY;
		}
		else
		{
			hResultCode = DPNERR_INVALIDGROUP;
		}
		pNTEntry->Unlock();
		goto Failure;
	}

	if( pNTEntry->IsAllPlayersGroup() )
	{
		pNTEntry->Unlock();
		DPFERR("Cannot getcontext for the all players group" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	*ppvGroupContext = pNTEntry->GetContext();
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_RegisterLobby"

STDMETHODIMP DN_RegisterLobby(PVOID pInterface,
							  const DPNHANDLE dpnhLobbyConnection, 
							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
							  const DWORD dwFlags)
{
#ifdef DPNBUILD_NOLOBBY
	DPFX(DPFPREP, 0, "RegisterLobby is not supported!");
	return DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_NOLOBBY
	DIRECTNETOBJECT		*pdnObject;
#ifndef	DPNBUILD_NOPARAMVAL
	HRESULT             hResultCode;
#endif // DPNBUILD_NOPARAMVAL

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pIDP8LobbiedApplication [0x%p], dwFlags [0x%lx]",
			pInterface,pIDP8LobbiedApplication,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateRegisterLobby( pInterface, dpnhLobbyConnection, pIDP8LobbiedApplication, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating register lobby params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	DNASSERT(pdnObject != NULL);

	if (dwFlags == DPNLOBBY_REGISTER)
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			return(DPNERR_ALREADYREGISTERED);
		}
				
		IDirectPlay8LobbiedApplication_AddRef(pIDP8LobbiedApplication);

		pdnObject->pIDP8LobbiedApplication = pIDP8LobbiedApplication;
		pdnObject->dpnhLobbyConnection = dpnhLobbyConnection;
		pdnObject->dwFlags |= DN_OBJECT_FLAG_LOBBY_AWARE;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}
	else
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			return(DPNERR_NOTREGISTERED);
		}
				
		IDirectPlay8LobbiedApplication_Release(pdnObject->pIDP8LobbiedApplication);
		pdnObject->dpnhLobbyConnection = NULL;
		pdnObject->pIDP8LobbiedApplication = NULL;
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LOBBY_AWARE);
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	return(DPN_OK);
#endif // ! DPNBUILD_NOLOBBY
}



#ifndef DPNBUILD_NOLOBBY

#undef DPF_MODNAME
#define DPF_MODNAME "DNNotifyLobbyClientOfSettings"
// 
// DNNotifyLobbyClientOfSettings
//
// This function sends a connection settings update to the lobby client informing it that the lobby 
// client settings have changed.  
//
HRESULT DNNotifyLobbyClientOfSettings(
	DIRECTNETOBJECT * const pdnObject,
	IDirectPlay8LobbiedApplication *pdpLobbiedApp, 
	DPNHANDLE dpnConnection, 
	IDirectPlay8Address *pHostAddress, 
	IDirectPlay8Address *pConnectFromAddress )
{
	HRESULT						hResultCode = DPN_OK;
	DPL_CONNECTION_SETTINGS		dplConnectionSettings;
	BOOL						fIsHost = FALSE;
	CPackedBuffer				packBuffer;
	PBYTE						pBuffer = NULL;
	BOOL						fINCriticalSection = FALSE;
	CNameTableEntry				*pNTEntry = NULL;
	DWORD						dwIndex;

	fIsHost = DN_CHECK_LOCALHOST( pdnObject );

	ZeroMemory( &dplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ) );
	dplConnectionSettings.dwSize = sizeof( DPL_CONNECTION_SETTINGS );
	dplConnectionSettings.dwFlags = (fIsHost) ? DPLCONNECTSETTINGS_HOST : 0;

	// Lock the object while we make a copy of the app desc.  
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	fINCriticalSection = TRUE;
	
	// Determine the size of buffer
	packBuffer.Initialize(NULL, 0 );
	hResultCode = pdnObject->ApplicationDesc.Pack(&packBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	if( hResultCode != DPNERR_BUFFERTOOSMALL ) 
	{
		DPFX(DPFPREP,  0, "Error getting app desc size hr=0x%x", hResultCode );
		goto NOTIFY_EXIT;
	}

	pBuffer = (BYTE*) DNMalloc(packBuffer.GetSizeRequired());

	if( !pBuffer )
	{
		DPFX(DPFPREP,  0, "Error allocating memory for buffer" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto NOTIFY_EXIT;
	}

	packBuffer.Initialize(pBuffer,packBuffer.GetSizeRequired());
	hResultCode = pdnObject->ApplicationDesc.Pack(&packBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Error packing app desc hr=0x%x", hResultCode );
		goto NOTIFY_EXIT;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	fINCriticalSection = FALSE;

	memcpy( &dplConnectionSettings.dpnAppDesc, pBuffer, sizeof( DPN_APPLICATION_DESC ) );

	hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry );

	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Error getting local player hr=0x%x", hResultCode );
		goto NOTIFY_EXIT;
	}

	// Make sure player name isn't changed while we are working with the entry
	pNTEntry->Lock();
	if( pNTEntry->GetName() )
	{
		dplConnectionSettings.pwszPlayerName = (WCHAR*) DNMalloc((wcslen(pNTEntry->GetName())+1)*sizeof(WCHAR));

		if( !dplConnectionSettings.pwszPlayerName )
		{
			pNTEntry->Unlock();
			DPFX(DPFPREP,  0, "Error allocating memory" );
			goto NOTIFY_EXIT;
		}
		
		wcscpy( dplConnectionSettings.pwszPlayerName, pNTEntry->GetName() );
	}
	else
	{
		dplConnectionSettings.pwszPlayerName = NULL;		
	}
	pNTEntry->Unlock();

	// Release our reference
	pNTEntry->Release();

	// Host address field
	if( fIsHost )
	{
		dplConnectionSettings.pdp8HostAddress = NULL;

		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );

		if( hResultCode != DPNERR_BUFFERTOOSMALL )
		{
			dplConnectionSettings.cNumDeviceAddresses = 0;
			DPFX(DPFPREP,  0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
			goto NOTIFY_EXIT;
		}

		dplConnectionSettings.ppdp8DeviceAddresses = (IDirectPlay8Address**) DNMalloc(dplConnectionSettings.cNumDeviceAddresses*sizeof(IDirectPlay8Address*));

		if( !dplConnectionSettings.ppdp8DeviceAddresses )
		{
			DPFX(DPFPREP,  0, "Error allocating memory" );
			dplConnectionSettings.cNumDeviceAddresses = 0;
			hResultCode = DPNERR_OUTOFMEMORY;
			goto NOTIFY_EXIT;
		}

		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );

		if( FAILED( hResultCode ) )
		{
			dplConnectionSettings.cNumDeviceAddresses = 0;
			DPFX(DPFPREP,  0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
			goto NOTIFY_EXIT;
		}
	}
	else
	{
		dplConnectionSettings.pdp8HostAddress = pHostAddress;
		dplConnectionSettings.ppdp8DeviceAddresses = &pConnectFromAddress;
		dplConnectionSettings.cNumDeviceAddresses = 1;	
	}

	// Update the settings
	hResultCode = IDirectPlay8LobbiedApplication_SetConnectionSettings( pdpLobbiedApp, dpnConnection, &dplConnectionSettings, 0 );

NOTIFY_EXIT:

	if( dplConnectionSettings.ppdp8DeviceAddresses && fIsHost )
	{
		for( dwIndex = 0; dwIndex < dplConnectionSettings.cNumDeviceAddresses; dwIndex++ )
		{
			IDirectPlay8Address_Release( dplConnectionSettings.ppdp8DeviceAddresses[dwIndex] );
		}

		DNFree(dplConnectionSettings.ppdp8DeviceAddresses);
	}

	if( dplConnectionSettings.pwszPlayerName )
		DNFree(dplConnectionSettings.pwszPlayerName);

	if( fINCriticalSection ) 
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if( pBuffer )
		DNFree(pBuffer);

	return hResultCode;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUpdateLobbyStatus"

HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
							const DWORD dwStatus)
{
	HRESULT		hResultCode;
	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
	DPNHANDLE dpnhLobbyConnection = NULL;
	IDirectPlay8Address *pHostAddress = NULL;
	IDirectPlay8Address *pConnectFromAddress = NULL;

	DPFX(DPFPREP, 4,"Parameters: dwStatus [0x%lx]",dwStatus);

	DNASSERT(pdnObject != NULL);

	pIDP8LobbiedApplication = NULL;

	//
	//	Get lobbied application interface, if it exists and other settings we need
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE) && (pdnObject->pIDP8LobbiedApplication))
	{
		IDirectPlay8LobbiedApplication_AddRef(pdnObject->pIDP8LobbiedApplication);
		pIDP8LobbiedApplication = pdnObject->pIDP8LobbiedApplication;
		dpnhLobbyConnection = pdnObject->dpnhLobbyConnection;

		pConnectFromAddress = pdnObject->pIDP8ADevice;
		pHostAddress = pdnObject->pConnectAddress;

		if( pConnectFromAddress )
		{
			IDirectPlay8Address_AddRef( pConnectFromAddress );			
		}

		if( pHostAddress )
		{
			IDirectPlay8Address_AddRef( pHostAddress );
		}
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Update status and release object
	//
	if (pIDP8LobbiedApplication)
	{
		// If we are about to do a connection notification
		// we send the updated connection settings.  
		// 
		// This gives lobby client full picture. 
		//
		if( dwStatus == DPLSESSION_CONNECTED )
		{
			DNNotifyLobbyClientOfSettings(pdnObject, pIDP8LobbiedApplication, dpnhLobbyConnection, pHostAddress, pConnectFromAddress );
		}

		IDirectPlay8LobbiedApplication_UpdateStatus(pIDP8LobbiedApplication,dpnhLobbyConnection,dwStatus,0);

		IDirectPlay8LobbiedApplication_Release(pIDP8LobbiedApplication);
		pIDP8LobbiedApplication = NULL;

		if( pHostAddress )
		{
			IDirectPlay8Address_Release( pHostAddress );
		}		

		if( pConnectFromAddress )
		{
			IDirectPlay8Address_Release( pConnectFromAddress );
		}
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

#endif // ! DPNBUILD_NOLOBBY

						
#undef DPF_MODNAME
#define DPF_MODNAME "DN_TerminateSession"

STDMETHODIMP DN_TerminateSession(PVOID pInterface,
								 void *const pvTerminateData,
								 const DWORD dwTerminateDataSize,
								 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pMsg;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pvTerminateData [0x%p], dwTerminateDataSize [%ld], dwFlags [0x%lx]",
			pInterface,pvTerminateData,dwTerminateDataSize,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateTerminateSession( pInterface, pvTerminateData, dwTerminateDataSize, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating terminatesession params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to terminate a session" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	if (!DN_CHECK_LOCALHOST(pdnObject))
	{
	    DPFERR( "Object is not session host, cannot destroy players" );
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}	

	//
	//	Build terminate message
	//
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION) + dwTerminateDataSize,
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pRefCountBuffer->GetBufferAddress());
	if (dwTerminateDataSize)
	{
		memcpy(pMsg+1,pvTerminateData,dwTerminateDataSize);
		pMsg->dwTerminateDataOffset = sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION);
	}
	else
	{
		pMsg->dwTerminateDataOffset = 0;
	}
	pMsg->dwTerminateDataSize = dwTerminateDataSize;

	//
	//	Worker job to send message to all players
	//
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not allocate new WorkerJob");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
	pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_TERMINATE_SESSION );
	pWorkerJob->SetSendNameTableOperationVersion( 0 );
	pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
	pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Terminate local session
	//
	hResultCode = DNUserTerminateSession(pdnObject,
										 DPNERR_HOSTTERMINATEDSESSION,
										 pvTerminateData,
										 dwTerminateDataSize);

	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not create WorkerJob");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pWorkerJob->SetJobType( WORKER_JOB_TERMINATE_SESSION );
	pWorkerJob->SetTerminateSessionReason( DPNERR_HOSTTERMINATEDSESSION );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}

//
//	FUnction that performs work for DN_GetHostAddress and for Lobby informs
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetHostAddressHelper"

HRESULT DNGetHostAddressHelper(DIRECTNETOBJECT *pdnObject, 
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress)
{
	CAsyncOp		*pListenParent;
	CAsyncOp		*pListenSP;
	CAsyncOp		*pListen;
	CBilink			*pBilinkSP;
	CBilink			*pBilink;
	DWORD			dwListenCount;
	CNameTableEntry			*pLocalPlayer;
	IDirectPlay8Address		**ppAddress;
	HRESULT hResultCode;

	pListenParent = NULL;
	pListenSP = NULL;
	pListen = NULL;	
	pLocalPlayer = NULL;
	
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (	!(pdnObject->dwFlags & DN_OBJECT_FLAG_LISTENING)
		||	!pLocalPlayer->IsHost()
		||	(pdnObject->pListenParent == NULL))

	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Not listening or Host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	pdnObject->pListenParent->AddRef();
	pListenParent = pdnObject->pListenParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Ensure that the address pointer buffer is large enough
	//
	dwListenCount = 0;
	pListenParent->Lock();	// Prevent changes while we run through
	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
	while (pBilinkSP != &pListenParent->m_bilinkParent)
	{
		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);

		pListenSP->Lock();

		pBilink = pListenSP->m_bilinkParent.GetNext();
		while (pBilink != &pListenSP->m_bilinkParent)
		{
			dwListenCount++;
			pBilink = pBilink->GetNext();
		}

		pListenSP->Unlock();
		pListenSP = NULL;

		pBilinkSP = pBilinkSP->GetNext();
	}

	if (dwListenCount > *pcAddress)
	{
		pListenParent->Unlock();
		*pcAddress = dwListenCount;
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Failure;
	}

	//
	//	Get addresses of LISTENs
	//

	ppAddress = prgpAddress;
	dwListenCount = 0;
	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
	while (pBilinkSP != &pListenParent->m_bilinkParent)
	{
		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);

		pListenSP->Lock();

		pBilink = pListenSP->m_bilinkParent.GetNext();
		while (pBilink != &pListenSP->m_bilinkParent)
		{
			pListen = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);

			if (pListen->GetProtocolHandle() != NULL)
			{
				SPGETADDRESSINFODATA	spInfoData;

				memset(&spInfoData,0x00,sizeof(SPGETADDRESSINFODATA));
				spInfoData.Flags = SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES;
				if ((hResultCode = DNPGetListenAddressInfo(pdnObject->pdnProtocolData,pListen->GetProtocolHandle(),&spInfoData)) != DPN_OK)
				{
					DPFERR("Could not get LISTEN address!");
					DisplayDNError(0,hResultCode);
					
					//
					// Release all the addresses we have so far.
					//
					while (dwListenCount > 0)
					{
						dwListenCount--;
						ppAddress--;
						IDirectPlay8Address_Release(*ppAddress);
						*ppAddress = NULL;
					}

					goto Failure;
				}
				*ppAddress++ = spInfoData.pAddress;
				dwListenCount++;
			}

			pBilink = pBilink->GetNext();
		}

		pListenSP->Unlock();
		pListenSP = NULL;

		pBilinkSP = pBilinkSP->GetNext();
	}
	pListenParent->Unlock();

	*pcAddress = dwListenCount;

	hResultCode = DPN_OK;

	pListenParent->Release();
	pListenParent = NULL;

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
	
}

//
//	DN_GetHostAddress
//
//	We will determine the host addresses by examining the LISTENs which are running.
//	We do this because after Host migration, we may not be running the same LISTEN
//	we started with.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetHostAddress"

STDMETHODIMP DN_GetHostAddress(PVOID pInterface,
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress,
							   const DWORD dwFlags)
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], prgpAddress [0x%p], pcAddress [0x%p], dwFlags [0x%lx]",
			pInterface,prgpAddress,pcAddress,dwFlags);

    pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateGetHostAddress( pInterface, prgpAddress, pcAddress, dwFlags ) ) )
    	{
    	    DPFERR( "Error validating gethostaddress params" );
    	    DPF_RETURN( hResultCode );
    	}
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    {
    	DPFERR("You must be connected / hosting to get host address" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	

	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	DNASSERT(pdnObject != NULL);

	// Actually do the work and get the addresses  
	hResultCode = DNGetHostAddressHelper( pdnObject, prgpAddress, pcAddress );

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUpdateListens"

HRESULT DNUpdateListens(DIRECTNETOBJECT *const pdnObject,
						const DWORD dwFlags)
{
	HRESULT		hResultCode;
	CAsyncOp	*pListenParent;

	DPFX(DPFPREP, 6,"Parameters: dwFlags [0x%u]", dwFlags);

	DNASSERT( pdnObject != NULL );
	DNASSERT( dwFlags != 0 );
	DNASSERT( ! ((dwFlags & DN_UPDATE_LISTEN_FLAG_ALLOW_ENUMS) && (dwFlags & DN_UPDATE_LISTEN_FLAG_DISALLOW_ENUMS)) );
	hResultCode = DPNERR_GENERIC;
	pListenParent = NULL;

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pListenParent)
	{
		pdnObject->pListenParent->AddRef();
		pListenParent = pdnObject->pListenParent;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pListenParent)
	{
		CBilink		*pBilinkSP;
		CBilink		*pBilink;
		CAsyncOp	*pListenSP;
		CAsyncOp	*pAsyncOp;
		CAsyncOp	**ListenList;
		DWORD		dwCount;
		DWORD		dwActual;

		dwCount = 0;
		dwActual = 0;
		ListenList = NULL;

		pListenParent->Lock();

		pBilinkSP = pListenParent->m_bilinkParent.GetNext();
		while (pBilinkSP != &pListenParent->m_bilinkParent)
		{
			pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);
			pListenSP->Lock();

			pBilink = pListenSP->m_bilinkParent.GetNext();
			while (pBilink != &pListenSP->m_bilinkParent)
			{
				dwCount++;
				pBilink = pBilink->GetNext();
			}
			pListenSP->Unlock();

			pBilinkSP = pBilinkSP->GetNext();
		}

		if (dwCount > 0)
		{
			if ((ListenList = static_cast<CAsyncOp**>(DNMalloc(dwCount*sizeof(CAsyncOp*)))) != NULL)
			{
				pBilinkSP = pListenParent->m_bilinkParent.GetNext();
				while (pBilinkSP != &pListenParent->m_bilinkParent)
				{
					pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);
					pListenSP->Lock();

					pBilink = pListenSP->m_bilinkParent.GetNext();
					while (pBilink != &pListenSP->m_bilinkParent)
					{
						pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
						pAsyncOp->AddRef();
						ListenList[dwActual] = pAsyncOp;

						dwActual++;
						if (dwActual > dwCount)
						{
							DNASSERT(FALSE);
							break;
						}
						pBilink = pBilink->GetNext();
					}
					pListenSP->Unlock();
					pBilinkSP = pBilinkSP->GetNext();
				}
			}
		}

		pListenParent->Unlock();

		if ((ListenList != NULL) && (dwActual > 0))
		{
			DWORD	dw;
			DWORD	dwUpdateFlags;
			HRESULT	hrRegister;

			dwUpdateFlags = 0;
			hrRegister = DPNERR_DPNSVRNOTAVAILABLE;
			if (dwFlags & DN_UPDATE_LISTEN_FLAG_HOST_MIGRATE)
			{
				dwUpdateFlags |= DN_UPDATELISTEN_HOSTMIGRATE;
			}
			if (dwFlags & DN_UPDATE_LISTEN_FLAG_ALLOW_ENUMS)
			{
				dwUpdateFlags |= DN_UPDATELISTEN_ALLOWENUMS;
			}
			if (dwFlags & DN_UPDATE_LISTEN_FLAG_DISALLOW_ENUMS)
			{
				dwUpdateFlags |= DN_UPDATELISTEN_DISALLOWENUMS;
			}

			for (dw = 0 ; dw < dwActual ; dw++)
			{
				if ((ListenList[dw]->GetResult() == DPN_OK) && (ListenList[dw]->GetProtocolHandle() != 0))
				{
					if (dwUpdateFlags)
					{
						if (DNPUpdateListen(pdnObject->pdnProtocolData,
											ListenList[dw]->GetProtocolHandle(),
											dwUpdateFlags) == DPN_OK)
						{
							hResultCode = DPN_OK;
						}
					}
#ifndef DPNBUILD_SINGLEPROCESS
					if (dwFlags & DN_UPDATE_LISTEN_FLAG_DPNSVR)
					{
						if (DNRegisterListenWithDPNSVR(pdnObject,ListenList[dw]) == DPN_OK)
						{
							hrRegister = DPN_OK;
						}
					}
#endif	// ! DPNBUILD_SINGLEPROCESS
				}

				ListenList[dw]->Release();
				ListenList[dw] = NULL;
			}

			if ((dwActual != 0) && (dwFlags & DN_UPDATE_LISTEN_FLAG_DPNSVR))
			{
				hResultCode = hrRegister;
			}
			DNFree(ListenList);
			ListenList = NULL;
		}

		pListenParent->Release();
		pListenParent = NULL;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#ifndef DPNBUILD_SINGLEPROCESS

#undef DPF_MODNAME
#define DPF_MODNAME "DNRegisterListenWithDPNSVR"

HRESULT DNRegisterListenWithDPNSVR(DIRECTNETOBJECT *const pdnObject,
								   CAsyncOp *const pListen)
{
	HRESULT	hResultCode;
	SPGETADDRESSINFODATA	spInfo;
	CAsyncOp			*pListenSP;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 6,"Parameters: pListen [0x%p]",pListen);

	pListenSP = NULL;
	pSP = NULL;

	pListen->Lock();
	if (pListen->GetParent() == NULL)
	{
		pListen->Unlock();
		DPFX(DPFPREP, 7,"No SP parent for listen async op");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}
	pListen->GetParent()->AddRef();
	pListenSP = pListen->GetParent();
	pListen->Unlock();
	pListenSP->Lock();
	if (pListenSP->GetSP() == NULL)
	{
		pListenSP->Unlock();
		DPFX(DPFPREP, 7,"No SP for listen SP async op");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}
	pListenSP->GetSP()->AddRef();
	pSP = pListenSP->GetSP();
	pListenSP->Unlock();

	pListenSP->Release();
	pListenSP = NULL;

	//
	//	Determine the address we're actually listening on
	//
	memset(&spInfo,0x00,sizeof(SPGETADDRESSINFODATA));
	spInfo.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;

	if ((hResultCode = DNPGetListenAddressInfo(pdnObject->pdnProtocolData, pListen->GetProtocolHandle(),&spInfo)) == DPN_OK)
	{
		DPN_SP_CAPS		dnSPCaps;

#ifdef DBG
		TCHAR	DP8ABuffer[512] = {0};
		DWORD	DP8ASize;
#endif // DBG

		DNASSERT(spInfo.pAddress != NULL);

#ifdef DBG
		DP8ASize = 512;
		IDirectPlay8Address_GetURL(spInfo.pAddress,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 7,"Listen address [%s]",DP8ABuffer);
#endif // DBG

		//
		//	Determine if the listen's SP supports DPNSVR
		//
		if ((hResultCode = DNGetActualSPCaps(pSP,&dnSPCaps)) == DPN_OK)
		{
			if (dnSPCaps.dwFlags & DPNSPCAPS_SUPPORTSDPNSRV)
			{
				DWORD	dwRetry;

				//
				//	We re-try the registration to catch the case where DPNSVR is shutting
				//	down while we are trying to register.  Unlikely but has to be handled.
				//
				for( dwRetry = 0; dwRetry < DPNSVR_REGISTER_ATTEMPTS ; dwRetry ++ )
				{
    				hResultCode = pdnObject->ApplicationDesc.RegisterWithDPNSVR( spInfo.pAddress );
					if (hResultCode == DPN_OK || hResultCode == DPNERR_ALREADYREGISTERED)
					{
						//
						//	Flag registering with DPNSVR for cleanup
						//
						DNEnterCriticalSection(&pdnObject->csDirectNetObject);
						pdnObject->dwFlags |= DN_OBJECT_FLAG_DPNSVR_REGISTERED;
						DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
						hResultCode = DPN_OK;
						break;
					}
					else
					{
    					if( dwRetry < DPNSVR_REGISTER_ATTEMPTS )
    					{
	    					DPFX(DPFPREP,  0, "Unable to register ourselves with DPNSVR hr=0x%x, retrying", hResultCode );    				
	    					Sleep( DPNSVR_REGISTER_SLEEP );    				
	    				}
						else
    					{
	    					DPFX(DPFPREP,  0, "Unable to register ourselves with DPNSVR hr=0x%x", hResultCode );
	    				}
	    			}
				}
			}
		}

		IDirectPlay8Address_Release(spInfo.pAddress);
		spInfo.pAddress = NULL;
	}

	pSP->Release();
	pSP = NULL;

Exit:
	DNASSERT( pListenSP == NULL );
	DNASSERT( pSP == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pListenSP)
	{
		pListenSP->Release();
		pListenSP = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}

#endif // ! DPNBUILD_SINGLEPROCESS


#undef DPF_MODNAME
#define DPF_MODNAME "DNAddRefLock"

HRESULT DNAddRefLock(DIRECTNETOBJECT *const pdnObject)
{
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING)) ||
			!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		return(DPNERR_ALREADYCLOSING);
	}
	pdnObject->dwLockCount++;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNDecRefLock"

void DNDecRefLock(DIRECTNETOBJECT *const pdnObject)
{
	BOOL	fSetEvent;

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwLockCount--;
	if ((pdnObject->dwLockCount == 0) && (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
	{
		fSetEvent = TRUE;
	}
	else
	{
		fSetEvent = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (fSetEvent)
	{
		DNSetEvent(pdnObject->hLockEvent);
	}
}


#ifndef	DPNBUILD_NONSEQUENTIALWORKERQUEUE
#undef DPF_MODNAME
#define DPF_MODNAME "DNThreadPoolAddRef"

void DNThreadPoolAddRef(DIRECTNETOBJECT *const pdnObject)
{
	LONG	lRefCount;

	DNASSERT(pdnObject->lThreadPoolRefCount >= 0);
	lRefCount = DNInterlockedIncrement( (LONG*)&pdnObject->lThreadPoolRefCount );
	DPFX(DPFPREP, 9, "Thread pool refcount = %i", lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNThreadPoolRelease"

void DNThreadPoolRelease(DIRECTNETOBJECT *const pdnObject)
{
	LONG	lRefCount;

	DNASSERT(pdnObject->lThreadPoolRefCount > 0);
	lRefCount = DNInterlockedDecrement( (LONG*)&pdnObject->lThreadPoolRefCount );

	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 9, "Thread pool refcount = 0, setting shut down event");
		DNASSERT( pdnObject->ThreadPoolShutDownEvent );
		pdnObject->ThreadPoolShutDownEvent->Set();
	}
	else
	{
		DPFX(DPFPREP, 9, "Thread pool refcount = %i", lRefCount);
	}
}
#endif	// DPNBUILD_NONSEQUENTIALWORKERQUEUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\common.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Common.h
 *  Content:    DirectNet common code header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	10/08/99	jtk		Created
 *	01/14/00	mjn		Added pvUserContext to DN_Host
 *	01/23/00	mjn		Added DN_DestroyPlayer and DNTerminateSession
 *	01/28/00	mjn		Added DN_ReturnBuffer
 *	02/01/00	mjn		Added DN_GetCaps, DN_SetCaps
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *	02/17/00	mjn		Reordered parameters in EnumServiceProviders,EnumHosts,Connect,Host
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *  03/17/00    rmt     Moved caps funcs to caps.h/caps.cpp
 *	04/06/00	mjn		Added DN_GetHostAddress()
 *	04/19/00	mjn		Changed DN_SendTo to accept a range of DPN_BUFFER_DESCs and a count
 *	06/23/00	mjn		Removed dwPriority from DN_SendTo()
 *	06/25/00	mjn		Added DNUpdateLobbyStatus()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *	07/30/00	mjn		Added hrReason to DNTerminateSession()
 *	08/15/00	mjn		Added hProtocol tp DNRegisterWithDPNSVR()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__COMMON_H__
#define	__COMMON_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_UPDATE_LISTEN_FLAG_DPNSVR			0x0001
#define	DN_UPDATE_LISTEN_FLAG_HOST_MIGRATE		0x0002
#define	DN_UPDATE_LISTEN_FLAG_ALLOW_ENUMS		0x0004
#define	DN_UPDATE_LISTEN_FLAG_DISALLOW_ENUMS	0x0008

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	struct	_PROTOCOL_ENUM_DATA PROTOCOL_ENUM_DATA;

typedef	struct	_PROTOCOL_ENUM_RESPONSE_DATA PROTOCOL_ENUM_RESPONSE_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

STDMETHODIMP DN_Initialize(PVOID pInterface,
						   PVOID const pvUserContext,
						   const PFNDPNMESSAGEHANDLER pfn,
						   const DWORD dwFlags);

STDMETHODIMP DN_Close(PVOID pInterface,
					  const DWORD dwFlags);

STDMETHODIMP DN_EnumServiceProviders( PVOID pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidApplication,
									  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
									  DWORD *const pcbEnumData,
									  DWORD *const pcReturned,
									  const DWORD dwFlags );

STDMETHODIMP DN_CancelAsyncOperation(PVOID pvInterface,
									 const DPNHANDLE hAsyncOp,
									 const DWORD dwFlags);

STDMETHODIMP DN_Connect( PVOID pInterface,
						 const DPN_APPLICATION_DESC *const pdnAppDesc,
						 IDirectPlay8Address *const pHostAddr,
						 IDirectPlay8Address *const pDeviceInfo,
						 const DPN_SECURITY_DESC *const pdnSecurity,
						 const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						 const void *const pvUserConnectData,
						 const DWORD dwUserConnectDataSize,
						 void *const pvPlayerContext,
						 void *const pvAsyncContext,
						 DPNHANDLE *const phAsyncHandle,
						 const DWORD dwFlags);

STDMETHODIMP DN_GetSendQueueInfo(PVOID pInterface,
								 const DPNID dpnid,
								 DWORD *const pdwNumMsgs,
								 DWORD *const pdwNumBytes,
								 const DWORD dwFlags);

STDMETHODIMP DN_GetApplicationDesc(PVOID pInterface,
								   DPN_APPLICATION_DESC *const pAppDescBuffer,
								   DWORD *const pcbDataSize,
								   const DWORD dwFlags);

STDMETHODIMP DN_SetApplicationDesc(PVOID pInterface,
								   const DPN_APPLICATION_DESC *const pdnApplicationDesc,
								   const DWORD dwFlags);

STDMETHODIMP DN_SendTo( PVOID pv,
						const DPNID dpnid,
						const DPN_BUFFER_DESC *const prgBufferDesc,
						const DWORD cBufferDesc,
						const DWORD dwTimeOut,
						void *const pvAsyncContext,
						DPNHANDLE *const phAsyncHandle,
						const DWORD dwFlags);

STDMETHODIMP DN_Host( PVOID pInterface,
					  const DPN_APPLICATION_DESC *const pdnAppDesc,
					  IDirectPlay8Address **const prgpDeviceInfo,
					  const DWORD cDeviceInfo,
					  const DPN_SECURITY_DESC *const pdnSecurity,
					  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
					  void *const pvPlayerContext,
					  const DWORD dwFlags);

STDMETHODIMP DN_CreateGroup(PVOID pInterface,
							const DPN_GROUP_INFO *const pdpnGroupInfo,
							void *const pvGroupContext,
							void *const pvAsyncContext,
							DPNHANDLE *const phAsyncHandle,
							const DWORD dwFlags);

STDMETHODIMP DN_DestroyGroup(PVOID pInterface,
							 const DPNID dpnidGroup,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags);

STDMETHODIMP DN_AddClientToGroup(PVOID pInterface,
								 const DPNID dpnidGroup,
								 const DPNID dpnidClient,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags);

STDMETHODIMP DN_RemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags);

STDMETHODIMP DN_SetGroupInfo( PVOID pv,
							  const DPNID dpnid,
							  DPN_GROUP_INFO *const pdpnGroupInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetGroupInfo(PVOID pv,
							 const DPNID dpnid,
							 DPN_GROUP_INFO *const pdpnGroupInfo,
							 DWORD *const pdwSize,
							 const DWORD dwFlags);

STDMETHODIMP DN_EnumClientsAndGroups(LPVOID lpv, DPNID *const lprgdpnid, DWORD *const lpcdpnid, const DWORD dwFlags);
STDMETHODIMP DN_EnumGroupMembers(LPVOID lpv,DPNID dpnid, DPNID *const lprgdpnid, DWORD *const lpcdpnid, const DWORD dwFlags);

STDMETHODIMP DN_EnumHosts( PVOID pv,
						   DPN_APPLICATION_DESC *const pApplicationDesc,
                           IDirectPlay8Address *const pAddrHost,
						   IDirectPlay8Address *const pDeviceInfo,
						   PVOID const pUserEnumData,
						   const DWORD dwUserEnumDataSize,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   PVOID const pvUserContext,
						   DPNHANDLE *const pAsyncHandle,
						   const DWORD dwFlags );

STDMETHODIMP DN_DestroyPlayer(PVOID pv,
							  const DPNID dnid,
							  const void *const pvDestroyData,
							  const DWORD dwDestroyDataSize,
							  const DWORD dwFlags);

STDMETHODIMP DN_ReturnBuffer(PVOID pv,
							 const DPNHANDLE hBufferHandle,
							 const DWORD dwFlags);

STDMETHODIMP DN_GetPlayerContext(PVOID pv,
								 const DPNID dpnid,
								 PVOID *const ppvPlayerContext,
								 const DWORD dwFlags);

STDMETHODIMP DN_GetGroupContext(PVOID pv,
								const DPNID dpnid,
								PVOID *const ppvGroupContext,
								const DWORD dwFlags);

HRESULT DNTerminateSession(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hrReason);

STDMETHODIMP DN_RegisterLobby(PVOID pInterface,
							  const DPNHANDLE dpnhLobbyConnection, 
							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
							  const DWORD dwFlags);

#ifndef DPNBUILD_NOLOBBY
HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
							const DWORD dwStatus);
#endif // ! DPNBUILD_NOLOBBY

STDMETHODIMP DN_TerminateSession(PVOID pInterface,
								 void *const pvTerminateData,
								 const DWORD dwTerminateDataSize,
								 const DWORD dwFlags);

STDMETHODIMP DN_GetHostAddress(PVOID pInterface,
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress,
							   const DWORD dwFlags);

HRESULT DNUpdateListens(DIRECTNETOBJECT *const pdnObject,
						const DWORD dwFlags);

#ifndef DPNBUILD_SINGLEPROCESS

HRESULT DNRegisterListenWithDPNSVR(DIRECTNETOBJECT *const pdnObject,
								   CAsyncOp *const pListen);

#endif // ! DPNBUILD_SINGLEPROCESS

HRESULT DNAddRefLock(DIRECTNETOBJECT *const pdnObject);

void DNDecRefLock(DIRECTNETOBJECT *const pdnObject);

#endif	// __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\connection.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       connection.cpp
 *  Content:    Connection routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/13/99	mjn		Created
 *	03/02/00	mjn		Conversion to class 
 *	04/08/00	mjn		Added ServiceProvider to Connection object
 *				mjn		Disconnect uses new CAsyncOp class
 *	04/18/00	mjn		CConnection tracks connection status better
 *	04/21/00	mjn		Disconnection through DNPerformDisconnect
 *	07/20/00	mjn		Changed Release() behaviour and beefed up Disconnect()
 *	07/28/00	mjn		Added m_bilinkConnections to CConnection
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	02/12/01	mjn		Fixed CConnection::GetEndPt() to track calling thread and added ReleaseEndPt()
 *	04/04/01	mjn		CConnection list off DirectNetObject guarded by proper critical section
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	CConnection::ReturnSelfToPool
//
//	Return object to FPM

#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::ReturnSelfToPool"

void CConnection::ReturnSelfToPool( void )
{
	DPFX(DPFPREP, 8,"Parameters: (none)");

	g_ConnectionPool.Release( this );

	DPFX(DPFPREP, 8,"Returning");
};



#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::Release"

void CConnection::Release(void)
{
	LONG	lRefCount;

	DPFX(DPFPREP, 8,"Parameters: (none)");

	DNASSERT(m_lRefCount > 0);
	lRefCount = DNInterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
	DPFX(DPFPREP, 3,"Connection::Release [0x%p] RefCount [0x%lx]",this,lRefCount);

	if (lRefCount == 0)
	{
		//
		//	Remove from the bilink of outstanding CConnection objects
		//
		DNEnterCriticalSection(&m_pdnObject->csConnectionList);
		m_bilinkConnections.RemoveFromList();
		DNLeaveCriticalSection(&m_pdnObject->csConnectionList);

		if (m_pSP)
		{
			m_pSP->Release();
			m_pSP = NULL;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		m_hEndPt = NULL;
		ReturnSelfToPool();
	}

	DPFX(DPFPREP, 8,"Returning");
};


#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::GetEndPt"

HRESULT CConnection::GetEndPt(HANDLE *const phEndPt,CCallbackThread *const pCallbackThread)
{
	HRESULT		hResultCode;

	DNASSERT(phEndPt != NULL);
	DNASSERT(pCallbackThread != NULL);

	Lock();
	if ((m_Status == CONNECTED) || (m_Status == CONNECTING))
	{
		//
		//	Add the calling thread to the bilink to that the endpoint will
		//	not be invalidated (through IndicateConnectionTerminated) until
		//	this thread is done with the endpoint.
		//
		pCallbackThread->GetCallbackThreadsBilink()->InsertBefore(&m_bilinkCallbackThreads);
		*phEndPt = m_hEndPt;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_NOCONNECTION;
	}
	Unlock();

	return(hResultCode);
};


#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::ReleaseEndPt"

void CConnection::ReleaseEndPt(CCallbackThread *const pCallbackThread)
{
	DNASSERT(pCallbackThread != NULL);

	Lock();
	pCallbackThread->GetCallbackThreadsBilink()->RemoveFromList();
	if (m_dwThreadCount != 0)
	{
		//
		//	If there is a thread count,
		//		decrement it
		//		if this is the last count
		//			set the event
		//
		m_dwThreadCount--;
		if (m_dwThreadCount == 0)
		{
			DNASSERT(m_pThreadEvent != NULL);
			if (m_pThreadEvent)
			{
				m_pThreadEvent->Set();
			}
		}
	}
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::SetSP"

void CConnection::SetSP( CServiceProvider *const pSP )
{
	DPFX(DPFPREP, 8,"Parameters: pSP [0x%p]",pSP);

	DNASSERT( pSP != NULL );

	pSP->AddRef();
	m_pSP = pSP;

	DPFX(DPFPREP, 8,"Returning");
}



//	CConnection::Disconnect
//
//	Initiate a disconnection.  If this is successful, eventually we will receive an IndicateConnectionTerminated
//	which we should use to remove a reference (from the Protocol).

#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::Disconnect"

void CConnection::Disconnect( void )
{
	BOOL		fDisconnect;

	DPFX(DPFPREP, 8,"Parameters: (none)");

	DNASSERT(m_pdnObject != NULL);

	fDisconnect = FALSE;
	Lock();
	if ((m_Status == CONNECTING) || (m_Status == CONNECTED))
	{
		if (m_hEndPt != NULL)
		{
			m_Status = DISCONNECTING;
			fDisconnect = TRUE;
		}
		else
		{
			m_Status = INVALID;
		}
	}
	Unlock();

	if (fDisconnect)
	{
#ifndef	DPNBUILD_NOMULTICAST
		if (m_dwFlags & CONNECTION_FLAG_MULTICAST_RECEIVER)
		{
			DNUserDestroySenderContext(m_pdnObject,m_pvContext);
		}
#endif	// DPNBUILD_NOMULTICAST
		DNPerformDisconnect(m_pdnObject,this,m_hEndPt,FALSE);
	}

	DPFX(DPFPREP, 8,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\connection.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connection.h
 *  Content:    Connection Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/29/00	mjn		Created
 *	04/08/00	mjn		Added ServiceProvider to Connection object
 *	04/18/00	mjn		CConnection tracks connection status better
 *	06/22/00	mjn		Replaced MakeConnecting(), MakeConnected(), MakeDisconnecting(), MakeInvalid() with SetStatus()
 *	07/20/00	mjn		Modified CConnection::Disconnect()
 *	07/28/00	mjn		Added send queue info structures
 *				mjn		Added m_bilinkConnections to CConnection
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/09/00	mjn		Added m_bilinkIndicated to CConnection
 *	02/12/01	mjn		Added m_bilinkCallbackThreads,m_dwThreadCount,m_pThreadEvent to track threads using m_hEndPt
 *	05/17/01	mjn		Remove unused flags
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CONNECTION_H__
#define	__CONNECTION_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CONNECTION_FLAG_LOCAL				0x00000001
#ifndef	DPNBUILD_NOMULTICAST
#define	CONNECTION_FLAG_MULTICAST_SENDER	0x00000010
#define	CONNECTION_FLAG_MULTICAST_RECEIVER	0x00000020
#endif	// DPNBUILD_NOMULTICAST

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef enum 
{
	INVALID,
	CONNECTING,
	CONNECTED,
	DISCONNECTING
} CONNECTION_STATUS;

typedef struct _USER_SEND_QUEUE_INFO
{
	DWORD	dwNumOutstanding;
	DWORD	dwBytesOutstanding;
} USER_SEND_QUEUE_INFO;

class CCallbackThread;
class CServiceProvider;
class CSyncEvent;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for RefCount buffer

class CConnection
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CConnection* pConnection = (CConnection*)pvItem;

			pConnection->m_Sig[0] = 'C';
			pConnection->m_Sig[1] = 'O';
			pConnection->m_Sig[2] = 'N';
			pConnection->m_Sig[3] = 'N';

			if (!DNInitializeCriticalSection(&pConnection->m_cs))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&pConnection->m_cs,0);

			pConnection->m_bilinkConnections.Initialize();
			pConnection->m_bilinkIndicated.Initialize();
			pConnection->m_bilinkCallbackThreads.Initialize();
#ifndef DPNBUILD_NOMULTICAST
			pConnection->m_bilinkMulticast.Initialize();
#endif // ! DPNBUILD_NOMULTICAST

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CConnection* pConnection = (CConnection*)pvItem;

			pConnection->m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			pConnection->m_dwFlags = 0;
			pConnection->m_lRefCount = 1;
			pConnection->m_hEndPt = NULL;
			pConnection->m_dpnid = 0;
			pConnection->m_pvContext = NULL;
			pConnection->m_pSP = NULL;
			pConnection->m_Status = INVALID;
			pConnection->m_dwThreadCount = 0;
			pConnection->m_pThreadEvent = NULL;

			//
			//	Queue info
			//
			pConnection->m_QueueInfoHigh.dwNumOutstanding = 0;
			pConnection->m_QueueInfoHigh.dwBytesOutstanding = 0;
			pConnection->m_QueueInfoNormal.dwNumOutstanding = 0;
			pConnection->m_QueueInfoNormal.dwBytesOutstanding = 0;
			pConnection->m_QueueInfoLow.dwNumOutstanding = 0;
			pConnection->m_QueueInfoLow.dwBytesOutstanding = 0;

			DNASSERT(pConnection->m_bilinkConnections.IsEmpty());
			DNASSERT(pConnection->m_bilinkIndicated.IsEmpty());
			DNASSERT(pConnection->m_bilinkCallbackThreads.IsEmpty());
#ifndef DPNBUILD_NOMULTICAST
			DNASSERT(pConnection->m_bilinkMulticast.IsEmpty());
#endif // ! DPNBUILD_NOMULTICAST
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::FPMRelease"
	static void FPMRelease( void* pvItem ) 
		{ 
			const CConnection* pConnection = (CConnection*)pvItem;

			DNASSERT(pConnection->m_bilinkConnections.IsEmpty());
			DNASSERT(pConnection->m_bilinkIndicated.IsEmpty());
			DNASSERT(pConnection->m_bilinkCallbackThreads.IsEmpty());
#ifndef DPNBUILD_NOMULTICAST
			DNASSERT(pConnection->m_bilinkMulticast.IsEmpty());
#endif // ! DPNBUILD_NOMULTICAST
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::FPMDealloc"
	static void FPMDealloc( void* pvItem )
		{
			CConnection* pConnection = (CConnection*)pvItem;

			DNDeleteCriticalSection(&pConnection->m_cs);
		};

	void CConnection::ReturnSelfToPool( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::AddRef"
	void AddRef(void)
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			lRefCount = DNInterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPFX(DPFPREP, 3,"Connection::AddRef [0x%p] RefCount [0x%lx]",this,lRefCount);
		};

	void CConnection::Release(void);

	void Lock( void )
		{
			DNEnterCriticalSection( &m_cs );
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection( &m_cs );
		};

	void SetEndPt(const HANDLE hEndPt)
		{
			m_hEndPt = hEndPt;
		};

	HRESULT CConnection::GetEndPt(HANDLE *const phEndPt,CCallbackThread *const pCallbackThread);

	void CConnection::ReleaseEndPt(CCallbackThread *const pCallbackThread);

	void SetStatus( const CONNECTION_STATUS status )
		{
			m_Status = status;
		};

	BOOL IsConnecting( void ) const
		{
			if (m_Status == CONNECTING)
				return( TRUE );

			return( FALSE );
		};

	BOOL IsConnected( void ) const
		{
			if (m_Status == CONNECTED)
				return( TRUE );

			return( FALSE );
		};

	BOOL IsDisconnecting( void ) const
		{
			if (m_Status == DISCONNECTING)
				return( TRUE );

			return( FALSE );
		};

	BOOL IsInvalid( void ) const
		{
			if (m_Status == INVALID)
				return( TRUE );

			return( FALSE );
		};

	void SetDPNID(const DPNID dpnid)
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID(void) const
		{
			return(m_dpnid);
		};

	void SetContext( void *const pvContext )
		{
			m_pvContext = pvContext;
		};

	void *GetContext( void ) const
		{
			return( m_pvContext );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::MakeLocal"
	void MakeLocal(void)
		{
			DNASSERT(m_hEndPt == NULL);
			m_dwFlags |= CONNECTION_FLAG_LOCAL;
		};

	BOOL IsLocal(void) const
		{
			if (m_dwFlags & CONNECTION_FLAG_LOCAL)
			{
				return(TRUE);
			}
				
			return(FALSE);
		};

#ifndef	DPNBUILD_NOMULTICAST
	void MakeMulticastSender( void )
		{
			m_dwFlags |= CONNECTION_FLAG_MULTICAST_SENDER;
		};

	BOOL IsMulticastSender( void ) const
		{
			if (m_dwFlags & CONNECTION_FLAG_MULTICAST_SENDER)
			{
				return( TRUE );
			}
			return( FALSE);
		};

	void MakeMulticastReceiver( void )
		{
			m_dwFlags |= CONNECTION_FLAG_MULTICAST_RECEIVER;
		};

	BOOL IsMulticastReceiver( void ) const
		{
			if (m_dwFlags & CONNECTION_FLAG_MULTICAST_RECEIVER)
			{
				return( TRUE );
			}
			return( FALSE);
		};
#endif	// DPNBUILD_NOMULTICAST

	void CConnection::SetSP( CServiceProvider *const pSP );

	CServiceProvider *GetSP( void ) const
		{
			return( m_pSP );
		};

	void SetThreadCount( const DWORD dwCount )
		{
			m_dwThreadCount = dwCount;
		};

	void SetThreadEvent( CSyncEvent *const pSyncEvent )
		{
			m_pThreadEvent = pSyncEvent;
		};

	void CConnection::Disconnect(void);

	void CConnection::AddToHighQueue( const DWORD dwBytes )
		{
			m_QueueInfoHigh.dwNumOutstanding++;
			m_QueueInfoHigh.dwBytesOutstanding += dwBytes;
		};

	void CConnection::AddToNormalQueue( const DWORD dwBytes )
		{
			m_QueueInfoNormal.dwNumOutstanding++;
			m_QueueInfoNormal.dwBytesOutstanding += dwBytes;
		};

	void CConnection::AddToLowQueue( const DWORD dwBytes )
		{
			m_QueueInfoLow.dwNumOutstanding++;
			m_QueueInfoLow.dwBytesOutstanding += dwBytes;
		};

	void CConnection::RemoveFromHighQueue( const DWORD dwBytes )
		{
			m_QueueInfoHigh.dwNumOutstanding--;
			m_QueueInfoHigh.dwBytesOutstanding -= dwBytes;
		};

	void CConnection::RemoveFromNormalQueue( const DWORD dwBytes )
		{
			m_QueueInfoNormal.dwNumOutstanding--;
			m_QueueInfoNormal.dwBytesOutstanding -= dwBytes;
		};

	void CConnection::RemoveFromLowQueue( const DWORD dwBytes )
		{
			m_QueueInfoLow.dwNumOutstanding--;
			m_QueueInfoLow.dwBytesOutstanding -= dwBytes;
		};

	DWORD CConnection::GetHighQueueNum( void ) const
		{
			return( m_QueueInfoHigh.dwNumOutstanding );
		};

	DWORD CConnection::GetHighQueueBytes( void ) const
		{
			return( m_QueueInfoHigh.dwBytesOutstanding );
		};

	DWORD CConnection::GetNormalQueueNum( void ) const
		{
			return( m_QueueInfoNormal.dwNumOutstanding );
		};

	DWORD CConnection::GetNormalQueueBytes( void ) const
		{
			return( m_QueueInfoNormal.dwBytesOutstanding );
		};

	DWORD CConnection::GetLowQueueNum( void ) const
		{
			return( m_QueueInfoLow.dwNumOutstanding );
		};

	DWORD CConnection::GetLowQueueBytes( void ) const
		{
			return( m_QueueInfoLow.dwBytesOutstanding );
		};

	CBilink				m_bilinkConnections;
	CBilink				m_bilinkIndicated;		// Indicated connections without DPNID's (players entries)
	CBilink				m_bilinkCallbackThreads;
#ifndef DPNBUILD_NOMULTICAST
	CBilink				m_bilinkMulticast;		// Multicast receive connections
#endif // ! DPNBUILD_NOMULTICAST

private:
	BYTE				m_Sig[4];

	DWORD	volatile	m_dwFlags;
	LONG	volatile	m_lRefCount;

	HANDLE	volatile	m_hEndPt;
	DPNID				m_dpnid;

	void	* volatile	m_pvContext;

	CServiceProvider	*m_pSP;

	CONNECTION_STATUS	m_Status;

	DWORD	volatile	m_dwThreadCount;
	CSyncEvent			*m_pThreadEvent;

	USER_SEND_QUEUE_INFO	m_QueueInfoHigh;
	USER_SEND_QUEUE_INFO	m_QueueInfoNormal;
	USER_SEND_QUEUE_INFO	m_QueueInfoLow;

	DIRECTNETOBJECT		*m_pdnObject;

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	m_cs;
#endif // !DPNBUILD_ONLYONETHREAD
};

#undef DPF_MODNAME

#endif	// __CONNECTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\coreclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   ClassFac.cpp
 *  Content:	DNET COM class factory
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	   By	  Reason
 *   ====	   ==	  ======
 *  07/21/99	mjn		Created
 *	12/23/99	mjn		Fixed Host and AllPlayers short-cut pointer use
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/08/00	mjn		Fixed DN_APPLICATION_DESC in DIRECTNETOBJECT
 *	01/13/00	mjn		Added CFixedPools and CRefCountBuffers
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Removed User message fixed pool
 *  01/18/00	mjn		Fixed bug in ref count.
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/19/00	mjn		Initialize structures for NameTable Operation List
 *	01/25/00	mjn		Added NameTable pending operation list
 *	01/31/00	mjn		Added Internal FPM's for RefCountBuffers
 *  03/17/00	rmt	 Added calls to init/free SP Caps cache
 *	03/23/00	mjn		Implemented RegisterLobby()
 *  04/04/00	rmt		Enabled "Enable Parameter Validation" flag on object by default
 *	04/09/00	mjn		Added support for CAsyncOp
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/28/00	mjn		Code cleanup - removed hsAsyncHandles,blAsyncOperations
 *	05/04/00	mjn		Cleaned up and made multi-thread safe
 *  05/23/00	RichGr  IA64: Substituted %p format specifier whereever
 *					  %x was being used to format pointers.  %p is 32-bit
 *					  in a 32-bit build, and 64-bit in a 64-bit build.
 *  06/09/00	rmt	 Updates to split CLSID and allow whistler compat
 *  06/09/00	rmt	 Updates to split CLSID and allow whistler compat and support external create funcs
 *	06/20/00	mjn		Fixed QueryInterface bug
 *  06/27/00	rmt		Fixed bug which was causing interfaces to always be created as peer interfaces
 *  07/05/00	rmt		Bug #38478 - Could QI for peer interfaces from client object
 *						(All interfaces could be queried from all types of objects).
 *				mjn		Initialize pConnect element of DIRECNETOBJECT to NULL
 *	07/07/00	mjn		Added pNewHost for DirectNetObject
 *	07/08/00	mjn		Call DN_Close when object is about to be free'd
 *  07/09/00	rmt		Added code to free interface set by RegisterLobby (if there is one)
 *	07/17/00	mjn		Add signature to DirectNetObject
 *  07/21/00	RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *	07/26/00	mjn		DN_QueryInterface returns E_POINTER if NULL destination pointer specified
 *	07/28/00	mjn		Added m_bilinkConnections to DirectNetObject
 *	07/30/00	mjn		Added CPendingDeletion
 *	07/31/00	mjn		Added CQueuedMsg
 *	08/05/00	mjn		Added m_bilinkActiveList and csActiveList
 *	08/06/00	mjn		Added CWorkerJob
 *	08/23/00	mjn		Added CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *  01/11/2001	rmt		MANBUG #48487 - DPLAY: Crashes if CoCreate() isn't called
 *	02/05/01	mjn		Removed unused debug members from DIRECTNETOBJECT
 *				mjn		Added CCallbackThread
 *  03/14/2001  rmt		WINBUG #342420 - Restore COM emulation layer to operation
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added pConnectSP,dwMaxFrameSize
 *				mjn		Removed blSPCapsList
 *	04/04/01	mjn		Added voice and lobby sigs
 *	04/13/01	mjn		Added m_bilinkRequestList
 *	05/17/01	mjn		Added dwRunningOpCount,hRunningOpEvent,dwWaitingThreadID to track threads performing NameTable operations
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *	10/05/01	vanceo	Added multicast object
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#ifndef DPNBUILD_LIBINTERFACE
typedef	STDMETHODIMP IUnknownQueryInterface( IUnknown *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	IUnknownAddRef( IUnknown *pInterface );
typedef	STDMETHODIMP_(ULONG)	IUnknownRelease( IUnknown *pInterface );

//
// VTable for IUnknown interface
//
IUnknownVtbl  DN_UnknownVtbl =
{
	(IUnknownQueryInterface*)	DN_QueryInterface,
	(IUnknownAddRef*)			DN_AddRef,
	(IUnknownRelease*)			DN_Release
};


//
// VTable for Class Factory
//
IClassFactoryVtbl DNCF_Vtbl =
{
	DPCF_QueryInterface, // dplay8\common\classfactory.cpp will implement these
	DPCF_AddRef,
	DPCF_Release,
	DNCORECF_CreateInstance,
	DPCF_LockServer
};
#endif // ! DPNBUILD_LIBINTERFACE



//**********************************************************************
// Variable definitions
//**********************************************************************

#ifndef DPNBUILD_NOVOICE
extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
#endif // DPNBUILD_NOVOICE


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DNCF_CreateObject"

HRESULT DNCF_CreateObject(
#ifndef DPNBUILD_LIBINTERFACE
							IClassFactory* pInterface,
#endif // ! DPNBUILD_LIBINTERFACE
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
							XDP8CREATE_PARAMS * pDP8CreateParams,
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
							DP8REFIID riid,
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
							LPVOID *lplpv
							)
{
	HRESULT				hResultCode = S_OK;
	DIRECTNETOBJECT		*pdnObject = NULL;
#ifndef DPNBUILD_LIBINTERFACE
	const _IDirectPlayClassFactory* pDPClassFactory = (_IDirectPlayClassFactory*) pInterface;
#endif // ! DPNBUILD_LIBINTERFACE


	DPFX(DPFPREP, 4,"Parameters: lplpv [%p]", lplpv);


	/*
	*
	*	TIME BOMB
	*
	*/

#if ((! defined(DX_FINAL_RELEASE)) && (! defined(DPNBUILD_LIBINTERFACE)))
{
#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
	SYSTEMTIME st;
	GetSystemTime(&st);

	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
	{
		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
//		return E_FAIL;
	}
}
#endif // ! DX_FINAL_RELEASE and ! DPNBUILD_LIBINTERFACE

#ifndef DPNBUILD_LIBINTERFACE
	if( pDPClassFactory->clsid == CLSID_DirectPlay8Client )
	{
		if( riid != IID_IDirectPlay8Client &&
			riid != IID_IUnknown
#ifndef DPNBUILD_NOVOICE
			 && riid != IID_IDirectPlayVoiceTransport 
#endif // DPNBUILD_NOVOICE
			)
		{
			DPFX(DPFPREP,  0, "Requesting unknown interface from client CLSID" );
			return E_NOINTERFACE;
		}
	}
#ifndef	DPNBUILD_NOSERVER
	else if( pDPClassFactory->clsid == CLSID_DirectPlay8Server )
	{
		if( riid != IID_IDirectPlay8Server &&
			riid != IID_IUnknown
#ifndef DPNBUILD_NOVOICE
			 && riid != IID_IDirectPlayVoiceTransport
#endif // ! DPNBUILD_NOVOICE
#ifndef DPNBUILD_NOPROTOCOLTESTITF
			 && riid != IID_IDirectPlay8Protocol 
#endif // ! DPNBUILD_NOPROTOCOLTESTITF
			)
		{
			DPFX(DPFPREP,  0, "Requesting unknown interface from server CLSID" );
			return E_NOINTERFACE;
		}
	}
#endif // ! DPNBUILD_NOSERVER
	else if( pDPClassFactory->clsid == CLSID_DirectPlay8Peer )
	{
		if( riid != IID_IDirectPlay8Peer &&
			riid != IID_IUnknown
#ifndef DPNBUILD_NOVOICE
			 && riid != IID_IDirectPlayVoiceTransport 
#endif // ! DPNBUILD_NOVOICE
			 )
		{
			DPFX(DPFPREP,  0, "Requesting unknown interface from peer CLSID" );
			return E_NOINTERFACE;
		}
	}
#ifndef	DPNBUILD_NOMULTICAST
	else if( pDPClassFactory->clsid == CLSID_DirectPlay8Multicast )
	{
		if( riid != IID_IDirectPlay8Multicast &&
			riid != IID_IUnknown
#ifndef DPNBUILD_NOPROTOCOLTESTITF
			 && riid != IID_IDirectPlay8Protocol 
#endif // ! DPNBUILD_NOPROTOCOLTESTITF
			)
		{
			DPFX(DPFPREP,  0, "Requesting unknown interface from server CLSID" );
			return E_NOINTERFACE;
		}
	}
#endif // ! DPNBUILD_NOMULTICAST
        else
        {
                DNASSERT(FALSE);
        }
#endif // ! DPNBUILD_LIBINTERFACE

	// Allocate object
	pdnObject = (DIRECTNETOBJECT*) DNMalloc(sizeof(DIRECTNETOBJECT));
	if (pdnObject == NULL)
	{
		DPFERR("Creating DIRECTNETOBJECT failed!");
		return(E_OUTOFMEMORY);
	}
	DPFX(DPFPREP, 0,"pdnObject [%p]",pdnObject);

	// Zero out the new object so we don't have to individually zero many members
	memset(pdnObject, 0, sizeof(DIRECTNETOBJECT));

	//
	//	Signatures
	//
	pdnObject->Sig[0] = 'D';
	pdnObject->Sig[1] = 'N';
	pdnObject->Sig[2] = 'E';
	pdnObject->Sig[3] = 'T';

#ifndef DPNBUILD_NOVOICE
	pdnObject->VoiceSig[0] = 'V';
	pdnObject->VoiceSig[1] = 'O';
	pdnObject->VoiceSig[2] = 'I';
	pdnObject->VoiceSig[3] = 'C';
#endif // !DPNBUILD_NOVOICE

#ifndef DPNBUILD_NOLOBBY
	pdnObject->LobbySig[0] = 'L';
	pdnObject->LobbySig[1] = 'O';
	pdnObject->LobbySig[2] = 'B';
	pdnObject->LobbySig[3] = 'B';
#endif // ! DPNBUILD_NOLOBBY


	// Initialize Critical Section
	if (!DNInitializeCriticalSection(&(pdnObject->csDirectNetObject)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csServiceProviders)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csNameTableOpList)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

#ifdef DBG
	if (!DNInitializeCriticalSection(&(pdnObject->csAsyncOperations)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
#endif // DBG

#ifndef DPNBUILD_NOVOICE
	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
#endif // !DPNBUILD_NOVOICE

#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	if (!DNInitializeCriticalSection(&(pdnObject->csWorkerQueue)))
	{
		DPFERR("DNInitializeCriticalSection(worker queue) failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE

	if (!DNInitializeCriticalSection(&(pdnObject->csActiveList)))
	{
		DPFERR("DNInitializeCriticalSection(csActiveList) failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csConnectionList)))
	{
		DPFERR("DNInitializeCriticalSection(csConnectionList) failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csCallbackThreads)))
	{
		DPFERR("DNInitializeCriticalSection(csCallbackThreads) failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

#ifndef DPNBUILD_NOPARAMVAL
	pdnObject->dwFlags = DN_OBJECT_FLAG_PARAMVALIDATION;
#endif // !DPNBUILD_NOPARAMVAL

	//
	//	Initialize NameTable
	//
	if ((hResultCode = pdnObject->NameTable.Initialize(pdnObject)) != DPN_OK)
	{
		DPFERR("Could not initialize NameTable");
		DisplayDNError(0,hResultCode);
		DNCF_FreeObject(pdnObject);
		return(hResultCode);
	}

	//
	//	Create a thread pool work interface
	//
#ifdef DPNBUILD_LIBINTERFACE
#if ((defined(DPNBUILD_ONLYONETHREAD)) && (! defined(DPNBUILD_MULTIPLETHREADPOOLS)))
	DPTPCF_GetObject(reinterpret_cast<void**>(&pdnObject->pIDPThreadPoolWork));
	hResultCode = S_OK;
#else // ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
	hResultCode = DPTPCF_CreateObject(reinterpret_cast<void**>(&pdnObject->pIDPThreadPoolWork));
#endif // ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
#else // ! DPNBUILD_LIBINTERFACE
	hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8ThreadPool,
										NULL,
										CLSCTX_INPROC_SERVER,
										IID_IDirectPlay8ThreadPoolWork,
										reinterpret_cast<void**>(&pdnObject->pIDPThreadPoolWork),
										FALSE);
#endif // ! DPNBUILD_LIBINTERFACE
	if (hResultCode != S_OK)
	{
		DPFX(DPFPREP, 0, "Could not create Thread Pool Work interface (err = 0x%lx)!", hResultCode);
		DisplayDNError(0,hResultCode);
		DNCF_FreeObject(pdnObject);
		return(hResultCode);
	}

	//
	//	Create Protocol Object
	//
	hResultCode = DNPProtocolCreate(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
									pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
									&pdnObject->pdnProtocolData
									);
	if (FAILED(hResultCode))
	{
		DPFERR("DNPProtocolCreate() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONESP)))
	if ((hResultCode = DNPProtocolInitialize( pdnObject->pdnProtocolData, pdnObject, &g_ProtocolVTBL, 
															pdnObject->pIDPThreadPoolWork, FALSE)) != DPN_OK)
	{
		DPFERR("DNPProtocolInitialize() failed");
		DisplayDNError(0,hResultCode);
		return(E_OUTOFMEMORY);
	}
#endif // DPNBUILD_LIBINTERFACE and DPNBUILD_ONLYONESP

	pdnObject->hProtocolShutdownEvent = NULL;
	pdnObject->lProtocolRefCount = 0;

#ifndef DPNBUILD_ONLYONESP
	// Initialize SP List
	pdnObject->m_bilinkServiceProviders.Initialize();
#endif // ! DPNBUILD_ONLYONESP

#ifdef DBG
	//
	//	Initialize AsyncOp List
	//
	pdnObject->m_bilinkAsyncOps.Initialize();
#endif // DBG

	//
	//	Initialize outstanding CConection list
	//
	pdnObject->m_bilinkConnections.Initialize();

	//
	//	Initialize pending deletion list
	//
	pdnObject->m_bilinkPendingDeletions.Initialize();

	//
	//	Initialize active AsyncOp list
	//
	pdnObject->m_bilinkActiveList.Initialize();

	//
	//	Initialize request AsyncOp list
	//
	pdnObject->m_bilinkRequestList.Initialize();

#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	//
	//	Initialize worker thread job list
	//
	pdnObject->m_bilinkWorkerJobs.Initialize();
	pdnObject->fProcessingWorkerJobs = FALSE;
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE

	//
	//	Initialize indicated connection list
	//
	pdnObject->m_bilinkIndicated.Initialize();

	//
	//	Initialize callback thread list
	//
	pdnObject->m_bilinkCallbackThreads.Initialize();

	// Setup Flags
#ifdef DPNBUILD_LIBINTERFACE
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	switch (pDP8CreateParams->riidInterfaceType)
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	switch (riid)
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	{
		case IID_IDirectPlay8Client:
		{
			DPFX(DPFPREP, 5,"DirectPlay8 CLIENT");
			pdnObject->dwFlags |= DN_OBJECT_FLAG_CLIENT;
			pdnObject->lpVtbl = &DN_ClientVtbl;
			break;
		}
		
#ifndef	DPNBUILD_NOSERVER
		case IID_IDirectPlay8Server:
		{
			DPFX(DPFPREP, 5,"DirectPlay8 SERVER");
			pdnObject->dwFlags |= DN_OBJECT_FLAG_SERVER;
			pdnObject->lpVtbl = &DN_ServerVtbl;
			break;
		}
#endif // ! DPNBUILD_NOSERVER

		case IID_IDirectPlay8Peer:
		{
			DPFX(DPFPREP, 5,"DirectPlay8 PEER");
			pdnObject->dwFlags |= DN_OBJECT_FLAG_PEER;
			pdnObject->lpVtbl = &DN_PeerVtbl;
			break;
		}
			
#ifndef	DPNBUILD_NOMULTICAST
		case IID_IDirectPlay8Multicast:
		{
			DPFX(DPFPREP, 5,"DirectPlay8 MULTICAST");
			pdnObject->dwFlags |= DN_OBJECT_FLAG_MULTICAST;
			pdnObject->lpVtbl = &DNMcast_Vtbl;
			break;
		}
#endif // ! DPNBUILD_NOMULTICAST

		default:
		{
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
			DPFX(DPFPREP, 0, "Requesting unknown interface type %x!",
				pDP8CreateParams->riidInterfaceType);
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
			DPFX(DPFPREP, 0, "Requesting unknown interface type %x!",
				riid);
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
			return E_NOINTERFACE;
			break;
		}
	}
#else // ! DPNBUILD_LIBINTERFACE
	if (IsEqualIID(riid,IID_IDirectPlay8Client))
	{
		DPFX(DPFPREP, 5,"DirectPlay8 CLIENT");
		pdnObject->dwFlags |= DN_OBJECT_FLAG_CLIENT;
	}
#ifndef	DPNBUILD_NOSERVER
	else if (IsEqualIID(riid,IID_IDirectPlay8Server))
	{
		DPFX(DPFPREP, 5,"DirectPlay8 SERVER");
		pdnObject->dwFlags |= DN_OBJECT_FLAG_SERVER;
	}
#endif	// DPNBUILD_NOSERVER
	else if (IsEqualIID(riid,IID_IDirectPlay8Peer))
	{
		DPFX(DPFPREP, 5,"DirectPlay8 PEER");
		pdnObject->dwFlags |= DN_OBJECT_FLAG_PEER;
	}
#ifndef	DPNBUILD_NOMULTICAST
	else if (IsEqualIID(riid,IID_IDirectPlay8Multicast))
	{
		DPFX(DPFPREP, 5,"DirectPlay8 MULTICAST");
		pdnObject->dwFlags |= DN_OBJECT_FLAG_MULTICAST;
	}
#endif	// DPNBUILD_NOMULTICAST
#ifndef DPNBUILD_NOPROTOCOLTESTITF
	else if (IsEqualIID(riid,IID_IDirectPlay8Protocol))
	{
		DPFX(DPFPREP, 5,"IDirectPlay8Protocol");
		pdnObject->dwFlags |= DN_OBJECT_FLAG_SERVER;
	}
#endif // !DPNBUILD_NOPROTOCOLTESTITF
	else if( riid == IID_IUnknown )
	{
		if( pDPClassFactory->clsid == CLSID_DirectPlay8Client )
		{
			DPFX(DPFPREP, 5,"DirectPlay8 CLIENT via IUnknown");
			pdnObject->dwFlags |= DN_OBJECT_FLAG_CLIENT;
		}
#ifndef	DPNBUILD_NOSERVER
		else if( pDPClassFactory->clsid == CLSID_DirectPlay8Server )
		{
			DPFX(DPFPREP, 5,"DirectPlay8 SERVER via IUnknown");
			pdnObject->dwFlags |= DN_OBJECT_FLAG_SERVER;
		}
#endif	// DPNBUILD_NOSERVER
		else if( pDPClassFactory->clsid == CLSID_DirectPlay8Peer )
		{
			DPFX(DPFPREP, 5,"DirectPlay8 PEER via IUnknown");
			pdnObject->dwFlags |= DN_OBJECT_FLAG_PEER;
		}
#ifndef	DPNBUILD_NOMULTICAST
		else if( pDPClassFactory->clsid == CLSID_DirectPlay8Multicast )
		{
			DPFX(DPFPREP, 5,"DirectPlay8 MULTICAST via IUnknown");
			pdnObject->dwFlags |= DN_OBJECT_FLAG_MULTICAST;
		}
#endif	// DPNBUILD_NOMULTICAST
		else
		{
			DPFX(DPFPREP, 0,"Unknown CLSID!");
			DNASSERT( FALSE );
			DNCF_FreeObject(pdnObject);
			return(E_NOTIMPL);
		}
	}
	else
	{
		DPFX(DPFPREP, 0,"Invalid DirectPlay8 Interface");
		DNCF_FreeObject(pdnObject);
		return(E_NOTIMPL);
	}
#endif // ! DPNBUILD_LIBINTERFACE

	//
	//	Create lock event
	//
	if ((pdnObject->hLockEvent = DNCreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
	{
		DPFERR("Unable to create lock event");
		DNCF_FreeObject(pdnObject);
		return(DPNERR_OUTOFMEMORY);
	}

	//
	//	Create running operation event (for host migration)
	//
	if ( pdnObject->dwFlags & DN_OBJECT_FLAG_PEER )
	{
		if ((pdnObject->hRunningOpEvent = DNCreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
		{
			DPFERR("Unable to create running operation event");
			DNCF_FreeObject(pdnObject);
			return(DPNERR_OUTOFMEMORY);
		}
	}

#ifndef	DPNBUILD_NOMULTICAST
	pdnObject->pMulticastSend = NULL;
	pdnObject->m_bilinkMulticast.Initialize();
#endif	// DPNBUILD_NOMULTICAST


#ifdef DPNBUILD_LIBINTERFACE
#ifdef DPNBUILD_ONLYONESP
	hResultCode = DN_SPInstantiate(
									pdnObject
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
									,pDP8CreateParams
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
									);
	if (hResultCode != S_OK)
	{
		DPFX(DPFPREP, 0, "Could not instantiate SP (err = 0x%lx)!", hResultCode);
		DisplayDNError(0,hResultCode);
		DNCF_FreeObject(pdnObject);
		return(hResultCode);
	}
#endif // DPNBUILD_ONLYONESP
	//
	//	For lib interface builds, the refcount is embedded in object.
	//
	pdnObject->lRefCount = 1;
#endif // DPNBUILD_LIBINTERFACE

	*lplpv = pdnObject;

	DPFX(DPFPREP, 4,"Returning: hResultCode = [%lx], *lplpv = [%p]",hResultCode,*lplpv);
	return(hResultCode);
}




#ifndef WINCE
#ifdef _XBOX

#undef DPF_MODNAME
#define DPF_MODNAME "XDirectPlay8Create"
HRESULT WINAPI XDirectPlay8Create(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
								const XDP8CREATE_PARAMS * const pDP8CreateParams,
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
								DP8REFIID riidInterfaceType,
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
								void **ppvInterface
								)
{
	HRESULT				hr;
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	XDP8CREATE_PARAMS	CreateParamsAdjusted;


	DPFX(DPFPREP, 5, "Parameters: pDP8CreateParams[0x%p], ppvInterface[0x%p]", pDP8CreateParams, ppvInterface);
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	DPFX(DPFPREP, 5, "Parameters: riidInterfaceType[0x%x], ppvInterface[0x%p]", riidInterfaceType, ppvInterface);
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	
#ifndef DPNBUILD_NOPARAMVAL
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if ((pDP8CreateParams == NULL) ||
		(! DNVALID_READPTR(pDP8CreateParams, sizeof(CreateParamsAdjusted))))
	{
		DPFX(DPFPREP, 0, "Invalid pointer to Create parameters!");
		return DPNERR_INVALIDPOINTER;
	}
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

	if( ppvInterface == NULL || !DNVALID_WRITEPTR( ppvInterface, sizeof( void * ) ) )
	{
		DPFX(DPFPREP, 0, "Invalid pointer specified to receive interface!");
		return DPNERR_INVALIDPOINTER;
	}
#endif // ! DPNBUILD_NOPARAMVAL

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	memcpy(&CreateParamsAdjusted, pDP8CreateParams, sizeof(CreateParamsAdjusted));
	
	switch (CreateParamsAdjusted.riidInterfaceType)
	{
		case IID_IDirectPlay8Client:
		{
			CreateParamsAdjusted.dwMaxNumPlayers = 1;
			break;
		}
		
#ifndef	DPNBUILD_NOSERVER
		case IID_IDirectPlay8Server:
#endif // ! DPNBUILD_NOSERVER
		case IID_IDirectPlay8Peer:
		{
			//
			// Include room for hidden All Players group.
			//
			CreateParamsAdjusted.dwMaxNumGroups++;
			break;
		}
		
#ifndef	DPNBUILD_NOMULTICAST
		case IID_IDirectPlay8Multicast:
		{
			CreateParamsAdjusted.dwMaxNumGroups = 0;
			break;
		}
#endif // ! DPNBUILD_NOMULTICAST

#ifndef DPNBUILD_NOPARAMVAL
		default:
		{
			DPFX(DPFPREP, 0, "Requesting unknown interface type %u!", CreateParamsAdjusted.riidInterfaceType);
			return E_NOINTERFACE;
			break;
		}
#endif // ! DPNBUILD_NOPARAMVAL
	}
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT(! DNMemoryTrackAreAllocationsAllowed());
	DNMemoryTrackAllowAllocations(TRUE);
	
	hr = DNCF_CreateObject(&CreateParamsAdjusted, ppvInterface);
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT(DNMemoryTrackAreAllocationsAllowed());
	
	hr = DNCF_CreateObject(riidInterfaceType, ppvInterface);
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create interface!");
		return hr;
	}

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	//
	// Pre-allocate the requested memory.
	//

	hr = DN_PopulateCorePools((DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(*ppvInterface),
								&CreateParamsAdjusted);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't populate core pools!");
		DNCF_FreeObject((DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(*ppvInterface));
		*ppvInterface = NULL;
		return hr;
	}

	DNASSERT(DNMemoryTrackAreAllocationsAllowed());
	DNMemoryTrackAllowAllocations(FALSE);
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

	return DPN_OK;
}

extern STDMETHODIMP DPTP_DoWork(const DWORD dwAllowedTimeSlice,
								const DWORD dwFlags);

HRESULT WINAPI XDirectPlay8DoWork(const DWORD dwAllowedTimeSlice)
{
	return DPTP_DoWork(dwAllowedTimeSlice, 0);
}

HRESULT WINAPI XDirectPlay8BuildAppDescReservedData(const XNKID * const pSessionID,
													const XNKEY * const pKeyExchangeKey,
													PVOID pvReservedData,
													DWORD * const pcbReservedDataSize)
{
	SPSESSIONDATA_XNET *	pSessionDataXNet;

	
#ifndef DPNBUILD_NOPARAMVAL
	if ((pSessionID == NULL) ||
		(! DNVALID_READPTR(pSessionID, sizeof(XNKID))))
	{
		DPFERR("Invalid session key ID specified");
		return DPNERR_INVALIDPOINTER;
	}

	if ((pKeyExchangeKey == NULL) ||
		(! DNVALID_READPTR(pKeyExchangeKey, sizeof(XNKEY))))
	{
		DPFERR("Invalid key exchange key specified");
		return DPNERR_INVALIDPOINTER;
	}

	if ((pcbReservedDataSize == NULL) ||
		(! DNVALID_WRITEPTR(pcbReservedDataSize, sizeof(DWORD))))
	{
		DPFERR("Invalid pointer specified for data size");
		return DPNERR_INVALIDPOINTER;
	}

	if ((*pcbReservedDataSize > 0) &&
		((pvReservedData == NULL) || (! DNVALID_WRITEPTR(pvReservedData, *pcbReservedDataSize))))
	{
		DPFERR("Invalid pointer specified for reserved data buffer");
		return DPNERR_INVALIDPOINTER;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	if (*pcbReservedDataSize < DPN_MAX_APPDESC_RESERVEDDATA_SIZE)
	{
		*pcbReservedDataSize = DPN_MAX_APPDESC_RESERVEDDATA_SIZE;
		return DPNERR_BUFFERTOOSMALL;
	}

	DBG_CASSERT(sizeof(SPSESSIONDATA_XNET) < DPN_MAX_APPDESC_RESERVEDDATA_SIZE);
	pSessionDataXNet = (SPSESSIONDATA_XNET*) pvReservedData;
	pSessionDataXNet->dwInfo = SPSESSIONDATAINFO_XNET;
	DBG_CASSERT(sizeof(pSessionDataXNet->guidKey) == sizeof(*pKeyExchangeKey));
	memcpy(&pSessionDataXNet->guidKey, pKeyExchangeKey, sizeof(pSessionDataXNet->guidKey));
	DBG_CASSERT(sizeof(pSessionDataXNet->ullKeyID) == sizeof(*pSessionID));
	memcpy(&pSessionDataXNet->ullKeyID, pSessionID, sizeof(pSessionDataXNet->ullKeyID));

	//
	// Fill in the remainder of the data with deterministic but non-obvious bytes so
	// that we can:
	//	a) overwrite potential stack garbage
	//	b) prevent the app from being able to assume there will always be less than
	//		DPN_MAX_APPDESC_RESERVEDDATA_SIZE bytes of data.  This gives us a little
	//		flexibility for forward compatibility.
	//
	memset((pSessionDataXNet + 1),
				(((BYTE*) pSessionID)[1] ^ ((BYTE*) pKeyExchangeKey)[2]),
				(DPN_MAX_APPDESC_RESERVEDDATA_SIZE - sizeof(SPSESSIONDATA_XNET)));

	*pcbReservedDataSize = DPN_MAX_APPDESC_RESERVEDDATA_SIZE;
	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "XDirectPlay8AddressCreate"
HRESULT WINAPI XDirectPlay8AddressCreate( DPNAREFIID riid, void **ppvInterface )
{
	HRESULT		hr;

	
	DPFX(DPFPREP, 5, "Parameters: riid[0x%p], ppvInterface[0x%p]", &riid, ppvInterface);
	
#ifndef DPNBUILD_NOPARAMVAL
	if( ppvInterface == NULL || !DNVALID_WRITEPTR( ppvInterface, sizeof( void * ) ) )
	{
		DPFERR( "Invalid pointer specified to receive interface" );
		return DPNERR_INVALIDPOINTER;
	}
	
	switch (riid)
	{
		case IID_IDirectPlay8Address:
		{
			break;
		}
		
		case IID_IDirectPlay8AddressIP:
		{
#ifdef DPNBUILD_NOADDRESSIPINTERFACE
			DPFX(DPFPREP, 0, "The IDirectPlay8AddressIP interface is not supported!");
			return DPNERR_UNSUPPORTED;
#endif // DPNBUILD_NOADDRESSIPINTERFACE
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Requesting unknown interface type %u!", riid);
			return E_NOINTERFACE;
			break;
		}
	}
#endif // ! DPNBUILD_NOPARAMVAL

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT(! DNMemoryTrackAreAllocationsAllowed());
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT(DNMemoryTrackAreAllocationsAllowed());
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
	
	hr = DP8ACF_CreateInstance(riid, ppvInterface);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create interface!");
		return hr;
	}


	return S_OK;	  
}



#undef DPF_MODNAME
#define DPF_MODNAME "XDirectPlay8AddressCreateFromXnAddr"
HRESULT WINAPI XDirectPlay8AddressCreateFromXnAddr( XNADDR *pxnaddr, IDirectPlay8Address **ppInterface )
{
	HRESULT		hr;
	TCHAR		tszHostname[(sizeof(XNADDR) * 2) + 1]; // 2 characters for every byte + NULL termination
	TCHAR *		ptszCurrent;
	BYTE *		pbCurrent;
	DWORD		dwTemp;

	
	DPFX(DPFPREP, 5, "Parameters: pxnaddr[0x%p], ppInterface[0x%p]", pxnaddr, ppInterface);
	
#ifndef DPNBUILD_NOPARAMVAL
	if( pxnaddr == NULL )
	{
		DPFERR( "Invalid XNADDR" );
		return DPNERR_INVALIDPOINTER;
	}
	
	if( ppInterface == NULL || !DNVALID_WRITEPTR( ppInterface, sizeof( IDirectPlay8Address * ) ) )
	{
		DPFERR( "Invalid pointer specified to receive interface" );
		return DPNERR_INVALIDPOINTER;
	}
#endif // ! DPNBUILD_NOPARAMVAL

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT(! DNMemoryTrackAreAllocationsAllowed());
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT(DNMemoryTrackAreAllocationsAllowed());
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
	
	hr = DP8ACF_CreateInstance(IID_IDirectPlay8Address, (PVOID*) ppInterface);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create interface!");
		return hr;
	}

	ptszCurrent = tszHostname;
	pbCurrent = (BYTE*) pxnaddr;
	for(dwTemp = 0; dwTemp < sizeof(XNADDR); dwTemp++)
	{
		ptszCurrent += wsprintf(tszHostname, _T("%02X"), (*pbCurrent));
		pbCurrent++;
	}
	DNASSERT(((_tcslen(tszHostname) + 1) * sizeof(TCHAR)) == sizeof(tszHostname));

#ifdef UNICODE
	hr = IDirectPlay8Address_AddComponent((*ppInterface),
											DPNA_KEY_HOSTNAME,
											tszHostname,
											sizeof(tszHostname),
											DPNA_DATATYPE_STRING);
#else // ! UNICODE
	hr = IDirectPlay8Address_AddComponent((*ppInterface),
											DPNA_KEY_HOSTNAME,
											tszHostname,
											sizeof(tszHostname),
											DPNA_DATATYPE_STRING_ANSI);
#endif // ! UNICODE
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't add hostname component!");

		IDirectPlay8Address_Release(*ppInterface);
		*ppInterface = NULL;
		return hr;
	}

	return S_OK;	  
}


#else // ! _XBOX

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlay8Create"
HRESULT WINAPI DirectPlay8Create( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown)
{
	GUID clsid;

	DPFX(DPFPREP, 5, "Parameters: pcIID[0x%p], ppvInterface[0x%p], pUnknown[0x%p]", pcIID, ppvInterface, pUnknown);
	
#ifndef DPNBUILD_NOPARAMVAL
	if( pcIID == NULL ||
		!DNVALID_READPTR( pcIID, sizeof( GUID ) ) )
	{
		DPFERR( "Invalid pointer specified for interface GUID" );
		return DPNERR_INVALIDPOINTER;
	}

	if( ppvInterface == NULL || !DNVALID_WRITEPTR( ppvInterface, sizeof( void * ) ) )
	{
		DPFERR( "Invalid pointer specified to receive interface" );
		return DPNERR_INVALIDPOINTER;
	}

	if( pUnknown != NULL )
	{
		DPFERR( "Aggregation is not supported by this object yet" );
		return DPNERR_INVALIDPARAM;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	if( *pcIID == IID_IDirectPlay8Client )
	{
		clsid = CLSID_DirectPlay8Client;
	}
#ifndef	DPNBUILD_NOSERVER
	else if( *pcIID == IID_IDirectPlay8Server )
	{
		clsid = CLSID_DirectPlay8Server;
	}
#endif	// ! DPNBUILD_NOSERVER
	else if( *pcIID == IID_IDirectPlay8Peer )
	{
		clsid = CLSID_DirectPlay8Peer;
	}
#ifndef	DPNBUILD_NOMULTICAST
	else if( *pcIID == IID_IDirectPlay8Multicast )
	{
		clsid = CLSID_DirectPlay8Multicast;
	}
#endif	// ! DPNBUILD_NOMULTICAST
#ifndef DPNBUILD_NOLOBBY
	else if( *pcIID == IID_IDirectPlay8LobbyClient )
	{
		clsid = CLSID_DirectPlay8LobbyClient;
	}
	else if( *pcIID == IID_IDirectPlay8LobbiedApplication )
	{
		clsid = CLSID_DirectPlay8LobbiedApplication;
	}
#endif // ! DPNBUILD_NOLOBBY
	else if( *pcIID == IID_IDirectPlay8Address )
	{
		clsid = CLSID_DirectPlay8Address;
	}
#ifndef DPNBUILD_NOADDRESSIPINTERFACE
	else if( *pcIID == IID_IDirectPlay8AddressIP )
	{
		clsid = CLSID_DirectPlay8Address;
	}
#endif // ! DPNBUILD_NOADDRESSIPINTERFACE
	else 
	{
		DPFERR( "Invalid IID specified" );
		return DPNERR_INVALIDPARAM;
	}	

	return COM_CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, *pcIID, ppvInterface, TRUE );	  
}
#endif // ! _XBOX
#endif // ! WINCE


#undef DPF_MODNAME
#define DPF_MODNAME "DNCF_FreeObject"

HRESULT DNCF_FreeObject(PVOID pInterface)
{
	HRESULT				hResultCode = S_OK;
	DIRECTNETOBJECT		*pdnObject;
	
	DPFX(DPFPREP, 4,"Parameters: pInterface [0x%p]",pInterface);

#pragma BUGBUG(minara,"Do I need to delete the fixed pools here ?")

	if (pInterface == NULL)
	{
		return(DPNERR_INVALIDPARAM);
	}

	pdnObject = static_cast<DIRECTNETOBJECT*>(pInterface);
	DNASSERT(pdnObject != NULL);

#ifdef DPNBUILD_LIBINTERFACE
	//
	//	For lib interface builds, the reference is embedded in the object directly.
	//
	DNASSERT(pdnObject->lRefCount == 0);

#ifdef DPNBUILD_ONLYONESP
	DN_SPReleaseAll(pdnObject);
#endif // DPNBUILD_ONLYONESP
#endif // DPNBUILD_LIBINTERFACE

	//
	//	No connect SP
	//
	DNASSERT(pdnObject->pConnectSP == NULL);

	//
	//	No outstanding listens
	//
	DNASSERT(pdnObject->pListenParent == NULL);

	//
	//	No outstanding connect
	//
	DNASSERT(pdnObject->pConnectParent == NULL);

	//
	//	Host migration target
	//
	DNASSERT(pdnObject->pNewHost == NULL);

	//
	//	Protocol shutdown event
	//
	DNASSERT(pdnObject->hProtocolShutdownEvent == NULL);

	//
	//	Lock event
	//
	if (pdnObject->hLockEvent)
	{
		DNCloseHandle(pdnObject->hLockEvent);
	}

	//
	//	Running operations
	//
	if (pdnObject->hRunningOpEvent)
	{
		DNCloseHandle(pdnObject->hRunningOpEvent);
	}

#ifdef DPNBUILD_ONLYONETHREAD
#ifndef	DPNBUILD_NONSEQUENTIALWORKERQUEUE
	DNASSERT(pdnObject->ThreadPoolShutDownEvent == NULL);
	DNASSERT(pdnObject->lThreadPoolRefCount == 0);
#endif // DPNBUILD_NONSEQUENTIALWORKERQUEUE
#endif // DPNBUILD_ONLYONETHREAD

	// pIDPThreadPoolWork will be NULL if we failed CoCreate'ing the thread pool in DNCF_CreateObject
	if (pdnObject->pIDPThreadPoolWork != NULL)
	{
		IDirectPlay8ThreadPoolWork_Release(pdnObject->pIDPThreadPoolWork);
		pdnObject->pIDPThreadPoolWork = NULL;
	}
#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	DNDeleteCriticalSection(&pdnObject->csWorkerQueue);
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE

	//
	//	Protocol
	//
#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONESP)))
	if ((hResultCode = DNPProtocolShutdown(pdnObject->pdnProtocolData)) != DPN_OK)
	{
		DPFERR("Could not shut down Protocol Layer !");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
	}
#endif // DPNBUILD_LIBINTERFACE and DPNBUILD_ONLYONESP
	
	DNPProtocolDestroy(pdnObject->pdnProtocolData);
	pdnObject->pdnProtocolData = NULL;

	//
	//	Deinitialize NameTable
	//
	DPFX(DPFPREP, 3,"Deinitializing NameTable");
	pdnObject->NameTable.Deinitialize();

	// Active AsyncOp List Critical Section
	DNDeleteCriticalSection(&pdnObject->csActiveList);

	// NameTable operation list Critical Section
	DNDeleteCriticalSection(&pdnObject->csNameTableOpList);

	// Service Providers Critical Section
	DNDeleteCriticalSection(&pdnObject->csServiceProviders);

#ifdef DBG
	// Async Ops Critical Section
	DNDeleteCriticalSection(&pdnObject->csAsyncOperations);
#endif // DBG

	// Connection Critical Section
	DNDeleteCriticalSection(&pdnObject->csConnectionList);

#ifndef DPNBUILD_NOVOICE
	// Voice Critical Section
	DNDeleteCriticalSection(&pdnObject->csVoice);
#endif // !DPNBUILD_NOVOICE

	// Callback Thread List Critical Section
	DNDeleteCriticalSection(&pdnObject->csCallbackThreads);

#ifndef DPNBUILD_NOLOBBY
	if( pdnObject->pIDP8LobbiedApplication)
	{
		IDirectPlay8LobbiedApplication_Release( pdnObject->pIDP8LobbiedApplication );
		pdnObject->pIDP8LobbiedApplication = NULL;
	}
#endif // ! DPNBUILD_NOLOBBY

	// Delete DirectNet critical section
	DNDeleteCriticalSection(&pdnObject->csDirectNetObject);

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (pdnObject->fPoolsPrepopulated)
	{
		pdnObject->EnumReplyMemoryBlockPool.DeInitialize();
		pdnObject->fPoolsPrepopulated = FALSE;
	}
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

	DPFX(DPFPREP, 5,"free pdnObject [%p]",pdnObject);
	DNFree(pdnObject);
	
	DPFX(DPFPREP, 4,"Returning: [%lx]",hResultCode);
	return(hResultCode);
}



#ifdef DPNBUILD_LIBINTERFACE

#undef DPF_MODNAME
#define DPF_MODNAME "DN_QueryInterface"
STDMETHODIMP DN_QueryInterface(void *pInterface,
							   DP8REFIID riid,
							   void **ppv)
{
	HRESULT		hResultCode;
	
	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], riid [0x%p], ppv [0x%p]",pInterface,&riid,ppv);

	DPFX(DPFPREP, 0, "Querying for an interface is not supported!");
	hResultCode = DPNERR_UNSUPPORTED;

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_AddRef"

STDMETHODIMP_(ULONG) DN_AddRef(void *pInterface)
{
	DIRECTNETOBJECT		*pdnObject;
	LONG				lRefCount;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p]",pInterface);

#ifndef DPNBUILD_NOPARAMVAL
	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	pdnObject = static_cast<DIRECTNETOBJECT*>(pInterface);
	lRefCount = DNInterlockedIncrement( &pdnObject->lRefCount );
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

#ifndef DPNBUILD_NOPARAMVAL
Exit:
#endif // ! DPNBUILD_NOPARAMVAL
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DN_Release"
STDMETHODIMP_(ULONG) DN_Release(void *pInterface)
{
	DIRECTNETOBJECT		*pdnObject;
	LONG				lRefCount;

	DPFX(DPFPREP, 2,"Parameters: pInterface [%p]",pInterface);
	
#ifndef DPNBUILD_NOPARAMVAL
	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	pdnObject = static_cast<DIRECTNETOBJECT*>(pInterface);
	lRefCount = DNInterlockedDecrement( &pdnObject->lRefCount );
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

	if (lRefCount == 0)
	{
		//
		//	Ensure we're properly closed
		//
		DN_Close(pdnObject, 0);

		// Free object here
		DPFX(DPFPREP, 5,"Free object");
		DNCF_FreeObject(pdnObject);
	}

#ifndef DPNBUILD_NOPARAMVAL
Exit:
#endif // ! DPNBUILD_NOPARAMVAL
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
}

#else // ! DPNBUILD_LIBINTERFACE

#undef DPF_MODNAME
#define DPF_MODNAME "DNCORECF_CreateInstance"
STDMETHODIMP DNCORECF_CreateInstance(IClassFactory *pInterface,
										LPUNKNOWN lpUnkOuter,
										REFIID riid,
										void **ppv)
{
	HRESULT				hResultCode;
	INTERFACE_LIST		*pIntList;
	OBJECT_DATA			*pObjectData;

	DPFX(DPFPREP, 6,"Parameters: pInterface [%p], lpUnkOuter [%p], riid [%p], ppv [%p]",pInterface,lpUnkOuter,&riid,ppv);

#ifndef DPNBUILD_NOPARAMVAL
	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}
	if (lpUnkOuter != NULL)
	{
		hResultCode = CLASS_E_NOAGGREGATION;
		goto Exit;
	}
	if (ppv == NULL)
	{
		DPFERR("Invalid target interface pointer specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	pObjectData = NULL;
	pIntList = NULL;

	if ((pObjectData = static_cast<OBJECT_DATA*>(DNMalloc(sizeof(OBJECT_DATA)))) == NULL)
	{
		DPFERR("Could not allocate object");
		hResultCode = E_OUTOFMEMORY;
		goto Failure;
	}

	// Object creation and initialization
	if ((hResultCode = DNCF_CreateObject(pInterface, riid, &pObjectData->pvData)) != S_OK)
	{
		DPFERR("Could not create object");
		goto Failure;
	}
	DPFX(DPFPREP, 7,"Created and initialized object");

	// Get requested interface
	if ((hResultCode = DN_CreateInterface(pObjectData,riid,&pIntList)) != S_OK)
	{
		DNCF_FreeObject(pObjectData->pvData);
		goto Failure;
	}
	DPFX(DPFPREP, 7,"Found interface");

	pObjectData->pIntList = pIntList;
	pObjectData->lRefCount = 1;
	DN_AddRef( pIntList );
	DNInterlockedIncrement(&g_lCoreObjectCount);
	*ppv = pIntList;

	DPFX(DPFPREP, 7,"*ppv = [0x%p]",*ppv);
	hResultCode = S_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pObjectData)
	{
		DNFree(pObjectData);
		pObjectData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_CreateInterface"

HRESULT DN_CreateInterface(OBJECT_DATA *pObject,
							   REFIID riid,
							   INTERFACE_LIST **const ppv)
{
	INTERFACE_LIST	*pIntNew;
	PVOID			lpVtbl;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pObject [%p], riid [%p], ppv [%p]",pObject,&riid,ppv);

	DNASSERT(pObject != NULL);
	DNASSERT(ppv != NULL);

	const DIRECTNETOBJECT* pdnObject = ((DIRECTNETOBJECT *)pObject->pvData);

	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 7,"riid = IID_IUnknown");
		lpVtbl = &DN_UnknownVtbl;
	}
#ifndef DPNBUILD_NOVOICE
	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlayVoiceTransport");
		lpVtbl = &DN_VoiceTbl;
	}
#endif // !DPNBUILD_NOVOICE
#ifndef DPNBUILD_NOPROTOCOLTESTITF
	else if (IsEqualIID(riid,IID_IDirectPlay8Protocol))
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8Protocol");
		lpVtbl = &DN_ProtocolVtbl;
	}
#endif // !DPNBUILD_NOPROTOCOLTESTITF
	else if (IsEqualIID(riid,IID_IDirectPlay8Client) && 
			 pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT )
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8Client");
		lpVtbl = &DN_ClientVtbl;
	}
#ifndef	DPNBUILD_NOSERVER
	else if (IsEqualIID(riid,IID_IDirectPlay8Server) && 
			 pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER )
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8Server");
		lpVtbl = &DN_ServerVtbl;
	}
#endif	// DPNBUILD_NOSERVER
	else if (IsEqualIID(riid,IID_IDirectPlay8Peer) && 
			 pdnObject->dwFlags & DN_OBJECT_FLAG_PEER )
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8Peer");
		lpVtbl = &DN_PeerVtbl;
	}
#ifndef	DPNBUILD_NOMULTICAST
	else if (IsEqualIID(riid,IID_IDirectPlay8Multicast) && 
			 pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST )
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8Multicast");
		lpVtbl = &DNMcast_Vtbl;
	}
#endif	// DPNBUILD_NOMULTICAST
	else
	{
		DPFERR("riid not found !");
		hResultCode = E_NOINTERFACE;
		goto Exit;
	}

	if ((pIntNew = static_cast<INTERFACE_LIST*>(DNMalloc(sizeof(INTERFACE_LIST)))) == NULL)
	{
		DPFERR("Could not allocate interface");
		hResultCode = E_OUTOFMEMORY;
		goto Exit;
	}
	pIntNew->lpVtbl = lpVtbl;
	pIntNew->lRefCount = 0;
	pIntNew->pIntNext = NULL;
	DBG_CASSERT( sizeof( pIntNew->iid ) == sizeof( riid ) );
	memcpy( &(pIntNew->iid), &riid, sizeof( pIntNew->iid ) );
	pIntNew->pObject = pObject;

	*ppv = pIntNew;
	DPFX(DPFPREP, 7,"*ppv = [0x%p]",*ppv);

	hResultCode = S_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DN_FindInterface"

INTERFACE_LIST *DN_FindInterface(void *pInterface,
								 REFIID riid)
{
	INTERFACE_LIST	*pIntList;

	DPFX(DPFPREP, 6,"Parameters: pInterface [%p], riid [%p]",pInterface,&riid);

	DNASSERT(pInterface != NULL);

	pIntList = (static_cast<INTERFACE_LIST*>(pInterface))->pObject->pIntList;	// Find first interface

	while (pIntList != NULL)
	{
		if (IsEqualIID(riid,pIntList->iid))
			break;
		pIntList = pIntList->pIntNext;
	}

	DPFX(DPFPREP, 6,"Returning: pIntList [0x%p]",pIntList);
	return(pIntList);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DN_QueryInterface"
STDMETHODIMP DN_QueryInterface(void *pInterface,
							   DP8REFIID riid,
							   void **ppv)
{
	INTERFACE_LIST	*pIntList;
	INTERFACE_LIST	*pIntNew;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], riid [0x%p], ppv [0x%p]",pInterface,&riid,ppv);
	
#ifndef DPNBUILD_NOPARAMVAL
	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}
	if (ppv == NULL)
	{
		DPFERR("Invalid target interface pointer specified");
		hResultCode = E_POINTER;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	if ((pIntList = DN_FindInterface(pInterface,riid)) == NULL)
	{	// Interface must be created
		pIntList = (static_cast<INTERFACE_LIST*>(pInterface))->pObject->pIntList;
		if ((hResultCode = DN_CreateInterface(pIntList->pObject,riid,&pIntNew)) != S_OK)
		{
			goto Exit;
		}
		pIntNew->pIntNext = pIntList;
		pIntList->pObject->pIntList = pIntNew;
		pIntList = pIntNew;
	}
	if (pIntList->lRefCount == 0)		// New interface exposed
	{
		DNInterlockedIncrement( &pIntList->pObject->lRefCount );
	}
	DNInterlockedIncrement( &pIntList->lRefCount );
	*ppv = static_cast<void*>(pIntList);
	DPFX(DPFPREP, 5,"*ppv = [0x%p]", *ppv);

	hResultCode = S_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DN_AddRef"

STDMETHODIMP_(ULONG) DN_AddRef(void *pInterface)
{
	INTERFACE_LIST	*pIntList;
	LONG			lRefCount;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p]",pInterface);

#ifndef DPNBUILD_NOPARAMVAL
	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	pIntList = static_cast<INTERFACE_LIST*>(pInterface);
	lRefCount = DNInterlockedIncrement( &pIntList->lRefCount );
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

#ifndef DPNBUILD_NOPARAMVAL
Exit:
#endif // ! DPNBUILD_NOPARAMVAL
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DN_Release"
STDMETHODIMP_(ULONG) DN_Release(void *pInterface)
{
	INTERFACE_LIST	*pIntList;
	INTERFACE_LIST	*pIntCurrent;
	LONG			lRefCount;
	LONG			lObjRefCount;

	DPFX(DPFPREP, 2,"Parameters: pInterface [%p]",pInterface);
	
#ifndef DPNBUILD_NOPARAMVAL
	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	pIntList = static_cast<INTERFACE_LIST*>(pInterface);
	lRefCount = DNInterlockedDecrement( &pIntList->lRefCount );
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

	if (lRefCount == 0)
	{
		//
		//	Decrease object's interface count
		//
		lObjRefCount = DNInterlockedDecrement( &pIntList->pObject->lRefCount );

		//
		//	Free object and interfaces
		//
		if (lObjRefCount == 0)
		{
			//
			//	Ensure we're properly closed
			//
			DN_Close(pInterface, 0);

			// Free object here
			DPFX(DPFPREP, 5,"Free object");
			DNCF_FreeObject(pIntList->pObject->pvData);
			
			pIntList = pIntList->pObject->pIntList;	// Get head of interface list
			DNFree(pIntList->pObject);

			// Free Interfaces
			DPFX(DPFPREP, 5,"Free interfaces");
			while(pIntList != NULL)
			{
				pIntCurrent = pIntList;
				pIntList = pIntList->pIntNext;
				DNFree(pIntCurrent);
			}

			DNInterlockedDecrement(&g_lCoreObjectCount);
		}
	}

#ifndef DPNBUILD_NOPARAMVAL
Exit:
#endif // ! DPNBUILD_NOPARAMVAL
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
}

#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\coredllmain.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DllMain.cpp
 *  Content:    Defines the entry point for the DLL application.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   07/21/99	mjn		Created
 *   05/23/00   RichGr  IA64: Substituted %p format specifier whereever
 *                      %x was being used to format pointers.  %p is 32-bit
 *                      in a 32-bit build, and 64-bit in a 64-bit build. 
 *   06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *				rmt	    Added missing set of CLSID for classfactory object
 *   07/06/00	rmt		Making DPNET.DLL self-registering.
 *   08/15/00   RichGr  Bug #41363: Trigger timer and memory pool initialization at DLL startup,
 *                      but actually do it during the first DPlay8 object instantiation.  New functions
 *                      Pools_Pre_Init() and Pools_Deinit() are called from DNet.dll's DllMain.  
 *   10/05/01	vanceo	Added multicast object
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"



#ifdef DPNBUILD_LIBINTERFACE
DWORD	g_dwDP8StartupFlags = 0;
#endif // DPNBUILD_LIBINTERFACE


//
//	Fixed Pools
//
CFixedPool g_RefCountBufferPool;
CFixedPool g_SyncEventPool;
CFixedPool g_ConnectionPool;
CFixedPool g_GroupConnectionPool;
CFixedPool g_GroupMemberPool;
CFixedPool g_NameTableEntryPool;
CFixedPool g_NameTableOpPool;
CFixedPool g_AsyncOpPool;
CFixedPool g_PendingDeletionPool;
CFixedPool g_QueuedMsgPool;
CFixedPool g_WorkerJobPool;
CFixedPool g_MemoryBlockTinyPool;
CFixedPool g_MemoryBlockSmallPool;
CFixedPool g_MemoryBlockMediumPool;
CFixedPool g_MemoryBlockLargePool;
CFixedPool g_MemoryBlockHugePool;

#define REFCOUNTBUFFER_POOL_INITED	0x00000001
#define SYNCEVENT_POOL_INITED		0x00000002
#define CONNECTION_POOL_INITED		0x00000004
#define GRPCONNECTION_POOL_INITED	0x00000008
#define GRPMEMBER_POOL_INITED		0x00000010
#define NTENTRY_POOL_INITED			0x00000020
#define NTOP_POOL_INITED			0x00000040
#define ASYNCOP_POOL_INITED			0x00000080
#define PENDINGDEL_POOL_INITED		0x00000100
#define QUEUEDMSG_POOL_INITED		0x00000200
#define WORKERJOB_POOL_INITED		0x00000400
#define MEMBLOCKTINY_POOL_INITED	0x00000800
#define MEMBLOCKSMALL_POOL_INITED	0x00001000
#define MEMBLOCKMED_POOL_INITED		0x00002000
#define MEMBLOCKLARGE_POOL_INITED	0x00004000
#define MEMBLOCKHUGE_POOL_INITED	0x00008000

DWORD g_dwCoreInitFlags = 0;

#undef DPF_MODNAME
#define DPF_MODNAME "DNGlobalsInit"
BOOL DNGlobalsInit(HANDLE hModule)
{
	if (!g_RefCountBufferPool.Initialize(sizeof(CRefCountBuffer), NULL, CRefCountBuffer::FPMInitialize, NULL, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= REFCOUNTBUFFER_POOL_INITED;
	if (!g_SyncEventPool.Initialize(sizeof(CSyncEvent), CSyncEvent::FPMAlloc, CSyncEvent::FPMInitialize, NULL, CSyncEvent::FPMDealloc))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= SYNCEVENT_POOL_INITED;
	if (!g_ConnectionPool.Initialize(sizeof(CConnection), CConnection::FPMAlloc, CConnection::FPMInitialize, CConnection::FPMRelease, CConnection::FPMDealloc))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= CONNECTION_POOL_INITED;
	if (!g_GroupConnectionPool.Initialize(sizeof(CGroupConnection), CGroupConnection::FPMAlloc, CGroupConnection::FPMInitialize, CGroupConnection::FPMRelease, CGroupConnection::FPMDealloc))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= GRPCONNECTION_POOL_INITED;
	if (!g_GroupMemberPool.Initialize(sizeof(CGroupMember), CGroupMember::FPMAlloc, CGroupMember::FPMInitialize, CGroupMember::FPMRelease, CGroupMember::FPMDealloc))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= GRPMEMBER_POOL_INITED;
	if (!g_NameTableEntryPool.Initialize(sizeof(CNameTableEntry), CNameTableEntry::FPMAlloc, CNameTableEntry::FPMInitialize, CNameTableEntry::FPMRelease, CNameTableEntry::FPMDealloc))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= NTENTRY_POOL_INITED;
	if (!g_NameTableOpPool.Initialize(sizeof(CNameTableOp), CNameTableOp::FPMAlloc, CNameTableOp::FPMInitialize, CNameTableOp::FPMRelease, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= NTOP_POOL_INITED;
	if (!g_AsyncOpPool.Initialize(sizeof(CAsyncOp), CAsyncOp::FPMAlloc, CAsyncOp::FPMInitialize, CAsyncOp::FPMRelease, CAsyncOp::FPMDealloc))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= ASYNCOP_POOL_INITED;
	if (!g_PendingDeletionPool.Initialize(sizeof(CPendingDeletion), CPendingDeletion::FPMAlloc, CPendingDeletion::FPMInitialize, CPendingDeletion::FPMRelease, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= PENDINGDEL_POOL_INITED;
	if (!g_QueuedMsgPool.Initialize(sizeof(CQueuedMsg), CQueuedMsg::FPMAlloc, CQueuedMsg::FPMInitialize, CQueuedMsg::FPMRelease, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= QUEUEDMSG_POOL_INITED;
	if (!g_WorkerJobPool.Initialize(sizeof(CWorkerJob), CWorkerJob::FPMAlloc, CWorkerJob::FPMInitialize, CWorkerJob::FPMRelease, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= WORKERJOB_POOL_INITED;
	if (!g_MemoryBlockTinyPool.Initialize(sizeof(CMemoryBlockTiny), CMemoryBlockTiny::FPMAlloc, NULL, NULL, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= MEMBLOCKTINY_POOL_INITED;

	if (!g_MemoryBlockSmallPool.Initialize(sizeof(CMemoryBlockSmall), CMemoryBlockSmall::FPMAlloc, NULL, NULL, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= MEMBLOCKSMALL_POOL_INITED;

	if (!g_MemoryBlockMediumPool.Initialize(sizeof(CMemoryBlockMedium), CMemoryBlockMedium::FPMAlloc, NULL, NULL, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= MEMBLOCKMED_POOL_INITED;

	if (!g_MemoryBlockLargePool.Initialize(sizeof(CMemoryBlockLarge), CMemoryBlockLarge::FPMAlloc, NULL, NULL, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= MEMBLOCKLARGE_POOL_INITED;

	if (!g_MemoryBlockHugePool.Initialize(sizeof(CMemoryBlockHuge), CMemoryBlockHuge::FPMAlloc, NULL, NULL, NULL))
	{
		goto Failure;
	}
	g_dwCoreInitFlags |= MEMBLOCKHUGE_POOL_INITED;

	return TRUE;

Failure:
	DNGlobalsDeInit();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNGlobalsDeInit"
VOID DNGlobalsDeInit()
{
	if (g_dwCoreInitFlags & REFCOUNTBUFFER_POOL_INITED)
	{
		g_RefCountBufferPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & SYNCEVENT_POOL_INITED)
	{
		g_SyncEventPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & CONNECTION_POOL_INITED)
	{
		g_ConnectionPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & GRPCONNECTION_POOL_INITED)
	{
		g_GroupConnectionPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & GRPMEMBER_POOL_INITED)
	{
		g_GroupMemberPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & NTENTRY_POOL_INITED)
	{
		g_NameTableEntryPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & NTOP_POOL_INITED)
	{
		g_NameTableOpPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & ASYNCOP_POOL_INITED)
	{
		g_AsyncOpPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & PENDINGDEL_POOL_INITED)
	{
		g_PendingDeletionPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & QUEUEDMSG_POOL_INITED)
	{
		g_QueuedMsgPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & WORKERJOB_POOL_INITED)
	{
		g_WorkerJobPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & MEMBLOCKTINY_POOL_INITED)
	{
		g_MemoryBlockTinyPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & MEMBLOCKSMALL_POOL_INITED)
	{
		g_MemoryBlockSmallPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & MEMBLOCKMED_POOL_INITED)
	{
		g_MemoryBlockMediumPool.DeInitialize();
	}
	if (g_dwCoreInitFlags & MEMBLOCKLARGE_POOL_INITED)
	{
		g_MemoryBlockLargePool.DeInitialize();
	}
	if (g_dwCoreInitFlags & MEMBLOCKHUGE_POOL_INITED)
	{
		g_MemoryBlockHugePool.DeInitialize();
	}

	g_dwCoreInitFlags = 0;
}

#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
STDAPI DllRegisterServer()
{
	CRegistry creg;

#if !defined(DBG) || !defined( DIRECTX_REDIST )
#define MAIN_DLL_NAME L"dpnet.dll"
#else
// For redist debug builds we append a 'd' to the name to allow both debug and retail to be installed on the system
#define MAIN_DLL_NAME L"dpnetd.dll"
#endif //  !defined(DBG) || !defined( DIRECTX_REDIST )

	if (!DNAddressRegister(MAIN_DLL_NAME))
	{
		DPFERR( "Could not register addressing object" );
		return E_FAIL;
	}
	if (!DNWsockRegister(MAIN_DLL_NAME))
	{
		DPFERR( "Could not register wsock object" );
		return E_FAIL;
	}
#ifndef DPNBUILD_NOSERIALSP
	if (!DNModemRegister(MAIN_DLL_NAME))
	{
		DPFERR( "Could not register serial object" );
		return E_FAIL;
	}
#endif // ! DPNBUILD_NOSERIALSP
#ifndef DPNBUILD_NOBLUETOOTHSP
	if (!DNBtspRegister(MAIN_DLL_NAME))
	{
		DPFERR( "Could not register bluetooth object" );
		return E_FAIL;
	}
#endif //!DPNBUILD_NOBLUETOOTHSP
#ifndef DPNBUILD_NOLOBBY
	if (!DNLobbyRegister(MAIN_DLL_NAME))
	{
		DPFERR( "Could not register lobby object" );
		return E_FAIL;
	}
#endif // ! DPNBUILD_NOLOBBY

	if( !CRegistry::Register( L"DirectPlay8.Client.1", L"DirectPlay8Client Object", 
							  MAIN_DLL_NAME, &CLSID_DirectPlay8Client, L"DirectPlay8.Client") )
	{
		DPFERR( "Could not register dp8 client object" );
		return E_FAIL;
	}

#ifndef DPNBUILD_NOSERVER
	if( !CRegistry::Register( L"DirectPlay8.Server.1", L"DirectPlay8Server Object", 
							  MAIN_DLL_NAME, &CLSID_DirectPlay8Server, L"DirectPlay8.Server") )
	{
		DPFERR( "Could not register dp8 server object" );
		return E_FAIL;
	}
#endif // ! DPNBUILD_NOSERVER

	if( !CRegistry::Register( L"DirectPlay8.Peer.1", L"DirectPlay8Peer Object", 
							  MAIN_DLL_NAME, &CLSID_DirectPlay8Peer, L"DirectPlay8.Peer") )
	{
		DPFERR( "Could not register dp8 peer object" );
		return E_FAIL;
	}

#ifndef DPNBUILD_NOMULTICAST
	if( !CRegistry::Register( L"DirectPlay8.Multicast.1", L"DirectPlay8Multicast Object", 
							  MAIN_DLL_NAME, &CLSID_DirectPlay8Multicast, L"DirectPlay8.Multicast") )
	{
		DPFERR( "Could not register dp8 multicast object" );
		return E_FAIL;
	}
#endif // ! DPNBUILD_NOMULTICAST

	if (!DPThreadPoolRegister(MAIN_DLL_NAME))
	{
		DPFERR( "Could not register thread pool object" );
		return E_FAIL;
	}

	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
STDAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;
	CRegistry creg;

	// If any one of these fails, we keep going hoping to remove as much of our stuff as possible

	if( !CRegistry::UnRegister(&CLSID_DirectPlay8Client) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister client object" );
		fFailed = TRUE;
	}

#ifndef DPNBUILD_NOSERVER
	if( !CRegistry::UnRegister(&CLSID_DirectPlay8Server) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister server object" );
		fFailed = TRUE;
	}
#endif // ! DPNBUILD_NOSERVER

	if( !CRegistry::UnRegister(&CLSID_DirectPlay8Peer) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister peer object" );
		fFailed = TRUE;
	}

#ifndef DPNBUILD_NOMULTICAST
	if( !CRegistry::UnRegister(&CLSID_DirectPlay8Multicast) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister multicast object" );
		fFailed = TRUE;
	}
#endif // ! DPNBUILD_NOMULTICAST

	// TODO: MASONB: Why are we setting fCreate to TRUE here?
	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot remove SP sub-area, does not exist" );
		fFailed = TRUE;
	}
	else
	{
		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_SP_SUB)[1] ) )
		{
			DPFERR( "Cannot remove SP sub-key, could have elements" );
		}
	}
	if (!DPThreadPoolUnRegister())
	{
		DPFERR( "Could not un-register thread pool object" );
		fFailed = TRUE;
	}

	if (!DNAddressUnRegister())
	{
		DPFERR( "Could not un-register addressing object" );
		fFailed = TRUE;
	}
	if (!DNWsockUnRegister())
	{
		DPFERR( "Could not un-register wsock object" );
		fFailed = TRUE;
	}
#ifndef DPNBUILD_NOSERIALSP
	if (!DNModemUnRegister())
	{
		DPFERR( "Could not un-register serial object" );
		fFailed = TRUE;
	}
#endif // ! DPNBUILD_NOSERIALSP
#ifndef DPNBUILD_NOBLUETOOTHSP
	if (!DNBtspUnregister())
	{
		DPFERR( "Could not unregister bluetooth object" );
		fFailed = TRUE;
	}
#endif //!DPNBUILD_NOBLUETOOTHSP
#ifndef DPNBUILD_NOLOBBY
	if (!DNLobbyUnRegister())
	{
		DPFERR( "Could not un-register lobby object" );
		fFailed = TRUE;
	}
#endif // ! DPNBUILD_NOLOBBY

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#endif // !DPNBUILD_NOCOMREGISTER



#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

BOOL APIENTRY DllMain( HANDLE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	switch ( ul_reason_for_call )
	{
		case DLL_PROCESS_ATTACH:
		{
#ifdef DPNBUILD_FIXEDMEMORYMODEL
#ifdef DPNBUILD_LIBINTERFACE
			XDP8STARTUP_PARAMS *pDP8StartupParams = (XDP8STARTUP_PARAMS*) hModule;

			if (DNOSIndirectionInit((DWORD_PTR) pDP8StartupParams->dwMaxMemUsage) == FALSE)
#else // ! DPNBUILD_LIBINTERFACE
// We can't build this way
Cannot build using FIXEDMEMORYMODEL without LIBINTERFACE!
#endif // ! DPNBUILD_LIBINTERFACE
#else // ! DPNBUILD_FIXEDMEMORYMODEL
			if (DNOSIndirectionInit(0) == FALSE)
#endif // ! DPNBUILD_FIXEDMEMORYMODEL
			{
				DPFX(DPFPREP, 0,"Failed to initialize OS indirection layer");
				return FALSE;
			}

#ifdef UNICODE
			// Make sure no one is trying to run the UNICODE version on Win9x
			// This must come after DNOSIndirectionInit()
			DNASSERT(IsUnicodePlatform);
#endif // UNICODE

			if (FAILED(COM_Init()))
			{
				DPFX(DPFPREP, 0,"Failed to initialize COM indirection layer");
				DNOSIndirectionDeinit();
				return FALSE;
			}
			if (!DNGlobalsInit(hModule))
			{
				DPFX(DPFPREP, 0,"Failed to initialize core pools");
				COM_Free();
				DNOSIndirectionDeinit();
				return FALSE;
			}
			//  Trigger timer and memory pool initialization for the Protocol 
			if (DNPPoolsInit(hModule) == FALSE)
			{
				DPFX(DPFPREP, 0,"Failed to initialize protocol pools");
				DNGlobalsDeInit();
				COM_Free();
				DNOSIndirectionDeinit();
				return FALSE;
			}
			if (DPThreadPoolInit(hModule) == FALSE)
			{
				DPFX(DPFPREP, 0,"Failed to initialize thread pool");
				DNPPoolsDeinit();
				DNGlobalsDeInit();
				COM_Free();
				DNOSIndirectionDeinit();
				return FALSE;
			}
			// Initialize the Address component
			if (!DNAddressInit(hModule))
			{
				DPFX(DPFPREP, 0,"Failed to initialize addressing object");
				DPThreadPoolDeInit();
				DNPPoolsDeinit();
				DNGlobalsDeInit();
				COM_Free();
				DNOSIndirectionDeinit();
				return FALSE;
			}

			// Initialize the Wsock component
			if (!DNWsockInit(hModule))
			{
				DPFX(DPFPREP, 0,"Failed to initialize wsock object");
				DNAddressDeInit();
				DPThreadPoolDeInit();
				DNPPoolsDeinit();
				DNGlobalsDeInit();
				COM_Free();
				DNOSIndirectionDeinit();
				return FALSE;
			}

#ifndef DPNBUILD_NOSERIALSP
			// Initialize the Serial component
			if (!DNModemInit(hModule))
			{
				DPFX(DPFPREP, 0,"Failed to initialize serial object");
				DPThreadPoolDeInit();
				DNWsockDeInit();
				DNAddressDeInit();
				DNPPoolsDeinit();
				DNGlobalsDeInit();
				COM_Free();
				DNOSIndirectionDeinit();
				return FALSE;
			}
#endif // ! DPNBUILD_NOSERIALSP
#ifndef DPNBUILD_NOBLUETOOTHSP
			//Initialize the Bluetooth component
			if (!DNBtspInit())
			{
				DPFX(DPFPREP, 0,"Failed to initialize bluetooth object");
#ifndef DPNBUILD_NOSERIALSP
				DNModemDeInit();
#endif // !DPNBUILD_NOSERIALSP
				DPThreadPoolDeInit();
				DNWsockDeInit();
				DNAddressDeInit();
				DNPPoolsDeinit();
				DNGlobalsDeInit();
				COM_Free();
				DNOSIndirectionDeinit();
				return FALSE;
			}
#endif	// ! DPNBUILD_NOBLUETOOTHSP

#ifndef DPNBUILD_NOLOBBY
			// Initialize the Lobby component
			if (!DNLobbyInit(hModule))
			{
				DPFX(DPFPREP, 0,"Failed to initialize lobby object");
#ifndef DPNBUILD_NOBLUETOOTHSP
				DNBtspDeInit();
#endif // ! DPNBUILD_NOBLUETOOTHSP
#ifndef DPNBUILD_NOSERIALSP
				DNModemDeInit();
#endif // ! DPNBUILD_NOSERIALSP
				DNWsockDeInit();
				DNAddressDeInit();
				DPThreadPoolDeInit();
				DNPPoolsDeinit();
				DNGlobalsDeInit();
				COM_Free();
				DNOSIndirectionDeinit();
				return FALSE;
			}
#endif // ! DPNBUILD_NOLOBBY

			DNASSERT(DNMemoryTrackAreAllocationsAllowed());
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
			DNMemoryTrackAllowAllocations(FALSE);
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

#ifndef DPNBUILD_LIBINTERFACE
			// We don't need to receive DLL_THREAD_ATTACH and DLL_THREAD_DETACH notification
			DisableThreadLibraryCalls((HMODULE)hModule);
#endif // ! DPNBUILD_LIBINTERFACE

			break;
		}

		case DLL_PROCESS_DETACH:
		{
#ifndef DPNBUILD_NOLOBBY
			DPFX(DPFPREP, 5, "Deinitializing Lobby");
			DNLobbyDeInit();
#endif // ! DPNBUILD_NOLOBBY
#ifndef DPNBUILD_NOBLUETOOTHSP
			DPFX(DPFPREP, 5, "Deinitializing Bluetooth SP");
			DNBtspDeInit();
#endif // ! DPNBUILD_NOBLUETOOTHSP
#ifndef DPNBUILD_NOSERIALSP
			DPFX(DPFPREP, 5, "Deinitializing Modem SP");
			DNModemDeInit();
#endif // ! DPNBUILD_NOSERIALSP
			DPFX(DPFPREP, 5, "Deinitializing WSock SP");
			DNWsockDeInit();
			DPFX(DPFPREP, 5, "Deinitializing Addressing");
			DNAddressDeInit();
			DPFX(DPFPREP, 5, "Deinitializing Thread Pool");
			DPThreadPoolDeInit();
			DPFX(DPFPREP, 5, "Deinitializing Protocol");
			DNPPoolsDeinit();
			DPFX(DPFPREP, 5, "Deinitializing Core");
			DNGlobalsDeInit();
			DPFX(DPFPREP, 5, "Deinitializing COM Layer");
			COM_Free();
			DPFX(DPFPREP, 5, "Deinitializing OS Indirection Layer");
			DNOSIndirectionDeinit();
			DPFX(DPFPREP, 5, "All deinitialized");
			break;
		}
	}

	return TRUE;
}


#ifdef DPNBUILD_LIBINTERFACE

#undef DPF_MODNAME
#define DPF_MODNAME "XDirectPlay8Startup"
HRESULT WINAPI XDirectPlay8Startup( const XDP8STARTUP_PARAMS * const pDP8StartupParams )
{
#ifndef DPNBUILD_NOPARAMVAL
	if ((pDP8StartupParams == NULL) ||
		(! DNVALID_READPTR(pDP8StartupParams, sizeof(XDP8STARTUP_PARAMS))))
	{
		DPFX(DPFPREP, 0, "Invalid pointer to Startup parameters!");
		return DPNERR_INVALIDPOINTER;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	//
	// Initialize DirectPlay.
	//
	if (! DllMain((HANDLE) pDP8StartupParams, DLL_PROCESS_ATTACH, NULL))
	{
		DPFX(DPFPREP, 0, "Starting DirectPlay8 failed!");
		return DPNERR_OUTOFMEMORY;
	}

	//
	// Save the startup flags for later reference.
	//
	g_dwDP8StartupFlags = pDP8StartupParams->dwFlags;

	
	DPFX(DPFPREP, 1, "Starting DirectPlay8 succeeded.");

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "XDirectPlay8Cleanup"
HRESULT WINAPI XDirectPlay8Cleanup( void )
{
	HRESULT		hr;

	
	if (DllMain(INVALID_HANDLE_VALUE, DLL_PROCESS_DETACH, NULL))
	{
		DPFX(DPFPREP, 1, "Cleaning up DirectPlay8 succeeded.");
		hr = S_OK;
	}
	else
	{
		DPFX(DPFPREP, 0, "Cleaning DirectPlay8 failed!");
		hr = E_OUTOFMEMORY;
	}

	return hr;
}


#else // ! DPNBUILD_LIBINTERFACE


#undef DPF_MODNAME
#define DPF_MODNAME "DllGetClassObject"

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
	if (rclsid == CLSID_DirectPlay8Client)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &DNCF_Vtbl, &g_lCoreObjectCount);
	}
#ifndef DPNBUILD_NOSERVER
	else if (rclsid == CLSID_DirectPlay8Server)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &DNCF_Vtbl, &g_lCoreObjectCount);
	}
#endif // ! DPNBUILD_NOSERVER
	else if (rclsid == CLSID_DirectPlay8Peer)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &DNCF_Vtbl, &g_lCoreObjectCount);
	}
#ifndef DPNBUILD_NOMULTICAST
	else if (rclsid == CLSID_DirectPlay8Multicast)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &DNCF_Vtbl, &g_lCoreObjectCount);
	}
#endif // ! DPNBUILD_NOMULTICAST
	else if (rclsid == CLSID_DirectPlay8Address)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &DP8ACF_Vtbl, &g_lCoreObjectCount);
	}
	else if (rclsid == CLSID_DP8SP_TCPIP)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &TCPIPClassFactoryVtbl, &g_lCoreObjectCount);
	}
#ifndef DPNBUILD_NOSERIALSP
	else if (rclsid == CLSID_DP8SP_MODEM)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &ModemClassFactoryVtbl, &g_lCoreObjectCount);
	}
	else if (rclsid == CLSID_DP8SP_SERIAL)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &SerialClassFactoryVtbl, &g_lCoreObjectCount);
	}
#endif // !DPNBUILD_NOSERIALSP
#ifndef DPNBUILD_NOBLUETOOTHSP
	else if (rclsid == CLSID_DP8SP_BLUETOOTH)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &DP8BluetoothClassFac_Vtbl, &g_lCoreObjectCount);
	}
#endif // ! DPNBUILD_NOBLUETOOTHSP
#ifndef DPNBUILD_NOIPX
	else if (rclsid == CLSID_DP8SP_IPX)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &IPXClassFactoryVtbl, &g_lCoreObjectCount);
	}
#endif // ! DPNBUILD_NOIPX
#ifndef DPNBUILD_NOLOBBY
	else if (rclsid == CLSID_DirectPlay8LobbiedApplication)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &DPLCF_Vtbl, &g_lCoreObjectCount);
	}
	else if (rclsid == CLSID_DirectPlay8LobbyClient)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &DPLCF_Vtbl, &g_lCoreObjectCount);
	}
#endif // ! DPNBUILD_NOLOBBY
	else if (rclsid == CLSID_DirectPlay8ThreadPool)
	{
		return DPCFUtil_DllGetClassObject(rclsid, riid, ppv, &DPTPCF_Vtbl, &g_lCoreObjectCount);
	}
	else
	{
		DPFX(DPFPREP, 0, "Class ID is not supported by this DLL!");
		return CLASS_E_CLASSNOTAVAILABLE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllCanUnloadNow"

STDAPI DllCanUnloadNow(void)
{
	DPFX(DPFPREP, 3,"Parameters: (none)");

	DPFX(DPFPREP, 5,"g_lCoreObjectCount = %ld", g_lCoreObjectCount);

	if (g_lCoreObjectCount == 0
		&& DPThreadPoolGetRemainingObjectCount() == 0
		&& DNAddressGetRemainingObjectCount() == 0
#ifndef DPNBUILD_NOSERIALSP
		&& DNModemGetRemainingObjectCount() == 0
#endif // !DPNBUILD_NOSERIALSP
#ifndef DPNBUILD_NOBLUETOOTHSP
		&& DNBtspGetRemainingObjectCount() == 0
#endif // !DPNBUILD_NOBLUETOOTHSP
		&& DNWsockGetRemainingObjectCount() == 0
#ifndef DPNBUILD_NOLOBBY
		&& DNLobbyGetRemainingObjectCount() == 0
#endif // ! DPNBUILD_NOLOBBY
		)
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\coreconnect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connect.cpp
 *  Content:    DNET connection routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/01/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/23/99	mjn		Fixed Host and AllPlayers short-cut pointer use
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	12/29/99	mjn		Turned off Instance GUID verification - TODO - turn back on !
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/07/00	mjn		DNHostVerifyConnect ensures connection to Host player only
 *	01/08/00	mjn		Failed connection returns HRESULT and buffer from Host
 *	01/08/00	mjn		Added group owner to NameTable
 *	01/08/00	mjn		Changed DNERR_INVALIDHOST to DNERR_NOTHOST
 *	01/08/00	mjn		Removed unused connection info
 *	01/09/00	mjn		Transfer Application Description at connect
 *	01/10/00	mjn		Fixed Application Description usage
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/13/00	mjn		Removed DIRECTNETOBJECT from Pack/UnpackApplicationDesc
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY
 *	01/14/00	mjn		Added password to DN_APPLICATION_DESC_PACKED_INFO
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/17/00	mjn		Fixed ConnectToPeer function names
 *	01/18/00	mjn		Moved Pack/UnpackNameTableInfo to NameTable.cpp
 *	01/24/00	mjn		Replaced on-wire message pointers to offsets
 *	02/01/00	mjn		Implement Player/Group context values
 *	03/23/00	mjn		Set player context through Connect
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/03/00	mjn		Verify DNET version on connect
 *	04/09/00	mjn		Modified Connect process to use CAsyncOp
 *	04/16/00	mjn		DNSendMessage() uses CAsyncOp
 *	04/18/00	mjn		CConnection tracks connection status better
 *				mjn		Fixed player count problem
 *				mjn		Return connect user reply buffer
 *	04/19/00	mjn		Fixed DNConnectToHost2 to set DirectNet object flags to CONNECTED
 *				mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	04/20/00	mjn		Host queries for connecting players' address if not specified
 *	05/03/00	mjn		Prevent unrequired RETURN_BUFFER message when CONNECT fails on Host player
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/08/00	mjn		Host sets connecting player's Connection as soon as player entry created
 *	05/09/00	mjn		Fixed New Player connection sequence to send NAMETABLE_ACK earlier
 *	05/23/00	mjn		Added DNConnectToPeerFailed()
 *	06/14/00	mjn		Added DNGetLocalAddress()
 *	06/19/00	mjn		Fixed connect process to better handle ALL_ADAPTERS case
 *	06/22/00	mjn		NameTable::UnpackNameTableInfo() returns local players DPNID
 *				mjn		Replace CConnection::MakeConnecting(),MakeConnected() with SetStatus()
 *	06/24/00	mjn		Added DNHostDropPlayer() to handle failed existing player connects to new players
 *	06/25/00	mjn		Added code to update lobby when DISCONNECTED
 *	06/26/00	mjn		Indicate COULDNOTCONNECT to lobby if connect to Host fails
 *	06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *				mjn		Host will attempt to determine connecting player's address if not specified in connect block
 *	07/05/00	mjn		More robust handling of disconnecting joining players during connection process
 *	07/06/00	mjn		More connect fixes
 *	07/20/00	mjn		The CONNECT process was revamped - new completions, asyncop structure, messages
 *				mjn		Better error handling for shutdown in DNHostVerifyConnect()
 *				mjn		Fixed up DNHostDropPlayer() to inform NewPlayer of drop
 *	07/21/00	mjn		Added code to handle unreachable players during connect process
 *	07/22/00	mjn		Extract connecting player's DNET version
 *	07/25/00	mjn		Update connect parent async op's result at end of DNConnectToHost2()
 *	07/27/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *	07/29/00	mjn		Save connection in DNConnectToHost1() on connect parent for better clean up
 *	07/30/00	mjn		Renamed DNGetLocalAddress() to DNGetLocalDeviceAddress()
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *	08/02/00	mjn		Removed unused code
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/05/00	rmt		Bug #41356 - DPLAY8: CORE: Connections refused by DPlay leak address objects
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/08/00	mjn		Mark groups created after CREATE_GROUP
 *  08/15/00	rmt		Bug #42506 - DPLAY8: LOBBY: Automatic connection settings not being sent
 *	08/25/00	mjn		Perform queued NameTable operations in DNConnectToHost2()
 *	08/28/00	mjn		Only compare major version numbers in DNHostVerifyConnect()
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/05/00	mjn		Set NameTable DPNID mask when connecting
 *	09/13/00	mjn		Perform queued operations after creating group in DNConnectToHost2()
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	09/26/00	mjn		Removed locking from CNameTable::SetVersion() and CNameTable::GetNewVersion()
 *	09/27/00	mjn		ACK nametable to Host after creating groups and local and host players
 *	10/11/00	mjn		Fixed up DNAbortConnect() and use it instead of DNConnectToHostFailed()
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	02/12/01	mjn		Fixed CConnection::GetEndPt() to track calling thread
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	04/05/01	mjn		Call DNHostDisconnect() with DPNDESTROYPLAYERREASON_NORMAL in DNHostConnect1()
 *	05/07/01	vpo		Whistler 384350: "DPLAY8: CORE: Messages from server can be indicated before connect completes"
 *	05/22/01	mjn		Properly set DirectNetObject as CONNECTED for successful client connect
 *	06/03/01	mjn		Don't clean up connect parent from DirectNetObject in DNAbortConnect() (will be done in DNTerminateSession())
 *	06/08/01	mjn		Disconnect connection in DNConnectToHostFailed()
 *	06/25/01	mjn		Use connect address for host if missing when installing name table in DNConnectToHost2()
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//
//	Accept a connection from a NewPlayer as the Host in peer-to-peer, or as the Server in
//	Client-Server modes.
//
//	The connection process is a multi part affair, requiring a bit of
//	synchronization between the Host and the NewPlayer.
//
//	In the first part:
//		The Host waits for the NewPlayer to send player game info
//		The Host verifies that everything is in order
//	If everything is okay:
//		The Host assigns the NewPlayer a DNID,
//		Adds the NewPlayer to the Host's NameTable,
//		Sends the NameTable to the NewPlayer,
//		Sends an ADD_PLAYER message to existing players to add NewPlayer to their NameTable's
//	Otherwise:
//		Inform NewPlayer that connection process failed
//
//	In the second part:
//		The Host awaits confirmation from the NewPlayer that the table was received AND installed.
//		The Host instructs existing players to connect to the NewPlayer
//


//	DNHostConnect1
//
//	Called once the connecting player has sent his player info.
//
//	- Verify NewPlayer and application info
//	- Assign a DNID to NewPlayer
//	- Add NewPlayer to Host's NameTable
//	- Send Name table to NewPlayer
//	- Send ADD_PLAYER message to existing players
//
//		LPVOID				lpvData			Player and application info
//		DWORD				dwBufferSize	Size of player and application info
//		HANDLE				hEndPt			End point handle

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostConnect1"

HRESULT DNHostConnect1(DIRECTNETOBJECT *const pdnObject,
					   const PVOID pvBuffer,
					   const DWORD dwBufferSize,
					   CConnection *const pConnection)
{
	HRESULT		hResultCode;
	UNALIGNED WCHAR	*pwszName;
	UNALIGNED WCHAR	*pwszPassword;
	PVOID		pvData;
	PVOID		pvConnectData;
	UNALIGNED DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO	*pInfo;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pAllPlayersGroup;
	CPackedBuffer		packedBuffer;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	IDirectPlay8Address	*pAddress;
	CPackedBuffer		PackedBuffer;
	void				*pvPlayerContext;
	BOOL		bPlayerVerified;
	BOOL		fDisconnect;
	HANDLE		hEndPt;
	void		*pvReplyBuffer;
	DWORD		dwReplyBufferSize;
	void		*pvReplyBufferContext;
	CCallbackThread		CallbackThread;
#ifdef DBG
	TCHAR				DP8ABuffer[512] = {0};
	DWORD				DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p], dwBufferSize [%ld], pConnection [0x%p]",pvBuffer,dwBufferSize,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);
	DNASSERT(pConnection != NULL);

	pAddress = NULL;
	pRefCountBuffer = NULL;
	pNTEntry = NULL;
	pAllPlayersGroup = NULL;
	pWorkerJob = NULL;
	bPlayerVerified = FALSE;
	pvReplyBuffer = NULL;
	dwReplyBufferSize = 0;
	pvReplyBufferContext = NULL;
	CallbackThread.Initialize();

	//
	//	Extract player and application info
	//
	pInfo = static_cast<DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO*>(pvBuffer);
	if (pInfo->dwNameOffset)
	{
		pwszName = reinterpret_cast<UNALIGNED WCHAR*>(static_cast<BYTE*>(pvBuffer) + pInfo->dwNameOffset);
	}
	else
	{
		pwszName = NULL;
	}

	if (pInfo->dwPasswordOffset)
	{
		pwszPassword = reinterpret_cast<UNALIGNED WCHAR*>(static_cast<BYTE*>(pvBuffer) + pInfo->dwPasswordOffset);
	}
	else
	{
		pwszPassword = NULL;
	}

	if (pInfo->dwDataOffset)
	{
		pvData = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pInfo->dwDataOffset);
	}
	else
	{
		pvData = NULL;
	}

	if (pInfo->dwConnectDataOffset)
	{
		pvConnectData = (PVOID)((char *)pvBuffer + pInfo->dwConnectDataOffset);
	}
	else
	{
		pvConnectData = NULL;
	}

	if (pInfo->dwURLOffset)
	{
#ifdef DPNBUILD_LIBINTERFACE
		hResultCode = DP8ACF_CreateInstance(IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pAddress));
#else // ! DPNBUILD_LIBINTERFACE
		hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pAddress),
											FALSE);
#endif // ! DPNBUILD_LIBINTERFACE
		if (hResultCode != S_OK)
		{
			DPFERR("Could not create IDirectPlay8Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			return(hResultCode);
		}

		DPFX(DPFPREP, 5,"Connecting Player URL [%hs]",static_cast<char*>(pvBuffer) + pInfo->dwURLOffset);
		if ((hResultCode = IDirectPlay8Address_BuildFromURLA(	pAddress,
															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
		{
			DPFERR("Could not build IDirectPlay8Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 5,"No address URL specified - Host will have to determine it");
		if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
		{
			DPFERR("Could not retrieve EndPoint from Connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		hResultCode = DNGetClearAddress(pdnObject,hEndPt,&pAddress,TRUE);

		pConnection->ReleaseEndPt(&CallbackThread);

		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not determine Clear Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
#ifdef DBG
		DP8ASize = 512;
		IDirectPlay8Address_GetURL(pAddress,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 5,"Remote Address [%s]",DP8ABuffer);
#endif // DBG
	}

#ifdef DBG
	if (pwszName != NULL)
	{
		if ((((DWORD_PTR) pwszName) % sizeof (WCHAR)) == 0)
		{
			DPFX(DPFPREP, 5,"Connecting Player: Name [%ls], Data Size [%ld], Connect Data Size [%ld]",
				pwszName,pInfo->dwDataSize,pInfo->dwConnectDataSize);
		}
		else
		{
			DPFX(DPFPREP, 5,"Connecting Player: Name [unaligned_name], Data Size [%ld], Connect Data Size [%ld]",
				pInfo->dwDataSize,pInfo->dwConnectDataSize);
		}
	}
	else
	{
		DPFX(DPFPREP, 5,"Connecting Player: No name, Data Size [%ld], Connect Data Size [%ld]",
			pInfo->dwDataSize,pInfo->dwConnectDataSize);
	}
#endif // DBG

	//
	//	Avoid alignment errors
	//
	GUID guidApplication;
	GUID guidInstance;
	guidApplication = pInfo->guidApplication;
	guidInstance = pInfo->guidInstance;

	//
	//	Ensure this connect is valid
	//
	if ((hResultCode = DNHostVerifyConnect(	pdnObject,
											pConnection,
											pInfo->dwFlags,
											pInfo->dwDNETVersion,
											pwszPassword,
											&guidApplication,
											&guidInstance,
											pvConnectData,
											pInfo->dwConnectDataSize,
											pAddress,
											&pvPlayerContext,
											&pvReplyBuffer,
											&dwReplyBufferSize,
											&pvReplyBufferContext)) != DPN_OK)
	{
		DPFX(DPFPREP, 5,"Connect failed, hResultCode = [0x%lx]",hResultCode);

		//
		//	Disconnect this connection.   We will also remove it from the indicated list.
		//
		DNEnterCriticalSection(&pdnObject->csConnectionList);
		if (!pConnection->m_bilinkIndicated.IsEmpty())
		{
			pConnection->Release();
		}
		pConnection->m_bilinkIndicated.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csConnectionList);

		pConnection->Disconnect();	// Terminate this connection

		hResultCode = DPN_OK;	// We handled everything okay !
		goto Failure;			// For clean up
	}

	bPlayerVerified = TRUE;

	//
	//	I am assuming that the player count has been updated by HostVerifyConnect.
	//	That means that until we flag the connection as CONNECTed, we will manually
	//	have to decrement it.
	//

	//
	// Create player entry
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not get new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// This function takes the lock internally
	pNTEntry->UpdateEntryInfo(	pwszName,
								pInfo->dwNameSize,
								pvData,
								pInfo->dwDataSize,
								DPNINFO_NAME | DPNINFO_DATA,
								FALSE);

	pNTEntry->SetDNETVersion( pInfo->dwDNETVersion );
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		pNTEntry->MakePeer();
	}
	else
	{
		pNTEntry->MakeClient();
	}

	if (pvPlayerContext)
	{
		pNTEntry->SetContext(pvPlayerContext);
	}
	pNTEntry->StartConnecting();
	pNTEntry->SetIndicated();
	pNTEntry->NotifyAddRef();
	pNTEntry->SetAddress(pAddress);
	IDirectPlay8Address_Release(pAddress);
	pAddress = NULL;

	//
	//	Add player to NameTable
	//
	if ((hResultCode = pdnObject->NameTable.AddEntry(pNTEntry)) != DPN_OK)
	{
		pdnObject->NameTable.Unlock();
		DPFERR("Could not add entry to NameTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Set up connection
	//	The connection should be "CONNECTING" or a disconnect has been issued since the NewPlayer sent
	//	their connect info.  Once the DPNID is set on the connection, the standard disconnect handler
	//	will take care of clean up.  If the DPNID is NOT set on the connection, the disconnect code
	//	will just release the connection, without cleaning up the NameTable or the NameTableEntry.
	//	Since the NameTable version may have changed since the NewPlayer was added, we will need to
	//	delete the player from the NameTable (and generate a new version number).  We will flag this
	//	case, and just send out the DELETE_PLAYER message after sending out the ADD_PLAYER
	//
	pConnection->Lock();
	if (pConnection->IsConnecting())
	{
		pConnection->SetStatus( CONNECTED );
		fDisconnect = FALSE;
	}
	else
	{
		DPFX(DPFPREP, 5,"NewPlayer has disconnected while joining - send out ADD_PLAYER and then DELETE_PLAYER");
		fDisconnect = TRUE;
	}
	pConnection->SetDPNID( pNTEntry->GetDPNID() );
	pNTEntry->SetConnection( pConnection );
	pConnection->Unlock();

	//
	//	Now that this connection is part of the NameTableEntry, remove it from the indicated list.
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	if (!pConnection->m_bilinkIndicated.IsEmpty())
	{
		pConnection->Release();
	}
	pConnection->m_bilinkIndicated.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	//
	//	Send name table to player
	//
	if (!fDisconnect)
	{
		hResultCode = DNSendConnectInfo(pdnObject,pNTEntry,pConnection,pvReplyBuffer,dwReplyBufferSize);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not send name table to player");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
#pragma TODO(minara,"Clean up here")
			goto Failure;
		}
	}
	if (pvReplyBuffer)
	{
		DNUserReturnBuffer(pdnObject,DPN_OK,pvReplyBuffer,pvReplyBufferContext);
		pvReplyBuffer = NULL;
		dwReplyBufferSize = 0;
		pvReplyBufferContext = NULL;
	}

	//
	// Setup name table entry to be passed to other players
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		packedBuffer.Initialize(NULL,0);
		if ((hResultCode = pNTEntry->PackEntryInfo(&packedBuffer)) != DPNERR_BUFFERTOOSMALL)
		{
			DPFERR("Unknown error encountered trying to pack NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if ((hResultCode = RefCountBufferNew(pdnObject,packedBuffer.GetSizeRequired(),MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create new RefCountBuffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
		if ((hResultCode = pNTEntry->PackEntryInfo(&packedBuffer)) != DPN_OK)
		{
			DPFERR("Could not pack NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		//
		//	Send ADD_PLAYER messages to other players (with lower versions)
		//
		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create worker thread job (add player)");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_ADD_PLAYER );
		pWorkerJob->SetSendNameTableOperationVersion( pNTEntry->GetVersion() );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	//
	//	If we were in the process of disconnecting, we will need to clean up now
	//
	if (fDisconnect)
	{
		DNHostDisconnect(pdnObject,pNTEntry->GetDPNID(),DPNDESTROYPLAYERREASON_NORMAL);
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	// Now, wait for synchronization (player has loaded name table)

	hResultCode = DPN_OK;

Exit:
	CallbackThread.Deinitialize();
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pvReplyBuffer)
	{
		//
		//	Return buffer to HostPlayer
		//
		DNUserReturnBuffer(pdnObject,DPN_OK,pvReplyBuffer,pvReplyBufferContext);
		pvReplyBuffer = NULL;
		dwReplyBufferSize = 0;
		pvReplyBufferContext = NULL;
	}
	if (bPlayerVerified)
	{
		pdnObject->ApplicationDesc.DecPlayerCount();
	}
	if (pAddress)
	{
		IDirectPlay8Address_Release(pAddress);
		pAddress = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pAllPlayersGroup)
	{
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	goto Exit;
}


//	DNHostConnect2
//
//	Mark player as "available" in NameTable
//	Send INSTRUCT_CONNECT messages to the existing players to add new player
//
//		CConnection		*pConnection		Connection for connecting player
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostConnect2"

HRESULT DNHostConnect2(DIRECTNETOBJECT *const pdnObject,
					   CConnection *const pConnection)
{
	HRESULT				hResultCode;
	DPNID				dpnid;
	CRefCountBuffer		*pRefCountBuffer;
	CNameTableEntry		*pNTEntry;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT	*pInfo;

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p]",pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pRefCountBuffer = NULL;
	pNTEntry = NULL;
	pWorkerJob = NULL;

	pConnection->Lock();
	dpnid = pConnection->GetDPNID();
	pConnection->Unlock();

	pdnObject->NameTable.PopulateConnection(pConnection);

	//
	// Instruct existing players to connect to NewPlayer
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DPFX(DPFPREP, 5,"Instruct existing players to connect to NewPlayer [0x%lx]",dpnid);

		// Need version number of this player
		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in nametable");
			DisplayDNError(0,hResultCode);
//			DNASSERT(FALSE);
			goto Failure;
		}

		hResultCode = RefCountBufferNew(pdnObject,
										sizeof(DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT),
										MemoryBlockAlloc,
										MemoryBlockFree,
										&pRefCountBuffer);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not create CountBuffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT*>(pRefCountBuffer->GetBufferAddress());
		pInfo->dpnid = dpnid;

		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.GetNewVersion( &pInfo->dwVersion );
		pdnObject->NameTable.Unlock();
		pInfo->dwVersionNotUsed = 0;

		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create worker thread job (add player)");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_INSTRUCT_CONNECT );
		pWorkerJob->SetSendNameTableOperationVersion( pInfo->dwVersion );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pNTEntry->Release();
		pNTEntry = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNHostVerifyConnect
//
//	Host connection verification.  Ensure that the player connecting meets ALL criteria
//	including:
//		correct mode (client/server or peer/peer)
//		correct instance guid
//		correct application (if specified)
//		correct password (if specified)
//		correct user spec (through call-back)
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostVerifyConnect"

HRESULT DNHostVerifyConnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const DWORD dwFlags,
							const DWORD dwDNETVersion,
							UNALIGNED WCHAR *const pwszPassword,
							GUID *const pguidApplication,
							GUID *const pguidInstance,
							PVOID const pvConnectData,
							const DWORD dwConnectDataSize,
							IDirectPlay8Address *const pAddress,
							void **const ppvPlayerContext,
							void **const ppvReplyBuffer,
							DWORD *const pdwReplyBufferSize,
							void **const ppvReplyBufferContext)
{
	HRESULT			hResultCode;
	HRESULT			hrFailure;
	PVOID			pvReplyData;
	DWORD			dwReplyDataSize;
	PVOID			pvReplyContext;
	DWORD			dwBufferSize;
	HANDLE			hEndPt;
	CNameTableEntry	*pLocalPlayer;
	CRefCountBuffer	*pRefCountBuffer;
	CPackedBuffer	packedBuffer;
	IDirectPlay8Address	*pDevice;
	DN_INTERNAL_MESSAGE_CONNECT_FAILED		*pInfo;
	BOOL			fDecPlayerCount;
	CCallbackThread	CallbackThread;
	GUID			guidnull;
#ifdef DBG
	TCHAR				DP8ABuffer[512] = {0};
	DWORD				DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: dwFlags [0x%lx], dwDPlay8Version [0x%lx], pwszPassword [0x%p], pguidApplication [0x%p], pguidInstance [0x%p], pvConnectData [0x%p], dwConnectDataSize [%ld]",
			dwFlags,dwDNETVersion,pwszPassword,pguidApplication,pguidInstance,pvConnectData,dwConnectDataSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppvReplyBuffer != NULL);
	DNASSERT(pdwReplyBufferSize != NULL);
	DNASSERT(ppvReplyBufferContext != NULL);

	pLocalPlayer = NULL;
	pRefCountBuffer = NULL;
	pvReplyData = NULL;
	dwReplyDataSize = 0;
	pvReplyContext = NULL;
	pDevice = NULL;
	fDecPlayerCount = FALSE;
	memset(&guidnull, 0, sizeof(guidnull));
	CallbackThread.Initialize();

	//
	//	Ensure we're not closing or host migrating
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_ALREADYCLOSING;
		goto CleanUp;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Ensure we are the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Connection received by non-host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	if (!pLocalPlayer->IsHost())
	{
		DPFERR("Connection received by non-host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Verify Mode
	//
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_PEER) && !(dwFlags & DN_OBJECT_FLAG_PEER))
	{
		DPFX(DPFPREP, 7,"Non peer player attempting connection to peer");
		hResultCode = DPNERR_INVALIDINTERFACE;
		goto Failure;
	}

#ifndef	DPNBUILD_NOSERVER
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER) && !(dwFlags & DN_OBJECT_FLAG_CLIENT))
	{
		DPFX(DPFPREP, 7,"Non client player attempting connection to server");
		hResultCode = DPNERR_INVALIDINTERFACE;
		goto Failure;
	}
#endif	// DPNBUILD_NOSERVER

	//
	//	Verify DNET version	- we will only compare the high 16-bits (major number)
	//						- we will allow different low 16-bits (minor number)
	//
	if ((dwDNETVersion & 0xffff0000) != (DN_VERSION_CURRENT & 0xffff0000))
	{
		DPFX(DPFPREP, 7,"Invalid DPlay8 version!");
		hResultCode = DPNERR_INVALIDVERSION;
		goto Failure;
	}

	//
	//	Validate instance GUID
	//
	if (pguidInstance && (*pguidInstance != guidnull))
	{
		if (!pdnObject->ApplicationDesc.IsEqualInstanceGuid(pguidInstance))
		{
			DPFERR("Invalid Instance GUID specified at connection");
			hResultCode = DPNERR_INVALIDINSTANCE;
			goto Failure;
		}
	}

	//
	//	Validate application (if specified)
	//
	if (pguidApplication && (*pguidApplication != guidnull))
	{
		if (!pdnObject->ApplicationDesc.IsEqualApplicationGuid(pguidApplication))
		{
			DPFERR("Invalid Application GUID specified at connection");
			hResultCode = DPNERR_INVALIDAPPLICATION;
			goto Failure;
		}
	}

	//
	//	Validate password
	//
	if (!pdnObject->ApplicationDesc.IsEqualPassword(pwszPassword))
	{
		DPFERR("Incorrect password (required) specified at connection");
		hResultCode = DPNERR_INVALIDPASSWORD;
		goto Failure;
	}

	//
	//	Get device address this connection came in on
	//
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
	{
		DPFERR("Could not extract endpoint from CConnection");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_GENERIC;	// Is there a better one ?
		goto Failure;
	}

	hResultCode = DNGetLocalDeviceAddress(pdnObject,hEndPt,&pDevice);

	pConnection->ReleaseEndPt(&CallbackThread);

	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not determine local device address");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_GENERIC;	// Is there a better one ?
		goto Failure;
	}
#ifdef DBG
		DP8ASize = 512;
		IDirectPlay8Address_GetURL(pDevice,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 5,"Local Device Address [%s]",DP8ABuffer);
#endif // DBG

	//
	//	Increment AppDesc count
	//
	hResultCode = pdnObject->ApplicationDesc.IncPlayerCount( TRUE );
	if (hResultCode != DPN_OK)
	{
		DPFX(DPFPREP, 7,"Could not add player to game");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fDecPlayerCount = TRUE;		// only for error handling

	//
	//	Validate user specified data (through call-back)
	//
	if (pvConnectData)
	{

		DPFX(DPFPREP, 7,"dwConnectDataSize [%ld]",dwConnectDataSize);
	}
	else
	{
		DPFX(DPFPREP, 7,"No connect data given");
	}

	if ((hResultCode = DNUserIndicateConnect(	pdnObject,
												pvConnectData,
												dwConnectDataSize,
												&pvReplyData,
												&dwReplyDataSize,
												&pvReplyContext,
												pAddress,
												pDevice,
												ppvPlayerContext)) != DPN_OK)
	{
		DPFERR("Application declined connection attempt");
		hResultCode = DPNERR_HOSTREJECTEDCONNECTION;
		goto Failure;
	}

	IDirectPlay8Address_Release(pDevice);
	pDevice = NULL;

	//
	//	Save reply buffer
	//
	if ((pvReplyData) && (dwReplyDataSize != 0))
	{
		*ppvReplyBuffer = pvReplyData;
		*pdwReplyBufferSize = dwReplyDataSize;
		*ppvReplyBufferContext = pvReplyContext;
	}
	else
	{
		*ppvReplyBuffer = NULL;
		*pdwReplyBufferSize = 0;
		*ppvReplyBufferContext = NULL;
	}

Exit:

	CallbackThread.Deinitialize();
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:

	if (fDecPlayerCount)
	{
		pdnObject->ApplicationDesc.DecPlayerCount();
	}

	//
	//	Send a message back to the connecting player that this failed
	//
	DPFX(DPFPREP, 7,"Connect failed [0x%lx]",hResultCode);
	hrFailure = hResultCode;
	if (pvReplyData == NULL)
	{
		dwReplyDataSize = 0;	// basic validation
	}
	dwBufferSize = sizeof(DN_INTERNAL_MESSAGE_CONNECT_FAILED) + dwReplyDataSize;
	DPFX(DPFPREP, 7,"Failure buffer is [%ld] bytes",dwBufferSize);

	//
	//	Create and fill failure message buffer
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,dwBufferSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto CleanUp;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_CONNECT_FAILED*>(pRefCountBuffer->GetBufferAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CONNECT_FAILED))) != DPN_OK)
	{
		DPFERR("Could not add header to message buffer");
		DisplayDNError(0,hResultCode);
		goto CleanUp;
	}
	if (pvReplyData)
	{
		if ((hResultCode = packedBuffer.AddToBack(pvReplyData,dwReplyDataSize)) != DPN_OK)
		{
			DPFERR("Could not add reply to failure buffer");
			DisplayDNError(0,hResultCode);
			goto CleanUp;
		}
		pInfo->dwReplyOffset = packedBuffer.GetTailOffset();
		pInfo->dwReplySize = dwReplyDataSize;
		DNUserReturnBuffer(pdnObject,DPN_OK,pvReplyData,pvReplyContext);	// Return buffer
	}
	else
	{
		pInfo->dwReplyOffset = 0;
		pInfo->dwReplySize = 0;
	}
	pInfo->hResultCode = hrFailure;

	//
	//	Send failure message
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_CONNECT_FAILED,
								NULL,
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

CleanUp:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pDevice)
	{
		IDirectPlay8Address_Release(pDevice);
		pDevice = NULL;
	}
	goto Exit;
}


//
//	DNHostDropPlayer
//
//	An existing player in a peer-peer game could not connect to a NewPlayer and is informing the
//	Host of this situation.  As a result, the Host will drop inform the NewPlayer of this and then
//	drop the NewPlayer from the game
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDropPlayer"

HRESULT DNHostDropPlayer(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,		//	ExistingPlayer who could not connect to NewPlayer
						 void *const pvBuffer)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	UNALIGNED DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED	*pInfo;
	DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED		*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pRefCountBuffer = NULL;
	pNTEntry = NULL;
	pConnection = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED*>(pvBuffer);
	DPFX(DPFPREP, 5,"Connection to [0x%lx] failed",pInfo->dpnid);

	//
	//	Get connection for NewPlayer
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("NewPlayer no longer in NameTable - not to worry");
		hResultCode = DPN_OK;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Connection for NewPlayer no longer valid - not to worry");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Send message to NewPlayer informing them of which existing player could not connect to them
	//
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnid = dpnid;
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED,
								pInfo->dpnid,
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send message to NewPlayer - assume he is gone or going");
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		hResultCode = DPN_OK;
		goto Failure;
	}
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	We will just drop (or at least attempt to drop) the connection
	//
	pConnection->Disconnect();
	pConnection->Release();
	pConnection = NULL;

	hResultCode = DNHostDisconnect(pdnObject,pInfo->dpnid,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//
//	Perform a connection to a host player (either host in peer-to-peer or server in client-server).
//	This processes the handshaking of the name table between the host and the player.
//	The first step is to send the player and application info to the host for verification
//	The second step is to receive and process the name table from the host
//	The last step is to wait for connections from other players and populate the name table
//	It assumes that the connection to the host has already been initiated.
//

//	DNPrepareConnectInfo
//
//	Prepare the connection info block which will be sent to the Host player once a connection
//	has been established.

#undef DPF_MODNAME
#define DPF_MODNAME "DNPrepareConnectInfo"

HRESULT DNPrepareConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 CConnection *const pConnection,
							 CRefCountBuffer **const ppRefCountBuffer)
{
	HRESULT				hResultCode;
	DWORD				dwSize;
	DWORD				dwPasswordSize;
	DWORD				dwAddressSize;
	HANDLE				hEndPt;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	IDirectPlay8Address		*pAddress;
	DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO *pInfo;
	CCallbackThread		CallbackThread;
#ifdef DBG
	TCHAR				DP8ABuffer[512] = {0};
	DWORD				DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p], ppRefCountBuffer [0x%p]",pConnection,ppRefCountBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);
	DNASSERT(ppRefCountBuffer != NULL);

	pRefCountBuffer = NULL;
	pAddress = NULL;
	dwAddressSize = 0;
	CallbackThread.Initialize();

	//
	//	Get clear address
	//
	dwAddressSize = 0;
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) == DPN_OK)
	{
		if ((hResultCode = DNGetClearAddress(pdnObject,hEndPt,&pAddress,FALSE)) == DPN_OK)
		{
			if (pAddress != NULL)
			{
				// Get address URL size
				IDirectPlay8Address_GetURL(pAddress,NULL,&dwAddressSize);
				DNASSERT(dwAddressSize != 0);
#ifdef DBG
				DP8ASize = 512;
				IDirectPlay8Address_GetURL(pAddress,DP8ABuffer,&DP8ASize);
				DPFX(DPFPREP, 5,"Remote Address [%s]",DP8ABuffer);
#endif // DBG
			}
		}
		pConnection->ReleaseEndPt(&CallbackThread);
	}

	// Determine total size of connection info buffer
	if (pdnObject->ApplicationDesc.GetPassword() != NULL)
		dwPasswordSize = (wcslen(pdnObject->ApplicationDesc.GetPassword()) + 1) * sizeof(WCHAR);
	else
		dwPasswordSize = 0;

	DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

	dwSize = sizeof(DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO)
			+ pdnObject->dwConnectDataSize
			+ dwAddressSize
			+ dwPasswordSize
			+ pdnObject->NameTable.GetDefaultPlayer()->GetDataSize()
			+ pdnObject->NameTable.GetDefaultPlayer()->GetNameSize();

	// Allocate connection info buffer
	DPFX(DPFPREP, 7,"Need to allocate [%ld] bytes",dwSize);
	if ((hResultCode = RefCountBufferNew(pdnObject,dwSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate space for connection info");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pInfo = static_cast<DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO*>(packedBuffer.GetHeadAddress());

	// Type of interface
#ifndef DPNBUILD_NOSERVER
	pInfo->dwFlags = pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER | DN_OBJECT_FLAG_CLIENT | DN_OBJECT_FLAG_SERVER);
#else
	pInfo->dwFlags = pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER | DN_OBJECT_FLAG_CLIENT);
#endif // DPNBUILD_NOSERVER

	// Version of DIRECTNET
	pInfo->dwDNETVersion = DN_VERSION_CURRENT;

	// Name
	if (pdnObject->NameTable.GetDefaultPlayer()->GetNameSize())
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->NameTable.GetDefaultPlayer()->GetName(),
				pdnObject->NameTable.GetDefaultPlayer()->GetNameSize())) != DPN_OK)
		{
			DPFERR("Could not add name to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwNameOffset = packedBuffer.GetTailOffset();
		pInfo->dwNameSize = pdnObject->NameTable.GetDefaultPlayer()->GetNameSize();
	}
	else
	{
		pInfo->dwNameOffset = 0;
		pInfo->dwNameSize = 0;
	}

	// Player data
	if (pdnObject->NameTable.GetDefaultPlayer()->GetData() && pdnObject->NameTable.GetDefaultPlayer()->GetDataSize())
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->NameTable.GetDefaultPlayer()->GetData(),
				pdnObject->NameTable.GetDefaultPlayer()->GetDataSize())) != DPN_OK)
		{
			DPFERR("Could not add connect data to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwDataOffset = packedBuffer.GetTailOffset();
		pInfo->dwDataSize = pdnObject->NameTable.GetDefaultPlayer()->GetDataSize();
	}
	else
	{
		pInfo->dwDataOffset = 0;
		pInfo->dwDataSize = 0;
	}

	// Password
	if (dwPasswordSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->ApplicationDesc.GetPassword(),dwPasswordSize)) != DPN_OK)
		{
			DPFERR("Could not add password to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwPasswordOffset = packedBuffer.GetTailOffset();
		pInfo->dwPasswordSize = dwPasswordSize;
	}
	else
	{
		pInfo->dwPasswordOffset = 0;
		pInfo->dwPasswordSize = 0;
	}

	// Connect data
	if (pdnObject->pvConnectData)
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->pvConnectData,pdnObject->dwConnectDataSize)) != DPN_OK)
		{
			DPFERR("Could not add connect data to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwConnectDataOffset = packedBuffer.GetTailOffset();
		pInfo->dwConnectDataSize = pdnObject->dwConnectDataSize;
	}
	else
	{
		pInfo->dwConnectDataOffset = 0;
		pInfo->dwConnectDataSize = 0;
	}

	// Clear address URL
	if (dwAddressSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(NULL,dwAddressSize)) != DPN_OK)
		{
			DPFERR("Could not add address URL to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if ((hResultCode = IDirectPlay8Address_GetURLA(pAddress,
													static_cast<char*>(packedBuffer.GetTailAddress()),
													&dwAddressSize)) != DPN_OK)
		{
			DPFERR("Could not get address URL");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwURLOffset = packedBuffer.GetTailOffset();
		pInfo->dwURLSize = dwAddressSize;
	}
	else
	{
		pInfo->dwURLOffset = 0;
		pInfo->dwURLSize = 0;
	}

	// Instance and appplication GUIDs
	memcpy(&pInfo->guidInstance,pdnObject->ApplicationDesc.GetInstanceGuid(),sizeof(GUID));
	memcpy(&pInfo->guidApplication,pdnObject->ApplicationDesc.GetApplicationGuid(),sizeof(GUID));

	*ppRefCountBuffer = pRefCountBuffer;
	pRefCountBuffer = NULL;

	if (pAddress)
	{
		IDirectPlay8Address_Release(pAddress);
		pAddress = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	CallbackThread.Deinitialize();
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:

	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pAddress)
	{
		IDirectPlay8Address_Release(pAddress);
		pAddress = NULL;
	}

	goto Exit;
}



//	DNConnectToHost1
//
//	After receiving protocol level connection acknowledgement, send player and application info
//		CConnection	*pConnection	Connection to host

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToHost1"

HRESULT DNConnectToHost1(DIRECTNETOBJECT *const pdnObject,
						 CConnection *const pConnection)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CAsyncOp			*pAsyncOp;
	CAsyncOp			*pConnectParent;

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p]",pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pRefCountBuffer = NULL;
	pAsyncOp = NULL;
	pConnectParent = NULL;

	//
	//	Get connect parent (and make sure we're not closing)
	//	We will also store the CConnection on the connect parent for future clean up.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DPFERR("Object is CLOSING or DISCONNECTING");
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		pConnection->Disconnect();
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNASSERT(pdnObject->pConnectParent != NULL);
	pdnObject->pConnectParent->SetConnection( pConnection );	
	pdnObject->pConnectParent->AddRef();
	pConnectParent = pdnObject->pConnectParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Prepare connect info
	//
	if ((hResultCode = DNPrepareConnectInfo(pdnObject,pConnection,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not prepare connect info");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	DNASSERT(pRefCountBuffer != NULL);

	//
	//	Send connect info
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_PLAYER_CONNECT_INFO,
								0,
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								pConnectParent,
								&pAsyncOp);

	if (hResultCode == DPNERR_PENDING)
	{
		pAsyncOp->SetCompletion( DNCompleteSendConnectInfo );
		pAsyncOp->Release();
		pAsyncOp = NULL;

		hResultCode = DPN_OK;
	}
	else
	{
		//
		//	Save error code, clean up DirectNetObject and fail
		//
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		DNAbortConnect(pdnObject,hResultCode);
	}

	pConnectParent->Release();
	pConnectParent = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	goto Exit;
}


//	DN_ConnectToHost2
//
//	Extract and install the host supplied name table
//	Send name table acknowledgement to the host
//	Propegate ADD_PLAYER messages to the application for host and local players
//	Propegate CREATE_GROUP messages to the application for groups in the name table
//
//		PVOID		pvData			NameTable buffer
//		CConnection	*pConnection	Connection to host

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToHost2"

HRESULT DNConnectToHost2(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pvData,
						 CConnection *const pConnection)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pHostPlayer;
	CNameTableEntry		*pLocalPlayer;
	CNameTableOp		*pNTOp;
	CBilink				*pBilink;
	DPNID				dpnid;
	DWORD				dwFlags;
	CConnection			*pLocalConnection;
	BOOL				fNotify;
	IDirectPlay8Address	*pIDevice;
	IDirectPlay8Address	*pIHost;
	CAsyncOp			*pListenParent;
	CAsyncOp			*pConnectParent;
	HANDLE				hEndPt;
	CCallbackThread		CallbackThread;

	DPFX(DPFPREP, 4,"Parameters: pvData [0x%p], pConnection [0x%p]",pvData,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvData != NULL);
	DNASSERT(pConnection != NULL);

	pNTEntry = NULL;
	pHostPlayer = NULL;
	pLocalPlayer = NULL;
	pLocalConnection = NULL;
	pIDevice = NULL;
	pIHost = NULL;
	pListenParent = NULL;
	pConnectParent = NULL;
	CallbackThread.Initialize();

	//
	//	Initial try to catch a close
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Extract application description and name table
	//
	if ((hResultCode = DNReceiveConnectInfo(pdnObject,pvData,pConnection,&dpnid)) != DPN_OK)
	{
		DPFERR("Could not extract name table passed by host");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get Connection object for local player
	//
	if ((hResultCode = ConnectionNew(pdnObject,&pLocalConnection)) != DPN_OK)
	{
		DPFERR("Could not create new Connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Get Host and Local players
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Local player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Ensure we have an address for the Host player
	//
	if (pHostPlayer->GetAddress() == NULL)
	{
		//
		//	Use connect address if it exists
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->pConnectAddress)
		{
			IDirectPlay8Address_AddRef(pdnObject->pConnectAddress);
			pIHost = pdnObject->pConnectAddress;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pIHost == NULL)
		{
			//
			//	No connect address was specified, so we will query for the host's address
			//
			if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
			{
				DPFERR("Could not get end point from connection");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}

			hResultCode = DNGetClearAddress(pdnObject,hEndPt,&pIHost,TRUE);

			pConnection->ReleaseEndPt(&CallbackThread);

			if (hResultCode != DPN_OK)
			{
				DPFERR("Could not get clear address for Host player");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
		}
		pHostPlayer->SetAddress(pIHost);
		IDirectPlay8Address_Release(pIHost);
		pIHost = NULL;
	}

	//
	//	Start LISTENs for CONNECTs from existing players in Peer-Peer mode
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
		{
			DPFERR("Could not get end point from connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		hResultCode = DNGetLocalDeviceAddress(pdnObject,hEndPt,&pIDevice);

		pConnection->ReleaseEndPt(&CallbackThread);

		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not get LISTEN address from endpoint");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		// Parent Async Op
		if ((hResultCode = AsyncOpNew(pdnObject,&pListenParent)) != DPN_OK)
		{
			DPFERR("Could not create AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pListenParent->SetOpType( ASYNC_OP_LISTEN );
		pListenParent->MakeParent();
		pListenParent->SetCompletion( DNCompleteListen );
		
		dwFlags = DN_LISTENFLAGS_DISALLOWENUMS;
		if (pdnObject->ApplicationDesc.GetReservedDataSize() > 0)
		{
			dwFlags |= DN_LISTENFLAGS_SESSIONDATA;
		}
		if (pdnObject->ApplicationDesc.IsFastSigned())
		{
			dwFlags|=DN_LISTENFLAGS_FASTSIGNED;
		}
		else if (pdnObject->ApplicationDesc.IsFullSigned())
		{
			dwFlags|=DN_LISTENFLAGS_FULLSIGNED;
		}
		pListenParent->SetOpFlags( dwFlags );

		// Perform child LISTEN
		hResultCode = DNPerformSPListen(pdnObject,
										pIDevice,
										pListenParent,
										NULL);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not perform child LISTEN");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		// Store parent LISTEN on DirectNet object
#pragma BUGBUG( minara, "What if we are closing down and have already terminated all listens ?" )
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pListenParent->AddRef();
		pdnObject->pListenParent = pListenParent;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		pListenParent->Release();
		pListenParent = NULL;
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}

	//
	//	Indicate peer connected - we will perform this before notifying the host so that
	//	DN_OBJECT_FLAG_CONNECTED is set when existing player CONNECTs come in
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
#pragma TODO( minara, "Shut down listen" )
			hResultCode = DPN_OK;
			goto Failure;
		}
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
		pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		//
		//	Inform application of groups and players.
		//	We will inform the application of
		//		- CREATE_GROUP
		//		- ADD_PLAYER (for Local and Host players)
		//		- ADD_PLAYER_TO_GROUP
		//

		pdnObject->NameTable.ReadLock();
		pBilink = pdnObject->NameTable.m_bilinkGroups.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->AddRef();
			pdnObject->NameTable.Unlock();

			fNotify = FALSE;
			pNTEntry->Lock();
			if (!pNTEntry->IsAvailable() && !pNTEntry->IsDisconnecting() && !pNTEntry->IsAutoDestructGroup())
			{
				pNTEntry->MakeAvailable();
				pNTEntry->NotifyAddRef();
				pNTEntry->NotifyAddRef();
				pNTEntry->SetInUse();
				fNotify = TRUE;
			}
			pNTEntry->Unlock();

			if (fNotify)
			{
				DNASSERT(!pNTEntry->IsAllPlayersGroup());
				DNUserCreateGroup(pdnObject,pNTEntry);

				pNTEntry->PerformQueuedOperations();

				pdnObject->NameTable.PopulateGroup( pNTEntry );
			}

			pNTEntry->Release();
			pNTEntry = NULL;

			pdnObject->NameTable.ReadLock();
			if (pBilink->IsEmpty())
			{
				pBilink = pdnObject->NameTable.m_bilinkGroups.GetNext();
			}
			else
			{
				pBilink = pBilink->GetNext();
			}
		}
		pNTEntry = NULL;
		pdnObject->NameTable.Unlock();
	}

	//
	//	We will pre-set the Host connection, so that any operation from the CREATE_PLAYER notification call-back
	//	for the local player will be able to find the Host player's connection (to send messages to).  We will
	//	not, however, expose the Host player to the user yet.
	//
	pHostPlayer->Lock();
	pHostPlayer->SetConnection( pConnection );
	pHostPlayer->Unlock();

	//
	// Add Local player
	//
	pLocalConnection->SetStatus( CONNECTED );
	pLocalConnection->SetEndPt(NULL);
	pLocalConnection->MakeLocal();

	//
	//	Preset player context
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	DNASSERT(pdnObject->pConnectParent);
	if (pdnObject->pConnectParent)
	{
		pdnObject->pConnectParent->AddRef();
		pConnectParent = pdnObject->pConnectParent;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pConnectParent)
	{
		pConnectParent->Lock();
		if (pConnectParent->GetContext())
		{
			pLocalPlayer->Lock();
			pLocalPlayer->SetContext(pConnectParent->GetContext());
			pLocalPlayer->Unlock();
		}
		pConnectParent->SetResult( DPN_OK );
		pConnectParent->Unlock();
		pConnectParent->Release();
		pConnectParent = NULL;
	}

#ifndef DPNBUILD_NOSERVER
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER|DN_OBJECT_FLAG_SERVER))
#else
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER))
#endif // DPNBUILD_NOSERVER
	{
		pdnObject->ApplicationDesc.IncPlayerCount( FALSE );
		pLocalConnection->SetDPNID(pLocalPlayer->GetDPNID());
		pdnObject->NameTable.PopulateConnection(pLocalConnection);
	}
	else
	{
		pLocalPlayer->Lock();
		pLocalPlayer->SetConnection(pLocalConnection);
		pLocalPlayer->StopConnecting();
		pLocalPlayer->MakeAvailable();
		pLocalPlayer->Unlock();

		pdnObject->NameTable.DecOutstandingConnections();
	}
	pLocalConnection->Release();
	pLocalConnection = NULL;

	//
	// Add Host player
	//
#ifndef DPNBUILD_NOSERVER
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER|DN_OBJECT_FLAG_SERVER))
#else
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER))
#endif // DPNBUILD_NOSERVER
	{
		pdnObject->ApplicationDesc.IncPlayerCount( FALSE );

		//
		//	If we have lost the connection to the host player, we will abort the connect process
		//
		pConnection->Lock();
		if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
		{
			pConnection->SetDPNID(pHostPlayer->GetDPNID());
			pConnection->SetStatus( CONNECTED );
			pConnection->Unlock();
			pdnObject->NameTable.PopulateConnection(pConnection);
		}
		else
		{
			pConnection->Unlock();
			DNAbortConnect(pdnObject,DPNERR_CONNECTIONLOST);
			goto Failure;
		}
	}
	else
	{
		pConnection->SetStatus( CONNECTED );

		pHostPlayer->Lock();
		pHostPlayer->StopConnecting();

		//
		//	We won't make the host player available until after CONNECT_COMPLETE
		//	has been indicated and the callback has returned.
		//
		//pHostPlayer->MakeAvailable();
		
		pHostPlayer->Unlock();

		pdnObject->NameTable.DecOutstandingConnections();
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Process any nametable operations that might have arrived
	//
	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if ((pNTOp->GetVersion() == (pdnObject->NameTable.GetVersion() + 1))
				&& !pNTOp->IsInUse())
		{
			pNTOp->SetInUse();
			pdnObject->NameTable.Unlock();

			hResultCode = DNNTPerformOperation(	pdnObject,
												pNTOp->GetMsgId(),
												pNTOp->GetRefCountBuffer()->GetBufferAddress() );

			pdnObject->NameTable.ReadLock();
		}
		else
		{
			//
			//	Once we find an operation that we won't perform, there is no point continuing
			//
			break;
		}
		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	//
	//	Send connect info acknowledgement to host
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_ACK_CONNECT_INFO,
								pHostPlayer->GetDPNID(),
								NULL,
								0,
								NULL,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DNAbortConnect(pdnObject,hResultCode);
		goto Failure;
	}

	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	CallbackThread.Deinitialize();
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pLocalConnection)
	{
		pLocalConnection->Release();
		pLocalConnection = NULL;
	}
	if (pIDevice)
	{
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}
	if (pIHost)
	{
		IDirectPlay8Address_Release(pIHost);
		pIHost = NULL;
	}
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	goto Exit;
}


//	DNConnectToHostFailed
//
//	Clean up if an attempt to connect to the HostPlayer fails

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToHostFailed"

HRESULT	DNConnectToHostFailed(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvBuffer,
							  const DWORD dwBufferSize,
							  CConnection *const pConnection)
{
	CAsyncOp		*pConnectParent;
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_FAILED			*pInfo;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p], dwBufferSize [%ld], pConnection [0x%x]",pvBuffer,dwBufferSize,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL || dwBufferSize == 0);

	pRefCountBuffer = NULL;
	pConnectParent = NULL;

	if (pvBuffer != NULL)
	{
		pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_FAILED*>(pvBuffer);
		if ((pInfo->dwReplyOffset != 0) && (pInfo->dwReplySize != 0))
		{
			//
			//	Extract reply buffer
			//
			if ((hResultCode = RefCountBufferNew(pdnObject,pInfo->dwReplySize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer - ignore and continue");
				DisplayDNError(0,hResultCode);
			}
			else
			{
				memcpy(	pRefCountBuffer->GetBufferAddress(),
						static_cast<BYTE*>(pvBuffer) + pInfo->dwReplyOffset,
						pInfo->dwReplySize );
			}
		}

		//
		//	Update connect operation parent with results
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		DNASSERT(pdnObject->pConnectParent);
		if (pdnObject->pConnectParent)
		{
			pdnObject->pConnectParent->Lock();
			pdnObject->pConnectParent->SetResult( pInfo->hResultCode );
			pdnObject->pConnectParent->SetRefCountBuffer( pRefCountBuffer );
			pdnObject->pConnectParent->Unlock();
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pRefCountBuffer)
		{
			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
DPFX(DPFPREP, 0,"ConnectToHostFailed: [0x%lx]",pInfo->hResultCode);
	}

	//
	//	Release the reference on the connection since we will be dropping the link.
	//	We are safe releasing the connection here, since the protocol will prevent
	//	the Host's DISCONNECT from being passed up to us until after this thread
	//	has returned back down.
	//
	pConnection->Disconnect();

	//
	//	Clean up DirectNetObject
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED
							| DN_OBJECT_FLAG_CONNECTING
							| DN_OBJECT_FLAG_HOST_CONNECTED));
	if (pdnObject->pConnectParent)
	{
		pConnectParent = pdnObject->pConnectParent;
		pdnObject->pConnectParent = NULL;
	}
	if( pdnObject->pIDP8ADevice )
	{
		IDirectPlay8Address_Release( pdnObject->pIDP8ADevice );
		pdnObject->pIDP8ADevice = NULL;
	}
	if( pdnObject->pConnectAddress )
	{
		IDirectPlay8Address_Release( pdnObject->pConnectAddress );
		pdnObject->pConnectAddress = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	DPFX(DPFPREP, 4,"Returning: DPN_OK");
	return(DPN_OK);
}



//
//	DNAbortConnect
//
//	Abort the CONNECT process by cleaning up the DirectNet object and terminating the session
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNAbortConnect"

HRESULT DNAbortConnect(DIRECTNETOBJECT *const pdnObject,
					   const HRESULT hrConnect)
{
	HRESULT		hResultCode;
	CAsyncOp	*pConnectParent;

	DPFX(DPFPREP, 4,"Parameters: hrConnect [0x%lx]",hrConnect);

	DNASSERT(pdnObject != NULL);

	pConnectParent = NULL;

	//
	//	Clean up DirectNetObject
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED
							| DN_OBJECT_FLAG_CONNECTING
							| DN_OBJECT_FLAG_HOST_CONNECTED));
	if (pdnObject->pConnectParent)
	{
		pdnObject->pConnectParent->AddRef();
		pConnectParent = pdnObject->pConnectParent;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Set error code on connect operation completion
	//
	if (pConnectParent)
	{
		pConnectParent->Lock();
		pConnectParent->SetResult( hrConnect );
		pConnectParent->Unlock();
	}

	//
	//	Shut down
	//
	DNTerminateSession(pdnObject,DPN_OK);

	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//	Player to player connection occurs at the direction of the host. (Peer-to-peer)
//
//	Once a NewPlayer has connected to the host,
//		The Host will send the NewPlayer's NameTable entry to all existing players
//	Once the NewPlayer has installed the NameTable, it informs the host
//		The Host will instruct the existing players to connect to the NewPlayer
//
//	When an existing player establishes a connection with the NewPlayer
//		The existing player send their DNID to the NewPlayer and an ADD_PLAYER to app
//		The NewPlayer activates the connecting (existing) player and sends ADD_PLAYER to app
//


//	DNPlayerConnect1
//
//	Receive an existing player's DNID.  This is called by the NewPlayer.  If valid, send an
//	ADD_PLAYER message to the application

#undef DPF_MODNAME
#define DPF_MODNAME "DNPlayerConnect1"

HRESULT	DNPlayerConnect1(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pv,
						 CConnection *const pConnection)
{
	HRESULT						hResultCode;
	CNameTableEntry				*pPlayer;
	UNALIGNED DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID	*pSend;

	DPFX(DPFPREP, 4,"Parameters: pv [0x%p], pConnection [0x%p]",pv,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);
	DNASSERT(pConnection != NULL);

	pPlayer = NULL;

	pSend = static_cast<DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID*>(pv);
	DNASSERT(pSend->dpnid != 0);

	DPFX(DPFPREP, 5,"Player [0x%lx] has connected",pSend->dpnid);

	if ((hResultCode = pdnObject->NameTable.FindEntry(pSend->dpnid,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find connecting player!");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Increment players in session
	//
	pdnObject->ApplicationDesc.IncPlayerCount( FALSE );

	// Associate DNID with player's connection
	pConnection->Lock();
	pConnection->SetDPNID(pSend->dpnid);
	pConnection->SetStatus( CONNECTED );
	pConnection->Unlock();

	// Populate connection
	pdnObject->NameTable.PopulateConnection(pConnection);

	//
	//	Now that this connection is part of a NameTableEntry, remove it from the indicated list
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	if (!pConnection->m_bilinkIndicated.IsEmpty())
	{
		pConnection->Release();
	}
	pConnection->m_bilinkIndicated.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	pPlayer->Release();
	pPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


//	DNConnectToPeer1
//
//	Accept the NameTable entry of the NewPlayer from the Host, and add it to the local
//	NameTable.  The Host will later provide an INSTRUCT_CONNECT message later.

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeer1"

HRESULT	DNConnectToPeer1(DIRECTNETOBJECT *const pdnObject,
						 PVOID const pv)
{
	HRESULT					hResultCode;
	DN_NAMETABLE_ENTRY_INFO	*pdnNTEInfo;
	CNameTableEntry			*pNTEntry;
//	DWORD					dwVersion;

	DPFX(DPFPREP, 4,"Parameters: pv [0x%p]",pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	pNTEntry = NULL;

	//
	//	Create and unpack new entry
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not create new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pdnNTEInfo = static_cast<DN_NAMETABLE_ENTRY_INFO*>(pv);
	DPFX(DPFPREP, 5,"New player DNID [0x%lx] - installing NameTable entry",pdnNTEInfo->dpnid);
	DPFX(DPFPREP, 5,"Connecting Player URL [%hs]",static_cast<char*>(pv) + pdnNTEInfo->dwURLOffset);
	if ((hResultCode = pNTEntry->UnpackEntryInfo(pdnNTEInfo,static_cast<BYTE*>(pv))) != DPN_OK)
	{
		DPFERR("Could not unpack NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pNTEntry->StartConnecting();

	//
	//	Add entry to NameTable
	//
	if ((hResultCode = pdnObject->NameTable.InsertEntry(pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not insert NameTableEntry into NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Update NameTableVersion
	//
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion( pdnNTEInfo->dwVersion );
	pdnObject->NameTable.Unlock();

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNConnectToPeer2
//
//	Perform a connection to the NewPlayer (as instructed by Host).
//	Once this connection has completed (DNConnectToPeer2) send this player's DNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeer2"

HRESULT DNConnectToPeer2(DIRECTNETOBJECT *const pdnObject,
						 PVOID const pv)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	UNALIGNED DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT	*pInfo;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 4,"Parameters: pv [0x%p]", pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	pNTEntry = NULL;
	pLocalPlayer = NULL;
	pSP = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT*>(pv);

	//
	//	Update NameTable version
	//
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion( pInfo->dwVersion );
	pdnObject->NameTable.Unlock();

	//
	//	Determine if this is an instruction to connect to ourselves.
	//	If it is, don't do anything other than update the NameTable version
	//
	DPFX(DPFPREP, 5,"Instructed to connect to [0x%lx]",pInfo->dpnid);
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->GetDPNID() == pInfo->dpnid)
	{
		DPFX(DPFPREP, 5,"Ignoring instruction to connect to self");
		hResultCode = DPN_OK;
		goto Failure;
	}

	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	We will not connect to older players.  They will connect to us.
	//
	if (pNTEntry->GetVersion() < pLocalPlayer->GetVersion())
	{
		DPFX(DPFPREP, 5,"Ignoring instruction to connect to older player");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Get SP (cached on DirectNet object from original Connect() to host)
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pConnectSP != NULL)
	{
		pdnObject->pConnectSP->AddRef();
		pSP = pdnObject->pConnectSP;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pSP == NULL)
	{
		DPFERR("Could not find connect SP on DirectNet object");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

#ifndef DPNBUILD_ONLYONESP
	//
	//	Force the correct service provider into the address.
	//
	GUID	guidSP;
	pSP->GetGUID(&guidSP);
	if ((hResultCode = IDirectPlay8Address_SetSP(pNTEntry->GetAddress(), &guidSP)) != DPN_OK)
	{
		DPFERR("Could not force correct service provider into player address");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONESP

	// Connect to new player
	DPFX(DPFPREP, 5,"Performing Connect");
	DNASSERT(pdnObject->pIDP8ADevice != NULL);
	hResultCode = DNPerformConnect(	pdnObject,
									pNTEntry->GetDPNID(),
									pdnObject->pIDP8ADevice,
									pNTEntry->GetAddress(),
									pSP,
									((pdnObject->ApplicationDesc.GetReservedDataSize() > 0) ? DN_CONNECTFLAGS_SESSIONDATA : 0),
									NULL);

	if (hResultCode == DPNERR_PENDING)
	{
		hResultCode = DPN_OK;
	}

	pSP->Release();
	pSP = NULL;

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DNASSERT( pSP == NULL );

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


//	DNConnectToPeer3
//
//	Finish the connection process to the NewPlayer.
//	Once the connection has completed send this player's DNID to NewPlayer and propegate
//	ADD_PLAYER message

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeer3"

HRESULT	DNConnectToPeer3(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 CConnection *const pConnection)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	CRefCountBuffer		*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID	*pSend;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx], pConnection [0x%p]",dpnid,pConnection);

	DNASSERT(dpnid != NULL);
	DNASSERT(pConnection != NULL);

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRefCountBuffer = NULL;

	//
	//	increment players in session
	//
	pdnObject->ApplicationDesc.IncPlayerCount( FALSE );

	// Associate DNID with player's end point handle
	pConnection->Lock();
	pConnection->SetDPNID(dpnid);
	pConnection->SetStatus( CONNECTED );
	pConnection->Unlock();

	//
	//	Get New Players's entry
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find new player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get Local player's entry
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	// Setup buffer to pass local player's DNID
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not allocate buffer to send connecting player DPNID");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pSend = reinterpret_cast<DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID*>(pRefCountBuffer->GetBufferAddress());
	pSend->dpnid = pLocalPlayer->GetDPNID();

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	// Send player's DNID to new player
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_SEND_PLAYER_DNID,
								dpnid,
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send connecting player DPNID");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		DNASSERT(FALSE);
		goto Failure;
	}

	//	Update NameTableEntry with Connection
	pdnObject->NameTable.PopulateConnection(pConnection);
	
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNConnectToPeerFailed
//
//	An existing player could not connect to a NewPlayer.
//	Send a message to the Host player that this connect attempt failed

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeerFailed"

HRESULT DNConnectToPeerFailed(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pHost;
	CConnection		*pConnection;
	CRefCountBuffer	*pRCBuffer;
	DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx]",dpnid);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != 0);

	pHost = NULL;
	pConnection = NULL;
	pRCBuffer = NULL;

	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHost )) != DPN_OK)
	{
		DPFERR("Could not get Host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHost->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get Host Connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Create message
	//
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRCBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED*>(pRCBuffer->GetBufferAddress());
	pMsg->dpnid = dpnid;

	//
	//	Send message
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED,
								pHost->GetDPNID(),
								pRCBuffer->BufferDescAddress(),
								1,
								pRCBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send CONNECT_FAILED message - maybe OUR connection is down !");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		goto Failure;
	}

	//
	//	Clean up
	//
	pHost->Release();
	pHost = NULL;
	pConnection->Release();
	pConnection = NULL;
	pRCBuffer->Release();
	pRCBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHost)
	{
		pHost->Release();
		pHost = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRCBuffer)
	{
		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	goto Exit;
}


//	DNSendConnectInfo
//
//	Send connection info to a new player.
//	This is the Host Applcation Description and the NameTable
//	This uses an enumeration buffer.
//	The format of the buffer is:
//		<DN_INTERNAL_MESSAGE_CONNECT_INFO>
//		<DN_APPLICATION_DESC>
//		<DN_NAMETABLE_INFO>
//			<DN_NAMETABLE_ENTRY_INFO>
//			<DN_NAMETABLE_ENTRY_INFO>
//				:
//		<strings and data blocks>
//
//	DNID	dnId		DNID of new player

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendConnectInfo"

HRESULT	DNSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry,
						  CConnection *const pConnection,
						  void *const pvReplyBuffer,
						  const DWORD dwReplyBufferSize)
{
	HRESULT					hResultCode;
	CPackedBuffer			packedBuffer;
	CRefCountBuffer			*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_CONNECT_INFO	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p], pConnection [0x%p], pvReplyBuffer [0x%p], dwReplyBufferSize [%ld]",
			pNTEntry,pConnection,pvReplyBuffer,dwReplyBufferSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pNTEntry != NULL);

	pRefCountBuffer = NULL;

	//
	//	Determine size of message
	//
	packedBuffer.Initialize(NULL,0);
	packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO));
	packedBuffer.AddToBack(NULL,dwReplyBufferSize);
	pdnObject->ApplicationDesc.PackInfo(&packedBuffer,
			DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->NameTable.PackNameTable(pNTEntry,&packedBuffer);

	//
	//	Create buffer
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,packedBuffer.GetSizeRequired(),MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());

	//
	//	Fill in buffer
	//
	pMsg = static_cast<DN_INTERNAL_MESSAGE_CONNECT_INFO*>(packedBuffer.GetHeadAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO))) != DPN_OK)
	{
		DPFERR("Could not add CONNECT_INFO struct to packed buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((pvReplyBuffer) && (dwReplyBufferSize != 0))
	{
		if ((hResultCode = packedBuffer.AddToBack(pvReplyBuffer,dwReplyBufferSize)) != DPN_OK)
		{
			DPFERR("Could not add reply buffer to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwReplyOffset = packedBuffer.GetTailOffset();
		pMsg->dwReplySize = dwReplyBufferSize;
	}
	else
	{
		pMsg->dwReplyOffset = 0;
		pMsg->dwReplySize = 0;
	}

	hResultCode = pdnObject->ApplicationDesc.PackInfo(&packedBuffer,
			DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not pack ApplicationDesc");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.PackNameTable(pNTEntry,&packedBuffer)) != DPN_OK)
	{
		DPFERR("Could not pack NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Send the name table to target
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_SEND_CONNECT_INFO,
								pNTEntry->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send connect info to joining player");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
//		DNASSERT(FALSE);
		goto Failure;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}



//	DNReceiveConnectInfo
//
//	Receive connect info from the host/server player.
//	This is the Application Description and the NameTable
//	The name table is in an enum buffer, with relative pointer references which will have
//	to be turned into absolutes.  This process requires two passes of the buffer.
//	The first pass will extract PLAYERS, and the second pass will extract groups.
//
//	PVOID				pvNTBuffer		Pointer to name table enum buffer
//	DWORD				dwNumEntries	Number of entries in the name table

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveConnectInfo"

HRESULT	DNReceiveConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer,
							 CConnection *const pHostConnection,
							 DPNID *const pdpnid)
{
	HRESULT		hResultCode;
	void		*pvReplyBuffer;
	DWORD		dwReplyBufferSize;
	UNALIGNED DPN_APPLICATION_DESC_INFO	*pdnAppDescInfo;
	UNALIGNED DN_NAMETABLE_INFO			*pdnNTInfo;
	CRefCountBuffer				*pRefCountBuffer;
	CAsyncOp					*pConnect;
	UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_INFO	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: pvBuffer [0x%p], pHostConnection [0x%p], pdpnid [0x%p]",
			pvBuffer,pHostConnection,pdpnid);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pdpnid != NULL);
	DNASSERT(pvBuffer != NULL);
	DNASSERT(pHostConnection != NULL);

	pRefCountBuffer = NULL;
	pConnect = NULL;

	//
	//	Pull fixed structures from front of buffer
	//
	pMsg = static_cast<DN_INTERNAL_MESSAGE_CONNECT_INFO*>(pvBuffer);
	pdnAppDescInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pMsg + 1);
	pdnNTInfo = reinterpret_cast<DN_NAMETABLE_INFO*>(pdnAppDescInfo + 1);

	//
	//	Extract reply buffer
	//
	dwReplyBufferSize = pMsg->dwReplySize;
	if (dwReplyBufferSize > 0)
	{
		pvReplyBuffer = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwReplyOffset);
		DPFX(DPFPREP, 7,"Reply Buffer [0x%p] [%ld]",pvReplyBuffer,dwReplyBufferSize);
		if ((hResultCode = RefCountBufferNew(pdnObject,dwReplyBufferSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create RefCountBuffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		memcpy(pRefCountBuffer->GetBufferAddress(),pvReplyBuffer,dwReplyBufferSize);
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->pConnectParent)
		{
			pdnObject->pConnectParent->AddRef();
			pConnect = pdnObject->pConnectParent;
			pConnect->SetRefCountBuffer( pRefCountBuffer );
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	//
	//	Extract Application Description
	//
	DPFX(DPFPREP, 7,"Extracting Application Description");
	hResultCode = pdnObject->ApplicationDesc.UnpackInfo(pdnAppDescInfo,pvBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME |
			DN_APPDESCINFO_FLAG_PASSWORD | DN_APPDESCINFO_FLAG_RESERVEDDATA | DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not unpack ApplicationDesc");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Set player count (Host and LocalPlayer)
	//
#pragma BUGBUG( minara,"What should happen here ?" )
//	dnAppDesc.dwCurrentPlayers = 2;

	//
	//	Extract NameTable
	//
	DPFX(DPFPREP, 7,"Extracting NameTable");
	DPFX(DPFPREP, 7,"Set DPNID mask to [0x%lx]",pdnObject->ApplicationDesc.GetDPNIDMask());
	pdnObject->NameTable.SetDPNIDMask( pdnObject->ApplicationDesc.GetDPNIDMask() );
	if ((hResultCode = pdnObject->NameTable.UnpackNameTableInfo(pdnNTInfo,static_cast<BYTE*>(pvBuffer),pdpnid)) != DPN_OK)
	{
		DPFERR("Could not unpack NameTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		//
		//	Create ALL_PLAYERS group
		//
		CNameTableEntry	*pAllPlayersGroup;

		pAllPlayersGroup = NULL;

		if ((hResultCode = NameTableEntryNew(pdnObject,&pAllPlayersGroup)) != DPN_OK)
		{
			DPFERR("Could not create NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pAllPlayersGroup->MakeGroup();

		// This function takes the lock internally
		pdnObject->NameTable.MakeAllPlayersGroup(pAllPlayersGroup);
		
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;

		DNASSERT(pAllPlayersGroup == NULL);
	}

	if (pConnect)
	{
		pConnect->Release();
		pConnect = NULL;
	}

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pConnect)
	{
		pConnect->SetResult( hResultCode );		// Try and salvage something !
		pConnect->Release();
		pConnect = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNGetClearAddress"

HRESULT DNGetClearAddress(DIRECTNETOBJECT *const pdnObject,
						  const HANDLE hEndPt,
						  IDirectPlay8Address **const ppAddress,
						  const BOOL fPartner)
{
	SPGETADDRESSINFODATA	spInfoData;
	HRESULT					hResultCode;
#ifdef DBG
	TCHAR					DP8ABuffer[512] = {0};
	DWORD					DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: hEndPt [0x%p], ppAddress [0x%p], fPartner [%ld]",hEndPt,ppAddress,fPartner);

	DNASSERT(pdnObject != NULL);
	DNASSERT(hEndPt != NULL);
	DNASSERT(ppAddress != NULL);

	if (fPartner)
	{
		spInfoData.Flags = SP_GET_ADDRESS_INFO_REMOTE_HOST;
	}
	else
	{
		spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS;
	}

	hResultCode = DNPCrackEndPointDescriptor(pdnObject->pdnProtocolData,hEndPt,&spInfoData);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Unknown error from DNPCrackEndPointDescriptor");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Exit;
	}
	*ppAddress = spInfoData.pAddress;
	spInfoData.pAddress = NULL;

#ifdef DBG
	if (*ppAddress)
	{
		DP8ASize = 512;
		IDirectPlay8Address_GetURL(*ppAddress,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 5,"Remote Address [%s]",DP8ABuffer);
	}
#endif // DBG

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNGetLocalDeviceAddress"

HRESULT DNGetLocalDeviceAddress(DIRECTNETOBJECT *const pdnObject,
								const HANDLE hEndPt,
								IDirectPlay8Address **const ppAddress)
{
	SPGETADDRESSINFODATA	spInfoData;
	HRESULT					hResultCode;
#ifdef DBG
	TCHAR					DP8ABuffer[512] = {0};
	DWORD					DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: hEndPt [0x%p], ppAddress [0x%p]",hEndPt,ppAddress);

	DNASSERT(pdnObject != NULL);
	DNASSERT(hEndPt != NULL);
	DNASSERT(ppAddress != NULL);

	spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;

	hResultCode = DNPCrackEndPointDescriptor(pdnObject->pdnProtocolData,hEndPt,&spInfoData);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Unknown error from DNPCrackEndPointDescriptor");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Exit;
	}
	*ppAddress = spInfoData.pAddress;
	spInfoData.pAddress = NULL;

#ifdef DBG
	if (*ppAddress)
	{
		DP8ASize = 512;
		IDirectPlay8Address_GetURL(*ppAddress,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 7,"Remote Address [%s]",DP8ABuffer);
	}
#endif // DBG

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\corepools.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.cpp
 *  Content:	Fixed Pool Wrappers
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/12/00	mjn		Created
 *	01/19/00	mjn		Added SyncEventNew()
 *	01/31/00	mjn		Added Internal FPM's for RefCountBuffers
 *	02/29/00	mjn		Added ConnectionNew()
 *	04/08/00	mjn		Added AsyncOpNew()
 *	07/28/00	mjn		Track outstanding CConnection objects
 *	07/30/00	mjn		Added PendingDeletionNew()
 *	07/31/00	mjn		Added QueuedMsgNew()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/06/00	mjn		Added CWorkerJob
 *	08/23/00	mjn		Added CNameTableOp
 *	04/04/01	mjn		CConnection list off DirectNetObject guarded by proper critical section
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// RefCountBufferNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//				const DWORD	dwBufferSize		- Size of buffer (may be 0)
//				pointer to allocation function
//				pointer to free function
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "RefCountBufferNew"

HRESULT RefCountBufferNew(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwBufferSize,
						  PFNALLOC_REFCOUNT_BUFFER pfnAlloc,
						  PFNFREE_REFCOUNT_BUFFER pfnFree,
						  CRefCountBuffer **const ppNewRefCountBuffer)
{
	CRefCountBuffer	*pRCBuffer;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: dwBufferSize [%ld], pfnAlloc [0x%p], pfnFree [0x%p], ppNewRefCountBuffer [0x%p]",
			dwBufferSize,pfnAlloc,pfnFree,ppNewRefCountBuffer);

	pRCBuffer = (CRefCountBuffer*)g_RefCountBufferPool.Get(pdnObject); // Context passed in as param
	if (pRCBuffer != NULL)
	{
		if ((hResultCode = pRCBuffer->Initialize(&g_RefCountBufferPool,
				pfnAlloc,pfnFree,dwBufferSize)) != DPN_OK)
		{
			DPFERR("Could not initialize");
			DisplayDNError(0,hResultCode);
			pRCBuffer->Release();
			hResultCode = DPNERR_OUTOFMEMORY;
		}
		else
		{
			*ppNewRefCountBuffer = pRCBuffer;
			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pRCBuffer);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
// SyncEventNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "SyncEventNew"

HRESULT SyncEventNew(DIRECTNETOBJECT *const pdnObject,
					 CSyncEvent **const ppNewSyncEvent)
{
	CSyncEvent		*pSyncEvent;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewSyncEvent [0x%p]",ppNewSyncEvent);

	pSyncEvent = (CSyncEvent*)g_SyncEventPool.Get(pdnObject->pIDPThreadPoolWork);
	if (pSyncEvent != NULL)
	{
		*ppNewSyncEvent = pSyncEvent;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pSyncEvent);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
// ConnectionNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "ConnectionNew"

HRESULT ConnectionNew(DIRECTNETOBJECT *const pdnObject,
					  CConnection **const ppNewConnection)
{
	CConnection		*pConnection;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewConnection [0x%p]",ppNewConnection);

	pConnection = (CConnection*)g_ConnectionPool.Get(pdnObject);
	if (pConnection != NULL)
	{
		*ppNewConnection = pConnection;
		hResultCode = DPN_OK;

		//
		//	Add this to the bilink of outstanding CConnections
		//
		DNEnterCriticalSection(&pdnObject->csConnectionList);
		pConnection->m_bilinkConnections.InsertBefore(&pdnObject->m_bilinkConnections);
		DNLeaveCriticalSection(&pdnObject->csConnectionList);
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pConnection);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// GroupConnectionNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "GroupConnectionNew"

HRESULT GroupConnectionNew(DIRECTNETOBJECT *const pdnObject,
						   CGroupConnection **const ppNewGroupConnection)
{
	CGroupConnection	*pGroupConnection;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewGroupConnection [0x%p]",ppNewGroupConnection);

	pGroupConnection = (CGroupConnection*)g_GroupConnectionPool.Get(pdnObject);
	if (pGroupConnection != NULL)
	{
		*ppNewGroupConnection = pGroupConnection;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pGroupConnection);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// GroupMemberNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "GroupMemberNew"

HRESULT GroupMemberNew(DIRECTNETOBJECT *const pdnObject,
					   CGroupMember **const ppNewGroupMember)
{
	CGroupMember	*pGroupMember;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewGroupMember [0x%p]",ppNewGroupMember);

	pGroupMember = (CGroupMember*)g_GroupMemberPool.Get(pdnObject);
	if (pGroupMember != NULL)
	{
		*ppNewGroupMember = pGroupMember;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pGroupMember);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// NameTableEntryNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "NameTableEntryNew"

HRESULT NameTableEntryNew(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry **const ppNewNameTableEntry)
{
	CNameTableEntry	*pNewNameTableEntry;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewNameTableEntry [0x%p]",ppNewNameTableEntry);

	pNewNameTableEntry = (CNameTableEntry*)g_NameTableEntryPool.Get(pdnObject);
	if (pNewNameTableEntry != NULL)
	{
		*ppNewNameTableEntry = pNewNameTableEntry;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pNewNameTableEntry);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// AsyncOpNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "AsyncOpNew"

HRESULT AsyncOpNew(DIRECTNETOBJECT *const pdnObject,
				   CAsyncOp **const ppNewAsyncOp)
{
	CAsyncOp		*pAsyncOp;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewAsyncOp [0x%p]",ppNewAsyncOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewAsyncOp != NULL);

	pAsyncOp = (CAsyncOp*)g_AsyncOpPool.Get(pdnObject);
	if (pAsyncOp != NULL)
	{
		*ppNewAsyncOp = pAsyncOp;
		hResultCode = DPN_OK;

#ifdef DBG
		//
		//	Add this to the bilink of outstanding AsyncOps
		//
		DNEnterCriticalSection(&pdnObject->csAsyncOperations);
		pAsyncOp->m_bilinkAsyncOps.InsertBefore(&pdnObject->m_bilinkAsyncOps);
		DNLeaveCriticalSection(&pdnObject->csAsyncOperations);
#endif // DBG
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pAsyncOp);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// PendingDeletionNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "PendingDeletionNew"

HRESULT PendingDeletionNew(DIRECTNETOBJECT *const pdnObject,
						   CPendingDeletion **const ppNewPendingDeletion)
{
	CPendingDeletion	*pPendingDeletion;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewPendingDeletion [0x%p]",ppNewPendingDeletion);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewPendingDeletion != NULL);

	pPendingDeletion = (CPendingDeletion*)g_PendingDeletionPool.Get(pdnObject);
	if (pPendingDeletion != NULL)
	{
		*ppNewPendingDeletion = pPendingDeletion;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pPendingDeletion);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// QueuedMsgNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "QueuedMsgNew"

HRESULT QueuedMsgNew(DIRECTNETOBJECT *const pdnObject,
					 CQueuedMsg **const ppNewQueuedMsg)
{
	CQueuedMsg	*pQueuedMsg;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewQueuedMsg [0x%p]",ppNewQueuedMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewQueuedMsg != NULL);

	pQueuedMsg = (CQueuedMsg*)g_QueuedMsgPool.Get(pdnObject);
	if (pQueuedMsg != NULL)
	{
		*ppNewQueuedMsg = pQueuedMsg;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pQueuedMsg);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// WorkerJobNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "WorkerJobNew"

HRESULT WorkerJobNew(DIRECTNETOBJECT *const pdnObject,
					 CWorkerJob **const ppNewWorkerJob)
{
	CWorkerJob	*pWorkerJob;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewWorkerJob [0x%p]",ppNewWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewWorkerJob != NULL);

	pWorkerJob = (CWorkerJob*)g_WorkerJobPool.Get(pdnObject);
	if (pWorkerJob != NULL)
	{
		*ppNewWorkerJob = pWorkerJob;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pWorkerJob);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// NameTableOpNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "NameTableOpNew"

HRESULT NameTableOpNew(DIRECTNETOBJECT *const pdnObject,
					   CNameTableOp **const ppNewNameTableOp)
{
	CNameTableOp	*pNameTableOp;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewNameTableOp [0x%p]",ppNewNameTableOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewNameTableOp != NULL);

	pNameTableOp = (CNameTableOp*)g_NameTableOpPool.Get(pdnObject);
	if (pNameTableOp != NULL)
	{
		*ppNewNameTableOp = pNameTableOp;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx] (object = 0x%p)",hResultCode,pNameTableOp);
	return(hResultCode);
}



#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
//**********************************************************************
// ------------------------------
// EnumReplyMemoryBlockAlloc
//
// Entry:		DWORD dwSize
//
// Exit:		PVOID		NULL or pointer to memory block
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "EnumReplyMemoryBlockAlloc"

PVOID EnumReplyMemoryBlockAlloc(void *const pvContext,
					   				const DWORD dwSize )
{
	DIRECTNETOBJECT		*pdnObject;
	PVOID				pv;

	DPFX(DPFPREP, 8,"Parameters: pvContext [0x%p], dwSize [%ld]",pvContext,dwSize);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);
	pv = pdnObject->EnumReplyMemoryBlockPool.Get(NULL);

	DPFX(DPFPREP, 8,"Returning: [0x%p]",pv);
	return(pv);
}


//**********************************************************************
// ------------------------------
// EnumReplyMemoryBlockFree
//
// Entry:		PVOID	pvMemoryBlock
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "EnumReplyMemoryBlockFree"

void EnumReplyMemoryBlockFree(void *const pvContext,
					 				void *const pvMemoryBlock)
{
	DIRECTNETOBJECT		*pdnObject;
	
	DPFX(DPFPREP, 8,"Parameters: pvContext [0x%p], pvMemoryBlock [0x%p]",
			pvContext,pvMemoryBlock);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);
	pdnObject->EnumReplyMemoryBlockPool.Release(pvMemoryBlock);

	DPFX(DPFPREP, 8,"Returning: (nothing)");
}



#undef DPF_MODNAME
#define DPF_MODNAME "DN_PopulateCorePools"
HRESULT DN_PopulateCorePools( DIRECTNETOBJECT *const pdnObject,
							const XDP8CREATE_PARAMS * const pDP8CreateParams )
{
	DWORD	dwSizeToAllocate;
	DWORD	dwNumToAllocate;
	DWORD	dwAllocated;
	BOOL	fEnumReplyPoolInitted = FALSE;

	DPFX(DPFPREP, 3,"Parameters: pDP8CreateParams [0x%p]",pDP8CreateParams);

	DNASSERT(DNMemoryTrackAreAllocationsAllowed());

	dwNumToAllocate = pDP8CreateParams->dwMaxSendsPerPlayer
						* pDP8CreateParams->dwMaxReceivesPerPlayer
						* pDP8CreateParams->dwMaxNumPlayers;
	dwAllocated = g_RefCountBufferPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested ref count buffers!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}

	dwNumToAllocate = pDP8CreateParams->dwMaxSendsPerPlayer
						* pDP8CreateParams->dwMaxNumPlayers;
	dwNumToAllocate += 2; // 1 for protocol and thread pool shutdown events
	dwAllocated = g_SyncEventPool.Preallocate(dwNumToAllocate, pdnObject->pIDPThreadPoolWork);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested sync event pools!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}

	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers;
	dwAllocated = g_ConnectionPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested connections!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}
	
	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers
						* pDP8CreateParams->dwMaxNumGroups;
	dwAllocated = g_GroupConnectionPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested group connections!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}
	
	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers
						* pDP8CreateParams->dwMaxNumGroups;
	dwAllocated = g_GroupMemberPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested group members!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}
	
	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers
						+ pDP8CreateParams->dwMaxNumGroups;
	dwAllocated = g_NameTableEntryPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested name table entries!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}
	
	dwNumToAllocate = pDP8CreateParams->dwMaxSendsPerPlayer
						* pDP8CreateParams->dwMaxReceivesPerPlayer
						* pDP8CreateParams->dwMaxNumPlayers;
	dwNumToAllocate += pDP8CreateParams->dwNumSimultaneousEnumHosts;
	dwNumToAllocate += 1; // one for the Host/Connect operation
	dwAllocated = g_AsyncOpPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested async operations!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}
	
	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers;
	dwAllocated = g_PendingDeletionPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested pending deletions!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}
	
	dwNumToAllocate = pDP8CreateParams->dwMaxReceivesPerPlayer
						* pDP8CreateParams->dwMaxNumPlayers;
	dwAllocated = g_QueuedMsgPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested queued messages!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}
	
	dwNumToAllocate = 5 * pDP8CreateParams->dwMaxNumPlayers;
	dwAllocated = g_WorkerJobPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested worker jobs!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}
	
	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers
						+ pDP8CreateParams->dwMaxNumGroups;
	dwAllocated = g_NameTableOpPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested name table operations!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}


	//
	//	Build a pool to handle enum replies.
	//
	dwSizeToAllocate = sizeof(DN_ENUM_RESPONSE_PAYLOAD)
					+ sizeof(DPN_APPLICATION_DESC_INFO)
					+ pDP8CreateParams->dwMaxAppDescSessionNameLength
					+ pDP8CreateParams->dwMaxAppDescAppReservedDataSize
					+ pDP8CreateParams->dwMaxEnumHostsResponseDataSize;
	if (! pdnObject->EnumReplyMemoryBlockPool.Initialize(dwSizeToAllocate, NULL, NULL, NULL, NULL))
	{
		goto Failure;
	}

	fEnumReplyPoolInitted = TRUE;

	//
	//	We only support one enum reply at a time.
	//
	dwNumToAllocate = 1;
	dwAllocated = pdnObject->EnumReplyMemoryBlockPool.Preallocate(dwNumToAllocate, pdnObject);
	if (dwAllocated < dwNumToAllocate)
	{
		DPFX(DPFPREP, 0, "Only allocated %u of %u requested enum reply memory blocks!",
			dwAllocated, dwNumToAllocate);
		goto Failure;
	}

	

	//
	//	Pre-allocate per-CPU items for the threadpool.  We want:
	//	+ 1 work item for RemoveServiceProvider
	//	+ 1 work item per send per player because they might be local sends
	//	+ no timers (the core doesn't have any)
	//	+ no I/O (the core doesn't use I/O directly)
	//
	dwNumToAllocate = 1 + pDP8CreateParams->dwMaxNumPlayers;
#pragma TODO(vanceo, "Moved from CSPData::Initialize because m_pThreadPool isn't set at point it's needed")
	//	+ one work item for each command
	//	+ one timer per enum hosts operation
	//	+ one I/O operation per simultaneous read
	dwNumToAllocate += pDP8CreateParams->dwMaxNumPlayers + pDP8CreateParams->dwNumSimultaneousEnumHosts;
	DWORD dwNumTimersToAllocate = pDP8CreateParams->dwNumSimultaneousEnumHosts;
	DWORD dwNumIoToAllocate = 1;
	if (IDirectPlay8ThreadPoolWork_Preallocate(pdnObject->pIDPThreadPoolWork, dwNumToAllocate, dwNumTimersToAllocate, dwNumIoToAllocate, 0) != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't pre-allocate %u work items!",
			dwNumToAllocate);
		goto Failure;
	}

	//
	//	Pre-allocate some address objects.  One for each player, plus one for a
	//	Host/Connect device address.
	//	Also include a host and device address for each enum.
	//
	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers + 1;
	dwNumToAllocate += 2 * pDP8CreateParams->dwNumSimultaneousEnumHosts;
	if (DNAddress_PreallocateInterfaces(dwNumToAllocate) != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't pre-allocate %u address objects!",
			dwNumToAllocate);
		goto Failure;
	}

	//
	//	Not really a pool, but should be pre-populated anyway.
	//
	dwNumToAllocate = pDP8CreateParams->dwMaxNumPlayers
						+ pDP8CreateParams->dwMaxNumGroups;
	if (pdnObject->NameTable.SetNameTableSize(dwNumToAllocate) != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set name table size to hold %u entries!",
			dwNumToAllocate);
		goto Failure;
	}

	pdnObject->fPoolsPrepopulated = TRUE;

	DPFX(DPFPREP, 3,"Returning: [DPN_OK]");
	
	return DPN_OK;

Failure:

	if (fEnumReplyPoolInitted)
	{
		pdnObject->EnumReplyMemoryBlockPool.DeInitialize();
		fEnumReplyPoolInitted = FALSE;
	}

	DPFX(DPFPREP, 3,"Returning: [DPNERR_OUTOFMEMORY]");
	
	return DPNERR_OUTOFMEMORY;
}

#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\connect.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connect.h
 *  Content:    DirectNet connect and disconnect routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/11/00	mjn		Created
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/17/00	mjn		Fixed ConnectToPeer function names
 *	01/18/00	mjn		Moved Pack/UnpackNameTableInfo to NameTable.cpp
 *	01/18/00	mjn		Added DNAutoDestructGroups
 *	01/22/00	mjn		Added DNProcessHostDestroyPlayer
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/03/00	mjn		Verify DNET version on connect
 *	04/12/00	mjn		Removed DNAutoDestructGroups - covered in NameTable.DeletePlayer()
 *	04/20/00	mjn		Added DNGetClearAddress
 *	05/23/00	mjn		Added DNConnectToPeerFailed()
 *	06/14/00	mjn		Added DNGetLocalAddress()
 *	06/24/00	mjn		Added DNHostDropPlayer()
 *	07/20/00	mjn		Structure changes and new function parameters
 *				mjn		Moved DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO and DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED to message.h
 *	07/30/00	mjn		Renamed DNGetLocalAddress() to DNGetLocalDeviceAddress()
 *	07/31/00	mjn		Added dwDestroyReason to DNHostDisconnect()
 *	10/11/00	mjn		DNAbortConnect() takes HRESULT parameters instead of PVOID
 *	06/07/01	mjn		Added connection parameter to DNConnectToHostFailed()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CONNECT_H__
#define	__CONNECT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct {
	HRESULT	hResultCode;
} DN_RESULT_CONNECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

// DirectNet - Connect routines

HRESULT DNHostConnect1(DIRECTNETOBJECT *const pdnObject,
					   const PVOID pvBuffer,
					   const DWORD dwBufferSize,
					   CConnection *const pConnection);

HRESULT DNHostConnect2(DIRECTNETOBJECT *const pdnObject,
					   CConnection *const pConnection);

HRESULT DNHostVerifyConnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const DWORD dwFlags,
							const DWORD dwDNETVersion,
							UNALIGNED WCHAR *const pwszPassword,
							GUID *const pguidApplication,
							GUID *const pguidInstance,
							PVOID const pvConnectData,
							const DWORD dwConnectDataSize,
							IDirectPlay8Address *const pAddress,
							void **const ppvPlayerContext,
							void **const ppvReplyBuffer,
							DWORD *const pdwReplyBufferSize,
							void **const ppvReplyBufferContext);

HRESULT DNHostDropPlayer(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 void *const pvBuffer);

HRESULT DNPrepareConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 CConnection *const pConnection,
							 CRefCountBuffer **const ppRefCountBuffer);

HRESULT DNConnectToHost1(DIRECTNETOBJECT *const pdnObject,
						 CConnection *const pConnection);

HRESULT DNConnectToHost2(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pvData,
						 CConnection *const pConnection);

HRESULT	DNConnectToHostFailed(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvBuffer,
							  const DWORD dwBufferSize,
							  CConnection *const pConnection);

HRESULT DNAbortConnect(DIRECTNETOBJECT *const pdnObject,
					   const HRESULT hrConnect);

HRESULT	DNPlayerConnect1(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pv,
						 CConnection *const pConnection);

HRESULT	DNConnectToPeer1(DIRECTNETOBJECT *const pdnObject,PVOID const pv);
HRESULT DNConnectToPeer2(DIRECTNETOBJECT *const pdnObject,PVOID const pv);

HRESULT	DNConnectToPeer3(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 CConnection *const pConnection);

HRESULT DNConnectToPeerFailed(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid);

HRESULT	DNSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry,
						  CConnection *const pConnection,
						  void *const pvReplyBuffer,
						  const DWORD dwReplyBufferSize);

HRESULT	DNReceiveConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer,
							 CConnection *const pHostConnection,
							 DPNID *const pdpnid);

HRESULT DNAbortLocalConnect(DIRECTNETOBJECT *const pdnObject);

// DirectNet - Disconnection routines
HRESULT DNLocalDisconnectNew(DIRECTNETOBJECT *const pdnObject);

HRESULT DNPlayerDisconnectNew(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnidDisconnecting);

HRESULT DNHostDisconnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnidDisconnecting,
						 const DWORD dwDestroyReason);

HRESULT DNInstructedDisconnect(DIRECTNETOBJECT *const pdnObject,
							   PVOID pv);

HRESULT DNProcessHostDestroyPlayer(DIRECTNETOBJECT *const pdnObject,void *const pv);

HRESULT DNGetClearAddress(DIRECTNETOBJECT *const pdnObject,
						  const HANDLE hEndPt,
						  IDirectPlay8Address **const ppAddress,
						  const BOOL fPartner);

HRESULT DNGetLocalDeviceAddress(DIRECTNETOBJECT *const pdnObject,
								const HANDLE hEndPt,
								IDirectPlay8Address **const ppAddress);

#endif	// __CONNECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\disconnect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Disconnect.cpp
 *  Content:    DNET disconnection routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/15/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Fixed PlayerDisconnect to prevent user notification of
 *							deletion from ALL_PLAYERS group
 *  12/23/99	mjn		Added basic host migration functionality
 *	12/28/99	mjn		Complete outstanding operations in DNPlayerDisconnectNew
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	01/03/00	mjn		Added DNPrepareToDeletePlayer
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/99	mjn		Moved NameTable stuff to NameTable.h
 *	01/09/00	mjn		Keep number of players in Application Description
 *	01/10/00	mjn		Check AppDesc for host migration
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/18/00	mjn		Added DNAutoDestructGroups
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/20/00	mjn		Fixed CBilink usage problem in DNLocalDisconnect
 *	01/22/00	mjn		Added DNProcessHostDestroyPlayer
 *	01/23/00	mjn		Update NameTable version for instructed disconnects
 *	01/24/00	mjn		Use DNNTUpdateVersion to update NameTable version
 *	01/25/00	mjn		Changed Host Migration to multi-step affair
 *	02/01/00	mjn		Implement Player/Group context values
 *	04/05/00	mjn		Updated DNProcessHostDestroyPlayer()
 *	04/12/00	mjn		Removed DNAutoDestructGroups - covered in NameTable.DeletePlayer()
 *				mjn		Don't set DN_OBJECT_FLAG_DISCONNECTING in DNPlayerDisconnect()
 *	04/18/00	mjn		Fixed player count problem
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	05/16/00	mjn		Do not take locks when clearing NameTable short-cut pointers
 *	06/06/00	mjn		Fixed DNPlayerDisconnect to always check for host migration in peer-peer mode w/ host migration flag
 *	07/07/00	mjn		Clear host migration status if new host disconnects during migration process
 *	07/20/00	mjn		Use ClearHostWithDPNID() to clear HostPlayer in DNPlayerDisconnectNew()
 *	07/29/00	mjn		Fix calls to DNUserConnectionTerminated()
 *	07/30/00	mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *				mjn		Removed DNProcessHostDestroyPlayer()
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Prevent DN_MSG_INTERNAL_DESTROY_PLAYER from being sent out in client/server
 *	08/06/00	mjn		Added CWorkerJob
 *	08/07/00	mjn		Added code to request peer-peer integrity checks and clean up afterwards
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/26/00	mjn		Removed locking from CNameTable::SetVersion() and CNameTable::GetNewVersion()
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	02/12/01	mjn		Fixed CConnection::GetEndPt() to track calling thread
 *	04/13/01	mjn		Remove request for integrity check from request list in DNInstructedDisconnect()
 *	07/22/01	mjn		Added DPNBUILD_NOHOSTMIGRATE compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNPlayerDisconnectNew
//
//	Another player has issued a disconnect with the local player.
//	- If the disconnecting player is still in the nametable
//		- prepare to delete player
//		- Save one refcount to be released by DELETE_PLAYER from host or Close
//	- check host migration

#undef DPF_MODNAME
#define DPF_MODNAME "DNPlayerDisconnectNew"

HRESULT DNPlayerDisconnectNew(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid)
{
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	HRESULT				hResultCode;
#ifndef	DPNBUILD_NOHOSTMIGRATE
	DPNID				dpnidNewHost;
#endif // !DPNBUILD_NOHOSTMIGRATE
	BOOL				fWasHost;
	BOOL				fRequestIntegrityCheck;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx]",dpnid);

	DNASSERT(pdnObject != NULL);

	pNTEntry = NULL;
	pLocalPlayer = NULL;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		//
		//	The Server has disconnected
		//	We will indicate the connection terminated and shut down
		//
		DPFX(DPFPREP, 5,"Server has disconnected from this client");
		DNUserTerminateSession(pdnObject,DPNERR_CONNECTIONLOST,NULL,0);
		DNTerminateSession(pdnObject,DPNERR_CONNECTIONLOST);
	}
	else
	{
		//
		//	Another peer has disconnected from this peer
		//	We will delete this player from the NameTable
		//	We may have to ask the host to perform an integrity check
		//
		DPFX(DPFPREP, 5,"Peer has disconnected from this peer");
		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find disconnecting player in NameTable");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		fRequestIntegrityCheck = FALSE;
		pNTEntry->Lock();
		if (pNTEntry->IsAvailable())
		{
			fRequestIntegrityCheck = TRUE;
		}
		pNTEntry->Unlock();
		if (fRequestIntegrityCheck)
		{
			DNRequestIntegrityCheck(pdnObject,dpnid);
		}
		pdnObject->NameTable.DeletePlayer(dpnid,0);

		//
		//	If this was the Host, clear the short-cut pointer
		//
		fWasHost = pdnObject->NameTable.ClearHostWithDPNID( dpnid );

		//
		//	May need to clear HOST_MIGRATING flag
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if ((pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING) && (pdnObject->pNewHost == pNTEntry))
		{
			pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_HOST_MIGRATING);
			pdnObject->pNewHost->Release();
			pdnObject->pNewHost = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

#ifndef	DPNBUILD_NOHOSTMIGRATE
		//
		//	If HostMigration flag is set, check to see if we are the new Host.
		//	Otherwise, if the disconnecting player was the Host, the session is lost.
		//
		if (pdnObject->ApplicationDesc.AllowHostMigrate())
		{
			DPFX(DPFPREP, 5,"Host-Migration was set - check for new Host");
			dpnidNewHost = 0;
			if ((hResultCode = DNFindNewHost(pdnObject,&dpnidNewHost)) == DPN_OK)
			{
				DPFX(DPFPREP, 5,"New Host [0x%lx]",dpnidNewHost);
				if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer)) == DPN_OK)
				{
					if (pLocalPlayer->GetDPNID() == dpnidNewHost)
					{
						DPFX(DPFPREP, 5,"Local player is new Host");
						hResultCode = DNPerformHostMigration1(pdnObject,dpnid);
					}

					pLocalPlayer->Release();
					pLocalPlayer = NULL;
				}
			}
		}
		else
#endif // DPNBUILD_NOHOSTMIGRATE
		{
			if (fWasHost)
			{
				DPFX(DPFPREP, 5,"Host-Migration was not set - terminating session");
				DNUserTerminateSession(pdnObject,DPNERR_CONNECTIONLOST,NULL,0);
				DNTerminateSession(pdnObject,DPNERR_CONNECTIONLOST);
			}
		}

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DNHostDisconnect
//
//	A player has initiated a disconnect with the host.
//	- Remove player from the name table
//	- Propegate DELETE_PLAYER messages to each player
#pragma TODO(minara,"Use pConnection instead of dpnidDisconnecting ?")

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDisconnect"

HRESULT DNHostDisconnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnidDisconnecting,
						 const DWORD dwDestroyReason)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CPendingDeletion	*pPending;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_DESTROY_PLAYER	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pdnObject [0x%p], dpnidDisconnecting [0x%lx], dwDestroyReason [0x%lx]",
			pdnObject,dpnidDisconnecting,dwDestroyReason);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidDisconnecting != 0);

	pRefCountBuffer = NULL;
	pPending = NULL;
	pWorkerJob = NULL;

	// Remove entry from NameTable and inform other players, only if Host is NOT migrating
	//	Otherwise, clean-up first and wait for migration to complete before informing others
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING))
	{
		DWORD			dwVersion;
		CNameTableEntry	*pNTEntry;

		dwVersion = 0;
		pNTEntry = NULL;

		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidDisconnecting,&pNTEntry)) == DPN_OK)
		{
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( dwDestroyReason );
			}
			pNTEntry->Unlock();
			pNTEntry->Release();
			pNTEntry = NULL;
		}
		hResultCode = pdnObject->NameTable.DeletePlayer(dpnidDisconnecting,&dwVersion);

		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			//
			//	Prepare internal message
			//
			hResultCode = RefCountBufferNew(pdnObject,
											sizeof(DN_INTERNAL_MESSAGE_DESTROY_PLAYER),
											MemoryBlockAlloc,
											MemoryBlockFree,
											&pRefCountBuffer);
			if (hResultCode != DPN_OK)
			{
				DPFERR("Could not allocate message buffer");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_DESTROY_PLAYER*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidLeaving = dpnidDisconnecting;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dwDestroyReason = dwDestroyReason;

			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create worker job");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_DESTROY_PLAYER );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( dpnidDisconnecting );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}
	else
	{
		//
		//	Put this on the Outstanding operation list
		//
		if ((hResultCode = PendingDeletionNew(pdnObject,&pPending)) == DPN_OK)
		{
			pPending->SetDPNID( dpnidDisconnecting );

			DNEnterCriticalSection(&pdnObject->csNameTableOpList);
			pPending->m_bilinkPendingDeletions.InsertBefore(&pdnObject->m_bilinkPendingDeletions);
			DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

			pPending = NULL;
		}

#ifndef	DPNBUILD_NOHOSTMIGRATE
		// See if we can continue with Host migration
		DNCheckReceivedAllVersions(pdnObject);
#endif // DPNBUILD_NOHOSTMIGRATE
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]", hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pPending)
	{
		pPending->ReturnSelfToPool();
		pPending = NULL;
	}
	goto Exit;
}


//	DNInstructedDisconnect
//
//	The host has instructed the local player to delete another player from the nametable
//	- If already closing
//		- ignore this message and return
//	- Prepare to delete player
//	- Release refcount of player

#undef DPF_MODNAME
#define DPF_MODNAME "DNInstructedDisconnect"

HRESULT DNInstructedDisconnect(DIRECTNETOBJECT *const pdnObject,
							   PVOID pv)
{
	HRESULT				hResultCode;
	DWORD				dwVersion;
	CNameTableEntry		*pNTEntry;
	UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_PLAYER	*pInfo;

	DPFX(DPFPREP, 4,"Parameters: pv [0x%p]",pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	pNTEntry = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_DESTROY_PLAYER*>(pv);

	DNASSERT(pInfo != NULL);
	DNASSERT(pInfo->dpnidLeaving != NULL);
	DNASSERT(pInfo->dwVersion != 0);

	DPFX(DPFPREP, 5,"Deleting player [0x%lx]",pInfo->dpnidLeaving);

	//
	//	If the player is still in the NameTable, we will preset the destroy reason.
	//	We will also use this "hint" to initiate a disconnect just in case the protocol
	//	
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnidLeaving,&pNTEntry)) == DPN_OK)
	{
		CConnection		*pConnection;
		CCallbackThread	CallbackThread;
		HANDLE			hEndPt;

		pConnection = NULL;
		CallbackThread.Initialize();
		hEndPt = NULL;

		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( pInfo->dwDestroyReason );
		}
		pNTEntry->Unlock();

		//
		//	Attempt a disconnect
		//
		if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) == DPN_OK)
			{
				DNPerformDisconnect(pdnObject,pConnection,hEndPt,FALSE);

				pConnection->ReleaseEndPt(&CallbackThread);
			}
			pConnection->Release();
			pConnection = NULL;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		CallbackThread.Deinitialize();
	}
	else
	{
		//
		//	Scan oustanding op list for integrity check request for this player.
		//	If found, remove it from the request list and the handle table
		//
		CBilink		*pBilink;
		CAsyncOp	*pAsyncOp;
		DN_SEND_OP_DATA	*pSendOpData;

		pAsyncOp = NULL;
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pBilink = pdnObject->m_bilinkRequestList.GetNext();
		while (pBilink != &pdnObject->m_bilinkRequestList)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
			DNASSERT(pAsyncOp->GetOpType() == ASYNC_OP_REQUEST);
			pSendOpData = pAsyncOp->GetLocalSendOpData();
			if (pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK)
			{
				UNALIGNED DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK	*pMsg;

				pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK*>
					(reinterpret_cast<UNALIGNED DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pSendOpData->BufferDesc[1].pBufferData) + 1);
				if (pMsg->dpnidTarget == pInfo->dpnidLeaving)
				{
					pAsyncOp->m_bilinkActiveList.RemoveFromList();
					pAsyncOp->AddRef();
					break;
				}
			}
			pSendOpData = NULL;
			pAsyncOp = NULL;
			pBilink = pBilink->GetNext();
		}
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		if (pAsyncOp != NULL)
		{
			DNASSERT(pAsyncOp->GetHandle() != 0);
			if (SUCCEEDED(pdnObject->HandleTable.Destroy( pAsyncOp->GetHandle(), NULL )))
			{
				// Release the HandleTable reference
				pAsyncOp->Release();
			}
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
		DNASSERT(pAsyncOp == NULL);
	}

	dwVersion = pInfo->dwVersion;
	pdnObject->NameTable.DeletePlayer(pInfo->dpnidLeaving,&dwVersion);

	//
	//	Update NameTable version
	//
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion(pInfo->dwVersion);
	pdnObject->NameTable.Unlock();

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\corereceive.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Receive.cpp
 *  Content:    Receive user messages
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/27/99	mjn		Created
 *	02/01/00	mjn		Implement Player/Group context values
 *	04/06/00	mjn		Prevent receives from being passed up until after ADD_PLAYER notification
 *	04/13/00	mjn		Fixed bug in DNReceiveUserData
 *	04/20/00	mjn		ReceiveBuffers use CAsyncOp
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	06/25/00	mjn		Always wait for sending player to be available before indicating receives from them
 *	08/02/00	mjn		Added CQueuedMsg to queue incoming messages for players who have not been indicated yet
 *				mjn		Added hCompletionOp and dwFlags to DNReceiveUserData()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *	08/08/00	mjn		Used CNameTableEntry::IsCreated() to determine if clients or peers may receive
 *	08/31/00	mjn		AddRef DirectNetLock during receives to prevent leaking operations
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added service provider to DNReceiveUserData()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNReceiveUserData
//
//	Pass received user data to the user.
//	This is normally a simple undertaking, but since we allow the user to
//	retain ownership of the buffer, there is an added level of complexity.
//
//	We also need to handle the condition of the player receiving data from
//	another player for whom he has not received a CREATE_PLAYER notification.
//	In this case, we will queue the messages on the NameTableEntry, and
//	once the player has been indicated as created, we will drain the queue.
//	Also, if the player entry is in use, we will queue the message so that
//	the thread currently indicating up the user will process this receive for us.

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveUserData"

HRESULT	DNReceiveUserData(DIRECTNETOBJECT *const pdnObject,
						  CConnection *const pConnection,
						  BYTE *const pBufferData,
						  const DWORD dwBufferSize,
						  const HANDLE hProtocol,
						  CRefCountBuffer *const pRefCountBuffer,
						  const DPNHANDLE hCompletionOp,
						  const DWORD dwFlags)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DPNHANDLE		hAsyncOp;
	CNameTableEntry	*pNTEntry;
	BOOL			fQueueMsg;
	BOOL			fReleaseLock;

	DPFX(DPFPREP, 6,"Parameters: pConnection [0x%p], pBufferData [0x%p], dwBufferSize [0x%lx], hProtocol [0x%p], pRefCountBuffer [0x%p], hCompletionOp [0x%p], dwFlags [0x%lx]",
			pConnection,pBufferData,dwBufferSize,hProtocol,pRefCountBuffer,hCompletionOp,dwFlags);

	DNASSERT(pBufferData != NULL);
	DNASSERT(hProtocol == NULL || pRefCountBuffer == NULL);	// One or the other - not both

	hAsyncOp = 0;
	pAsyncOp = NULL;
	pNTEntry = NULL;
	fReleaseLock = FALSE;

	//
	//	Keep DirectNetObject from vanishing under us !
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		DPFERR("Aborting receive - object is closing");
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Find sending player's NameTableEntry
	//
#ifndef DPNBUILD_NOSERVER
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER|DN_OBJECT_FLAG_SERVER))
#else
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER))
#endif // DPNBUILD_NOSERVER
	{
		if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) != DPN_OK)
		{
			DPFERR("Player no longer in NameTable");
			DisplayDNError(0,hResultCode);

			//
			//	Try "deleted" list
			//
			if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(pConnection->GetDPNID(),&pNTEntry)) != DPN_OK)
			{
				DPFERR("Player not in deleted list either");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
		}
	}
#ifndef	DPNBUILD_NOMULTICAST
	else if (pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST)
	{
	}
#endif	// DPNBUILD_NOMULTICAST
	else
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DPFERR("Could not find Host player");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	//
	//	Create an AsyncOp for this receive
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->HandleTable.Create(pAsyncOp,&hAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create Handle for AsyncOp");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	else
	{
		// Add a reference for the HandleTable
		pAsyncOp->AddRef();
		pAsyncOp->Lock();
		pAsyncOp->SetHandle(hAsyncOp);
		pAsyncOp->Unlock();
	}
	pAsyncOp->SetOpType( ASYNC_OP_RECEIVE_BUFFER );
	pAsyncOp->SetRefCountBuffer( pRefCountBuffer );
	pAsyncOp->SetSP( pConnection->GetSP() );

	//
	//	Add buffer to list of active AsyncOp's
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	fQueueMsg = FALSE;
#ifndef	DPNBUILD_NOMULTICAST
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST))
	{
#endif	// DPNBUILD_NOMULTICAST
	pNTEntry->Lock();
	if (pNTEntry->IsDisconnecting())
	{
		pNTEntry->Unlock();
		DPFERR("Message received from disconnecting player - ignoring");
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (pNTEntry->IsInUse())
	{
		//
		//	If the player entry is in use, we will queue the message
		//
		fQueueMsg = TRUE;
	}
	else
	{
		//
		//	If the player entry is not in use, but the target player is not available (not created)
		//	we will queue the message
		//
		if (	((pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT) && !pNTEntry->IsAvailable())	||
				(!(pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT) && !pNTEntry->IsCreated())		)
		{
			fQueueMsg = TRUE;
		}
		else
		{
			//
			//	If there are other messages queued, add this to the queue
			//
			if (!pNTEntry->m_bilinkQueuedMsgs.IsEmpty())
			{
				fQueueMsg = TRUE;
			}
			else
			{
				pNTEntry->SetInUse();
			}
		}
	}
#ifndef	DPNBUILD_NOMULTICAST
	}
#endif	// DPNBUILD_NOMULTICAST

	//
	//	If required, add the message to the end of the queue, otherwise process it
	//
	if (fQueueMsg)
	{
		CQueuedMsg	*pQueuedMsg;

		pQueuedMsg = NULL;

		if ((hResultCode = QueuedMsgNew(pdnObject,&pQueuedMsg)) != DPN_OK)
		{
			pNTEntry->Unlock();
			DPFERR("Could not create queued message");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}
		pAsyncOp->SetProtocolHandle( hProtocol );
		pAsyncOp->SetCompletion( DNCompleteReceiveBuffer );

		pQueuedMsg->SetOpType( RECEIVE );
		pQueuedMsg->SetBuffer( pBufferData );
		pQueuedMsg->SetBufferSize( dwBufferSize );
		pQueuedMsg->SetAsyncOp( pAsyncOp );
		if (dwFlags & DN_SENDFLAGS_SET_USER_FLAG_TWO)
		{
#ifndef DPNBUILD_NOVOICE
			pQueuedMsg->MakeVoiceMessage();
#else
			DNASSERT(FALSE);
#endif // DPNBUILD_NOVOICE
		}
		if (hCompletionOp)
		{
			pQueuedMsg->SetCompletionOp( hCompletionOp );
		}
		pQueuedMsg->m_bilinkQueuedMsgs.InsertBefore( &pNTEntry->m_bilinkQueuedMsgs );
#ifdef DBG
		pNTEntry->m_lNumQueuedMsgs++;
		if ((pNTEntry->m_lNumQueuedMsgs % 25) == 0)
		{
			DPFX(DPFPREP, 1, "Queue now contains %d msgs from player [0x%lx], the CREATE_PLAYER might be taking a long time and sender may need to back off.", pNTEntry->m_lNumQueuedMsgs, pNTEntry->GetDPNID());
		}
#endif // DBG


		pNTEntry->NotifyAddRef();
		pNTEntry->Unlock();

		hResultCode = DPNERR_PENDING;
	}
	else
	{
		//
		//	Hand the message directly to the user
		//
		HRESULT		hrProcess;
		HRESULT		hr;
//		CQueuedMsg	*pQueuedMsg;

#ifndef	DPNBUILD_NOMULTICAST
		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST))
		{
#endif	// DPNBUILD_NOMULTICAST

		//
		//	Hand message up and track it if the user returns DPNERR_PENDING.
		//	Otherwise, let it go
		//
		pNTEntry->NotifyAddRef();
		pNTEntry->Unlock();
		if (dwFlags & DN_SENDFLAGS_SET_USER_FLAG_TWO)
		{
#ifndef DPNBUILD_NOVOICE
			hr = Voice_Receive(	pdnObject,
								pNTEntry->GetDPNID(),
								0,
								pBufferData,
								dwBufferSize);

			pNTEntry->NotifyRelease();
#else
			DNASSERT(FALSE);
#endif // DPNBUILD_NOVOICE
		}
		else
		{
			hr = DNUserReceive(	pdnObject,
								pNTEntry,
								pBufferData,
								dwBufferSize,
								hAsyncOp);
			if (hCompletionOp != 0)
			{
				hResultCode = DNSendUserProcessCompletion(pdnObject,pConnection,hCompletionOp);
			}
		}
#ifndef	DPNBUILD_NOMULTICAST
		}
		else
		{
			hr = DNUserReceiveMulticast(pdnObject,
										pConnection->GetContext(),
										NULL,
										NULL,
										pBufferData,
										dwBufferSize,
										hAsyncOp);
		}
#endif	// DPNBUILD_NOMULTICAST

		if (hr == DPNERR_PENDING)
		{
			if (!pRefCountBuffer)
			{
				pAsyncOp->SetProtocolHandle( hProtocol );
				pAsyncOp->SetCompletion(DNCompleteReceiveBuffer);
			}
			hrProcess = DPNERR_PENDING;
		}
		else
		{
			DNEnterCriticalSection(&pdnObject->csActiveList);
			pAsyncOp->m_bilinkActiveList.RemoveFromList();
			DNLeaveCriticalSection(&pdnObject->csActiveList);
			pAsyncOp->Lock();
			if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
			{
				pAsyncOp->SetComplete();
				pAsyncOp->Unlock();
				if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOp, NULL )))
				{
					// Release the HandleTable reference
					pAsyncOp->Release();
				}
				hAsyncOp = 0;
			}
			else
			{
				pAsyncOp->Unlock();
			}
			hrProcess = DPN_OK;
		}

		//
		//	Perform any queued messages which need to be indicated up to the user
		//
		if (pNTEntry)
		{
			pNTEntry->PerformQueuedOperations();
		}
		hResultCode = hrProcess;
	}



	DNDecRefLock(pdnObject);
	fReleaseLock = FALSE;

	pAsyncOp->Release();
	pAsyncOp = NULL;
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (hAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOp, NULL )))
		{
			// Release the HandleTable reference
			pAsyncOp->Release();
		}
		hAsyncOp = 0;
	}
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNSendUserProcessCompletion
//
//	Send a PROCESS_COMPLETION for a user message.  This indicates that a message was received and
//	handed to the user's message handler.

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendUserProcessCompletion"

HRESULT DNSendUserProcessCompletion(DIRECTNETOBJECT *const pdnObject,
									CConnection *const pConnection,
									const DPNHANDLE hCompletionOp)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_PROCESS_COMPLETION	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p], hCompletionOp [0x%lx]",pConnection,hCompletionOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pRefCountBuffer = NULL;

	//
	//	Create process completion
	//
	if ((hResultCode = RefCountBufferNew(	pdnObject,
											sizeof(DN_INTERNAL_MESSAGE_PROCESS_COMPLETION),
											MemoryBlockAlloc,
											MemoryBlockFree,
											&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer for processed response");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_PROCESS_COMPLETION*>(pRefCountBuffer->GetBufferAddress());
	pMsg->hCompletionOp = hCompletionOp;

	//
	//	SEND process completion
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_PROCESS_COMPLETION,
								pConnection->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not SEND process completion");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		DNASSERT(FALSE);
		goto Failure;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNFreeProtocolBuffer"

void DNFreeProtocolBuffer(void *const pvContext, void *const pvBuffer)
{
	DNPReleaseReceiveBuffer(((DIRECTNETOBJECT*)pvContext)->pdnProtocolData, pvBuffer);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteReceiveBuffer"

void DNCompleteReceiveBuffer(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNASSERT(pAsyncOp->GetProtocolHandle()  != NULL);

	DNPReleaseReceiveBuffer( pdnObject->pdnProtocolData, pAsyncOp->GetProtocolHandle() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\dncore.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dncore.h
 *  Content:    DIRECT NET CORE HEADER FILE
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	10/08/99	jtk		Moved COM interfaces into separate files
 *	11/09/99	mjn		Moved Worker Thread constants/structures to separate file
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Added host migration structures and functions
 *	12/28/99	mjn		Added DNCompleteOutstandingOperations
 *	12/28/99	mjn		Added NameTable version to Host migration message
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/03/00	mjn		Added DNPrepareToDeletePlayer
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/08/00	mjn		Added DN_INTERNAL_MESSAGE_CONNECT_FAILED
 *	01/08/00	mjn		Removed unused connection info
 *	01/09/00	mjn		Added Application Description routines
 *						Changed SEND/ACK NAMETABLE to SEND/ACK CONNECT INFO
 *	01/10/00	mjn		Added DNSendUpdateAppDescMessage and DN_UserUpdateAppDesc
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *						Moved Application Description stuff to AppDesc.h
 *						Moved Connect/Disconnect stuff to Connect.h
 *	01/13/00	mjn		Added CFixedPools for CRefCountBuffers
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY_INFO
 *	01/14/00	mjn		Moved Message stuff to Message.h
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Modified User message handler definition
 *						Moved User call back stuff to User.h
 *	01/17/00	mjn		Added DN_MSG_INTERNAL_VOICE_SEND and DN_MSG_INTERNAL_BUFFER_IN_USE
 *	01/18/00	mjn		Moved NameTable info structures to NameTable.h
 *	01/19/00	mjn		Added structures for NameTable Operation List
 *	01/20/00	mjn		Moved internal messages to Message.h
 *	01/21/00	mjn		Removed DNAcknowledgeHostRequest
 *	01/23/00	mjn		Added DN_MSG_INTERNAL_HOST_DESTROY_PLAYER
 *	01/24/00	mjn		Implemented NameTable operation list clean up
 *	01/25/00	mjn		Changed Host Migration to multi-step affair
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	01/27/00	mjn		Reordered DN_MSG_INTERNAL's
 *	01/31/00	mjn		Added Internal FPM's for RefCountBuffers
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	03/23/00	mjn		Implemented RegisterLobby()
 *	04/04/00	mjn		Added DN_MSG_INTERNAL_TERMINATE_SESSION
 *	04/09/00	mjn		Added support for CAsyncOp
 *	04/11/00	mjn		Moved DN_INTERNAL_MESSAGE_HEADER from Async.h
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	04/23/00	mjn		Replaced DN_MSG_INTERNAL_SEND_PROCESSED with DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION
 *				mjn		Replaced DN_MSG_INTERNAL_SEND_PROCESSED_COMPLETE with DN_MSG_INTERNAL_PROCESS_COMPLETION
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/28/00	mjn		Code clean up - removed comments and unused consts/structs/funcs
 *	05/23/00	mjn		Added DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED
 *	07/05/00	mjn		Removed references to DN_MSG_INTERNAL_ENUM_WITH_APPLICATION_GUID,DN_MSG_INTERNAL_ENUM,DN_MSG_INTERNAL_ENUM_RESPONSE
 *	07/07/00	mjn		Added pNewHost as host migration target to DirectNetObject
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *	07/12/00	mjn		Moved internal messages back to Message.h
 *	07/17/00	mjn		Add signature to DirectNetObject
 *	07/28/00	mjn		Added m_bilinkConnections to DirectNetObject
 *	07/30/00	mjn		Added CPendingDeletion
 *	07/31/00	mjn		Added CQueuedMsg
 *	08/05/00	mjn		Added m_bilinkActiveList and csActiveList
 *	08/06/00	mjn		Added CWorkerJob
 *	08/09/00	mjn		Added csConnectionList and m_bilinkIndicated
 *	08/11/00	mjn		Added DN_OBJECT_FLAG_HOST_MIGRATING_2 flag (!)
 *	08/23/00	mjn		Added DN_OBJECT_FLAG_DPNSVR_REGISTERED
 *	08/23/00	mjn		Added CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *  09/13/00	rmt		Bug #44625 - DPVOICE: Multihomed machines are not always enumerable (Added DN_OBJECT_FLAG_LOCALHOST flag).
 *	02/05/01	mjn		Removed unused debug members from DIRECTNETOBJECT
 *				mjn		Added CCallbackThread
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added pConnectSP,dwMaxFrameSize
 *				mjn		Removed blSPCapsList
 *	04/04/01	mjn		Re-ordered DirectNetObject fields
 *				mjn		Revised minor version number for DirectX8.1
 *				mjn		Added voice and lobby sigs
 *	04/05/01	mjn		Added DPNID parameter to DNProcessHostMigration3()
 *	04/13/01	mjn		Added m_bilinkRequestList
 *	05/17/01	mjn		Added dwRunningOpCount,hRunningOpEvent,dwWaitingThreadID to track threads performing NameTable operations
 *	10/08/01	vanceo	Added multicast support
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DNCORE_H__
#define	__DNCORE_H__

#include "AppDesc.h"
#include "HandleTable.h"
#include "NameTable.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//
//	Core version history
//
//	0.1		DirectX 8.0
//	0.2		DirectX 8.1
//	0.3		PocketPC
//	0.4
//	0.5		Windows Server 2003
//	0.6		DirectX 9.0
//
#define DN_VERSION_MAJOR					0x0000
#define DN_VERSION_MINOR					0x0005
#define DN_VERSION_CURRENT					((DN_VERSION_MAJOR << 16) | DN_VERSION_MINOR)

#define DN_OBJECT_FLAG_INITIALIZED			0x80000000
#ifndef DPNBUILD_NOLOBBY
#define DN_OBJECT_FLAG_LOBBY_AWARE			0x40000000
#endif // ! DPNBUILD_NOLOBBY
#define DN_OBJECT_FLAG_DPNSVR_REGISTERED	0x20000000
#define DN_OBJECT_FLAG_LOCALHOST			0x10000000
#define	DN_OBJECT_FLAG_DISALLOW_ENUMS		0x04000000
#define DN_OBJECT_FLAG_LISTENING			0x02000000
#define DN_OBJECT_FLAG_ENUMERATING			0x01000000
#define DN_OBJECT_FLAG_HOST_CONNECTED		0x00400000 // the original host will never have this flag set
#define DN_OBJECT_FLAG_CONNECTING			0x00200000
#define DN_OBJECT_FLAG_CONNECTED			0x00100000
#define DN_OBJECT_FLAG_DISCONNECTING		0x00040000
#define	DN_OBJECT_FLAG_CLOSING_IMMEDIATE	0x00020000
#define DN_OBJECT_FLAG_CLOSING				0x00010000
#define DN_OBJECT_FLAG_HOST_MIGRATING_WAIT	0x00004000	// Wait for running operations to finish
#define DN_OBJECT_FLAG_HOST_MIGRATING_2		0x00002000
#define DN_OBJECT_FLAG_HOST_MIGRATING		0x00001000

#ifndef DPNBUILD_NOPARAMVAL
#define DN_OBJECT_FLAG_PARAMVALIDATION		0x00000010
#endif // !DPNBUILD_NOPARAMVAL

#ifndef DPNBUILD_NOMULTICAST
#define DN_OBJECT_FLAG_MULTICAST			0x00000008
#endif // ! DPNBUILD_NOMULTICAST

#define DN_OBJECT_FLAG_PEER					0x00000004
#define DN_OBJECT_FLAG_CLIENT				0x00000002

#ifndef DPNBUILD_NOSERVER
#define DN_OBJECT_FLAG_SERVER				0x00000001
#endif // ! DPNBUILD_NOSERVER

#define DN_GUID_STR_LEN						38			// {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}
#define DN_FLAG_STR_LEN						5			// FALSE (or TRUE or YES or NO)

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_ONLYONEADAPTER)))
#define MAX_HOST_ADDRESSES					1
#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_ONLYONEADAPTER
#define MAX_HOST_ADDRESSES					8
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_ONLYONEADAPTER

#undef DPF_SUBCOMP
#define DPF_SUBCOMP	DN_SUBCOMP_CORE // Used by Debug Logging to determine sub-component

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef DPNBUILD_NOPARAMVAL
#define TRY 			_try
#define EXCEPT(a)		_except( a )
#endif // !DPNBUILD_NOPARAMVAL


//**********************************************************************
// Global definitions
//**********************************************************************

extern DN_PROTOCOL_INTERFACE_VTBL	g_ProtocolVTBL;

#ifndef DPNBUILD_LIBINTERFACE
extern LONG							g_lCoreObjectCount;
#endif // ! DPNBUILD_LIBINTERFACE


//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct IDirectPlay8Address	IDirectPlay8Address;				// DPNAddr.h
typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;

class CAsyncOp;
class CServiceProvider;
class CSyncEvent;


#ifndef DPNBUILD_NOVOICE
//
// Voice Additions
//
// this is the number of clients of IDirectPlayVoice in this process
// this is actually a ridiculously large number of client slots.
//
#define MAX_VOICE_CLIENTS	32	
#endif // !DPNBUILD_NOVOICE

typedef struct _DIRECTNETOBJECT 
{
#ifdef DPNBUILD_LIBINTERFACE
	//
	//	For lib interface builds, the interface Vtbl and refcount are embedded in the object itself.
	//
	LPVOID					lpVtbl;					// must be first entry in structure
	LONG					lRefCount;
#endif // DPNBUILD_LIBINTERFACE

	BYTE					Sig[4];					// Signature

	//
	//	DirectNet object flags
	//	Protected by csDirectNetObject
	//
	DWORD	volatile		dwFlags;

	//
	//	User information
	//	Protected by csDirectNetObject
	//
	PVOID					pvUserContext;
	PFNDPNMESSAGEHANDLER	pfnDnUserMessageHandler;

	//
	//	Shutdown info
	//	Protected by csDirectNetObject
	//
	DWORD	volatile		dwLockCount;			// Count to prevent closing
	DNHANDLE				hLockEvent;				// Set when dwLockCount=0

	//
	//	Protocol information
	//	Protected by csDirectNetObject
	//
	LONG	volatile		lProtocolRefCount;		// Protocol usage
	CSyncEvent				*hProtocolShutdownEvent;// No outstanding protocol operations
	HANDLE					pdnProtocolData;

	//
	//	Listen information
	//	Protected by csDirectNetObject
	//
	CAsyncOp				*pListenParent;			// LISTEN async op
	DWORD					dwMaxFrameSize;			// Max frame size (cached for enum payload size checks)

	//
	//	Connect information
	//	Protected by csDirectNetObject
	//
	CAsyncOp				*pConnectParent;		// CONNECT async op
	PVOID					pvConnectData;			// Connect data
	DWORD					dwConnectDataSize;
	CServiceProvider		*pConnectSP;			// SP used to connect (cached for future connects)
	IDirectPlay8Address		*pIDP8ADevice;			// SP Local Device
	IDirectPlay8Address		*pConnectAddress;		// Connect Address (cached) for clients

	//
	//	Host migration information
	//	Protected by csDirectNetObject
	//
	CNameTableEntry			*pNewHost;				// Host migration target
	DWORD	volatile		dwRunningOpCount;		// Running operation count (wait for them during host migration)
	DNHANDLE				hRunningOpEvent;		// Running operation event (set when running ops finish)
	DWORD	volatile		dwWaitingThreadID;		// Last thread to wait for outstanding running operations

	//
	//	Outstanding callback threads	(use csCallbackThreads)
	//	Protected by csCallbackThreads
	//
	CBilink					m_bilinkCallbackThreads;

#ifdef DBG
	//
	//	Outstanding CAsyncOps
	//	Protected by csAsyncOperations
	//
	CBilink					m_bilinkAsyncOps;
#endif // DBG

	//
	//	Outstanding CConnections
	//	Protected by csConnectionList
	//
	CBilink					m_bilinkConnections;
	CBilink					m_bilinkIndicated;		// Indicated connections

	//
	//	Active CAsyncOps (w/ protocol handles, no requests)
	//	Protected by csActiveList
	//
	CBilink					m_bilinkActiveList;

	//
	//	Request CAsyncOps (no active CAsyncOps)
	//	Protected by csActiveList
	//
	CBilink					m_bilinkRequestList;

	//
	//	CBilink of NameTable pending deletions
	//	Protected by csNameTableOpList
	//
	CBilink					m_bilinkPendingDeletions;

	//
	//	Protected by csServiceProviders
	//
#ifdef DPNBUILD_ONLYONESP
	CServiceProvider *		pOnlySP;
#else // ! DPNBUILD_ONLYONESP
	CBilink					m_bilinkServiceProviders;
#endif // ! DPNBUILD_ONLYONESP

#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	//
	//	Protected by csWorkerQueue
	//
	CBilink					m_bilinkWorkerJobs;
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE
	IDirectPlay8ThreadPoolWork	*pIDPThreadPoolWork;	// pointer to thread pool work interface
	DWORD					dwClosingThreadID; // ID of thread that called Close
#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	LONG	volatile		lThreadPoolRefCount;
	CSyncEvent				*ThreadPoolShutDownEvent;
	BOOL					fProcessingWorkerJobs;	// whether a thread is currently processing worker jobs or not
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE

	//
	//	Application Description
	//
	CApplicationDesc		ApplicationDesc;

	//
	//	Name Table
	//
	CNameTable				NameTable;

	//
	//	Handle Table
	//
	CHandleTable			HandleTable;

	//
	//	Critical Sections
	//
#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION		csDirectNetObject;		// access control critical section

	DNCRITICAL_SECTION		csCallbackThreads;		// CS to protect callback thread list CBilink

#ifdef DBG
	DNCRITICAL_SECTION		csAsyncOperations;		// CS to protect outstanding async CBilink
#endif // DBG

	DNCRITICAL_SECTION		csActiveList;			// CS to protect active list of AsyncOps

	DNCRITICAL_SECTION		csConnectionList;		// CS to protect Connection list

	DNCRITICAL_SECTION		csNameTableOpList;		// CS to protect NameTable operation list

	DNCRITICAL_SECTION		csServiceProviders;		// CS to protect Service Provider list

#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	DNCRITICAL_SECTION		csWorkerQueue;			// CS to protect worker thread job queue
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE

#ifndef DPNBUILD_NOVOICE
	DNCRITICAL_SECTION		csVoice;				// CS to protect voice
#endif // !DPNBUILD_NOVOICE
#endif // !DPNBUILD_ONLYONETHREAD

#ifndef DPNBUILD_NOVOICE
	//
	//	Voice Additions
	//	Protected by csVoice
	//
	BYTE					VoiceSig[4];
	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;

	//
	//	Send Target Cache for voice targets on DV_SendSpeechEx
	//	Protected by csVoice
	//
	DWORD					nTargets;			     // number of used entries in the target list
	DWORD					nTargetListLen;          // max number of target list entries list can hold
	PDPNID					pTargetList;	  	   // ptr to target list array
	DWORD					nExpandedTargets;        // simplified list of targets, removes dup's
	DWORD					nExpandedTargetListLen;  // max number of target list entries list can hold
	PDPNID					pExpandedTargetList;	// ptr to array of simplified list of targets
#endif // !DPNBUILD_NOVOICE

#ifndef DPNBUILD_NOLOBBY
	//
	//	Lobby additions
	//
	BYTE					LobbySig[4];
	DPNHANDLE				dpnhLobbyConnection;	// Lobby Connection to update

	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
#endif // ! DPNBUILD_NOLOBBY

#ifndef DPNBUILD_NOMULTICAST
	//
	//	Multicast additions
	//	Protected by csDirectNetObject
	//
	CConnection				*pMulticastSend;		// Multicast send connection
	CBilink					m_bilinkMulticast;		// Multicast receive connections
#endif // ! DPNBUILD_NOMULTICAST

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	BOOL					fPoolsPrepopulated;			// whether these pools have been prepopulated yet or not
	CFixedPool				EnumReplyMemoryBlockPool;	// pool for enum reply buffers
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
} DIRECTNETOBJECT, *PDIRECTNETOBJECT;


//**********************************************************************
// Variable definitions
//**********************************************************************

extern CFixedPool g_RefCountBufferPool;
extern CFixedPool g_SyncEventPool;
extern CFixedPool g_ConnectionPool;
extern CFixedPool g_GroupConnectionPool;
extern CFixedPool g_GroupMemberPool;
extern CFixedPool g_NameTableEntryPool;
extern CFixedPool g_NameTableOpPool;
extern CFixedPool g_AsyncOpPool;
extern CFixedPool g_PendingDeletionPool;
extern CFixedPool g_QueuedMsgPool;
extern CFixedPool g_WorkerJobPool;
extern CFixedPool g_MemoryBlockTinyPool;
extern CFixedPool g_MemoryBlockSmallPool;
extern CFixedPool g_MemoryBlockMediumPool;
extern CFixedPool g_MemoryBlockLargePool;
extern CFixedPool g_MemoryBlockHugePool;

#ifdef DPNBUILD_LIBINTERFACE
extern DWORD	g_dwDP8StartupFlags;
#endif // DPNBUILD_LIBINTERFACE



//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL DNGlobalsInit(HANDLE hModule);
VOID DNGlobalsDeInit();

//
//	DirectNet Core Message Handler
//
HRESULT	DN_CoreMessageHandler(PVOID const pv,
							  const DWORD dwMsgId,
							  const HANDLE hEndPt,
							  PBYTE const pData,
							  const DWORD dwDataSize,
							  PVOID const pvUserContext,
							  const HANDLE hProtocol,
							  const HRESULT hr);


//
//	Protocol Ref Counts
//
void DNProtocolAddRef(DIRECTNETOBJECT *const pdnObject);
void DNProtocolRelease(DIRECTNETOBJECT *const pdnObject);


#ifndef	DPNBUILD_NONSEQUENTIALWORKERQUEUE
//
//	Thread pool ref counts
//
void DNThreadPoolAddRef(DIRECTNETOBJECT *const pdnObject);
void DNThreadPoolRelease(DIRECTNETOBJECT *const pdnObject);
#endif	// DPNBUILD_NONSEQUENTIALWORKERQUEUE


#ifndef DPNBUILD_NOHOSTMIGRATE
//
//	DirectNet - Host Migration routines
//
HRESULT	DNFindNewHost(DIRECTNETOBJECT *const pdnObject,
					  DPNID *const pdpnidNewHost);

HRESULT	DNPerformHostMigration1(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidOldHost);

HRESULT	DNPerformHostMigration2(DIRECTNETOBJECT *const pdnObject);

HRESULT	DNPerformHostMigration3(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg);

HRESULT	DNProcessHostMigration1(DIRECTNETOBJECT *const pdnObject,
								void *const pvMsg);

HRESULT	DNProcessHostMigration2(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg);

HRESULT	DNProcessHostMigration3(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnid);

HRESULT DNCompleteOutstandingOperations(DIRECTNETOBJECT *const pdnObject);

HRESULT DNCheckReceivedAllVersions(DIRECTNETOBJECT *const pdnObject);

HRESULT DNCleanUpNameTable(DIRECTNETOBJECT *const pdnObject);

HRESULT	DNSendHostMigrateCompleteMessage(DIRECTNETOBJECT *const pdnObject);
#endif // !DPNBUILD_NOHOSTMIGRATE

//
//	DirectNet - Protocol Interface (message handler callback functions)
//
HRESULT DNPIIndicateEnumQuery(void *const pvUserContext,
							  void *const pvEndPtContext,
							  const HANDLE hCommand,
							  void *const pvEnumQueryData,
							  const DWORD dwEnumQueryDataSize);

HRESULT DNPIIndicateEnumResponse(void *const pvUserContext,
								 const HANDLE hCommand,
								 void *const pvCommandContext,
								 void *const pvEnumResponseData,
								 const DWORD dwEnumResponseDataSize);

HRESULT DNPIIndicateConnect(void *const pvUserContext,
							void *const pvListenContext,
							const HANDLE hEndPt,
							void **const ppvEndPtContext);

HRESULT DNPIIndicateDisconnect(void *const pvUserContext,
							   void *const pvEndPtContext);

HRESULT DNPIIndicateConnectionTerminated(void *const pvUserContext,
										 void *const pvEndPtContext,
										 const HRESULT hr);

HRESULT DNPIIndicateReceive(void *const pvUserContext,
							void *const pvEndPtContext,
							void *const pvData,
							const DWORD dwDataSize,
							const HANDLE hBuffer,
							const DWORD dwFlags);

HRESULT DNPICompleteListen(void *const pvUserContext,
						   void **const ppvCommandContext,
						   const HRESULT hr,
						   const HANDLE hCommand);

HRESULT DNPICompleteListenTerminate(void *const pvUserContext,
									void *const pvCommandContext,
									const HRESULT hr);

HRESULT DNPICompleteEnumQuery(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr);

HRESULT DNPICompleteEnumResponse(void *const pvUserContext,
								 void *const pvCommandContext,
								 const HRESULT hr);

HRESULT DNPICompleteConnect(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hr,
							const HANDLE hEndPt,
							void **const ppvEndPtContext);

HRESULT DNPICompleteDisconnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr);

HRESULT DNPICompleteSend(void *const pvUserContext,
						 void *const pvCommandContext,
						 const HRESULT hr,
						 DWORD dwFirstFrameRTT,
						 DWORD dwFirstFrameRetryCount);

HRESULT DNPIAddressInfoConnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr,
							   IDirectPlay8Address *const pHostAddress,
							   IDirectPlay8Address *const pDeviceAddress );

HRESULT DNPIAddressInfoEnum(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hr,
							IDirectPlay8Address *const pHostAddress,
							IDirectPlay8Address *const pDeviceAddress );

HRESULT DNPIAddressInfoListen(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr,
							  IDirectPlay8Address *const pDeviceAddress );

#ifndef DPNBUILD_NOMULTICAST
HRESULT DNPIIndicateReceiveUnknownSender(void *const pvUserContext,
											void *const pvListenCommandContext,
											IDirectPlay8Address *const pSenderAddress,
											void *const pvData,
											const DWORD dwDataSize,
											const HANDLE hBuffer);

HRESULT DNPICompleteMulticastConnect(void *const pvUserContext,
									 void *const pvCommandContext,
									 const HRESULT hrProt,
									 const HANDLE hEndPt,
									 void **const ppvEndPtContext);
#endif	// DPNBUILD_NOMULTICAST



//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __DNCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\corevoice.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       corevoice.cpp
 *  Content:    DNET voice transport interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/17/00	rmt		Created
 *  01/19/00	rmt		Fixed bug in send, wasn't copying buffer
 *  01/21/00	rmt		Updated for new interface
 *  01/21/00	rmt		Updated to use locks to protect voice portion of DNet interface
 *  01/27/2000	rmt		Added concurrency protection to the interface
 *  04/04/2000  rmt     Fixed crash if transmitting during shutdown
 *  04/07/2000  rmt     Fixed Bug #32179
 *              rmt     Added support for nocopy sends
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/20/00	mjn		DNCompleteVoiceSend calls DNCompleteSendAsyncOp to clean up
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *  04/28/00	rmt		Fixed possible deadlock condition
 *	04/28/00	mjn		Prevent infinite loops in group SENDs
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/30/00	mjn		Modified logic for group sends to target connected players only
 *	06/26/00	mjn		Added VoiceSendSpeechSync()
 *				mjn		Use Host player as sender in Client mode for Voice_Receive()
 *  06/27/00	rmt		Added support for sync sends
 *				mjn		Ensure DirectNet object is initialized and not closing when sending
 *	07/06/00	mjn		Use DNSendGroupMessage() to send group voice messages
 *	07/08/00	mjn		Send non-guaranteed voice traffic as non-sequential
 *	07/11/00	mjn		Added NOLOOPBACK capability to group sends
 *  07/21/00	rmt		Bug #36386 - Target list with groups and players may result in redundant sends
 *  07/22/00	rmt  	Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  	Now for a thread to make an indication into voice they addref the interface
 *						so that the voice core can tell when all indications have returned.  
 *  07/31/00	rodtoll	Bug #41135 - Shutdown lockup -- now does not addref if notification
 *						is a session lost.  Added AddRefs() for VoiceReceive 
 *  08/11/2000	rodtoll	Bug #42235 - DVERR_NOTRANSPORT error when attempting to host voice sample app
 *	09/04/00	mjn		Added CApplicationDesc
 *  10/06/2000	rodtoll	Bug #46693 - DPVOICE: DPLAY8: Voice Data sends do not timeout
 *  10/10/2000	rodtoll	Bug #46895 - Regression from above -- guaranteed voice sends would timeout
 *  01/04/2001	rodtoll	WinBug #94200 - Remove stray comments
 *  01/22/2001	rodtoll	WINBUG #288437 - IA64 Pointer misalignment due to wire packets
 *	07/22/01	mjn		Added DPNBUILD_NOHOSTMIGRATE compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#ifndef DPNBUILD_NOVOICE

#define DNET_VOICE_TIMEOUT			1500

//**********************************************************************
// Function prototypes
//**********************************************************************

STDMETHODIMP VoiceAdvise( IDirectPlayVoiceTransport *pInterface, IUnknown *pUnknown, DWORD dwObjectType );
STDMETHODIMP VoiceUnAdvise( IDirectPlayVoiceTransport *pInterface, DWORD dwObjectType );
STDMETHODIMP VoiceIsGroupMember( IDirectPlayVoiceTransport *pInterface, DVID dvidGroup, DVID dvidPlayer );
STDMETHODIMP VoiceSendSpeech( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags );
STDMETHODIMP VoiceSendSpeechAsync( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags );
STDMETHODIMP VoiceSendSpeechSync(IDirectPlayVoiceTransport *pInterface,
									  DVID dvidFrom,
									  DVID dvidTo,
									  PDVTRANSPORT_BUFFERDESC pBufferDesc,
									  void *pvUserContext,
									  DWORD dwFlags );
STDMETHODIMP VoiceGetSessionInfo( IDirectPlayVoiceTransport *pInterface, PDVTRANSPORTINFO pdvTransportInfo );
STDMETHODIMP VoiceIsValidEntity( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid );
STDMETHODIMP VoiceSendSpeechEx( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DWORD dwNumTargets, UNALIGNED DVID * pdvidTargets, PDVTRANSPORT_BUFFERDESC, PVOID pvUserContext, DWORD dwFlags );
STDMETHODIMP VoiceIsValidGroup( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid );
STDMETHODIMP VoiceIsValidPlayer( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid );
VOID VoiceTarget_ClearTargetList( DIRECTNETOBJECT *pdnObject );
VOID VoiceTarget_ClearExpandedTargetList(DIRECTNETOBJECT *pdnObject);
HRESULT VoiceTarget_AddExpandedTargetListEntry(DIRECTNETOBJECT *pdnObject, DPNID dpid);
void VoiceTarget_AddIfNotAlreadyFound( DIRECTNETOBJECT *pdnObject, DPNID dpidID );
HRESULT VoiceTarget_ExpandTargetList(DIRECTNETOBJECT *pdnObject, DWORD nTargets, UNALIGNED DPNID * pdvidTo);


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

typedef	STDMETHODIMP VoiceQueryInterface( IDirectPlayVoiceTransport *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	VoiceAddRef( IDirectPlayVoiceTransport *pInterface );
typedef	STDMETHODIMP_(ULONG)	VoiceRelease( IDirectPlayVoiceTransport *pInterface );

IDirectPlayVoiceTransportVtbl DN_VoiceTbl =
{
	(VoiceQueryInterface*)			DN_QueryInterface,
	(VoiceAddRef*)					DN_AddRef,
	(VoiceRelease*)					DN_Release,
									VoiceAdvise,
									VoiceUnAdvise,
									VoiceIsGroupMember,
									VoiceSendSpeech,
									VoiceGetSessionInfo,
									VoiceIsValidEntity,
									VoiceSendSpeechEx,
									VoiceIsValidGroup,
									VoiceIsValidPlayer
};

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "Voice_Receive"
HRESULT Voice_Receive(PDIRECTNETOBJECT pdnObject, DVID dvidFrom, DVID dvidTo, LPVOID lpvMessage, DWORD dwMessageLen )
{
	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;
	CNameTableEntry	*pNTEntry;
	HRESULT			hResultCode;

    pNTEntry = NULL;

	//
	//	Ensure sender still exists in NameTable.
	//	If we are a client, the sender will be the Host player.  Otherwise, we will have to look up the player
	//	by the specified DPNID
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pNTEntry)) != DPN_OK)
		{
			DPFERR("Host not in NameTable - fail");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = pdnObject->NameTable.FindEntry(dvidFrom,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Player not in NameTable - fail");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	if (!pNTEntry->IsAvailable())
	{
		DNASSERT(FALSE);	// Is this ever hit ?
		DPFX(DPFPREP, 7,"Waiting for connection");
//		pNTEntry->WaitUntilAvailable();
	}
	if (pNTEntry->IsDisconnecting())
	{
		DPFERR("Player is now disconnecting !");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	DNEnterCriticalSection( &pdnObject->csVoice );

	pServer = pdnObject->lpDxVoiceNotifyServer;
	pClient = pdnObject->lpDxVoiceNotifyClient;
	
	if( pServer )
		IDirectPlayVoiceNotify_AddRef( pServer );

	if( pClient )
		IDirectPlayVoiceNotify_AddRef( pClient );
	
	DNLeaveCriticalSection( &pdnObject->csVoice );

	// Ensure that voice objects created as a result of this notification
	// do not receive the notification	

	if( pClient != NULL )
        IDirectPlayVoiceNotify_ReceiveSpeechMessage(pClient, dvidFrom, dvidTo, lpvMessage, dwMessageLen );

	if( pServer != NULL )
    	IDirectPlayVoiceNotify_ReceiveSpeechMessage(pServer, dvidFrom, dvidTo, lpvMessage, dwMessageLen );

	if( pServer )
		IDirectPlayVoiceNotify_Release( pServer );

	if( pClient )
		IDirectPlayVoiceNotify_Release( pClient );	

	hResultCode = DV_OK;

Exit:
	DNASSERT(hResultCode != DPNERR_PENDING);
	return hResultCode;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Voice_Notify"
HRESULT Voice_Notify( PDIRECTNETOBJECT pdnObject, DWORD dwMsgType, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD dwObjectType )
{
	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;
    
	DNEnterCriticalSection( &pdnObject->csVoice );

	pServer = pdnObject->lpDxVoiceNotifyServer;
	pClient = pdnObject->lpDxVoiceNotifyClient;

	if( dwMsgType != DVEVENT_STOPSESSION )
	{
	    if( pServer )
		    IDirectPlayVoiceNotify_AddRef( pServer );

	    if( pClient )
		    IDirectPlayVoiceNotify_AddRef( pClient );
	}

	DNLeaveCriticalSection( &pdnObject->csVoice );

	// Reset the target cache when nametable changes
	if(  dwMsgType == DVEVENT_ADDPLAYER || 
		dwMsgType == DVEVENT_REMOVEPLAYER ||
		dwMsgType == DVEVENT_CREATEGROUP || 
		dwMsgType == DVEVENT_DELETEGROUP ||
		dwMsgType == DVEVENT_ADDPLAYERTOGROUP ||
		dwMsgType == DVEVENT_REMOVEPLAYERFROMGROUP )
	{
		VoiceTarget_ClearTargetList( pdnObject );
	}

	// Ensure that voice objects created as a result of this notification
	// do not receive the notification	

	if( pClient != NULL  && dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
        IDirectPlayVoiceNotify_NotifyEvent(pClient, dwMsgType, dwParam1, dwParam2 );

	if( pServer != NULL && dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER)
    	IDirectPlayVoiceNotify_NotifyEvent(pServer, dwMsgType, dwParam1, dwParam2 );

	if( dwMsgType != DVEVENT_STOPSESSION )
	{
		if( pClient )
			IDirectPlayVoiceNotify_Release(pClient);

		if( pServer )
			IDirectPlayVoiceNotify_Release(pServer);
	}

	return DV_OK;
}

#pragma TODO(rodtoll,"Add protection to the voice elements")
#pragma TODO(rodtoll,"Add checking for session parameters")
#undef DPF_MODNAME
#define DPF_MODNAME "VoiceAdvise"
HRESULT __stdcall VoiceAdvise( IDirectPlayVoiceTransport *pInterface, IUnknown *pUnknown, DWORD dwObjectType )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	HRESULT hr;
//	DWORD dwCurrentIndex;

	DNEnterCriticalSection( &pdnObject->csVoice );

	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
	    if( pdnObject->lpDxVoiceNotifyServer != NULL )
	    {
	        DPFX(DPFPREP,  0, "There is already a server interface registered on this object" );
	        hr = DPNERR_GENERIC;
	    }
	    else
	    {
	        hr = pUnknown->lpVtbl->QueryInterface( pUnknown, IID_IDirectPlayVoiceNotify, (void **) &pdnObject->lpDxVoiceNotifyServer );

	        if( FAILED( hr ) )
	        {
	            DPFX(DPFPREP,  0, "QueryInterface failed! hr=0x%x", hr );
	        }
	        else
	        {
            	hr = IDirectPlayVoiceNotify_Initialize(pdnObject->lpDxVoiceNotifyServer);

            	if( FAILED( hr ) )
            	{
            	    DPFX(DPFPREP,  0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    IDirectPlayVoiceNotify_Release( pdnObject->lpDxVoiceNotifyServer );
            	    pdnObject->lpDxVoiceNotifyServer = NULL;
            	}
	        }
	    }
	    
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    if( pdnObject->lpDxVoiceNotifyClient != NULL )
	    {
	        DPFX(DPFPREP,  0, "There is already a client interface registered on this object" );
	        hr = DPNERR_GENERIC;
	    }
	    else
	    {
	        hr = pUnknown->lpVtbl->QueryInterface( pUnknown, IID_IDirectPlayVoiceNotify, (void **) &pdnObject->lpDxVoiceNotifyClient );

	        if( FAILED( hr ) )
	        {
	            DPFX(DPFPREP,  0, "QueryInterface failed! hr=0x%x", hr );
	        }
	        else
	        {
            	hr = IDirectPlayVoiceNotify_Initialize(pdnObject->lpDxVoiceNotifyClient);

            	if( FAILED( hr ) )
            	{
            	    DPFX(DPFPREP,  0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    IDirectPlayVoiceNotify_Release( pdnObject->lpDxVoiceNotifyClient );
            	    pdnObject->lpDxVoiceNotifyClient = NULL;
            	}
	        }
	    }	    
	}
	else
	{
	    DPFX(DPFPREP,  0, "Error: Invalid object type specified in advise" );
	    DNASSERT( FALSE );
	    hr = DPNERR_GENERIC;
	}

	DNLeaveCriticalSection( &pdnObject->csVoice );
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceUnAdvise"
HRESULT __stdcall VoiceUnAdvise( IDirectPlayVoiceTransport *pInterface, DWORD dwObjectType )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
//	DWORD dwIndex;
	HRESULT hr = DV_OK;

	DNEnterCriticalSection( &pdnObject->csVoice );

	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
        if( pdnObject->lpDxVoiceNotifyServer != NULL )
	    {
    	    IDirectPlayVoiceNotify_Release( pdnObject->lpDxVoiceNotifyServer );
    	    pdnObject->lpDxVoiceNotifyServer = NULL;	    
	    }
	    else
	    {
	        DPFX(DPFPREP,  0, "No server currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    if( pdnObject->lpDxVoiceNotifyClient != NULL )
	    {
    	    IDirectPlayVoiceNotify_Release( pdnObject->lpDxVoiceNotifyClient );
    	    pdnObject->lpDxVoiceNotifyClient = NULL;	    
	    }
	    else
	    {
	        DPFX(DPFPREP,  0, "No client currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else
	{
	    DPFX(DPFPREP,  0, "Could not find interface to unadvise" );
	    hr = DVERR_GENERIC;
	}
	
	DNLeaveCriticalSection( &pdnObject->csVoice );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsGroupMember"
HRESULT __stdcall VoiceIsGroupMember( IDirectPlayVoiceTransport *pInterface, DVID dvidGroup, DVID dvidPlayer )
{
	PDIRECTNETOBJECT	pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);	
	BOOL				fResult;

	if( dvidGroup == 0 )
	{
		return DV_OK;
	}
	
	fResult = pdnObject->NameTable.IsMember(dvidGroup,dvidPlayer);

	if( fResult )
	{
		return DV_OK;
	}
	else
	{
		return E_FAIL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNVReturnBuffer"
void DNVReturnBuffer( DIRECTNETOBJECT *const pdnObject, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvContext, HRESULT hrResult )
{
	if( DNInterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
	{
    	DVEVENTMSG_SENDCOMPLETE dvSendComplete;

    	dvSendComplete.pvUserContext = pvContext; 
		dvSendComplete.hrSendResult = hrResult; 

    	Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteVoiceSend"

void DNCompleteVoiceSend(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp)
{
	PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) (pAsyncOp->GetContext());

	DNVReturnBuffer( pdnObject, pBufferDesc, pAsyncOp->GetContext(), pAsyncOp->GetResult() );

	//
	//	Still need to complete the SEND to clean up
	//
	DNCompleteSendAsyncOp(pdnObject,pAsyncOp);
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeech"
HRESULT __stdcall VoiceSendSpeech( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags )
{
	if( dwFlags & DVTRANSPORT_SEND_SYNC )
	{
		return VoiceSendSpeechSync( pInterface, dvidFrom, dvidTo, pBufferDesc, pvUserContext, dwFlags );
	}
	else
	{
		return VoiceSendSpeechAsync( pInterface, dvidFrom, dvidTo, pBufferDesc, pvUserContext, dwFlags );
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeech"
HRESULT __stdcall VoiceSendSpeechAsync( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags )
{
	HRESULT             hr;
	DWORD	            dwAsyncFlags = 0;
	DWORD	            dwSendFlags = 0;
	PDIRECTNETOBJECT    pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	CNameTableEntry		*pNTEntry;
	CGroupConnection	*pGroupConnection;
	CAsyncOp			*pAsyncOp;
    CConnection			*pConnection;
	DWORD				dwTimeout = 0;

	pNTEntry = NULL;
	pGroupConnection = NULL;
	pAsyncOp = NULL;
	pConnection = NULL;

    if( pBufferDesc->lRefCount == 0 )
    	pBufferDesc->lRefCount = 1;	

	//
    //	Flags
	//
	if (dwFlags & DVTRANSPORT_SEND_GUARANTEED)
	{
		dwSendFlags |= DN_SENDFLAGS_RELIABLE;
	}
	else
	{
		dwSendFlags |= DN_SENDFLAGS_NON_SEQUENTIAL;
		dwTimeout = DNET_VOICE_TIMEOUT;
	}

    // Sending to ALL players
	// Retrieve NameTableEntry (use AllPlayersGroup if none specified)
	if( dvidTo == 0 )
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetAllPlayersGroupRef( &pNTEntry )) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

            if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
            {
                DPFX(DPFPREP, 0, "ERROR: All group does not exist!" );
				hr = DPNERR_GENERIC;
				goto Failure;
            }
            else
            {
    		    DPFX(DPFPREP, 1, "All players group missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
            }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		dvidTo = pNTEntry->GetDPNID();
	}
	// Sending to server player
	else if( dvidTo == 1 )
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	        if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
	        {
	            DPFX(DPFPREP,  0, "ERROR: No host player in session!" );
				hr = DPNERR_GENERIC;
				goto Failure;
	        }
	        else
	        {
	            DPFX(DPFPREP,  1, "Host player missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
	        }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	    dvidTo = pNTEntry->GetDPNID();
	}
	else
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.FindEntry(dvidTo,&pNTEntry)) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			DPFERR("Could not find player/group");
			goto Failure;
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	if (pNTEntry->IsGroup())
	{
		hr = DNSendGroupMessage(pdnObject,
								pNTEntry,
								DN_MSG_INTERNAL_VOICE_SEND,
								reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
								1,
								NULL,
								dwTimeout,
								dwSendFlags,
								FALSE,
								FALSE,
								NULL,
								&pAsyncOp );

		if (hr == DPN_OK)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetCompletion( DNCompleteVoiceSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
	}
	else
	{
	    hr = pNTEntry->GetConnectionRef( &pConnection );

	    if( FAILED( hr ) )
	    {
	        DPFX(DPFPREP,  0, "Getting connection for player failed hr=0x%x", hr );
			goto Failure;
	    }
	    
   		DNASSERT(pConnection != NULL);
   		
   		hr = DNSendMessage(	pdnObject,
    						pConnection,
    						DN_MSG_INTERNAL_VOICE_SEND,
    						dvidTo,
    						reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
							1,
    						NULL,
    						dwTimeout,
    						dwSendFlags,
							NULL,
    						&pAsyncOp);

		if (hr == DPNERR_PENDING)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetCompletion( DNCompleteVoiceSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;
			hr = DPN_OK;
		}
		else if (hr == DPNERR_INVALIDENDPOINT)
		{
			hr = DPNERR_INVALIDPLAYER;
		}

        // Release our reference on the connection
		pConnection->Release();
		pConnection = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	return hr;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	DNVReturnBuffer( pdnObject, pBufferDesc, pvUserContext, hr );
		
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeechSync"
HRESULT __stdcall VoiceSendSpeechSync(IDirectPlayVoiceTransport *pInterface,
									  DVID dvidFrom,
									  DVID dvidTo,
									  PDVTRANSPORT_BUFFERDESC pBufferDesc,
									  void *pvUserContext,
									  DWORD dwFlags )
{
	HRESULT             hr;
	HRESULT				hrSend;
	DWORD	            dwAsyncFlags = 0;
	DWORD	            dwSendFlags = 0;
	PDIRECTNETOBJECT    pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	CNameTableEntry		*pNTEntry;
	CGroupConnection	*pGroupConnection;
	CAsyncOp			*pAsyncOp;
    CConnection			*pConnection;
	CSyncEvent			*pSyncEvent;
	DWORD				dwTimeout = 0;
	

	pNTEntry = NULL;
	pGroupConnection = NULL;
	pAsyncOp = NULL;
	pConnection = NULL;
	pSyncEvent = NULL;

    if( pBufferDesc->lRefCount == 0 )
    	pBufferDesc->lRefCount = 1;	

	//
	//	Create Sync Event
	//
	if ((hr = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not create SyncEvent");
		DisplayDNError(0,hr);
		goto Failure;
	}
	pSyncEvent->Reset();

	//
    //	Flags
	//
	if (dwFlags & DVTRANSPORT_SEND_GUARANTEED)
	{
		dwSendFlags |= DN_SENDFLAGS_RELIABLE;
	}
	else
	{
		dwSendFlags |= DN_SENDFLAGS_NON_SEQUENTIAL;
		dwTimeout = DNET_VOICE_TIMEOUT;
	}

	//
	//	Get appropriate target
	//
	if( dvidTo == 0 )
	{
		//
		//	Sending to ALL players
		//	Retrieve NameTableEntry (use AllPlayersGroup if none specified)
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetAllPlayersGroupRef(&pNTEntry)) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

            if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
            {
                DPFX(DPFPREP, 0, "ERROR: All group does not exist!" );
				hr = DPNERR_GENERIC;
				goto Failure;
            }
            else
            {
    		    DPFX(DPFPREP, 1, "All players group missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
            }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		dvidTo = pNTEntry->GetDPNID();
	}
	else if( dvidTo == 1 )
	{
		//
		//	Sending to server player
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	        if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
	        {
	            DPFX(DPFPREP,  0, "ERROR: No host player in session!" );
				hr = DPNERR_GENERIC;
				goto Failure;
	        }
	        else
	        {
	            DPFX(DPFPREP,  1, "Host player missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
	        }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	    dvidTo = pNTEntry->GetDPNID();
	}
	else
	{
		//
		//	Targeted send to some other player
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.FindEntry(dvidTo,&pNTEntry)) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			DPFERR("Could not find player/group");
			DisplayDNError(0,hr);
			goto Failure;
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	if (pNTEntry->IsGroup())
	{
		hr = DNSendGroupMessage(pdnObject,
								pNTEntry,
								DN_MSG_INTERNAL_VOICE_SEND,
								reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
								1,
								NULL,
								dwTimeout,
								dwSendFlags,
								FALSE,
								FALSE,
								NULL,
								&pAsyncOp );

		if (hr == DPN_OK)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetSyncEvent( pSyncEvent );
			pAsyncOp->SetResultPointer( &hrSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
	}
	else
	{
	    hr = pNTEntry->GetConnectionRef( &pConnection );

	    if( FAILED( hr ) )
	    {
	        DPFX(DPFPREP,  0, "Getting connection for player failed hr=0x%x", hr );
			DisplayDNError(0,hr);
			goto Failure;
	    }
	    
   		DNASSERT(pConnection != NULL);
   		
   		hr = DNSendMessage(	pdnObject,
    						pConnection,
    						DN_MSG_INTERNAL_VOICE_SEND,
    						dvidTo,
    						reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
							1,
    						NULL,
    						dwTimeout,
    						dwSendFlags,
							NULL,
    						&pAsyncOp);

		if (hr == DPNERR_PENDING)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetSyncEvent( pSyncEvent );
			pAsyncOp->SetResultPointer( &hrSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;

			hr = DPN_OK;
		}

        // Release our reference on the connection
		pConnection->Release();
		pConnection = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Wait for SENDs to complete
	//
	pSyncEvent->WaitForEvent();
	pSyncEvent->ReturnSelfToPool();
	pSyncEvent = NULL;
	hr = hrSend;

Exit:
	return hr;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	DNVReturnBuffer( pdnObject, pBufferDesc, pvUserContext, hr );
	
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "VoiceGetSessionInfo"
HRESULT __stdcall VoiceGetSessionInfo( IDirectPlayVoiceTransport *pInterface, PDVTRANSPORTINFO pdvTransportInfo )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	CNameTableEntry	*pHostPlayer;
	CNameTableEntry	*pLocalPlayer;
	
	pHostPlayer = NULL;
	pLocalPlayer = NULL;
	pdvTransportInfo->dwFlags = 0;

	if (pdnObject->ApplicationDesc.IsClientServer())
	{
		pdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_CLIENTSERVER;
	}
	else
	{
		pdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_PEERTOPEER;
	}

#ifndef	DPNBUILD_NOHOSTMIGRATE
	if (pdnObject->ApplicationDesc.AllowHostMigrate())
	{
		pdvTransportInfo->dwFlags |= DVTRANSPORT_MIGRATEHOST;
	} 
#endif // DPNBUILD_NOHOSTMIGRATE

	pdvTransportInfo->dwMaxPlayers = pdnObject->ApplicationDesc.GetMaxPlayers();

	if (pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer ) == DPN_OK)
	{
		pdvTransportInfo->dvidLocalID = pLocalPlayer->GetDPNID();
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DPFERR( "Unable to find a local player" );
		pdvTransportInfo->dvidLocalID = 0;
		return DVERR_TRANSPORTNOPLAYER;
	}

	if (pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer ) != DPN_OK)
	{
		pdvTransportInfo->dvidSessionHost = 0;
		DPFERR( "Unable to find a session host" );
//		return DVERR_TRANSPORTNOPLAYER;
	}
	else
	{
		pdvTransportInfo->dvidSessionHost = pHostPlayer->GetDPNID();	
		pHostPlayer->Release();
	}
	
	pHostPlayer = NULL;

	if( pdvTransportInfo->dvidSessionHost == pdvTransportInfo->dvidLocalID )
	{
		pdvTransportInfo->dwFlags |= DVTRANSPORT_LOCALHOST;
	}
		
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsValidGroup"
HRESULT __stdcall VoiceIsValidGroup( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	HRESULT hr;
	CNameTableEntry	*pNTEntry;

	hr = pdnObject->NameTable.FindEntry(dvidID,&pNTEntry);

	if( FAILED( hr ) )
	{
		*pfIsValid = FALSE;
	}
	else if( pNTEntry->IsGroup() )
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = TRUE;
	}
	else
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = FALSE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsValidPlayer"
HRESULT __stdcall VoiceIsValidPlayer( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	HRESULT hr;
	CNameTableEntry	*pNTEntry;

	hr = pdnObject->NameTable.FindEntry(dvidID,&pNTEntry);

	if( FAILED( hr ) )
	{
		*pfIsValid = FALSE;
	}
	else if( !pNTEntry->IsGroup() )
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = TRUE;
	}
	else
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = FALSE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsValidEntity"
HRESULT __stdcall VoiceIsValidEntity( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	HRESULT hr;
	CNameTableEntry	*pNTEntry;

	hr = pdnObject->NameTable.FindEntry(dvidID,&pNTEntry);

	if( FAILED( hr ) )
	{
		*pfIsValid = FALSE;
	}
	else
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = TRUE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeechEx"
HRESULT __stdcall VoiceSendSpeechEx( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DWORD dwNumTargets, UNALIGNED DPNID * pdvidTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvUserContext, DWORD dwFlags )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);	
	
	DWORD dwIndex;
	HRESULT hr;

	DNEnterCriticalSection( &pdnObject->csVoice );

	hr= VoiceTarget_ExpandTargetList(pdnObject, dwNumTargets, pdvidTargets);

	if(hr != DPN_OK)
	{
		DNLeaveCriticalSection( &pdnObject->csVoice );		
		return hr;
	}

	pBufferDesc->lRefCount = pdnObject->nExpandedTargets;

	// Send to our expanded and duplicate removed list.
	for(dwIndex=0; dwIndex < pdnObject->nExpandedTargets; dwIndex++)
	{
		hr = VoiceSendSpeech( pInterface, dvidFrom, pdnObject->pExpandedTargetList[dwIndex], pBufferDesc, pvUserContext, dwFlags );
	}    

	DNLeaveCriticalSection( &pdnObject->csVoice );			

	return hr;
}

/////////////////////////////////////////
// Support Routinesfor VoiceSendSpeechEx //
/////////////////////////////////////////

VOID VoiceTarget_ClearTargetList( DIRECTNETOBJECT *pdnObject )
{
	pdnObject->nTargets=0;
}

VOID VoiceTarget_ClearExpandedTargetList(DIRECTNETOBJECT *pdnObject)
{
	pdnObject->nExpandedTargets=0;
}

HRESULT VoiceTarget_AddExpandedTargetListEntry(DIRECTNETOBJECT *pdnObject, DPNID dpid)
{
	#define GROW_SIZE 16
	
	PDPNID pdpid;
	
	if(pdnObject->nExpandedTargets == pdnObject->nExpandedTargetListLen){
		// Need more room, allocate another 16 entries

		pdpid=new DPNID[pdnObject->nExpandedTargetListLen+GROW_SIZE];

		if(!pdpid){
			DPFX(DPFPREP,  0, "Error allocating room for target cache" );
			return DVERR_OUTOFMEMORY;
		}
		
		if(pdnObject->pExpandedTargetList){
			memcpy(pdpid, pdnObject->pExpandedTargetList, pdnObject->nExpandedTargetListLen*sizeof(DPNID));
			if( pdnObject->pExpandedTargetList )
			{
				delete [] pdnObject->pExpandedTargetList;
				pdnObject->pExpandedTargetList = NULL;
			}
		}
		pdnObject->pExpandedTargetList = pdpid;
		pdnObject->nExpandedTargetListLen += GROW_SIZE;
	}

	pdnObject->pExpandedTargetList[pdnObject->nExpandedTargets++]=dpid;

	return DV_OK;

	#undef GROW_SIZE
}

void VoiceTarget_AddIfNotAlreadyFound( DIRECTNETOBJECT *pdnObject, DPNID dpidID )
{
	DWORD j;
	
	for(j=0;j<pdnObject->nExpandedTargets;j++)
	{
		if( pdnObject->pExpandedTargetList[j] == dpidID )
		{
			break;
		}
	}

	// It was not found, add him to the list
	if( j == pdnObject->nExpandedTargets )
	{
		VoiceTarget_AddExpandedTargetListEntry(pdnObject, dpidID);							
	}
}

HRESULT VoiceTarget_ExpandTargetList(DIRECTNETOBJECT *pdnObject, DWORD nTargets, UNALIGNED DVID * pdvidTo)
{
	HRESULT hr=DPN_OK;
	UINT i;
	CNameTableEntry *pEntry;
	CGroupMember		*pGroupMember;
	CBilink				*pBilink;

	pEntry = NULL;
	
	// See if we need to change the expanded target list or we have it cached.
	
	if(nTargets != pdnObject->nTargets || memcmp(pdvidTo, pdnObject->pTargetList, nTargets * sizeof(DVID))){

		DPFX(DPFPREP, 9, "VoiceTarget_ExpandTargetList, new list re-building cached list\n");
		
		// the target list is wrong, rebuild it.
		// First copy the new target list...
		if(nTargets > pdnObject->nTargetListLen){
			// Current list is too small, possibly non-existant, allocate one to cache the list.
			if(pdnObject->pTargetList){
				delete [] pdnObject->pTargetList;
				pdnObject->pTargetList = NULL;
			}
			pdnObject->pTargetList=new DVID[nTargets];
			if(pdnObject->pTargetList){
				pdnObject->nTargetListLen=nTargets;
			} else {
				pdnObject->nTargetListLen=0;
				pdnObject->nTargets=0;
				hr=DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP, 0,"Ran out of memory trying to cache target list!\n");
				goto exit;
			}
		}
		pdnObject->nTargets = nTargets;
		memcpy(pdnObject->pTargetList, pdvidTo, nTargets*sizeof(DVID));

		// OK we have the target list cached, now build the list we are going to send to.
		VoiceTarget_ClearExpandedTargetList(pdnObject);
		for(i=0;i<pdnObject->nTargets;i++)
		{
			hr = pdnObject->NameTable.FindEntry( pdnObject->pTargetList[i], &pEntry );

			if( SUCCEEDED( hr ) )
			{
				if( !pEntry->IsGroup() )
				{
					VoiceTarget_AddIfNotAlreadyFound( pdnObject, pdnObject->pTargetList[i] );
				}
				else
				{
					pEntry->Lock();

					pBilink = pEntry->m_bilinkMembership.GetNext();
					while (pBilink != &pEntry->m_bilinkMembership)
					{
						pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
						VoiceTarget_AddIfNotAlreadyFound( pdnObject, pGroupMember->GetPlayer()->GetDPNID() );
										
						pBilink = pBilink->GetNext();
					}

					pEntry->Unlock();					
				}

				pEntry->Release();
				pEntry = NULL;
				
			}
			
		}

	} else {
		DPFX(DPFPREP, 9,"ExpandTargetList, using cached list\n");
	}

exit:
	return hr;
}

#endif // DPNBUILD_NOVOICE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\dpprot.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DPlay8.h
 *  Content:	DirectPlay8 include file
 *  History:
 *	Date		By		Reason
 *	==========================
 *	9/26/2000	masonb		created - Removed from public header dplay8.h
 *
 ***************************************************************************/

#ifndef __DIRECTPLAY8PROT_H__
#define __DIRECTPLAY8PROT_H__

#ifndef DPNBUILD_NOPROTOCOLTESTITF

#ifdef _XBOX
//@@BEGIN_MSINTERNAL
#ifdef XBOX_ON_DESKTOP
#include <ole2.h>	   // for DECLARE_INTERFACE_ and HRESULT
#endif // XBOX_ON_DESKTOP
//@@END_MSINTERNAL
#undef DECLARE_INTERFACE_
#define DECLARE_INTERFACE_(iface, baseiface)	DECLARE_INTERFACE(iface)
#else // ! _XBOX
#include <ole2.h>	   // for DECLARE_INTERFACE_ and HRESULT
#endif // ! _XBOX

#include "dpaddr.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


/****************************************************************************
 *
 * DirectPlay8 CLSIDs
 *
 ****************************************************************************/

#ifdef _XBOX
#define IID_IDirectPlay8Protocol	0x00000007
#else // ! _XBOX
// {EBFE7B84-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Protocol,
0xebfe7b84, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
#endif // ! _XBOX


/****************************************************************************
 *
 * DirectPlay8 Interface Definitions
 *
 ****************************************************************************/

typedef struct _DN_PROTOCOL_INTERFACE_VTBL DN_PROTOCOL_INTERFACE_VTBL, *PDN_PROTOCOL_INTERFACE_VTBL;

//
// COM definition for DirectPlay8 Protocol interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Protocol
DECLARE_INTERFACE_(IDirectPlay8Protocol,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Protocol methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID, PDN_PROTOCOL_INTERFACE_VTBL pfVTBL) PURE;
	STDMETHOD(Shutdown)					(THIS) PURE;
	STDMETHOD(AddServiceProvider)		(THIS_ IDP8ServiceProvider* pISP, HANDLE* phSPHandle) PURE;
	STDMETHOD(RemoveServiceProvider)	(THIS_ HANDLE hSPHandle) PURE;
	STDMETHOD(Connect)					(THIS_ IDirectPlay8Address* paLocalAddress, IDirectPlay8Address* paRemoteAddress, HANDLE hSPHandle, ULONG ulFlags, VOID* pvContext, HANDLE* phConnect) PURE;
	STDMETHOD(Listen)					(THIS_ IDirectPlay8Address* paAddress, HANDLE hSPHandle, ULONG ulFlags, VOID* pvContext, HANDLE* phListen) PURE;
	STDMETHOD(SendData)					(THIS_ HANDLE hEndpoint, UINT uiBufferCount, BUFFERDESC* pBuffers, UINT uiTimeout, ULONG ulFlags, VOID* pvContext, HANDLE* phSendHandle) PURE;
	STDMETHOD(DisconnectEP)				(THIS_ HANDLE hEndPoint, VOID* pvContext, HANDLE* phDisconnect, DWORD dwFlags) PURE;
	STDMETHOD(Cancel)					(THIS_ HANDLE hCommand) PURE;
	STDMETHOD(ReturnReceiveBuffers)		(THIS_ HANDLE hBuffer) PURE;
	STDMETHOD(GetEndpointCaps)			(THIS_ HANDLE hEndpoint, VOID* pvBuffer) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS* pCaps) PURE;
	STDMETHOD(SetCaps)					(THIS_ DPN_CAPS* pCaps) PURE;
	STDMETHOD(EnumQuery)				(THIS_ IDirectPlay8Address* paHostAddress, IDirectPlay8Address* paDeviceAddress, HANDLE hSPHandle, BUFFERDESC* pBuffers, DWORD dwBufferCount, DWORD dwRetryCount, DWORD dwRetryInterval, DWORD dwTimeout, DWORD dwFlags, VOID* pvUserContext, HANDLE* phEnumHandle) PURE;
	STDMETHOD(EnumRespond)				(THIS_ HANDLE hSPHandle, HANDLE hQueryHandle, BUFFERDESC* pBuffers, DWORD dwBufferCount, DWORD dwFlags, VOID* pvUserContext, HANDLE* phEnumHandle) PURE;
	STDMETHOD(CrackEPD)					(THIS_ HANDLE hEndPoint, long Flags, IDirectPlay8Address** ppAddr) PURE;
	STDMETHOD(GetListenAddressInfo)		(THIS_ HANDLE hCommand, long Flags, IDirectPlay8Address** ppAddr) PURE;
	STDMETHOD(Debug)					(THIS_ UINT uiOpcode, HANDLE hEndpoint, VOID* pvBuffer) PURE;
};

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // !DPNBUILD_NOPROTOCOLTESTITF

#endif // __DIRECTPLAY8PROT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\enumhosts.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum.cpp
 *  Content:    Enumeration routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/10/00	mjn		Created
 *	04/17/00	mjn		Fixed DNCompleteEnumQuery to clean up properly
 *	04/18/00	mjn		Return User Buffer in DNProcessEnumQuery
 *	04/19/00	mjn		Removed DPN_BUFFER_DESC from DPNMSG_ENUM_HOSTS_QUERY and DPNMSG_ENUM_HOSTS_RESPONSE structs
 *	05/02/00	mjn		Allow application to reject ENUM_QUERY's
 *	06/25/00	mjn		Fixed payload problem in DNProcessEnumQuery()
 *	07/10/00	mjn		Removed DNCompleteEnumQuery() and DNCompleteEnumResponse()
 *	07/12/00	mjn		Ensure connected before replying to ENUMs
 *	07/29/00	mjn		Verify enum responses sizes
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Ensure cancelled operations don't proceed
 *	08/29/00	mjn		Cancel EnumHosts if non-DPN_OK returned from response notification
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/14/00	mjn		AddRef Protocol refcount when invoking protocol
 *	01/22/01	mjn		Add SP reference on AsyncOp in DNProcessEnumQuery()
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	03/13/01	mjn		Don't copy user response buffer when responding to enums
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// ------------------------------
// DNProcessEnumQuery - process enum query
//
// Entry:		Pointer to this DNet interface object
//				Pointer to the associated listen operation
//				Pointer to protocol's enum data
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessEnumQuery"

void DNProcessEnumQuery(DIRECTNETOBJECT *const pdnObject,
						CAsyncOp *const pListen,
						const PROTOCOL_ENUM_DATA *const pEnumQueryData )
{
	HRESULT						hResultCode;
	DPNMSG_ENUM_HOSTS_QUERY		AppData;
	CPackedBuffer				PackedBuffer;
	CRefCountBuffer				*pRefCountBuffer;
	CAsyncOp					*pAsyncOp;
	HANDLE						hProtocol;
	const DN_ENUM_QUERY_PAYLOAD	*pEnumQueryPayload;
	DN_ENUM_RESPONSE_OP_DATA	*pEnumResponseOpData;
	DN_ENUM_RESPONSE_PAYLOAD	*pEnumResponsePayload;
	DWORD						dwPayloadOffset;
	IDP8ServiceProvider			*pIDP8SP;
	SPGETCAPSDATA				spGetCapsData;
	CServiceProvider			*pSP;
	DWORD						dwBufferCount;
	BOOL						fNeedToReturnBuffer;

	DPFX(DPFPREP, 6,"Parameters: pListen [0x%p], pEnumQueryData [0x%p]",pListen,pEnumQueryData);

	DNASSERT( pdnObject != NULL );
	DNASSERT( pListen != NULL );
	DNASSERT( pEnumQueryData != NULL );

	pAsyncOp = NULL;
	pRefCountBuffer = NULL;
	pIDP8SP = NULL;
	pSP = NULL;
	fNeedToReturnBuffer = FALSE;		// Is this needed ?

	//
	//	Ensure we are in a position to reply to this message.
	//	We must be CONNECTED and not be HOST_MIGRATING
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		DPFX(DPFPREP, 7, "Not connected or host is migrating (object 0x%p flags = 0x%x), ignoring enum.", pdnObject, pdnObject->dwFlags);
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	// Check to see if this message is for this game type.  Since the application
	// GUID cannot be changed while the session is running, there's no need to
	// enter a critical section.
	//
	pEnumQueryPayload = reinterpret_cast<DN_ENUM_QUERY_PAYLOAD*>( pEnumQueryData->ReceivedData.pBufferData );
	if ( pEnumQueryPayload == NULL )
	{
		//
		// no enum payload (there needs to be at least one byte!)
		//
		DPFX(DPFPREP, 4, "No enum payload, object 0x%p ignoring enum.", pdnObject);
		goto Failure;
	}

	dwPayloadOffset = 0;
	switch ( pEnumQueryPayload->QueryType )
	{
		//
		// an application guid was specified, make sure it matches this application's
		// guid before further processing
		//
		case DN_ENUM_QUERY_WITH_APPLICATION_GUID:
		{
			if ( pEnumQueryData->ReceivedData.dwBufferSize < sizeof( DN_ENUM_QUERY_PAYLOAD ) )
			{
				DNASSERTX( ! "Received data too small to be valid enum query with application guid!", 2 );
				goto Failure;
			}

			if ( !pdnObject->ApplicationDesc.IsEqualApplicationGuid( &pEnumQueryPayload->guidApplication ) )
			{
#ifdef DBG
				GUID	guidApplication;


				//
				// GUID might not be aligned, so copy it to a temp variable
				//
				guidApplication = pEnumQueryPayload->guidApplication;
				DPFX(DPFPREP, 7, "Application GUID {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X} doesn't match, object 0x%p, ignoring enum.",
					guidApplication.Data1,
					guidApplication.Data2,
					guidApplication.Data3,
					guidApplication.Data4[0],
					guidApplication.Data4[1],
					guidApplication.Data4[2],
					guidApplication.Data4[3],
					guidApplication.Data4[4],
					guidApplication.Data4[5],
					guidApplication.Data4[6],
					guidApplication.Data4[7],
					pdnObject);
#endif // DBG
				goto Failure;
			}

			dwPayloadOffset = sizeof( DN_ENUM_QUERY_PAYLOAD );

			break;
		}

		//
		// no application guid was specified, continue processing
		//
		case DN_ENUM_QUERY_WITHOUT_APPLICATION_GUID:
		{
			if ( pEnumQueryData->ReceivedData.dwBufferSize < ( sizeof( DN_ENUM_QUERY_PAYLOAD ) - sizeof( GUID ) ) )
			{
				DNASSERTX( ! "Received data too small to be valid enum query without application guid!", 2 );
				goto Failure;
			}

			dwPayloadOffset = sizeof( DN_ENUM_QUERY_PAYLOAD ) - sizeof( GUID );

			break;
		}

		default:
		{
			DNASSERTX( ! "Unrecognized enum query payload type!", 2 );
			goto Failure;
			break;
		}
	}


	//
	// buld message structure, be nice and clear the user payload pointer if
	// there is no payload
	//
	AppData.dwSize = sizeof( AppData );
	AppData.pAddressSender = pEnumQueryData->pSenderAddress;
	AppData.pAddressDevice = pEnumQueryData->pDeviceAddress;

	DPFX(DPFPREP, 7,"AppData.pAddressSender: [0x%p]",AppData.pAddressSender);
	DPFX(DPFPREP, 7,"AppData.pAddressDevice: [0x%p]",AppData.pAddressDevice);

	if (pEnumQueryData->ReceivedData.dwBufferSize > dwPayloadOffset)
	{
		DNASSERT( pEnumQueryData->ReceivedData.pBufferData );
		DNASSERT( pEnumQueryData->ReceivedData.dwBufferSize );

		AppData.pvReceivedData = static_cast<void*>(static_cast<BYTE*>(pEnumQueryData->ReceivedData.pBufferData) + dwPayloadOffset);
		AppData.dwReceivedDataSize = pEnumQueryData->ReceivedData.dwBufferSize - dwPayloadOffset;
	}
	else
	{
		AppData.pvReceivedData = NULL;
		AppData.dwReceivedDataSize = 0;
	}

	//
	//	Response Info
	//
	AppData.pvResponseData = NULL;
	AppData.dwResponseDataSize = 0;
	AppData.pvResponseContext = NULL;

	//
	//	Determine max size of response
	//		-	Get SP interface from listen SP (listen's parent)
	//		-	Get SP caps on the interface to determine the total available buffer size
	//		-	Figure out what the DNET enum response size will be
	//		-	Determine space available to user
	//
	DNASSERT(pListen->GetParent() != NULL);
	DNASSERT(pListen->GetParent()->GetSP() != NULL);
	pListen->GetParent()->GetSP()->AddRef();
	pSP = pListen->GetParent()->GetSP();
	if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get ListenSP SP interface");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	memset( &spGetCapsData, 0x00, sizeof( SPGETCAPSDATA ) );
	spGetCapsData.dwSize = sizeof( SPGETCAPSDATA );
	spGetCapsData.hEndpoint = INVALID_HANDLE_VALUE;
	if ((hResultCode = IDP8ServiceProvider_GetCaps( pIDP8SP, &spGetCapsData )) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	IDP8ServiceProvider_Release( pIDP8SP );
	pIDP8SP = NULL;
	PackedBuffer.Initialize(NULL,0);
	PackedBuffer.AddToFront(NULL,sizeof(DN_ENUM_RESPONSE_PAYLOAD));
	pdnObject->ApplicationDesc.PackInfo(&PackedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	AppData.dwMaxResponseDataSize = spGetCapsData.dwEnumFrameSize - PackedBuffer.GetSizeRequired();

	//
	// pass message to the user
	//
	hResultCode = DNUserEnumQuery(pdnObject,&AppData);

	//
	//	Only ENUMs which are accepted get responded to
	//
	if (hResultCode != DPN_OK)
	{
		DPFX(DPFPREP, 9, "EnumQuery rejected");
		DisplayDNError(9, hResultCode);
		goto Failure;
	}

	//
	// get an async operation to track the progress of the response
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not allocate Async Op struct for enum response");
		DisplayDNError( 0, hResultCode );
		DNASSERT( FALSE );
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_ENUM_RESPONSE );

	//
	// compute the size needed to pack up an application description with any
	// user data and send it back
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	PackedBuffer.Initialize(NULL,0);
	PackedBuffer.AddToFront(NULL,sizeof(DN_ENUM_RESPONSE_PAYLOAD));
	hResultCode = pdnObject->ApplicationDesc.PackInfo(&PackedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	DNASSERT( hResultCode == DPNERR_BUFFERTOOSMALL );

	//
	//	Ensure this enum response will fit in SP enum frame - only indicate this if there was a response
	//
	if (((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0)) &&
			(PackedBuffer.GetSizeRequired() + AppData.dwResponseDataSize > spGetCapsData.dwEnumFrameSize))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Enum response is too large");
		DNUserReturnBuffer(pdnObject,DPNERR_ENUMRESPONSETOOLARGE,AppData.pvResponseData,AppData.pvResponseContext);
		goto Failure;
	}

	hResultCode = RefCountBufferNew(pdnObject,
								PackedBuffer.GetSizeRequired(),
								EnumReplyMemoryBlockAlloc,
								EnumReplyMemoryBlockFree,
								&pRefCountBuffer);
	if ( hResultCode != DPN_OK )
	{
		DNASSERT( FALSE );
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		goto Failure;
	}
	PackedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),
							pRefCountBuffer->GetBufferSize());
	pEnumResponsePayload = static_cast<DN_ENUM_RESPONSE_PAYLOAD*>(PackedBuffer.GetHeadAddress());
	hResultCode = PackedBuffer.AddToFront(NULL,sizeof(DN_ENUM_RESPONSE_PAYLOAD));
	if (hResultCode != DPN_OK)
	{
		DNASSERT(FALSE);
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		goto Failure;
	}
	if ((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0))
	{
		pEnumResponsePayload->dwResponseOffset = pRefCountBuffer->GetBufferSize();
		pEnumResponsePayload->dwResponseSize = AppData.dwResponseDataSize;
	}
	else
	{
		pEnumResponsePayload->dwResponseOffset = 0;
		pEnumResponsePayload->dwResponseSize = 0;
	}
	pdnObject->ApplicationDesc.PackInfo(&PackedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if ( hResultCode != DPN_OK )
	{
		DNASSERT( FALSE );
		goto Failure;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	// build enum response and send it down to the protocol
	//
	pEnumResponseOpData = pAsyncOp->GetLocalEnumResponseOpData();
	pEnumResponseOpData->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD].pBufferData = pRefCountBuffer->GetBufferAddress();
	pEnumResponseOpData->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD].dwBufferSize = pRefCountBuffer->GetBufferSize();

	pAsyncOp->SetCompletion( DNCompleteEnumResponse );
	pAsyncOp->SetRefCountBuffer( pRefCountBuffer );
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	if ((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0))
	{
		pEnumResponseOpData->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData = static_cast<BYTE*>(AppData.pvResponseData);
		pEnumResponseOpData->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].dwBufferSize = AppData.dwResponseDataSize;
		pEnumResponseOpData->pvUserContext = AppData.pvResponseContext;
		dwBufferCount = DN_ENUM_BUFFERDESC_RESPONSE_COUNT;
	}
	else
	{
		pEnumResponseOpData->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData = NULL;
		pEnumResponseOpData->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].dwBufferSize = 0;
		pEnumResponseOpData->pvUserContext = NULL;
		dwBufferCount = DN_ENUM_BUFFERDESC_RESPONSE_COUNT - 1;
	}

	DNASSERT(pListen->GetParent() != NULL);
	DNASSERT(pListen->GetParent()->GetSP() != NULL);
	DNASSERT(pListen->GetParent()->GetSP()->GetHandle() != NULL);

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	pAsyncOp->AddRef();
	hResultCode = DNPEnumRespond(	pdnObject->pdnProtocolData,
									pListen->GetParent()->GetSP()->GetHandle(),
									pEnumQueryData->hEnumQuery,
									&pEnumResponseOpData->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD],
									dwBufferCount,
									0,
									reinterpret_cast<void*>(pAsyncOp),
									&hProtocol);
	if ( hResultCode != DPNERR_PENDING )
	{
		pAsyncOp->Release();
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	//
	//	Save Protocol Handle
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPFX(DPFPREP, 7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetSP( pSP );
	pAsyncOp->SetProtocolHandle(hProtocol);
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

	pSP->Release();
	pSP = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning");
	return;

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pIDP8SP)
	{
		IDP8ServiceProvider_Release(pIDP8SP);
		pIDP8SP = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNProcessEnumResponse - process response to enum query
//
// Entry:		Pointer to this DNet interface object
//				Pointer to the associated enum operation
//				Pointer to protocol's enum response data
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessEnumResponse"

void DNProcessEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp,
						   const PROTOCOL_ENUM_RESPONSE_DATA *const pEnumResponseData)
{
	HRESULT						hResultCode;
	DPNMSG_ENUM_HOSTS_RESPONSE	AppData;
	BYTE						*pWorkingItem;
	UNALIGNED DN_ENUM_RESPONSE_PAYLOAD	*pEnumResponsePayload;
	DPN_APPLICATION_DESC		dpnAppDesc;
	UNALIGNED DPN_APPLICATION_DESC_INFO	*pInfo;
	BYTE						AppDescReservedData[DPN_MAX_APPDESC_RESERVEDDATA_SIZE];


	DNASSERT( pdnObject != NULL );
	DNASSERT( pAsyncOp != NULL );
	DNASSERT( pEnumResponseData != NULL );

	pWorkingItem = pEnumResponseData->ReceivedData.pBufferData;

	//
	//	Unpack the ENUM response.
	//	It will be in the following format:
	//	<UserResponseOffset>
	//	<UserResponseSize>
	//	<AppDescInfo>
	//

	//
	//	Verify buffer size
	//
	if (pEnumResponseData->ReceivedData.dwBufferSize < (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO)))
	{
		DPFERR("Received invalid enum response - buffer is smaller than minimum size");
		goto Exit;
	}

	pEnumResponsePayload = reinterpret_cast<DN_ENUM_RESPONSE_PAYLOAD*>(pEnumResponseData->ReceivedData.pBufferData);

	//
	// Application Description
	//
	pInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pEnumResponsePayload + 1);
	memset(&dpnAppDesc,0,sizeof(DPN_APPLICATION_DESC));
	if (pInfo->dwSessionNameOffset)
	{
		if ((pInfo->dwSessionNameOffset > pEnumResponseData->ReceivedData.dwBufferSize) ||
				(pInfo->dwSessionNameOffset+pInfo->dwSessionNameSize > pEnumResponseData->ReceivedData.dwBufferSize))
		{
			DPFERR("Received invalid enum response - session name is outside of buffer");
			goto Exit;
		}
		dpnAppDesc.pwszSessionName = reinterpret_cast<WCHAR*>(pWorkingItem + pInfo->dwSessionNameOffset);
	}
	if (pInfo->dwReservedDataOffset)
	{
		if ((pInfo->dwReservedDataOffset > pEnumResponseData->ReceivedData.dwBufferSize) ||
				(pInfo->dwReservedDataOffset+pInfo->dwReservedDataSize > pEnumResponseData->ReceivedData.dwBufferSize))
		{
			DPFERR("Received invalid enum response - reserved data is outside of buffer");
			goto Exit;
		}
		dpnAppDesc.pvReservedData = static_cast<void*>(pWorkingItem + pInfo->dwReservedDataOffset);
		dpnAppDesc.dwReservedDataSize = pInfo->dwReservedDataSize;

		//
		// If we understand the reserved data, we want to pad the buffer so the user doesn't
		// assume the data is less than DPN_MAX_APPDESC_RESERVEDDATA_SIZE bytes long.
		//
		if ((dpnAppDesc.dwReservedDataSize == sizeof(SPSESSIONDATA_XNET)) &&
			(*((DWORD*) dpnAppDesc.pvReservedData) == SPSESSIONDATAINFO_XNET))
		{
			SPSESSIONDATA_XNET *	pSessionDataXNet;


			pSessionDataXNet = (SPSESSIONDATA_XNET*) AppDescReservedData;
			memcpy(pSessionDataXNet, dpnAppDesc.pvReservedData, dpnAppDesc.dwReservedDataSize);
			memset((pSessionDataXNet + 1),
						(((BYTE*) (&pSessionDataXNet->ullKeyID))[1] ^ ((BYTE*) (&pSessionDataXNet->guidKey))[2]),
						(DPN_MAX_APPDESC_RESERVEDDATA_SIZE - sizeof(SPSESSIONDATA_XNET)));
			dpnAppDesc.pvReservedData = AppDescReservedData;
			dpnAppDesc.dwReservedDataSize = DPN_MAX_APPDESC_RESERVEDDATA_SIZE;
		}
	}
	if (pInfo->dwApplicationReservedDataOffset)
	{
		if ((pInfo->dwApplicationReservedDataOffset > pEnumResponseData->ReceivedData.dwBufferSize) ||
				(pInfo->dwApplicationReservedDataOffset+pInfo->dwApplicationReservedDataSize > pEnumResponseData->ReceivedData.dwBufferSize))
		{
			DPFERR("Received invalid enum response - application reserved data is outside of buffer");
			goto Exit;
		}
		dpnAppDesc.pvApplicationReservedData = static_cast<void*>(pWorkingItem + pInfo->dwApplicationReservedDataOffset);
		dpnAppDesc.dwApplicationReservedDataSize = pInfo->dwApplicationReservedDataSize;
	}
	dpnAppDesc.guidApplication = pInfo->guidApplication;
	dpnAppDesc.guidInstance = pInfo->guidInstance;
	dpnAppDesc.dwFlags = pInfo->dwFlags;
	dpnAppDesc.dwCurrentPlayers = pInfo->dwCurrentPlayers;
	dpnAppDesc.dwMaxPlayers = pInfo->dwMaxPlayers;
	dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);

	//
	//	Fill in AppData
	//
	AppData.dwSize = sizeof( AppData );
	AppData.pAddressSender = pEnumResponseData->pSenderAddress;
	AppData.pAddressDevice = pEnumResponseData->pDeviceAddress;
	AppData.pApplicationDescription = &dpnAppDesc;
	AppData.dwRoundTripLatencyMS = pEnumResponseData->dwRoundTripTime;

	if (pEnumResponsePayload->dwResponseOffset)
	{
		if ((pEnumResponsePayload->dwResponseOffset > pEnumResponseData->ReceivedData.dwBufferSize) ||
				(pEnumResponsePayload->dwResponseOffset+pEnumResponsePayload->dwResponseSize > pEnumResponseData->ReceivedData.dwBufferSize))
		{
			DPFERR("Received invalid enum response - response data is outside of buffer");
			goto Exit;
		}
		AppData.pvResponseData = (pEnumResponseData->ReceivedData.pBufferData + pEnumResponsePayload->dwResponseOffset);
		AppData.dwResponseDataSize = pEnumResponsePayload->dwResponseSize;
	}
	else
	{
		AppData.pvResponseData = NULL;
		AppData.dwResponseDataSize = 0;
	}
	AppData.pvUserContext = pAsyncOp->GetContext();

	//
	// pass message to the user
	//
	hResultCode = DNUserEnumResponse(pdnObject,&AppData);

	//
	//	Check to see if this is to be cancelled
	//
	if (hResultCode != DPN_OK)
	{
		CAsyncOp	*pCancelOp = NULL;

		//
		//	Get top level operation (may be async op handle)
		//
		pAsyncOp->Lock();
		pCancelOp = pAsyncOp;
		while (pCancelOp->IsChild())
		{
			DNASSERT(pCancelOp->GetParent() != NULL);
			pCancelOp = pCancelOp->GetParent();
		}
		pCancelOp->AddRef();
		pAsyncOp->Unlock();

		//
		//	Cancel
		//
		DNCancelChildren(pdnObject,pCancelOp);
		pCancelOp->Release();
		pCancelOp = NULL;
	}

Exit:
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\enumhosts.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum.h
 *  Content:    Enumeration Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/10/00	mjn		Created
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	07/10/00	mjn		Removed DNCompleteEnumQuery() and DNCompleteEnumResponse()
 *	07/11/00	mjn		Added fields to DN_ENUM_QUERY
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ENUMHOSTS_H__
#define	__ENUMHOSTS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_ENUM_QUERY_WITH_APPLICATION_GUID			0x01
#define	DN_ENUM_QUERY_WITHOUT_APPLICATION_GUID		0x02

#define	DN_ENUM_BUFFERDESC_QUERY_SP_RESERVED		0
#define	DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD			1
#define	DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD		2
#define	DN_ENUM_BUFFERDESC_QUERY_COUNT				2

#define	DN_ENUM_BUFFERDESC_RESPONSE_SP_RESERVED		0
#define	DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD		1
#define	DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD	2
#define	DN_ENUM_BUFFERDESC_RESPONSE_COUNT			2

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack( push, 1 )
typedef	struct	_DN_ENUM_QUERY_PAYLOAD
{
	BYTE	QueryType;
	GUID	guidApplication;
} DN_ENUM_QUERY_PAYLOAD;

typedef	struct	_DN_ENUM_RESPONSE_PAYLOAD
{
	DWORD	dwResponseOffset;
	DWORD	dwResponseSize;
} DN_ENUM_RESPONSE_PAYLOAD;
#pragma pack( pop )

typedef struct _DN_ENUM_QUERY_OP_DATA
{
#ifndef DPNBUILD_ONLYONEADAPTER
	DWORD					dwNumAdapters;
	DWORD					dwCurrentAdapter;
#endif // ! DPNBUILD_ONLYONEADAPTER
	DWORD					dwRetryCount;
	DWORD					dwRetryInterval;
	DWORD					dwTimeOut;
	DN_ENUM_QUERY_PAYLOAD	EnumQueryPayload;
	DPN_BUFFER_DESC			BufferDesc[3];
	DWORD					dwBufferCount;
	DWORD					dwAppDescReservedDataSize;
	BYTE					AppDescReservedData[DPN_MAX_APPDESC_RESERVEDDATA_SIZE];
} DN_ENUM_QUERY_OP_DATA;

typedef struct _DN_ENUM_RESPONSE_OP_DATA
{
	DN_ENUM_RESPONSE_PAYLOAD	EnumResponsePayload;
	DPN_BUFFER_DESC				BufferDesc[3];
	void						*pvUserContext;
} DN_ENUM_RESPONSE_OP_DATA;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

class CAsyncOp;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

void DNProcessEnumQuery(DIRECTNETOBJECT *const pdnObject,
						CAsyncOp *const pAsyncOp,
						const PROTOCOL_ENUM_DATA *const pEnumQueryData );

void DNProcessEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp,
						   const PROTOCOL_ENUM_RESPONSE_DATA *const pEnumResponseData);

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __ENUMHOSTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\dncorei.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dncorei.h
 *  Content:    DirectPlay Core master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *	04/10/01	mjn		Removed Handles.h
 *	10/16/01	vanceo	Added Mcast.h
 *
 ***************************************************************************/

#ifndef __DNCOREI_H__
#define __DNCOREI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#include <xtl.h>
#else // ! _XBOX or XBOX_ON_DESKTOP
#include <windows.h>
#include <mmsystem.h>	// NT BUILD requires this for timeGetTime
#include <stdio.h>
#ifdef XBOX_ON_DESKTOP
#include <winsock.h>
#endif // XBOX_ON_DESKTOP
#endif // ! _XBOX or XBOX_ON_DESKTOP
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#ifndef DPNBUILD_NOVOICE
#include "dvoice.h"
#endif // DPNBUILD_NOVOICE
#ifndef DPNBUILD_NOLOBBY
#include "dplobby8.h"
#endif // ! DPNBUILD_NOLOBBY
#include "dpsp8.h"

#ifdef UNICODE
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLW
#else
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLA
#endif // UNICODE

// 
// DirectPlay private includes
//
#include "osind.h"
#include "classbilink.h"
#include "fixedpool.h"
#include "dneterrors.h"
#include "dndbg.h"
#include "PackBuff.h"
#include "RCBuffer.h"
#include "comutil.h"
#include "creg.h"
#include "HandleTable.h"
#include "ClassFactory.h"


// 
// Address includes
//
#include "dpnaddrextern.h"

// 
// SP includes
//
#include "dpnwsockextern.h"
#ifndef DPNBUILD_NOSERIALSP
#include "dpnmodemextern.h"
#endif // !DPNBUILD_NOSERIALSP
#ifndef DPNBUILD_NOBLUETOOTHSP
#include "dpnbluetoothextern.h"
#endif // !DPNBUILD_NOBLUETOOTHSP

// 
// Lobby includes
//
#ifndef DPNBUILD_NOLOBBY
#include "dpnlobbyextern.h"
#endif // ! DPNBUILD_NOLOBBY

// 
// Protocol includes
//
#include "DNPExtern.h"

//
// Dpnsvr includes
//
#ifndef DPNBUILD_SINGLEPROCESS
#include "dpnsvlib.h"
#endif // ! DPNBUILD_SINGLEPROCESS

// 
// ThreadPool includes
//
#include "threadpooldllmain.h"
#include "threadpoolclassfac.h"

// 
// DirectX private includes
//
#if !defined(_XBOX)
#include "verinfo.h"
#endif // ! _XBOX

// 
// Core private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

#include "Async.h"
#include "EnumHosts.h"
#include "AppDesc.h"
#include "AsyncOp.h"
#include "CallbackThread.h"
#include "Cancel.h"
#include "Caps.h"
#include "Classfac.h"
#include "Client.h"
#include "Common.h"
#include "Connect.h"
#include "Connection.h"
#include "DNCore.h"
#include "DPProt.h"
#include "Enum_SP.h"
#include "GroupCon.h"
#include "GroupMem.h"
#ifndef DPNBUILD_NOMULTICAST
#include "Mcast.h"
#endif // ! DPNBUILD_NOMULTICAST
#include "MemoryFPM.h"
#include "Message.h"
#include "NameTable.h"
#include "NTEntry.h"
#include "NTOp.h"
#include "NTOpList.h"
#include "Paramval.h"
#include "Peer.h"
#include "PendingDel.h"
#include "Pools.h"
#include "Protocol.h"
#include "QueuedMsg.h"
#include "Receive.h"
#include "Request.h"
#include "Server.h"
#include "ServProv.h"
#include "SPMessages.h"
#include "SyncEvent.h"
#include "User.h"
#include "Verify.h"
#include "Voice.h"
#include "Worker.h"
#include "WorkerJob.h"

#endif // __DNCOREI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\enum_sp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum_SP.cpp
 *  Content:    DNET service provider enumeration routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/99	mjn		Created
 *	01/05/00	mjn		Return DPNERR_NOINTERFACE if CoCreateInstance fails
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/18/00	mjn		Converted EnumAdapters registry interface to use CRegistry
 *	01/24/00	mjn		Converted EnumSP registry interface to use CRegistry
 *	04/07/00	mjn		Fixed MemoryHeap corruption problem in DN_EnumSP
 *	04/08/00	mjn		Added DN_SPCrackEndPoint()
 *	05/01/00	mjn		Prevent unusable SPs from being enumerated.
 *	05/02/00	mjn		Better clean-up for DN_SPEnsureLoaded()
 *	05/03/00	mjn		Added DPNENUMSERVICEPROVIDERS_ALL flag
 *	05/23/00	mjn		Fixed cast from LPGUID to GUID*
 *	06/27/00	rmt		Added COM abstraction
 *	07/20/00	mjn		Return SP count from DN_EnumSP() even when buffer is too small
 *	07/29/00	mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/16/00	mjn		Removed DN_SPCrackEndPoint()
 *	08/20/00	mjn		Added DN_SPInstantiate(), DN_SPLoad()
 *				mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	09/25/00	mjn		Handle SP initialization failure in DN_EnumAdapters()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"



#ifndef DPNBUILD_ONLYONESP

#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumSP"

HRESULT DN_EnumSP(DIRECTNETOBJECT *const pdnObject,
				  const DWORD dwFlags,
#ifndef DPNBUILD_LIBINTERFACE
				  const GUID *const lpguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
				  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
				  DWORD *const pcbEnumData,
				  DWORD *const pcReturned)
{
	GUID	guid;
	DWORD	dwSizeRequired;
	DWORD	dwEntrySize;
	DWORD	dwEnumCount;
	DWORD	dwEnumIndex;
	DWORD	dwFriendlyNameLen;
	DWORD	dwGuidSize;
	DWORD	dwKeyLen;
	DWORD	dwMaxFriendlyNameLen;
	DWORD	dwMaxKeyLen;
	PWSTR	pwszFriendlyName;
	PWSTR	pwszKeyName;
	HRESULT	hResultCode = DPN_OK;
	CPackedBuffer				packedBuffer;
	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
	CRegistry	RegistryEntry;
	CRegistry	SubEntry;
	CServiceProvider	*pSP;

#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pSPInfoBuffer,pcbEnumData,pcReturned);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
#endif // ! DPNBUILD_LIBINTERFACE

	DNASSERT(pdnObject != NULL);
	DNASSERT(pcbEnumData != NULL);
	DNASSERT(pcReturned != NULL);

	pwszFriendlyName = NULL;
	pwszKeyName = NULL;
	pSP = NULL;

	dwSizeRequired = *pcbEnumData;
	packedBuffer.Initialize(static_cast<void*>(pSPInfoBuffer),dwSizeRequired);

	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
	{
		DPFERR("RegistryEntry.Open() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Set up to enumerate
	//
	if (!RegistryEntry.GetMaxKeyLen(&dwMaxKeyLen))
	{
		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}
	dwMaxKeyLen++;	// Null terminator
	DPFX(DPFPREP, 5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	dwMaxFriendlyNameLen = dwMaxKeyLen;
	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
	{
		DPFERR("DNMalloc() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
	dwEnumIndex = 0;
	dwKeyLen = dwMaxKeyLen;
	dwEnumCount = 0;

	//
	//	Enumerate SP's !
	//
	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
	{
		dwEntrySize = 0;
		DPFX(DPFPREP, 5,"%ld - %ls (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
		if (!SubEntry.Open(RegistryEntry,pwszKeyName,TRUE,FALSE))
		{
			DPFX(DPFPREP, 0,"Couldn't open subentry.  Skipping [%ls]", pwszKeyName);
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}

		//
		//	GUID
		//
		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
		if (!SubEntry.ReadGUID(DPN_REG_KEYNAME_GUID, &guid))
		{
			DPFX(DPFPREP, 0,"SubEntry.ReadGUID failed.  Skipping [%ls]", pwszKeyName);
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}

		//
		//	If the SP is not already loaded, try loading it to ensure that it's usable
		//
		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
		{
			DPFX(DPFPREP, 5,"Checking [%ls]",pwszKeyName);

			hResultCode = DN_SPEnsureLoaded(pdnObject,
											&guid,
#ifndef DPNBUILD_LIBINTERFACE
											lpguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
											&pSP);
			if (hResultCode != DPN_OK)
			{
				if (hResultCode == DPNERR_UNSUPPORTED)
				{
					DPFX(DPFPREP, 1, "Could not find or load SP, it is unsupported.");
				}
				else
				{
					DPFERR("Could not find or load SP");
					DisplayDNError(0,hResultCode);
				}
				SubEntry.Close();
				dwEnumIndex++;
				dwKeyLen = dwMaxKeyLen;
				hResultCode = DPN_OK; // override return code
				continue;
			}
			pSP->Release();
			pSP = NULL;
		}

		//
		//	Friendly Name
		//
		if (!SubEntry.GetValueLength(DPN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
		{
			DPFX(DPFPREP, 0,"Could not get FriendlyName length.  Skipping [%ls]",pwszKeyName);
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}
		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
		{
			// grow buffer (noting that the registry functions always return WCHAR) and try again
			DPFX(DPFPREP, 5,"Need to grow pwszFriendlyName from %ld to %ld",
					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
			if (pwszFriendlyName != NULL)
			{
				DNFree(pwszFriendlyName);
			}
			dwMaxFriendlyNameLen = dwFriendlyNameLen;
			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
			{
				DPFERR("DNMalloc() failed");
				hResultCode = DPNERR_OUTOFMEMORY;
				goto Failure;
			}
		}
		if (!SubEntry.ReadString(DPN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
		{
			DPFX(DPFPREP, 0,"Could not read friendly name.  Skipping [%ls]",pwszKeyName);
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}
		DPFX(DPFPREP, 5,"Friendly Name = %ls (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);

		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
		dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
		memcpy(&dnSpInfo.guid,&guid,sizeof(GUID));
		dnSpInfo.dwFlags = 0;
		dnSpInfo.dwReserved = 0;
		dnSpInfo.pvReserved = NULL;
		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));

		dwEnumCount++;
		SubEntry.Close();
		dwEnumIndex++;
		dwKeyLen = dwMaxKeyLen;
	}

	RegistryEntry.Close();

	//
	//	Success ?
	//
	dwSizeRequired = packedBuffer.GetSizeRequired();
	if (dwSizeRequired > *pcbEnumData)
	{
		DPFX(DPFPREP, 5,"Buffer too small");
		*pcbEnumData = dwSizeRequired;
		*pcReturned = dwEnumCount;
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Failure;
	}
	else
	{
		*pcReturned = dwEnumCount;
		hResultCode = DPN_OK;
	}

	DPFX(DPFPREP, 5,"*pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

	DNFree(pwszKeyName);
	pwszKeyName = NULL;
	DNFree(pwszFriendlyName);
	pwszFriendlyName = NULL;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pwszKeyName)
	{
		DNFree(pwszKeyName);
		pwszKeyName = NULL;
	}
	if (pwszFriendlyName)
	{
		DNFree(pwszFriendlyName);
		pwszFriendlyName = NULL;
	}
	if (SubEntry.IsOpen())
	{
		SubEntry.Close();
	}
	if (RegistryEntry.IsOpen())
	{
		RegistryEntry.Close();
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}

#endif // ! DPNBUILD_ONLYONESP


#ifndef DPNBUILD_ONLYONEADAPTER

#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumAdapters"

HRESULT DN_EnumAdapters(DIRECTNETOBJECT *const pdnObject,
						const DWORD dwFlags,
#ifndef DPNBUILD_ONLYONESP
						const GUID *const pguidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
						const GUID *const pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
						DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
						DWORD *const pcbEnumData,
						DWORD *const pcReturned)
{
	HRESULT					hResultCode;
	CServiceProvider		*pSP;
	IDP8ServiceProvider		*pDNSP;
	SPENUMADAPTERSDATA		spEnumData;
#ifndef DPNBUILD_ONLYONESP
	BOOL					bFound;
	GUID					guid;
	DWORD					dwEnumIndex;
	DWORD					dwKeyLen;
	DWORD					dwMaxKeyLen;
	LPWSTR					lpwszKeyName;
	CRegistry				RegistryEntry;
	CRegistry				SubEntry;
#endif // ! DPNBUILD_ONLYONESP

#ifdef DPNBUILD_ONLYONESP
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pSPInfoBuffer,pcbEnumData,pcReturned);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidApplication [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
#endif // ! DPNBUILD_LIBINTERFACE
#else // ! DPNBUILD_ONLYONESP
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidSP [0x%p], [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidSP,pSPInfoBuffer,pcbEnumData,pcReturned);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidSP [0x%p], pguidApplication [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidSP,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
#endif // ! DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_ONLYONESP

	DNASSERT(pdnObject != NULL);
	DNASSERT(pcbEnumData != NULL);
	DNASSERT(pcReturned != NULL);

	pSP = NULL;
	pDNSP = NULL;
#ifndef DPNBUILD_ONLYONESP
	lpwszKeyName = NULL;

	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
	{
		DPFERR("RegOpenKeyExA() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Set up to enumerate
	//
	if (!RegistryEntry.GetMaxKeyLen(&dwMaxKeyLen))
	{
		DPFERR("RegQueryInfoKey() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}
	dwMaxKeyLen++;	// Null terminator
	DPFX(DPFPREP, 7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
	if ((lpwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen*sizeof(WCHAR)))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	dwEnumIndex = 0;
	dwKeyLen = dwMaxKeyLen;

	//
	//	Locate Service Provider
	//
	bFound = FALSE;
	while (RegistryEntry.EnumKeys(lpwszKeyName,&dwKeyLen,dwEnumIndex))
	{
		// For each service provider
		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,TRUE,FALSE))
		{
			DPFERR("RegOpenKeyExA() failed");
			hResultCode = DPNERR_GENERIC;
			goto Failure;
		}

		// Get SP GUID
		if (!SubEntry.ReadGUID(DPN_REG_KEYNAME_GUID, &guid))
		{
			DPFERR("Could not read GUID");
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}

		// Check SP GUID
		if (guid == *pguidSP)
		{
			bFound = TRUE;
			break;
		}
		SubEntry.Close();
		dwKeyLen = dwMaxKeyLen;
		dwEnumIndex++;
	}

	if (!bFound)
	{
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONESP

	//
	//	Ensure SP is loaded
	//
	hResultCode = DN_SPEnsureLoaded(pdnObject,
#ifndef DPNBUILD_ONLYONESP
									pguidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
									pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
									&pSP);
	if (hResultCode != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not find or load SP");
		DisplayDNError(1,hResultCode);
		goto Failure;
	}

	//
	//	Get SP interface
	//
	if ((hResultCode = pSP->GetInterfaceRef(&pDNSP)) != DPN_OK)
	{
		DPFERR("Could not get SP interface");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pSP->Release();
	pSP = NULL;

	spEnumData.pAdapterData = pSPInfoBuffer;
	spEnumData.dwAdapterDataSize = *pcbEnumData;
	spEnumData.dwAdapterCount = *pcReturned;
	spEnumData.dwFlags = 0;

	hResultCode = IDP8ServiceProvider_EnumAdapters(pDNSP,&spEnumData);
	*pcbEnumData = spEnumData.dwAdapterDataSize;
	*pcReturned = spEnumData.dwAdapterCount;

	IDP8ServiceProvider_Release(pDNSP);
	pDNSP = NULL;

#ifndef DPNBUILD_ONLYONESP
	if (lpwszKeyName)
	{
		DNFree(lpwszKeyName);
		lpwszKeyName = NULL;
	}
#endif // ! DPNBUILD_ONLYONESP

	DPFX(DPFPREP, 5,"*pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

Exit:
	DNASSERT( pSP == NULL );
	DNASSERT( pDNSP == NULL );
#ifndef DPNBUILD_ONLYONESP
	DNASSERT( lpwszKeyName == NULL );
#endif // ! DPNBUILD_ONLYONESP

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pDNSP)
	{
		IDP8ServiceProvider_Release(pDNSP);
		pDNSP = NULL;
	}
#ifndef DPNBUILD_ONLYONESP
	if (lpwszKeyName)
	{
		DNFree(lpwszKeyName);
		lpwszKeyName = NULL;
	}
#endif // ! DPNBUILD_ONLYONESP
	goto Exit;
}

#endif // ! DPNBUILD_ONLYONEADAPTER


#ifndef DPNBUILD_NOMULTICAST

#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumMulticastScopes"

HRESULT DN_EnumMulticastScopes(DIRECTNETOBJECT *const pdnObject,
								const DWORD dwFlags,
#ifndef DPNBUILD_ONLYONESP
								const GUID *const pguidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
								const GUID *const pguidDevice,
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_LIBINTERFACE
								const GUID *const pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
								DPN_MULTICAST_SCOPE_INFO *const pScopeInfoBuffer,
								DWORD *const pcbEnumData,
								DWORD *const pcReturned)
{
	HRESULT						hResultCode;
	CServiceProvider			*pSP;
	IDP8ServiceProvider			*pDNSP;
	SPENUMMULTICASTSCOPESDATA	spEnumData;
#ifndef DPNBUILD_ONLYONESP
	BOOL						bFound;
	GUID						guid;
	DWORD						dwEnumIndex;
	DWORD						dwKeyLen;
	DWORD						dwMaxKeyLen;
	LPWSTR						lpwszKeyName;
	CRegistry					RegistryEntry;
	CRegistry					SubEntry;
#endif // ! DPNBUILD_ONLYONESP

#ifdef DPNBUILD_ONLYONESP
#ifdef DPNBUILD_ONLYONEADAPTER
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pScopeInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pScopeInfoBuffer,pcbEnumData,pcReturned);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidApplication [0x%p], pScopeInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidApplication,pScopeInfoBuffer,pcbEnumData,pcReturned);
#endif // ! DPNBUILD_LIBINTERFACE
#else // ! DPNBUILD_ONLYONEADAPTER
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidDevice [0x%p], pScopeInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidDevice,pScopeInfoBuffer,pcbEnumData,pcReturned);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidDevice [0x%p], pguidApplication [0x%p], pScopeInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidDevice,pguidApplication,pScopeInfoBuffer,pcbEnumData,pcReturned);
#endif // ! DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_ONLYONEADAPTER
#else // ! DPNBUILD_ONLYONESP
#ifdef DPNBUILD_ONLYONEADAPTER
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidSP [0x%p], pScopeInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidSP,pScopeInfoBuffer,pcbEnumData,pcReturned);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidSP [0x%p], pguidApplication [0x%p], pScopeInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidSP,pguidApplication,pScopeInfoBuffer,pcbEnumData,pcReturned);
#endif // ! DPNBUILD_LIBINTERFACE
#else // ! DPNBUILD_ONLYONEADAPTER
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidSP [0x%p], pguidDevice [0x%p], pScopeInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidSP,pguidDevice,pScopeInfoBuffer,pcbEnumData,pcReturned);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 4,"Parameters: dwFlags [0x%lx], pguidSP [0x%p], pguidDevice [0x%p], pguidApplication [0x%p], pScopeInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,pguidSP,pguidDevice,pguidApplication,pScopeInfoBuffer,pcbEnumData,pcReturned);
#endif // ! DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_ONLYONEADAPTER
#endif // ! DPNBUILD_ONLYONESP

	DNASSERT(pdnObject != NULL);
	DNASSERT(pcbEnumData != NULL);
	DNASSERT(pcReturned != NULL);

	pSP = NULL;
	pDNSP = NULL;
#ifndef DPNBUILD_ONLYONESP
	lpwszKeyName = NULL;

	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DPN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
	{
		DPFERR("RegOpenKeyExA() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Set up to enumerate
	//
	if (!RegistryEntry.GetMaxKeyLen(&dwMaxKeyLen))
	{
		DPFERR("RegQueryInfoKey() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}
	dwMaxKeyLen++;	// Null terminator
	DPFX(DPFPREP, 7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
	if ((lpwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen*sizeof(WCHAR)))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	dwEnumIndex = 0;
	dwKeyLen = dwMaxKeyLen;

	//
	//	Locate Service Provider
	//
	bFound = FALSE;
	while (RegistryEntry.EnumKeys(lpwszKeyName,&dwKeyLen,dwEnumIndex))
	{
		// For each service provider
		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,TRUE,FALSE))
		{
			DPFERR("RegOpenKeyExA() failed");
			hResultCode = DPNERR_GENERIC;
			goto Failure;
		}

		// Get SP GUID
		if (!SubEntry.ReadGUID(DPN_REG_KEYNAME_GUID, &guid))
		{
			DPFERR("Could not read GUID");
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
			continue;
		}

		// Check SP GUID
		if (guid == *pguidSP)
		{
			bFound = TRUE;
			break;
		}
		SubEntry.Close();
		dwKeyLen = dwMaxKeyLen;
		dwEnumIndex++;
	}

	if (!bFound)
	{
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONESP

	//
	//	Ensure SP is loaded
	//
	hResultCode = DN_SPEnsureLoaded(pdnObject,
#ifndef DPNBUILD_ONLYONESP
									pguidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
									pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
									&pSP);
	if (hResultCode != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not find or load SP");
		DisplayDNError(1,hResultCode);
		goto Failure;
	}

	//
	//	Get SP interface
	//
	if ((hResultCode = pSP->GetInterfaceRef(&pDNSP)) != DPN_OK)
	{
		DPFERR("Could not get SP interface");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pSP->Release();
	pSP = NULL;

#ifdef DPNBUILD_ONLYONEADAPTER
	spEnumData.pguidAdapter = NULL;
#else // ! DPNBUILD_ONLYONEADAPTER
	spEnumData.pguidAdapter = pguidDevice;
#endif // ! DPNBUILD_ONLYONEADAPTER
	spEnumData.pScopeData = pScopeInfoBuffer;
	spEnumData.dwScopeDataSize = *pcbEnumData;
	spEnumData.dwScopeCount = *pcReturned;
	spEnumData.dwFlags = 0;

	hResultCode = IDP8ServiceProvider_EnumMulticastScopes(pDNSP,&spEnumData);
	*pcbEnumData = spEnumData.dwScopeDataSize;
	*pcReturned = spEnumData.dwScopeCount;

	IDP8ServiceProvider_Release(pDNSP);
	pDNSP = NULL;

#ifndef DPNBUILD_ONLYONESP
	if (lpwszKeyName)
	{
		DNFree(lpwszKeyName);
		lpwszKeyName = NULL;
	}
#endif // ! DPNBUILD_ONLYONESP

	DPFX(DPFPREP, 5,"*pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

Exit:
	DNASSERT( pSP == NULL );
	DNASSERT( pDNSP == NULL );
#ifndef DPNBUILD_ONLYONESP
	DNASSERT( lpwszKeyName == NULL );
#endif // ! DPNBUILD_ONLYONESP

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pDNSP)
	{
		IDP8ServiceProvider_Release(pDNSP);
		pDNSP = NULL;
	}
#ifndef DPNBUILD_ONLYONESP
	if (lpwszKeyName)
	{
		DNFree(lpwszKeyName);
		lpwszKeyName = NULL;
	}
#endif // ! DPNBUILD_ONLYONESP
	goto Exit;
}

#endif // ! DPNBUILD_NOMULTICAST



#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPReleaseAll"

void DN_SPReleaseAll(DIRECTNETOBJECT *const pdnObject)
{
#ifndef DPNBUILD_ONLYONESP
	CBilink				*pBilink;
	CServiceProvider	*pSP;
#endif // ! DPNBUILD_ONLYONESP

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	DNEnterCriticalSection(&pdnObject->csServiceProviders);

#ifdef DPNBUILD_ONLYONESP
	DNASSERT(pdnObject->pOnlySP != NULL);
	pdnObject->pOnlySP->Deinitialize();
	pdnObject->pOnlySP = NULL;
#else // ! DPNBUILD_ONLYONESP
	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		pSP = CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders);
		pBilink = pBilink->GetNext();
		pSP->m_bilinkServiceProviders.RemoveFromList();
		pSP->Release();
		pSP = NULL;
	}
#endif // ! DPNBUILD_ONLYONESP

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	DPFX(DPFPREP, 6,"Returning");
}


#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_LIBINTERFACE)))

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPInstantiate"

HRESULT DN_SPInstantiate(
						 DIRECTNETOBJECT *const pdnObject
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
						 ,const XDP8CREATE_PARAMS * const pDP8CreateParams
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
						 )
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pdnObject [0x%p]",pdnObject);

	//
	//	Create and initialize SP
	//
	DNASSERT(pdnObject->pOnlySP == NULL);
	pdnObject->pOnlySP = (CServiceProvider*) DNMalloc(sizeof(CServiceProvider));
	if (pdnObject->pOnlySP == NULL)
	{
		DPFERR("Could not create SP");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	hResultCode = pdnObject->pOnlySP->Initialize(
												pdnObject
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
												,pDP8CreateParams
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
												);
	if (hResultCode != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not initialize SP");
		DisplayDNError(1,hResultCode);
		goto Failure;
	}

	DPFX(DPFPREP, 7, "Created Service Provider object 0x%p.", pdnObject->pOnlySP);
	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pdnObject->pOnlySP)
	{
		pdnObject->pOnlySP->Release();
		pdnObject->pOnlySP = NULL;
	}
	goto Exit;
}

#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE


//	DN_SPInstantiate
//
//	Instantiate an SP, regardless of whether it's loaded or not

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPInstantiate"

HRESULT DN_SPInstantiate(DIRECTNETOBJECT *const pdnObject,
#ifndef DPNBUILD_ONLYONESP
						 const GUID *const pguid,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
						 const GUID *const pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
						 CServiceProvider **const ppSP)
{
	HRESULT		hResultCode;
	CServiceProvider	*pSP;

#ifdef DPNBUILD_ONLYONESP
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: ppSP [0x%p]",ppSP);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: pguidApplication [0x%p], ppSP [0x%p]",pguidApplication,ppSP);
#endif // ! DPNBUILD_LIBINTERFACE
#else // ! DPNBUILD_ONLYONESP
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], ppSP [0x%p]",pguid,ppSP);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], pguidApplication [0x%p], ppSP [0x%p]",pguid,pguidApplication,ppSP);
#endif // ! DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_ONLYONESP

	pSP = NULL;

	//
	//	Create and initialize SP
	//
	pSP = (CServiceProvider*) DNMalloc(sizeof(CServiceProvider));
	if (pSP == NULL)
	{
		DPFERR("Could not create SP");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "Created Service Provider object 0x%p.", pSP);
	
	hResultCode = pSP->Initialize(pdnObject
#ifndef DPNBUILD_ONLYONESP
								,pguid
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
								,pguidApplication
#endif // ! DPNBUILD_LIBINTERFACE
								);
	if (hResultCode != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not initialize SP");
		DisplayDNError(1,hResultCode);
		goto Failure;
	}
	

	if (ppSP)
	{
		pSP->AddRef();
		*ppSP = pSP;
	}

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		DNFree(pSP);
		pSP = NULL;
	}
	goto Exit;
}



//	DN_SPFindEntry
//
//	Find a connected SP and AddRef it if it exists

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPFindEntry"

#ifdef DPNBUILD_ONLYONESP
HRESULT DN_SPFindEntry(DIRECTNETOBJECT *const pdnObject,
					   CServiceProvider **const ppSP)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: ppSP [0x%p]",ppSP);

	DNEnterCriticalSection(&pdnObject->csServiceProviders);

	if (pdnObject->pOnlySP)
	{
		pdnObject->pOnlySP->AddRef();
		*ppSP = pdnObject->pOnlySP;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_DOESNOTEXIST;
	}

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
#else // ! DPNBUILD_ONLYONESP
HRESULT DN_SPFindEntry(DIRECTNETOBJECT *const pdnObject,
					   const GUID *const pguid,
					   CServiceProvider **const ppSP)
{
	HRESULT				hResultCode;
	CBilink				*pBilink;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 6,"Parameters: ppSP [0x%p]",ppSP);

	DNEnterCriticalSection(&pdnObject->csServiceProviders);

	hResultCode = DPNERR_DOESNOTEXIST;
	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		pSP = CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders);
		if (pSP->CheckGUID(pguid))
		{
			pSP->AddRef();
			*ppSP = pSP;
			hResultCode = DPN_OK;
			break;
		}
		pBilink = pBilink->GetNext();
	}

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
#endif // ! DPNBUILD_ONLYONESP


//	DN_SPLoad
//
//	Load an SP, and set caps

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPLoad"

HRESULT DN_SPLoad(DIRECTNETOBJECT *const pdnObject,
#ifndef DPNBUILD_ONLYONESP
				  const GUID *const pguid,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
				  const GUID *const pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
				  CServiceProvider **const ppSP)
{
	HRESULT		hResultCode;
	DPN_SP_CAPS	*pCaps;
#ifndef DPNBUILD_ONLYONESP
	CBilink		*pBilink;
#endif // ! DPNBUILD_ONLYONESP
	CServiceProvider	*pSP;

#ifdef DPNBUILD_ONLYONESP
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: ppSP [0x%p]",ppSP);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: pguidApplication [0x%p], ppSP [0x%p]",pguidApplication,ppSP);
#endif // ! DPNBUILD_LIBINTERFACE
#else // ! DPNBUILD_ONLYONESP
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], ppSP [0x%p]",pguid,ppSP);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], pguidApplication [0x%p], ppSP [0x%p]",pguid,pguidApplication,ppSP);
#endif // ! DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_ONLYONESP

	pSP = NULL;
	pCaps = NULL;

	//
	//	Instantiate SP
	//
	hResultCode = DN_SPInstantiate(pdnObject,
#ifndef DPNBUILD_ONLYONESP
									pguid,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
									pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
									&pSP);
	if (hResultCode != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not instantiate SP");
		DisplayDNError(1,hResultCode);
		goto Failure;
	}

	DNASSERT(pSP != NULL);

	//
	//	Keep this loaded on the DirectNet object.  We will also check for duplicates.
	//
	DNEnterCriticalSection(&pdnObject->csServiceProviders);

#ifdef DPNBUILD_ONLYONESP
	if (pdnObject->pOnlySP != NULL)
	{
		DNLeaveCriticalSection(&pdnObject->csServiceProviders);
		DPFERR("SP is already loaded!");
		hResultCode = DPNERR_ALREADYINITIALIZED;
		goto Failure;
	}
#else // ! DPNBUILD_ONLYONESP
	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		if ((CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders))->CheckGUID(pguid))
		{
			DNLeaveCriticalSection(&pdnObject->csServiceProviders);
			DPFERR("SP is already loaded!");
			hResultCode = DPNERR_ALREADYINITIALIZED;
			goto Failure;
		}
		pBilink = pBilink->GetNext();
	}
#endif // ! DPNBUILD_ONLYONESP

	//
	//	Add the SP to the SP list off the DirectNet object and add a reference for it
	//
	pSP->AddRef();
#ifdef DPNBUILD_ONLYONESP
	pdnObject->pOnlySP = pSP;
#else // ! DPNBUILD_ONLYONESP
	pSP->m_bilinkServiceProviders.InsertBefore(&pdnObject->m_bilinkServiceProviders);
#endif // ! DPNBUILD_ONLYONESP

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	if (ppSP)
	{
		pSP->AddRef();
		*ppSP = pSP;
	}

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


//	DN_SPEnsureLoaded
//
//	Ensure that an SP is loaded.  If the SP is not loaded,
//	it will be instantiated, and connected to the protocol.
//	If it is loaded, its RefCount will be increased.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPEnsureLoaded"

HRESULT DN_SPEnsureLoaded(DIRECTNETOBJECT *const pdnObject,
#ifndef DPNBUILD_ONLYONESP
						  const GUID *const pguid,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
						  const GUID *const pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
						  CServiceProvider **const ppSP)
{
	HRESULT				hResultCode;
	CServiceProvider	*pSP;

#ifdef DPNBUILD_ONLYONESP
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: ppSP [0x%p]",ppSP);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: pguidApplication [0x%p], ppSP [0x%p]",pguidApplication,ppSP);
#endif // ! DPNBUILD_LIBINTERFACE
#else // ! DPNBUILD_ONLYONESP
#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], ppSP [0x%p]",pguid,ppSP);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 6,"Parameters: pguid [0x%p], pguidApplication [0x%p], ppSP [0x%p]",pguid,pguidApplication,ppSP);
#endif // ! DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_ONLYONESP

	pSP = NULL;

	//
	//	Try to find the SP
	//
	hResultCode = DN_SPFindEntry(pdnObject,
#ifndef DPNBUILD_ONLYONESP
								pguid,
#endif // ! DPNBUILD_ONLYONESP
								&pSP);
	if (hResultCode == DPNERR_DOESNOTEXIST)
	{
		//
		//	Instantiate SP and add to Protocol
		//
		hResultCode = DN_SPLoad(pdnObject,
#ifndef DPNBUILD_ONLYONESP
								pguid,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
								pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
								&pSP);
		if (hResultCode != DPN_OK)
		{
			DPFX(DPFPREP,1,"Could not load SP");
			DisplayDNError(1,hResultCode);
			goto Failure;
		}
	}
	else
	{
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not find SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	DNASSERT(pSP != NULL);

	if (ppSP != NULL)
	{
		pSP->AddRef();
		*ppSP = pSP;
	}

	pSP->Release();
	pSP = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}

#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\enum_sp.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum_SP.h
 *  Content:    DirectNet SP/Adapter Enumeration
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/15/00	mjn		Created
 *	04/08/00	mjn		Added DN_SPCrackEndPoint()
 *	05/01/00	mjn		Prevent unusable SPs from being enumerated.
 *	07/29/00	mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *	08/16/00	mjn		Removed DN_SPCrackEndPoint()
 *	08/20/00	mjn		Added DN_SPInstantiate(), DN_SPLoad()
 *				mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ENUM_SP_H__
#define	__ENUM_SP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#ifndef	GUID_STRING_LENGTH
#define	GUID_STRING_LENGTH	((sizeof(GUID) * 2) + 2 + 4)
#endif // GUID_STRING_LENGTH
//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CServiceProvider;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
//	Enumeration
//
#ifndef DPNBUILD_ONLYONESP
HRESULT DN_EnumSP(DIRECTNETOBJECT *const pdnObject,
				  const DWORD dwFlags,
#ifndef DPNBUILD_LIBINTERFACE
				  const GUID *const lpguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
				  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
				  DWORD *const pcbEnumData,
				  DWORD *const pcReturned);
#endif // ! DPNBUILD_ONLYONESP

#ifndef DPNBUILD_ONLYONEADAPTER
HRESULT DN_EnumAdapters(DIRECTNETOBJECT *const pdnObject,
						const DWORD dwFlags,
#ifndef DPNBUILD_ONLYONESP
						const GUID *const lpguidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
						const GUID *const lpguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
						DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
						DWORD *const pcbEnumData,
						DWORD *const pcReturned);
#endif // ! DPNBUILD_ONLYONEADAPTER

#ifndef DPNBUILD_NOMULTICAST
HRESULT DN_EnumMulticastScopes(DIRECTNETOBJECT *const pdnObject,
									const DWORD dwFlags,
#ifndef DPNBUILD_ONLYONESP
									const GUID *const pguidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
									const GUID *const pguidDevice,
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_LIBINTERFACE
									const GUID *const pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
									DPN_MULTICAST_SCOPE_INFO *const pScopeInfoBuffer,
									DWORD *const pcbEnumData,
									DWORD *const pcReturned);
#endif // ! DPNBUILD_NOMULTICAST

void DN_SPReleaseAll(DIRECTNETOBJECT *const pdnObject);

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_LIBINTERFACE)))

HRESULT DN_SPInstantiate(DIRECTNETOBJECT *const pdnObject
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
						 ,const XDP8CREATE_PARAMS * const pDP8CreateParams
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
						 );

#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE

HRESULT DN_SPInstantiate(DIRECTNETOBJECT *const pdnObject,
#ifndef DPNBUILD_ONLYONESP
						 const GUID *const pguid,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
						 const GUID *const pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
						 CServiceProvider **const ppSP);

HRESULT DN_SPFindEntry(DIRECTNETOBJECT *const pdnObject,
#ifndef DPNBUILD_ONLYONESP
					   const GUID *const pguidSP,
#endif // ! DPNBUILD_ONLYONESP
					   CServiceProvider **const ppSP);

HRESULT DN_SPLoad(DIRECTNETOBJECT *const pdnObject,
#ifndef DPNBUILD_ONLYONESP
				  const GUID *const pguid,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
				  const GUID *const pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
				  CServiceProvider **const ppSP);

HRESULT DN_SPEnsureLoaded(DIRECTNETOBJECT *const pdnObject,
#ifndef DPNBUILD_ONLYONESP
						  const GUID *const pguid,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
						  const GUID *const pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
						  CServiceProvider **const ppSP);

#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE


#endif	// __ENUM_SP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\groupcon.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupCon.cpp
 *  Content:    Group Connection object routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/02/00	mjn		Created
 *	04/18/00	mjn		CConnection tracks connection status better
 *	05/05/00	mjn		Added GetConnectionRef()
 *	08/15/00	mjn		Added SetGroup()
 *				mjn		Fixed Release() to take locks and cleanup m_pGroup
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


void CGroupConnection::ReturnSelfToPool( void )
{
	g_GroupConnectionPool.Release( this );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CGroupConnection::Release"

void CGroupConnection::Release(void)
{
	LONG	lRefCount;

	DNASSERT(m_lRefCount > 0);
	lRefCount = DNInterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
	if (lRefCount == 0)
	{
		if (m_pGroup)
		{
			m_pGroup->Lock();
			RemoveFromConnectionList();
			m_pGroup->Unlock();

			m_pGroup->Release();
			m_pGroup = NULL;
		}
		if (m_pConnection)
		{
			m_pConnection->Release();
			m_pConnection = NULL;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		ReturnSelfToPool();
	}
}


void CGroupConnection::SetConnection( CConnection *const pConnection )
{
	if (pConnection)
	{
		pConnection->Lock();
		if (pConnection->IsConnected())
		{
			pConnection->AddRef();
			m_pConnection = pConnection;
		}
		pConnection->Unlock();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CGroupConnection::GetConnectionRef"

HRESULT	CGroupConnection::GetConnectionRef( CConnection **const ppConnection )
{
	HRESULT		hResultCode;

	DNASSERT( ppConnection != NULL);

	Lock();
	if ( m_pConnection && !m_pConnection->IsInvalid())
	{
		m_pConnection->AddRef();
		*ppConnection = m_pConnection;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_NOCONNECTION;
	}
	Unlock();

	return( hResultCode );
}


void CGroupConnection::SetGroup( CNameTableEntry *const pGroup )
{
	if (pGroup)
	{
		pGroup->AddRef();
	}
	m_pGroup = pGroup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\groupcon.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupCon.h
 *  Content:    Group Connection Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/02/00	mjn		Created
 *	05/05/00	mjn		Added GetConnectionRef()
 *	08/15/00	mjn		Added m_pGroup,SetGroup(),GetGroup()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__GROUPCON_H__
#define	__GROUPCON_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	VALID		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CConnection;
class CNameTableEntry;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Group Connections

class CGroupConnection
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupConnection::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CGroupConnection* pGroupConn = (CGroupConnection*)pvItem;

			pGroupConn->m_Sig[0] = 'G';
			pGroupConn->m_Sig[1] = 'C';
			pGroupConn->m_Sig[2] = 'O';
			pGroupConn->m_Sig[3] = 'N';

			if (!DNInitializeCriticalSection(&pGroupConn->m_cs))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&pGroupConn->m_cs,0);
		
			pGroupConn->m_bilink.Initialize();

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupConnection::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CGroupConnection* pGroupConn = (CGroupConnection*)pvItem;

			pGroupConn->m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			pGroupConn->m_dwFlags = 0;
			pGroupConn->m_pConnection = NULL;
			pGroupConn->m_lRefCount = 1;
			pGroupConn->m_pGroup = NULL;

			DNASSERT(pGroupConn->m_bilink.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupConnection::FPMRelease"
	static void FPMRelease( void* pvItem )
		{
			const CGroupConnection* pGroupConn = (CGroupConnection*)pvItem;

			DNASSERT(pGroupConn->m_bilink.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupConnection::FPMDealloc"
	static void FPMDealloc( void* pvItem )
		{
			CGroupConnection* pGroupConn = (CGroupConnection*)pvItem;

			DNDeleteCriticalSection(&pGroupConn->m_cs);
		};

	void ReturnSelfToPool( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupConnection::AddRef"
	void AddRef(void)
		{
			DNASSERT(m_lRefCount > 0);
			DNInterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
		};

	void Release(void);

	void Lock( void )
		{
			DNEnterCriticalSection(&m_cs);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_cs);
		};

	void AddToConnectionList( CBilink *const pBilink )
		{
			m_bilink.InsertBefore(pBilink);
		};

	void RemoveFromConnectionList( void )
		{
			m_bilink.RemoveFromList();
		};

	void SetConnection( CConnection *const pConnection );

	CConnection *GetConnection( void )
	{
		return(m_pConnection);
	};

	HRESULT	GetConnectionRef( CConnection **const ppConnection );

	void SetGroup( CNameTableEntry *const pGroup );

	CNameTableEntry *GetGroup( void )
		{
			return( m_pGroup );
		};

	void MakeValid( void )
		{
			m_dwFlags |= VALID;
		};

	void MakeInvalid( void )
		{
			m_dwFlags &= (~VALID);
		};

	BOOL IsConnected( void ) const
		{
			if (m_pConnection != NULL)
				return(TRUE);

			return(FALSE);
		};

	CBilink				m_bilink;

private:
	BYTE				m_Sig[4];
	DWORD	volatile	m_dwFlags;
	LONG	volatile	m_lRefCount;
	CConnection			*m_pConnection;
	CNameTableEntry		*m_pGroup;
#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	m_cs;
#endif // !DPNBUILD_ONLYONETHREAD
	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __GROUPCON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\groupmem.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupMem.cpp
 *  Content:    Group Membership object routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/03/00	mjn		Created
 *	08/05/99	mjn		Modified SetMembership to perform duplicate check and get NameTable version internally
 *	08/15/00	mjn		Allow NULL pGroupConnection in SetGroupConnection()
 *	09/17/00	mjn		Remove locks from SetMembership()
 *	09/26/00	mjn		Assume NameTable locks are taken for AddMembership() and RemoveMembership()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


void CGroupMember::ReturnSelfToPool( void )
{
	g_GroupMemberPool.Release( this );
};


#undef DPF_MODNAME
#define DPF_MODNAME "CGroupMember::Release"
void CGroupMember::Release( void )
{
	LONG	lRefCount;

	lRefCount = DNInterlockedDecrement(&m_lRefCount);

	if (lRefCount == 0)
	{
		DNASSERT(!(m_dwFlags & GROUP_MEMBER_FLAG_AVAILABLE));

		if (m_pGroup != NULL)
		{
			m_pGroup->Release();
			m_pGroup = NULL;
		}
		if (m_pPlayer != NULL)
		{
			m_pPlayer->Release();
			m_pPlayer = NULL;
		}
		if (m_pGroupConnection != NULL)
		{
			m_pGroupConnection->Release();
			m_pGroupConnection = NULL;
		}

		ReturnSelfToPool();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CGroupMember::SetMembership"

HRESULT CGroupMember::SetMembership(CNameTableEntry *const pGroup,
									CNameTableEntry *const pPlayer,
									DWORD *const pdwVersion)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CGroupMember	*pGroupMember;

	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	//
	//	THIS ASSUMES THAT LOCKS FOR NameTable,pGroup,pPlayer and 'this' are taken (in that order) !
	//

	//
	//	Scan group list to ensure this player is not a member already
	//
	pBilink = pGroup->m_bilinkMembership.GetNext();
	while (pBilink != &pGroup->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		if (pGroupMember->GetPlayer() == pPlayer)
		{
			hResultCode = DPNERR_PLAYERALREADYINGROUP;
			goto Failure;
		}
		pBilink = pBilink->GetNext();
	}

	//
	//	Version stuff
	//
	if (pdwVersion)
	{
		if (*pdwVersion)
		{
			DPFX(DPFPREP, 7,"Version already specified");
			m_dwVersion = *pdwVersion;
			m_pdnObject->NameTable.SetVersion(*pdwVersion);
		}
		else
		{
			DPFX(DPFPREP, 7,"New version required");
			m_pdnObject->NameTable.GetNewVersion( &m_dwVersion );
			*pdwVersion = m_dwVersion;
		}
	}
	else
	{
		m_dwVersion = 0;
	}

	//
	//	Update
	//
	AddRef();
	pGroup->AddRef();
	m_pGroup = pGroup;

	AddRef();
	pPlayer->AddRef();
	m_pPlayer = pPlayer;

	m_bilinkGroups.InsertBefore(&pPlayer->m_bilinkMembership);
	m_bilinkPlayers.InsertBefore(&pGroup->m_bilinkMembership);

	if (m_pGroupConnection)
	{
		m_pGroupConnection->AddToConnectionList( &pGroup->m_bilinkConnections );
	}

	hResultCode = DPN_OK;

Exit:
	return(hResultCode);

Failure:
	goto Exit;
}


void CGroupMember::RemoveMembership( DWORD *const pdnVersion )
{
	//
	//	THIS ASSUMES THAT LOCKS FOR NameTable,pGroup,pPlayer and 'this' are taken (in that order) !
	//	Since there will be several Release()'d items, someone should keep a reference on them
	//		so that they don't get free'd with all of the locks taken !
	//

	m_pGroup->Release();
	m_pGroup = NULL;
	Release();

	m_pPlayer->Release();
	m_pPlayer = NULL;
	Release();

	m_bilinkGroups.RemoveFromList();
	m_bilinkPlayers.RemoveFromList();

	if (m_pGroupConnection)
	{
		m_pGroupConnection->RemoveFromConnectionList();
	}

	if (pdnVersion)
	{
		if (*pdnVersion != 0)
		{
			m_pdnObject->NameTable.SetVersion( *pdnVersion );
		}
		else
		{
			m_pdnObject->NameTable.GetNewVersion( pdnVersion );
		}
	}
};


void CGroupMember::SetGroupConnection( CGroupConnection *const pGroupConnection )
{
	if (pGroupConnection)
	{
		pGroupConnection->AddRef();
	}
	m_pGroupConnection = pGroupConnection;
}


HRESULT	CGroupMember::PackMembershipInfo(CPackedBuffer *const pPackedBuffer)
{
	HRESULT		hResultCode;
	DN_NAMETABLE_MEMBERSHIP_INFO	*pdnMembershipInfo;

	pdnMembershipInfo = static_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(pPackedBuffer->GetHeadAddress());
	if ((hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DN_NAMETABLE_MEMBERSHIP_INFO))) == DPN_OK)
	{
		pdnMembershipInfo->dpnidGroup = m_pGroup->GetDPNID();
		pdnMembershipInfo->dpnidPlayer = m_pPlayer->GetDPNID();
		pdnMembershipInfo->dwVersion = m_dwVersion;
		pdnMembershipInfo->dwVersionNotUsed = 0;
	}

	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\globals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Globals.cpp
 *  Content:    Definition of global variables.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	04/13/00	mjn		Added g_ProtocolVTBL
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//
//	Global Variables
//

#ifndef DPNBUILD_LIBINTERFACE
LONG	g_lCoreObjectCount = 0;
#endif // ! DPNBUILD_LIBINTERFACE


DN_PROTOCOL_INTERFACE_VTBL	g_ProtocolVTBL =
{
	DNPIIndicateEnumQuery,
	DNPIIndicateEnumResponse,
	DNPIIndicateConnect,
	DNPIIndicateDisconnect,
	DNPIIndicateConnectionTerminated,
	DNPIIndicateReceive,
	DNPICompleteListen,
	DNPICompleteListenTerminate,
	DNPICompleteEnumQuery,
	DNPICompleteEnumResponse,
	DNPICompleteConnect,
	DNPICompleteDisconnect,
	DNPICompleteSend,
	DNPIAddressInfoConnect,
	DNPIAddressInfoEnum,
	DNPIAddressInfoListen,
#ifndef DPNBUILD_NOMULTICAST
	DNPIIndicateReceiveUnknownSender,
	DNPICompleteMulticastConnect,
#endif	// DPNBUILD_NOMULTICAST
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\groupmem.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupMem.h
 *  Content:    Group Membership Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/03/00	mjn		Created
 *	08/05/99	mjn		Modified SetMembership to perform duplicate check and get NameTable version internally 
 *	09/17/99	mjn		Added GROUP_MEMBER_FLAG_NEED_TO_ADD,GROUP_MEMBER_FLAG_NEED_TO_REMOVE
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__GROUPMEM_H__
#define	__GROUPMEM_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	GROUP_MEMBER_FLAG_VALID				0x0001
#define	GROUP_MEMBER_FLAG_AVAILABLE			0x0002
#define	GROUP_MEMBER_FLAG_NEED_TO_ADD		0x0004
#define	GROUP_MEMBER_FLAG_NEED_TO_REMOVE	0x0008

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CPackedBuffer;
class CGroupConnection;
class CNameTableEntry;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//
//	Used to pass NameTable group membership
//
typedef struct _DN_NAMETABLE_MEMBERSHIP_INFO
{
	DPNID	dpnidPlayer;
	DPNID	dpnidGroup;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
} DN_NAMETABLE_MEMBERSHIP_INFO, *PDN_NAMETABLE_MEMBERSHIP_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Group Members

class CGroupMember
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CGroupMember* pGroupMember = (CGroupMember*)pvItem;

			pGroupMember->m_Sig[0] = 'G';
			pGroupMember->m_Sig[1] = 'M';
			pGroupMember->m_Sig[2] = 'E';
			pGroupMember->m_Sig[3] = 'M';

			if (!DNInitializeCriticalSection(&pGroupMember->m_cs))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&pGroupMember->m_cs,0);

			pGroupMember->m_bilinkPlayers.Initialize();
			pGroupMember->m_bilinkGroups.Initialize();

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CGroupMember* pGroupMember = (CGroupMember*)pvItem;

			pGroupMember->m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			pGroupMember->m_dwFlags = 0;
			pGroupMember->m_lRefCount = 1;
			pGroupMember->m_pGroup = NULL;
			pGroupMember->m_pPlayer = NULL;
			pGroupMember->m_pGroupConnection = NULL;

			DNASSERT(pGroupMember->m_bilinkPlayers.IsEmpty());
			DNASSERT(pGroupMember->m_bilinkGroups.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::FPMRelease"
	static void FPMRelease( void* pvItem )
		{
			const CGroupMember* pGroupMember = (CGroupMember*)pvItem;

			DNASSERT(pGroupMember->m_bilinkPlayers.IsEmpty());
			DNASSERT(pGroupMember->m_bilinkGroups.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::FPMDealloc"
	static void FPMDealloc( void* pvItem )
		{
			CGroupMember* pGroupMember = (CGroupMember*)pvItem;

			DNDeleteCriticalSection(&pGroupMember->m_cs);
		};

	void MakeValid( void )
		{
			m_dwFlags |= GROUP_MEMBER_FLAG_VALID;
		};

	void MakeInvalid( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_VALID);
		};

	BOOL IsValid( void ) const
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_VALID)
				return(TRUE);

			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::MakeAvailable"
	void MakeAvailable( void )
		{
			DNASSERT(m_pGroup != NULL);
			DNASSERT(m_pPlayer != NULL);

			m_dwFlags |= GROUP_MEMBER_FLAG_AVAILABLE;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::MakeUnavailable"
	void MakeUnavailable( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_AVAILABLE);
		};

	BOOL IsAvailable( void ) const
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_AVAILABLE)
				return(TRUE);

			return(FALSE);
		};

	void SetNeedToAdd( void )
		{
			m_dwFlags |= GROUP_MEMBER_FLAG_NEED_TO_ADD;
		};

	void ClearNeedToAdd( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_NEED_TO_ADD);
		};

	BOOL IsNeedToAdd( void ) const
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_NEED_TO_ADD)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetNeedToRemove( void )
		{
			m_dwFlags |= GROUP_MEMBER_FLAG_NEED_TO_REMOVE;
		};

	void ClearNeedToRemove( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_NEED_TO_REMOVE);
		};

	BOOL IsNeedToRemove( void ) const
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_NEED_TO_REMOVE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void AddRef( void )
		{
			DNInterlockedIncrement(&m_lRefCount);
		};

	void Release( void );

	void ReturnSelfToPool( void );

	void Lock( void )
		{
			DNEnterCriticalSection(&m_cs);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_cs);
		};

	void CGroupMember::RemoveMembership( DWORD *const pdnVersion );

	void SetVersion( const DWORD dwVersion )
		{
			m_dwVersion = dwVersion;
		};

	DWORD GetVersion( void ) const
		{
			return(m_dwVersion);
		};

	HRESULT CGroupMember::SetMembership(CNameTableEntry *const pGroup,
										CNameTableEntry *const pPlayer,
										DWORD *const pdwVersion);

	CNameTableEntry *GetGroup( void )
		{
			return(m_pGroup);
		};

	CNameTableEntry *GetPlayer( void )
		{
			return(m_pPlayer);
		};

	void SetGroupConnection( CGroupConnection *const pGroupConnection );

	CGroupConnection *GetGroupConnection( void )
		{
			return(m_pGroupConnection);
		};

	HRESULT	CGroupMember::PackMembershipInfo(CPackedBuffer *const pPackedBuffer);

	CBilink				m_bilinkPlayers;	// Players in this group
	CBilink				m_bilinkGroups;		// Groups this player belongs to

private:
	BYTE				m_Sig[4];
	DWORD				m_dwFlags;
	LONG				m_lRefCount;

	CNameTableEntry		*m_pPlayer;
	CNameTableEntry		*m_pGroup;
	CGroupConnection	*m_pGroupConnection;

	DWORD				m_dwVersion;
	DWORD				m_dwVersionNotUsed;

	DIRECTNETOBJECT		*m_pdnObject;

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	m_cs;
#endif // !DPNBUILD_ONLYONETHREAD
};

#undef DPF_MODNAME

#endif	// __GROUPMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\memoryfpm.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryFPM.cpp
 *  Content:	Memory Block FPM
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/31/00	mjn		Created
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// MemoryBlockAlloc
//
// Entry:		DWORD dwSize
//
// Exit:		PVOID		NULL or pointer to memory block
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "MemoryBlockAlloc"

PVOID MemoryBlockAlloc(void *const pvContext,
					   const DWORD dwSize )
{
	DIRECTNETOBJECT		*pdnObject;
	CMemoryBlockTiny	*pMBTiny;
	CMemoryBlockSmall	*pMBSmall;
	CMemoryBlockMedium	*pMBMedium;
	CMemoryBlockLarge	*pMBLarge;
	CMemoryBlockHuge	*pMBHuge;
	DN_MEMORY_BLOCK_HEADER	*pMBHeader;
	PVOID				pv;

	DPFX(DPFPREP, 8,"Parameters: pvContext [0x%p], dwSize [%ld]",pvContext,dwSize);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

	pv = NULL;
	if (dwSize <= DN_MEMORY_BLOCK_SIZE_TINY)
	{
		pMBTiny = (CMemoryBlockTiny*)g_MemoryBlockTinyPool.Get();
		DPFX(DPFPREP, 9,"Got TINY at [0x%p]",pMBTiny);
		if (pMBTiny != NULL)
			pv = pMBTiny->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_SMALL)
	{
		pMBSmall = (CMemoryBlockSmall*)g_MemoryBlockSmallPool.Get();
		DPFX(DPFPREP, 9,"Got SMALL at [0x%p]",pMBSmall);
		if (pMBSmall != NULL)
			pv = pMBSmall->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_MEDIUM)
	{
		pMBMedium = (CMemoryBlockMedium*)g_MemoryBlockMediumPool.Get();
		DPFX(DPFPREP, 9,"Got MEDIUM at [0x%p]",pMBMedium);
		if (pMBMedium != NULL)
			pv = pMBMedium->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_LARGE)
	{
		pMBLarge = (CMemoryBlockLarge*)g_MemoryBlockLargePool.Get();
		DPFX(DPFPREP, 9,"Got LARGE at [0x%p]",pMBLarge);
		if (pMBLarge != NULL)
			pv = pMBLarge->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_HUGE)
	{
		pMBHuge = (CMemoryBlockHuge*)g_MemoryBlockHugePool.Get();
		DPFX(DPFPREP, 9,"Got HUGE at [0x%p]",pMBHuge);
		if (pMBHuge != NULL)
			pv = pMBHuge->GetBuffer();
	}
	else
	{
		pMBHeader = static_cast<DN_MEMORY_BLOCK_HEADER*>(DNMalloc( dwSize + sizeof( DN_MEMORY_BLOCK_HEADER ) ));
		if (pMBHeader != NULL)
		{
			pMBHeader->dwSize = DN_MEMORY_BLOCK_SIZE_CUSTOM;
			pv = pMBHeader + 1;
		}
		DPFX(DPFPREP, 9,"malloc odd size at [0x%p]",pMBHeader);
	}

	DPFX(DPFPREP, 8,"Returning: [0x%p]",pv);
	return(pv);
}


//**********************************************************************
// ------------------------------
// MemoryBlockFree
//
// Entry:		PVOID	pvMemoryBlock
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "MemoryBlockFree"

void MemoryBlockFree(void *const pvContext,
					 void *const pvMemoryBlock)
{
	CMemoryBlockTiny	*pMBTiny;
	CMemoryBlockSmall	*pMBSmall;
	CMemoryBlockMedium	*pMBMedium;
	CMemoryBlockLarge	*pMBLarge;
	CMemoryBlockHuge	*pMBHuge;
	DN_MEMORY_BLOCK_HEADER	*pMBHeader;

	DPFX(DPFPREP, 8,"Parameters: pvContext [0x%p], pvMemoryBlock [0x%p]",
			pvContext,pvMemoryBlock);

	pMBTiny = CMemoryBlockTiny::GetObjectFromBuffer(pvMemoryBlock);
	if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_TINY)
	{
		pMBTiny->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_SMALL)
	{
		pMBSmall = reinterpret_cast<CMemoryBlockSmall*>(pMBTiny);
		pMBSmall->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_MEDIUM)
	{
		pMBMedium = reinterpret_cast<CMemoryBlockMedium*>(pMBTiny);
		pMBMedium->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_LARGE)
	{
		pMBLarge = reinterpret_cast<CMemoryBlockLarge*>(pMBTiny);
		pMBLarge->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_HUGE)
	{
		pMBHuge = reinterpret_cast<CMemoryBlockHuge*>(pMBTiny);
		pMBHuge->ReturnSelfToPool();
	}
	else
	{
		pMBHeader = reinterpret_cast<DN_MEMORY_BLOCK_HEADER*>(pMBTiny);
		DNFree(pMBHeader); 
	}

	DPFX(DPFPREP, 8,"Returning: (nothing)");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\memoryfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryFPM.h
 *  Content:	Memory Block FPM
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/31/00	mjn		Created
 ***************************************************************************/

#ifndef __MEMORYFPM_H__
#define __MEMORYFPM_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_MEMORY_BLOCK_SIZE_CUSTOM		0

#define	DN_MEMORY_BLOCK_SIZE_TINY		128
#define	DN_MEMORY_BLOCK_SIZE_SMALL		256
#define	DN_MEMORY_BLOCK_SIZE_MEDIUM		512
#define	DN_MEMORY_BLOCK_SIZE_LARGE		1024
#define	DN_MEMORY_BLOCK_SIZE_HUGE		2048

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DN_MEMORY_BLOCK_HEADER
{
	DWORD_PTR	dwSize; // Make this DWORD_PTR so it is aligned on 64-bit platforms
} DN_MEMORY_BLOCK_HEADER;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

PVOID MemoryBlockAlloc(void *const pvContext,const DWORD dwSize);
void MemoryBlockFree(void *const pvContext,void *const pvMemoryBlock);

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for TINY memory block

class CMemoryBlockTiny
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockTiny::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CMemoryBlockTiny* pMem = (CMemoryBlockTiny*)pvItem;

			pMem->m_dwSize = DN_MEMORY_BLOCK_SIZE_TINY;

			return(TRUE);
		};

	DWORD_PTR GetSize(void) const
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockTiny::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			g_MemoryBlockTinyPool.Release(this);
		};

	static CMemoryBlockTiny *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockTiny*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockTiny, m_pBuffer ) ] ) );
		};

private:
	DWORD_PTR	m_dwSize; // Make this DWORD_PTR so it is aligned on 64-bit platforms
	BYTE		m_pBuffer[DN_MEMORY_BLOCK_SIZE_TINY];
};


// class for SMALL memory block

class CMemoryBlockSmall
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockSmall::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CMemoryBlockSmall* pMem = (CMemoryBlockSmall*)pvItem;

			pMem->m_dwSize = DN_MEMORY_BLOCK_SIZE_SMALL;

			return(TRUE);
		};

	DWORD_PTR GetSize(void) const
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockSmall::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			g_MemoryBlockSmallPool.Release(this);
		};

	static CMemoryBlockSmall *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockSmall*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockSmall, m_pBuffer ) ] ) );
		};

private:
	DWORD_PTR	m_dwSize; // Make this DWORD_PTR so it is aligned on 64-bit platforms
	BYTE		m_pBuffer[DN_MEMORY_BLOCK_SIZE_SMALL];	
};


// class for MEDIUM memory block

class CMemoryBlockMedium
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockMedium::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CMemoryBlockMedium* pMem = (CMemoryBlockMedium*)pvItem;

			pMem->m_dwSize = DN_MEMORY_BLOCK_SIZE_MEDIUM;

			return(TRUE);
		};

	DWORD_PTR GetSize(void) const
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockMedium::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			g_MemoryBlockMediumPool.Release(this);
		};

	static CMemoryBlockMedium *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockMedium*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockMedium, m_pBuffer ) ] ) );
		};

private:
	DWORD_PTR	m_dwSize; // Make this DWORD_PTR so it is aligned on 64-bit platforms
	BYTE		m_pBuffer[DN_MEMORY_BLOCK_SIZE_MEDIUM];	
};


// class for LARGE memory block

class CMemoryBlockLarge
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockLarge::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CMemoryBlockLarge* pMem = (CMemoryBlockLarge*)pvItem;

			pMem->m_dwSize = DN_MEMORY_BLOCK_SIZE_LARGE;

			return(TRUE);
		};

	DWORD_PTR GetSize(void) const
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockLarge::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			g_MemoryBlockLargePool.Release(this);
		};

	static CMemoryBlockLarge *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockLarge*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockLarge, m_pBuffer ) ] ) );
		};

private:
	DWORD_PTR	m_dwSize; // Make this DWORD_PTR so it is aligned on 64-bit platforms
	BYTE		m_pBuffer[DN_MEMORY_BLOCK_SIZE_LARGE];	
};


// class for HUGE memory block

class CMemoryBlockHuge
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockHuge::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CMemoryBlockHuge* pMem = (CMemoryBlockHuge*)pvItem;

			pMem->m_dwSize = DN_MEMORY_BLOCK_SIZE_HUGE;

			return(TRUE);
		};

	DWORD_PTR GetSize(void) const
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockHuge::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			g_MemoryBlockHugePool.Release(this);
		};

	static CMemoryBlockHuge *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockHuge*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockHuge, m_pBuffer ) ] ) );
		};

private:
	DWORD_PTR	m_dwSize; // Make this DWORD_PTR so it is aligned on 64-bit platforms
	BYTE		m_pBuffer[DN_MEMORY_BLOCK_SIZE_HUGE];	
};


#undef DPF_MODNAME

#endif	// __MEMORYFPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\mcast.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcast.cpp
 *  Content:    DirectPlay8 Mcast interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	10/08/01	vanceo		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#ifndef DPNBUILD_NOMULTICAST

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

typedef	STDMETHODIMP McastQueryInterface(IDirectPlay8Multicast *pInterface, DP8REFIID riid, LPVOID *ppvObj);
typedef	STDMETHODIMP_(ULONG)	McastAddRef(IDirectPlay8Multicast *pInterface);
typedef	STDMETHODIMP_(ULONG)	McastRelease(IDirectPlay8Multicast *pInterface);
typedef	STDMETHODIMP McastInitialize(IDirectPlay8Multicast *pInterface, PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags);
typedef STDMETHODIMP McastJoin(IDirectPlay8Multicast *pInterface, IDirectPlay8Address *const pGroupAddr, IUnknown *const pDeviceInfo, const DPN_SECURITY_DESC *const pdnSecurity, const DPN_SECURITY_CREDENTIALS *const pdnCredentials, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef	STDMETHODIMP McastClose(IDirectPlay8Multicast *pInterface, const DWORD dwFlags);
typedef	STDMETHODIMP McastCreateSenderContext(IDirectPlay8Multicast *pInterface, IDirectPlay8Address *const pSenderAddress, void *const pvSenderContext, const DWORD dwFlags);
typedef	STDMETHODIMP McastDestroySenderContext(IDirectPlay8Multicast *pInterface, IDirectPlay8Address *const pSenderAddress, const DWORD dwFlags);
typedef	STDMETHODIMP McastSend(IDirectPlay8Multicast *pInterface, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef	STDMETHODIMP McastGetGroupAddress(IDirectPlay8Multicast *pInterface, IDirectPlay8Address **const ppAddress, const DWORD dwFlags);
typedef	STDMETHODIMP McastGetSendQueueInfo( IDirectPlay8Multicast *pInterface, DWORD *const lpdwNumMsgs, DWORD *const lpdwNumBytes, const DWORD dwFlags);
typedef	STDMETHODIMP McastCancelAsyncOperation( IDirectPlay8Multicast *pInterface, const DPNHANDLE hAsyncHandle, const DWORD dwFlags);
typedef STDMETHODIMP McastReturnBuffer( IDirectPlay8Multicast *pInterface, const DPNHANDLE hBufferHandle,const DWORD dwFlags);
typedef	STDMETHODIMP McastEnumServiceProviders( IDirectPlay8Multicast *pInterface, const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, DWORD *const pcbEnumData, DWORD *const pcReturned, const DWORD dwFlags);
typedef	STDMETHODIMP McastEnumMulticastScopes( IDirectPlay8Multicast *pInterface, const GUID *const pguidServiceProvider, const GUID *const pguidDevice, const GUID *const pguidApplication, DPN_MULTICAST_SCOPE_INFO *const pScopeInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags);
typedef STDMETHODIMP McastGetSPCaps(IDirectPlay8Multicast *pInterface, const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags);
typedef STDMETHODIMP McastSetSPCaps(IDirectPlay8Multicast *pInterface, const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags);


IDirectPlay8MulticastVtbl DNMcast_Vtbl =
{
	(McastQueryInterface*)			DN_QueryInterface,
	(McastAddRef*)					DN_AddRef,
	(McastRelease*)					DN_Release,
	(McastInitialize*)				DN_Initialize,
	(McastJoin*)					DN_Join,
	(McastClose*)					DN_Close,
	(McastCreateSenderContext*)		DN_CreateSenderContext,
	(McastDestroySenderContext*)	DN_DestroySenderContext,
	(McastSend*)					DN_Send,
	(McastGetGroupAddress*)			DN_GetGroupAddress,
	(McastGetSendQueueInfo*)		DN_GetHostSendQueueInfo,
	(McastCancelAsyncOperation*)	DN_CancelAsyncOperation,
	(McastReturnBuffer*)			DN_ReturnBuffer,
	(McastEnumServiceProviders*)	DN_EnumServiceProviders,
	(McastEnumMulticastScopes*)		DN_EnumMulticastScopes,
    (McastGetSPCaps*)                DN_GetSPCaps,
    (McastSetSPCaps*)                DN_SetSPCaps
};

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************



//
//	Completion for join connect parent
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteJoinOperation"

void DNCompleteJoinOperation(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp)
{
	CServiceProvider	*pSP;
	IDirectPlay8Address	*pIDevice;

	pSP = NULL;
	pIDevice = NULL;

	//
	//	Save the result code on the parent (if it exists - it will be the CONNECT handle)
	//
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->Lock();
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		pAsyncOp->GetParent()->Unlock();

		if (SUCCEEDED(pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle(), NULL )))
		{
			// Release the HandleTable reference
			pAsyncOp->GetParent()->Release();
		}
	}

	//
	//	Clear CONNECTING flag, and DISCONNECTING flag in case this was aborted.
	//	If the connect succeeded, set the CONNECTED flag.
	//
	DPFX(DPFPREP, 8,"Clearing CONNECTING and DISCONNECTING flags");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING | DN_OBJECT_FLAG_DISCONNECTING);
	if (pAsyncOp->GetResult() == DPN_OK)
	{
		pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
	}
	else
	{
		//
		//	Clean up DirectNet object
		//
		pSP = pdnObject->pConnectSP;
		pdnObject->pConnectSP = NULL;
		pIDevice = pdnObject->pIDP8ADevice;
		pdnObject->pIDP8ADevice = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pIDevice)
	{
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}

	DNASSERT( pSP == NULL );
	DNASSERT( pIDevice == NULL );
}


//
//	Completion for join handle parent
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteUserJoin"

void DNCompleteUserJoin(DIRECTNETOBJECT *const pdnObject,
						CAsyncOp *const pAsyncOp)
{
	DNUserJoinComplete(	pdnObject,
						pAsyncOp->GetHandle(),
						pAsyncOp->GetContext(),
						pAsyncOp->GetResult());
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Join"

STDMETHODIMP DN_Join( IDirectPlay8Multicast *pInterface,
						 IDirectPlay8Address *const pGroupAddr,
						 IUnknown *const pDeviceInfo,
						 const DPN_SECURITY_DESC *const pdnSecurity,
						 const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						 void *const pvAsyncContext,
						 DPNHANDLE *const phAsyncHandle,
						 const DWORD dwFlags)
{
	HRESULT						hResultCode;
	HRESULT volatile			hrOperation;
	DIRECTNETOBJECT				*pdnObject;
	IDirectPlay8Address			*pIGroup;
	IDirectPlay8Address			*pIDevice;
#ifndef DPNBUILD_ONLYONESP
	GUID						guidSP;
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
	GUID						guidAdapter;
#endif // ! DPNBUILD_ONLYONEADAPTER
	PVOID 						pvNewInterface;
	DWORD						dwListenFlags;
	CAsyncOp					*pListenParent;
	CAsyncOp					*pParent;
	CAsyncOp					*pAsyncOp;
	CAsyncOp					*pConnectParent;
	CAsyncOp					*pHandleParent;
	CServiceProvider			*pSP;
	CSyncEvent					*pSyncEvent;
	HANDLE						hEndpoint;
	SPGETADDRESSINFODATA		spInfoData;
	// Variables used when device interface is a DIRECTNETOBJECT
	DIRECTNETOBJECT				*pdnDeviceObject;
	CConnection					*pExistingConnection;
	CNameTableEntry				*pNTEntry;
	CServiceProvider			*pShareSP;
	IDP8ServiceProvider			*pShareDP8ServiceProvider;
	HANDLE						hEndPt;
	CCallbackThread				CallbackThread;
	CAsyncOp					*pShareListenParent;
	CBilink						*pBilink;
	CAsyncOp					*pShareParent;
	IDP8ServiceProvider			*pLocalDP8ServiceProvider;
	SPSHAREENDPOINTINFODATA		spShareData;


	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pGroupAddr [0x%p], pDeviceInfo [0x%p], pdnSecurity [0x%p], pdnCredentials [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
		pInterface,pGroupAddr,pDeviceInfo,pdnSecurity,pdnCredentials,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
    	if( FAILED( hResultCode = DN_ValidateJoin( pInterface, pGroupAddr, pDeviceInfo,
                                                      pdnSecurity, pdnCredentials,
                                                      pvAsyncContext,phAsyncHandle,dwFlags ) ) )
    	{
    	    DPFERR( "Error validating join params" );
    	    DPF_RETURN( hResultCode );
    	}
    }    	
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }

	// Check to ensure not already connected/connecting
    if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING)
    {
    	DPFERR( "Object is already connecting" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }
    if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
    {
    	DPFERR( "Object is already connected" );
    	DPF_RETURN(DPNERR_ALREADYCONNECTED);
    }
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
    	DPFERR( "Object is closing or disconnecting" );
    	DPF_RETURN(DPNERR_ALREADYCLOSING);
	}


	pIGroup = NULL;
	pIDevice = NULL;
	pvNewInterface = NULL;
	pListenParent = NULL;
	pParent = NULL;
	pConnectParent = NULL;
	pHandleParent = NULL;
	pSP = NULL;
	pSyncEvent = NULL;

	pdnDeviceObject = NULL;
	pExistingConnection = NULL;
	pNTEntry = NULL;
	pShareSP = NULL;
	pShareDP8ServiceProvider = NULL;
	CallbackThread.Deinitialize();
	pShareListenParent = NULL;
	pShareParent = NULL;
	pLocalDP8ServiceProvider = NULL;


	//
	//	Flag as CONNECTING to prevent other operations here
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTING | DN_OBJECT_FLAG_CONNECTED))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_ALREADYCONNECTED;
		goto Failure;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTING;

	// Adding local host flag
	//pdnObject->dwFlags |= DN_OBJECT_FLAG_LOCALHOST;
	
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);



	//
	//	Duplicate specified Group Address, or create a blank one if NULL
	//
	if (pGroupAddr != NULL)
	{
		if ((hResultCode = IDirectPlay8Address_Duplicate(pGroupAddr,&pIGroup)) != DPN_OK)
		{
			DPFERR("Could not duplicate group address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
#ifdef DPNBUILD_LIBINTERFACE
		hResultCode = DP8ACF_CreateInstance(IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pIGroup));
#else // ! DPNBUILD_LIBINTERFACE
		hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pIGroup),
											FALSE);
#endif // ! DPNBUILD_LIBINTERFACE
		if (hResultCode != S_OK)
		{
			DPFERR("Could not create Group Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}


	//
	//	Generate a Device Address from the DPlay interface, or duplicate
	//	the user's.  Start by finding out which type of interface it is.
	//
	if (((IDirectPlay8Peer_QueryInterface((IDirectPlay8Peer*) pDeviceInfo, IID_IDirectPlay8Peer, &pvNewInterface)) == S_OK) ||
#ifndef DPNBUILD_NOSERVER
		((IDirectPlay8Server_QueryInterface((IDirectPlay8Server*) pDeviceInfo, IID_IDirectPlay8Server, &pvNewInterface)) == S_OK) ||
#endif // ! DPNBUILD_NOSERVER
		((IDirectPlay8Client_QueryInterface((IDirectPlay8Client*) pDeviceInfo, IID_IDirectPlay8Client, &pvNewInterface)) == S_OK) ||
		((IDirectPlay8Multicast_QueryInterface((IDirectPlay8Multicast*) pDeviceInfo, IID_IDirectPlay8Multicast, &pvNewInterface)) == S_OK))
	{
		//
		//	It's a DIRECTNETOBJECT.
		//
		pdnDeviceObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pvNewInterface);

		DNEnterCriticalSection(&pdnDeviceObject->csDirectNetObject);
		if (! (pdnDeviceObject->dwFlags & DN_OBJECT_FLAG_CONNECTED))
		{
			DPFERR("DirectPlay device object is not connected or hosting" );
			DNLeaveCriticalSection(&pdnDeviceObject->csDirectNetObject);
			hResultCode = DPNERR_INVALIDDEVICEADDRESS;
			goto Failure;
		}
		DNLeaveCriticalSection(&pdnDeviceObject->csDirectNetObject);


		//
		//	Get the host player's connection (if not a multicast object).
		//
		if (! (pdnDeviceObject->dwFlags & DN_OBJECT_FLAG_MULTICAST))
		{
			if ((hResultCode = pdnDeviceObject->NameTable.GetHostPlayerRef(&pNTEntry)) != DPN_OK)
			{
				DPFERR("Could not find device object's Host player");
				DisplayDNError(0,hResultCode);
				hResultCode = DPNERR_INVALIDDEVICEADDRESS;
				goto Failure;
			}

			//
			//	If we're the host, then the name table entry won't have a valid
			//	connection object.
			//
			if (! pNTEntry->IsLocal())
			{
				hResultCode = pNTEntry->GetConnectionRef(&pExistingConnection);
				if (hResultCode != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Could not find device object's Host player (err = 0x%lx)!  Ignoring.",
						pdnDeviceObject, pExistingConnection);
					DNASSERT(pExistingConnection == NULL);
				}
			}

			pNTEntry->Release();
			pNTEntry = NULL;
		}

		//
		//	If we got a connection, simply extract its device address.
		//	If we couldn't get the non-local host player's connection, we
		//	have to select the device a different way.
		//
		if (pExistingConnection != NULL)
		{
			if ((hResultCode = pExistingConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
			{
				DPFERR( "Couldn't retrieve host player's endpoint" );
				DisplayDNError(0, hResultCode);
				goto Failure;
			}
			
			spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;

			//
			// Note that we are calling our Protocol object with the other
			// interface's endpoint.
			//
			hResultCode = DNPCrackEndPointDescriptor(pdnObject->pdnProtocolData, hEndPt,&spInfoData);
			if (hResultCode != DPN_OK)
			{
				DPFERR("Unknown error from DNPCrackEndPointDescriptor");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				pExistingConnection->ReleaseEndPt(&CallbackThread);
				goto Failure;
			}

			pIDevice = spInfoData.pAddress;
			spInfoData.pAddress = NULL;
			
			pExistingConnection->ReleaseEndPt(&CallbackThread);
	
			pShareSP = pExistingConnection->GetSP();
			if (pShareSP == NULL)
			{
				DPFERR("Could not get host player connection's SP!");
				DNASSERT(FALSE);
				hResultCode = DPNERR_INVALIDDEVICEADDRESS;
				goto Failure;
			}

			pExistingConnection->Release();
			pExistingConnection = NULL;
		}
		else
		{
			//
			//	Get the listen operation.
			//
			DNEnterCriticalSection(&pdnDeviceObject->csDirectNetObject);
			if (pdnDeviceObject->pListenParent == NULL)
			{
				DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
				DPFERR("Could not find device object's listen parent operation!");
				DNASSERT(FALSE);
				hResultCode = DPNERR_INVALIDDEVICEADDRESS;
				goto Failure;
			}
			pdnDeviceObject->pListenParent->AddRef();
			pShareListenParent = pdnDeviceObject->pListenParent;
			DNLeaveCriticalSection(&pdnDeviceObject->csDirectNetObject);

			//
			//	Get the first SP listen.
			//
			pShareListenParent->Lock();
			pBilink = pShareListenParent->m_bilinkParent.GetNext();
			if (pBilink == &pShareListenParent->m_bilinkParent)
			{
				DPFERR("Could not find device object's first listen operation!");
				DNASSERT(FALSE);
				hResultCode = DPNERR_INVALIDDEVICEADDRESS;
				goto Failure;
			}
			pShareParent = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
			pShareSP = pShareParent->GetSP();
			if (pShareSP == NULL)
			{
				DPFERR("Could not get first listen operation's SP!");
				DNASSERT(FALSE);
				hResultCode = DPNERR_INVALIDDEVICEADDRESS;
				goto Failure;
			}

			pShareSP->AddRef();

			pShareListenParent->Unlock();
			pShareListenParent->Release();
			pShareListenParent = NULL;


#ifndef DPNBUILD_ONLYONESP
			//
			//	Get the share SP's GUID.
			//
			pShareSP->GetGUID(&guidSP);
#endif // ! DPNBUILD_ONLYONESP

			//
			//	Build a device address object.
			//
#ifdef DPNBUILD_LIBINTERFACE
			hResultCode = DP8ACF_CreateInstance(IID_IDirectPlay8Address,
												reinterpret_cast<void**>(&pIDevice));
#else // ! DPNBUILD_LIBINTERFACE
			hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
												NULL,
												CLSCTX_INPROC_SERVER,
												IID_IDirectPlay8Address,
												reinterpret_cast<void**>(&pIDevice),
												FALSE);
#endif // ! DPNBUILD_LIBINTERFACE
			if (hResultCode != S_OK)
			{
				DPFERR("Could not create Device Address");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			
#ifndef DPNBUILD_ONLYONESP
			if ((hResultCode = IDirectPlay8Address_SetSP(pIDevice,&guidSP)) != DPN_OK)
			{
				DPFERR("Could not set SP on Device Address");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
#endif // ! DPNBUILD_ONLYONESP

#ifndef DPNBUILD_ONLYONEADAPTER
			//
			//	For multicast objects we can reuse the same device GUID, too,
			//	since we know there will be only one.
			//
			if (pdnDeviceObject->dwFlags & DN_OBJECT_FLAG_MULTICAST)
			{
				pShareParent->Lock();
				DNASSERT(! pShareParent->IsCancelled());
				DNASSERT(! pShareParent->m_bilinkParent.IsEmpty());
				pAsyncOp = CONTAINING_OBJECT(pParent->m_bilinkParent.GetNext(),CAsyncOp,m_bilinkChildren);
				pAsyncOp->Lock();
				DNASSERT((! pAsyncOp->IsCancelled()) && (! pAsyncOp->IsComplete()));
				DNASSERT(pAsyncOp->m_bilinkChildren.GetNext() == &pShareParent->m_bilinkParent);
				hEndpoint = pAsyncOp->GetProtocolHandle();
				pAsyncOp->Unlock();
				pShareParent->Unlock();

				spInfoData.hEndpoint = hEndpoint;
				spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
				//
				// Note that we are calling our Protocol object with the other
				// interface's endpoint.
				//
				if ((hResultCode = DNPGetListenAddressInfo(pdnObject->pdnProtocolData, spInfoData.hEndpoint,&spInfoData)) != DPN_OK)
				{
					DPFERR("Could not get LISTEN device address!");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}

				//
				// Retrieve the device GUID from the listen address.
				//
				if ((hResultCode = IDirectPlay8Address_GetDevice(spInfoData.pAddress, &guidAdapter)) != DPN_OK)
				{
					DPFERR("Could not get adapter GUID!");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					IDirectPlay8Address_Release(spInfoData.pAddress);
					spInfoData.pAddress = NULL;
					goto Failure;
				}

				IDirectPlay8Address_Release(spInfoData.pAddress);
				spInfoData.pAddress = NULL;

				//
				// Store the device GUID on our device address.
				//
				if ((hResultCode = IDirectPlay8Address_SetDevice(pIDevice, &guidAdapter)) != DPN_OK)
				{
					DPFERR("Could not set adapter GUID!");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
			}
#endif // ! DPNBUILD_ONLYONEADAPTER
		}


		//
		//	Get the share SP's COM interface.
		//
		if ((hResultCode = pShareSP->GetInterfaceRef(&pShareDP8ServiceProvider)) != DPN_OK)
		{
			DPFERR("Could not get shared SP interface");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pShareSP->Release();
		pShareSP = NULL;


		//
		//	Load our own local instance of that SP.
		//
		hResultCode = DN_SPEnsureLoaded(pdnObject,
#ifndef DPNBUILD_ONLYONESP
										&guidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
										NULL,
#endif // ! DPNBUILD_LIBINTERFACE
										&pSP);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not find or load SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}


		//
		//	Get the local SP's COM interface.
		//
		if ((hResultCode = pSP->GetInterfaceRef(&pLocalDP8ServiceProvider)) != DPN_OK)
		{
			DPFERR("Could not get local SP interface");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		
		//
		//	Tell our SP interface to get its endpoint information from the
		//	other interface's SP.
		//
		spShareData.pDP8ServiceProvider = pShareDP8ServiceProvider;
		spShareData.dwFlags = 0;
		hResultCode = IDP8ServiceProvider_ShareEndpointInfo(pLocalDP8ServiceProvider,
															&spShareData);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not have SPs share endpoint info");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		IDP8ServiceProvider_Release(pLocalDP8ServiceProvider);
		pLocalDP8ServiceProvider = NULL;
		IDP8ServiceProvider_Release(pShareDP8ServiceProvider);
		pShareDP8ServiceProvider = NULL;

		//
		// Release the ref we held on the device object.
		//
		IDirectPlay8Peer_Release((IDirectPlay8Peer*) pvNewInterface); // all core objects have Release in same location in Vtbl
		pvNewInterface = NULL;
	}
	else if ((IDirectPlay8Address_QueryInterface((IDirectPlay8Address*) pDeviceInfo, IID_IDirectPlay8Address, &pvNewInterface)) == S_OK)
	{
		//
		//	It's an address.
		//
		IDirectPlay8Address_Release((IDirectPlay8Address*) pvNewInterface);
		pvNewInterface = NULL;
			
		if ((hResultCode = IDirectPlay8Address_Duplicate(reinterpret_cast<IDirectPlay8Address*>(pDeviceInfo),&pIDevice)) != DPN_OK)
		{
			DPFERR("Could not duplicate device info");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		DPFERR( "Invalid device address, it must be an IDirectPlay8Peer, IDirectPlay8Server, IDirectPlay8Client, IDirectPlay8Multicast, or IDirectPlay8Address object" );
		return( DPNERR_INVALIDDEVICEADDRESS );
	}	

#ifndef DPNBUILD_ONLYONESP
	//
	//	If there is no SP on the group address, then steal it from the device address
	//
	if ((hResultCode = IDirectPlay8Address_GetSP(pIGroup,&guidSP)) != DPN_OK)
	{
		if ((hResultCode = IDirectPlay8Address_GetSP(pIDevice,&guidSP)) != DPN_OK)
		{
			DPFERR("Could not retrieve SP from Device Address");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		if ((hResultCode = IDirectPlay8Address_SetSP(pIGroup,&guidSP)) != DPN_OK)
		{
			DPFERR("Could not set SP on Group Address");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
#endif // ! DPNBUILD_ONLYONESP

	//
	//	Ensure SP is loaded, if we haven't already.
	//
	if (pSP == NULL)
	{
		hResultCode = DN_SPEnsureLoaded(pdnObject,
#ifndef DPNBUILD_ONLYONESP
										&guidSP,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
										NULL,
#endif // ! DPNBUILD_LIBINTERFACE
										&pSP);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not find or load SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

#ifndef DPNBUILD_ONLYONEADAPTER
	//
	//	Multicast listen device addresses are formed by taking the adapter GUID from
	//	the user's device address, combined with the entire user specified group address.
	//	If there is no adapter, then we will pick the best one as reported by the service
	//	provider (that part occurs inside DNPerformSPListen).
	//
	if ((hResultCode = IDirectPlay8Address_GetDevice(pIDevice,&guidAdapter)) == DPN_OK)
	{
		if ((hResultCode = IDirectPlay8Address_SetDevice(pIGroup,&guidAdapter)) != DPN_OK)
		{
			DPFERR("Could not set SP on Group Address");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
#endif // ! DPNBUILD_ONLYONEADAPTER


	dwListenFlags = DN_LISTENFLAGS_MULTICAST;
	if (dwFlags & DPNJOIN_ALLOWUNKNOWNSENDERS)
	{
		dwListenFlags |= DN_LISTENFLAGS_ALLOWUNKNOWNSENDERS;
	}

	//
	//	Start multicast listen
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pListenParent)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pListenParent->SetOpType( ASYNC_OP_LISTEN_MULTICAST );
	pListenParent->SetOpFlags( dwListenFlags );
	pListenParent->MakeParent();
	pListenParent->SetCompletion( DNCompleteListen );

	// See note above about why it's pIGroup instead of pIDevice.
	if ((hResultCode = DNPerformSPListen(pdnObject,pIGroup,pListenParent,&pParent)) != DPN_OK)
	{
		DPFERR("Could not start LISTEN");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pListenParent->AddRef();
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->pListenParent = pListenParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pListenParent->Release();
	pListenParent = NULL;


	//
	//	Multicast send endpoints are created using the user specified device address for the
	//	device, and what the SP reports it's using for the multicast listen as the group
	//	address.
	//
	
	pParent->Lock();
	DNASSERT(! pParent->IsCancelled());
	DNASSERT(! pParent->m_bilinkParent.IsEmpty());
	pAsyncOp = CONTAINING_OBJECT(pParent->m_bilinkParent.GetNext(),CAsyncOp,m_bilinkChildren);
	pAsyncOp->Lock();
	DNASSERT((! pAsyncOp->IsCancelled()) && (! pAsyncOp->IsComplete()));
	DNASSERT(pAsyncOp->m_bilinkChildren.GetNext() == &pParent->m_bilinkParent);
	hEndpoint = pAsyncOp->GetProtocolHandle();
	pAsyncOp->Unlock();
	pParent->Unlock();

	spInfoData.hEndpoint = hEndpoint;
	spInfoData.Flags = SP_GET_ADDRESS_INFO_MULTICAST_GROUP;
	if ((hResultCode = DNPGetListenAddressInfo(pdnObject->pdnProtocolData, spInfoData.hEndpoint,&spInfoData)) != DPN_OK)
	{
		DPFERR("Could not get LISTEN multicast group address!");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	// Release the old group address and save this new one.
	IDirectPlay8Address_Release(pIGroup);
	pIGroup = spInfoData.pAddress;
	spInfoData.pAddress = NULL;

	//
	// If the user did not specify an adapter GUID, we selected one and we need to
	// copy that selection over to the connect operation's device address.  If the user
	// did specify an adapter GUID, then this DNPGetListenAddressInfo will just be
	// echoing it back, so there's no harm in copying it in either case.
	//
	spInfoData.hEndpoint = hEndpoint;
	spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
	if ((hResultCode = DNPGetListenAddressInfo(pdnObject->pdnProtocolData, spInfoData.hEndpoint,&spInfoData)) != DPN_OK)
	{
		DPFERR("Could not get LISTEN device address!");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
#ifndef DPNBUILD_ONLYONEADAPTER
	if ((hResultCode = IDirectPlay8Address_GetDevice(spInfoData.pAddress,&guidAdapter)) != DPN_OK)
	{
		DPFERR("Could not get LISTEN device GUID!");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		IDirectPlay8Address_Release(spInfoData.pAddress);
		spInfoData.pAddress = NULL;
		goto Failure;
	}
	if ((hResultCode = IDirectPlay8Address_SetDevice(pIDevice,&guidAdapter)) != DPN_OK)
	{
		DPFERR("Could not set CONNECT device GUID!");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		IDirectPlay8Address_Release(spInfoData.pAddress);
		spInfoData.pAddress = NULL;
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONEADAPTER
	//
	//	Keep device address and connect SP on DirectNet object
	//
	pSP->AddRef();
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->pIDP8ADevice = spInfoData.pAddress;	// Transfering reference
	spInfoData.pAddress = NULL;
	pdnObject->pConnectSP = pSP;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pParent->Release();
	pParent = NULL;


	//
	//	Create parent async op, which will be released when the ENTIRE connection is finished
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pConnectParent)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pConnectParent->SetOpType( ASYNC_OP_CONNECT_MULTICAST_SEND );
	pConnectParent->MakeParent();
	pConnectParent->SetResult( DPNERR_NOCONNECTION );
	pConnectParent->SetCompletion( DNCompleteJoinOperation );
//	pConnectParent->SetReserved(1);

	if (dwFlags & DPNCONNECT_SYNC)
	{
		DPFX(DPFPREP, 5,"Sync operation - create sync event");
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not create synchronization event");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnectParent->SetSyncEvent( pSyncEvent );
		pConnectParent->SetResultPointer( &hrOperation );
	}
	else
	{
		DPFX(DPFPREP, 5,"Async operation - create handle parent");
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create handle parent");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pHandleParent->SetContext( pvAsyncContext );

		pHandleParent->Lock();
		if (pHandleParent->IsCancelled())
		{
			pHandleParent->Unlock();
			pConnectParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pConnectParent->MakeChild( pHandleParent );
		pHandleParent->Unlock();
	}

	hResultCode = DNPerformConnect(pdnObject,
									0,
									pIDevice,
									pIGroup,
									pSP,
									DN_CONNECTFLAGS_MULTICAST_SEND,
									pConnectParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not start CONNECT");
		goto Failure;
	}

	pConnectParent->Release();
	pConnectParent = NULL;

	pSP->Release();
	pSP = NULL;

	if (pIGroup)
	{
		IDirectPlay8Address_Release(pIGroup);
		pIGroup = NULL;
	}

	if (pIDevice)
	{
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}

	if (dwFlags & DPNCONNECT_SYNC)
	{
		if ((hResultCode = pSyncEvent->WaitForEvent()) != DPN_OK)
		{
			DPFERR("DNSyncEventWait() terminated bizarrely");
			DNASSERT(FALSE);
		}
		else
		{
			hResultCode = hrOperation;
		}
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	else
	{
		pHandleParent->SetCompletion( DNCompleteUserJoin );
		if (phAsyncHandle)
		{
			*phAsyncHandle = pHandleParent->GetHandle();
		}
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;
	}

Exit:

	CallbackThread.Deinitialize();
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:

	if (pIGroup)
	{
		IDirectPlay8Address_Release(pIGroup);
		pIGroup = NULL;
	}
	if (pIDevice)
	{
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}
	if (pExistingConnection != NULL)
	{
		pExistingConnection->Release();
		pExistingConnection = NULL;
	}
	if (pShareListenParent != NULL)
	{
		pShareListenParent->Unlock();
		pShareListenParent->Release();
		pShareListenParent = NULL;
	}
	if (pShareSP != NULL)
	{
		pShareSP->Release();
		pShareSP = NULL;
	}
	if (pShareDP8ServiceProvider != NULL)
	{
		IDP8ServiceProvider_Release(pShareDP8ServiceProvider);
		pShareDP8ServiceProvider = NULL;
	}
	if (pLocalDP8ServiceProvider != NULL)
	{
		IDP8ServiceProvider_Release(pLocalDP8ServiceProvider);
		pLocalDP8ServiceProvider = NULL;
	}
	if (pvNewInterface != NULL)
	{
		// Even if it's not an address, the Vtbl should be the same.
		IDirectPlay8Address_Release((IDirectPlay8Address*) pvNewInterface);
		pvNewInterface = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pListenParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pConnectParent)
	{
		if (SUCCEEDED(pdnObject->HandleTable.Destroy( pConnectParent->GetHandle(), NULL )))
		{
			// Release the HandleTable reference
			pConnectParent->Release();
		}
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pListenParent = pdnObject->pListenParent;
	pdnObject->pListenParent = NULL;
	pSP = pdnObject->pConnectSP;
	pdnObject->pConnectSP = NULL;
	pIDevice = pdnObject->pIDP8ADevice;
	pdnObject->pIDP8ADevice = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pListenParent)
	{
		DNCancelChildren(pdnObject,pListenParent);
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pIDevice)
	{
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_LOCALHOST);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	goto Exit;
} // DN_Join


//
//	Completion for create sender context
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteCreateSenderContext"

void DNCompleteCreateSenderContext(DIRECTNETOBJECT *const pdnObject,
								   CAsyncOp *const pAsyncOp)
{
}


//
// Associate a context value with a given multicast sender's address
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_CreateSenderContext"

STDMETHODIMP DN_CreateSenderContext( IDirectPlay8Multicast *pInterface,
									  IDirectPlay8Address *const pSenderAddress,
									  void *const pvSenderContext,
									  const DWORD dwFlags )
{
	HRESULT		        hResultCode;
	PDIRECTNETOBJECT    pdnObject;
	IDirectPlay8Address	*pIDevice;
	CServiceProvider	*pSP;
	CAsyncOp			*pConnectParent;
	CSyncEvent			*pSyncEvent;
	HRESULT				hrConnect;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pSenderAddress [0x%p], pvSenderContext [0x%p], dwFlags [0x%lx]",
		pInterface,pSenderAddress,pvSenderContext,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateCreateSenderContext( pInterface, pSenderAddress,
            												pvSenderContext, dwFlags ) ) )
        {
            DPFERR( "Error validating params" );
            DPF_RETURN(hResultCode);
        }
    }
#endif	// DPNBUILD_NOPARAMVAL

	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
	{
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN( DPNERR_UNINITIALIZED );
	}  

	pIDevice = NULL;
	pSP = NULL;
	pConnectParent = NULL;
	pSyncEvent = NULL;

#pragma BUGBUG( minara, "Need to ensure not closing" )
	//
	//	Extract device and SP from DirectNet object
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	DNASSERT( pdnObject->pConnectSP != NULL );
	DNASSERT( pdnObject->pIDP8ADevice != NULL );
	if (pdnObject->pConnectSP)
	{
		pdnObject->pConnectSP->AddRef();
		pSP = pdnObject->pConnectSP;
	}
	if (pdnObject->pIDP8ADevice)
	{
		IDirectPlay8Address_AddRef(pdnObject->pIDP8ADevice);
		pIDevice = pdnObject->pIDP8ADevice;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pSP == NULL || pIDevice == NULL)
	{
		DPFERR("Invalid connect SP or device address");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Create SyncEvent
	//
	if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not create SyncEvent");
		goto Failure;
	}

	//
	//	Create AsyncOp parent
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pConnectParent)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		goto Failure;
	}
	pConnectParent->SetOpType( ASYNC_OP_CONNECT_MULTICAST_RECEIVE );
	pConnectParent->SetSyncEvent( pSyncEvent );
	pConnectParent->SetResultPointer( &hrConnect );
	pConnectParent->SetContext( pvSenderContext );

	//
	//	We will call connect on the Protocol to associate the sender's endpoint with a context
	//	This call to connect must be turned into a synchronous operation since this API call is synchronous
	//
	if ((hResultCode = DNPerformConnect(pdnObject,
										0,
										pIDevice,
										pSenderAddress,
										pSP,
										DN_CONNECTFLAGS_MULTICAST_RECEIVE,
										pConnectParent)) != DPN_OK)
	{
		DPFERR("Failed to connect");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Release references and wait for completion
	//
	pConnectParent->SetCompletion( DNCompleteCreateSenderContext );
	pConnectParent->Release();
	pConnectParent = NULL;
	pSP->Release();
	pSP = NULL;
	IDirectPlay8Address_Release(pIDevice);
	pIDevice = NULL;

	pSyncEvent->WaitForEvent();
	pSyncEvent->ReturnSelfToPool();
	pSyncEvent = NULL;

	if (hrConnect == DPN_OK)
	{
		DNUserCreateSenderContext(pdnObject,pvSenderContext);
	}

	hResultCode = hrConnect;
	
Exit:
	DNASSERT( pIDevice == NULL );
	DNASSERT( pSP == NULL );
	DNASSERT( pConnectParent == NULL );
	DNASSERT( pSyncEvent == NULL );

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pIDevice)
	{
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
} // DN_CreateSenderContext


//
// Removes a previously associated context value from a given multicast sender's address
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_DestroySenderContext"

STDMETHODIMP DN_DestroySenderContext( IDirectPlay8Multicast *pInterface,
									  IDirectPlay8Address *const pSenderAddress,
									  const DWORD dwFlags )
{
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject;
	CServiceProvider	*pSP;
	CConnection			*pConnection;
	IDirectPlay8Address	*pDevice;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pSenderAddress [0x%p], dwFlags [0x%lx]",
		pInterface,pSenderAddress,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateDestroySenderContext( pInterface, pSenderAddress, dwFlags ) ) )
        {
            DPFERR( "Error validating params" );
            DPF_RETURN(hResultCode);
        }
    }
#endif	// DPNBUILD_NOPARAMVAL

	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
	{
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN( DPNERR_UNINITIALIZED );
	}  

	pSP = NULL;
	pConnection = NULL;

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pIDP8ADevice)
	{
		IDirectPlay8Address_AddRef(pdnObject->pIDP8ADevice);
		pDevice = pdnObject->pIDP8ADevice;
	}
	if (pdnObject->pConnectSP)
	{
		pdnObject->pConnectSP->AddRef();
		pSP = pdnObject->pConnectSP;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Get endpoint from address
	//
	if ((hResultCode = DNPGetEndPointContextFromAddress(pdnObject->pdnProtocolData, pSP->GetHandle(),pSenderAddress,pDevice,reinterpret_cast<void**>(&pConnection))) == DPN_OK)
	{
		pConnection->AddRef();

		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}

	//
	//	Clean up
	//
	IDirectPlay8Address_Release(pDevice);
	pDevice = NULL;

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

	DNASSERT( pSP == NULL );
	DNASSERT( pConnection == NULL );

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
} // DN_DestroySenderContext


//
// Retrieves the current multicast group address
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetGroupAddress"

STDMETHODIMP DN_GetGroupAddress(IDirectPlay8Multicast *pInterface,
							   IDirectPlay8Address **const ppAddress,
							   const DWORD dwFlags)
{
	HRESULT					hResultCode;
	DIRECTNETOBJECT			*pdnObject;
	CConnection				*pConnection;
	HANDLE					hEndPt;
	SPGETADDRESSINFODATA	spInfoData;
	CCallbackThread			CallbackThread;

	DPFX(DPFPREP, 2,"Parameters : pInterface [0x%p], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,ppAddress,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateGetGroupAddress( pInterface, ppAddress, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating get group address info hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    {
    	DPFERR("You must be connected / disconnecting to use this function" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	    	

	CallbackThread.Initialize();

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pMulticastSend != NULL)
	{
		pdnObject->pMulticastSend->AddRef();
		pConnection = pdnObject->pMulticastSend;
	}
	else
	{
		pConnection = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pConnection == NULL)
	{
	    DPFERR( "Couldn't retrieve multicast send connection" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}


	//
	//	Get the remote multicast address address
	//
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
	{
	    DPFERR( "Couldn't retrieve multicast send endpoint" );
	    DisplayDNError(0, hResultCode);
		goto Failure;
	}
	
	spInfoData.Flags = SP_GET_ADDRESS_INFO_MULTICAST_GROUP;

	hResultCode = DNPCrackEndPointDescriptor(pdnObject->pdnProtocolData, hEndPt,&spInfoData);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Unknown error from DNPCrackEndPointDescriptor");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);

		// Drop through...
	}
	
	pConnection->ReleaseEndPt(&CallbackThread);

	pConnection->Release();
	pConnection = NULL;

	*ppAddress = spInfoData.pAddress;
	spInfoData.pAddress = NULL;

Exit:
	CallbackThread.Deinitialize();
	DPF_RETURN(hResultCode);

Failure:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	goto Exit;
} // DN_GetGroupAddress

//
// Enumerate multicast scopes reported by SP
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumMulticastScopes"

STDMETHODIMP DN_EnumMulticastScopes( IDirectPlay8Multicast *pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidDevice,
									  const GUID *const pguidApplication,
									  DPN_MULTICAST_SCOPE_INFO *const pScopeInfoBuffer,
									  DWORD *const pcbEnumData,
									  DWORD *const pcReturned,
									  const DWORD dwFlags )
{
	HRESULT		        hResultCode;
	PDIRECTNETOBJECT    pdnObject;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pguidServiceProvider [0x%p], pguidDevice [0x%p], pguidApplication [0x%p], pScopeInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p], dwFlags [0x%lx]",
		pInterface,pguidServiceProvider,pguidDevice,pguidApplication,pScopeInfoBuffer,pcbEnumData,pcReturned,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateEnumMulticastScopes( pInterface, pguidServiceProvider, pguidDevice,
            													   pguidApplication, pScopeInfoBuffer,
                                                                   pcbEnumData, pcReturned, dwFlags ) ) )
        {
            DPFERR( "Error validating params" );
            DPF_RETURN(hResultCode);
        }
    }
#endif	// DPNBUILD_NOPARAMVAL

	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
	{
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN( DPNERR_UNINITIALIZED );
	}  

	hResultCode = DN_EnumMulticastScopes(pdnObject,
											dwFlags,
#ifndef DPNBUILD_ONLYONESP
											pguidServiceProvider,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
											pguidDevice,
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_LIBINTERFACE
											pguidApplication,
#endif // ! DPNBUILD_LIBINTERFACE
											pScopeInfoBuffer,
											pcbEnumData,
											pcReturned);
	

	DPFX(DPFPREP, 3,"Set: *pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
} // DN_EnumMulticastScopes


#endif // ! DPNBUILD_NOMULTICAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\migration.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Migration.cpp
 *  Content:    DNET Host Migration Routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/23/99	mjn		Created
 *	12/23/99	mjn		Fixed basic host migration
 *	12/28/99	mjn		Added DNCompleteOutstandingOperations
 *	12/28/99	mjn		Added NameTable version to Host migration message
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/11/00	mjn		Moved connect/disconnect stuff to Connect.h
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/17/00	mjn		Generate DN_MSGID_HOST_MIGRATE at host migration
 *	01/19/00	mjn		Auto destruct groups at host migration
 *	01/24/00	mjn		Use DNNTUpdateVersion to update NameTable version
 *	01/25/00	mjn		Send dwLatestVersion to Host at migration
 *	01/25/00	mjn		Changed Host Migration to multi-step affair
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/04/00	mjn		Clean up NameTable to remove old entries
 *  03/25/00    rmt     Added calls into DPNSVR modules
 *  04/04/00	rmt		Added check for DPNSVR disable flag before attempting to register w/DPNSVR
 *	04/16/00	mjn		DNSendMessage() used CAsyncOp
 *	04/18/00	mjn		CConnection tracks connection status better
 *				mjn		Fixed player count problem
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	04/25/00	mjn		Fixed migration process to ensure use of CAsyncOp
 *				mjn		Migration calls CoInitialize()/CoUninitialize() before registering w/ DPNSVR
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/04/00	mjn		Ensure local player still in session for Host migration
 *	05/16/00	mjn		Do not take locks when clearing NameTable short-cut pointers
 *	06/25/00	mjn		Ignore players older than old Host when determining new Host in DNFindNewHost()
 *	07/06/00	mjn		Fixed locking problem in CNameTable::MakeLocalPlayer,MakeHostPlayer,MakeAllPlayersGroup
 *	07/07/00	mjn		Added shut down checks to migration code.
 *	07/20/00	mjn		Cleaned up leaking RefCountBuffers and added closing tests
 *	07/21/00	mjn		Added code in DNCheckReceivedAllVersions() to skip disconnecting players
 *  07/27/00	rmt		Bug #40882 - DPLSESSION_HOSTMIGRATED status update is not sent
 *	07/31/00	mjn		Added dwDestroyReason to DNHostDisconnect()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added fInternal to DNPerformChildSend()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/07/00	mjn		Handle integrity check requests during host migration
 *	08/08/00	mjn		Moved DN_NAMETABLE_OP_INFO to Message.h
 *	08/11/00	mjn		Added DN_OBJECT_FLAG_HOST_MIGRATING_2 to prevent multiple threads from passing DNCheckReceivedAllVersions()
 *	08/15/00	mjn		Perform LISTEN registration with DPNSVR in PerformHostMigration3()
 *	08/24/00	mjn		Replace DN_NAMETABLE_OP with CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/06/00	mjn		Fixed register with DPNSVR problem
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	10/12/00	mjn		Ensure proper locks taken when traversing CNameTable::m_bilinkEntries
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	04/05/01	mjn		Added DPNID parameter to DNProcessHostMigration3() to ensure correct new host is completing host migration
 *	04/13/01	mjn		Use request list instead of async op list when retrying outstanding requests
 *	05/17/01	mjn		Wait for threads performing NameTable operations to finish before sending NameTable version during host migration
 *	07/22/01	mjn		Added DPNBUILD_NOHOSTMIGRATE compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#ifndef	DPNBUILD_NOHOSTMIGRATE


//	DNFindNewHost
//
//	Find the new host from the entries in the NameTable.
//	This is based on version number of the players in the NameTable.  The player with
//		the oldest version number (after the old Host) will be the new Host.
//
//	DPNID	*pdpnidNewHost		New Host DNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNFindNewHost"

HRESULT	DNFindNewHost(DIRECTNETOBJECT *const pdnObject,
					  DPNID *const pdpnidNewHost)
{
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pHostPlayer;
	HRESULT			hResultCode;
	DWORD			dwVersionNewHost;
	DWORD			dwVersionOldHost;
	DPNID			dpnidNewHost;

	DPFX(DPFPREP, 6,"Parameters: pdpnidNewHost [0x%p]",pdpnidNewHost);

	DNASSERT(pdnObject != NULL);

	pNTEntry = NULL;
	pLocalPlayer = NULL;
	pHostPlayer = NULL;

	//
	//	Seed local player as new Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	dpnidNewHost = pLocalPlayer->GetDPNID();
	dwVersionNewHost = pLocalPlayer->GetVersion();
	DPFX(DPFPREP, 7,"First Host Candidate: dpnid [0x%lx], dwVersion [%ld]",dpnidNewHost,dwVersionNewHost);
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Determine old host player version
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		dwVersionOldHost = pHostPlayer->GetVersion();
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		dwVersionOldHost = 0;
	}

	//
	//	Lock down NameTable
	//
	pdnObject->NameTable.ReadLock();

	// Traverse NameTable to find player with next older version
	//	TODO - we should release the NameTable CS so that leaving players get updated in NameTable
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetVersion() < dwVersionNewHost))
		{
			//
			//	There are some conditions where we might have players older than the Host in the NameTable
			//	Consider the following: P1,P2,P3,P4 (P1 is Host)
			//		- P1, P2 drop
			//		- P3 detects drop of P1 and P2
			//		- P4 detects drop of P1 only (P2 may not yet have timed out)
			//		- P3 sends HOST_MIGRATE message to P4
			//		- P4 makes P3 new Host, but P2 is still in NameTable (at this stage)
			//		- P3 drops (P2's drop sill has not been detected!)
			//	We should therefore ignore all players older than the old Host,
			//
			if (pNTEntry->GetVersion() < dwVersionOldHost)
			{
				DPFERR("Found player older than old Host ! (Have we missed a drop ?)");
			}
			else
			{
				dpnidNewHost = pNTEntry->GetDPNID();
				dwVersionNewHost = pNTEntry->GetVersion();
				DPFX(DPFPREP, 7,"Better Host Candidate: dpnid [0x%lx], dwVersion [%ld]",
						dpnidNewHost,dwVersionNewHost);
			}
		}
		pNTEntry->Unlock();
		pNTEntry = NULL;
		pBilink = pBilink->GetNext();
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	DPFX(DPFPREP, 7,"Found New Host: dpnid [0x%lx], dwVersion [%ld]",dpnidNewHost,dwVersionNewHost);

	if (pdpnidNewHost)
		*pdpnidNewHost = dpnidNewHost;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	goto Exit;
}


//	DNPerformHostMigration1
//
//	Perform host migration to become the new Host.

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformHostMigration1"

HRESULT	DNPerformHostMigration1(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidOldHost)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	CNameTableEntry		*pLocalPlayer;
	CPendingDeletion	*pPending;
	DN_INTERNAL_MESSAGE_HOST_MIGRATE	*pInfo;
	CBilink				*pBilink;
	CNameTableOp		*pNTOp;

	DPFX(DPFPREP, 6,"Parameters: dpnidOldHost [0x%lx]",dpnidOldHost);

	DNASSERT(pdnObject != NULL);

	pLocalPlayer = NULL;
	pRefCountBuffer = NULL;
	pPending = NULL;
	pWorkerJob = NULL;
	pNTOp = NULL;

	//
	//	Need reference on local player
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get reference on LocalPlayer");
		goto Failure;
	}

	//
	//	Flag as performing host migration - ensure we're not already running this from another thread
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING;
	DNASSERT(pdnObject->pNewHost == NULL);
	pLocalPlayer->AddRef();
	pdnObject->pNewHost = pLocalPlayer;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Put this on the Outstanding operation list
	//
	if ((hResultCode = PendingDeletionNew(pdnObject,&pPending)) == DPN_OK)
	{
		pPending->SetDPNID( dpnidOldHost );

		DNEnterCriticalSection(&pdnObject->csNameTableOpList);
		pPending->m_bilinkPendingDeletions.InsertBefore(&pdnObject->m_bilinkPendingDeletions);
		DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

		pPending = NULL;
	}
#ifndef DPNBUILD_NOLOBBY
	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATEDHERE);
#endif // ! DPNBUILD_NOLOBBY

	//
	//	Make new host
	//
	pdnObject->NameTable.UpdateHostPlayer( pLocalPlayer );

	//
	//	We will need to wait for all threads performing name table operations to finish running
	//	before we send the current name table version to the host player
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING_WAIT;
	if (pdnObject->dwRunningOpCount > 0)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFX(DPFPREP,7,"Waiting for running threads to finish");
		IDirectPlay8ThreadPoolWork_WaitWhileWorking(pdnObject->pIDPThreadPoolWork,
													HANDLE_FROM_DNHANDLE(pdnObject->hRunningOpEvent),
													0);
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	}
	else
	{
		DPFX(DPFPREP,7,"No running threads to wait for");
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Clean-up outstanding operations
	//
	DPFX(DPFPREP,7,"Cleaning up outstanding NameTable operations");
	pdnObject->NameTable.WriteLock();
	DPFX(DPFPREP,7,"NameTable version [%ld]",pdnObject->NameTable.GetVersion());
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		pBilink = pBilink->GetNext();
		if (pNTOp->GetVersion() > pdnObject->NameTable.GetVersion())
		{
			DPFX(DPFPREP,7,"Removing outstanding operation [0x%p], version [%ld]",pNTOp,pNTOp->GetVersion());
			pNTOp->m_bilinkNameTableOps.RemoveFromList();
			if (pNTOp->GetRefCountBuffer())
			{
				pNTOp->GetRefCountBuffer()->Release();
				pNTOp->SetRefCountBuffer( NULL );
			}
			if (pNTOp->GetSP())
			{
				pNTOp->GetSP()->Release();
				pNTOp->SetSP( NULL );
			}
			pNTOp->ReturnSelfToPool();
		}
		pNTOp = NULL;
	}
	pdnObject->NameTable.Unlock();

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_HOST_MIGRATING_WAIT);
	DNResetEvent(pdnObject->hRunningOpEvent);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Update NameTable operation list version
	//
	hResultCode = DNNTPlayerSendVersion(pdnObject);

	//
	//	Update protocol (and SP)
	DNUpdateListens(pdnObject,DN_UPDATE_LISTEN_FLAG_HOST_MIGRATE);

	// Only need to proceed if we're not the only player left in the session
	if ((hResultCode = DNCheckReceivedAllVersions(pdnObject)) != DPN_OK)
	{
		// Inform other players of host migration
		DPFX(DPFPREP, 7,"Informing other players of host migration");
		hResultCode = RefCountBufferNew(pdnObject,
										sizeof(DN_INTERNAL_MESSAGE_HOST_MIGRATE),
										MemoryBlockAlloc,
										MemoryBlockFree,
										&pRefCountBuffer);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not create RefCountBuffer for Host Migration");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_HOST_MIGRATE*>(pRefCountBuffer->GetBufferAddress());
		pInfo->dpnidNewHost = pLocalPlayer->GetDPNID();
		pInfo->dpnidOldHost = dpnidOldHost;

		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create WorkerJob for Host Migration");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_HOST_MIGRATE );
		pWorkerJob->SetSendNameTableOperationVersion( 0 );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pNTOp == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pPending)
	{
		pPending->ReturnSelfToPool();
		pPending = NULL;
	}
	goto Exit;
}


//	DNPerformHostMigration2
//
//	Resynchronize NameTables of all connected players

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformHostMigration2"

HRESULT	DNPerformHostMigration2(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CBilink			*pBilink;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pNTELatest;
	CConnection		*pConnection;
	DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	pRefCountBuffer = NULL;
	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pNTELatest = NULL;
	pConnection = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	See if we (Host player) have the latest NameTable
	//
	pLocalPlayer->AddRef();
	pNTELatest = pLocalPlayer;
	DPFX(DPFPREP, 7,"Seed latest version [%ld] - player [0x%lx]",pNTELatest->GetLatestVersion(),pNTELatest->GetDPNID());

	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() > pNTELatest->GetLatestVersion()))
		{
			//
			// Only want players we can actually reach !
			//
			pNTEntry->Unlock();
			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
			{
				if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
				{
					pNTELatest->Release();
					pNTEntry->AddRef();
					pNTELatest = pNTEntry;

					DPFX(DPFPREP, 7,"New latest version [%ld] - player [0x%lx]",
							pNTELatest->GetLatestVersion(),pNTELatest->GetDPNID());
				}
				pConnection->Release();
				pConnection = NULL;
			}
			else
			{
				DNASSERT(pConnection == NULL);
			}
		}
		else
		{
			pNTEntry->Unlock();
		}
		pNTEntry = NULL;

		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	if (!pNTELatest->IsLocal())
	{
		// Request missing entries from player w/ latest NameTable
		DPFX(DPFPREP, 7,"Host DOES NOT have latest NameTable !");
		DPFX(DPFPREP, 7,"Host has [%ld], player [0x%lx] has [%ld]",pLocalPlayer->GetLatestVersion(),
				pNTELatest->GetDPNID(),pNTELatest->GetLatestVersion());

		// Create REQ
		hResultCode = RefCountBufferNew(pdnObject,
										sizeof(DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP),
										MemoryBlockAlloc,
										MemoryBlockFree,
										&pRefCountBuffer);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not create RefCount buffer for NameTable re-sync");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP*>(pRefCountBuffer->GetBufferAddress());
		pInfo->dwVersion = pLocalPlayer->GetLatestVersion() + 1;
		pInfo->dwVersionNotUsed = 0;

		// Send REQ
		if ((hResultCode = pNTELatest->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			hResultCode = DNSendMessage(pdnObject,
										pConnection,
										DN_MSG_INTERNAL_REQ_NAMETABLE_OP,
										pNTELatest->GetDPNID(),
										pRefCountBuffer->BufferDescAddress(),
										1,
										pRefCountBuffer,
										0,
										DN_SENDFLAGS_RELIABLE,
										NULL,
										NULL);
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not send NameTable re-sync REQ");
				DisplayDNError(0,hResultCode);
				DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
				DNASSERT(FALSE);
				goto Failure;
			}
			pConnection->Release();
			pConnection = NULL;
		}

		pRefCountBuffer->Release();	// Added 19/07/00 MJN - is this needed ?
		pRefCountBuffer = NULL;
	}
	else
	{
		DPFX(DPFPREP, 7,"Host has latest NameTable - proceed with Host Migration");
		hResultCode = DNPerformHostMigration3(pdnObject,NULL);
	}

	pNTELatest->Release();
	pNTELatest = NULL;

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pNTELatest)
	{
		pNTELatest->Release();
		pNTELatest = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//	DNPerformHostMigration3
//
//	Finish host migration.
//		- perform missing NameTable operations and pass them on
//		- send pending operations
//		- inform players that host migration is complete
//		- complete (local) outstanding async operations
//		- initiate new listen (if required) to handle enums on known port
//	As they say on the TTC, "All operations have returned to normal."

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformHostMigration3"

HRESULT	DNPerformHostMigration3(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg)
{
	HRESULT				hResultCode;
	CBilink				*pBilink;
	CNameTableEntry		**PlayerList;
	CNameTableEntry		*pNTEntry;
	CConnection			*pConnection;
	CPendingDeletion	*pPending;
	DWORD				dwNameTableVersion;
	DWORD				dw;
	DWORD				dwCount;
	DWORD				dwActual;
	DWORD				dwUpdateFlags;
	CNameTableOp		*pNTOp;
	UNALIGNED DN_NAMETABLE_OP_INFO	*pInfo;
	UNALIGNED DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP	*pAck;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);

	pNTOp = NULL;
	pNTEntry = NULL;
	pConnection = NULL;
	pPending = NULL;
	PlayerList = NULL;

	//
	//	Update missing NameTable operations on Host
	//
	if (pMsg != NULL)
	{
		pAck = static_cast<DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP*>(pMsg);
		DPFX(DPFPREP, 7,"Number of missing NameTable entries [%ld]",pAck->dwNumEntries);
		pInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(pAck+1);
		for (dw = 0; dw < pAck->dwNumEntries ; dw++)
		{
			DPFX(DPFPREP, 7,"Adding missing entry [%ld] of [%ld]",dw+1,pAck->dwNumEntries);
			hResultCode = DNNTAddOperation(	pdnObject,
											pInfo->dwMsgId,
											static_cast<void*>(reinterpret_cast<BYTE*>(pMsg) + pInfo->dwOpOffset),
											pInfo->dwOpSize,
											0,
											NULL );
			if (hResultCode != DPN_OK)
			{
				DPFERR("Could not add missing NameTable operation - ignore and continue");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
			}
			pInfo++;
		}
	}

	//
	//	Update missing NameTable operations on other players
	//

	//
	//	Determine player list
	//
	dwCount = 0;
	dwActual = 0;
	pdnObject->NameTable.ReadLock();
	dwNameTableVersion = pdnObject->NameTable.GetVersion();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() < dwNameTableVersion))
		{
			dwCount++;
		}
		pNTEntry->Unlock();
		pNTEntry = NULL;

		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		if ((PlayerList = static_cast<CNameTableEntry**>(DNMalloc(dwCount * sizeof(CNameTableEntry*)))) == NULL)
		{
			DPFERR("Could not allocate target list");
			DNASSERT(FALSE);
			pdnObject->NameTable.Unlock();
			hResultCode = DPN_OK;
			goto Exit;
		}
		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->Lock();
			if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() < dwNameTableVersion))
			{
				DNASSERT(dwActual < dwCount);
				pNTEntry->AddRef();
				PlayerList[dwActual] = pNTEntry;
				dwActual++;
			}
			pNTEntry->Unlock();
			pNTEntry = NULL;

			pBilink = pBilink->GetNext();
		}
	}
	pdnObject->NameTable.Unlock();

	//
	//	Send missing entries to players in player list
	//
	for (dwCount = 0 ; dwCount < dwActual ; dwCount++)
	{
		//
		//	Ensure player is reachable
		//
		if ((hResultCode = PlayerList[dwCount]->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
			{
				DPFX(DPFPREP, 7,"Player [0x%lx] is missing entries: dwLatestVersion [%ld] should be [%ld]",
						PlayerList[dwCount]->GetDPNID(),PlayerList[dwCount]->GetLatestVersion(),dwNameTableVersion);

				// Send required entries
				for (	dw = PlayerList[dwCount]->GetLatestVersion() + 1 ; dw <= dwNameTableVersion ; dw++ )
				{
					DPFX(DPFPREP, 7,"Send entry [%ld] to player [0x%lx]",dw,PlayerList[dwCount]->GetDPNID());

					// Get entry to send
					pNTOp = NULL;
					if ((hResultCode = DNNTFindOperation(pdnObject,dw,&pNTOp)) != DPN_OK)
					{
						DPFERR("Could not retrieve NameTable operation - advance to next player");
						DisplayDNError(0,hResultCode);
						break;
					}

					hResultCode = DNSendMessage(pdnObject,
												pConnection,
												pNTOp->GetMsgId(),
												PlayerList[dwCount]->GetDPNID(),
												pNTOp->GetRefCountBuffer()->BufferDescAddress(),
												1,
												pNTOp->GetRefCountBuffer(),
												0,
												DN_SENDFLAGS_RELIABLE,
												NULL,
												NULL);
					if (hResultCode != DPNERR_PENDING)
					{
						DPFERR("Could not send missing NameTable entry - advance to next player");
						DisplayDNError(0,hResultCode);
						DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
						DNASSERT(FALSE);
						break;
					}
				} // for
			} // if
			pConnection->Release();
			pConnection = NULL;
		} // if
		PlayerList[dwCount]->Release();
		PlayerList[dwCount] = NULL;
	}
	if (PlayerList != NULL)
	{
		DNFree(PlayerList);
		PlayerList = NULL;
	}

	//
	//	Host finished migration process
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_HOST_MIGRATING | DN_OBJECT_FLAG_HOST_MIGRATING_2));
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Exit;
	}
	DNASSERT(pdnObject->pNewHost != NULL);	// This should be set !
	pdnObject->pNewHost->Release();
	pdnObject->pNewHost = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Cleanup NameTable
	//
	DPFX(DPFPREP, 7,"Cleaning up NameTable");
	hResultCode = DNCleanUpNameTable(pdnObject);

	//
	//	Send pending deletions
	//
	DPFX(DPFPREP, 7,"Running pending operations");
	DNEnterCriticalSection(&pdnObject->csNameTableOpList);
	pBilink = pdnObject->m_bilinkPendingDeletions.GetNext();
	while (pBilink != &pdnObject->m_bilinkPendingDeletions)
	{
		pPending = CONTAINING_OBJECT(pBilink,CPendingDeletion,m_bilinkPendingDeletions);

		pPending->m_bilinkPendingDeletions.RemoveFromList();

		DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

		DNHostDisconnect(pdnObject,pPending->GetDPNID(),DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);
		pPending->ReturnSelfToPool();
		pPending = NULL;

		DNEnterCriticalSection(&pdnObject->csNameTableOpList);
		pBilink = pdnObject->m_bilinkPendingDeletions.GetNext();
	}
	DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

	//
	//	Inform connected players that Host migration is complete
	//
	DPFX(DPFPREP, 7,"Sending HOST_MIGRATE_COMPLETE messages");
	hResultCode = DNSendHostMigrateCompleteMessage(pdnObject);

	//
	//	Ensure outstanding operations complete
	//
	DPFX(DPFPREP, 7,"Completing outstanding operations");
	hResultCode = DNCompleteOutstandingOperations(pdnObject);

	//
	//	Update listens
	//
	dwUpdateFlags = 0;
#ifndef DPNBUILD_SINGLEPROCESS
	if(pdnObject->ApplicationDesc.UseDPNSVR())
	{
		dwUpdateFlags |= DN_UPDATE_LISTEN_FLAG_DPNSVR;
	}
#endif // ! DPNBUILD_SINGLEPROCESS
	if (pdnObject->ApplicationDesc.DisallowEnums())
	{
		dwUpdateFlags |= DN_UPDATE_LISTEN_FLAG_DISALLOW_ENUMS;
	}
	if (dwUpdateFlags)
	{
		DNUpdateListens(pdnObject,dwUpdateFlags);
	}

	hResultCode = DPN_OK;

Exit:
	DNASSERT(pNTEntry == NULL);
	DNASSERT(pConnection == NULL);
	DNASSERT(pPending == NULL);
	DNASSERT(PlayerList == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNProcessHostMigration1
//
//	Perform an instructed host migration

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessHostMigration1"

HRESULT	DNProcessHostMigration1(DIRECTNETOBJECT *const pdnObject,
								void *const pvMsg)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	UNALIGNED DN_INTERNAL_MESSAGE_HOST_MIGRATE	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: pvMsg [0x%p]",pvMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvMsg != NULL);

	pNTEntry = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_HOST_MIGRATE*>(pvMsg);

	DPFX(DPFPREP, 7,"New Host [0x%lx], Old Host [0x%lx]",pInfo->dpnidNewHost,pInfo->dpnidOldHost);

	DNASSERT(pInfo->dpnidNewHost != NULL);
	DNASSERT(pInfo->dpnidOldHost != NULL);

	//
	//	Update destruction of old host as normal, and disconnect if possible
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnidOldHost,&pNTEntry)) == DPN_OK)
	{
		CConnection	*pConnection;

		pConnection = NULL;

		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
		}
		pNTEntry->Unlock();

		if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			if (pConnection->IsConnected())
			{
				pConnection->Disconnect();
			}
			pConnection->Release();
			pConnection = NULL;
		}

		pNTEntry->Release();
		pNTEntry = NULL;

		DNASSERT( pConnection == NULL );
	}

	//
	//	Get new host entry
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnidNewHost,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find new host NameTableEntry");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}

	//
	//	Set HOST_MIGRATE status on DirectNet object
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		//
		//	If we are already host migrating, ensure that this message
		//	is not from on older host than we expect.  If it is, we
		//	will ignore it, and continue
		//
		DNASSERT(pdnObject->pNewHost != NULL);
		if (pdnObject->pNewHost->GetVersion() > pNTEntry->GetVersion())
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hResultCode = DPN_OK;
			goto Failure;
		}
		pdnObject->pNewHost->Release();
		pdnObject->pNewHost = NULL;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING;
	DNASSERT( pdnObject->pNewHost == NULL );
	pNTEntry->AddRef();
	pdnObject->pNewHost = pNTEntry;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	// Delete old host
	pdnObject->NameTable.DeletePlayer(pInfo->dpnidOldHost,NULL);

#ifndef DPNBUILD_NOLOBBY
	// 
	// Indicate to lobby (if there is one) that a host migration has occured
	//
	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATED);
#endif // ! DPNBUILD_NOLOBBY

	//
	//	Make new host
	//
	pdnObject->NameTable.UpdateHostPlayer( pNTEntry );

	//
	//	We will need to wait for all threads performing name table operations to finish running
	//	before we send the current name table version to the host player
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING_WAIT;
	pdnObject->dwWaitingThreadID = GetCurrentThreadId();
	if (pdnObject->dwRunningOpCount > 0)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFX(DPFPREP,7,"Waiting for running threads to finish");
		IDirectPlay8ThreadPoolWork_WaitWhileWorking(pdnObject->pIDPThreadPoolWork,
													HANDLE_FROM_DNHANDLE(pdnObject->hRunningOpEvent),
													0);
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	}
	else
	{
		DPFX(DPFPREP,7,"No running threads to wait for");
	}
	if (pdnObject->dwWaitingThreadID == GetCurrentThreadId())
	{
		CBilink			*pBilink;
		CNameTableOp	*pNTOp;

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		//
		//	Clean-up outstanding operations
		//
		DPFX(DPFPREP,7,"Cleaning up outstanding NameTable operations");
		pdnObject->NameTable.WriteLock();
		DPFX(DPFPREP,7,"NameTable version [%ld]",pdnObject->NameTable.GetVersion());
		pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
		{
			pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
			pBilink = pBilink->GetNext();
			if (pNTOp->GetVersion() > pdnObject->NameTable.GetVersion())
			{
				DPFX(DPFPREP,7,"Removing outstanding operation [0x%p], version [%ld]",pNTOp,pNTOp->GetVersion());
				pNTOp->m_bilinkNameTableOps.RemoveFromList();
				if (pNTOp->GetRefCountBuffer())
				{
					pNTOp->GetRefCountBuffer()->Release();
					pNTOp->SetRefCountBuffer( NULL );
				}
				if (pNTOp->GetSP())
				{
					pNTOp->GetSP()->Release();
					pNTOp->SetSP( NULL );
				}
				pNTOp->ReturnSelfToPool();
			}
			pNTOp = NULL;
		}
		pdnObject->NameTable.Unlock();

		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_HOST_MIGRATING_WAIT);
		pdnObject->dwWaitingThreadID = 0;
		DNResetEvent(pdnObject->hRunningOpEvent);
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}
	else
	{
		//
		//	Don't continue because a newer host migration on another thread is now waiting
		//
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFX(DPFPREP,7,"Looks like a newer host migration is running - exiting");
		goto Failure;
	}

	//
	//	Send NameTable version to Host player
	//
	DNNTPlayerSendVersion(pdnObject);

	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNProcessHostMigration2
//
//	Send Host player NameTable entries missing from its (Host's) NameTable	

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessHostMigration2"

HRESULT	DNProcessHostMigration2(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg)
{
	HRESULT			hResultCode;
	DWORD			dwAckMsgSize;
	CBilink			*pBilink;
	CNameTableEntry	*pHostPlayer;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	CPackedBuffer	PackedBuffer;
	CNameTableOp	*pNTOp;
	DN_NAMETABLE_OP_INFO					*pInfo;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP	*pReq;
	DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP	*pAck;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	pHostPlayer = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	pReq = static_cast<DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP*>(pMsg);

	DPFX(DPFPREP, 5,"Host requested NameTable ops [%ld] to [%ld]",
			pReq->dwVersion,pdnObject->NameTable.GetVersion());

	//
	//	Determine ACK message size
	//
	pdnObject->NameTable.ReadLock();
	DNASSERT(pdnObject->NameTable.GetVersion() >= pReq->dwVersion);
	dwAckMsgSize = sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP);			// Number of entries
	dwAckMsgSize +=	((pdnObject->NameTable.GetVersion() - pReq->dwVersion + 1)	// Message info
			* sizeof(DN_NAMETABLE_OP_INFO));

	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if ((pNTOp->GetVersion() >= pReq->dwVersion) && (pNTOp->GetVersion() <= pdnObject->NameTable.GetVersion()))
		{
			DNASSERT(pNTOp->GetRefCountBuffer() != NULL);
			dwAckMsgSize += pNTOp->GetRefCountBuffer()->GetBufferSize();
		}
		pBilink = pBilink->GetNext();
	}

	//
	//	Create ACK buffer
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,dwAckMsgSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCount buffer for NameTable re-sync ACK");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		pdnObject->NameTable.Unlock();
		goto Failure;
	}
	PackedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pAck = reinterpret_cast<DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP *>(pRefCountBuffer->GetBufferAddress());

	// Header
	pAck->dwNumEntries = pdnObject->NameTable.GetVersion() - pReq->dwVersion + 1;
	PackedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP));

	// Offset list
	pInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(PackedBuffer.GetHeadAddress());
	PackedBuffer.AddToFront(NULL,pAck->dwNumEntries * sizeof(DN_NAMETABLE_OP_INFO));

	// Messages
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if ((pNTOp->GetVersion() >= pReq->dwVersion) && (pNTOp->GetVersion() <= pdnObject->NameTable.GetVersion()))
		{
			DNASSERT(pNTOp->GetRefCountBuffer() != NULL);
			if ((hResultCode = PackedBuffer.AddToBack(pNTOp->GetRefCountBuffer()->GetBufferAddress(),
					pNTOp->GetRefCountBuffer()->GetBufferSize())) != DPN_OK)
			{
				DPFERR("Could not fill NameTable re-sync ACK");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				pdnObject->NameTable.Unlock();
				goto Failure;
			}
			pInfo->dwMsgId = pNTOp->GetMsgId();
			pInfo->dwOpOffset = PackedBuffer.GetTailOffset();
			pInfo->dwOpSize = pNTOp->GetRefCountBuffer()->GetBufferSize();
			pInfo++;
		}
		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	// Send ACK buffer
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get Connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_ACK_NAMETABLE_OP,
								pHostPlayer->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send NameTable re-sync ACK");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		DNASSERT(FALSE);
		goto Failure;
	}

	pRefCountBuffer->Release();		// Added 19/07/00 MJN - Is this needed ?
	pRefCountBuffer = NULL;
	pConnection->Release();
	pConnection = NULL;
	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNProcessHostMigration3
//
//	

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessHostMigration3"

HRESULT	DNProcessHostMigration3(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnid)
{
	HRESULT		hResultCode;
	CNameTableEntry	*pNTEntry;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx]",dpnid);

	pNTEntry = NULL;

	// No longer in Host migration mode
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_HOST_MIGRATING);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Exit;
	}

	//
	//	If we receive a HOST_MIGRATION_COMPLETE, we need to ensure that it is for the current host migration,
	//	and that another one hasn't started after.
	//	If this is the correct new host (i.e. pdnObject->pNewHost != NULL and DPNID's match),
	//	then we will continue.  Otherwise, we will exit this function.
	//
	if (pdnObject->pNewHost)
	{
		if (pdnObject->pNewHost->GetDPNID() == dpnid)
		{
			pNTEntry = pdnObject->pNewHost;
			pdnObject->pNewHost = NULL;
		}
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;

		//
		//	Complete outstanding operations
		//
		DPFX(DPFPREP, 7,"Completing outstanding operations");
		hResultCode = DNCompleteOutstandingOperations(pdnObject);
	}
	else
	{
		DPFX(DPFPREP,7,"Host migration completed by wrong new host - ignore and continue");
	}

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pNTEntry == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCompleteOutstandingOperations
//
//	We will attempt to complete any outstanding asynchronous NameTable operations
//	(i.e. create/destroy group, add/delete player to/from group, update info).
//	If we are the Host player,
//		- try processing the request directly
//		- release the async op to generate completions
//	Otherwise
//		- resend the request to the Host

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteOutstandingOperations"

HRESULT DNCompleteOutstandingOperations(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CAsyncOp		*pAsyncOp;
	CAsyncOp		*pSend;
	CAsyncOp		**RequestList;
	CConnection		*pConnection;
	CNameTableEntry	*pHostPlayer;
	CNameTableEntry	*pLocalPlayer;
	DN_SEND_OP_DATA	*pSendOpData;
	DWORD			dwCount;
	DWORD			dwActual;

	DPFX(DPFPREP, 6,"Parameters: none");

	DNASSERT(pdnObject != NULL);

	pAsyncOp = NULL;
	pSend = NULL;
	RequestList = NULL;
	pConnection = NULL;
	pHostPlayer = NULL;
	pLocalPlayer = NULL;

	//
	//	Get Host connection
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not get host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get host connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	//
	//	Get local player
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	dwCount = 0;
	dwActual = 0;

	//
	//	Determine outstanding request list size and build it
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pBilink = pdnObject->m_bilinkRequestList.GetNext();
	while (pBilink != &pdnObject->m_bilinkRequestList)
	{
		dwCount++;
		pBilink = pBilink->GetNext();
	}
	if (dwCount > 0)
	{
		if ((RequestList = static_cast<CAsyncOp**>(MemoryBlockAlloc(pdnObject,dwCount * sizeof(CAsyncOp*)))) == NULL)
		{
			DNLeaveCriticalSection(&pdnObject->csActiveList);
			DPFERR("Could not allocate request list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		pBilink = pdnObject->m_bilinkRequestList.GetNext();
		while (pBilink != &pdnObject->m_bilinkRequestList)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
			DNASSERT(dwActual < dwCount);
			DNASSERT(pAsyncOp->GetOpType() == ASYNC_OP_REQUEST);
			pAsyncOp->AddRef();
			RequestList[dwActual] = pAsyncOp;
			pAsyncOp = NULL;
			dwActual++;
			pBilink = pBilink->GetNext();
		}
	}
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Perform outstanding requests
	//

	if (RequestList)
	{
		DWORD	dw;

		for ( dw = 0 ; dw < dwActual ; dw++ )
		{
			pSendOpData = RequestList[dw]->GetLocalSendOpData();
			if (	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_CREATE_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_DESTROY_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_UPDATE_INFO
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK)
			{
				DPFX(DPFPREP, 7,"Found outstanding operation: dwMsgId [0x%lx]",pSendOpData->dwMsgId);

				if (pLocalPlayer->IsHost())
				{
					//
					//	Remove request from request list
					//
					DNEnterCriticalSection(&pdnObject->csActiveList);
					RequestList[dw]->m_bilinkActiveList.RemoveFromList();
					DNLeaveCriticalSection(&pdnObject->csActiveList);

					hResultCode = DNHostProcessRequest(	pdnObject,
														pSendOpData->dwMsgId,
														pSendOpData->BufferDesc[1].pBufferData,
														pLocalPlayer->GetDPNID() );
				}
				else
				{
					//
					//	re-SEND REQUEST
					//
					hResultCode = DNPerformChildSend(	pdnObject,
														RequestList[dw],
														pConnection,
														0,
														&pSend,
														TRUE);
					if (hResultCode == DPNERR_PENDING)
					{
						//
						//	Reset SEND AsyncOp to complete apropriately.
						//
						pSend->SetCompletion( DNCompleteSendRequest );

						pSend->Release();
						pSend = NULL;
					}
				}
			}
			pSendOpData = NULL;
			RequestList[dw]->Release();
			RequestList[dw] = NULL;
		}
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;
	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (RequestList)
	{
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}
	goto Exit;
}


//	DNCheckReceivedAllVersions
//
//	Check to see if all players in the NameTable have returned their
//	NameTable versions.  If so, ensure the NameTables are re-sync'd and
//	then finish the Host migration

#undef DPF_MODNAME
#define DPF_MODNAME "DNCheckReceivedAllVersions"

HRESULT DNCheckReceivedAllVersions(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	BOOL			bNotReady;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	bNotReady = FALSE;
	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while ((pBilink != &pdnObject->NameTable.m_bilinkPlayers) && (!bNotReady))
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() == 0))
		{
			//
			//	Ensure that we are not including dropped/disconnected players who have yet to be processed
			//
			CConnection	*pConnection;

			pConnection = NULL;

			pNTEntry->Unlock();
			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
			{
				if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
				{
					DPFX(DPFPREP, 7,"Player [0x%lx] has not returned dwLatestVersion",pNTEntry->GetDPNID());
					bNotReady = TRUE;	// these must all be non-zero
				}
				pConnection->Release();
				pConnection = NULL;
			}
		}
		else
		{
			pNTEntry->Unlock();
		}
		pNTEntry = NULL;

		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	if (bNotReady)
	{
		DPFX(DPFPREP, 7,"All players have not responded");
		return(DPNERR_PENDING);
	}

	//
	//	Ensure only one thread runs this from here on out
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFX(DPFPREP, 7,"Another thread has already finished Host Migration - returning");
		hResultCode = DPN_OK;
		goto Exit;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING_2)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFX(DPFPREP, 7,"Another thread will proceed with Host Migration - returning");
		hResultCode = DPN_OK;
		goto Exit;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING_2;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	DPFX(DPFPREP, 7,"All players have responded - host migration stage 1 complete");
	hResultCode = DNPerformHostMigration2(pdnObject);

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCleanUpNameTable
//
//	Clean up the NameTable.
//	There are some cases where dropped players are not properly removed from the NameTable.
//		An example is when the Host-elect drops right after the Host before it has a chance
//		to send out a HOST_MIGRATE message.  In this case, since the HOST_MIGRATE message
//		implicitly includes the DELETE_PLAYER message for the original Host, the original
//		Host player never gets removed from current players' NameTables, though it DOES get
//		marked as DISCONNECTING.
//	Delete all DISCONNECTING players with older NameTable versions than ourselves.
//	Players with newer NameTable versions imply WE are the Host player, so we will
//		take care of them later (Pending Operations)

#undef DPF_MODNAME
#define DPF_MODNAME "DNCleanUpNameTable"

HRESULT DNCleanUpNameTable(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	DPNID			*List;
	DWORD			dwCount;
	DWORD			dwActual;
	DWORD			dw;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	List = NULL;

	//
	//	Create list of old player DPNID's
	//
	dwCount = 0;
	dwActual = 0;
	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (pNTEntry->IsDisconnecting() && (pNTEntry->GetVersion() < pdnObject->NameTable.GetLocalPlayer()->GetVersion()))
		{
			DPFX(DPFPREP, 7,"Found old player [0x%lx]",pNTEntry->GetDPNID());
			dwCount++;
		}
		pNTEntry->Unlock();

		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		if ((List = static_cast<DPNID*>(DNMalloc(dwCount * sizeof(DPNID*)))) != NULL)
		{
			pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
			while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
			{
				pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
				pNTEntry->Lock();
				if (pNTEntry->IsDisconnecting() && (pNTEntry->GetVersion() < pdnObject->NameTable.GetLocalPlayer()->GetVersion()))
				{
					DNASSERT(dwActual < dwCount);
					List[dwActual] = pNTEntry->GetDPNID();
					dwActual++;
				}
				pNTEntry->Unlock();

				pBilink = pBilink->GetNext();
			}
		}
	}
	pdnObject->NameTable.Unlock();

	//
	//	Remove old players
	//
	if (List)
	{
		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DPFX(DPFPREP, 7,"Removing old player [0x%lx]",List[dw]);
			DNHostDisconnect(pdnObject,List[dw],DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);
			List[dw] = 0;
		}

		DNFree(List);
		List = NULL;
	}

	hResultCode = DPN_OK;

	DNASSERT(List == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNSendHostMigrateCompleteMessage
//
//	Send a HOST_MIGRATE_COMPLETE message to connected players

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendHostMigrateCompleteMessage"

HRESULT	DNSendHostMigrateCompleteMessage(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CBilink		*pBilink;
	CNameTableEntry	*pNTEntry;
	CConnection	*pConnection;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	pParent = NULL;
	pNTEntry = NULL;
	pConnection = NULL;

	hResultCode = DNCreateSendParent(	pdnObject,
										DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE,
										NULL,
										0,
										DN_SENDFLAGS_RELIABLE,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Lock NameTable
	//
	pdnObject->NameTable.ReadLock();

	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		if (!pNTEntry->IsDisconnecting() && !pNTEntry->IsLocal())
		{
			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
			{
				hResultCode = DNPerformChildSend(	pdnObject,
													pParent,
													pConnection,
													0,
													NULL,
													TRUE);
				if (hResultCode != DPNERR_PENDING)
				{
					DPFERR("Could not perform part of group send - ignore and continue");
					DisplayDNError(0,hResultCode);
					DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
				}
				pConnection->Release();
				pConnection = NULL;
			}
		}

		pBilink = pBilink->GetNext();
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	pParent->Release();
	pParent = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
}


#endif // !DPNBUILD_NOHOSTMIGRATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\message.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Message.h
 *  Content:    DirectNet Internal Messages
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/14/00	mjn		Created
 *	01/20/00	mjn		Moved internal messages from DNCore.h
 *	01/24/00	mjn		Replaced on-wire message pointers to offsets
 *	01/24/00	mjn		Added messages for NameTable operation list clean-up
 *	01/25/00	mjn		Added DNSendHostMigrateCompleteMessage
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/15/00	mjn		Added dwInfoFlags to UPDATE_INFO messages
 *	04/04/00	mjn		Added DNSendTerminateSession() and structure
 *	04/05/00	mjn		Modified DN_INTERNAL_MESSAGE_DESTROY_PLAYER
 *	04/23/00	mjn		Removed DN_INTERNAL_MESSAGE_SEND_PROCESSED and DN_INTERNAL_MESSAGE_SEND_PROCESSED_COMPLETE
 *				mjn		Added DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION and DN_INTERNAL_MESSAGE_PROCESS_COMPLETION
 *	04/25/00	mjn		Removed hCompletionOp from group/info REQUESTs
 *	07/12/00	mjn		Moved internal messages back from DNCore.h
 *	07/20/00	mjn		Changed SEND_PLAYER_INFO to PLAYER_CONNECT_INFO
 *				mjn		Added DN_INTERNAL_MESSAGE_CONNECT_INFO structure
 *				mjn		Modified DN_INTERNAL_MESSAGE_CONNECT_FAILED structure
 *				mjn		Moved DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO and DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED from connect.h
 *				mjn		Added DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED, DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED
 *	07/31/00	mjn		DN_INTERNAL_MESSAGE_DESTROY_PLAYER renamed to  DN_INTERNAL_MESSAGE_HOST_DESTROY_PLAYER
 *				mjn		DN_INTERNAL_MESSAGE_DELETE_PLAYER renamed to DN_INTERNAL_MESSAGE_DESTROY_PLAYER
 *				mjn		Added dwDestroyReason to DN_INTERNAL_MESSAGE_DESTROY_PLAYER
 *				mjn		Removed DN_MSG_INTERNAL_HOST_DESTROY_PLAYER and DN_INTERNAL_MESSAGE_HOST_DESTROY_PLAYER structure
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *	08/07/00	mjn		Added structures for peer-peer session integrity checking
 *	08/08/00	mjn		Moved DN_NAMETABLE_OP_INFO from Migration.cpp
 *	08/25/00	mjn		Added NameTable version to DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__MESSAGE_H__
#define	__MESSAGE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_MSG_INTERNAL									0xc0
#define DN_MSG_INTERNAL_PLAYER_CONNECT_INFO				(0x01 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_SEND_CONNECT_INFO				(0x02 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ACK_CONNECT_INFO				(0x03 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_SEND_PLAYER_DNID				(0x04 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_CONNECT_FAILED					(0x05 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INSTRUCT_CONNECT				(0x06 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED		(0x07 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED			(0x08 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_NAMETABLE_VERSION				(0x09 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_RESYNC_VERSION					(0x0a | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_NAMETABLE_OP				(0x0b | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ACK_NAMETABLE_OP				(0x0c | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_HOST_MIGRATE					(0x0d | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE			(0x0e | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC			(0x0f | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ADD_PLAYER						(0x10 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_DESTROY_PLAYER					(0x11 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_CREATE_GROUP				(0x12 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP			(0x13 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP	(0x14 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_DESTROY_GROUP				(0x15 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_REQ_UPDATE_INFO					(0x16 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_CREATE_GROUP					(0x17 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_DESTROY_GROUP					(0x18 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP				(0x19 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP		(0x1a | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_UPDATE_INFO						(0x1b | DN_MSG_INTERNAL)

#ifndef DPNBUILD_NOVOICE
#define	DN_MSG_INTERNAL_VOICE_SEND						(0x1c | DN_MSG_INTERNAL)
#endif // DPNBUILD_NOVOICE

#define	DN_MSG_INTERNAL_BUFFER_IN_USE					(0x1d | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQUEST_FAILED					(0x1e | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_TERMINATE_SESSION				(0x1f | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION			(0x20 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_PROCESS_COMPLETION				(0x21 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK				(0x22 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INTEGRITY_CHECK					(0x23 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE		(0x24 | DN_MSG_INTERNAL)

#define	DN_MSG_USER_SEND					0x02

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO {
	DWORD	dwFlags;
	DWORD	dwDNETVersion;
	DWORD	dwNameOffset;
	DWORD	dwNameSize;
	DWORD	dwDataOffset;
	DWORD	dwDataSize;
	DWORD	dwPasswordOffset;
	DWORD	dwPasswordSize;
	DWORD	dwConnectDataOffset;
	DWORD	dwConnectDataSize;
	DWORD	dwURLOffset;
	DWORD	dwURLSize;
	GUID	guidInstance;
	GUID	guidApplication;
} DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO, *PDN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO;


typedef struct _DN_INTERNAL_MESSAGE_CONNECT_INFO {
	DWORD	dwReplyOffset;
	DWORD	dwReplySize;
} DN_INTERNAL_MESSAGE_CONNECT_INFO, *PDN_INTERNAL_MESSAGE_CONNECT_INFO;


typedef struct _DN_INTERNAL_MESSAGE_CONNECT_FAILED {
	HRESULT	hResultCode;
	DWORD	dwReplyOffset;
	DWORD	dwReplySize;
} DN_INTERNAL_MESSAGE_CONNECT_FAILED, *PDN_INTERNAL_MESSAGE_CONNECT_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT {
	DPNID	dpnid;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT, *PDN_INTERNAL_MESSAGE_INSTRUCT_CONNECT;


typedef struct _DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED {
	DPNID	dpnid;
} DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED {
	DPNID	dpnid;
} DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_REQUEST_FAILED {
	DPNHANDLE	hCompletionOp;
	HRESULT		hResultCode;
} DN_INTERNAL_MESSAGE_REQUEST_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID {
	DPNID	dpnid;
} DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID, *PDN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID;


typedef struct _DN_INTERNAL_MESSAGE_DESTROY_PLAYER {
	DPNID	dpnidLeaving;		// DPNID of leaving player
	DWORD	dwVersion;			// Name table version of this operation
	DWORD	dwVersionNotUsed;
	DWORD	dwDestroyReason;
} DN_INTERNAL_MESSAGE_DESTROY_PLAYER, *PDN_INTERNAL_MESSAGE_DESTROY_PLAYER;


typedef struct _DN_INTERNAL_MESSAGE_CREATE_GROUP {
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_CREATE_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_DESTROY_GROUP {
	DPNID		dpnidGroup;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_DESTROY_GROUP;

typedef struct _DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP, *PDN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP, *PDN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_UPDATE_INFO {
	DPNID		dpnid;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DWORD		dwInfoFlags;
	DWORD		dwNameOffset;
	DWORD		dwNameSize;
	DWORD		dwDataOffset;
	DWORD		dwDataSize;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_UPDATE_INFO, *PDN_INTERNAL_MESSAGE_UPDATE_INFO;


typedef struct _DN_INTERNAL_MESSAGE_HOST_MIGRATE {
	DPNID		dpnidOldHost;
	DPNID		dpnidNewHost;
} DN_INTERNAL_MESSAGE_HOST_MIGRATE, *PDN_INTERNAL_MESSAGE_HOST_MIGRATE;


typedef struct _DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP {
	DWORD		dwGroupFlags;
	DWORD		dwInfoFlags;
	DWORD		dwNameOffset;
	DWORD		dwNameSize;
	DWORD		dwDataOffset;
	DWORD		dwDataSize;
} DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP, *PDN_INTERNAL_MESSAGE_REQ_CREATE_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP {
	DPNID		dpnidGroup;
} DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP, *PDN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
} DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP, *PDN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
} DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP, *PDN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO {
	DPNID		dpnid;
	DWORD		dwInfoFlags;
	DWORD		dwNameOffset;
	DWORD		dwNameSize;
	DWORD		dwDataOffset;
	DWORD		dwDataSize;
} DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO, *PDN_INTERNAL_MESSAGE_REQ_UPDATE_INFO;

typedef struct _DN_INTERNAL_MESSAGE_NAMETABLE_VERSION {
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_NAMETABLE_VERSION, *PDN_INTERNAL_MESSAGE_NAMETABLE_VERSION;


typedef struct _DN_INTERNAL_MESSAGE_RESYNC_VERSION {
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_RESYNC_VERSION, *PDN_INTERNAL_MESSAGE_RESYNC_VERSION;


typedef struct _DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP {
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP, *PDN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP;


typedef struct _DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP {
	DWORD		dwNumEntries;
} DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP, *PDN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION {
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION;


typedef struct _DN_INTERNAL_MESSAGE_PROCESS_COMPLETION {
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_PROCESS_COMPLETION;


typedef struct _DN_INTERNAL_MESSAGE_TERMINATE_SESSION {
	DWORD		dwTerminateDataOffset;
	DWORD		dwTerminateDataSize;
} DN_INTERNAL_MESSAGE_TERMINATE_SESSION, *PDN_INTERNAL_MESSAGE_TERMINATE_SESSION;


typedef struct _DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK {
	DPNID		dpnidTarget;
} DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK;


typedef struct _DN_INTERNAL_MESSAGE_INTEGRITY_CHECK {
	DPNID		dpnidRequesting;
} DN_INTERNAL_MESSAGE_INTEGRITY_CHECK;


typedef struct _DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE {
	DPNID		dpnidRequesting;
} DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE;


typedef struct _DN_NAMETABLE_OP_INFO {
	DWORD	dwMsgId;
	DWORD	dwOpOffset;
	DWORD	dwOpSize;
} DN_NAMETABLE_OP_INFO, *PDN_NAMETABLE_OP_INFO;


// DN_APPLICATION_DESC_INFO - used to pack / send info
//		Force byte alignment as this may go out on the wire
#pragma pack( push, 1 )

typedef	struct DPN_APPLICATION_DESC_INFO {
	DWORD	dwSize;
	DWORD	dwFlags;
	DWORD	dwMaxPlayers;
	DWORD	dwCurrentPlayers;
	DWORD	dwSessionNameOffset;
	DWORD	dwSessionNameSize;
	DWORD	dwPasswordOffset;
	DWORD	dwPasswordSize;
	DWORD	dwReservedDataOffset;
	DWORD	dwReservedDataSize;
	DWORD	dwApplicationReservedDataOffset;
	DWORD	dwApplicationReservedDataSize;
	GUID	guidInstance;
	GUID	guidApplication;
} DPN_APPLICATION_DESC_INFO;
#pragma pack( pop )


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __MESSAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\nametable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NameTable.cpp
 *  Content:    NameTable Object
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/11/00	mjn		Created
 *	04/09/00	mjn		Track outstanding connections in NameTable
 *	04/18/00	mjn		CConnection tracks connection status better
 *	04/19/00	mjn		PopulateConnection makes the ALL_PLAYERS link valid before posting ADD_PLAYER
 *	05/03/00	mjn		Implemented GetHostPlayerRef, GetLocalPlayerRef, GetAllPlayersGroupRef
 *	05/08/00	mjn		PopulateConnection() only sets the player's connection if it was previously NULL
 *	05/10/00	mjn		Release NameTableEntry lock during notifications in PopulateConnection()
 *	05/16/00	mjn		Ensure dpnidGroup is actually a group in IsMember()
 *				mjn		Better use of locks when clearing short-cut pointers
 *	05/25/00	mjn		Fixed infinite loop in UpdateTable()
 *	06/01/00	mjn		Added code to validate NameTable array
 *	06/02/00	mjn		Fixed logic in GrowNameTable() to handle case of existing free entries
 *	06/07/00	mjn		Fixed logic in UpdateTable() to adjust m_dwLastFreeEntry correctly
 *	06/22/00	mjn		UnpackNameTableInfo() returns local players DPNID
 *	06/29/00	mjn		64-bit build fixes (2)
 *	07/06/00	mjn		Fixed locking problem in CNameTable::MakeLocalPlayer,MakeHostPlayer,MakeAllPlayersGroup
 *	07/07/00	mjn		Fixed validation error in FindEntry()
 *	07/20/00	mjn		Cleaned up CConnection refcounts and added attempted disconnects
 *				mjn		Added ClearHostWithDPNID()
 *	07/21/00	mjn		Fixed DeletePlayer() to properly handle deleted unconnected players
 *	07/26/00	mjn		Moved initialization code from contructor to Initialize()
 *				mjn		Allow DPNID=0 for FindEntry(), but return DPNERR_DOESNOTEXIST
 *	07/30/00	mjn		Set reason codes for destroying players and groups
 *				mjn		Added hrReason to CNameTable::EmptyTable() and extended clean-up to include short-cut pointers
 *	08/02/00	mjn		Dequeue queued messages when propagating CREATE_PLAYER message
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *				mjn		AddPlayerToGroup() does a duplicate check
 *	08/07/00	mjn		Wait until player to be  added to groups before reducing outstanding connections in PopulateConnection()
 *	08/15/00	mjn		Keep group on CGroupConnection objects
 *				mjn		Clear pGroupConnection from CGroupMembership when removing players from groups
 *	08/23/00	mjn		Added CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/05/00	mjn		Added m_dpnidMask
 *				mjn		Removed dwIndex from InsertEntry()
 *	09/06/00	mjn		Remove queued messages in EmptyTable() and DeletePlayer()
 *	09/14/00	mjn		Added missing pGroupMember->AddRef() in PopulateConnection()
 *	09/17/00	mjn		Split m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *				mjn		Changed AddPlayerToGroup and RemovePlayerFromGroup to use NameTableEntry params
 *	09/26/00	mjn		Assume NameTable locks are taken for AddMembership() and RemoveMembership()
 *				mjn		Attempt to disconnect client from Host in EmptyTable()
 *	09/28/00	mjn		Autodestruct groups in DeletePlayer()
 *	10/18/00	mjn		Reset m_lOutstandingConnections in UnpackNameTableInfo()
 *	01/11/00	mjn		Proper clean up for indicated but not created players in DeletePlayer()
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking NameTable
 *	06/02/01	mjn		Remove receive buffers from active list in EmptyTable()
 *	06/03/01	mjn		Complete and orphan connect parent before releasing in DecOutstandingConnections()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::Initialize"

HRESULT CNameTable::Initialize(DIRECTNETOBJECT *const pdnObject)
{
	m_dwVersion = 1;

	m_bilinkPlayers.Initialize();
	m_bilinkGroups.Initialize();
	m_bilinkDeleted.Initialize();
	m_bilinkNameTableOps.Initialize();

	// NOTE: It is important that we call Initialize even if we are going to fail in this
	// function.  In other words, don't put anything above this that fails, or you will
	// break CReadWriteLock::Deinitialize.
	if (!m_RWLock.Initialize())
	{
		return(DPNERR_OUTOFMEMORY);
	}

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	//
	// (Pre)allocate a name table entry.
	//
	if (g_NameTableEntryPool.Preallocate(1, pdnObject) < 1)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate default player name table entry!");
		return(DPNERR_OUTOFMEMORY);
	}

	NameTableEntryNew(pdnObject,&m_pDefaultPlayer);
	DNASSERT(m_pDefaultPlayer != NULL);
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (NameTableEntryNew(pdnObject,&m_pDefaultPlayer) != DPN_OK)
	{
		return(DPNERR_OUTOFMEMORY);
	}
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

	DNASSERT(m_pdnObject == NULL);
	m_pdnObject = pdnObject;

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::Deinitialize"

void CNameTable::Deinitialize( void )
{
	if (m_NameTableArray)
	{
#ifdef DBG
		ValidateArray();
#endif // DBG

		DNFree(m_NameTableArray);
		m_NameTableArray = NULL;
	}

	// Calling this is safe as long as CReadWriteLock::Initialize was called, regardless of
	// whether or not it succeeded.
	m_RWLock.Deinitialize();

	m_pDefaultPlayer->Release();
	m_pDefaultPlayer = NULL;

	DNASSERT(m_bilinkPlayers.IsEmpty());
	DNASSERT(m_bilinkGroups.IsEmpty());
	DNASSERT(m_bilinkDeleted.IsEmpty());
	DNASSERT(m_bilinkNameTableOps.IsEmpty());

	DNASSERT(m_pDefaultPlayer == NULL);
	DNASSERT(m_pLocalPlayer == NULL);
	DNASSERT(m_pHostPlayer == NULL);
	DNASSERT(m_NameTableArray == NULL);
}


#ifdef	DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ValidateArray"

void CNameTable::ValidateArray( void )
{
	DWORD	dw;
	DWORD	dwFreeEntries;

	ReadLock();

	//
	//	Ensure free entry count is correct
	//
	dwFreeEntries = 0;
	for (dw = 2 ; dw < m_dwNameTableSize ; dw++)
	{
		if (!(m_NameTableArray[dw].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID))
		{
			dwFreeEntries++;
		}
	}
	if (dwFreeEntries != m_dwNumFreeEntries)
	{
		DPFERR("Incorrect number of free entries in NameTable");
		DNASSERT(FALSE);
	}

	//
	//	Ensure free list integrity
	//
	if (m_dwNumFreeEntries)
	{
		dwFreeEntries = 0;
		dw = m_dwFirstFreeEntry;
		do
		{
			if (m_NameTableArray[dw].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID)
			{
				DPFERR("Valid entry in NameTable array free list");
				DNASSERT(FALSE);
			}
			dwFreeEntries++;
			dw = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[dw].pNameTableEntry));
		} while (dw != 0);

		if (dwFreeEntries != m_dwNumFreeEntries)
		{
			DPFERR("Incorrect number of free entries in NameTable array free list");
			DNASSERT(FALSE);
		}
	}

	Unlock();
}

#endif // DBG


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::SetNameTableSize"

HRESULT CNameTable::SetNameTableSize( const DWORD dwNumEntries )
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GrowNameTable"

HRESULT CNameTable::GrowNameTable( void )
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
{
	NAMETABLE_ARRAY_ENTRY *pNewArray;
	DWORD			dwNewSize;
	DWORD			dw;

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT(m_dwNameTableSize == 0);
	dwNewSize = dwNumEntries + 1; // + 1 because we never hand out entry 0
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (m_dwNameTableSize == 0)
	{
		dwNewSize = 2;
	}
	else
	{
		dwNewSize = m_dwNameTableSize * 2;
	}
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

	// Allocate new array
	pNewArray = static_cast<NAMETABLE_ARRAY_ENTRY*>(DNMalloc(sizeof(NAMETABLE_ARRAY_ENTRY) * dwNewSize));
	if (pNewArray == NULL)
	{
		return(DPNERR_OUTOFMEMORY);
	}

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (m_dwNameTableSize > 0)
	{
		DNASSERT(m_NameTableArray != NULL);
		// Copy old array to new array
		memcpy(pNewArray, m_NameTableArray, (sizeof(NAMETABLE_ARRAY_ENTRY) * m_dwNameTableSize));
	}
	else
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	{
		DNASSERT(m_NameTableArray == NULL);
	}

	//
	//	If the array is being grown because there are no free entries, then all of the new free
	//	entries will be in the new part of the array.  Otherwise, we will need to link the old
	//	free list to the new one
	//
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (m_dwNumFreeEntries != 0)
	{
		// Only new free entries at end of new array
		pNewArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(m_dwNameTableSize));
	}
	else
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	{
		// All free entries at end of new array
		m_dwFirstFreeEntry = m_dwNameTableSize;
	}
	m_dwLastFreeEntry = dwNewSize-1;

	// Very last FREE entry will not wrap to 0
	pNewArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(0);
	pNewArray[m_dwLastFreeEntry].dwFlags = 0;

	// Link new FREE entries
	for (dw = m_dwNameTableSize ; dw < m_dwLastFreeEntry ; dw++)
	{
		pNewArray[dw].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(dw+1));
		pNewArray[dw].dwFlags = 0;
	}

	// Update NameTable
	m_dwNumFreeEntries += (dwNewSize - m_dwNameTableSize);
	m_dwNameTableSize = dwNewSize;

	// New array
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (m_NameTableArray)
	{
		DNFree(m_NameTableArray);
	}
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	m_NameTableArray = pNewArray;

	// We will never allocate 0
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (m_dwFirstFreeEntry == 0)
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	{
		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[m_dwFirstFreeEntry].pNameTableEntry));
		DNASSERT(m_dwNumFreeEntries > 0);
		m_dwNumFreeEntries--;
	}

	// We will never allocate 1 either, for backwards compatibility
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (m_dwFirstFreeEntry == 1)
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	{
		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[m_dwFirstFreeEntry].pNameTableEntry));
		DNASSERT(m_dwNumFreeEntries > 0);
		m_dwNumFreeEntries--;
	}
	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ResetNameTable"

void CNameTable::ResetNameTable( void )
{
	DNASSERT(m_pdnObject != NULL);
	DNASSERT(m_pDefaultPlayer != NULL);
	DNASSERT(m_pLocalPlayer == NULL);
	DNASSERT(m_pHostPlayer == NULL);
	DNASSERT(m_pAllPlayersGroup == NULL);
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT(m_NameTableArray != NULL);
	DNASSERT(m_dwNameTableSize > 0);
	DNASSERT(m_dwNumFreeEntries == (m_dwNameTableSize - 1));
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

	m_dpnidMask = 0;
	m_dwVersion = 1;
	m_dwLatestVersion = 0;
	m_dwConnectVersion = 0;
	m_lOutstandingConnections = 0;

#pragma TODO(vanceo, "Should we bother?")
	/*
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (m_NameTableArray != NULL)
	{
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
		// Re-link the FREE entries in order.

		m_dwLastFreeEntry = m_dwNameTableSize - 1;

		// Very last FREE entry will not wrap to 0
		pNewArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(0);
		pNewArray[m_dwLastFreeEntry].dwFlags = 0;

		for (dw = 0 ; dw < m_dwLastFreeEntry ; dw++)
		{
			pNewArray[dw].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(dw+1));
			pNewArray[dw].dwFlags = 0;
		}

		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[0].pNameTableEntry));
	}
	*/
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::UpdateTable"

HRESULT CNameTable::UpdateTable(const DWORD dwIndex,
								CNameTableEntry *const pNameTableEntry)
{
	BOOL	bFound;
	DWORD	dw;

	DNASSERT(dwIndex < m_dwNameTableSize);
	DNASSERT(!(m_NameTableArray[dwIndex].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID));

	if (m_dwFirstFreeEntry == dwIndex)
	{
		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[m_dwFirstFreeEntry].pNameTableEntry));
		bFound = TRUE;
	}
	else
	{
		bFound = FALSE;
		dw = m_dwFirstFreeEntry;
		while (!bFound && (dw != m_dwLastFreeEntry))
		{
			if (m_NameTableArray[dw].pNameTableEntry == reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(dwIndex)))
			{
				m_NameTableArray[dw].pNameTableEntry = m_NameTableArray[dwIndex].pNameTableEntry;
				if (m_dwLastFreeEntry == dwIndex)
				{
					m_dwLastFreeEntry = dw;
				}
				bFound = TRUE;
			}
			else
			{
				dw = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[dw].pNameTableEntry));
			}
		}
	}

	if (!bFound)
	{
		return(DPNERR_GENERIC);
	}

	pNameTableEntry->AddRef();
	m_NameTableArray[dwIndex].pNameTableEntry = pNameTableEntry;
	m_NameTableArray[dwIndex].dwFlags |= NAMETABLE_ARRAY_ENTRY_FLAG_VALID;

	//
	//	Insert into entry bilink
	//
	if (pNameTableEntry->IsGroup())
	{
		pNameTableEntry->m_bilinkEntries.InsertBefore(&m_bilinkGroups);
	}
	else
	{
		pNameTableEntry->m_bilinkEntries.InsertBefore(&m_bilinkPlayers);
	}

	DNASSERT(m_dwNumFreeEntries > 0);
	m_dwNumFreeEntries--;

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::InsertEntry"

HRESULT CNameTable::InsertEntry(CNameTableEntry *const pNameTableEntry)
{
	HRESULT	hResultCode;
	DWORD	dwIndex;

	DNASSERT(pNameTableEntry != NULL);
	DNASSERT(pNameTableEntry->GetDPNID() != 0);

	dwIndex = DECODE_INDEX(pNameTableEntry->GetDPNID());

	WriteLock();

	while (dwIndex >= m_dwNameTableSize)
	{
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
		if (GrowNameTable() != DPN_OK)
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
		{
			Unlock();
			DNASSERTX(! "Couldn't fit entry into nametable!", 2);
			return(DPNERR_OUTOFMEMORY);
		}
	}

	if ((hResultCode = UpdateTable(dwIndex,pNameTableEntry)) != DPN_OK)
	{
		Unlock();
		return(DPNERR_GENERIC);
	}

	Unlock();

#ifdef DBG
	ValidateArray();
#endif // DBG

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ReleaseEntry"

void CNameTable::ReleaseEntry(const DWORD dwIndex)
{
	CNameTableEntry	*pNTEntry;

	DNASSERT(dwIndex != 0);

	pNTEntry = m_NameTableArray[dwIndex].pNameTableEntry;
	m_NameTableArray[dwIndex].pNameTableEntry = NULL;
	pNTEntry->m_bilinkEntries.RemoveFromList();
	pNTEntry->Release();

	if (m_dwNumFreeEntries == 0)
	{
		m_dwFirstFreeEntry = dwIndex;
	}
	else
	{
		m_NameTableArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(dwIndex));
	}
	m_dwLastFreeEntry = dwIndex;
	m_NameTableArray[m_dwLastFreeEntry].dwFlags &= (~NAMETABLE_ARRAY_ENTRY_FLAG_VALID);
	m_dwNumFreeEntries++;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::EmptyTable"

void CNameTable::EmptyTable( const HRESULT hrReason )
{
	DWORD			dw;
	CNameTableEntry	*pNTEntry;
	DWORD			dwGroupReason;
	DWORD			dwPlayerReason;
	CBilink			*pBilink;
	CQueuedMsg		*pQueuedMsg;

	DPFX(DPFPREP, 6,"Parameters: hrReason [0x%lx]",hrReason);

	DNASSERT( (hrReason == DPN_OK) || (hrReason == DPNERR_HOSTTERMINATEDSESSION) || (hrReason == DPNERR_CONNECTIONLOST));

	if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
	{
		//
		//	Determine destruction reason to pass to application
		//
		switch (hrReason)
		{
			case DPN_OK:
				{
					dwPlayerReason = DPNDESTROYPLAYERREASON_NORMAL;
					dwGroupReason = DPNDESTROYGROUPREASON_NORMAL;
					break;
				}
			case DPNERR_HOSTTERMINATEDSESSION:
				{
					dwPlayerReason = DPNDESTROYPLAYERREASON_SESSIONTERMINATED;
					dwGroupReason = DPNDESTROYGROUPREASON_SESSIONTERMINATED;
					break;
				}
			case DPNERR_CONNECTIONLOST:
				{
					dwPlayerReason = DPNDESTROYPLAYERREASON_CONNECTIONLOST;
					dwGroupReason = DPNDESTROYGROUPREASON_NORMAL;
					break;
				}
			default:
				{
					DNASSERT( FALSE );	// Should never get here !
					dwPlayerReason = DPNDESTROYPLAYERREASON_NORMAL;
					dwGroupReason = DPNDESTROYGROUPREASON_NORMAL;
					break;
				}
		}

		//
		//	To make VanceO happy, I've agreed to pre-mark the group destructions as NORMAL,
		//	rather than AUTODESTRUCT
		//
		ReadLock();
		pBilink = m_bilinkGroups.GetNext();
		while (pBilink != &m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( dwGroupReason );
			}
			pNTEntry->Unlock();
			pNTEntry = NULL;

			pBilink = pBilink->GetNext();
		}
		Unlock();

		for (dw = 0 ; dw < m_dwNameTableSize ; dw++)
		{
			pNTEntry = NULL;
			ReadLock();
			if ((m_NameTableArray[dw].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID) &&
				(m_NameTableArray[dw].pNameTableEntry))
			{
				//
				//	Cleanup this entry (if it's not disconnecting) and then release it
				//
				m_NameTableArray[dw].pNameTableEntry->Lock();
				if (!m_NameTableArray[dw].pNameTableEntry->IsDisconnecting())
				{
					m_NameTableArray[dw].pNameTableEntry->AddRef();
					pNTEntry = m_NameTableArray[dw].pNameTableEntry;
				}
				m_NameTableArray[dw].pNameTableEntry->Unlock();
				Unlock();

				if (pNTEntry)
				{
					//
					//	Set destroy reason if required
					//
					pNTEntry->Lock();
					if (pNTEntry->GetDestroyReason() == 0)
					{
						if (pNTEntry->IsGroup())
						{
							pNTEntry->SetDestroyReason( dwGroupReason );
						}
						else
						{
							pNTEntry->SetDestroyReason( dwPlayerReason );
						}
					}
					pNTEntry->Unlock();

					//
					//	Delete entry
					//
					if (pNTEntry->IsGroup())
					{
						if (!pNTEntry->IsAllPlayersGroup())
						{
							DeleteGroup(pNTEntry->GetDPNID(),NULL);
						}
					}
					else
					{
						CConnection	*pConnection;

						pConnection = NULL;

						pNTEntry->GetConnectionRef( &pConnection );
						if (pConnection)
						{
							pConnection->Disconnect();
							pConnection->Release();
							pConnection = NULL;
						}
						DeletePlayer(pNTEntry->GetDPNID(),NULL);
					}

					pNTEntry->Release();
					pNTEntry = NULL;
				}
			}
			else
			{
				Unlock();
			}
		}


		//
		//	Set reason for short-cut pointers (if required)
		//
		ReadLock();
		if (m_pLocalPlayer)
		{
			m_pLocalPlayer->Lock();
			if (m_pLocalPlayer->GetDestroyReason() == 0)
			{
				m_pLocalPlayer->SetDestroyReason( dwPlayerReason );
			}
			m_pLocalPlayer->Unlock();
		}
		if (m_pHostPlayer)
		{
			m_pHostPlayer->Lock();
			if (m_pHostPlayer->GetDestroyReason() == 0)
			{
				m_pHostPlayer->SetDestroyReason( dwPlayerReason );
			}
			m_pHostPlayer->Unlock();
		}
		if (m_pAllPlayersGroup)
		{
			m_pAllPlayersGroup->Lock();
			if (m_pAllPlayersGroup->GetDestroyReason() == 0)
			{
				m_pAllPlayersGroup->SetDestroyReason( dwGroupReason );
			}
			m_pAllPlayersGroup->Unlock();
		}
		Unlock();
	}
	else
	{
		//
		//	Disconnect from Host and remove any queued messages from Host player (on Client)
		//
		if (GetHostPlayerRef(&pNTEntry) == DPN_OK)
		{
			CConnection	*pConnection;

			pConnection = NULL;

			pNTEntry->GetConnectionRef( &pConnection );
			if (pConnection)
			{
				pConnection->Disconnect();
				pConnection->Release();
				pConnection = NULL;
			}

			pNTEntry->Lock();
			pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			while (pBilink != &pNTEntry->m_bilinkQueuedMsgs)
			{
				pQueuedMsg = CONTAINING_OBJECT(pBilink,CQueuedMsg,m_bilinkQueuedMsgs);
				pQueuedMsg->m_bilinkQueuedMsgs.RemoveFromList();
				DEBUG_ONLY(pNTEntry->m_lNumQueuedMsgs--);

				pNTEntry->Unlock();
				
				DNASSERT(pQueuedMsg->GetAsyncOp() != NULL);
				DNASSERT(pQueuedMsg->GetAsyncOp()->GetHandle() != 0);

				DNEnterCriticalSection(&m_pdnObject->csActiveList);
				pQueuedMsg->GetAsyncOp()->m_bilinkActiveList.RemoveFromList();
				DNLeaveCriticalSection(&m_pdnObject->csActiveList);

				if (SUCCEEDED(m_pdnObject->HandleTable.Destroy( pQueuedMsg->GetAsyncOp()->GetHandle(), NULL )))
				{
					// Release the HandleTable reference
					pQueuedMsg->GetAsyncOp()->Release();
				}

				pQueuedMsg->GetAsyncOp()->Release();
				pQueuedMsg->SetAsyncOp( NULL );
				pQueuedMsg->ReturnSelfToPool();
				pQueuedMsg = NULL;

				pNTEntry->Lock();

				pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			}
			pNTEntry->Unlock();
			pNTEntry->Release();
			pNTEntry = NULL;

			DNASSERT(pConnection == NULL);
		}
	}

	//
	//	Remove short-cut pointers
	//
	ClearLocalPlayer();
	ClearHostPlayer();
	ClearAllPlayersGroup();

	DPFX(DPFPREP, 6,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::FindEntry"

HRESULT CNameTable::FindEntry(const DPNID dpnid,
							  CNameTableEntry **const ppNameTableEntry)
{
	DWORD	dwIndex;
	HRESULT	hResultCode;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], ppNameTableEntry [0x%p]",dpnid,ppNameTableEntry);

	DNASSERT(ppNameTableEntry != NULL);

	if (dpnid == 0)
	{
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	ReadLock();
	dwIndex = DECODE_INDEX(dpnid);
	if ((dwIndex >= m_dwNameTableSize)
			|| !(m_NameTableArray[dwIndex].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID)
			|| (m_NameTableArray[dwIndex].pNameTableEntry == NULL))
	{
		Unlock();
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	if (!VERIFY_VERSION(dpnid,m_NameTableArray[dwIndex].pNameTableEntry->GetVersion()))
	{
		Unlock();
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	m_NameTableArray[dwIndex].pNameTableEntry->AddRef();
	*ppNameTableEntry = m_NameTableArray[dwIndex].pNameTableEntry;

	Unlock();

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"hResultCode: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::FindDeletedEntry"

HRESULT	CNameTable::FindDeletedEntry(const DPNID dpnid,
									 CNameTableEntry **const ppNTEntry)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], ppNTEntry [0x%p]",dpnid,ppNTEntry);

	DNASSERT(ppNTEntry != NULL);

	pNTEntry = NULL;
	hResultCode = DPNERR_DOESNOTEXIST;

	ReadLock();
	pBilink = m_bilinkDeleted.GetNext();
	while (pBilink != &m_bilinkDeleted)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkDeleted);
		if (pNTEntry->GetDPNID() == dpnid)
		{
			pNTEntry->AddRef();
			hResultCode = DPN_OK;
			break;
		}
		else
		{
			pBilink = pBilink->GetNext();
			pNTEntry = NULL;
		}
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->AddRef();
		*ppNTEntry = pNTEntry;
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AddEntry"

HRESULT	CNameTable::AddEntry(CNameTableEntry *const pNTEntry)
{
	DPNID	dpnid;
	DWORD	dwIndex;
	DWORD	dwVersion;
	HRESULT	hResultCode;

	WriteLock();

	//
	// Create DPNID
	//

	while (m_dwNumFreeEntries == 0)
	{
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
		if (GrowNameTable() != DPN_OK)
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
		{
			DNASSERTX(! "No free slots in name table!", 2);
			Unlock();
			return(DPNERR_OUTOFMEMORY);
		}
	}
	DNASSERT(m_dwFirstFreeEntry != 0);
	dwIndex = m_dwFirstFreeEntry;

	dwVersion = ++m_dwVersion;
	DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);

	dpnid = CONSTRUCT_DPNID(dwIndex,dwVersion);
	DNASSERT(dpnid != 0);

	pNTEntry->Lock();
	pNTEntry->SetDPNID(dpnid);
	pNTEntry->SetVersion(dwVersion);
	pNTEntry->Unlock();

	dwIndex = DECODE_INDEX(dpnid);
	hResultCode = UpdateTable(dwIndex,pNTEntry);

	Unlock();

#ifdef DBG
	ValidateArray();
#endif // DBG

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DeletePlayer"

HRESULT CNameTable::DeletePlayer(const DPNID dpnid,
								 DWORD *const pdwVersion)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	BOOL			fNotifyRelease;
	BOOL			fDecConnections;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pdwVersion [0x%p]",dpnid,pdwVersion);

	pNTEntry = NULL;
	fNotifyRelease = FALSE;
	fDecConnections = FALSE;

	if ((hResultCode = FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Player not in NameTable");
		DisplayDNError(0,hResultCode);

		//
		//	If a version is requested, we will give one back.  This might be a host migration case
		//	in which case even though the player was removed from the NameTable, we will want to
		//	send out a DESTROY_PLAYER message with an updated version number
		//
		if (pdwVersion)
		{
			if (*pdwVersion == 0)
			{
				WriteLock();
				*pdwVersion = ++m_dwVersion;
				DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
				Unlock();
			}
		}
		goto Failure;
	}
	DNASSERT(!pNTEntry->IsGroup());

	//
	//	Don't do anything if already disconnecting.
	//	Otherwise, set disconnecting to prevent others from cleaning up, and clean up
	//
	pNTEntry->Lock();
	if (!pNTEntry->IsDisconnecting())
	{
		pNTEntry->StartDisconnecting();
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();
		}
		if ((pNTEntry->IsCreated() || pNTEntry->IsIndicated() || pNTEntry->IsInUse()) && !pNTEntry->IsNeedToDestroy())
		{
			pNTEntry->SetNeedToDestroy();
			fNotifyRelease = TRUE;
		}
		if (	  !pNTEntry->IsCreated()
				&& pNTEntry->IsConnecting()
				&& (m_pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTING | DN_OBJECT_FLAG_CONNECTED))
				&& (pNTEntry->GetVersion() <= m_dwConnectVersion))
		{
			fDecConnections = TRUE;
		}
		pNTEntry->Unlock();

		//
		//	Remove this player from any groups they belong to
		//
		RemoveAllGroupsFromPlayer( pNTEntry );

		//
		//	Autodestruct any groups this player owns (will also remove any players from those groups first)
		//
		if (pNTEntry->GetDPNID() != 0)
		{
			AutoDestructGroups( pNTEntry->GetDPNID() );
		}

		if (fNotifyRelease)
		{
			pNTEntry->NotifyRelease();
		}

		//
		//	Adjust player count
		//
		m_pdnObject->ApplicationDesc.DecPlayerCount();
		if (fDecConnections)
		{
			DecOutstandingConnections();
		}

		//
		//	Update version and remove from NameTable
		//
		WriteLock();
		pNTEntry->Lock();
		if ((pNTEntry->IsCreated() || pNTEntry->IsInUse()) && pNTEntry->IsNeedToDestroy())
		{
			//
			//	The DESTROY_PLAYER message has not been posted, so we will add this entry to our "deleted" list
			//	so that some future operations (get info,context,etc.) may succeed.  This entry will be removed
			//	from the list then the DESTROY_PLAYER notification is posted
			//
			pNTEntry->m_bilinkDeleted.InsertBefore(&m_bilinkDeleted);

			pNTEntry->Unlock();

			ReleaseEntry(DECODE_INDEX(dpnid));

			//
			//	Update version
			//
			if (pdwVersion)
			{
				if (*pdwVersion)
				{
					m_dwVersion = *pdwVersion;
				}
				else
				{
					*pdwVersion = ++m_dwVersion;
				}
				DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
			}
			Unlock();
		}
		else
		{
			CBilink		*pBilink;
			CQueuedMsg	*pQueuedMsg;

			//
			//	Remove any queued messages at this stage.  A CREATE_PLAYER won't be generated, so no messages
			//	will be passed up.
			//
			//	This is probably wrong since for reliable traffic, we assume it got here
			//
			Unlock();

#pragma BUGBUG(minara,"This is probably wrong since reliable traffic should be indicated rather than just thrown away!")
			pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			while (pBilink != &pNTEntry->m_bilinkQueuedMsgs)
			{
				pQueuedMsg = CONTAINING_OBJECT(pBilink,CQueuedMsg,m_bilinkQueuedMsgs);
				pQueuedMsg->m_bilinkQueuedMsgs.RemoveFromList();
				DEBUG_ONLY(pNTEntry->m_lNumQueuedMsgs--);

				pNTEntry->Unlock();
				
				DNASSERT(pQueuedMsg->GetAsyncOp() != NULL);
				DNASSERT(pQueuedMsg->GetAsyncOp()->GetHandle() != 0);

				DNDoCancelCommand( m_pdnObject,pQueuedMsg->GetAsyncOp() );

				pQueuedMsg->GetAsyncOp()->Release();
				pQueuedMsg->SetAsyncOp( NULL );
				pQueuedMsg->ReturnSelfToPool();
				pQueuedMsg = NULL;

				pNTEntry->Lock();

				pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			}
			pNTEntry->Unlock();

			//
			//	Update version
			//
			WriteLock();
			ReleaseEntry(DECODE_INDEX(dpnid));
			if (pdwVersion)
			{
				if (*pdwVersion)
				{
					m_dwVersion = *pdwVersion;
				}
				else
				{
					*pdwVersion = ++m_dwVersion;
				}
				DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
			}
			Unlock();
		}
		
		hResultCode = DPN_OK;
	}
	else
	{
		pNTEntry->Unlock();

		hResultCode = DPNERR_INVALIDPLAYER;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DeleteGroup"

HRESULT CNameTable::DeleteGroup(const DPNID dpnid,
								DWORD *const pdwVersion)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	BOOL			fNotifyRelease;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pdwVersion [0x%p]",dpnid,pdwVersion);

	pNTEntry = NULL;
	fNotifyRelease = FALSE;

	if ((hResultCode = FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Player not in NameTable");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}
	DNASSERT(pNTEntry->IsGroup() && !pNTEntry->IsAllPlayersGroup());

	//
	//	Don't do anything if already disconnecting.
	//	Otherwise, set disconnecting to prevent others from cleaning up, and clean up
	//
	pNTEntry->Lock();
	if (pNTEntry->GetDestroyReason() == 0)
	{
		//
		//	Default this if it isn't set
		//
		pNTEntry->SetDestroyReason( DPNDESTROYGROUPREASON_NORMAL );
	}
	if (!pNTEntry->IsDisconnecting())
	{
		pNTEntry->StartDisconnecting();
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();
		}
		if (pNTEntry->IsCreated() && !pNTEntry->IsNeedToDestroy())
		{
			pNTEntry->SetNeedToDestroy();
			fNotifyRelease = TRUE;
		}
		pNTEntry->Unlock();

		RemoveAllPlayersFromGroup( pNTEntry );

		if (fNotifyRelease)
		{
			pNTEntry->NotifyRelease();
		}

		//
		//	Update version and remove from NameTable
		//
		WriteLock();
		pNTEntry->Lock();
		if (pNTEntry->IsNeedToDestroy())
		{
			//
			//	The DESTROY_GROUP message has not been posted, so we will add this entry to our "deleted" list
			//	so that some future operations (get info,context,etc.) may succeed.  This entry will be removed
			//	from the list then the DESTROY_GROUP notification is posted
			//
			pNTEntry->m_bilinkDeleted.InsertBefore(&m_bilinkDeleted);
		}
		pNTEntry->Unlock();
		ReleaseEntry(DECODE_INDEX(dpnid));
		if (pdwVersion)
		{
			if (*pdwVersion)
			{
				m_dwVersion = *pdwVersion;
			}
			else
			{
				*pdwVersion = ++m_dwVersion;
			}
			DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
		}
		Unlock();

		hResultCode = DPN_OK;
	}
	else
	{
		pNTEntry->Unlock();

		hResultCode = DPNERR_INVALIDGROUP;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AddPlayerToGroup"

HRESULT CNameTable::AddPlayerToGroup(CNameTableEntry *const pGroup,
									 CNameTableEntry *const pPlayer,
									 DWORD *const pdwVersion)
{
	HRESULT				hResultCode;
	CGroupMember		*pGroupMember;
	CGroupConnection	*pGroupConnection;
	CConnection			*pConnection;
	BOOL				fNotifyAdd;
	BOOL				fRemove;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p], pPlayer [0x%p], pdwVersion [0x%p]",pGroup,pPlayer,pdwVersion);

	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	pGroupConnection = NULL;
	pGroupMember = NULL;
	pConnection = NULL;

	if (!pGroup->IsGroup())
	{
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (pPlayer->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Create the group connection
	//
	if ((hResultCode = GroupConnectionNew(m_pdnObject,&pGroupConnection)) != DPN_OK)
	{
		DPFERR("Could not allocate name table group connection entry from FPM");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pGroupConnection->SetGroup( pGroup );

	//
	//	Create new group membership record
	//
	if ((hResultCode = GroupMemberNew(m_pdnObject,&pGroupMember)) != DPN_OK)
	{
		DPFERR("Could not get new group member");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Set group connection on group membership record
	//
	pGroupMember->SetGroupConnection(pGroupConnection);

	//
	//	Add player to group
	//
	fNotifyAdd = FALSE;
	fRemove = FALSE;
	WriteLock();
	pGroup->Lock();
	pPlayer->Lock();
	pGroupMember->Lock();
	if (!pGroup->IsDisconnecting() && !pPlayer->IsDisconnecting())
	{
		pGroupMember->MakeValid();
		pGroupMember->GetGroupConnection()->MakeValid();

		//
		//	Set group membership (checks for duplicates as well)
		//
		if ((hResultCode = pGroupMember->SetMembership(pGroup,pPlayer,pdwVersion)) != DPN_OK)
		{
			DPFERR("Could not set membership record");
			DisplayDNError(0,hResultCode);
			Unlock();
			pGroup->Unlock();
			pPlayer->Unlock();
			pGroupMember->Unlock();
			goto Failure;
		}
		//
		//	Generate notification (ALL_PLAYERS GROUP should never be "Created")
		//
		if (pGroup->IsCreated() && pPlayer->IsCreated())
		{
			//
			//	Add the player's connection to the group connection record
			//
			if (pPlayer->GetConnection() != NULL)
			{
				pGroupConnection->SetConnection( pPlayer->GetConnection() );
			}

			if (!pGroupMember->IsNeedToAdd() && !pGroupMember->IsAvailable() && pGroupMember->GetGroupConnection()->IsConnected())
			{
				pGroupMember->SetNeedToAdd();
				fNotifyAdd = TRUE;
			}
		}

		//
		//	Need to set up the group connection if this is the ALL_PLAYERS group
		//
		if (pGroup->IsAllPlayersGroup())
		{
			if (pPlayer->GetConnection() != NULL)
			{
				pGroupConnection->SetConnection( pPlayer->GetConnection() );
			}
		}

		//
		//	Prevent a DESTROY_PLAYER/DESTROY_GROUP from occurring until this GroupMember record is cleared
		//
		pGroup->NotifyAddRef();
		pPlayer->NotifyAddRef();
	}
	Unlock();
	pGroup->Unlock();
	pPlayer->Unlock();
	pGroupMember->Unlock();

	if (fNotifyAdd)
	{
		DNUserAddPlayerToGroup(m_pdnObject,pGroup,pPlayer);

		pGroupMember->Lock();
		pGroupMember->ClearNeedToAdd();
		pGroupMember->MakeAvailable();
		if (pGroupMember->IsNeedToRemove())
		{
			fRemove = TRUE;
		}
		pGroupMember->Unlock();
	}
	if (fRemove)
	{
		RemovePlayerFromGroup(pGroup,pPlayer,NULL);
	}

	pGroupConnection->Release();
	pGroupConnection = NULL;

	pGroupMember->Release();
	pGroupMember = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pGroupConnection)
	{
		pGroupConnection->Release();
		pGroupConnection = NULL;
	}
	if (pGroupMember)
	{
		pGroupMember->Release();
		pGroupMember = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::RemovePlayerFromGroup"

HRESULT CNameTable::RemovePlayerFromGroup(CNameTableEntry *const pGroup,
										  CNameTableEntry *const pPlayer,
										  DWORD *const pdwVersion)
{
	CGroupMember	*pGroupMember;
	CBilink			*pBilink;
	BOOL			fNotifyRemove;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p], pPlayer [0x%p], pdwVersion [0x%p]",pGroup,pPlayer,pdwVersion);

	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	pGroupMember = NULL;
	fNotifyRemove = FALSE;

	WriteLock();
	pGroup->Lock();
	pPlayer->Lock();

	//
	//	The first order of business is to locate the GroupMembership record.
	//	We will use the player's NameTable entry and scan through the
	//	group membership bilink until we find the required entry.
	//	(We're assuming that this will be faster than going the other route.)
	//
	pBilink = pPlayer->m_bilinkMembership.GetNext();
	while (pBilink != &pPlayer->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);
		if (pGroupMember->GetGroup() == pGroup)
		{
			pGroupMember->AddRef();
			break;
		}
		pGroupMember = NULL;
		pBilink = pBilink->GetNext();
	}
	if (pGroupMember == NULL)
	{
		Unlock();
		pGroup->Unlock();
		pPlayer->Unlock();
		hResultCode = DPNERR_PLAYERNOTINGROUP;
		goto Failure;
	}

	DNASSERT(pGroupMember != NULL);
	pGroupMember->Lock();

	//
	//	Ensure no one else is trying to remove this already
	//
	if (!pGroupMember->IsValid() || pGroupMember->IsNeedToRemove())
	{
		Unlock();
		pGroup->Unlock();
		pPlayer->Unlock();
		pGroupMember->Unlock();
		hResultCode = DPNERR_PLAYERNOTINGROUP;
		goto Failure;
	}
	pGroupMember->SetNeedToRemove();

	//
	//	We will only notify the application if the player is not being added to a group
	//
	if (!pGroupMember->IsNeedToAdd())
	{
		//
		//	Either this is already indicated, or is not about to be indicated, so remove it
		//	(and see if we need to generate a notification)
		//
		pGroupMember->RemoveMembership( pdwVersion );

		if (pGroupMember->IsAvailable())
		{
			pGroupMember->MakeUnavailable();
			if (!pGroup->IsAllPlayersGroup())
			{
				fNotifyRemove = TRUE;
			}
		}
	}
	Unlock();
	pGroup->Unlock();
	pPlayer->Unlock();
	pGroupMember->Unlock();

	if (fNotifyRemove)
	{
		DNUserRemovePlayerFromGroup(m_pdnObject,pGroup,pPlayer);
	}

	//
	//	Trigger a DESTROY_PLAYER/DESTROY_GROUP if this was the last member
	//
	pGroup->NotifyRelease();
	pPlayer->NotifyRelease();

	pGroupMember->Release();
	pGroupMember = NULL;

	hResultCode = DPN_OK;

Exit:
	return(hResultCode);

Failure:
	if (pGroupMember)
	{
		pGroupMember->Release();
		pGroupMember = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::RemoveAllPlayersFromGroup"

HRESULT CNameTable::RemoveAllPlayersFromGroup(CNameTableEntry *const pGroup)
{
	CNameTableEntry	**PlayerList;
	CBilink			*pBilink;
	HRESULT			hResultCode;
	DWORD			dwCount;
	DWORD			dwActual;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p]",pGroup);

	DNASSERT(pGroup != NULL);

	PlayerList = NULL;

	//
	//	This is not an elegant solution - we will build a list of membership records and remove each one
	//
	dwCount = 0;
	dwActual = 0;
	pGroup->Lock();
	DNASSERT(pGroup->IsDisconnecting());
	pBilink = pGroup->m_bilinkMembership.GetNext();
	while (pBilink != &pGroup->m_bilinkMembership)
	{
		dwCount++;
		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		CGroupMember	*pGroupMember;

		pGroupMember = NULL;

		if ((PlayerList = static_cast<CNameTableEntry**>(MemoryBlockAlloc(m_pdnObject,dwCount*sizeof(CNameTableEntry*)))) == NULL)
		{
			DPFERR("Could not allocate player list");
			hResultCode = DPNERR_OUTOFMEMORY;
			DNASSERT(FALSE);
			pGroup->Unlock();
			goto Failure;
		}
		pBilink = pGroup->m_bilinkMembership.GetNext();
		while (pBilink != &pGroup->m_bilinkMembership)
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);

			pGroupMember->Lock();
			if (pGroupMember->IsValid() && !pGroupMember->IsNeedToRemove() && pGroupMember->GetPlayer())
			{
				DNASSERT(dwActual < dwCount);
				pGroupMember->GetPlayer()->AddRef();
				PlayerList[dwActual] = pGroupMember->GetPlayer();
				dwActual++;
			}
			pGroupMember->Unlock();

			pBilink = pBilink->GetNext();
			pGroupMember = NULL;
		}

		DNASSERT(pGroupMember == NULL);
	}
	pGroup->Unlock();

	if (PlayerList)
	{
		DWORD	dw;

		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DNASSERT(PlayerList[dw] != NULL);

			RemovePlayerFromGroup(pGroup,PlayerList[dw],NULL);
			PlayerList[dw]->Release();
			PlayerList[dw] = NULL;
		}

		MemoryBlockFree(m_pdnObject,PlayerList);
		PlayerList = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (PlayerList)
	{
		MemoryBlockFree(m_pdnObject,PlayerList);
		PlayerList = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::RemoveAllGroupsFromPlayer"

HRESULT CNameTable::RemoveAllGroupsFromPlayer(CNameTableEntry *const pPlayer)
{
	CNameTableEntry	*apGroupList[32];
	CBilink			*pBilink;
	HRESULT			hResultCode;
	CGroupMember	*pGroupMember;
	DWORD			dwRemainingCount;
	DWORD			dwCurrentCount;
#ifdef DBG
	DWORD			dwInitialCount;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: pPlayer [0x%p]",pPlayer);

	DNASSERT(pPlayer != NULL);

	memset(apGroupList, 0, sizeof(apGroupList));
	pGroupMember = NULL;

	//
	//	This is not an elegant solution - we will build a list of membership records and remove each one
	//
	dwRemainingCount = 0;
	pPlayer->Lock();
	DNASSERT(pPlayer->IsDisconnecting());
	pBilink = pPlayer->m_bilinkMembership.GetNext();
	while (pBilink != &pPlayer->m_bilinkMembership)
	{
		dwRemainingCount++;
		pBilink = pBilink->GetNext();
	}
	pPlayer->Unlock();

#ifdef DBG
	dwInitialCount = dwRemainingCount;
#endif // DBG

	while (dwRemainingCount > 0)
	{
		dwRemainingCount = 0;
		dwCurrentCount = 0;
		pPlayer->Lock();
		pBilink = pPlayer->m_bilinkMembership.GetNext();
		while (pBilink != &pPlayer->m_bilinkMembership)
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);

			pGroupMember->Lock();
			if (pGroupMember->IsValid() && !pGroupMember->IsNeedToRemove() && pGroupMember->GetGroup())
			{
				if (dwCurrentCount < (sizeof(apGroupList) / sizeof(CNameTableEntry*)))
				{
					pGroupMember->GetGroup()->AddRef();
					apGroupList[dwCurrentCount] = pGroupMember->GetGroup();
					dwCurrentCount++;
#ifdef DBG
					DNASSERT(dwCurrentCount <= dwInitialCount);
#endif // DBG
				}
				else
				{
					dwRemainingCount++;

					//
					// The list should never grow.  In fact it should
					// always be smaller because the current group list
					// should have taken some.
					//
#ifdef DBG
					DNASSERT(dwRemainingCount < dwInitialCount);
#endif // DBG
				}
			}
			pGroupMember->Unlock();

			pBilink = pBilink->GetNext();
			pGroupMember = NULL;
		}

		DNASSERT(pGroupMember == NULL);

		pPlayer->Unlock();

		if (dwCurrentCount > 0)
		{
			DWORD	dw;

			for (dw = 0 ; dw < dwCurrentCount ; dw++)
			{
				DNASSERT(apGroupList[dw] != NULL);

				RemovePlayerFromGroup(apGroupList[dw],pPlayer,NULL);
				apGroupList[dw]->Release();
				apGroupList[dw] = NULL;
			}
		}
		else
		{
			DNASSERT(dwRemainingCount == 0);
		}
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::IsMember"

BOOL CNameTable::IsMember(const DPNID dpnidGroup,
						  const DPNID dpnidPlayer)
{
	CNameTableEntry		*pNTEntry;
	CGroupMember		*pGroupMember;
	CBilink				*pBilink;
	BOOL				bFound;

	bFound = FALSE;

	if (FindEntry(dpnidGroup,&pNTEntry) != DPN_OK)
	{
		goto Exit;
	}

	//
	//	Is this a group ?
	//
	if (!pNTEntry->IsGroup())
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		goto Exit;
	}

	pNTEntry->Lock();
	pBilink = pNTEntry->m_bilinkMembership.GetNext();
	while (pBilink != &pNTEntry->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		if (pGroupMember->GetPlayer()->GetDPNID() == dpnidPlayer)
		{
			bFound = TRUE;
			break;
		}
		pBilink = pBilink->GetNext();
	}

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	return(bFound);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::PackNameTable"

HRESULT CNameTable::PackNameTable(CNameTableEntry *const pTarget,
								  CPackedBuffer *const pPackedBuffer)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CBilink			*pBilinkMembership;
	CNameTableEntry	*pNTEntry;
	CGroupMember	*pGroupMember;
	DN_NAMETABLE_INFO	*pdnNTInfo;
	BOOL			bOutOfSpace;
	DWORD			dwEntryCount;
	DWORD			dwMembershipCount;
	DWORD			dwVersion;

	DNASSERT(pTarget != NULL);
	DNASSERT(pPackedBuffer != NULL);

	//
	//	PackedNameTable:
	//		<DN_NAMETABLE_INFO>
	//		<DN_NAMETABLE_ENTRY_INFO>	(DN_NAMETABLE_INFO.dwEntryCount entries)
	//		<DN_MEMBERSHIP_INFO>		(DN_NAMETABLE_INFO.dwMembershipCount entries)
	//			...
	//		<strings>
	//

	//
	//	NameTable Info
	//
	dwVersion = pTarget->GetVersion();
	bOutOfSpace = FALSE;
	pdnNTInfo = static_cast<DN_NAMETABLE_INFO*>(pPackedBuffer->GetHeadAddress());
	if ((hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DN_NAMETABLE_INFO))) != DPN_OK)
	{
		bOutOfSpace = TRUE;
	}

	ReadLock();

	//
	//	NameTableEntry Info
	//
	if (m_pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		dwEntryCount = 0;

		//
		//	Players
		//
		pBilink = m_bilinkPlayers.GetNext();
		while (pBilink != &m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			if (pNTEntry->GetVersion() <= dwVersion)
			{
				if ((hResultCode = pNTEntry->PackEntryInfo(pPackedBuffer)) != DPN_OK)
				{
					bOutOfSpace = TRUE;
				}
				dwEntryCount++;
			}
			pBilink = pBilink->GetNext();
		}

		//
		//	Groups
		//
		pBilink = m_bilinkGroups.GetNext();
		while (pBilink != &m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			if (pNTEntry->GetVersion() <= dwVersion)
			{
				if ((hResultCode = pNTEntry->PackEntryInfo(pPackedBuffer)) != DPN_OK)
				{
					bOutOfSpace = TRUE;
				}
				dwEntryCount++;
			}
			pBilink = pBilink->GetNext();
		}
	}
	else
	{
		DNASSERT(m_pLocalPlayer != NULL);

		if ((hResultCode = m_pLocalPlayer->PackEntryInfo(pPackedBuffer)) != DPN_OK)
		{
			bOutOfSpace = TRUE;
		}
		if ((hResultCode = pTarget->PackEntryInfo(pPackedBuffer)) != DPN_OK)
		{
			bOutOfSpace = TRUE;
		}
		dwEntryCount = 2;
	}

	//
	//	GroupMember Info
	//
	dwMembershipCount = 0;
	if (m_pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		pBilink = m_bilinkGroups.GetNext();
		while (pBilink != &m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			DNASSERT(pNTEntry->IsGroup());
			if (!pNTEntry->IsAllPlayersGroup())
			{
				pBilinkMembership = pNTEntry->m_bilinkMembership.GetNext();
				while (pBilinkMembership != &pNTEntry->m_bilinkMembership)
				{
					pGroupMember = CONTAINING_OBJECT(pBilinkMembership,CGroupMember,m_bilinkPlayers);
					if (pGroupMember->GetVersion() <= dwVersion)
					{
						if ((hResultCode = pGroupMember->PackMembershipInfo(pPackedBuffer)) != DPN_OK)
						{
							bOutOfSpace = TRUE;
						}
						dwMembershipCount++;
					}
					pBilinkMembership = pBilinkMembership->GetNext();
				}
			}
			pBilink = pBilink->GetNext();
		}
	}

	Unlock();

	if (!bOutOfSpace)
	{
		pdnNTInfo->dpnid = pTarget->GetDPNID();
		pdnNTInfo->dwVersion = dwVersion;
		pdnNTInfo->dwVersionNotUsed = 0;
		pdnNTInfo->dwEntryCount = dwEntryCount;
		pdnNTInfo->dwMembershipCount = dwMembershipCount;
	}

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::UnpackNameTableInfo"

HRESULT	CNameTable::UnpackNameTableInfo(UNALIGNED DN_NAMETABLE_INFO *const pdnNTInfo,
										BYTE *const pBufferStart,
										DPNID *const pdpnid)
{
	HRESULT			hResultCode;
	DWORD			dwCount;
	CNameTableEntry	*pNTEntry;
	UNALIGNED DN_NAMETABLE_ENTRY_INFO			*pdnEntryInfo;
	UNALIGNED DN_NAMETABLE_MEMBERSHIP_INFO	*pdnMembershipInfo;

	DNASSERT(pdnNTInfo != NULL);
	DNASSERT(pBufferStart != NULL);

	//
	//	Preset outstanding connections
	//
	m_lOutstandingConnections = 0;

	//
	//	NameTable Entries
	//
	pdnEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(pdnNTInfo+1);
	for (dwCount = 0 ; dwCount < pdnNTInfo->dwEntryCount ; dwCount++)
	{
		if ((hResultCode = NameTableEntryNew(m_pdnObject,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not get new NameTableEntry");
			DNASSERT(FALSE);
			return(hResultCode);
		}

		if ((hResultCode = pNTEntry->UnpackEntryInfo(pdnEntryInfo,pBufferStart)) != DPN_OK)
		{
			DPFERR("Could not unpack NameTableEntryInfo");
			DNASSERT(FALSE);
			pNTEntry->Release();
			return(hResultCode);
		}

		//
		//	Increment outstanding connection count
		//
		if (!pNTEntry->IsGroup() && (pNTEntry->GetVersion() <= pdnNTInfo->dwVersion))
		{
			pNTEntry->StartConnecting();	// This will be cleared when the player has connected or disconnected
			IncOutstandingConnections();
		}

		// Only put in NameTable if Host player
#ifndef DPNBUILD_NOSERVER
		if (m_pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER | DN_OBJECT_FLAG_SERVER))
#else
		if (m_pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER))
#endif // DPNBUILD_NOSERVER
		{
			if ((hResultCode = InsertEntry(pNTEntry)) != DPN_OK)
			{
				DPFERR("Could not add NameTableEntry to NameTable");
				DNASSERT(FALSE);
				pNTEntry->Release();
				return(hResultCode);
			}
		}

		// Check for ShortCut pointers
		if (pNTEntry->GetDPNID() == pdnNTInfo->dpnid)
		{
			MakeLocalPlayer(pNTEntry);
		}
		else if (pNTEntry->IsHost())
		{
			MakeHostPlayer(pNTEntry);
		}
		else if (pNTEntry->IsAllPlayersGroup())
		{
			MakeAllPlayersGroup(pNTEntry);
		}

		pNTEntry->Release();
		pNTEntry = NULL;

		pdnEntryInfo++;
	}

	//
	//	Pass back local player's DPNID
	//
	if (pdpnid)
	{
		*pdpnid = pdnNTInfo->dpnid;
	}

	//
	//	Group Memberships
	//
	pdnMembershipInfo = reinterpret_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(pdnEntryInfo);
	for (dwCount = 0 ; dwCount < pdnNTInfo->dwMembershipCount ; dwCount++)
	{
		CNameTableEntry	*pGroup;

		pGroup = NULL;

		if ((hResultCode = m_pdnObject->NameTable.FindEntry(pdnMembershipInfo->dpnidGroup,&pGroup)) == DPN_OK)
		{
			CNameTableEntry	*pPlayer;

			pPlayer = NULL;

			if ((hResultCode = m_pdnObject->NameTable.FindEntry(pdnMembershipInfo->dpnidPlayer,&pPlayer)) == DPN_OK)
			{
				DWORD	dwVersion;

				dwVersion = pdnMembershipInfo->dwVersion;

				hResultCode = AddPlayerToGroup(pGroup,pPlayer,&dwVersion);
				pPlayer->Release();
				pPlayer = NULL;
			}
			pGroup->Release();
			pGroup = NULL;

			DNASSERT(pPlayer == NULL);
		}
		pdnMembershipInfo++;

		DNASSERT(pGroup == NULL);
	}

	//
	//	Version
	//
	WriteLock();
	SetVersion(pdnNTInfo->dwVersion);
	SetConnectVersion(pdnNTInfo->dwVersion);
	Unlock();

	hResultCode = DPN_OK;
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::MakeLocalPlayer"

void CNameTable::MakeLocalPlayer(CNameTableEntry *const pNTEntry)
{
	DNASSERT(pNTEntry != NULL);
	DNASSERT(m_pLocalPlayer == NULL);

	pNTEntry->AddRef();
	pNTEntry->Lock();
	pNTEntry->MakeLocal();
	pNTEntry->Unlock();

	WriteLock();
	m_pLocalPlayer = pNTEntry;
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearLocalPlayer"

void CNameTable::ClearLocalPlayer( void )
{
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;

	fInform = FALSE;
	pNTEntry = NULL;
	pConnection = NULL;

	WriteLock();
	if (m_pLocalPlayer)
	{
		pNTEntry = m_pLocalPlayer;
		m_pLocalPlayer = NULL;

		//
		//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
		//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
		//
		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
		}
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();

			if (pNTEntry->IsInUse())
			{
				//
				//	Queue destruction notification
				//
				pNTEntry->SetNeedToDestroy();
			}
			else
			{
				//
				//	Notify destruction
				//
				pNTEntry->SetInUse();
				fInform = TRUE;
			}
		}
		pNTEntry->Unlock();
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->GetConnectionRef(&pConnection);

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Try to disconnect
	//
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::MakeHostPlayer"

void CNameTable::MakeHostPlayer(CNameTableEntry *const pNTEntry)
{
	BOOL	bNotify;
	DPNID	dpnid;
	PVOID	pvContext;

	DNASSERT(pNTEntry != NULL);
	DNASSERT(m_pHostPlayer == NULL);

	pNTEntry->AddRef();

	pNTEntry->Lock();
	pNTEntry->MakeHost();
	if (pNTEntry->IsAvailable())
	{
		bNotify = TRUE;
		dpnid = pNTEntry->GetDPNID();
		pvContext = pNTEntry->GetContext();
	}
	else
	{
		bNotify = FALSE;
	}
	pNTEntry->Unlock();

	WriteLock();
	m_pHostPlayer = pNTEntry;
	Unlock();

	if (bNotify)
	{
		// Inform user that host has migrated
		DN_UserHostMigrate(m_pdnObject,dpnid,pvContext);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearHostPlayer"

void CNameTable::ClearHostPlayer( void )
{
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;

	fInform = FALSE;
	pNTEntry = NULL;
	pConnection = NULL;

	WriteLock();
	if (m_pHostPlayer)
	{
		pNTEntry = m_pHostPlayer;
		m_pHostPlayer = NULL;

		//
		//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
		//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
		//
		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
		}
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();

			if (pNTEntry->IsInUse())
			{
				//
				//	Queue destruction notification
				//
				pNTEntry->SetNeedToDestroy();
			}
			else
			{
				//
				//	Notify destruction
				//
				pNTEntry->SetInUse();
				fInform = TRUE;
			}
		}
		pNTEntry->Unlock();
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->GetConnectionRef(&pConnection);

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Try to disconnect
	//
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}
}


//
//	Clear the HostPlayer if it has a matching DPNID
//

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearHostWithDPNID"

BOOL CNameTable::ClearHostWithDPNID( const DPNID dpnid )
{
	BOOL	fCleared;
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;

	fCleared = FALSE;
	fInform = FALSE;
	pNTEntry = NULL;
	pConnection = NULL;

	WriteLock();
	if (m_pHostPlayer)
	{
		if (m_pHostPlayer->GetDPNID() == dpnid)
		{
			pNTEntry = m_pHostPlayer;
			m_pHostPlayer = NULL;

			//
			//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
			//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
			//
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
			}
			if (pNTEntry->IsAvailable())
			{
				pNTEntry->MakeUnavailable();

				if (pNTEntry->IsInUse())
				{
					//
					//	Queue destruction notification
					//
					pNTEntry->SetNeedToDestroy();
				}
				else
				{
					//
					//	Notify destruction
					//
					pNTEntry->SetInUse();
					fInform = TRUE;
				}
			}
			pNTEntry->Unlock();
			fCleared = TRUE;
		}
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->GetConnectionRef(&pConnection);

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Try to disconnect
	//
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}

	return(fCleared);
}


//
//	Attempt to update the HostPlayer short-cut pointer with a new player entry.
//	This will only be performed if the new entry has a larger version than the
//	existing HostPlayer entry.
//

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::UpdateHostPlayer"

void CNameTable::UpdateHostPlayer( CNameTableEntry *const pNewHost )
{
	BOOL	fInformDelete;
	BOOL	fInformMigrate;
	DPNID	dpnid;
	PVOID	pvContext;
	CNameTableEntry	*pNTEntry;

	DNASSERT( pNewHost != NULL);

	fInformDelete = FALSE;
	fInformMigrate = FALSE;
	pNTEntry = NULL;

	WriteLock();

	//
	//	Clear old Host
	//
	if (m_pHostPlayer)
	{
		if (pNewHost->GetVersion() > m_pHostPlayer->GetVersion())
		{
			pNTEntry = m_pHostPlayer;
			m_pHostPlayer = NULL;

			//
			//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
			//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
			//
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
			}
			if (pNTEntry->IsAvailable())
			{
				pNTEntry->MakeUnavailable();

				if (pNTEntry->IsInUse())
				{
					//
					//	Queue destruction notification
					//
					pNTEntry->SetNeedToDestroy();
				}
				else
				{
					//
					//	Notify destruction
					//
					pNTEntry->SetInUse();
					fInformDelete = TRUE;
				}
			}
			pNTEntry->Unlock();
		}
	}

	//
	//	New Host player
	//
	if (m_pHostPlayer == NULL)
	{
		pNewHost->Lock();
		pNewHost->MakeHost();
		if (pNewHost->IsAvailable())
		{
			fInformMigrate = TRUE;
			dpnid = pNewHost->GetDPNID();
			pvContext = pNewHost->GetContext();
		}
		pNewHost->Unlock();
		pNewHost->AddRef();
		m_pHostPlayer = pNewHost;
	}
	Unlock();

	//
	//	User notifications
	//
	if (pNTEntry)
	{

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	if (fInformMigrate)
	{
		DN_UserHostMigrate(m_pdnObject,dpnid,pvContext);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::MakeAllPlayersGroup"

void CNameTable::MakeAllPlayersGroup(CNameTableEntry *const pNTEntry)
{
	DNASSERT(pNTEntry != NULL);
	DNASSERT(m_pAllPlayersGroup == NULL);

	pNTEntry->AddRef();
	pNTEntry->Lock();
	pNTEntry->MakeAllPlayersGroup();
	pNTEntry->Unlock();

	WriteLock();
	m_pAllPlayersGroup = pNTEntry;
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearAllPlayersGroup"

void CNameTable::ClearAllPlayersGroup( void )
{
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;

	fInform = FALSE;
	pNTEntry = NULL;

	WriteLock();
	if (m_pAllPlayersGroup)
	{
		pNTEntry = m_pAllPlayersGroup;
		pNTEntry->Lock();
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();
			fInform = TRUE;
		}
		pNTEntry->Unlock();
		m_pAllPlayersGroup = NULL;
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::PopulateConnection"

HRESULT CNameTable::PopulateConnection(CConnection *const pConnection)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pAllPlayersGroup;
	CGroupMember	*pGroupMember;
	CGroupMember	*pOldGroupMember;
	BOOL			fNotifyCreate;
	BOOL			fNotifyAddPlayerToGroup;
	BOOL			fNotifyRemovePlayerFromGroup;

	DNASSERT(pConnection != NULL);
	DNASSERT(pConnection->GetDPNID() != 0);

	pNTEntry = NULL;
	pAllPlayersGroup = NULL;
	pGroupMember = NULL;
	pOldGroupMember = NULL;

	if ((hResultCode = FindEntry(pConnection->GetDPNID(),&pNTEntry)) != DPN_OK)
	{
		return(hResultCode);
	}
	DNASSERT(!pNTEntry->IsGroup());

	//
	//	Set the connection for this player
	//
	pNTEntry->Lock();
	if (pNTEntry->GetConnection() == NULL)
	{
		pNTEntry->SetConnection( pConnection );
	}
	DNASSERT( pNTEntry->IsConnecting() );
	DNASSERT( !pNTEntry->IsAvailable() );
	pNTEntry->StopConnecting();
	pNTEntry->MakeAvailable();
	pNTEntry->Unlock();

	//
	//	Add this player to the ALL_PLAYERS group and make the link active
	//
	if ((hResultCode = m_pdnObject->NameTable.GetAllPlayersGroupRef( &pAllPlayersGroup )) != DPN_OK)
	{
		DPFERR("Could not get ALL_PLAYERS_GROUP reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = m_pdnObject->NameTable.AddPlayerToGroup(	pAllPlayersGroup,
																pNTEntry,
																NULL)) != DPN_OK)
	{
		DPFERR("Could not add player to AllPlayersGroup");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAllPlayersGroup->Release();
	pAllPlayersGroup = NULL;

	fNotifyCreate = FALSE;
	pNTEntry->Lock();
	if (!pNTEntry->IsDisconnecting() && !pNTEntry->IsCreated())
	{
		//
		//	We will set the entry as InUse so that any receives will get queued.
		//	We will also addref the NotifyRefCount twice.  Once for the
		//	CREATE_PLAYER notification if there was no INDICATE_CONNECT
		//	(so that a corresponding release will generate the DESTROY_PLAYER),
		//	and a second one to prevent a premature release from generating
		//	the DESTROY_PLAYER before we return from CREATE_PLAYER.  We will
		//	therefore have to release the refcount as soon as the CREATE_PLAYER
		//	returns back to us from the user (setting the context value).
		//
		DNASSERT(!pNTEntry->IsInUse());
		pNTEntry->SetInUse();
		if (!pNTEntry->IsIndicated())
		{
			pNTEntry->NotifyAddRef();
		}
		pNTEntry->NotifyAddRef();
		fNotifyCreate = TRUE;
	}
	pNTEntry->Unlock();		// Release lock during notifications (CREATE_PLAYER, CONNECT_COMPLETE?)

	if (fNotifyCreate)
	{
		if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
		{
			DNUserCreatePlayer(m_pdnObject,pNTEntry);
		}

		//
		//	Process any queued messages for this player
		//
		pNTEntry->PerformQueuedOperations();
	}

	//
	//	Create any auto-destruct groups belonging to this player
	//
	AutoCreateGroups(pNTEntry);


	pNTEntry->Lock();

	//
	//	Ensure this entry is still available (might have been deleted)
	//
	if (!pNTEntry->IsAvailable() || pNTEntry->IsDisconnecting())
	{
		//
		//	Reduce outstanding connections (if required)
		//
		if (pNTEntry->GetVersion() <= m_dwConnectVersion)
		{
			DecOutstandingConnections();
		}
		pNTEntry->Unlock();
		goto Failure;
	}

	pBilink = pNTEntry->m_bilinkMembership.GetNext();
	while (pBilink != &pNTEntry->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);
		pGroupMember->AddRef();
		pNTEntry->Unlock();

		DNASSERT(pGroupMember->GetGroup() != NULL);
		DNASSERT(pGroupMember->GetPlayer() != NULL);

		fNotifyAddPlayerToGroup = FALSE;
		fNotifyRemovePlayerFromGroup = FALSE;

		pGroupMember->GetGroup()->Lock();
		pGroupMember->Lock();
		DNASSERT(pGroupMember->GetGroupConnection() != NULL);
		if (!pGroupMember->IsAvailable() && !pGroupMember->IsNeedToAdd() && !pGroupMember->GetGroupConnection()->IsConnected())
		{
			//
			//	We will only indicate this up if the group has been created
			//	We don't need to see if the player has been created since he should have been and the NotifyRefCount
			//		on the player's entry for this group member will still be there
			//
			if (	pGroupMember->GetGroup()->IsCreated()
				&&	!pGroupMember->GetGroup()->IsDisconnecting()
				&&	!pGroupMember->GetGroup()->IsAllPlayersGroup())
			{
				pGroupMember->SetNeedToAdd();
				fNotifyAddPlayerToGroup = TRUE;
			}
		}
		pGroupMember->GetGroup()->Unlock();
		pGroupMember->Unlock();

		if (fNotifyAddPlayerToGroup)
		{
			DNASSERT(pGroupMember->GetGroupConnection()->GetConnection() == NULL);
			pGroupMember->Lock();
			pGroupMember->GetGroupConnection()->Lock();
			pGroupMember->GetGroupConnection()->SetConnection(pConnection);
			pGroupMember->GetGroupConnection()->Unlock();
			pGroupMember->MakeAvailable();
			pGroupMember->Unlock();

			DNUserAddPlayerToGroup(	m_pdnObject,pGroupMember->GetGroup(),pGroupMember->GetPlayer());

			pGroupMember->Lock();
			pGroupMember->ClearNeedToAdd();
			if (pGroupMember->IsNeedToRemove())
			{
				fNotifyRemovePlayerFromGroup = TRUE;
			}
			pGroupMember->Unlock();
		}

		if (fNotifyRemovePlayerFromGroup)
		{
			DNUserRemovePlayerFromGroup(m_pdnObject,pGroupMember->GetGroup(),pGroupMember->GetPlayer());
		}

		//
		//	Release old group member and transfer reference
		//
		if (pOldGroupMember)
		{
			pOldGroupMember->Release();
			pOldGroupMember = NULL;
		}
		pOldGroupMember = pGroupMember;
		pGroupMember = NULL;

		pNTEntry->Lock();
		//
		//	Avoid infinite loops by ensuring that we are not on a "disconnected" entry
		//
		if ((pBilink->GetNext() != &pNTEntry->m_bilinkMembership) && (pBilink->GetNext() == pBilink))
		{
			//
			//	We have an invalid entry - need to restart
			//
			pBilink = pNTEntry->m_bilinkMembership.GetNext();
		}
		else
		{
			//
			//	We either have a valid entry or we're finished
			//
			pBilink = pBilink->GetNext();
		}
	}

	pNTEntry->Unlock();

	if (pOldGroupMember)
	{
		pOldGroupMember->Release();
		pOldGroupMember = NULL;
	}

	//
	//	Reduce outstanding connections
	//
	if (pNTEntry->GetVersion() <= m_dwConnectVersion)
	{
		DecOutstandingConnections();
	}

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DNASSERT(pNTEntry == NULL);
	DNASSERT(pGroupMember == NULL);
	DNASSERT(pOldGroupMember == NULL);

	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pAllPlayersGroup)
	{
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;
	}
	if (pGroupMember)
	{
		pGroupMember->Release();
		pGroupMember = NULL;
	}
	goto Exit;
}


//
//	This will generate ADD_PLAYER_TO_GROUP messages for all of the CREATE'd players in a group
//	(for whom a notification has not been posted)
//
#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::PopulateGroup"

HRESULT CNameTable::PopulateGroup(CNameTableEntry *const pGroup)
{
	HRESULT			hResultCode;
	BOOL			fNotifyAddPlayerToGroup;
	BOOL			fNotifyRemovePlayerFromGroup;
	CBilink			*pBilink;
	CGroupMember	*pGroupMember;
	CGroupMember	*pOldGroupMember;
	CNameTableEntry	*pPlayer;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p]",pGroup);

	DNASSERT(pGroup != NULL);

	hResultCode = DPN_OK;
	pPlayer = NULL;
	pGroupMember = NULL;
	pOldGroupMember = NULL;

	if (!pGroup->IsGroup())
	{
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	pGroup->Lock();
	pBilink = pGroup->m_bilinkMembership.GetNext();
	while (pBilink != &pGroup->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		pGroupMember->AddRef();
		pGroupMember->Lock();
		DNASSERT(pGroupMember->GetGroup() != NULL);
		DNASSERT(pGroupMember->GetPlayer() != NULL);
		DNASSERT(pGroupMember->GetGroup() == pGroup);
		pGroupMember->GetPlayer()->AddRef();
		pPlayer = pGroupMember->GetPlayer();
		pGroup->Unlock();
		pGroupMember->Unlock();

		fNotifyAddPlayerToGroup = FALSE;
		fNotifyRemovePlayerFromGroup = FALSE;

		pGroup->Lock();
		pPlayer->Lock();
		pGroupMember->Lock();
		DNASSERT( pGroupMember->GetGroupConnection() != NULL );
		if (	 pPlayer->IsCreated()
			&&	!pPlayer->IsDisconnecting()
			&&	 pGroup->IsCreated()
			&&	!pGroup->IsDisconnecting()
			&&	!pGroupMember->IsAvailable()
			&&	!pGroupMember->IsNeedToAdd()
			&&	!pGroupMember->GetGroupConnection()->IsConnected() )
		{
			pGroupMember->MakeAvailable();
			pGroupMember->SetNeedToAdd();
			fNotifyAddPlayerToGroup = TRUE;
		}
		pGroup->Unlock();
		pPlayer->Unlock();
		pGroupMember->Unlock();

		if (fNotifyAddPlayerToGroup)
		{
			DNUserAddPlayerToGroup(m_pdnObject,pGroup,pPlayer);

			pGroupMember->Lock();
			pGroupMember->ClearNeedToAdd();
			if (pGroupMember->IsNeedToRemove())
			{
				fNotifyRemovePlayerFromGroup = TRUE;
			}
			pGroupMember->Unlock();
		}
		if (fNotifyRemovePlayerFromGroup)
		{
			RemovePlayerFromGroup(pGroup,pPlayer,NULL);
		}

		pPlayer->Release();
		pPlayer = NULL;

		//
		//	Release old group member and transfer reference
		//
		if (pOldGroupMember)
		{
			pOldGroupMember->Release();
			pOldGroupMember = NULL;
		}
		pOldGroupMember = pGroupMember;
		pGroupMember = NULL;

		pGroup->Lock();
		if (pBilink->IsEmpty())
		{
			pBilink = pGroup->m_bilinkMembership.GetNext();
		}
		else
		{
			pBilink = pBilink->GetNext();
		}
	}
	pGroup->Unlock();

	if (pOldGroupMember)
	{
		pOldGroupMember->Release();
		pOldGroupMember = NULL;
	}

Exit:
	DNASSERT(pPlayer == NULL);
	DNASSERT(pGroupMember == NULL);
	DNASSERT(pOldGroupMember == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


//
//	This will generate CREATE_GROUP messages for all of the auto-destruct groups owned by a particular player
//
#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AutoCreateGroups"

HRESULT CNameTable::AutoCreateGroups(CNameTableEntry *const pPlayer)
{
	HRESULT			hResultCode;
	BOOL			fNotify;
	CBilink			*pBilink;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pOldGroup;

	DPFX(DPFPREP, 6,"Parameters: pPlayer [0x%p]",pPlayer);

	DNASSERT(pPlayer != NULL);

	pGroup = NULL;
	pOldGroup = NULL;

	if (pPlayer->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	ReadLock();

	pBilink = m_bilinkGroups.GetNext();
	while (pBilink != &m_bilinkGroups)
	{
		pGroup = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pGroup->AddRef();
		Unlock();

		fNotify = FALSE;
		pGroup->Lock();
		if (	pGroup->IsAutoDestructGroup()
			&&	(pGroup->GetOwner() == pPlayer->GetDPNID())
			&&	!pGroup->IsAvailable()
			&&	!pGroup->IsDisconnecting()	)
		{
			pGroup->MakeAvailable();
			pGroup->NotifyAddRef();
			pGroup->NotifyAddRef();
			pGroup->SetInUse();
			fNotify = TRUE;
		}
		pGroup->Unlock();

		if (fNotify)
		{
			DNASSERT(!pGroup->IsAllPlayersGroup());
			DNUserCreateGroup(m_pdnObject,pGroup);

			pGroup->PerformQueuedOperations();

			//
			//	Attempt to populate group with connected players
			//
			PopulateGroup(pGroup);
		}

		//
		//	Release old group and transfer reference
		//
		if (pOldGroup)
		{
			pOldGroup->Release();
			pOldGroup = NULL;
		}
		pOldGroup = pGroup;
		pGroup = NULL;

		ReadLock();
		if (pBilink->IsEmpty())
		{
			//
			//	We were removed from the list of groups, so re-start at the beginning
			//
			pBilink = m_bilinkGroups.GetNext();
		}
		else
		{
			pBilink = pBilink->GetNext();
		}
	}

	Unlock();

	if (pOldGroup)
	{
		pOldGroup->Release();
		pOldGroup = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DNASSERT(pGroup == NULL);
	DNASSERT(pOldGroup == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AutoDestructGroups"

HRESULT CNameTable::AutoDestructGroups(const DPNID dpnid)
{
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pOldNTEntry;

	pNTEntry = NULL;
	pOldNTEntry = NULL;

	ReadLock();
	pBilink = m_bilinkGroups.GetNext();
	while (pBilink != &m_bilinkGroups)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->AddRef();

		Unlock();

		if (pNTEntry->IsAutoDestructGroup() && (pNTEntry->GetOwner() == dpnid))
		{
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYGROUPREASON_AUTODESTRUCTED );
			}
			pNTEntry->Unlock();
			DeleteGroup(pNTEntry->GetDPNID(),NULL);
		}

		//
		//	Release old entry and transfer reference
		//
		if (pOldNTEntry)
		{
			pOldNTEntry->Release();
			pOldNTEntry = NULL;
		}
		pOldNTEntry = pNTEntry;
		pNTEntry = NULL;

		ReadLock();

		//
		//	Avoid infinite loops by ensuring that we are not on a "disconnected" entry
		//
		if ((pBilink->GetNext() != &m_bilinkGroups) && (pBilink->GetNext() == pBilink))
		{
			//
			//	We have an invalid entry - need to restart
			//
			pBilink = m_bilinkGroups.GetNext();
		}
		else
		{
			//
			//	We either have a valid entry or we're finished
			//
			pBilink = pBilink->GetNext();
		}
	}
	Unlock();

	if (pOldNTEntry)
	{
		pOldNTEntry->Release();
		pOldNTEntry = NULL;
	}

	DNASSERT(pNTEntry == NULL);
	DNASSERT(pOldNTEntry == NULL);

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DecOutstandingConnections"

void CNameTable::DecOutstandingConnections( void )
{
	LONG		lRefCount;

	lRefCount = DNInterlockedDecrement(&m_lOutstandingConnections);
	DNASSERT(lRefCount >= 0);
	if (lRefCount == 0)
	{
		CAsyncOp	*pConnectParent;

		pConnectParent = NULL;

		//
		//	Clear connect handle from DirectNetObject if we are connected
		//
		DNEnterCriticalSection(&m_pdnObject->csDirectNetObject);
		if (m_pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING))
		{
			DPFX(DPFPREP, 5,"Clearing connection operation from DirectNetObject");
			pConnectParent = m_pdnObject->pConnectParent;
			m_pdnObject->pConnectParent = NULL;
		}
		DNLeaveCriticalSection(&m_pdnObject->csDirectNetObject);

		if (pConnectParent)
		{
			//
			//	We will set the connect parent as complete and remove this from the parent's (if it exists - it will be the connect handle)
			//	bilink of children to prevent a race condition of the connect being cancelled from above
			//
			pConnectParent->Lock();
			pConnectParent->SetComplete();
			pConnectParent->Unlock();
			pConnectParent->Orphan();

			pConnectParent->Release();
			pConnectParent = NULL;
		}
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GetLocalPlayerRef"

HRESULT CNameTable::GetLocalPlayerRef( CNameTableEntry **const ppNTEntry )
{
	HRESULT		hResultCode;

	ReadLock();
	if (m_pLocalPlayer)
	{
		m_pLocalPlayer->AddRef();
		*ppNTEntry = m_pLocalPlayer;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_INVALIDPLAYER;
	}
	Unlock();
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GetHostPlayerRef"

HRESULT CNameTable::GetHostPlayerRef( CNameTableEntry **const ppNTEntry )
{
	HRESULT		hResultCode;

	ReadLock();
	if (m_pHostPlayer)
	{
		m_pHostPlayer->AddRef();
		*ppNTEntry = m_pHostPlayer;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_INVALIDPLAYER;
	}
	Unlock();
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GetAllPlayersGroupRef"

HRESULT CNameTable::GetAllPlayersGroupRef( CNameTableEntry **const ppNTEntry )
{
	HRESULT		hResultCode;

	ReadLock();
	if (m_pAllPlayersGroup)
	{
		m_pAllPlayersGroup->AddRef();
		*ppNTEntry = m_pAllPlayersGroup;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_INVALIDPLAYER;
	}
	Unlock();
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\msghandler.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MsgHandler.cpp
 *  Content:    DirectPlay Core/Protocol Interface
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/15/00	mjn		Created
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	04/08/00	mjn		Save SP with connections
 *	04/11/00	mjn		Use CAsyncOp for ENUMs
 *	04/13/00	mjn		Use Protocol Interface VTBL
 *	04/14/00	mjn		DNPICompleteListen sets status and SyncEvent
 *	04/17/00	mjn		DNPICompleteEnumQuery just sets return value of AsyncOp
 *	04/18/00	mjn		CConnection tracks connection status better
 *	04/21/00	mjn		Ensure that RECEIVEs are from a valid connection before passing up notifications
 *				mjn		Disconnect CONNECTing end points on errors
 *	04/22/00	mjn		Consume notifications when closing or disconnecting.
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	05/23/00	mjn		Call DNConnectToPeerFailed if ExistingPlayer connect to NewPlayer fails
 *	06/14/00	mjn		Allow only one connection to Host in DNPICompleteConnect()
 *	06/21/00	mjn		Modified DNSendMessage() and DNCreateSendParent() to use protocol voice bit
 *	06/22/00	mjn		Fixed DNPIIndicateReceive() to properly handle voice messages
 *				mjn		Cleaned up DNPIIndicateConnectionTerminated()
 *	06/24/00	mjn		Fixed DNPICompleteConnect()
 *	07/08/00	mjn		Only signal protocol shutdown event if it exists
 *	07/11/00	mjn		Fixed DNPIAddressInfoXXX() routines to ENUM,LISTEN,CONNECT multiple adapters with address info
 *	07/20/00	mjn		Modified CONNECT process, cleaned up refcount problems
 *	07/24/00	mjn		Decline EnumQueries if not host or if host is migrating
 *	07/28/00	mjn		Added code to validate return value from DPNICompleteSend()
 *	07/29/00	mjn		Fix calls to DNUserConnectionTerminated()
 *	07/30/00	mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *	08/02/00	mjn		Pass received voice messages through DNReceiveUserData()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added m_bilinkActiveList to CAsyncOp
 *	08/15/00	mjn		Call DNConnectToHostFailed() when connecting player's connection to host drops
 *	08/16/00	mjn		Modified IndicateConnect() and CompleteConnect() to determine SP directly from AsyncOps
 *	08/23/00	mjn		Unregister with DPNSVR when LISTENs terminate
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/06/00	mjn		Fixed DNPIIndicateConnectionTerminated() to better handle disconnects from partially connected players
 *	09/14/00	mjn		Release Protocol refcounts in completions
 *	09/21/00	mjn		Disconnect duplicate connections to Host player in DNPICompleteConnect()
 *	09/29/00	mjn		AddRef/Release locks in DNPIIndicateReceive()
 *	09/30/00	mjn		AddRef/Release locks in DNPIIndicateEnumQuery(),DNPIIndicateEnumResponse()
 *	10/11/00	mjn		Cancel outstanding CONNECTs if one succeeds
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *	02/08/01	mjn		Wait for cancels in DNPICompleteXXX()
 *				mjn		Wait for endpoint users in DNPIIndicateConnectionTerminated()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	04/05/01	mjn		Set destroy reason to DPNDESTROYPLAYERREASON_CONNECTIONLOST in DNPIIndicateConnectionTerminated()
 *	05/23/01	mjn		Cancel LISTEN's that have been flagged as cancelled in DNPICompleteListen()
 *	06/03/01	mjn		Orphan completed CONNECT's and DISCONNECT's
 *	06/25/01	mjn		Don't unregister with DPNSVR in DNPICompleteListenTerminate()
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateEnumQuery"

HRESULT DNPIIndicateEnumQuery(void *const pvUserContext,
							  void *const pvEndPtContext,
							  const HANDLE hCommand,
							  void *const pvEnumQueryData,
							  const DWORD dwEnumQueryDataSize)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;
	CNameTableEntry	*pLocalPlayer;
	BOOL			fReleaseLock;

	DPFX(DPFPREP, 6,"Parameters: pvEndPtContext [0x%p], hCommand [0x%p], pvEnumQueryData [0x%p], dwEnumQueryDataSize [%ld]",
			pvEndPtContext,hCommand,pvEnumQueryData,dwEnumQueryDataSize);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);

	pLocalPlayer = NULL;
	fReleaseLock = FALSE;

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvEndPtContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Don't perform this if host migrating
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) == DPN_OK)
	{
		if (pLocalPlayer->IsHost())
		{
#pragma TODO(minara,"The protocol should ensure that the LISTEN does not complete until this call-back returns")
#pragma TODO(minara,"As the context value (AsyncOp) needs to be valid !")
			DNProcessEnumQuery( pdnObject, pAsyncOp, reinterpret_cast<const PROTOCOL_ENUM_DATA*>( pvEnumQueryData ) );
		}
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateEnumResponse"

HRESULT DNPIIndicateEnumResponse(void *const pvUserContext,
								 const HANDLE hCommand,
								 void *const pvCommandContext,
								 void *const pvEnumResponseData,
								 const DWORD dwEnumResponseDataSize)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;
	BOOL			fReleaseLock;

	DPFX(DPFPREP, 6,"Parameters: hCommand [0x%p], pvCommandContext [0x%p], pvEnumResponseData [0x%p], dwEnumResponseDataSize [%ld]",
			hCommand,pvCommandContext,pvEnumResponseData,dwEnumResponseDataSize);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	fReleaseLock = FALSE;

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

#pragma TODO(minara,"The protocol should ensure that the ENUM does not complete until this call-back returns")
#pragma TODO(minara,"As the context value (AsyncOp) needs to be valid !")
	DNProcessEnumResponse(	pdnObject,
							pAsyncOp,
							reinterpret_cast<const PROTOCOL_ENUM_RESPONSE_DATA*>( pvEnumResponseData ));

	hResultCode = DPN_OK;

Exit:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}



//
//	When a new connection is indicated by the Protocol layer, we will perform some basic validation,
//	and then create a CConnection object for it
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateConnect"

HRESULT DNPIIndicateConnect(void *const pvUserContext,
							void *const pvListenContext,
							const HANDLE hEndPt,
							void **const ppvEndPtContext)
{
	HRESULT				hResultCode;
	CConnection			*pConnection;
	DIRECTNETOBJECT		*pdnObject;

#pragma TODO( minara, "Decline connections to non-hosting players and peers who are not expecting them")

	DPFX(DPFPREP, 6,"Parameters: pvListenContext [0x%p], hEndPt [0x%p], ppvEndPtContext [0x%p]",
			pvListenContext,hEndPt,ppvEndPtContext);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvListenContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	
	pConnection = NULL;

	//
	//	Allocate and set up a CConnection object and hand a reference to the Protocol
	//
	if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
	{
		DPFERR("Could not get new connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pConnection->SetStatus( CONNECTING );
	pConnection->SetEndPt(hEndPt);
	DNASSERT( (static_cast<CAsyncOp*>(pvListenContext))->GetParent() != NULL);
	DNASSERT( (static_cast<CAsyncOp*>(pvListenContext))->GetParent()->GetSP() != NULL);
	pConnection->SetSP((static_cast<CAsyncOp*>(pvListenContext))->GetParent()->GetSP());
	pConnection->AddRef();
	*ppvEndPtContext = pConnection;

	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DPFERR("CONNECT indicated while closing or disconnecting");
		DNPerformDisconnect(pdnObject,pConnection,hEndPt,FALSE);
		goto Failure;
	}

	DNASSERT(pdnObject->NameTable.GetLocalPlayer() != NULL);
	if (pdnObject->NameTable.GetLocalPlayer()->IsHost())
	{
		// This connect was detected by a host player
		DPFX(DPFPREP, 7,"Host received connection attempt");

		//
		//	Ensure we're not connecting (still in Host()) or drop the connection
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING)
		{
			pConnection->Disconnect();
			goto Failure;
		}
	}
	else
	{
		// This connect was detected by a peer player (should be expecting a connection)
		DPFX(DPFPREP, 7,"Non-Host player received connection attempt");
	}

	//
	//	Add this entry to the bilink of indicated connections.  When we receive more info,
	//	or this connection is terminated, we will remove this entry from the bilink.
	//	This will enable us to clean up properly.
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	pConnection->AddRef();
	pConnection->m_bilinkIndicated.InsertBefore(&pdnObject->m_bilinkIndicated);
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateDisconnect"

HRESULT DNPIIndicateDisconnect(void *const pvUserContext,
							   void *const pvEndPtContext)
{
	HRESULT			hResultCode;
	CConnection		*pConnection;
	DIRECTNETOBJECT	*pdnObject;
	CNameTableEntry	*pNTEntry;

	DPFX(DPFPREP, 6,"Parameters: pvEndPtContext [0x%p]",
			pvEndPtContext);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pConnection = static_cast<CConnection*>(pvEndPtContext);

	//
	//	Mark the connection as DISCONNECTing so that we don't use it any more
	//
	pConnection->Lock();
	pConnection->SetStatus( DISCONNECTING );
	pConnection->Unlock();

	if (pConnection->GetDPNID() == 0)
	{
		if (pdnObject->NameTable.GetLocalPlayer() && pdnObject->NameTable.GetLocalPlayer()->IsHost())
		{
			DPFX(DPFPREP, 7,"Joining player has issued a disconnect to Host (local) player");
		}
		else
		{
			DPFX(DPFPREP, 7,"Host has issued a disconnect to Joining (local) player");
		}
	}
	else
	{
		DNASSERT(!(pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT));

		if (pdnObject->NameTable.GetLocalPlayer() && pdnObject->NameTable.GetLocalPlayer()->IsHost())
		{
			DPFX(DPFPREP, 7,"Connected player has issued a disconnect to Host (local) player");
		}
		else
		{
			DPFX(DPFPREP, 7,"Connected player has issued a disconnect to local player");
		}

		//
		//	Mark this player for normal destruction since they disconnected and are playing nice
		//
		if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) == DPN_OK)
		{
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
			}
			pNTEntry->Unlock();
			pNTEntry->Release();
			pNTEntry = NULL;
		}
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateConnectionTerminated"

HRESULT DNPIIndicateConnectionTerminated(void *const pvUserContext,
										 void *const pvEndPtContext,
										 const HRESULT hr)
{
	HRESULT			hResultCode;
	CConnection		*pConnection;
	DIRECTNETOBJECT	*pdnObject;
	BOOL			fWasConnecting;
	CBilink			*pBilink;
	DWORD			dwCount;
	CSyncEvent		*pSyncEvent;

	DPFX(DPFPREP, 6,"Parameters: pvEndPtContext [0x%p], hr [0x%lx]",pvEndPtContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);

	pSyncEvent = NULL;

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pConnection = static_cast<CConnection*>(pvEndPtContext);

	//
	//	pConnection should still have at least 1 reference on it at this stage since
	//	INDICATE_CONNECTION_TERMINATED is supposed to be the final release for it.
	//	All outstanding SENDs and RECEIVEs should have already been processed.
	//
	//	If there are any users of the endpoint, then we will need to wait for them
	//	to be done with it.  To do this, we will count the number of threads using
	//	the endpoint (not including any occurances of THIS thread), and set the count
	//	and an event on the Connection
	//

	fWasConnecting = FALSE;
	pConnection->Lock();
	if (pConnection->IsConnecting())
	{
		fWasConnecting = TRUE;
	}
	pConnection->SetStatus( INVALID );

	dwCount = 0;
	pBilink = pConnection->m_bilinkCallbackThreads.GetNext();
	while (pBilink != &pConnection->m_bilinkCallbackThreads)
	{
		if (!(CONTAINING_CALLBACKTHREAD(pBilink))->IsCurrentThread())
		{
			dwCount++;
		}
		pBilink = pBilink->GetNext();
	}
	if (dwCount != 0)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not get sync event - ignore and continue (we will not wait!)");
			dwCount = 0;
		}
		else
		{
			pConnection->SetThreadCount( dwCount );
			pConnection->SetThreadEvent( pSyncEvent );
		}
	}
	pConnection->Unlock();

	if (dwCount)
	{
		DNASSERT(pSyncEvent != NULL);

		pSyncEvent->WaitForEvent();
		pConnection->Lock();
		pConnection->SetThreadEvent( NULL );
		pConnection->Unlock();
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}

	//
	//	Remove this connection from the indicated connection list
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	if (!pConnection->m_bilinkIndicated.IsEmpty())
	{
		pConnection->Release();
	}
	pConnection->m_bilinkIndicated.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	//
	//	If we are a client (in client server), and the server has disconnected from us, we have to shut down
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		if (fWasConnecting)
		{
			DPFX(DPFPREP, 7,"Server disconnected from local connecting client - failing connect");
		}
		else
		{
			DPFX(DPFPREP, 7,"Server disconnected from local client - shutting down");

			//
			//	Only inform the user if they are IN the session
			//
			if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
			{
				DNUserTerminateSession(pdnObject,DPNERR_CONNECTIONLOST,NULL,0);
			}
			DNTerminateSession(pdnObject,DPNERR_CONNECTIONLOST);
		}
	}
#ifndef	DPNBUILD_NOSERVER
	else if (pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
	{
		if (fWasConnecting || (pConnection->GetDPNID() == 0))
		{
			DPFX(DPFPREP, 7,"Unconnected client has disconnected from server");
		}
		else
		{
			CNameTableEntry	*pNTEntry;
			DWORD			dwReason;

			pNTEntry = NULL;

			//
			//	If the destruction code has not been set, mark as CONNECTIONLOST
			//
			if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) == DPN_OK)
			{
				pNTEntry->Lock();
				if (pNTEntry->GetDestroyReason() == 0)
				{
					pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_CONNECTIONLOST );
				}
				dwReason = pNTEntry->GetDestroyReason();
				pNTEntry->Unlock();
				pNTEntry->Release();
				pNTEntry = NULL;
			}
			else
			{
				dwReason = DPNDESTROYPLAYERREASON_CONNECTIONLOST;
			}

			DNHostDisconnect(pdnObject,pConnection->GetDPNID(),dwReason);
		}
	}
#endif	// DPNBUILD_NOSERVER
	else //	DN_OBJECT_FLAG_PEER
	{
		DNASSERT( pdnObject->dwFlags & DN_OBJECT_FLAG_PEER );

		if (fWasConnecting || (pConnection->GetDPNID() == 0))
		{
			DPFX(DPFPREP, 7,"Unconnected peer has disconnected from local peer");
			CAsyncOp	*pConnectParent;

			pConnectParent = NULL;

			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING)
			{
				pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED
										| DN_OBJECT_FLAG_CONNECTING
										| DN_OBJECT_FLAG_HOST_CONNECTED));
				if (pdnObject->pConnectParent)
				{
					pConnectParent = pdnObject->pConnectParent;
					pdnObject->pConnectParent = NULL;
				}
				if( pdnObject->pIDP8ADevice )
				{
					IDirectPlay8Address_Release( pdnObject->pIDP8ADevice );
					pdnObject->pIDP8ADevice = NULL;
				}
				if( pdnObject->pConnectAddress )
				{
					IDirectPlay8Address_Release( pdnObject->pConnectAddress );
					pdnObject->pConnectAddress = NULL;
				}
			}
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

			if (pConnectParent)
			{
				pConnectParent->Release();
				pConnectParent = NULL;
			}

			DNASSERT(pConnectParent == NULL);
		}
		else
		{
			CNameTableEntry	*pNTEntry;
			CNameTableEntry	*pLocalPlayer;
			DWORD			dwReason;

			pNTEntry = NULL;
			pLocalPlayer = NULL;

			//
			//	If the destruction code has not been set, mark as CONNECTIONLOST
			//
			if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) == DPN_OK)
			{
				pNTEntry->Lock();
				if (pNTEntry->GetDestroyReason() == 0)
				{
					pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_CONNECTIONLOST );
				}
				dwReason = pNTEntry->GetDestroyReason();
				pNTEntry->Unlock();
				pNTEntry->Release();
				pNTEntry = NULL;
			}
			else
			{
				dwReason = DPNDESTROYPLAYERREASON_CONNECTIONLOST;
			}

			//
			//	Based on who we are, and who's disconnecting, we will have different behaviour
			//
			if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer)) == DPN_OK)
			{
				if (pLocalPlayer->IsHost())
				{
					DPFX(DPFPREP, 7,"Connected peer has disconnected from Host");
					DNHostDisconnect(pdnObject,pConnection->GetDPNID(),dwReason);
				}
				else
				{
					DPFX(DPFPREP, 7,"Peer has disconnected from non-Host peer");
					DNPlayerDisconnectNew(pdnObject,pConnection->GetDPNID());
				}
				pLocalPlayer->Release();
				pLocalPlayer = NULL;
			}
		}
	}

	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateReceive"

HRESULT DNPIIndicateReceive(void *const pvUserContext,
							void *const pvEndPtContext,
							void *const pvData,
							const DWORD dwDataSize,
							const HANDLE hBuffer,
							const DWORD dwFlags)
{
	HRESULT		hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	void			*pvInternalData;
	DWORD			dwInternalDataSize;
	CConnection		*pConnection;
	DWORD			*pdwMsgId;
	BOOL 			fReleaseLock;

	DPFX(DPFPREP, 6,"Parameters: pvEndPtContext [0x%p], pvData [0x%p], dwDataSize [%ld], hBuffer [0x%p], dwFlags [0x%lx]",
			pvEndPtContext,pvData,dwDataSize,hBuffer,dwFlags);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);
	DNASSERT(pvData != NULL);
	DNASSERT(((DWORD_PTR) pvData & 3) == 0);	// data should be DWORD aligned
	DNASSERT(dwDataSize != 0);
	DNASSERT(hBuffer != NULL);

	fReleaseLock = FALSE;
	
	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pConnection = static_cast<CConnection*>(pvEndPtContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Ensure that this is a valid connection
	//
	if (!pConnection->IsConnected() && !pConnection->IsConnecting())
	{
		hResultCode = DPN_OK;
		goto Failure;
	}

	pConnection->AddRef();

	if ((dwFlags & DN_SENDFLAGS_SET_USER_FLAG) && !(dwFlags & DN_SENDFLAGS_SET_USER_FLAG_TWO))
	{
		//
		//	Internal message
		//
		DPFX(DPFPREP, 7,"Received INTERNAL message");

		DNASSERT(dwDataSize >= sizeof(DWORD));
		pdwMsgId = static_cast<DWORD*>(pvData);
		dwInternalDataSize = dwDataSize - sizeof(DWORD);
		if (dwInternalDataSize > 0)
		{
			pvInternalData = static_cast<void*>(static_cast<BYTE*>(pvData) + sizeof(DWORD));
		}
		else
		{
			pvInternalData = NULL;
		}

		hResultCode = DNProcessInternalOperation(	pdnObject,
													*pdwMsgId,
													pvInternalData,
													dwInternalDataSize,
													pConnection,
													hBuffer,
													NULL );
	}
	else
	{
		//
		//	User or voice message
		//
		DPFX(DPFPREP, 7,"Received USER or Voice message");

		hResultCode = DNReceiveUserData(pdnObject,
										pConnection,
										static_cast<BYTE*>(pvData),
										dwDataSize,
										hBuffer,
										NULL,
										0,
										dwFlags);
	}

	//
	//	Only allow DPNERR_PENDING or DPN_OK
	//
	if (hResultCode != DPNERR_PENDING)
	{
		hResultCode = DPN_OK;
	}

	pConnection->Release();
	pConnection = NULL;

Exit:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteListen"

HRESULT DNPICompleteListen(void *const pvUserContext,
						   void **const ppvCommandContext,
						   const HRESULT hr,
						   const HANDLE hCommand)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*pParent;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: ppvCommandContext [0x%p], hr [0x%lx], hCommand [0x%p]",
			ppvCommandContext,hr,hCommand);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(ppvCommandContext != NULL);
	DNASSERT(*ppvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(*ppvCommandContext);

	pParent = NULL;

	//
	//	AddRef pAsyncOp to keep it around in case a CompleteListenTerminated is posted
	//
	pAsyncOp->AddRef();

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If the LISTEN was cancelled and has been started successfully, we will need to shut it down.
	//	Otherwise, we will keep the result of the LISTEN attempt
	//
	DNASSERT(pAsyncOp->GetResultPointer() != NULL);
	if (hr == DPN_OK)
	{
		if (pAsyncOp->IsCancelled())
		{
			HRESULT	hrCancel;

			if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hCommand)) == DPN_OK)
			{
				*(pAsyncOp->GetResultPointer()) = DPNERR_USERCANCEL;
			}
			else
			{
				*(pAsyncOp->GetResultPointer()) = DPNERR_GENERIC;
			}
		}
		else
		{
			//
			//	We probably don't have to lock pAsyncOp to clear the CANNOT_CANCEL, but better safe than sorry
			//
			pAsyncOp->Lock();
			pAsyncOp->ClearCannotCancel();
			pAsyncOp->SetResult( hr );
			pAsyncOp->Unlock();
			*(pAsyncOp->GetResultPointer()) = hr;
		}
	}
	else
	{
		*(pAsyncOp->GetResultPointer()) = hr;
	}

	//
	//	Set SyncEvent
	//
	DNASSERT(pAsyncOp->GetSyncEvent() != NULL);
	pAsyncOp->GetSyncEvent()->Set();

	//
	//	If there was an SP parent, we will check to see if this is the last completion and then set the
	//	parent's SP listen event (if it exists)
	//
	if (pParent)
	{
#ifndef DPNBUILD_ONLYONEADAPTER
		DN_LISTEN_OP_DATA	*pListenOpData;

		pListenOpData = pParent->GetLocalListenOpData();

		if (pListenOpData->dwCompleteAdapters < pListenOpData->dwNumAdapters)
		{
			pListenOpData->dwCompleteAdapters++;
			if (pListenOpData->dwCompleteAdapters == pListenOpData->dwNumAdapters)
			{
				if (pListenOpData->pSyncEvent)
				{
					pListenOpData->pSyncEvent->Set();
					pListenOpData->pSyncEvent = NULL;
				}
			}
		}
#endif // ! DPNBUILD_ONLYONEADAPTER
		pParent->Release();
		pParent = NULL;
	}

	//
	//	Done with pAsyncOp - release reference taken earlier
	//
	pAsyncOp->Release();

	hResultCode = DPN_OK;

	DNASSERT( pParent == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteListenTerminate"

HRESULT DNPICompleteListenTerminate(void *const pvUserContext,
									void *const pvCommandContext,
									const HRESULT hr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);


	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	DNASSERT(pAsyncOp->IsChild());
	pAsyncOp->Orphan();

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteEnumQuery"

HRESULT DNPICompleteEnumQuery(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_ENUM_QUERY );

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	pAsyncOp->SetResult( hr );
	pAsyncOp->Orphan();

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release Protocol reference
	//
	DNProtocolRelease(pdnObject);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteEnumResponse"

HRESULT DNPICompleteEnumResponse(void *const pvUserContext,
								 void *const pvCommandContext,
								 const HRESULT hr)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_ENUM_RESPONSE );

	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	if (pAsyncOp->IsChild())
	{
		DNASSERT(FALSE);
		pAsyncOp->Orphan();
	}
	if (SUCCEEDED(pdnObject->HandleTable.Destroy( pAsyncOp->GetHandle(), NULL )))
	{
		// Release the HandleTable reference
		pAsyncOp->Release();
	}
	pAsyncOp->SetResult( hr );

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release protocol reference
	//
	DNProtocolRelease(pdnObject);

	hResultCode = DPN_OK;
	
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteConnect"

HRESULT DNPICompleteConnect(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hrProt,
							const HANDLE hEndPt,
							void **const ppvEndPtContext)
{
	HRESULT				hResultCode;
	HRESULT				hr;
	CAsyncOp			*pAsyncOp;
	CConnection			*pConnection;
	DIRECTNETOBJECT		*pdnObject;
	IDirectPlay8Address	*pIDevice;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hrProt [0x%lx], hEndPt [0x%p], ppvEndPtContext [0x%p]",
			pvCommandContext,hrProt,hEndPt,ppvEndPtContext);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);
	DNASSERT( (hrProt != DPN_OK) || (ppvEndPtContext != NULL) );

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_CONNECT );

	pConnection = NULL;
	pIDevice = NULL;

	//
	//	Re-map DPNERR_ABORTED (!)
	//
	if (hrProt == DPNERR_ABORTED)
	{
		hr = DPNERR_USERCANCEL;
	}
	else
	{
		hr = hrProt;
	}

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	if (pAsyncOp->IsChild())
	{
		pAsyncOp->Orphan();
	}

	//
	//	If there is a DPNID associated with this operation, then we are an ExistingPlayer
	//	connecting with a NewPlayer.  If there is no DPNID, then we are a NewPlayer connecting
	//	to the Host.
	//

	if (pAsyncOp->GetDPNID())
	{
		DPFX(DPFPREP, 7,"CONNECT completed for existing player connecting to NewPlayer");

		//
		//	We are an existing player attempting to CONNECT to a NewPlayer.
		//	If this CONNECT failed, we must inform the Host
		//
		if (hr != DPN_OK)
		{
			DPFERR("Could not CONNECT to NewPlayer");
			DisplayDNError(0,hr);
			DNConnectToPeerFailed(pdnObject,pAsyncOp->GetDPNID());
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Allocate and set up a CConnection object and hand a reference to the Protocol
		//
		DNASSERT(pAsyncOp->GetSP() != NULL);
		if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
		{
			DPFERR("Could not get new connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnection->SetStatus( CONNECTING );
		pConnection->SetEndPt(hEndPt);
		pConnection->SetSP(pAsyncOp->GetSP());
		pConnection->AddRef();
		*ppvEndPtContext = pConnection;

		//
		//	Send this player's DNID to the connecting player to enable name table entry
		//
		if ((hResultCode = DNConnectToPeer3(pdnObject,pAsyncOp->GetDPNID(),pConnection)) != DPN_OK)
		{
			DPFERR("Could not connect to NewPlayer");
			DisplayDNError(0,hr);
			DNPerformDisconnect(pdnObject,pConnection,hEndPt,FALSE);
			DNConnectToPeerFailed(pdnObject,pAsyncOp->GetDPNID());
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 7,"CONNECT completed for NewPlayer connecting to Host");

		//
		//	We are the NewPlayer attempting to CONNECT to the Host.
		//

		//
		//	If this CONNECT succeeded, we will cancell any other CONNECTs.
		//	If this CONNECT failed, we will set the result code on the AsyncOp
		//	and release it.
		//
		if (hr == DPN_OK)
		{
			CAsyncOp	*pParent;

			pParent = NULL;

			pAsyncOp->Lock();
			if (pAsyncOp->GetParent())
			{
				pAsyncOp->GetParent()->AddRef();
				pParent = pAsyncOp->GetParent();
			}
			pAsyncOp->Unlock();
			if (pParent)
			{
				DNCancelChildren(pdnObject,pParent);
				pParent->Release();
				pParent = NULL;
			}

			DNASSERT(pParent == NULL);
		}
		else
		{
			DPFERR("Could not CONNECT to Host");
			DisplayDNError(0,hr);
			pAsyncOp->SetResult( hr );
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Allocate and set up a CConnection object and hand a reference to the Protocol
		//
		DNASSERT(pAsyncOp->GetSP() != NULL);
		if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
		{
			DPFERR("Could not get new connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnection->SetStatus( CONNECTING );
		pConnection->SetEndPt(hEndPt);
		pConnection->SetSP(pAsyncOp->GetSP());
		pConnection->AddRef();
		*ppvEndPtContext = pConnection;

		//
		//	Ensure that this is the first CONNECT to succeed.
		//	If it isn't we will just drop the connection.
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_CONNECTED)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			DPFERR("Connect already established - disconnecting");
			DNPerformDisconnect(pdnObject,pConnection,hEndPt,FALSE);
			hResultCode = DPN_OK;
			goto Failure;
		}
		pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_CONNECTED;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		// rodtoll: Modifying so we always store this information so that when we update
		// 		  lobby settings we return the device we actually connected on for clients

		/*
		//
		//	For Peer-Peer, we will need the device address we connected on so that
		//	we can CONNECT to new players later on.
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{*/
			if ((hResultCode = DNGetLocalDeviceAddress(pdnObject,hEndPt,&pIDevice)) != DPN_OK)
			{
				DPFERR("Could not determine local address");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				DNPerformDisconnect(pdnObject,pConnection,hEndPt,FALSE);
				goto Failure;
			}
			IDirectPlay8Address_AddRef(pIDevice);
			pdnObject->pIDP8ADevice = pIDevice;

			IDirectPlay8Address_Release(pIDevice);
			pIDevice = NULL;
		// }

		//
		//	Send player and application info for NewPlayer connecting to Host
		//
		if ((hResultCode = DNConnectToHost1(pdnObject,pConnection)) != DPN_OK)
		{
			DPFERR("Could not CONNECT to Host");
			DisplayDNError(0,hResultCode);
			DNPerformDisconnect(pdnObject,pConnection,hEndPt,FALSE);
			goto Failure;
		}
	}
	pAsyncOp->Lock();
	pAsyncOp->SetResult( DPN_OK );
	pAsyncOp->Unlock();

	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

Exit:
	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pAsyncOp);

	DNASSERT(pAsyncOp != NULL);
	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release protocol reference
	//
	DNProtocolRelease(pdnObject);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pIDevice)
	{
		IDirectPlay8Address_Release(pIDevice);
		pIDevice = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteDisconnect"

HRESULT DNPICompleteDisconnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_DISCONNECT );

	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	if (pAsyncOp->IsChild())
	{
		pAsyncOp->Orphan();
	}

	//
	//	If this completed successfully, we can remove the reference on the connection held by the Protocol
	//
	if (hr == DPN_OK)
	{
		pAsyncOp->Lock();
		if (pAsyncOp->GetConnection())
		{
			pAsyncOp->GetConnection()->Release();
		}
		pAsyncOp->Unlock();
	}

	pAsyncOp->SetResult( hr );

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release Protocol reference
	//
	DNProtocolRelease(pdnObject);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteSend"

HRESULT DNPICompleteSend(void *const pvUserContext,
						 void *const pvCommandContext,
						 const HRESULT hr,
						 DWORD dwFirstFrameRTT,
						 DWORD dwFirstFrameRetryCount)
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx], dwFirstFrameRTT [%i], dwFirstFrameRetryCount [%u]",
			pvCommandContext,hr,dwFirstFrameRTT,dwFirstFrameRetryCount);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_SEND );

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	switch( hr )
	{
		case	DPN_OK:
		case	DPNERR_ABORTED:
#pragma TODO( minara, "remove DPNERR_ABORTED" )
		case	DPNERR_CONNECTIONLOST:
		case	DPNERR_GENERIC:	
		case	DPNERR_OUTOFMEMORY:
		case	DPNERR_TIMEDOUT:
		case	DPNERR_USERCANCEL:
			{
				break;
			}

		default:
			{
				DNASSERT(FALSE);	// unexpected return code !
				break;
			}
	}

	if (pAsyncOp->IsChild())
	{
		pAsyncOp->Orphan();
	}
	pAsyncOp->SetResult( hr );
	pAsyncOp->SetFirstFrameRTT( dwFirstFrameRTT );
	pAsyncOp->SetFirstFrameRetryCount( dwFirstFrameRetryCount );

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pAsyncOp);

	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release Protocol reference
	//
	DNProtocolRelease(pdnObject);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIAddressInfoConnect"

HRESULT DNPIAddressInfoConnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr,
							   IDirectPlay8Address *const pHostAddress,
							   IDirectPlay8Address *const pDeviceAddress )
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;
#ifdef DBG
	TCHAR			DP8ABuffer[512] = {0};
	DWORD			DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);
	DNASSERT(pHostAddress != NULL);
	DNASSERT(pDeviceAddress != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DPFX(DPFPREP, 7,"hr [0x%lx]",hr);
#ifdef DBG
	DP8ASize = 512;
	IDirectPlay8Address_GetURL(pHostAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Host address [%s]",DP8ABuffer);

	DP8ASize = 512;
	IDirectPlay8Address_GetURL(pDeviceAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Device address [%s]",DP8ABuffer);
#endif // DBG

	hResultCode = DNPerformNextConnect(pdnObject,pAsyncOp,pHostAddress,pDeviceAddress);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIAddressInfoEnum"

HRESULT DNPIAddressInfoEnum(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hr,
							IDirectPlay8Address *const pHostAddress,
							IDirectPlay8Address *const pDeviceAddress )
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;

#ifdef DBG
	TCHAR			DP8ABuffer[512] = {0};
	DWORD			DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);
	DNASSERT(pHostAddress != NULL);
	DNASSERT(pDeviceAddress != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DPFX(DPFPREP, 7,"hr [0x%lx]",hr);
#ifdef DBG
	DP8ASize = 512;
	IDirectPlay8Address_GetURL(pHostAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Host address [%s]",DP8ABuffer);

	DP8ASize = 512;
	IDirectPlay8Address_GetURL(pDeviceAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Device address [%s]",DP8ABuffer);
#endif // DBG

	//
	//	Crack open next enum only if not closing
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) == DPN_OK)
	{
		hResultCode = DNPerformNextEnumQuery(pdnObject,pAsyncOp,pHostAddress,pDeviceAddress);
		DNDecRefLock(pdnObject);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIAddressInfoListen"

HRESULT DNPIAddressInfoListen(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr,
							  IDirectPlay8Address *const pDeviceAddress )
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;
#ifdef DBG
	TCHAR			DP8ABuffer[512] = {0};
	DWORD			DP8ASize;
#endif // DBG

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);
	DNASSERT(pDeviceAddress != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

#ifdef DBG
	DP8ASize = 512;
	IDirectPlay8Address_GetURL(pDeviceAddress,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Device address [%s]",DP8ABuffer);
#endif // DBG

#ifndef DPNBUILD_ONLYONEADAPTER
	hResultCode = DNPerformNextListen(pdnObject,pAsyncOp,pDeviceAddress);
#endif // ! DPNBUILD_ONLYONEADAPTER

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#ifndef DPNBUILD_NOMULTICAST


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateReceiveUnknownSender"

HRESULT DNPIIndicateReceiveUnknownSender(void *const pvUserContext,
											void *const pvListenCommandContext,
											IDirectPlay8Address *const pSenderAddress,
											void *const pvData,
											const DWORD dwDataSize,
											const HANDLE hBuffer)
{
	HRESULT					hResultCode;
	DIRECTNETOBJECT			*pdnObject;
	CAsyncOp				*pAsyncOpListen;
	SPGETADDRESSINFODATA	spInfoData;
	CAsyncOp				*pAsyncOpReceive;
	DPNHANDLE				hAsyncOpReceive;
	BOOL 					fReleaseLock;

	DPFX(DPFPREP, 6,"Parameters: pvListenCommandContext [0x%p], pSenderAddress [0x%p], pvData [0x%p], dwDataSize [%ld], hBuffer [0x%p]",
			pvListenCommandContext,pSenderAddress,pvData,dwDataSize,hBuffer);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvListenCommandContext != NULL);
	DNASSERT(pSenderAddress != NULL);
	DNASSERT(pvData != NULL);
	DNASSERT(((DWORD_PTR) pvData & 3) == 0);	// data should be DWORD aligned
	DNASSERT(dwDataSize != 0);
	DNASSERT(hBuffer != NULL);

	memset(&spInfoData, 0, sizeof(spInfoData));
	fReleaseLock = FALSE;
	pAsyncOpReceive = NULL;
	hAsyncOpReceive = NULL;
	
	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOpListen = static_cast<CAsyncOp*>(pvListenCommandContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		DPFX(DPFPREP, 1, "Couldn't lock object (0x%lx), ignoring data.", hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Ensure that this is a valid async op
	//
	if (pAsyncOpListen->GetOpType() != ASYNC_OP_LISTEN_MULTICAST)
	{
		DPFX(DPFPREP, 0, "Receiving data from unknown sender on non-listen-multicast operation (0x%p, type %u)!",
			pAsyncOpListen, pAsyncOpListen->GetOpType());
		DNASSERTX(FALSE, 2);
		hResultCode = DPN_OK;
		goto Failure;
	}

	//
	//	User or voice message
	//
	DPFX(DPFPREP, 7,"Received USER message from unknown sender");

	spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
	if ((hResultCode = DNPGetListenAddressInfo(pdnObject->pdnProtocolData,pAsyncOpListen->GetProtocolHandle(),&spInfoData)) != DPN_OK)
	{
		DPFERR("Could not get LISTEN device address!");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Create an AsyncOp for this receive
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOpReceive)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pdnObject->HandleTable.Create(pAsyncOpReceive,&hAsyncOpReceive)) != DPN_OK)
	{
		DPFERR("Could not create Handle for AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	else
	{
		// Add a reference for the HandleTable
		pAsyncOpReceive->AddRef();
		pAsyncOpReceive->Lock();
		pAsyncOpReceive->SetHandle(hAsyncOpReceive);
		pAsyncOpReceive->Unlock();
	}
	pAsyncOpReceive->SetOpType( ASYNC_OP_RECEIVE_BUFFER );
	pAsyncOpReceive->SetSP( pAsyncOpListen->GetSP() );

	//
	//	Add buffer to list of active AsyncOp's
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOpReceive->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	hResultCode = DNUserReceiveMulticast(pdnObject,
										NULL,
										pSenderAddress,
										spInfoData.pAddress,
										static_cast<BYTE*>(pvData),
										dwDataSize,
										hAsyncOpReceive);

	if (hResultCode == DPNERR_PENDING)
	{
		pAsyncOpReceive->SetProtocolHandle( hBuffer );
		pAsyncOpReceive->SetCompletion(DNCompleteReceiveBuffer);
	}
	else
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOpReceive->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOpReceive->Lock();
		if (!pAsyncOpReceive->IsCancelled() && !pAsyncOpReceive->IsComplete())
		{
			pAsyncOpReceive->SetComplete();
			pAsyncOpReceive->Unlock();
			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOpReceive, NULL )))
			{
				// Release the HandleTable reference
				pAsyncOpReceive->Release();
			}
			hAsyncOpReceive = NULL;
		}
		else
		{
			pAsyncOpReceive->Unlock();
		}
		//
		//	Only allow DPNERR_PENDING or DPN_OK
		//
		hResultCode = DPN_OK;
	}

	IDirectPlay8Address_Release(spInfoData.pAddress);
	spInfoData.pAddress = NULL;

	DNDecRefLock(pdnObject);
	fReleaseLock = FALSE;
	
	pAsyncOpReceive->Release();
	pAsyncOpReceive = NULL;

Exit:

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (hAsyncOpReceive)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOpReceive->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOpReceive, NULL )))
		{
			// Release the HandleTable reference
			pAsyncOpReceive->Release();
		}
		hAsyncOpReceive = 0;
	}
	if (pAsyncOpReceive)
	{
		pAsyncOpReceive->Release();
		pAsyncOpReceive = NULL;
	}
	if (spInfoData.pAddress != NULL)
	{
		IDirectPlay8Address_Release(spInfoData.pAddress);
		spInfoData.pAddress = NULL;
	}
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteMulticastConnect"

HRESULT DNPICompleteMulticastConnect(void *const pvUserContext,
									 void *const pvCommandContext,
									 const HRESULT hrProt,
									 const HANDLE hEndPt,
									 void **const ppvEndPtContext)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	CAsyncOp		*pConnectParent;
	CConnection		*pConnection;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 6,"Parameters: pvCommandContext [0x%p], hrProt [0x%lx], hEndPt [0x%p]",
			pvCommandContext,hrProt,hEndPt);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pConnection = NULL;

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DNASSERT( pAsyncOp->GetOpType() == ASYNC_OP_CONNECT_MULTICAST_SEND || pAsyncOp->GetOpType() == ASYNC_OP_CONNECT_MULTICAST_RECEIVE );

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	DNASSERT(!pAsyncOp->IsComplete());
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Clear connect parent from DirectNet object
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pConnectParent = pdnObject->pConnectParent;
	pdnObject->pConnectParent = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	//
	//	Save multicast endpoint if this was successful
	//
	if (hrProt == DPN_OK)
	{
		//
		//	Allocate and set up a CConnection object and hand a reference to the Protocol
		//
		DNASSERT(pAsyncOp->GetSP() != NULL);
		if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
		{
			DPFERR("Could not get new connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnection->SetStatus( CONNECTED );
		pConnection->SetEndPt(hEndPt);
		pConnection->SetSP(pAsyncOp->GetSP());
		pConnection->AddRef();
		*ppvEndPtContext = pConnection;

		if (pAsyncOp->GetOpType() == ASYNC_OP_CONNECT_MULTICAST_SEND)
		{
			//
			//	We will keep a reference on the connection object on the DirectNet object
			//
			pConnection->MakeMulticastSender();
			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			pdnObject->pMulticastSend = pConnection;
			pConnection = NULL;
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		}
		else
		{
			//
			//	We will keep a reference on the connection object in the list off the DirectNet object
			//
			pConnection->MakeMulticastReceiver();
			if (pAsyncOp->GetParent())
			{
				pConnection->SetContext( pAsyncOp->GetParent()->GetContext() );
			}

			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			pConnection->m_bilinkMulticast.InsertBefore(&pdnObject->m_bilinkMulticast);
			pConnection = NULL;
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		}
	}

	if (pAsyncOp->IsChild())
	{
		pAsyncOp->Orphan();
	}

	pAsyncOp->Lock();
	pAsyncOp->SetResult( hrProt );
	pAsyncOp->Unlock();

	hResultCode = DPN_OK;

Exit:
	DNASSERT(pConnection == NULL);

	//
	//	Ensure there are no cancels outstanding
	//
	DNWaitForCancel(pAsyncOp);

	DNASSERT(pAsyncOp != NULL);
	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release protocol reference
	//
	DNProtocolRelease(pdnObject);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return( hResultCode );

Failure:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}

#endif	// DPNBUILD_NOMULTICAST


#undef DPF_MODNAME
#define DPF_MODNAME "DNProtocolAddRef"

void DNProtocolAddRef(DIRECTNETOBJECT *const pdnObject)
{
	LONG	lRefCount;

	DPFX(DPFPREP, 8,"(0x%p) Parameters: (none)",pdnObject);

	lRefCount = DNInterlockedIncrement((LONG*)&pdnObject->lProtocolRefCount);

	DPFX(DPFPREP, 8,"(0x%p) Returning (lRefCount = [%ld])",pdnObject,lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProtocolRelease"

void DNProtocolRelease(DIRECTNETOBJECT *const pdnObject)
{
	LONG	lRefCount;

	DPFX(DPFPREP, 8,"(0x%p) Parameters: (none)",pdnObject);

	lRefCount = DNInterlockedDecrement((LONG*)&pdnObject->lProtocolRefCount);

	DNASSERT(lRefCount >= 0);

	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 9,"Signalling protocol shutdown !");
		if (pdnObject->hProtocolShutdownEvent)
		{
			pdnObject->hProtocolShutdownEvent->Set();
		}
	}

	DPFX(DPFPREP, 8,"(0x%p) Returning (lRefCount = [%ld])",pdnObject,lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\mcast.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Mcast.h
 *  Content:    DirectNet Multicast interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/05/01	vanceo	Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__MCAST_H__
#define	__MCAST_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for client interface
//
extern IDirectPlay8MulticastVtbl DNMcast_Vtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

void DNCompleteJoinOperation(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp);

void DNCompleteUserJoin(DIRECTNETOBJECT *const pdnObject,
						CAsyncOp *const pAsyncOp);

STDMETHODIMP DN_Join(IDirectPlay8Multicast *pInterface,
						   IDirectPlay8Address *const pGroupAddr,
						   IUnknown *const pDeviceInfo,
						   const DPN_SECURITY_DESC *const pdnSecurity,
						   const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						   void *const pvAsyncContext,
						   DPNHANDLE *const phAsyncHandle,
						   const DWORD dwFlags);

STDMETHODIMP DN_CreateSenderContext(IDirectPlay8Multicast *pInterface,
					  IDirectPlay8Address *const pSenderAddress,
					  void *const pvSenderContext,
					  const DWORD dwFlags);

STDMETHODIMP DN_DestroySenderContext(IDirectPlay8Multicast *pInterface,
							IDirectPlay8Address *const pSenderAddress,
							const DWORD dwFlags);

STDMETHODIMP DN_GetGroupAddress(IDirectPlay8Multicast *pInterface,
								   IDirectPlay8Address **const ppAddress,
								   const DWORD dwFlags);

STDMETHODIMP DN_EnumMulticastScopes(IDirectPlay8Multicast *pInterface,
								 const GUID *const pguidServiceProvider,
								 const GUID *const pguidDevice,
								 const GUID *const pguidApplication,
								 DPN_MULTICAST_SCOPE_INFO *const pScopeInfoBuffer,
								 PDWORD const pcbEnumData,
								 PDWORD const pcReturned,
								 const DWORD);


#endif	// __MCAST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\ntentry.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTEntry.h
 *  Content:    NameTable Entry Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/07/00	mjn		Created
 *	04/06/00	mjn		Added AvailableEvent to block pre-ADD_PLAYER-notification sends
 *	05/05/00	mjn		Added GetConnectionRef()
 *	07/22/00	mjn		Added m_dwDNETVersion
 *	07/29/00	mjn		Added SetIndicated(),ClearIndicated(),IsIndicated()
 *	07/30/00	mjn		Added m_dwDestoyReason
 *	08/02/00	mjn		Added m_bilinkQueuedMsgs
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/08/00	mjn		Added SetCreated(),ClearCreated(),IsCreated()
 *				mjn		Added SetNeedToDestroy(),ClearNeedToDestroy(),IsNeedToDestroy()
 *	09/06/00	mjn		Changed SetAddress() to return void instead of HRESULT
 *	09/12/00	mjn		Added NAMETABLE_ENTRY_FLAG_IN_USE
 *	09/17/00	mjn		Added m_lNotifyRefCount
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking entries
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NTENTRY_H__
#define	__NTENTRY_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

//
//	NameTable Entry Status Flags:
//
//		INDICATED		App was given an INDICATE_CONNECTION message
//
//		CREATED			App was given a CREATE_PLAYER message
//
//		AVAILABLE		The entry is available for use.
//
//		CONNECTING		The player is in the process of connecting.
//
//		DISCONNECTING	The player/group is in the process of disconnecting.
//

#define	NAMETABLE_ENTRY_FLAG_LOCAL				0x00001
#define	NAMETABLE_ENTRY_FLAG_HOST				0x00002
#define	NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP	0x00004
#define	NAMETABLE_ENTRY_FLAG_GROUP				0x00010
#define	NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST	0x00020
#define	NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT	0x00040
#define	NAMETABLE_ENTRY_FLAG_PEER				0x00100
#define NAMETABLE_ENTRY_FLAG_CLIENT				0x00200
#define	NAMETABLE_ENTRY_FLAG_SERVER				0x00400
#define	NAMETABLE_ENTRY_FLAG_CONNECTING			0x01000
#define	NAMETABLE_ENTRY_FLAG_AVAILABLE			0x02000
#define	NAMETABLE_ENTRY_FLAG_DISCONNECTING		0x04000
#define	NAMETABLE_ENTRY_FLAG_INDICATED			0x10000	//	INDICATE_CONNECT
#define NAMETABLE_ENTRY_FLAG_CREATED			0x20000	//	CREATE_PLAYER
#define	NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY	0x40000
#define	NAMETABLE_ENTRY_FLAG_IN_USE				0x80000

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct IDirectPlay8Address	IDirectPlay8Address;
typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

class CPackedBuffer;
class CConnection;

//
//	Used to pass the NameTable entries
//
typedef struct _DN_NAMETABLE_ENTRY_INFO
{
	DPNID	dpnid;
	DPNID	dpnidOwner;
	DWORD	dwFlags;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwDNETVersion;
	DWORD	dwNameOffset;
	DWORD	dwNameSize;
	DWORD	dwDataOffset;
	DWORD	dwDataSize;
	DWORD	dwURLOffset;
	DWORD	dwURLSize;
} DN_NAMETABLE_ENTRY_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable Entries

class CNameTableEntry
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CNameTableEntry* pNTEntry = (CNameTableEntry*)pvItem;

			pNTEntry->m_Sig[0] = 'N';
			pNTEntry->m_Sig[1] = 'T';
			pNTEntry->m_Sig[2] = 'E';
			pNTEntry->m_Sig[3] = '*';

			if (!DNInitializeCriticalSection(&pNTEntry->m_csEntry))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&pNTEntry->m_csEntry,0);
			if (!DNInitializeCriticalSection(&pNTEntry->m_csMembership))
			{
				DNDeleteCriticalSection(&pNTEntry->m_csEntry);
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&pNTEntry->m_csMembership,0);
			if (!DNInitializeCriticalSection(&pNTEntry->m_csConnections))
			{
				DNDeleteCriticalSection(&pNTEntry->m_csMembership);
				DNDeleteCriticalSection(&pNTEntry->m_csEntry);
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&pNTEntry->m_csConnections,0);

			pNTEntry->m_bilinkEntries.Initialize();
			pNTEntry->m_bilinkDeleted.Initialize();
			pNTEntry->m_bilinkMembership.Initialize();
			pNTEntry->m_bilinkConnections.Initialize();
			pNTEntry->m_bilinkQueuedMsgs.Initialize();

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CNameTableEntry* pNTEntry = (CNameTableEntry*)pvItem;

			pNTEntry->m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			pNTEntry->m_dpnid = 0;
			pNTEntry->m_dpnidOwner = 0;
			pNTEntry->m_pvContext = NULL;
			pNTEntry->m_lRefCount = 1;
			pNTEntry->m_lNotifyRefCount = 0;
			DEBUG_ONLY(pNTEntry->m_lNumQueuedMsgs = 0);
			pNTEntry->m_dwFlags = 0;
			pNTEntry->m_dwDNETVersion = 0;
			pNTEntry->m_dwVersion = 0;
			pNTEntry->m_dwVersionNotUsed = 0;
			pNTEntry->m_dwLatestVersion = 0;
			pNTEntry->m_dwDestroyReason = 0;
			pNTEntry->m_pwszName = NULL;
			pNTEntry->m_dwNameSize = 0;
			pNTEntry->m_pvData = NULL;
			pNTEntry->m_dwDataSize = 0;
			pNTEntry->m_pAddress = NULL;
			pNTEntry->m_pConnection = NULL;

			DNASSERT(pNTEntry->m_bilinkEntries.IsEmpty());
			DNASSERT(pNTEntry->m_bilinkDeleted.IsEmpty());
			DNASSERT(pNTEntry->m_bilinkMembership.IsEmpty());
			DNASSERT(pNTEntry->m_bilinkConnections.IsEmpty());
			DNASSERT(pNTEntry->m_bilinkQueuedMsgs.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::FPMRelease"
	static void FPMRelease( void* pvItem )
		{
			const CNameTableEntry* pNTEntry = (CNameTableEntry*)pvItem;

			DNASSERT(pNTEntry->m_bilinkEntries.IsEmpty());
			DNASSERT(pNTEntry->m_bilinkDeleted.IsEmpty());
			DNASSERT(pNTEntry->m_bilinkMembership.IsEmpty());
			DNASSERT(pNTEntry->m_bilinkConnections.IsEmpty());
			DNASSERT(pNTEntry->m_bilinkQueuedMsgs.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::FPMDealloc"
	static void FPMDealloc( void* pvItem )
		{
			CNameTableEntry* pNTEntry = (CNameTableEntry*)pvItem;

			DNDeleteCriticalSection(&pNTEntry->m_csConnections);
			DNDeleteCriticalSection(&pNTEntry->m_csMembership);
			DNDeleteCriticalSection(&pNTEntry->m_csEntry);
		};

	void ReturnSelfToPool( void );

	void Lock( void )
		{
			DNEnterCriticalSection(&m_csEntry);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_csEntry);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::AddRef"
	void AddRef(void)
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			lRefCount = DNInterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPFX(DPFPREP, 3,"NameTableEntry::AddRef [0x%p] RefCount [0x%lx]",this,lRefCount);
		};

	void Release(void);

	void CNameTableEntry::NotifyAddRef( void );

	void CNameTableEntry::NotifyRelease( void );

	void MakeLocal( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_LOCAL;
		};

	BOOL IsLocal( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_LOCAL)
				return(TRUE);

			return(FALSE);
		};

	void MakeHost( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_HOST;
		};

	BOOL IsHost( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_HOST)
				return(TRUE);

			return(FALSE);
		};

	void MakeAllPlayersGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP;
		};

	BOOL IsAllPlayersGroup( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP)
				return(TRUE);

			return(FALSE);
		};

	void MakeGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_GROUP;
		};

	BOOL IsGroup( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
				return(TRUE);

			return(FALSE);
		};

	void MakeMulticastGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST;
		};

	BOOL IsMulticastGroup( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST)
				return(TRUE);

			return(FALSE);
		};

	void MakeAutoDestructGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT;
		};

	BOOL IsAutoDestructGroup( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT)
				return(TRUE);

			return(FALSE);
		};

	void MakePeer( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_PEER;
		};

	BOOL IsPeer( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_PEER)
				return(TRUE);

			return(FALSE);
		};

	void MakeClient( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_CLIENT;
		};

	BOOL IsClient( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CLIENT)
				return(TRUE);

			return(FALSE);
		};

#ifndef DPNBUILD_NOSERVER
	void MakeServer( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_SERVER;
		};


	BOOL IsServer( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_SERVER)
				return(TRUE);

			return(FALSE);
		};
#endif // !DPNBUILD_NOSERVER

	void MakeAvailable( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_AVAILABLE;
		};

	void MakeUnavailable( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_AVAILABLE);
		};

	BOOL IsAvailable( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_AVAILABLE)
				return(TRUE);

			return(FALSE);
		};

	void SetIndicated( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_INDICATED;
		};

	void ClearIndicated( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_INDICATED);
		};

	BOOL IsIndicated( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_INDICATED)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	void SetCreated( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_CREATED;
		};

	void ClearCreated( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_CREATED);
		};

	BOOL IsCreated( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CREATED)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	void SetNeedToDestroy( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY;
		};

	void ClearNeedToDestroy( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY);
		};

	BOOL IsNeedToDestroy( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	void SetInUse( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_IN_USE;
		};

	void ClearInUse( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_IN_USE);
		};

	BOOL IsInUse( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_IN_USE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void StartConnecting( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_CONNECTING;
		};

	void StopConnecting( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_CONNECTING);
		};

	BOOL IsConnecting( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CONNECTING)
				return(TRUE);

			return(FALSE);
		};

	void CNameTableEntry::StartDisconnecting( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_DISCONNECTING;
		};

	void StopDisconnecting( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_DISCONNECTING);
		};

	BOOL IsDisconnecting( void ) const
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_DISCONNECTING)
				return(TRUE);

			return(FALSE);
		};

	void SetDPNID(const DPNID dpnid)
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID(void) const
		{
			return(m_dpnid);
		};

	void SetContext(void *const pvContext)
		{
			m_pvContext = pvContext;
		};

	void *GetContext(void)
		{
			return(m_pvContext);
		};

	void SetDNETVersion( const DWORD dwDNETVersion )
		{
			m_dwDNETVersion = dwDNETVersion;
		};

	DWORD GetDNETVersion( void ) const
		{
			return( m_dwDNETVersion );
		};

	void SetVersion(const DWORD dwVersion)
		{
			m_dwVersion = dwVersion;
		};

	DWORD GetVersion( void ) const
		{
			return(m_dwVersion);
		};

	void SetLatestVersion(const DWORD dwLatestVersion)
		{
			m_dwLatestVersion = dwLatestVersion;
		};

	DWORD GetLatestVersion( void ) const
		{
			return(m_dwLatestVersion);
		};

	void SetDestroyReason( const DWORD dwReason )
		{
			m_dwDestroyReason = dwReason;
		};

	DWORD GetDestroyReason( void ) const
		{
			return( m_dwDestroyReason );
		};

	HRESULT CNameTableEntry::UpdateEntryInfo(UNALIGNED WCHAR *const pwszName,
											 const DWORD dwNameSize,
											 void *const pvData,
											 const DWORD dwDataSize,
											 const DWORD dwInfoFlags,
											 BOOL fNotify);

	WCHAR *GetName( void )
		{
			return(m_pwszName);
		};

	DWORD GetNameSize( void ) const
		{
			return(m_dwNameSize);
		};

	void *GetData( void )
		{
			return(m_pvData);
		};

	DWORD GetDataSize( void ) const
		{
			return(m_dwDataSize);
		};

	void SetOwner(const DPNID dpnidOwner)
		{
			m_dpnidOwner = dpnidOwner;
		};

	DPNID GetOwner( void ) const
		{
			return(m_dpnidOwner);
		};

	void SetAddress( IDirectPlay8Address *const pAddress );

	IDirectPlay8Address *GetAddress( void )
		{
			return(m_pAddress);
		};

	void SetConnection( CConnection *const pConnection );

	CConnection *GetConnection( void )
		{
			return(m_pConnection);
		};

	HRESULT	CNameTableEntry::GetConnectionRef( CConnection **const ppConnection );

	HRESULT	CNameTableEntry::PackInfo(CPackedBuffer *const pPackedBuffer);

	HRESULT CNameTableEntry::PackEntryInfo(CPackedBuffer *const pPackedBuffer);

	HRESULT CNameTableEntry::UnpackEntryInfo(UNALIGNED const DN_NAMETABLE_ENTRY_INFO *const pdnEntryInfo,
											 BYTE *const pBufferStart);

	void CNameTableEntry::PerformQueuedOperations(void);


	CBilink				m_bilinkEntries;
	CBilink				m_bilinkDeleted;
	CBilink				m_bilinkMembership;
	CBilink				m_bilinkConnections;
	CBilink				m_bilinkQueuedMsgs;

private:
	BYTE				m_Sig[4];
	DPNID				m_dpnid;
	DPNID				m_dpnidOwner;
	void *				m_pvContext;
	LONG	volatile	m_lRefCount;
	LONG	volatile	m_lNotifyRefCount;
	DWORD	volatile	m_dwFlags;
	DWORD				m_dwDNETVersion;
	DWORD				m_dwVersion;
	DWORD				m_dwVersionNotUsed;
	DWORD	volatile	m_dwLatestVersion;
	DWORD	volatile	m_dwDestroyReason;
	PWSTR				m_pwszName;
	DWORD				m_dwNameSize;
	void *				m_pvData;
	DWORD				m_dwDataSize;
	IDirectPlay8Address	*m_pAddress;
	CConnection			*m_pConnection;

	DIRECTNETOBJECT		*m_pdnObject;

#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	m_csEntry;
	DNCRITICAL_SECTION	m_csMembership;
	DNCRITICAL_SECTION	m_csConnections;
#endif // !DPNBUILD_ONLYONETHREAD

public:
	DEBUG_ONLY(LONG		m_lNumQueuedMsgs);
};

#undef DPF_MODNAME

#endif	// __NTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\ntop.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTOp.h
 *  Content:    NameTable Operation Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/23/00	mjn		Created
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added m_pSP, SetSP(), GetSP()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NT_OP_H__
#define	__NT_OP_H__

#include "ServProv.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	NAMETABLE_OP_FLAG_IN_USE	0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CFixedPool;
class CRefCountBuffer;
class CServiceProvider;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

extern CFixedPool g_NameTableOpPool;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable Operations

class CNameTableOp
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableOp::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CNameTableOp* pNTOp = (CNameTableOp*)pvItem;

			pNTOp->m_Sig[0] = 'N';
			pNTOp->m_Sig[1] = 'T';
			pNTOp->m_Sig[2] = 'O';
			pNTOp->m_Sig[3] = 'P';

			pNTOp->m_bilinkNameTableOps.Initialize();

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableOp::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CNameTableOp* pNTOp = (CNameTableOp*)pvItem;

			pNTOp->m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			pNTOp->m_dwFlags = 0;
			pNTOp->m_dwMsgId = 0;
			pNTOp->m_dwVersion = 0;
			pNTOp->m_dwVersionNotUsed = 0;

			pNTOp->m_pRefCountBuffer = NULL;
			pNTOp->m_pSP = NULL;

			DNASSERT(pNTOp->m_bilinkNameTableOps.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableOp::FPMRelease"
	static void FPMRelease( void* pvItem ) 
		{ 
			const CNameTableOp* pNTOp = (CNameTableOp*)pvItem;

			DNASSERT(pNTOp->m_bilinkNameTableOps.IsEmpty());
		};

	void ReturnSelfToPool( void )
		{
			g_NameTableOpPool.Release( this );
		};

	void SetInUse( void )
		{
			m_dwFlags |= NAMETABLE_OP_FLAG_IN_USE;
		};

	BOOL IsInUse( void ) const
		{
			if (m_dwFlags & NAMETABLE_OP_FLAG_IN_USE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetMsgId( const DWORD dwMsgId )
		{
			m_dwMsgId = dwMsgId;
		};

	DWORD GetMsgId( void ) const
		{
			return( m_dwMsgId );
		};

	void SetVersion( const DWORD dwVersion )
		{
			m_dwVersion = dwVersion;
		};

	DWORD GetVersion( void ) const
		{
			return( m_dwVersion );
		};

	void SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer )
		{
			if (pRefCountBuffer)
			{
				pRefCountBuffer->AddRef();
			}
			m_pRefCountBuffer = pRefCountBuffer;
		};

	CRefCountBuffer *GetRefCountBuffer( void )
		{
			return( m_pRefCountBuffer );
		};

	void SetSP( CServiceProvider *const pSP )
		{
			if (pSP)
			{
				pSP->AddRef();
			}
			m_pSP = pSP;
		};

	CServiceProvider *GetSP( void )
		{
			return( m_pSP );
		};

	CBilink				m_bilinkNameTableOps;

private:
	BYTE				m_Sig[4];			// Signature
	DWORD				m_dwFlags;
	DWORD				m_dwMsgId;
	DWORD				m_dwVersion;
	DWORD				m_dwVersionNotUsed;

	CRefCountBuffer		*m_pRefCountBuffer;

	CServiceProvider	*m_pSP;

	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __NT_OP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\ntentry.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTEntry.cpp
 *  Content:    NameTable Entry Objects
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/10/00	mjn		Created
 *	04/06/00	mjn		Added AvailableEvent to block pre-ADD_PLAYER-notification sends
 *	05/05/00	mjn		Added GetConnectionRef()
 *	05/16/00	mjn		Better locking during User notifications
 *	06/27/00	rmt		Added COM abstraction
 *	07/22/00	mjn		Pack/Unpack DNET version in DN_NAMETABLE_ENTRY_INFO
 *	07/26/00	mjn		Fix PackInfo() to handle NULL names and data
 *  08/03/00	rmt		Bug #41386 - Getting player info when no name and/or user data returns garbage in 
 *						name / data field.
 *	09/06/00	mjn		Changed SetAddress() to return void instead of HRESULT
 *	09/13/00	mjn		Added PerformQueuedOperations()
 *	09/17/00	mjn		Added NotifyAddRef() and NotifyRelease()
 *	09/28/00	mjn		Flag AutoDestruct groups in PackInfo()
 *	10/11/00	mjn		Don't take locks in PackInfo()
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking entries
 *	04/19/01	mjn		Lock entry when packing in PackEntryInfo()
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


void CNameTableEntry::ReturnSelfToPool( void )
{
	g_NameTableEntryPool.Release( this );
};


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::Release"

void CNameTableEntry::Release(void)
{
	LONG	lRefCount;

	DNASSERT(m_lRefCount > 0);
	lRefCount = DNInterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
	DPFX(DPFPREP, 3,"NameTableEntry::Release [0x%p] RefCount [0x%lx]",this,lRefCount);
	if (lRefCount == 0)
	{
		DNASSERT(!(m_dwFlags & NAMETABLE_ENTRY_FLAG_AVAILABLE));

		DNASSERT(m_bilinkDeleted.IsEmpty());
		DNASSERT(m_bilinkMembership.IsEmpty());
		DNASSERT(m_bilinkConnections.IsEmpty());
		DNASSERT(m_bilinkQueuedMsgs.IsEmpty());

		if (m_pAddress)
		{
			IDirectPlay8Address_Release(m_pAddress);
			m_pAddress = NULL;
		}
		if (m_pConnection)
		{
			m_pConnection->Release();
			m_pConnection = NULL;
		}
		if (m_pwszName)
		{
			DNFree(m_pwszName);
			m_pwszName = NULL;
		}
		if (m_pvData)
		{
			DNFree(m_pvData);
			m_pvData = NULL;
			m_dwDataSize = 0;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		ReturnSelfToPool();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::NotifyAddRef"

void CNameTableEntry::NotifyAddRef( void )
{
	LONG	lRefCount;

	lRefCount = DNInterlockedIncrement( const_cast<LONG*>(&m_lNotifyRefCount) );
	DNASSERT( lRefCount >= 0 );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::NotifyRelease"

void CNameTableEntry::NotifyRelease( void )
{
	LONG	lRefCount;

	lRefCount = DNInterlockedDecrement( const_cast<LONG*>(&m_lNotifyRefCount) );
	DNASSERT( lRefCount >= 0 );

	if (lRefCount == 0)
	{
		Lock();
//		DNASSERT(IsDisconnecting());
		if (IsNeedToDestroy())
		{
			Unlock();

			//
			//	Generate notifications
			//
			if (IsGroup())
			{
				if (!IsAllPlayersGroup())
				{
					DNUserDestroyGroup(m_pdnObject,this);
				}
			}
			else
			{
				if (IsIndicated() && !IsCreated())
				{
					DNUserIndicatedConnectAborted(m_pdnObject,m_pvContext);
				}
				else
				{
					DNASSERT(IsCreated());
					DNUserDestroyPlayer(m_pdnObject,this);
				}
			}

			m_pdnObject->NameTable.WriteLock();
			Lock();
			m_bilinkDeleted.RemoveFromList();
			m_pdnObject->NameTable.Unlock();
			ClearNeedToDestroy();
			ClearCreated();
		}
		Unlock();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::UpdateEntryInfo"

HRESULT CNameTableEntry::UpdateEntryInfo(UNALIGNED WCHAR *const pwszName,
										 const DWORD dwNameSize,
										 void *const pvData,
										 const DWORD dwDataSize,
										 const DWORD dwInfoFlags,
										 BOOL fNotify)
{
	PWSTR	pwszTempName;
	DWORD	dwTempNameSize;
	void	*pvTempData;
	DWORD	dwTempDataSize;

	Lock();

	if (dwInfoFlags & DPNINFO_NAME)
	{
		if (pwszName && dwNameSize)
		{
			if ((pwszTempName = static_cast<WCHAR*>(DNMalloc(dwNameSize))) == NULL)
			{
				return(DPNERR_OUTOFMEMORY);
			}
			memcpy(pwszTempName,pwszName,dwNameSize);
			dwTempNameSize = dwNameSize;
		}
		else
		{
			pwszTempName = NULL;
			dwTempNameSize = 0;
		}
		if (m_pwszName)
		{
			DNFree(m_pwszName);
		}
		m_pwszName = pwszTempName;
		m_dwNameSize = dwTempNameSize;
	}
	if (dwInfoFlags & DPNINFO_DATA)
	{
		if (pvData && dwDataSize)
		{
			if ((pvTempData = DNMalloc(dwDataSize)) == NULL)
			{
				return(DPNERR_OUTOFMEMORY);
			}
			memcpy(pvTempData,pvData,dwDataSize);
			dwTempDataSize = dwDataSize;
		}
		else
		{
			pvTempData = NULL;
			dwTempDataSize = 0;
		}
		if (m_pvData)
		{
			DNFree(m_pvData);
		}
		m_pvData = pvTempData;
		m_dwDataSize = dwTempDataSize;
	}

	// Generate notifications
	if (m_dwFlags & NAMETABLE_ENTRY_FLAG_AVAILABLE && fNotify)
	{
		DPNID dpnid = m_dpnid;
		PVOID pvContext = m_pvContext;
		DIRECTNETOBJECT* pdnObject = m_pdnObject;

		if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
		{
			Unlock();
			DNUserUpdateGroupInfo(pdnObject,dpnid,pvContext);
		}
		else
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_PEER)
			{
				Unlock();
				DNUserUpdatePeerInfo(pdnObject,dpnid,pvContext);
			}
#ifndef	DPNBUILD_NOSERVER
			else if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CLIENT && pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
			{
				Unlock();
				DNUserUpdateClientInfo(pdnObject,dpnid,pvContext);
			}
#endif	// DPNBUILD_NOSERVER
			else if (m_dwFlags & NAMETABLE_ENTRY_FLAG_SERVER && pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
			{
				Unlock();
				// Clients do not get to see server's DPNID or context
				DNUserUpdateServerInfo(pdnObject,0,0);
			}
			else
			{
				Unlock();
				DNASSERT(FALSE);
			}
		}
	}
	else
	{
		Unlock();
	}

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::SetAddress"

void CNameTableEntry::SetAddress( IDirectPlay8Address *const pAddress )
{
	if (pAddress)
	{
		IDirectPlay8Address_AddRef(pAddress);
	}

	if (m_pAddress)
	{
		IDirectPlay8Address_Release(m_pAddress);
		m_pAddress = NULL;
	}
	m_pAddress = pAddress;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::SetConnection"

void CNameTableEntry::SetConnection( CConnection *const pConnection )
{
	if (pConnection)
	{
		pConnection->AddRef();
	}
	m_pConnection = pConnection;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::GetConnectionRef"

HRESULT	CNameTableEntry::GetConnectionRef( CConnection **const ppConnection )
{
	HRESULT		hResultCode;

	DNASSERT( ppConnection != NULL);

	Lock();
	if ( m_pConnection && !m_pConnection->IsInvalid())
	{
		m_pConnection->AddRef();
		*ppConnection = m_pConnection;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_NOCONNECTION;
	}
	Unlock();

	return( hResultCode );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::PackInfo"

HRESULT CNameTableEntry::PackInfo(CPackedBuffer *const pPackedBuffer)
{
	HRESULT			hResultCode;
	DPN_PLAYER_INFO	*pPlayerInfo;
	DPN_GROUP_INFO	*pGroupInfo;

	DNASSERT(pPackedBuffer != NULL);

//	Lock();
	if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
	{
		pGroupInfo = static_cast<DPN_GROUP_INFO*>(pPackedBuffer->GetHeadAddress());
		hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_GROUP_INFO));
		
		//
		//	Add data
		//
		if ((m_pvData) && (m_dwDataSize != 0))
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pvData,m_dwDataSize)) == DPN_OK)
			{
				pGroupInfo->pvData = pPackedBuffer->GetTailAddress();
				pGroupInfo->dwDataSize = m_dwDataSize;
			}
		}
		else
		{
			if (pGroupInfo)
			{
				pGroupInfo->pvData = NULL;
				pGroupInfo->dwDataSize = 0;
			}
		}

		//
		//	Add name
		//
		if ((m_pwszName) && (m_dwNameSize != 0))
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pwszName,m_dwNameSize)) == DPN_OK)
			{
				pGroupInfo->pwszName = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
			}
		}
		else
		{
			if (pGroupInfo)
			{
				pGroupInfo->pwszName = NULL;
			}
		}

		//
		//	Update flags
		//
		if (hResultCode == DPN_OK)
		{
			if (pGroupInfo)
			{
				pGroupInfo->dwSize = sizeof(DPN_GROUP_INFO);
				pGroupInfo->dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
				pGroupInfo->dwGroupFlags = 0;
				if (IsAutoDestructGroup())
				{
					pGroupInfo->dwGroupFlags |= DPNGROUP_AUTODESTRUCT;
				}
			}
		}
	}
	else
	{
		pPlayerInfo = static_cast<DPN_PLAYER_INFO*>(pPackedBuffer->GetHeadAddress());
		hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_PLAYER_INFO));

		if( !m_dwDataSize )
		{
			if( pPlayerInfo )
			{
				pPlayerInfo->pvData = NULL;
				pPlayerInfo->dwDataSize = 0;
			}
		}
		else
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pvData,m_dwDataSize)) == DPN_OK)
			{
				pPlayerInfo->pvData = pPackedBuffer->GetTailAddress();
				pPlayerInfo->dwDataSize = m_dwDataSize;
			}
		}

		if( !m_pwszName )
		{
			if( pPlayerInfo )
			{
				pPlayerInfo->pwszName = NULL;
			}
		}
		else
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pwszName,m_dwNameSize)) == DPN_OK)
			{
				pPlayerInfo->pwszName = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
			}
		}
		
		if (hResultCode == DPN_OK)
		{
			pPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
			pPlayerInfo->dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
			pPlayerInfo->dwPlayerFlags = 0;
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_HOST)
			{
				pPlayerInfo->dwPlayerFlags |= DPNPLAYER_HOST;
			}
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_LOCAL)
			{
				pPlayerInfo->dwPlayerFlags |= DPNPLAYER_LOCAL;
			}
		}
	}
//	Unlock();

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::PackEntryInfo"

HRESULT CNameTableEntry::PackEntryInfo(CPackedBuffer *const pPackedBuffer)
{
	DWORD			dwURLSize;
	HRESULT			hResultCode;
	DN_NAMETABLE_ENTRY_INFO			dnEntryInfo;

	DPFX(DPFPREP, 6,"Attempting to pack [0x%lx]",m_dpnid);

	DNASSERT(pPackedBuffer != NULL);

	Lock();

	dnEntryInfo.dpnid = m_dpnid;
	dnEntryInfo.dpnidOwner = m_dpnidOwner;
	dnEntryInfo.dwFlags = m_dwFlags & (		NAMETABLE_ENTRY_FLAG_HOST
										|	NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP
										|	NAMETABLE_ENTRY_FLAG_GROUP
										|	NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT
										|	NAMETABLE_ENTRY_FLAG_PEER
										|	NAMETABLE_ENTRY_FLAG_CLIENT
										|	NAMETABLE_ENTRY_FLAG_SERVER );
	dnEntryInfo.dwVersion = m_dwVersion;
	dnEntryInfo.dwVersionNotUsed = m_dwVersionNotUsed;
	dnEntryInfo.dwDNETVersion = m_dwDNETVersion;

	// Entry name
	if (m_pwszName != NULL)
	{
		if ((hResultCode = pPackedBuffer->AddToBack(m_pwszName,m_dwNameSize)) == DPN_OK)
		{
			dnEntryInfo.dwNameOffset = pPackedBuffer->GetTailOffset();
			dnEntryInfo.dwNameSize = m_dwNameSize;
		}
	}
	else
	{
		dnEntryInfo.dwNameOffset = 0;
		dnEntryInfo.dwNameSize = 0;
	}

	// Entry data
	if (m_pvData != NULL && m_dwDataSize != 0)
	{
		if ((hResultCode = pPackedBuffer->AddToBack(m_pvData,m_dwDataSize)) == DPN_OK)
		{
			dnEntryInfo.dwDataOffset = pPackedBuffer->GetTailOffset();
			dnEntryInfo.dwDataSize = m_dwDataSize;
		}
	}
	else
	{
		dnEntryInfo.dwDataOffset = 0;
		dnEntryInfo.dwDataSize = 0;
	}

	// Entry address (URL)
	if ((m_pdnObject->dwFlags & DN_OBJECT_FLAG_PEER) && (m_pAddress != NULL))
	{
		dwURLSize = 0;
		hResultCode = IDirectPlay8Address_GetURLA(m_pAddress,NULL,&dwURLSize);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_BUFFERTOOSMALL)
		{
			DPFERR("Could not determine URL size");
			DisplayDNError(0,hResultCode);
			Unlock();
			goto EXIT_PackEntry;
		}
		if (dwURLSize != 0)
		{
			if ((hResultCode = pPackedBuffer->AddToBack(NULL,dwURLSize)) == DPN_OK)
			{
				if ((hResultCode = IDirectPlay8Address_GetURLA(m_pAddress,
						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
				{
					dnEntryInfo.dwURLOffset = pPackedBuffer->GetTailOffset();
					dnEntryInfo.dwURLSize = dwURLSize;
				}
				else
				{
					DPFERR("Could not extract URL from DirectPlayAddress");
					DisplayDNError(0,hResultCode);
					Unlock();
					goto EXIT_PackEntry;
				}
			}
		}
		else
		{
			dnEntryInfo.dwURLOffset = 0;
			dnEntryInfo.dwURLSize = 0;
		}
	}
	else
	{
		dnEntryInfo.dwURLOffset = 0;
		dnEntryInfo.dwURLSize = 0;
	}

	hResultCode = pPackedBuffer->AddToFront(&dnEntryInfo,sizeof(DN_NAMETABLE_ENTRY_INFO));

	Unlock();

EXIT_PackEntry:

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::UnpackEntryInfo"

HRESULT CNameTableEntry::UnpackEntryInfo(UNALIGNED const DN_NAMETABLE_ENTRY_INFO *const pdnEntryInfo,
										 BYTE *const pBufferStart)
{
	HRESULT		hResultCode;
	PWSTR		pwszName;
	DWORD		dwNameSize;
	void		*pvData;
	DWORD		dwDataSize;
	IDirectPlay8Address	*pAddress;

	DNASSERT(m_pwszName == NULL);
	DNASSERT(m_pvData == NULL);
	DNASSERT(m_pAddress == NULL);

	if (pdnEntryInfo->dwNameOffset && pdnEntryInfo->dwNameSize)
	{
		pwszName = reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwNameOffset);
		dwNameSize = pdnEntryInfo->dwNameSize;
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}

	if (pdnEntryInfo->dwDataOffset && pdnEntryInfo->dwDataSize)
	{
		pvData = static_cast<void*>(pBufferStart + pdnEntryInfo->dwDataOffset);
		dwDataSize = pdnEntryInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	// This function takes the lock internally
	UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,DPNINFO_NAME|DPNINFO_DATA, FALSE);

	pAddress = NULL;
	if (pdnEntryInfo->dwURLOffset)
	{
#ifdef DPNBUILD_LIBINTERFACE
		hResultCode = DP8ACF_CreateInstance(IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pAddress));
#else // ! DPNBUILD_LIBINTERFACE
		hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pAddress),
											FALSE);
#endif // ! DPNBUILD_LIBINTERFACE
		if (hResultCode != S_OK)
		{
			DPFERR("Could not create empty DirectPlayAddress");
			DisplayDNError(0,hResultCode);
			return(DPNERR_OUTOFMEMORY);
		}
		hResultCode = IDirectPlay8Address_BuildFromURLA(pAddress,reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not build URL");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			IDirectPlay8Address_Release(pAddress);
			pAddress = NULL;
			return(hResultCode);
		}
		SetAddress(pAddress);
		IDirectPlay8Address_Release(pAddress);
		pAddress = NULL;
	}

	m_dpnid = pdnEntryInfo->dpnid;
	m_dpnidOwner = pdnEntryInfo->dpnidOwner;
	m_dwFlags = pdnEntryInfo->dwFlags;
	m_dwDNETVersion = pdnEntryInfo->dwDNETVersion;
	m_dwVersion = pdnEntryInfo->dwVersion;
	m_dwVersionNotUsed = pdnEntryInfo->dwVersionNotUsed;

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::PerformQueuedOperations"

void CNameTableEntry::PerformQueuedOperations( void )
{
	HRESULT		hResultCode;
	CQueuedMsg	*pQueuedMsg;
	BOOL		fDestroy;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	fDestroy = FALSE;

	Lock();
	fDestroy = IsNeedToDestroy();

	//
	//	This assumes that the InUse flag is set.  We will clear it before returning.
	//
#ifdef DBG
	DNASSERT( IsInUse() );

	if (!m_bilinkQueuedMsgs.IsEmpty())
	{
		DPFX(DPFPREP, 7, "Nametable entry 0x%p has %i queued messages.", this, m_lNumQueuedMsgs);
	}
#endif // DBG

	while (!m_bilinkQueuedMsgs.IsEmpty())
	{
		pQueuedMsg = CONTAINING_OBJECT(m_bilinkQueuedMsgs.GetNext(),CQueuedMsg,m_bilinkQueuedMsgs);
		pQueuedMsg->m_bilinkQueuedMsgs.RemoveFromList();
		DEBUG_ONLY(m_lNumQueuedMsgs--);

		Unlock();

		switch (pQueuedMsg->GetOpType())
		{
			case	RECEIVE:
				{
					HRESULT		hrProcess;

					DNASSERT(pQueuedMsg->GetAsyncOp() != NULL);
					DNASSERT(pQueuedMsg->GetAsyncOp()->GetHandle() != 0);

#ifndef DPNBUILD_NOVOICE
					if (pQueuedMsg->IsVoiceMessage())
					{
						hrProcess = Voice_Receive(	m_pdnObject,
													GetDPNID(),
													0,
													pQueuedMsg->GetBuffer(),
													pQueuedMsg->GetBufferSize());

						NotifyRelease();

					}
					else
#endif // DPNBUILD_NOVOICE
					{
						hrProcess = DNUserReceive(	m_pdnObject,
													this,
													pQueuedMsg->GetBuffer(),
													pQueuedMsg->GetBufferSize(),
													pQueuedMsg->GetAsyncOp()->GetHandle());
						if (pQueuedMsg->GetCompletionOp() != 0)
						{
							//
							//	Send completion message
							//
							CConnection	*pConnection;

							pConnection = NULL;
							if ((hResultCode = GetConnectionRef( &pConnection )) == DPN_OK)
							{
								hResultCode = DNSendUserProcessCompletion(	m_pdnObject,
																			pConnection,
																			pQueuedMsg->GetCompletionOp());
							}
							pConnection->Release();
							pConnection = NULL;
						}
					}

					//
					//	See if we can return this buffer now
					//
					if (hrProcess == DPNERR_PENDING)
					{
						pQueuedMsg->GetAsyncOp()->Release();
						pQueuedMsg->SetAsyncOp( NULL );
					}
					else
					{
						DNEnterCriticalSection(&m_pdnObject->csActiveList);
						pQueuedMsg->GetAsyncOp()->m_bilinkActiveList.RemoveFromList();
						DNLeaveCriticalSection(&m_pdnObject->csActiveList);
						pQueuedMsg->GetAsyncOp()->Lock();
						if (!pQueuedMsg->GetAsyncOp()->IsCancelled() && !pQueuedMsg->GetAsyncOp()->IsComplete())
						{
							pQueuedMsg->GetAsyncOp()->SetComplete();
							pQueuedMsg->GetAsyncOp()->Unlock();
							if (SUCCEEDED(m_pdnObject->HandleTable.Destroy( pQueuedMsg->GetAsyncOp()->GetHandle(), NULL )))
							{
								// Release the HandleTable reference
								pQueuedMsg->GetAsyncOp()->Release();
							}
						}
						else
						{
							pQueuedMsg->GetAsyncOp()->Unlock();
						}
						pQueuedMsg->GetAsyncOp()->Release();
						pQueuedMsg->SetAsyncOp( NULL );
					}

					break;
				}
			default:
				{
					DPFERR("Invalid Queued Operation");
					DNASSERT(FALSE);
					break;
				}
		}

		//
		//	Return this queued message
		//
		pQueuedMsg->ReturnSelfToPool();
		pQueuedMsg = NULL;

		Lock();
		fDestroy = IsNeedToDestroy();
	}

	//
	//	No longer processing
	//
	ClearInUse();
	Unlock();

	DPFX(DPFPREP, 6,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\paramval.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       paramval.cpp
 *  Content:    DirectPlat8 Parameter Validation helper routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/28/00    rmt     Created
 *  04/13/2000  rmt     More parameter validation
 *  04/17/00    rmt     More param validation
 *              rmt     Added DPF_MODNAMES
 *  04/18/00    rmt     Fix: Bug #32669
 *  04/21/00	rmt		Fix: Bug #33056 Param validation preventing read-only buffers
 *  04/25/00    rmt     Fix: Bug #33190 and fixed param validation to allow nodpnsvr flag
 *	04/28/00	mjn		Allow NULL Device Address in DN_ValidateConnect()
 *	05/03/00	mjn		Added DPNENUMSERVICEPROVIDERS_ALL flag
 *	05/31/00	mjn		Added operation specific SYNC flags
 *				mjn		Fix EnumHosts param validation for timeout and enum period
 *	06/12/00	mjn		Removed validation of DPNSEND_ENCRYPTED,DPNSEND_SIGNED,DPNGROUP_MULTICAST,DPNENUM_GROUP_MULTICAST flags
 *	06/27/00	mjn		Allow priorities to be specified to GetSendQueueInfo() API calls
 *				mjn		Added DPNSEND_NONSEQUENTIAL flag to Send/SendTo
 *				mjn		Allow mix-n-match of priorities in GetSendQueueInfo() API call
 *	07/09/00	mjn		Ensure non-null addresses specified to Host
 *  07/12/00	rmt		Bug #39018 - Need param validation on RegisterLobby() API call
 *  07/19/00	aarono	Bug #39751 - fix parameter validation for CancelAsyncOperation
 *	07/20/00	mjn		Fix validation of pvApplicationReservedData in DN_ValidHostAppDesc()
 *	07/26/00	mjn		Fix param validation for Connect(),SendTo(),DestroyGroup(),AddPlayerToGroup()
 *						RemovePlayerFromGroup(),SetGroupInfo()
 *	07/31/00	mjn		Require dwFlags for DN_ValidateEnumClientsAndGroups()
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2
 *	08/04/00	mjn		Added dwFlags to DN_ValidateGetConnectionInfoHelper()
 *	08/05/00	mjn		Allow NULL Host address to EnumHosts()
 *  08/08/00	rmt		Minor parameter validation error
 *	08/20/00	mjn		Prevent 0 length send buffer
 *	09/04/00	mjn		Ensure pvReservedData in application descriptions is NULL
 *  09/16/00	rmt		Bug #45175 - DPLAY8: [A/V] Param validation prevents non-null async handle w/ no complete
 *	11/27/00	mjn		Fixed spew for async op handle pointers and changed verification order
 *	07/22/01	mjn		Added DPNBUILD_NOHOSTMIGRATE compile flag
 *	07/24/01	mjn		Added DPNBUILD_NOPARAMVAL compile flag
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *	10/08/01	vanceo	Added multicast interface method validation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#ifndef	DPNBUILD_NOPARAMVAL

#ifndef DPNBUILD_NOVOICE
extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
#endif // DPNBUILD_NOVOICE

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateDestroyPlayer"

HRESULT DN_ValidateDestroyPlayer(PVOID pInterface,
								 const DPNID dnid,
								 const void *const pvDestroyData,
								 const DWORD dwDestroyDataSize,
								 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get player context for all players group" );
        return DPNERR_INVALIDPLAYER;
    }

    if( dwDestroyDataSize > 0 &&
        (pvDestroyData == NULL || !DNVALID_READPTR( pvDestroyData, dwDestroyDataSize  ) ) )
    {
        DPFERR( "Invalid pointer specified for destroy data" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified for destroy player" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateReturnBuffer"

HRESULT DN_ValidateReturnBuffer(PVOID pInterface,
								const DPNHANDLE hBufferHandle,
								const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( hBufferHandle == NULL )
    {
        DPFERR( "Invalid handle specified" );
        return DPNERR_INVALIDHANDLE;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetPlayerContext"

HRESULT DN_ValidateGetPlayerContext(PVOID pInterface,
									const DPNID dpnid,
									PVOID *const ppvPlayerContext,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get player context for all players group" );
        return DPNERR_INVALIDPLAYER;
    }

    if( ppvPlayerContext == NULL ||
        !DNVALID_WRITEPTR( ppvPlayerContext, sizeof( PVOID ) ) )
    {
        DPFERR( "Invalid pointer specified for player context" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetGroupContext"

HRESULT DN_ValidateGetGroupContext(PVOID pInterface,
								   const DPNID dpnid,
								   PVOID *const ppvGroupContext,
								   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get group context for all players group" );
        return DPNERR_INVALIDGROUP;
    }

    if( ppvGroupContext == NULL ||
        !DNVALID_WRITEPTR( ppvGroupContext, sizeof( PVOID ) ) )
    {
        DPFERR( "Invalid pointer specified for group context" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;
}


#ifndef DPNBUILD_NOLOBBY

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateRegisterLobby"

HRESULT DN_ValidateRegisterLobby(PVOID pInterface,
								 const DPNHANDLE dpnhLobbyConnection,
								 const IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
								 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pIDP8LobbiedApplication != NULL &&
        !DNVALID_READPTR( pIDP8LobbiedApplication, sizeof( IDirectPlay8LobbiedApplication * ) ) )
    {
        DPFERR( "Invalid interface pointer specified for register lobby" );
        return DPNERR_INVALIDPOINTER;
    }

	if( dwFlags == 0 )
	{
		DPFERR( "You must specify either DPNLOBBY_REGISTER or DPNLOBBY_UNREGISTER" );
		return DPNERR_INVALIDFLAGS;
	}

	if( (dwFlags & DPNLOBBY_REGISTER) &&
		(dwFlags & DPNLOBBY_UNREGISTER) )
	{
		DPFERR( "You cannot specify both register and UNREGISTER" );
		return DPNERR_INVALIDPARAM;
	}

    if( dwFlags & ~(DPNLOBBY_REGISTER | DPNLOBBY_UNREGISTER) )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

	if( dwFlags & DPNLOBBY_REGISTER )
	{
	    if( dpnhLobbyConnection == 0 )
	    {
	    	DPFX(DPFPREP,  0, "Invalid handle" );
	    	return DPNERR_INVALIDHANDLE;
	    }

	    if( !pIDP8LobbiedApplication )
	    {
	    	DPFERR( "You must specify a lobby application interface to use" );
	    	return DPNERR_INVALIDPOINTER;
	    }
	}
	else
	{
		if( dpnhLobbyConnection != 0 || pIDP8LobbiedApplication != NULL )
		{
			DPFX(DPFPREP,  0, "When unregistering you must specify 0 for handle and NULL for lobbiedapp" );
			return DPNERR_INVALIDPARAM;
		}
	}

    return DPN_OK;
}

#endif // ! DPNBUILD_NOLOBBY



#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateTerminateSession"

HRESULT DN_ValidateTerminateSession(PVOID pInterface,
									const void *const pvTerminateData,
									const DWORD dwTerminateDataSize,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dwTerminateDataSize > 0 &&
        (pvTerminateData == NULL || !DNVALID_READPTR( pvTerminateData, dwTerminateDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for terminate data" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetHostAddress"

HRESULT DN_ValidateGetHostAddress(PVOID pInterface,
								  IDirectPlay8Address **const prgpAddress,
								  DWORD *const pcAddress,
								  const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pcAddress == NULL || !DNVALID_WRITEPTR( pcAddress, sizeof( DWORD ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer specified for address count" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pcAddress > 0 &&
         (prgpAddress == NULL || !DNVALID_WRITEPTR( prgpAddress, sizeof( IDirectPlay8Address * ) * (*pcAddress) ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

   	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

	return DPN_OK;
}


#ifndef	DPNBUILD_NOSERVER

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetClientAddress"

HRESULT DN_ValidateGetClientAddress(IDirectPlay8Server *pInterface,
									const DPNID dpnid,
									IDirectPlay8Address **const ppAddress,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get client address for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;

}
#endif	// DPNBUILD_NOSERVER


#ifndef	DPNBUILD_NOSERVER

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetClientInfo"

HRESULT DN_ValidateGetClientInfo(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 DPN_PLAYER_INFO *const pdpnPlayerInfo,
								 DWORD *const pdwSize,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get client info for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( pdwSize == NULL || !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Error validating size param, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwSize &&
        (pdpnPlayerInfo == NULL || !DNVALID_WRITEPTR( pdpnPlayerInfo, *pdwSize ) ) )
    {
        DPFERR( "Error validating player info buffer, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdpnPlayerInfo != NULL )
    {
        if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, FALSE ) ) )
        {
            DPFERR( "Error validating player info" );
            return hResultCode;
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}
#endif	// DPNBUILD_NOSERVER


#ifndef	DPNBUILD_NOSERVER

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetServerInfo"

HRESULT DN_ValidateSetServerInfo(IDirectPlay8Server *pInterface,
								 const DPN_PLAYER_INFO *const pdpnPlayerInfo,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, TRUE ) ) )
    {
        DPFERR( "Error validating player info" );
        return hResultCode;
    }

   if( dwFlags & ~(DPNSETSERVERINFO_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNSETSERVERINFO_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
  
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
	}

    return DPN_OK;
}
#endif	// DPNBUILD_NOSERVER

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetPeerInfo"

HRESULT DN_ValidateSetPeerInfo(IDirectPlay8Peer *pInterface,
							   const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							   PVOID const pvAsyncContext,
							   DPNHANDLE *const phAsyncHandle,
							   const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, TRUE ) ) )
    {
        DPFERR( "Error validating player info" );
        return hResultCode;
    }

	if( dwFlags & ~(DPNSETPEERINFO_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNSETPEERINFO_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
  
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetPeerInfo"

HRESULT DN_ValidateGetPeerInfo(IDirectPlay8Peer *pInterface,
							   const DPNID dpnid,
							   DPN_PLAYER_INFO *const pdpnPlayerInfo,
							   DWORD *const pdwSize,
							   const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get peer info for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( pdwSize == NULL || !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Error validating size param, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwSize &&
        (pdpnPlayerInfo == NULL || !DNVALID_WRITEPTR( pdpnPlayerInfo, *pdwSize ) ) )
    {
        DPFERR( "Error validating player info buffer, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdpnPlayerInfo != NULL )
    {
        if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, FALSE ) ) )
        {
            DPFERR( "Error validating player info" );
            return hResultCode;
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetPeerAddress"

HRESULT DN_ValidateGetPeerAddress(IDirectPlay8Peer *pInterface,
								  const DPNID dpnid,
								  IDirectPlay8Address **const ppAddress,
								  const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get peer address for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetServerAddress"

HRESULT DN_ValidateGetServerAddress(IDirectPlay8Client *pInterface,
									IDirectPlay8Address **const ppAddress,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

     if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

   return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetHostSendQueueInfo"

HRESULT DN_ValidateGetHostSendQueueInfo(IDirectPlay8Client *pInterface,
										DWORD *const pdwNumMsgs,
										DWORD *const pdwNumBytes,
										const DWORD dwFlags )
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

	if( pdwNumMsgs != NULL &&
	    !DNVALID_WRITEPTR( pdwNumMsgs, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num messages specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes != NULL &&
	    !DNVALID_WRITEPTR( pdwNumBytes, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num bytes specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes == NULL && pdwNumMsgs == NULL )
	{
	    DPFERR("Must request at least one of num bytes and num messages" );
	    return( DPNERR_INVALIDPARAM );
	}

    if( dwFlags & ~(DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_LOW | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }
    
#ifndef DPNBUILD_NOMULTICAST
	DIRECTNETOBJECT		*pdnObject;

	// The multicast interface doesn't support low or high priority.
	pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST)
	{
	    if( dwFlags & (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_LOW) )
	    {
	        DPFERR( "Invalid flags specified, multicast interface does not support high or low priority sends" );
	        return( DPNERR_INVALIDFLAGS );
	    }
	}
#endif // ! DPNBUILD_NOMULTICAST

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetServerInfo"

HRESULT DN_ValidateGetServerInfo(IDirectPlay8Client *pInterface,
								 DPN_PLAYER_INFO *const pdpnPlayerInfo,
								 DWORD *const pdwSize,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pdwSize == NULL || !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Error validating size param, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwSize &&
        (pdpnPlayerInfo == NULL || !DNVALID_WRITEPTR( pdpnPlayerInfo, *pdwSize ) ) )
    {
        DPFERR( "Error validating player info buffer, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdpnPlayerInfo != NULL )
    {
        if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, FALSE ) ) )
        {
            DPFERR( "Error validating player info" );
            return hResultCode;
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetClientInfo"

HRESULT DN_ValidateSetClientInfo(IDirectPlay8Client *pInterface,
								 const DPN_PLAYER_INFO *const pdpnPlayerInfo,
								 const PVOID pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, TRUE ) ) )
    {
        DPFERR("Error validating player info" );
        return hResultCode;
    }

    if( dwFlags & ~(DPNSETCLIENTINFO_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNSETCLIENTINFO_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
  
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetConnectionInfoHelper"

HRESULT DN_ValidateGetConnectionInfoHelper(PVOID pv,
										   const DPNID dpnid,
										   DPN_CONNECTION_INFO *const pdpConnectionInfo,
										   BOOL fServerPlayer,
										   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pdpConnectionInfo == NULL ||
        !DNVALID_WRITEPTR( pdpConnectionInfo, sizeof( DPN_CONNECTION_INFO ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for connection info" );
        return(DPNERR_INVALIDPOINTER);
    }

    if( pdpConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO ) 
		&& pdpConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO_INTERNAL )
		)
    {
        DPFX(DPFPREP,  0, "Invalid size on connection info structure" );
        return(DPNERR_INVALIDPARAM);
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}
	return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetSPCaps"

HRESULT DN_ValidateGetSPCaps(PVOID pv,
							 const GUID * const pguidSP,
							 DPN_SP_CAPS *const pdnSPCaps,
							 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
	    return(DPNERR_INVALIDOBJECT);
    }

#ifndef DPNBUILD_ONLYONESP
    if( pguidSP == NULL ||
       !DNVALID_READPTR( pguidSP, sizeof( GUID ) ) )
    {
    	DPFERR( "Invalid pointer specified for SP GUID" );
    	return(DPNERR_INVALIDPOINTER);
    }
#endif // ! DPNBUILD_ONLYONESP

    if( pdnSPCaps == NULL ||
        !DNVALID_WRITEPTR( pdnSPCaps, sizeof( DPN_SP_CAPS ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for caps" );
	    return(DPNERR_INVALIDPOINTER);
    }

    if( pdnSPCaps->dwSize != sizeof( DPN_SP_CAPS ) )
    {
        DPFX(DPFPREP,  0, "Invalid size on SP caps structure" );
        return(DPNERR_INVALIDPARAM);
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetSPCaps"

HRESULT DN_ValidateSetSPCaps(PVOID pv,
							 const GUID * const pguidSP,
							 const DPN_SP_CAPS *const pdnSPCaps,
							 const DWORD dwFlags)
{
    HRESULT hr;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return(DPNERR_INVALIDOBJECT);
    }

#ifndef DPNBUILD_ONLYONESP
    if( pguidSP == NULL ||
        !DNVALID_READPTR( pguidSP, sizeof( GUID ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer to GUID specified" );
        return(DPNERR_INVALIDPOINTER);
    }
#endif // ! DPNBUILD_ONLYONESP

	if(dwFlags){
		DPFX(DPFPREP,  0, "Invalid Flags specified, must be zero" );
		return DPNERR_INVALIDFLAGS;
	}

    hr = DN_ValidSPCaps( pdnSPCaps );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Error validating caps structure hr=[0x%lx]", hr );
        return( hr );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetCaps"

HRESULT DN_ValidateGetCaps(PVOID pv,
						   DPN_CAPS *const pdnCaps,
						   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return(DPNERR_INVALIDOBJECT);
    }

    if( pdnCaps == NULL ||
        !DNVALID_WRITEPTR( pdnCaps, sizeof( DPN_CAPS ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for caps" );
        return(DPNERR_INVALIDPOINTER);
    }

    if( pdnCaps->dwSize != sizeof( DPN_CAPS ) &&  pdnCaps->dwSize != sizeof( DPN_CAPS_EX ))
    {
        DPFX(DPFPREP,  0, "Invalid size on caps structure" );
        return(DPNERR_INVALIDPARAM);
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetCaps"

HRESULT DN_ValidateSetCaps(PVOID pv,
						   const DPN_CAPS *const pdnCaps,
						   const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    hResultCode = DN_ValidCaps( pdnCaps );

    if( FAILED( hResultCode ) )
    {
        DPFX(DPFPREP,  0, "Error validating caps structure hr=0x%x", hResultCode );
        return(hResultCode);
    }

    if( dwFlags != 0 )
    {
        DPFX(DPFPREP,  0, "Invalid flags specified" );
        return(DPNERR_INVALIDFLAGS);
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumHosts"

HRESULT DN_ValidateEnumHosts(PVOID pv,
							 const DPN_APPLICATION_DESC *const pApplicationDesc,
							 IDirectPlay8Address *const pAddrHost,
							 IDirectPlay8Address *const pDeviceInfo,
							 const VOID* const pUserEnumData,
							 const DWORD dwUserEnumDataSize,
							 const DWORD dwRetryCount,
							 const DWORD dwRetryInterval,
							 const DWORD dwTimeOut,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const pAsyncHandle,
							 const DWORD dwFlags )
{
#ifndef DPNBUILD_ONLYONESP
	HRESULT hResultCode;
	GUID guidspHost, guidspDevice;
#endif // ! DPNBUILD_ONLYONESP

	if( !IsValidDirectPlay8Object( pv ) )
	{
		DPFERR("Invalid object specified " );
		return( DPNERR_INVALIDOBJECT );
	}

	if( pApplicationDesc == NULL ||
		!DNVALID_READPTR( pApplicationDesc, sizeof( DPN_APPLICATION_DESC ) ) )
	{
		DPFERR( "Invalid pointer for app desc specified" );
		return( DPNERR_INVALIDPOINTER );
	}

	if( pApplicationDesc->dwSize != sizeof( DPN_APPLICATION_DESC ) )
	{
		DPFERR( "Invalid size for application desc" );
		return( DPNERR_INVALIDPARAM );
	}

	if ((pApplicationDesc->dwFlags != 0) ||
		(pApplicationDesc->dwMaxPlayers != 0) ||
		(pApplicationDesc->dwCurrentPlayers != 0) ||
		(pApplicationDesc->pvApplicationReservedData != NULL) || (pApplicationDesc->dwApplicationReservedDataSize != 0))
	{
		DPFERR( "Cannot specify flags, max players, current players, or application reserved data in application desc" );
		return DPNERR_INVALIDPARAM;
	}

	if (pApplicationDesc->dwReservedDataSize > 0)
	{
		if ((pApplicationDesc->pvReservedData == NULL) ||
			(! DNVALID_READPTR(pApplicationDesc->pvReservedData, pApplicationDesc->dwReservedDataSize)))
		{
			DPFERR("Invalid pointer specified for application desc reserved data");
			return DPNERR_INVALIDPARAM;
		}
		
		//
		//	Make sure it's a type we know about and that it's valid.
		//
		if ((pApplicationDesc->dwReservedDataSize == DPN_MAX_APPDESC_RESERVEDDATA_SIZE) &&
			(*((DWORD*) pApplicationDesc->pvReservedData) == SPSESSIONDATAINFO_XNET))
		{
			SPSESSIONDATA_XNET *	pSessionDataXNet;
			BYTE					bCompare;
			BYTE *					pbCurrent;
			DWORD					dwBytesRemaining;

		
			pSessionDataXNet = (SPSESSIONDATA_XNET*) pApplicationDesc->pvReservedData;
			bCompare = ((BYTE*) (&pSessionDataXNet->ullKeyID))[1] ^ ((BYTE*) (&pSessionDataXNet->guidKey))[2];
			pbCurrent = (BYTE*) (pSessionDataXNet + 1);
			dwBytesRemaining = DPN_MAX_APPDESC_RESERVEDDATA_SIZE - sizeof(SPSESSIONDATA_XNET);
			while (dwBytesRemaining > 0)
			{
				if (*pbCurrent != bCompare)
				{
					DPFERR("Unsupported application desc reserved data");
					return DPNERR_INVALIDPARAM;
				}

				dwBytesRemaining--;
				pbCurrent++;
			}
		}
		else
		{
			DPFERR("Unsupported application desc reserved data");
			return DPNERR_INVALIDPARAM;
		}
	}
	else
	{
		if (pApplicationDesc->pvReservedData != NULL)
		{
			DPFERR("Application desc reserved data pointer should be NULL if reserved data size is 0");
			return DPNERR_INVALIDPARAM;
		}
	}

	if (pAddrHost != NULL)
	{
		if( !DNVALID_READPTR( pAddrHost, sizeof( IDirectPlay8Address * ) ) )
		{
			DPFERR( "Invalid pointer specified for host address" );
			return( DPNERR_INVALIDPOINTER );
		}

#ifndef DPNBUILD_ONLYONESP
		if( FAILED( hResultCode = IDirectPlay8Address_GetSP( pAddrHost, &guidspHost ) ) )
		{
			DPFX(DPFPREP,  0, "Unable to get SP for specified address hr=0x%x", hResultCode );
			return( DPNERR_INVALIDHOSTADDRESS );
		}
#endif // ! DPNBUILD_ONLYONESP
	}

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_ONLYONEADAPTER)))
	if (pDeviceInfo != NULL)
#endif // DPNBUILD_ONLYONESP and DPNBUILD_ONLYONEADAPTER
	{
		if( pDeviceInfo == NULL || !DNVALID_READPTR( pDeviceInfo, sizeof ( IDirectPlay8Address * ) ) )
		{
			DPFERR("Invalid pointer for device address" );
			return( DPNERR_INVALIDPOINTER );
		}

#ifndef DPNBUILD_ONLYONESP
		if( FAILED( hResultCode = IDirectPlay8Address_GetSP( pDeviceInfo, &guidspDevice ) ) )
		{
			DPFX(DPFPREP,  0, "Unable to get SP for specified address hr=0x%x", hResultCode );
			return( DPNERR_INVALIDDEVICEADDRESS );
		}

		if (pAddrHost != NULL)
		{
			if( guidspHost != guidspDevice )
			{
				DPFERR( "Device and remote addresses must use the same SP" );
				return( DPNERR_INVALIDPARAM );
			}
		}
#endif // ! DPNBUILD_ONLYONESP
	}

    if( dwUserEnumDataSize > 0 &&
        (pUserEnumData == NULL || !DNVALID_READPTR( pUserEnumData, dwUserEnumDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for user enum data" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK) )
    {
        DPFX(DPFPREP,  0, "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNENUMHOSTS_SYNC )
    {
        if( pAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( pAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
  
		if( !DNVALID_WRITEPTR( pAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumGroupMembers"

HRESULT DN_ValidateEnumGroupMembers(PVOID pInterface,
									const DPNID dpnid,
									DPNID *const prgdpnid,
									DWORD *const pcdpnid,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR("Cannot enumerate all players group" );
        return DPNERR_INVALIDGROUP;
    }

    if( pcdpnid == NULL ||
        !DNVALID_WRITEPTR( pcdpnid, sizeof( DWORD ) ) )
    {
        DPFERR("Invalid count param specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( *pcdpnid > 0 &&
        (prgdpnid == NULL || !DNVALID_WRITEPTR( prgdpnid, *pcdpnid ) ) )
    {
        DPFERR("Invalid pointer specified for buffer" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumClientsAndGroups"

HRESULT DN_ValidateEnumClientsAndGroups(PVOID pInterface,
										DPNID *const prgdpnid,
										DWORD *const pcdpnid,
										const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( pcdpnid == NULL ||
        !DNVALID_WRITEPTR( pcdpnid, sizeof( DWORD ) ) )
    {
        DPFERR("Invalid count param specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( *pcdpnid > 0 &&
        (prgdpnid == NULL || !DNVALID_WRITEPTR( prgdpnid, *pcdpnid ) ) )
    {
        DPFERR("Invalid pointer specified for buffer" );
        return( DPNERR_INVALIDPOINTER );
    }

	if (dwFlags == 0)
	{
		DPFERR("Flags must be specified");
		return( DPNERR_INVALIDPARAM );
	}

    if (dwFlags & ~(DPNENUM_GROUPS | DPNENUM_PLAYERS))
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetGroupInfo"

HRESULT DN_ValidateGetGroupInfo(PVOID pv,
								const DPNID dpnid,
								DPN_GROUP_INFO *const pdpnGroupInfo,
								DWORD *const pdwSize,
								const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR("Cannot get group info for all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( pdwSize == NULL ||
        !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR("Invalid pdwSize parameter specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    // Only validate group info pointer if size is > 0
    if( *pdwSize > 0 )
    {
        if( pdpnGroupInfo == NULL ||
            !DNVALID_WRITEPTR( pdpnGroupInfo, *pdwSize ) )
        {
            DPFERR("Invalid pointer specified for group info" );
            return( DPNERR_INVALIDPOINTER );
        }

        if( FAILED( hResultCode = DN_ValidGroupInfo( pdpnGroupInfo, FALSE ) ) )
        {
            DPFERR("Error validating group info parameter" );
            return( hResultCode );
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetGroupInfo"

HRESULT DN_ValidateSetGroupInfo(PVOID pv,
								const DPNID dpnid,
								const DPN_GROUP_INFO *const pdpnGroupInfo,
								PVOID const pvAsyncContext,
								DPNHANDLE *const phAsyncHandle,
								const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot remove from all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( FAILED( hResultCode = DN_ValidGroupInfo( pdpnGroupInfo, TRUE ) ) )
    {
        DPFERR( "Error validating group info structure" );
        return(hResultCode);
    }

    if( dwFlags & ~(DPNSETGROUPINFO_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNSETGROUPINFO_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
  
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateRemoveClientFromGroup"

HRESULT DN_ValidateRemoveClientFromGroup(PVOID pInterface,
										 const DPNID dpnidGroup,
										 const DPNID dpnidClient,
										 PVOID const pvAsyncContext,
										 DPNHANDLE *const phAsyncHandle,
										 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnidGroup == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot remove from all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( dpnidClient == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot specify all players group as client to remove" );
        return( DPNERR_INVALIDPARAM );
    }

    if( dwFlags & ~(DPNREMOVEPLAYERFROMGROUP_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
  
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateAddClientToGroup"

HRESULT DN_ValidateAddClientToGroup(PVOID pInterface,
									const DPNID dpnidGroup,
									const DPNID dpnidClient,
									PVOID const pvAsyncContext,
									DPNHANDLE *const phAsyncHandle,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnidGroup == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot add from all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( dpnidClient == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot specify all players group as client to add" );
        return( DPNERR_INVALIDPLAYER );
    }

    if( dwFlags & ~(DPNADDPLAYERTOGROUP_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNADDPLAYERTOGROUP_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
   
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
   }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateDestroyGroup"

HRESULT DN_ValidateDestroyGroup(PVOID pInterface,
								const DPNID dpnidGroup,
								PVOID const pvAsyncContext,
								DPNHANDLE *const phAsyncHandle,
								const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnidGroup == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot destroy all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( dwFlags & ~(DPNDESTROYGROUP_SYNC) )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNDESTROYGROUP_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
  
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateCreateGroup"

HRESULT DN_ValidateCreateGroup(PVOID pInterface,
							   const DPN_GROUP_INFO *const pdpnGroupInfo,
							   void *const pvGroupContext,
							   void *const pvAsyncContext,
							   DPNHANDLE *const phAsyncHandle,
							   const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( FAILED( hResultCode = DN_ValidGroupInfo( pdpnGroupInfo, TRUE ) ) )
    {
        DPFERR("Invalid group info structure" );
        return( DPNERR_INVALIDPARAM );
    }

    if( dwFlags & ~(DPNCREATEGROUP_SYNC) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNCREATEGROUP_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle pointer if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle pointer w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
  
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
    }

	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateHost"

HRESULT DN_ValidateHost(PVOID pInterface,
						const DPN_APPLICATION_DESC *const pdnAppDesc,
						IDirectPlay8Address **const prgpDeviceInfo,
						const DWORD cDeviceInfo,
						const DPN_SECURITY_DESC *const pdnSecurity,
						const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						void *const pvPlayerContext,
						const DWORD dwFlags)
{
	HRESULT hResultCode;
#ifndef DPNBUILD_ONLYONESP
	GUID guidSP;
#endif // ! DPNBUILD_ONLYONESP
	DWORD dwTmpPort;
	DWORD dwPortType;
	DWORD dwPortSize;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( FAILED( hResultCode = DN_ValidHostAppDesc( pdnAppDesc ) ) )
    {
        DPFERR("Invalid host app desc specified");
        return( hResultCode );
    }

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_ONLYONEADAPTER)))
    if ( ( prgpDeviceInfo == NULL && cDeviceInfo != 0 ) ||
    	( prgpDeviceInfo != NULL && cDeviceInfo == 0 ) )
    {
        DPFERR("You MUST specify a device address array and count, or NULL and 0");
        return( DPNERR_INVALIDDEVICEADDRESS );
    }
#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_ONLYONEADAPTER
    if( prgpDeviceInfo == NULL || cDeviceInfo == 0 )
    {
        DPFERR("You MUST specify a device address");
        return( DPNERR_INVALIDDEVICEADDRESS );
    }
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_ONLYONEADAPTER

    if( cDeviceInfo > MAX_HOST_ADDRESSES )
    {
        DPFX(DPFPREP, 0, "Cannot specify more than %u device addresses!", cDeviceInfo);
        return( DPNERR_INVALIDPARAM );
    }

#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_ONLYONEADAPTER)))
	if (cDeviceInfo > 0)
#endif // DPNBUILD_ONLYONESP and DPNBUILD_ONLYONEADAPTER
	{
	    if( !DNVALID_READPTR( prgpDeviceInfo, sizeof( IDirectPlay8Address * ) * cDeviceInfo ) )
	    {
	        DPFERR("Invalid pointer specified for device info" );
	        return( DPNERR_INVALIDPOINTER );
	    }

		// ensure SPs are specified in addresses
		for (DWORD dw = 0 ; dw < cDeviceInfo ; dw++)
		{
			if ( prgpDeviceInfo[dw] == NULL )
			{
				DPFERR( "Null device address interface pointer specified" );
				return( DPNERR_INVALIDDEVICEADDRESS );
			}
#ifndef DPNBUILD_ONLYONESP
			if (IDirectPlay8Address_GetSP(prgpDeviceInfo[dw],&guidSP) != DPN_OK)
			{
			    DPFERR("SP not specified for one of the addresses" );
				return(DPNERR_INVALIDDEVICEADDRESS);
			}
#endif // ! DPNBUILD_ONLYONESP

			dwPortType = DPNA_DATATYPE_DWORD;
			dwPortSize = sizeof( DWORD );
			// Check to ensure it's not using the default DPNSVR port
			if( SUCCEEDED( hResultCode = IDirectPlay8Address_GetComponentByName( prgpDeviceInfo[dw], DPNA_KEY_PORT, &dwTmpPort, &dwPortSize, &dwPortType ) ) )
			{
				if( dwTmpPort == DPNA_DPNSVR_PORT )
				{
					DPFERR( "Cannot use the DPNSVR port in device addresses" );
					DPFERR( "This port is reserved for DPNSVR" );
					return( DPNERR_INVALIDDEVICEADDRESS );
				}
			}    		
		}
	}	

    if( FAILED( hResultCode = DN_ValidSecurityDesc( pdnSecurity ) ) )
    {
        DPFERR("Error validating reserved param" );
        return( hResultCode );
    }

    if( FAILED( hResultCode = DN_ValidSecurityCredentials(pdnCredentials) ) )
    {
        DPFERR("Error validating reserved param" );
        return( hResultCode );
    }

    if( ( dwFlags & ~(DPNHOST_OKTOQUERYFORADDRESSING) ) != 0 )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumServiceProviders"

HRESULT DN_ValidateEnumServiceProviders(PVOID pInterface,
										const GUID *const pguidServiceProvider,
										const GUID *const pguidApplication,
										DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
										DWORD *const pcbEnumData,
										const DWORD *const pcReturned,
										const DWORD dwFlags )
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pguidServiceProvider != NULL &&
	    !DNVALID_READPTR( pguidServiceProvider, sizeof( GUID ) ) )
	{
	    DPFERR("Invalid service provider specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pguidApplication != NULL &&
	    !DNVALID_READPTR( pguidApplication, sizeof( GUID ) ) )
	{
	    DPFERR("Invalid application GUID specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pcbEnumData == NULL ||
	    !DNVALID_READPTR( pcbEnumData, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid enum data pointer" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pcReturned == NULL ||
	    !DNVALID_READPTR( pcReturned, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid retuned count" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbEnumData > 0 &&
	    (pSPInfoBuffer == NULL || !DNVALID_WRITEPTR(pSPInfoBuffer,*pcbEnumData) ) )
	{
	    DPFERR("Invalid enum buffer specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( dwFlags & (~(DPNENUMSERVICEPROVIDERS_ALL)) )
	{
	    DPFERR("Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateCancelAsyncOperation"

HRESULT DN_ValidateCancelAsyncOperation(PVOID pvInterface,
										const DPNHANDLE hAsyncOp,
										const DWORD dwFlags )
{
	DIRECTNETOBJECT		*pdnObject;

	
	if( !IsValidDirectPlay8Object( pvInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pvInterface));
	
	if( dwFlags )
	{
#ifdef	DIRECTPLAYDIRECTX9
		if ( dwFlags & DPNCANCEL_PLAYER_SENDS )
		{
			if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
			{
				if( (DPNID) hAsyncOp != 0 )
				{
				    DPFERR("Invalid player ID specified, must be 0" );
				    return( DPNERR_INVALIDPARAM );
				}
			}
			else
			{
				if( (DPNID) hAsyncOp == 0 )
				{
				    DPFERR("Invalid player ID specified, cannot be 0" );
				    return( DPNERR_INVALIDPLAYER );
				}
			}

			// make sure only correct bits are set
			if(  dwFlags != ( dwFlags & ( DPNCANCEL_PLAYER_SENDS | DPNCANCEL_PLAYER_SENDS_PRIORITY_NORMAL | DPNCANCEL_PLAYER_SENDS_PRIORITY_HIGH | DPNCANCEL_PLAYER_SENDS_PRIORITY_LOW ) ) )
			{
			    DPFERR("Invalid flags specified" );
			    return( DPNERR_INVALIDFLAGS );
			}
		}
		else
#endif
		{
			if( hAsyncOp )
			{
				DPFERR("Invalid parameter, hAsyncOp specified with flags");
				return ( DPNERR_INVALIDPARAM );
			}

			// make sure only correct bits are set, AND only 1 bit is set.
#ifdef DPNBUILD_NOMULTICAST
			if(  ( dwFlags != ( dwFlags & ( DPNCANCEL_ALL_OPERATIONS | DPNCANCEL_CONNECT | DPNCANCEL_ENUM | DPNCANCEL_SEND ) ) ) ||
#else // ! DPNBUILD_NOMULTICAST
			if(  ( dwFlags != ( dwFlags & ( DPNCANCEL_ALL_OPERATIONS | DPNCANCEL_CONNECT | DPNCANCEL_ENUM | DPNCANCEL_SEND | DPNCANCEL_JOIN ) ) ) ||
#endif // ! DPNBUILD_NOMULTICAST
				( ( ( dwFlags - 1 ) & dwFlags ) != 0 ) )
			{
			    DPFERR("Invalid flags specified" );
			    return( DPNERR_INVALIDFLAGS );
			}
		}
		
		// Server objects don't have the concept of connects, enums, or joins.
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
		{
#ifdef DPNBUILD_NOMULTICAST
			if (dwFlags & (DPNCANCEL_CONNECT | DPNCANCEL_ENUM))
#else // ! DPNBUILD_NOMULTICAST
			if (dwFlags & (DPNCANCEL_CONNECT | DPNCANCEL_ENUM | DPNCANCEL_JOIN))
#endif // ! DPNBUILD_NOMULTICAST
			{
				DPFERR("Server interface cannot cancel connect, enum, or join operations");
				return(DPNERR_INVALIDFLAGS);
			}
		}
		// Client objects don't have the concept of joins.
		else if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
		{
#ifndef DPNBUILD_NOMULTICAST
			if (dwFlags & DPNCANCEL_JOIN)
			{
				DPFERR("Client interface cannot cancel join operations");
				return(DPNERR_INVALIDFLAGS);
			}
#endif // ! DPNBUILD_NOMULTICAST
		}
#ifndef DPNBUILD_NOMULTICAST
		// Multicast objects don't have the concept of connects, enums, or player sends.
		else if (pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST)
		{
			if (dwFlags & (DPNCANCEL_CONNECT | DPNCANCEL_ENUM | DPNCANCEL_PLAYER_SENDS))
			{
				DPFERR("Multicast interface cannot cancel connect, enum or player send operations");
				return(DPNERR_INVALIDFLAGS);
			}
		}
#endif // ! DPNBUILD_NOMULTICAST
		// Peer objects don't have the concept of joins.
		else
		{
			DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_PEER);
#ifndef DPNBUILD_NOMULTICAST
			if (dwFlags & DPNCANCEL_JOIN)
			{
				DPFERR("Peer interface cannot cancel join operations");
				return(DPNERR_INVALIDFLAGS);
			}
#endif // ! DPNBUILD_NOMULTICAST
		}
	}
	else
	{
		if( hAsyncOp == NULL)
		{
		    DPFERR("Invalid handle specified" );
		    return( DPNERR_INVALIDHANDLE );
		}
	}
	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateConnect"

HRESULT DN_ValidateConnect(PVOID pInterface,
						   const DPN_APPLICATION_DESC *const pdnAppDesc,
						   IDirectPlay8Address *const pHostAddr,
						   IDirectPlay8Address *const pDeviceInfo,
						   const DPN_SECURITY_DESC *const pdnSecurity,
						   const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						   const void *const pvUserConnectData,
						   const DWORD dwUserConnectDataSize,
						   void *const pvPlayerContext,
						   void *const pvAsyncContext,
						   DPNHANDLE *const phAsyncHandle,
						   const DWORD dwFlags)
{
    HRESULT hResultCode;
#ifndef DPNBUILD_ONLYONESP
    GUID guidHostSP;
    GUID guidDeviceSP;
#endif // ! DPNBUILD_ONLYONESP

	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    hResultCode = DN_ValidConnectAppDesc( pdnAppDesc );

    if( FAILED( hResultCode ) )
    {
        DPFX(DPFPREP, 0, "Invalid connect app desc hr=[0x%lx]", hResultCode );
        return( hResultCode );
    }

	if( pHostAddr == NULL ||
	    !DNVALID_READPTR( pHostAddr, sizeof( IDirectPlay8Address * ) ) )
	{
	    DPFERR("Invalid host address specified" );
	    return( DPNERR_INVALIDHOSTADDRESS );
	}

#ifndef DPNBUILD_ONLYONESP
	if( FAILED( hResultCode = IDirectPlay8Address_GetSP( pHostAddr, &guidHostSP ) ) )
	{
	    DPFERR("No SP specified in host address" );
	    return( DPNERR_INVALIDHOSTADDRESS );
	}
#endif // ! DPNBUILD_ONLYONESP

	//
	//	Allow a NULL Device Address (we will copy the SP from the Host address)
	//
	if( pDeviceInfo != NULL)
	{
		if ( !DNVALID_READPTR( pDeviceInfo, sizeof( IDirectPlay8Address * ) ) )
		{
			DPFERR("Invalid device address specified" );
			return( hResultCode );
		}

#ifndef DPNBUILD_ONLYONESP
		if( FAILED( hResultCode = IDirectPlay8Address_GetSP( pDeviceInfo, &guidDeviceSP ) ) )
		{
			DPFERR("No SP specified in device address" );
			return( DPNERR_INVALIDDEVICEADDRESS );
		}

		if (guidHostSP != guidDeviceSP)
		{
			DPFERR( "Specified different SPs for device and connect" );
			return(DPNERR_INVALIDDEVICEADDRESS);
		}
#endif // ! DPNBUILD_ONLYONESP

		DWORD dwTmpPort;
		DWORD dwDataType;
		DWORD dwDataSize;

		dwDataType = DPNA_DATATYPE_DWORD;
		dwDataSize = sizeof( DWORD );

		// Check to ensure it's not using the default DPNSVR port
		if( SUCCEEDED( hResultCode = IDirectPlay8Address_GetComponentByName( pDeviceInfo, DPNA_KEY_PORT, &dwTmpPort, &dwDataSize, &dwDataType ) ) )
		{
			if( dwTmpPort == DPNA_DPNSVR_PORT )
			{
				DPFERR( "Cannot use the DPNSVR port in device addresses" );
				DPFERR( "This port is reserved for DPNSVR" );
				return( DPNERR_INVALIDDEVICEADDRESS );
			}
		}
	}

    if( FAILED( hResultCode = DN_ValidSecurityDesc(pdnSecurity) ) )
    {
        DPFERR(" Invalid reserved specified" );
        return( hResultCode );
    }

    if( FAILED( hResultCode = DN_ValidSecurityCredentials(pdnCredentials) ) )
    {
        DPFERR( "Invalid reserved2 specified" );
        return( hResultCode );
    }

    if( dwUserConnectDataSize > 0 &&
        (pvUserConnectData == NULL || !DNVALID_READPTR( pvUserConnectData, dwUserConnectDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for connect data" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( pvUserConnectData != NULL && dwUserConnectDataSize == 0 )
    {
        DPFERR( "Non NULL connect data with datasize = 0 is invalid" );
        return( DPNERR_INVALIDPARAM );
    }

    if( dwFlags & ~(DPNCONNECT_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    if( dwFlags & DPNCONNECT_SYNC )
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle if op is synchronous" );
            return( DPNERR_INVALIDPARAM );
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
  
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
    }
    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetSendQueueInfo"

HRESULT DN_ValidateGetSendQueueInfo(PVOID pInterface,
									DWORD *const pdwNumMsgs,
									DWORD *const pdwNumBytes,
									const DWORD dwFlags)
{
	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pdwNumMsgs != NULL &&
	    !DNVALID_WRITEPTR( pdwNumMsgs, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num messages specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes != NULL &&
	    !DNVALID_WRITEPTR( pdwNumBytes, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num bytes specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes == NULL && pdwNumMsgs == NULL )
	{
	    DPFERR("Must request at least one of num bytes and num messages" );
	    return( DPNERR_INVALIDPARAM );
	}

    if( dwFlags & ~(DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_LOW | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetApplicationDesc"

HRESULT DN_ValidateGetApplicationDesc(PVOID pInterface,
									  DPN_APPLICATION_DESC *const pAppDescBuffer,
									  DWORD *const pcbDataSize,
									  const DWORD dwFlags )
{
	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pcbDataSize == NULL ||
	    !DNVALID_WRITEPTR( pcbDataSize, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid pointer specified for data size" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbDataSize > 0 &&
	    (pAppDescBuffer == NULL || !DNVALID_WRITEPTR( pAppDescBuffer, *pcbDataSize ) ) )
	{
	    DPFERR( "Invalid pointer specified for app description buffer" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbDataSize > 0 &&
	    pAppDescBuffer->dwSize != sizeof( DPN_APPLICATION_DESC ) )
	{
	    DPFERR("Invalid size specified" );
	    return(DPNERR_INVALIDPARAM);
	}

	if( dwFlags != 0 )
	{
	    DPFERR( "Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}
	
    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetApplicationDesc"

HRESULT DN_ValidateSetApplicationDesc(PVOID pInterface,
									  const DPN_APPLICATION_DESC *const pdnApplicationDesc,
									  const DWORD dwFlags)
{
    HRESULT hResultCode;

	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( FAILED( hResultCode = DN_ValidHostAppDesc(pdnApplicationDesc) ) )
	{
	    DPFX(DPFPREP, 0,"Invalid app desc specified hr=[0x%lx]", hResultCode );
	    return( hResultCode );
	}

	if( dwFlags != 0 )
	{
	    DPFERR( "Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}
	
    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSendParams"

HRESULT DN_ValidateSendParams(PVOID pv,
                              const DPN_BUFFER_DESC *const pBufferDesc,
							  const DWORD cBufferDesc,
                              const DWORD dwTimeOut,
							  void *const pvAsyncContext,
                              DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags )
{
    HRESULT hResultCode;

	if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return(DPNERR_INVALIDOBJECT);
    }

    if( FAILED( hResultCode = DN_ValidBufferDescs( pBufferDesc, cBufferDesc ) ) )
    {
        DPFERR( "Invalid buffer descs specified" );
        return( hResultCode );
    }

	if (pBufferDesc->dwBufferSize == 0)
	{
		DPFERR( "Cannot specify 0 data size" );
		return(DPNERR_INVALIDPARAM);
	}

   	if ( dwFlags & ~(DPNSEND_SYNC
					| DPNSEND_NOCOPY
					| DPNSEND_NOCOMPLETE
					| DPNSEND_COMPLETEONPROCESS
					| DPNSEND_GUARANTEED
					| DPNSEND_NONSEQUENTIAL
					| DPNSEND_NOLOOPBACK
					| DPNSEND_PRIORITY_LOW
					| DPNSEND_PRIORITY_HIGH
#ifdef	DIRECTPLAYDIRECTX9
					| DPNSEND_COALESCE
#endif	// DIRECTPLAYDIRECTX9
					))
	{
	    DPFERR( "Invalid flags specified" );
	    return(DPNERR_INVALIDFLAGS);
	}

	if ((dwFlags & DPNSEND_NOCOPY) && (dwFlags & DPNSEND_NOCOMPLETE))
	{
	    DPFERR( "Cannot specify NOCOPY and NOCOMPLETE" );
		return(DPNERR_INVALIDFLAGS);
	}

	if ((dwFlags & DPNSEND_COMPLETEONPROCESS) && (dwFlags & DPNSEND_NOCOMPLETE))
	{
	    DPFERR("Cannot specify complete on process AND NOCOMPLETE" );
		return(DPNERR_INVALIDFLAGS);
	}

	if ((dwFlags & DPNSEND_COMPLETEONPROCESS) && !(dwFlags & DPNSEND_GUARANTEED))
	{
	    DPFERR("Cannot specify COMPLETEONPROCESS without guaranteed" );
		return(DPNERR_INVALIDFLAGS);
	}

    // Guaranteed asyncs MUST get a complete
	if ((dwFlags & DPNSEND_GUARANTEED) && !(dwFlags & DPNSEND_SYNC) &&
	    (dwFlags & DPNSEND_NOCOMPLETE) )
	{
	    DPFERR("Async, guaranteed sends must get a completion" );
	    return(DPNERR_INVALIDFLAGS);
	}

	// Cannot specify high AND low priority
	if ((dwFlags & DPNSEND_PRIORITY_HIGH) && (dwFlags & DPNSEND_PRIORITY_LOW))
	{
		DPFERR("Cannot specify high AND low priority");
		return(DPNERR_INVALIDFLAGS);
	}

    if (dwFlags & DPNSEND_SYNC)
    {
        if( phAsyncHandle != NULL )
        {
            DPFERR( "You cannot specify an async handle if op is synchronous" );
            return(DPNERR_INVALIDPARAM);
        }
    }
    else
    {
        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle if op async and/or has a completion" );
            return(DPNERR_INVALIDPARAM);
        }
   
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
   }

#ifndef DPNBUILD_NOMULTICAST
	DIRECTNETOBJECT		*pdnObject;

	// Multicast sends essentially must be normal priority, non-guaranteed, non-sequential sends.
	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST)
	{
		if ((dwFlags & (DPNSEND_COMPLETEONPROCESS
						| DPNSEND_GUARANTEED
						| DPNSEND_NOLOOPBACK
						| DPNSEND_PRIORITY_LOW
						| DPNSEND_PRIORITY_HIGH
#ifdef	DIRECTPLAYDIRECTX9
						| DPNSEND_COALESCE
#endif	// DIRECTPLAYDIRECTX9
						)) ||
			!(dwFlags & DPNSEND_NONSEQUENTIAL))
		{
			DPFERR("Multicast sends cannot be guaranteed, COMPLETEONPROCESS, and must be non-sequential, have normal priority, and be able to loop back");
			return(DPNERR_INVALIDFLAGS);
		}
		
		if (dwTimeOut != 0)
		{
			DPFERR("Multicast sends cannot have timeouts");
			return(DPNERR_INVALIDPARAM);
		}
	}
#endif // ! DPNBUILD_NOMULTICAST

   	return DPN_OK;

}



#ifndef DPNBUILD_NOMULTICAST

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateJoin"

HRESULT DN_ValidateJoin(IDirectPlay8Multicast *pInterface,
						   IDirectPlay8Address *const pGroupAddr,
						   IUnknown *const pDeviceInfo,
						   const DPN_SECURITY_DESC *const pdnSecurity,
						   const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						   void *const pvAsyncContext,
						   DPNHANDLE *const phAsyncHandle,
						   const DWORD dwFlags)
{
	HRESULT hResultCode;
	PVOID  pvNewInterface;
#ifndef DPNBUILD_ONLYONESP
	GUID guidSPFromGroup, guidSPFromDevice;
#endif // ! DPNBUILD_ONLYONESP
	DWORD dwTmpPort;
	DWORD dwDataType;
	DWORD dwDataSize;

	if( !IsValidDirectPlay8Object( pInterface ) )
	{
		DPFERR("Invalid object specified " );
		return( DPNERR_INVALIDOBJECT );
	}

	// Check for an option group address.
#ifndef DPNBUILD_ONLYONESP
	//
	// Initialize the group object SP to GUID_NULL.
	//
	memset(&guidSPFromGroup, 0, sizeof(guidSPFromGroup));
#endif // ! DPNBUILD_ONLYONESP
	if( pGroupAddr != NULL)
	{
		if( !DNVALID_READPTR( pGroupAddr, sizeof( IDirectPlay8Address * ) ) )
		{
			DPFERR("Invalid group address specified" );
			return( DPNERR_INVALIDHOSTADDRESS );
		}

#ifndef DPNBUILD_ONLYONESP
		if( FAILED( hResultCode = IDirectPlay8Address_GetSP( pGroupAddr, &guidSPFromGroup ) ) )
		{
		    DPFERR("No SP specified in host address" );
		    return( DPNERR_INVALIDHOSTADDRESS );
		}
#endif // ! DPNBUILD_ONLYONESP


		dwDataType = DPNA_DATATYPE_DWORD;
		dwDataSize = sizeof( DWORD );

		// Check to ensure it's not using the default DPNSVR port
		if( SUCCEEDED( hResultCode = IDirectPlay8Address_GetComponentByName( pGroupAddr, DPNA_KEY_PORT, &dwTmpPort, &dwDataSize, &dwDataType ) ) )
		{
			if( dwTmpPort == DPNA_DPNSVR_PORT )
			{
				DPFERR( "Cannot use the DPNSVR port in device addresses" );
				DPFERR( "This port is reserved for DPNSVR" );
				return( DPNERR_INVALIDDEVICEADDRESS );
			}
		}
	}

	// A device address/object is required.
	if( ( pDeviceInfo == NULL) ||
		( !DNVALID_READPTR( pDeviceInfo, sizeof( IUnknown * ) ) ) )
	{
		DPFERR("Invalid device address specified" );
		return( DPNERR_INVALIDDEVICEADDRESS );
	}

#ifndef DPNBUILD_ONLYONESP
	//
	// Initialize the group object SP to GUID_NULL.
	//
	memset(&guidSPFromDevice, 0, sizeof(guidSPFromGroup));
#endif // ! DPNBUILD_ONLYONESP
	// Find out what type of interface this is.
	if( ( (IDirectPlay8Peer_QueryInterface( (IDirectPlay8Peer*) pDeviceInfo, IID_IDirectPlay8Peer, &pvNewInterface )) == S_OK ) ||
#ifndef DPNBUILD_NOSERVER
		( (IDirectPlay8Server_QueryInterface( (IDirectPlay8Server*) pDeviceInfo, IID_IDirectPlay8Server, &pvNewInterface )) == S_OK ) ||
#endif // ! DPNBUILD_NOSERVER
		( (IDirectPlay8Client_QueryInterface( (IDirectPlay8Client*) pDeviceInfo, IID_IDirectPlay8Client, &pvNewInterface )) == S_OK ) ||
		( (IDirectPlay8Multicast_QueryInterface( (IDirectPlay8Multicast*) pDeviceInfo, IID_IDirectPlay8Multicast, &pvNewInterface )) == S_OK ) )
	{
		DIRECTNETOBJECT		*pdnDeviceObject;

		
		// It's a DIRECTNETOBJECT.

		if( !IsValidDirectPlay8Object( pvNewInterface ) )
		{
			DPFERR("Invalid DirectPlay device object specified " );
 			IDirectPlay8Peer_Release((IDirectPlay8Peer*) pvNewInterface); // since it queried successfully like a core object, release it like a core object
			pvNewInterface = NULL;
			return( DPNERR_INVALIDDEVICEADDRESS );
		}

		// Make sure the DIRECTNETOBJECT is in the right state.
		pdnDeviceObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pvNewInterface);
		
		// Check to ensure message handler registered
		if (!(pdnDeviceObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
		{
			DPFERR( "DirectPlay device object is not initialized" );
 			IDirectPlay8Peer_Release((IDirectPlay8Peer*) pvNewInterface); // all core objects release the same way
			pvNewInterface = NULL;
			DPF_RETURN(DPNERR_INVALIDDEVICEADDRESS);
		}

		if( pdnDeviceObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
		{
			DPFERR( "DirectPlay device object has not yet completed connecting / hosting" );
 			IDirectPlay8Peer_Release((IDirectPlay8Peer*) pvNewInterface); // all core objects release the same way
			pvNewInterface = NULL;
			DPF_RETURN(DPNERR_INVALIDDEVICEADDRESS);
		}

		if (!(pdnDeviceObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
		{
			DPFERR("DirectPlay device object is not connected or hosting" );
 			IDirectPlay8Peer_Release((IDirectPlay8Peer*) pvNewInterface); // all core objects release the same way
			pvNewInterface = NULL;
			DPF_RETURN(DPNERR_INVALIDDEVICEADDRESS);
		}
		
 		IDirectPlay8Peer_Release((IDirectPlay8Peer*) pvNewInterface); // all core objects release the same way
		pvNewInterface = NULL;
	}
	else if( (IDirectPlay8Address_QueryInterface( (IDirectPlay8Address*) pDeviceInfo, IID_IDirectPlay8Address, &pvNewInterface )) == S_OK )
	{
		// It's an address.

#ifndef DPNBUILD_ONLYONESP
		if( FAILED( hResultCode = IDirectPlay8Address_GetSP( reinterpret_cast<IDirectPlay8Address*>(pvNewInterface), &guidSPFromDevice ) ) )
		{
			DPFERR("No SP specified in device address" );
			IDirectPlay8Address_Release(reinterpret_cast<IDirectPlay8Address*>(pvNewInterface));
			pvNewInterface = NULL;
			return( DPNERR_INVALIDDEVICEADDRESS );
		}
#endif // ! DPNBUILD_ONLYONESP


		dwDataType = DPNA_DATATYPE_DWORD;
		dwDataSize = sizeof( DWORD );

		// Check to ensure it's not using the default DPNSVR port
		if( SUCCEEDED( hResultCode = IDirectPlay8Address_GetComponentByName( reinterpret_cast<IDirectPlay8Address*>(pvNewInterface), DPNA_KEY_PORT, &dwTmpPort, &dwDataSize, &dwDataType ) ) )
		{
			if( dwTmpPort == DPNA_DPNSVR_PORT )
			{
				DPFERR( "Cannot use the DPNSVR port in device addresses" );
				DPFERR( "This port is reserved for DPNSVR" );
				IDirectPlay8Address_Release(reinterpret_cast<IDirectPlay8Address*>(pvNewInterface));
				pvNewInterface = NULL;
				return( DPNERR_INVALIDDEVICEADDRESS );
			}
		}

		IDirectPlay8Address_Release(reinterpret_cast<IDirectPlay8Address*>(pvNewInterface));
		pvNewInterface = NULL;


#ifndef DPNBUILD_ONLYONESP
		//
		//	Make sure that if both the group address or device address specified an SP,
		//	they both specified the same SP.
		//
		if (guidSPFromGroup != guidSPFromDevice)
		{
			//
			// Reuse guidSPFromDevice to store GUID_NULL.  It's okay that we lose the
			// information it previously contained, we don't need it anymore.
			//
			memset(&guidSPFromDevice, 0, sizeof(guidSPFromDevice));
			if (guidSPFromGroup != guidSPFromDevice)
			{
				DPFERR( "Specified different SPs for device and group" );
				return(DPNERR_INVALIDDEVICEADDRESS);
			}
		}
#endif // ! DPNBUILD_ONLYONESP
	}
	else
	{
		DPFERR( "Invalid device address, it must be an IDirectPlay8Peer, IDirectPlay8Server, IDirectPlay8Client, IDirectPlay8Multicast, or IDirectPlay8Address object" );
		return( DPNERR_INVALIDDEVICEADDRESS );
	}

	if( FAILED( hResultCode = DN_ValidSecurityDesc(pdnSecurity) ) )
	{
		DPFERR(" Invalid reserved specified" );
		return( hResultCode );
	}

	if( FAILED( hResultCode = DN_ValidSecurityCredentials(pdnCredentials) ) )
	{
		DPFERR( "Invalid reserved2 specified" );
		return( hResultCode );
	}

	if( dwFlags & ~( DPNJOIN_SYNC | DPNJOIN_ALLOWUNKNOWNSENDERS ) )
	{
		DPFERR( "Invalid flags specified" );
		return( DPNERR_INVALIDFLAGS );
	}

	if( dwFlags & DPNJOIN_SYNC )
	{
		if( phAsyncHandle != NULL )
		{
			DPFERR( "You cannot specify an async handle if op is synchronous" );
			return( DPNERR_INVALIDPARAM );
		}
	}
	else
	{
		if( phAsyncHandle == NULL )
		{
			DPFERR( "You MUST specify a valid async handle w/async ops" );
			return( DPNERR_INVALIDPARAM );
		}
  
		if( !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
		{
			DPFERR("Invalid async handle pointer specified" );
			return( DPNERR_INVALIDPOINTER );
		}
	}
	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetGroupAddress"

HRESULT DN_ValidateGetGroupAddress(IDirectPlay8Multicast *pInterface,
										IDirectPlay8Address **const ppAddress,
										const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFX(DPFPREP,  0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateCreateSenderContext"

HRESULT DN_ValidateCreateSenderContext(IDirectPlay8Multicast *pInterface,
								  IDirectPlay8Address *const pSenderAddress,
								  void *const pvSenderContext,
								  const DWORD dwFlags)
{
 #ifndef DPNBUILD_ONLYONESP
   HRESULT hResultCode;
    GUID guidSender;
#endif // ! DPNBUILD_ONLYONESP
   
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pSenderAddress == NULL ||
	    !DNVALID_READPTR( pSenderAddress, sizeof( IDirectPlay8Address * ) ) )
	{
	    DPFERR("Invalid host address specified" );
	    return( DPNERR_INVALIDHOSTADDRESS );
	}

#ifndef DPNBUILD_ONLYONESP
	if( FAILED( hResultCode = IDirectPlay8Address_GetSP( pSenderAddress, &guidSender ) ) )
	{
	    DPFERR("No SP specified in address" );
	    return( DPNERR_INVALIDHOSTADDRESS );
	}
#endif // ! DPNBUILD_ONLYONESP

	if( dwFlags != 0 )
	{
	    DPFERR("Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateDestroySenderContext"

HRESULT DN_ValidateDestroySenderContext(IDirectPlay8Multicast *pInterface,
								  IDirectPlay8Address *const pSenderAddress,
								  const DWORD dwFlags)
{
#ifndef DPNBUILD_ONLYONESP
    HRESULT hResultCode;
    GUID guidSender;
#endif // ! DPNBUILD_ONLYONESP
   
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pSenderAddress == NULL ||
	    !DNVALID_READPTR( pSenderAddress, sizeof( IDirectPlay8Address * ) ) )
	{
	    DPFERR("Invalid host address specified" );
	    return( DPNERR_INVALIDHOSTADDRESS );
	}

#ifndef DPNBUILD_ONLYONESP
	if( FAILED( hResultCode = IDirectPlay8Address_GetSP( pSenderAddress, &guidSender ) ) )
	{
	    DPFERR("No SP specified in address" );
	    return( DPNERR_INVALIDHOSTADDRESS );
	}
#endif // ! DPNBUILD_ONLYONESP

	if( dwFlags != 0 )
	{
	    DPFERR("Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumMulticastScopes"

HRESULT DN_ValidateEnumMulticastScopes(IDirectPlay8Multicast *pInterface,
										const GUID *const pguidServiceProvider,
										const GUID *const pguidDevice,
										const GUID *const pguidApplication,
										DPN_MULTICAST_SCOPE_INFO *const pScopeInfoBuffer,
										DWORD *const pcbEnumData,
										const DWORD *const pcReturned,
										const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pguidServiceProvider == NULL ||
	    !DNVALID_READPTR( pguidServiceProvider, sizeof( GUID ) ) )
	{
	    DPFERR("Invalid service provider specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pguidDevice == NULL ||
	    !DNVALID_READPTR( pguidDevice, sizeof( GUID ) ) )
	{
	    DPFERR("Invalid device specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pguidApplication != NULL &&
	    !DNVALID_READPTR( pguidApplication, sizeof( GUID ) ) )
	{
	    DPFERR("Invalid application specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pcbEnumData == NULL ||
	    !DNVALID_READPTR( pcbEnumData, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid enum data pointer" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pcReturned == NULL ||
	    !DNVALID_READPTR( pcReturned, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid retuned count" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbEnumData > 0 &&
	    (pScopeInfoBuffer == NULL || !DNVALID_WRITEPTR(pScopeInfoBuffer,*pcbEnumData) ) )
	{
	    DPFERR("Invalid enum buffer specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( dwFlags != 0 )
	{
	    DPFERR("Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}

    return DPN_OK;
}


#endif // ! DPNBUILD_NOMULTICAST



#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidBufferDescs"

HRESULT DN_ValidBufferDescs(const DPN_BUFFER_DESC * const pbBufferDesc,
							const DWORD cBufferDesc )
{
	DWORD	dw;

    if( cBufferDesc == 0 )
    {
        DPFERR( "You must specify at least one buffer desc" );
        return DPNERR_INVALIDPARAM;
    }

    if( cBufferDesc > DN_ASYNC_MAX_SEND_BUFFERDESC )
    {
        DPFX(DPFPREP,  0, "Too many buffer descs specified.  Max allowed = %d", DN_ASYNC_MAX_SEND_BUFFERDESC );
        return DPNERR_INVALIDPARAM;
    }

    if( pbBufferDesc == NULL ||
       !DNVALID_READPTR( pbBufferDesc, cBufferDesc*sizeof( DPN_BUFFER_DESC ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid buffer for buffer description" );
        return DPNERR_INVALIDPOINTER;
    }

	for ( dw = 0 ; dw < cBufferDesc ; dw++ )
	{
		if( pbBufferDesc[dw].dwBufferSize > 0 &&
		   (pbBufferDesc[dw].pBufferData == NULL || !DNVALID_READPTR( pbBufferDesc[dw].pBufferData, pbBufferDesc[dw].dwBufferSize ) ) )
		{
			DPFX(DPFPREP,  0, "Invalid pBuffer Data" );
			return DPNERR_INVALIDPOINTER;
		}
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidConnectAppDesc"

HRESULT DN_ValidConnectAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc )
{
	if( pdnAppDesc == NULL ||
		!DNVALID_READPTR( pdnAppDesc, sizeof( DPN_APPLICATION_DESC ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid pointer for app description" );
		return DPNERR_INVALIDPOINTER;
	}

	if( pdnAppDesc->dwSize != sizeof( DPN_APPLICATION_DESC ) )
	{
		DPFX(DPFPREP,  0, "Invalid size for app description" );
		return DPNERR_INVALIDPARAM;
	}

	if( pdnAppDesc->pwszSessionName != NULL &&
		!DNVALID_STRING_W( pdnAppDesc->pwszSessionName ) )
	{
		DPFX(DPFPREP,  0, "Invalid session name specified" );
		return DPNERR_INVALIDSTRING;
	}

	if( pdnAppDesc->pwszPassword != NULL &&
		!DNVALID_STRING_W( pdnAppDesc->pwszPassword ) )
	{
		DPFX(DPFPREP,  0, "Invalid session desc" );
		return DPNERR_INVALIDSTRING;
	}

	if (pdnAppDesc->dwReservedDataSize > 0)
	{
		if ((pdnAppDesc->pvReservedData == NULL) ||
			(! DNVALID_READPTR(pdnAppDesc->pvReservedData, pdnAppDesc->dwReservedDataSize)))
		{
			DPFERR("Invalid pointer specified for application desc reserved data");
			return DPNERR_INVALIDPARAM;
		}
		
		//
		//	Make sure it's a type we know about and that it's valid.
		//
		if ((pdnAppDesc->dwReservedDataSize == DPN_MAX_APPDESC_RESERVEDDATA_SIZE) &&
			(*((DWORD*) pdnAppDesc->pvReservedData) == SPSESSIONDATAINFO_XNET))
		{
			SPSESSIONDATA_XNET *	pSessionDataXNet;
			BYTE					bCompare;
			BYTE *					pbCurrent;
			DWORD					dwBytesRemaining;

		
			pSessionDataXNet = (SPSESSIONDATA_XNET*) pdnAppDesc->pvReservedData;
			bCompare = ((BYTE*) (&pSessionDataXNet->ullKeyID))[1] ^ ((BYTE*) (&pSessionDataXNet->guidKey))[2];
			pbCurrent = (BYTE*) (pSessionDataXNet + 1);
			dwBytesRemaining = DPN_MAX_APPDESC_RESERVEDDATA_SIZE - sizeof(SPSESSIONDATA_XNET);
			while (dwBytesRemaining > 0)
			{
				if (*pbCurrent != bCompare)
				{
					DPFERR("Unsupported application desc reserved data");
					return DPNERR_INVALIDPARAM;
				}

				dwBytesRemaining--;
				pbCurrent++;
			}
		}
		else
		{
			DPFERR("Unsupported application desc reserved data");
			return DPNERR_INVALIDPARAM;
		}
	}
	else
	{
		if (pdnAppDesc->pvReservedData != NULL)
		{
			DPFERR("Application desc reserved data pointer should be NULL if reserved data size is 0");
			return DPNERR_INVALIDPARAM;
		}
	}

	return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidHostAppDesc"

HRESULT DN_ValidHostAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc )
{
	GUID	guidnull;


	if( pdnAppDesc == NULL ||
		!DNVALID_READPTR( pdnAppDesc, sizeof( DPN_APPLICATION_DESC ) ) )
	{
    	DPFX(DPFPREP,  0, "Invalid pointer for app description" );
		return DPNERR_INVALIDPOINTER;
	}

	if( pdnAppDesc->dwSize != sizeof( DPN_APPLICATION_DESC ) )
	{
		DPFX(DPFPREP,  0, "Invalid size for app description" );
		return DPNERR_INVALIDPARAM;
	}

	if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER |
#ifndef DPNBUILD_NOHOSTMIGRATE
								DPNSESSION_MIGRATE_HOST |
#endif // ! DPNBUILD_NOHOSTMIGRATE
								DPNSESSION_REQUIREPASSWORD |
								DPNSESSION_NODPNSVR
#ifdef	DIRECTPLAYDIRECTX9
								|
								DPNSESSION_NOENUMS |
								DPNSESSION_FAST_SIGNED |
								DPNSESSION_FULL_SIGNED
#endif	// DIRECTPLAYDIRECTX9
								) )
	{
		DPFX(DPFPREP,  0, "Invalid flag specified" );
		return DPNERR_INVALIDFLAGS;
	}

#ifdef	DIRECTPLAYDIRECTX9
	if ((pdnAppDesc->dwFlags & DPNSESSION_FAST_SIGNED) && (pdnAppDesc->dwFlags & DPNSESSION_FULL_SIGNED))
	{
		DPFX(DPFPREP,  0, "Cannot have both fast and full signed session" );
		return DPNERR_INVALIDPARAM;
	}
#endif	// DIRECTPLAYDIRECTX9

#ifndef	DPNBUILD_NOHOSTMIGRATE
	if( (pdnAppDesc->dwFlags & DPNSESSION_CLIENT_SERVER) &&
	   (pdnAppDesc->dwFlags & DPNSESSION_MIGRATE_HOST) )
	{
		DPFX(DPFPREP,  0, "Cannot have host migration with client/server" );
		return DPNERR_INVALIDPARAM;
	}
#endif // !DPNBUILD_NOHOSTMIGRATE

	memset(&guidnull, 0, sizeof(guidnull));
	if( pdnAppDesc->guidApplication == guidnull )
	{
		DPFERR( "You must specify a valid GUID for your application GUID" );
		return DPNERR_INVALIDPARAM;
	}

	if( pdnAppDesc->pwszSessionName != NULL &&
	   !DNVALID_STRING_W( pdnAppDesc->pwszSessionName ) )
	{
		DPFX(DPFPREP,  0, "Invalid session name" );
		return DPNERR_INVALIDSTRING;
	}

	if( pdnAppDesc->dwFlags & DPNSESSION_REQUIREPASSWORD )
	{
		if( pdnAppDesc->pwszPassword == NULL )
		{
			DPFERR( "Must specify a password w/the requirepassword flag." );
			return DPNERR_INVALIDPARAM;
		}

		if( !DNVALID_STRING_W( pdnAppDesc->pwszPassword ) )
		{
			DPFX(DPFPREP,  0, "Invalid password specified." );
			return DPNERR_INVALIDSTRING;
		}
	}
	else
	{
		if( pdnAppDesc->pwszPassword != NULL )
		{
			DPFERR( "Cannot specify a password without the requirepassword flag" );
			return DPNERR_INVALIDPARAM;
		}
	}

	if (pdnAppDesc->dwReservedDataSize > 0)
	{
		if ((pdnAppDesc->pvReservedData == NULL) ||
			(! DNVALID_READPTR(pdnAppDesc->pvReservedData, pdnAppDesc->dwReservedDataSize)))
		{
			DPFERR("Invalid pointer specified for application desc reserved data");
			return DPNERR_INVALIDPARAM;
		}
		
		//
		//	Make sure it's a type we know about and that it's valid.
		//
		if ((pdnAppDesc->dwReservedDataSize == DPN_MAX_APPDESC_RESERVEDDATA_SIZE) &&
			(*((DWORD*) pdnAppDesc->pvReservedData) == SPSESSIONDATAINFO_XNET))
		{
			SPSESSIONDATA_XNET *	pSessionDataXNet;
			BYTE					bCompare;
			BYTE *					pbCurrent;
			DWORD					dwBytesRemaining;

		
			pSessionDataXNet = (SPSESSIONDATA_XNET*) pdnAppDesc->pvReservedData;
			bCompare = ((BYTE*) (&pSessionDataXNet->ullKeyID))[1] ^ ((BYTE*) (&pSessionDataXNet->guidKey))[2];
			pbCurrent = (BYTE*) (pSessionDataXNet + 1);
			dwBytesRemaining = DPN_MAX_APPDESC_RESERVEDDATA_SIZE - sizeof(SPSESSIONDATA_XNET);
			while (dwBytesRemaining > 0)
			{
				if (*pbCurrent != bCompare)
				{
					DPFERR("Unsupported application desc reserved data");
					return DPNERR_INVALIDPARAM;
				}

				dwBytesRemaining--;
				pbCurrent++;
			}
		}
		else
		{
			DPFERR("Unsupported application desc reserved data");
			return DPNERR_INVALIDPARAM;
		}
	}
	else
	{
		if (pdnAppDesc->pvReservedData != NULL)
		{
			DPFERR("Application desc reserved data pointer should be NULL if reserved data size is 0");
			return DPNERR_INVALIDPARAM;
		}
	}

	if ( pdnAppDesc->dwApplicationReservedDataSize != 0 &&
		!DNVALID_READPTR( pdnAppDesc->pvApplicationReservedData, pdnAppDesc->dwApplicationReservedDataSize ) )
	{
		DPFX(DPFPREP,  0, "Invalid pointer for application reserved data" );
		return DPNERR_INVALIDPARAM;
	}

	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidPlayerInfo"

HRESULT DN_ValidPlayerInfo(const DPN_PLAYER_INFO * const pdnPlayerInfo,
						   BOOL fSet )
{
   if( pdnPlayerInfo == NULL ||
       !DNVALID_READPTR( pdnPlayerInfo, sizeof( DPN_PLAYER_INFO ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for player info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnPlayerInfo->dwSize != sizeof( DPN_PLAYER_INFO ) )
    {
        DPFX(DPFPREP,  0, "Invalid size for player info" );
        return DPNERR_INVALIDPARAM;
    }

    if( fSet )
    {
        if( pdnPlayerInfo->dwInfoFlags & ~(DPNINFO_NAME | DPNINFO_DATA) )
        {
            DPFERR("Invalid info flags specified" );
            return DPNERR_INVALIDFLAGS;
        }

        if( pdnPlayerInfo->dwInfoFlags & DPNINFO_NAME )
        {
            if( pdnPlayerInfo->pwszName != NULL && !DNVALID_STRING_W( pdnPlayerInfo->pwszName ) )
            {
                DPFERR("Invalid string specified for name" );
                return DPNERR_INVALIDSTRING;
            }
        }
        else
        {
            if( pdnPlayerInfo->pwszName != NULL )
            {
                DPFERR( "You must specify DPNINFO_NAME to set name" );
                return DPNERR_INVALIDSTRING;
            }
        }

        if( pdnPlayerInfo->dwInfoFlags & DPNINFO_DATA )
        {
            if( pdnPlayerInfo->dwDataSize > 0 &&
                (pdnPlayerInfo->pvData == NULL || !DNVALID_READPTR( pdnPlayerInfo->pvData, pdnPlayerInfo->dwDataSize )  ) )
            {
                DPFERR("Invalid pointer specified for data" );
                return DPNERR_INVALIDPOINTER;
            }
        }
        else
        {
            if( pdnPlayerInfo->pvData != NULL )
            {
                DPFERR("You must specify DPNINFO_DATA if you want to set data" );
                return DPNERR_INVALIDPARAM;
            }
        }

        if( pdnPlayerInfo->dwPlayerFlags != 0  )
        {
            DPFERR( "Invalid player flags specified" );
            return DPNERR_INVALIDFLAGS;
        }
    }

    return DPN_OK;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidGroupInfo"

HRESULT DN_ValidGroupInfo(const DPN_GROUP_INFO * const pdnGroupInfo,
						  BOOL fSet )
{
   if( pdnGroupInfo == NULL ||
       !DNVALID_READPTR( pdnGroupInfo, sizeof( DPN_GROUP_INFO ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for group info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnGroupInfo->dwSize != sizeof( DPN_GROUP_INFO ) )
    {
        DPFX(DPFPREP,  0, "Invalid size for group info" );
        return DPNERR_INVALIDPARAM;
    }

    if( fSet )
    {
        if( pdnGroupInfo->dwInfoFlags & ~(DPNINFO_NAME | DPNINFO_DATA) )
        {
            DPFERR("Invalid info flags specified" );
            return DPNERR_INVALIDFLAGS;
        }

        if( pdnGroupInfo->dwInfoFlags & DPNINFO_NAME )
        {
            if( pdnGroupInfo->pwszName != NULL && !DNVALID_STRING_W( pdnGroupInfo->pwszName ) )
            {
                DPFERR("Invalid string specified for name" );
                return DPNERR_INVALIDSTRING;
            }
        }
        else
        {
            if( pdnGroupInfo->pwszName != NULL )
            {
                DPFERR( "You must specify DPNINFO_NAME to set name" );
                return DPNERR_INVALIDSTRING;
            }
        }

        if( pdnGroupInfo->dwInfoFlags & DPNINFO_DATA )
        {
            if( pdnGroupInfo->dwDataSize > 0 &&
                (pdnGroupInfo->pvData == NULL || !DNVALID_READPTR( pdnGroupInfo->pvData, pdnGroupInfo->dwDataSize )  ) )
            {
                DPFERR("Invalid pointer specified for data" );
                return DPNERR_INVALIDPOINTER;
            }
        }
        else
        {
            if( pdnGroupInfo->pvData != NULL )
            {
                DPFERR("You must specify DPNINFO_DATA if you want to set data" );
                return DPNERR_INVALIDPARAM;
            }
        }

        if( pdnGroupInfo->dwGroupFlags & ~(DPNGROUP_AUTODESTRUCT /* | DPNGROUP_MULTICAST */ ) )
        {
            DPFERR( "Invalid group flags specified" );
            return DPNERR_INVALIDFLAGS;
        }
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidSecurityCredentials"

HRESULT DN_ValidSecurityCredentials( const DPN_SECURITY_CREDENTIALS * const pdnCredentials )
{
	if( pdnCredentials != NULL )
	{
		DPFERR( "Invalid value for reserved field" );
		return DPNERR_INVALIDPOINTER;
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidSecurityDesc"

HRESULT DN_ValidSecurityDesc( const DPN_SECURITY_DESC * const pdnValidSecurityDesc )
{
	if( pdnValidSecurityDesc != NULL )
	{
		DPFERR( "Invalid value for reserved field" );
		return DPNERR_INVALIDPOINTER;
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "IsValidDirectPlay8Object"

BOOL IsValidDirectPlay8Object( LPVOID lpvObject )
#ifdef DPNBUILD_LIBINTERFACE
{
	DIRECTNETOBJECT *pdn = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE( lpvObject );

	if( pdn == NULL ||
	   !DNVALID_WRITEPTR( pdn, sizeof( DIRECTNETOBJECT ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object" );
		return FALSE;
	}
	
	if( pdn->lpVtbl != &DN_ClientVtbl &&
	   pdn->lpVtbl != &DN_PeerVtbl &&
#ifndef	DPNBUILD_NOSERVER
	   pdn->lpVtbl != &DN_ServerVtbl &&
#endif	// ! DPNBUILD_NOSERVER
#ifndef DPNBUILD_NOVOICE
	   pdn->lpVtbl != &DN_VoiceTbl &&
#endif // ! DPNBUILD_NOVOICE
#ifndef DPNBUILD_NOPROTOCOLTESTITF
       pdn->lpVtbl != &DN_ProtocolVtbl &&
#endif // ! DPNBUILD_NOPROTOCOLTESTITF
#ifndef	DPNBUILD_NOMULTICAST
	   pdn->lpVtbl != &DNMcast_Vtbl &&
#endif	// ! DPNBUILD_NOMULTICAST
       pdn->lpVtbl != &SPMessagesVtbl
	   )
	{
		DPFX(DPFPREP,  0, "Invalid object - bad vtable" );
		return FALSE;
	}

	return TRUE;
}
#else // ! DPNBUILD_LIBINTERFACE
{
	INTERFACE_LIST *pIntList = (INTERFACE_LIST *) lpvObject;
	
	if( !DNVALID_READPTR( lpvObject, sizeof( INTERFACE_LIST ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object pointer" );
		return FALSE;
	}

	if( pIntList->lpVtbl != &DN_ClientVtbl &&
	   pIntList->lpVtbl != &DN_PeerVtbl &&
#ifndef	DPNBUILD_NOSERVER
	   pIntList->lpVtbl != &DN_ServerVtbl &&
#endif	// ! DPNBUILD_NOSERVER
#ifndef DPNBUILD_NOVOICE
	   pIntList->lpVtbl != &DN_VoiceTbl &&
#endif // ! DPNBUILD_NOVOICE
#ifndef DPNBUILD_NOPROTOCOLTESTITF
       pIntList->lpVtbl != &DN_ProtocolVtbl &&
#endif // ! DPNBUILD_NOPROTOCOLTESTITF
#ifndef	DPNBUILD_NOMULTICAST
	   pIntList->lpVtbl != &DNMcast_Vtbl &&
#endif	// ! DPNBUILD_NOMULTICAST
       pIntList->lpVtbl != &SPMessagesVtbl
	   )
	{
		DPFX(DPFPREP,  0, "Invalid object - bad vtable" );
		return FALSE;
	}

	if( pIntList->iid != IID_IDirectPlay8Client &&
	   pIntList->iid != IID_IDirectPlay8Peer &&
#ifndef	DPNBUILD_NOSERVER
	   pIntList->iid != IID_IDirectPlay8Server &&
#endif	// ! DPNBUILD_NOSERVER
#ifndef DPNBUILD_NOVOICE
	   pIntList->iid != IID_IDirectPlayVoiceTransport &&
#endif // ! DPNBUILD_NOVOICE
#ifndef DPNBUILD_NOPROTOCOLTESTITF
       pIntList->iid != IID_IDirectPlay8Protocol &&
#endif // ! DPNBUILD_NOPROTOCOLTESTITF
#ifndef	DPNBUILD_NOMULTICAST
	   pIntList->iid != IID_IDirectPlay8Multicast &&
#endif	// ! DPNBUILD_NOMULTICAST
       pIntList->iid != IID_IDP8SPCallback )
	{
		DPFX(DPFPREP,  0, "Invalid object - bad iid" );
		return FALSE;
	}

	if( pIntList->pObject == NULL ||
	   !DNVALID_READPTR( pIntList->pObject, sizeof( OBJECT_DATA ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object" );
		return FALSE;
	}

	DIRECTNETOBJECT *pdn = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE( lpvObject );

	if( pdn == NULL ||
	   !DNVALID_WRITEPTR( pdn, sizeof( DIRECTNETOBJECT ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid object" );
		return FALSE;
	}

	return TRUE;
}
#endif // ! DPNBUILD_LIBINTERFACE


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidSPCaps"

HRESULT DN_ValidSPCaps( const DPN_SP_CAPS * const pdnSPCaps )
{
    if( pdnSPCaps == NULL ||
       !DNVALID_READPTR( pdnSPCaps, sizeof( DPN_SP_CAPS ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for SP caps" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnSPCaps->dwSize != sizeof( DPN_SP_CAPS ) )
    {
        DPFX(DPFPREP,  0, "Invalid structure size" );
        return DPNERR_INVALIDPARAM;
    }

#ifdef DPNBUILD_ONLYONETHREAD
	if ( pdnSPCaps->dwNumThreads != 0 )
	{
		DPFX(DPFPREP,  0, "Invalid thread count, must be 0!" );
		return DPNERR_INVALIDPARAM;
	}
#endif // DPNBUILD_ONLYONETHREAD

	if ( pdnSPCaps->dwBuffersPerThread == 0 )
	{
		DPFX(DPFPREP,  0, "Invalid buffers per thread setting!" );
		return 	DPNERR_INVALIDPARAM;
	}

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidConnectionInfo"

HRESULT DN_ValidConnectionInfo( const DPN_CONNECTION_INFO * const pdnConnectionInfo )
{
    if( pdnConnectionInfo == NULL ||
       !DNVALID_READPTR( pdnConnectionInfo, sizeof( DPN_CONNECTION_INFO ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer for connection info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO ) 
#ifndef DPNBUILD_NOPROTOCOLTESTITF
		&& pdnConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO_INTERNAL )
#endif // !DPNBUILD_NOPROTOCOLTESTITF
		)
    {
        DPFX(DPFPREP,  0, "Invalid structure size" );
        return DPNERR_INVALIDPARAM;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidCaps"

HRESULT DN_ValidCaps( const DPN_CAPS * const pdnCaps )
{
	if( pdnCaps == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid pointer for caps" );
		return DPNERR_INVALIDPOINTER;
	}

	if( pdnCaps->dwSize != sizeof( DPN_CAPS )  && pdnCaps->dwSize != sizeof( DPN_CAPS_EX))
	{
		DPFX(DPFPREP,  0, "Invalid structure size" );
		return DPNERR_INVALIDPARAM;
	}

	if (DNVALID_READPTR( pdnCaps, pdnCaps->dwSize)==FALSE)
	{
		DPFX(DPFPREP,  0, "Invalid pointer for caps" );
		return DPNERR_INVALIDPOINTER;
	}
	
	if (pdnCaps->dwSize == sizeof( DPN_CAPS_EX))
	{
		DPN_CAPS_EX * pCapsEx=(DPN_CAPS_EX * ) pdnCaps;
		if (pCapsEx->dwNumSendRetries>MAX_SEND_RETRIES_TO_DROP_LINK)
		{
			DPFX(DPFPREP,  0, "DPN_CAPS_EX::dwMaxNumSendRetries value %u is greater than %u ",  
									pCapsEx->dwNumSendRetries, MAX_SEND_RETRIES_TO_DROP_LINK);
			return DPNERR_INVALIDPARAM;
		}
		if (pCapsEx->dwMaxSendRetryInterval>MAX_SEND_RETRY_INTERVAL_LIMIT)
		{
			DPFX(DPFPREP,  0, "DPN_CAPS_EX::dwMaxSendRetryInterval value %u is greater than %u ",  
									pCapsEx->dwMaxSendRetryInterval, MAX_SEND_RETRY_INTERVAL_LIMIT);
			return DPNERR_INVALIDPARAM;
		}
		else if (pCapsEx->dwMaxSendRetryInterval<MIN_SEND_RETRY_INTERVAL_LIMIT)
		{
			DPFX(DPFPREP,  0, "DPN_CAPS_EX::dwMaxSendRetryInterval value %u is less than %u ",  
									pCapsEx->dwMaxSendRetryInterval, MIN_SEND_RETRY_INTERVAL_LIMIT);
			return DPNERR_INVALIDPARAM;
		}
		if (pCapsEx->dwDropThresholdRate > 100)
		{
			DPFX(DPFPREP,  0, "DPN_CAPS_EX::dwDropThresholdRate value %u is greater than 100",  
									pCapsEx->dwDropThresholdRate);
			return DPNERR_INVALIDPARAM;
		}
		if (pCapsEx->dwThrottleRate > 100)
		{
			DPFX(DPFPREP,  0, "DPN_CAPS_EX::dwThrottleRate value %u is greater than 100",  
									pCapsEx->dwThrottleRate);
			return DPNERR_INVALIDPARAM;
		}
		if (pCapsEx->dwNumHardDisconnectSends>MAX_HARD_DISCONNECT_SENDS)
		{
			DPFX(DPFPREP,  0, "DPN_CAPS_EX::dwNumHardDisconnectSends value %u is greater than %u",  
									pCapsEx->dwNumHardDisconnectSends, MAX_HARD_DISCONNECT_SENDS);
			return DPNERR_INVALIDPARAM;
		}
		else if (pCapsEx->dwNumHardDisconnectSends<MIN_HARD_DISCONNECT_SENDS)
		{
			DPFX(DPFPREP,  0, "DPN_CAPS_EX::dwNumHardDisconnectSends value %u is less than %u",  
									pCapsEx->dwNumHardDisconnectSends, MIN_HARD_DISCONNECT_SENDS);
			return DPNERR_INVALIDPARAM;
		}
		if (pCapsEx->dwMaxHardDisconnectPeriod>MAX_HARD_DISCONNECT_PERIOD)
		{
			DPFX(DPFPREP,  0, "DPN_CAPS_EX::dwMaxHardDisconnectPeriod value %u is greater than %u",  
									pCapsEx->dwMaxHardDisconnectPeriod, MAX_HARD_DISCONNECT_PERIOD);
			return DPNERR_INVALIDPARAM;
		}
		else if (pCapsEx->dwMaxHardDisconnectPeriod<MIN_HARD_DISCONNECT_PERIOD)
		{
			DPFX(DPFPREP,  0, "DPN_CAPS_EX::dwMaxHardDisconnectPeriod value %u is less than %u",  
									pCapsEx->dwMaxHardDisconnectPeriod, MIN_HARD_DISCONNECT_PERIOD);
			return DPNERR_INVALIDPARAM;
		}
	}
    return DPN_OK;
}

#endif // !DPNBUILD_NOPARAMVAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\ntoplist.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTOpList.h
 *  Content:    DirectNet NameTable Operation List Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/19/00	mjn		Created
 *	01/20/00	mjn		Added DNNTOLGetVersion,DNNTOLDestroyEntry,
 *						DNNTOLCleanUp,DNNTOLProcessOperation
 *	01/24/00	mjn		Implemented NameTable operation list version cleanup
 *	01/25/00	mjn		Added pending operation list routines DNPOAdd and DNPORun
 *	01/26/00	mjn		Added DNNTOLFindEntry
 *	07/19/00	mjn		Added DNPOCleanUp()
 *	08/28/00	mjn		Moved CPendingDeletion out
 *				mjn		Revamped NameTable operation list routines
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added service provider to DNNTAddOperation()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NTOPLIST_H__
#define	__NTOPLIST_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_NAMETABLE_OP_RESYNC_INTERVAL		4

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


//
//
//

HRESULT DNNTHostReceiveVersion(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   void *const pMsg);

HRESULT DNNTPlayerSendVersion(DIRECTNETOBJECT *const pdnObject);

HRESULT DNNTHostResyncVersion(DIRECTNETOBJECT *const pdnObject,
							  const DWORD dwVersion);

HRESULT DNNTPlayerResyncVersion(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg);

//
//
//

HRESULT DNNTGetOperationVersion(DIRECTNETOBJECT *const pdnObject,
								const DWORD dwMsgId,
								void *const pOpBuffer,
								const DWORD dwOpBufferSize,
								DWORD *const pdwVersion,
								DWORD *const pdwVersionNotUsed);

HRESULT DNNTPerformOperation(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 void *const pvBuffer);

HRESULT DNNTAddOperation(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 void *const pOpBuffer,
						 const DWORD dwOpBufferSize,
						 const HANDLE hProtocol,
						 CServiceProvider *const pSP);

HRESULT	DNNTFindOperation(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwVersion,
						  CNameTableOp **ppNTOp);

void DNNTRemoveOperations(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwOldestVersion,
						  const BOOL fRemoveAll);


//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __NTOPLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\nametable.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NameTable.h
 *  Content:    NameTable Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/11/00	mjn		Created
 *	04/09/00	mjn		Track outstanding connections in NameTable
 *	05/03/00	mjn		Implemented GetHostPlayerRef, GetLocalPlayerRef, GetAllPlayersGroupRef
 *	07/20/00	mjn		Added ClearHostWithDPNID()
 *	07/30/00	mjn		Added hrReason to CNameTable::EmptyTable()
 *	08/23/00	mjn		Added CNameTableOp
 *	09/05/00	mjn		Added m_dpnidMask
 *				mjn		Removed dwIndex from InsertEntry()
 *	09/17/00	mjn		Split m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *				mjn		Changed AddPlayerToGroup and RemovePlayerFromGroup to use NameTableEntry params
 *	09/26/00	mjn		Removed locking from SetVersion(),GetNewVersion()
 *				mjn		Changed DWORD GetNewVersion(void) to void GetNewVersion( PDWORD )
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking NameTable
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NAMETABLE_H__
#define	__NAMETABLE_H__

#include "ReadWriteLock.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//
//	NameTable
//	
//	The NameTable consists of:
//		- an array of CNameTableEntry pointers
//		- short-cuts to the LocalPlayer, Host and AllPlayersGroup
//		- a version number
//
//	There is a list running through the free entries in the NameTable array.
//	When a free entry is required, it is taken from the front of this list,
//	and when an entry is released, it is added to the end of the list.
//	If a particular entry is required, it must be properly removed from the
//	list.  This may be a little time-consuming, since the entire list may
//	need to be traversed, but this will only happen on non-Host cases and
//	is a small price to pay to keep the Host case timely.
//

//
//	DPNIDs
//
//	DPNIDs are unique identifiers for NameTable entries.  They are constructed
//	from the NameTable array index and the version number of the entry.
//	The value 0x0 is invalid.  As a result, we must prevent it from being
//	generated.  Since the DPNID is constructed from two parts, we can do
//	this by ensuring that one of the two parts is never 0.  The best
//	solution is to ensure that the NameTable array index is never 0.
//	

//
//	Locking
//
//	When locking multiple entries in the NameTable, locks should be taken
//	in order based on DPNIDs.  e.g. Locking two entries with DPNIDs 200 and
//	101, the lock for 101 should be taken before the lock for 200.  Locks for
//	groups should be taken before locks for players.
//


//**********************************************************************
// Constant definitions
//**********************************************************************

#define NAMETABLE_INDEX_MASK			0x000FFFFF
#define NAMETABLE_VERSION_MASK			0xFFF00000
#define NAMETABLE_VERSION_SHIFT			20

#define	NAMETABLE_ARRAY_ENTRY_FLAG_VALID	0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#define	CONSTRUCT_DPNID(i,v)	(((i & NAMETABLE_INDEX_MASK) | ((v << NAMETABLE_VERSION_SHIFT) & NAMETABLE_VERSION_MASK)) ^ m_dpnidMask)
#define	DECODE_INDEX(d)			((d ^ m_dpnidMask) & NAMETABLE_INDEX_MASK)
#define	VERIFY_VERSION(d,v)		(((d ^ m_dpnidMask) & NAMETABLE_VERSION_MASK) == (v << NAMETABLE_VERSION_SHIFT))

//**********************************************************************
// Structure definitions
//**********************************************************************

class CPackedBuffer;
class CConnection;
class CNameTableEntry;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

typedef struct _NAMETABLE_ARRAY_ENTRY
{
	CNameTableEntry	*pNameTableEntry;
	DWORD			dwFlags;
} NAMETABLE_ARRAY_ENTRY;

typedef struct _DN_NAMETABLE_INFO
{
	DPNID	dpnid;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwEntryCount;
	DWORD	dwMembershipCount;
} DN_NAMETABLE_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable

class CNameTable
{
public:
	CNameTable()				// Constructor
		{
			m_Sig[0] = 'N';
			m_Sig[1] = 'T';
			m_Sig[2] = 'B';
			m_Sig[3] = 'L';
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::~CNameTable"
	~CNameTable()
		{
		};			// Destructor

	HRESULT CNameTable::Initialize(DIRECTNETOBJECT *const pdnObject);

	void CNameTable::Deinitialize( void );

	void ReadLock( void )
		{
			m_RWLock.EnterReadLock();
		};

	void WriteLock( void )
		{
			m_RWLock.EnterWriteLock();
		};

	void Unlock( void )
		{
			m_RWLock.LeaveLock();
		};

#ifdef DBG
	void CNameTable::ValidateArray( void );
#endif // DBG

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	HRESULT CNameTable::SetNameTableSize( const DWORD dwNumEntries );
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	HRESULT CNameTable::GrowNameTable( void );
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

	void CNameTable::ResetNameTable( void );

	HRESULT CNameTable::UpdateTable(const DWORD dwIndex,
									CNameTableEntry *const pNameTableEntry);

	HRESULT CNameTable::InsertEntry(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ReleaseEntry(const DWORD dwIndex);

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::GetNewVersion"
	void GetNewVersion( DWORD *const pdwVersion )
		{
			DNASSERT( pdwVersion != NULL );

			*pdwVersion = ++m_dwVersion;

			DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::SetVersion"
	void SetVersion( const DWORD dwVersion )
		{
			m_dwVersion = dwVersion;

			DPFX(DPFPREP, 8,"Setting new version [%ld]",m_dwVersion);
		};

	DWORD GetVersion( void ) const
		{
			return(m_dwVersion);
		};

	void CNameTable::EmptyTable( const HRESULT hrReason );

	HRESULT CNameTable::FindEntry(const DPNID dpnid,
								  CNameTableEntry **const ppNameTableEntry);

	HRESULT	CNameTable::FindDeletedEntry(const DPNID dpnid,
										 CNameTableEntry **const ppNTEntry);

	HRESULT	CNameTable::AddEntry(CNameTableEntry *const pNTEntry);

	HRESULT CNameTable::DeletePlayer(const DPNID dpnid,
									 DWORD *const pdwVersion);

	HRESULT CNameTable::DeleteGroup(const DPNID dpnid,
									DWORD *const pdwVersion);

	HRESULT CNameTable::AddPlayerToGroup(CNameTableEntry *const pGroup,
										 CNameTableEntry *const pPlayer,
										 DWORD *const pdwVersion);

	HRESULT CNameTable::RemovePlayerFromGroup(CNameTableEntry *const pGroup,
											  CNameTableEntry *const pPlayer,
											  DWORD *const pdwVersion);

	HRESULT CNameTable::RemoveAllPlayersFromGroup(CNameTableEntry *const pGroup);

	HRESULT CNameTable::RemoveAllGroupsFromPlayer(CNameTableEntry *const pPlayer);

	BOOL CNameTable::IsMember(const DPNID dpnidGroup,
							  const DPNID dpnidPlayer);

	HRESULT CNameTable::PackNameTable(CNameTableEntry *const pTarget,
									  CPackedBuffer *const pPackedBuffer);

	HRESULT	CNameTable::UnpackNameTableInfo(UNALIGNED DN_NAMETABLE_INFO *const pdnNTInfo,
											BYTE *const pBufferStart,
											DPNID *const pdpnid);

	CNameTableEntry *GetDefaultPlayer( void )
		{
			return(m_pDefaultPlayer);
		};

	void MakeLocalPlayer(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ClearLocalPlayer( void );

	CNameTableEntry *GetLocalPlayer( void )
		{
			return(m_pLocalPlayer);
		};

	HRESULT CNameTable::GetLocalPlayerRef( CNameTableEntry **const ppNTEntry );

	void MakeHostPlayer(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ClearHostPlayer( void );

	BOOL CNameTable::ClearHostWithDPNID( const DPNID dpnid );

	void CNameTable::UpdateHostPlayer( CNameTableEntry *const pNewHost );

	CNameTableEntry *GetHostPlayer( void )
		{
			return(m_pHostPlayer);
		};

	HRESULT CNameTable::GetHostPlayerRef( CNameTableEntry **const ppNTEntry );

	void MakeAllPlayersGroup(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ClearAllPlayersGroup( void );

	CNameTableEntry *GetAllPlayersGroup( void )
		{
			return(m_pAllPlayersGroup);
		};

	HRESULT CNameTable::GetAllPlayersGroupRef( CNameTableEntry **const ppNTEntry );

	HRESULT CNameTable::PopulateConnection(CConnection *const pConnection);

	HRESULT CNameTable::PopulateGroup(CNameTableEntry *const pGroup);

	HRESULT CNameTable::AutoCreateGroups(CNameTableEntry *const pPlayer);

	HRESULT CNameTable::AutoDestructGroups(const DPNID dpnid);

	void CNameTable::SetLatestVersion( const DWORD dwVersion )
		{
			m_dwLatestVersion = dwVersion;
		};

	DWORD CNameTable::GetLatestVersion( void ) const
		{
			return( m_dwLatestVersion );
		};

	void CNameTable::SetConnectVersion(const DWORD dwVersion)
		{
			m_dwConnectVersion = dwVersion;
		};

	DWORD CNameTable::GetConnectVersion( void ) const
		{
			return(m_dwConnectVersion);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::IncOutstandingConnections"
	void IncOutstandingConnections( void )
		{
			long	lRefCount;

			lRefCount = DNInterlockedIncrement(&m_lOutstandingConnections);
			DNASSERT(lRefCount > 0);
		};

	void SetDPNIDMask( const DPNID dpnidMask )
		{
			m_dpnidMask = dpnidMask;
		};

	DPNID GetDPNIDMask( void ) const
		{
			return( m_dpnidMask );
		};

	void CNameTable::DecOutstandingConnections( void );


	CBilink		m_bilinkPlayers;
	CBilink		m_bilinkGroups;
	CBilink		m_bilinkDeleted;
	CBilink		m_bilinkNameTableOps;

private:
	BYTE					m_Sig[4];
	DIRECTNETOBJECT			*m_pdnObject;

	DPNID					m_dpnidMask;

	CNameTableEntry			*m_pDefaultPlayer;
	CNameTableEntry			*m_pLocalPlayer;
	CNameTableEntry			*m_pHostPlayer;
	CNameTableEntry			*m_pAllPlayersGroup;

	NAMETABLE_ARRAY_ENTRY	*m_NameTableArray;
	DWORD					m_dwNameTableSize;
	DWORD					m_dwFirstFreeEntry;
	DWORD					m_dwLastFreeEntry;
	DWORD					m_dwNumFreeEntries;

	DWORD					m_dwVersion;

	DWORD					m_dwLatestVersion;	// Only used by Host in PEER

	DWORD					m_dwConnectVersion;
	LONG					m_lOutstandingConnections;

	CReadWriteLock			m_RWLock;
};

#undef DPF_MODNAME

#endif	// __NAMETABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\ntoplist.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTOpList.cpp
 *  Content:    DirectNet NameTable Operation List
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/19/00	mjn		Created
 *	01/20/00	mjn		Added DNNTOLGetVersion,DNNTOLDestroyEntry,
 *						DNNTOLCleanUp,DNNTOLProcessOperation
 *	01/21/00	mjn		Host ACKnowledgements contain the actual op and not the REQuest
 *	01/24/00	mjn		Implemented NameTable operation list version cleanup
 *	01/25/00	mjn		Send dwLatestVersion to Host at migration
 *	01/25/00	mjn		Added pending operation list routines DNPOAdd and DNPORun
 *	01/26/00	mjn		Added DNNTOLFindEntry
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	07/19/00	mjn		Added DNPOCleanUp()
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *	08/08/00	mjn		Ensure DNOLPlayerSendVersion() takes player reference correctly
 *	08/24/00	mjn		Added CNameTableOp (to replace DN_NAMETABLE_OP)
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	09/28/00	mjn		Fixed logic error in DNNTAddOperation()
 *	01/25/01	mjn		Fixed 64-bit alignment problem in DNNTGetOperationVersion()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added service provider to DNNTAddOperation()
 *	04/05/01	mjn		Overwrite old NameTable operations with newer ones in DNNTAddOperation()
 *	04/11/01	mjn		Cleanup and return CNameTableOp if replaced in DNNTAddOperation()
 *	07/22/01	mjn		Added DPNBUILD_NOHOSTMIGRATE compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#ifndef	DPNBUILD_NOHOSTMIGRATE
//	DNNTHostReceiveVersion
//
//	Update the NameTable version of a player's entry in the Host player's NameTable

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTHostReceiveVersion"

HRESULT DNNTHostReceiveVersion(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   void *const pMsg)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	UNALIGNED DN_INTERNAL_MESSAGE_NAMETABLE_VERSION	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pMsg [0x%p]",dpnid,pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	pNTEntry = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_NAMETABLE_VERSION*>(pMsg);

	//
	//	Find player's entry in NameTable
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Player no longer in NameTable");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Update version number of entry
	//
	DPFX(DPFPREP, 7,"Set player [0x%lx] dwLatestVersion [%ld]", dpnid,pInfo->dwVersion);
	pNTEntry->Lock();
	pNTEntry->SetLatestVersion(pInfo->dwVersion);
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If the host is migrating, see if we can continue
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNCheckReceivedAllVersions(pdnObject);
	}
	else
	{
		DWORD	dwOldestVersion;
		BOOL	fReSync;
		CBilink	*pBilink;

		//
		//	Determine the oldest version EVERYONE has updated to
		//
		fReSync = FALSE;
		dwOldestVersion = pInfo->dwVersion;
		pdnObject->NameTable.ReadLock();
		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->Lock();
			if (pNTEntry->IsAvailable() && !pNTEntry->IsHost())
			{
				if (pNTEntry->GetLatestVersion() < dwOldestVersion)
				{
					dwOldestVersion = pNTEntry->GetLatestVersion();
				}
			}
			pNTEntry->Unlock();
			pNTEntry = NULL;
			pBilink = pBilink->GetNext();
		}
		if (dwOldestVersion > pdnObject->NameTable.GetLatestVersion())
		{
			fReSync = TRUE;
		}
		pdnObject->NameTable.Unlock();

		//
		//	Resync NameTable versions of other players if required
		//
		if (fReSync)
		{
			DNNTHostResyncVersion(pdnObject,dwOldestVersion);
		}
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}
#endif // DPNBUILD_NOHOSTMIGRATE


#ifndef	DPNBUILD_NOHOSTMIGRATE
//	DNNTPlayerSendVersion
//
//	Send the Local player's NameTable version to the Host
//	This should only be called in Peer-to-Peer mode

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTPlayerSendVersion"

HRESULT DNNTPlayerSendVersion(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pHostPlayer;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_NAMETABLE_VERSION	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_PEER);

	pHostPlayer = NULL;
	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	//
	//	Get Host player reference
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_NOHOSTPLAYER;
		goto Failure;
	}

	//
	//	Host player updates entry directly
	//
	if (pHostPlayer->IsLocal())
	{
		DWORD	dwVersion;

		pdnObject->NameTable.ReadLock();
		dwVersion = pdnObject->NameTable.GetVersion();
		pdnObject->NameTable.Unlock();

		DPFX(DPFPREP, 7,"Set Host player dwLatestVersion [%ld]",dwVersion);
		pHostPlayer->Lock();
		pHostPlayer->SetLatestVersion(dwVersion);
		pHostPlayer->Unlock();

	}
	else
	{
		//
		//	Create message and send to Host player
		//
		hResultCode = RefCountBufferNew(pdnObject,
										sizeof(DN_INTERNAL_MESSAGE_NAMETABLE_VERSION),
										MemoryBlockAlloc,
										MemoryBlockFree,
										&pRefCountBuffer);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not allocate space for RefCount buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_NAMETABLE_VERSION*>(pRefCountBuffer->GetBufferAddress());
		pdnObject->NameTable.ReadLock();
		pInfo->dwVersion = pdnObject->NameTable.GetVersion();
		pInfo->dwVersionNotUsed = 0;
		pdnObject->NameTable.Unlock();

		DPFX(DPFPREP, 7,"Send Local player dwLatestVersion [%ld]",pInfo->dwVersion);

		//
		//	Send message to host player
		//
		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create worker job");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_VERSION );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}
#endif // DPNBUILD_NOHOSTMIGRATE


#ifndef	DPNBUILD_NOHOSTMIGRATE
//	DNNTHostResyncVersion
//
//	Re-sync of the NameTable operation lists based on lowest common version number

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTHostResyncVersion"

HRESULT DNNTHostResyncVersion(DIRECTNETOBJECT *const pdnObject,
							  const DWORD dwVersion)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_RESYNC_VERSION	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: dwVersion [%ld]",dwVersion);

	DNASSERT(pdnObject != NULL);

	pWorkerJob = NULL;
	pRefCountBuffer = NULL;

	//
	//	Create re-sync message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_RESYNC_VERSION),MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCount buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pInfo = (DN_INTERNAL_MESSAGE_RESYNC_VERSION *)(pRefCountBuffer->GetBufferAddress());
	pInfo->dwVersion = dwVersion;
	pInfo->dwVersionNotUsed = 0;

	//
	//	Hand this to worker thread
	//
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not allocate new worker thread job");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
	pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_RESYNC_VERSION );
	pWorkerJob->SetSendNameTableOperationVersion( 0 );
	pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
	pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pWorkerJob)
	{
		pWorkerJob->ReturnSelfToPool();
		pWorkerJob = NULL;
	}
	goto Exit;
}
#endif // DPNBUILD_NOHOSTMIGRATE


#ifndef	DPNBUILD_NOHOSTMIGRATE
//	DNNTPlayerResyncVersion
//
//	Re-sync of the NameTable operation list from Host player

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTPlayerResyncVersion"

HRESULT DNNTPlayerResyncVersion(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_RESYNC_VERSION	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	pInfo = static_cast<DN_INTERNAL_MESSAGE_RESYNC_VERSION*>(pMsg);

	DPFX(DPFPREP, 5,"Instructed to clean up NameTable operation list dwVersion < [%ld]",
			pInfo->dwVersion);
	DNNTRemoveOperations(pdnObject,pInfo->dwVersion,FALSE);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
#endif // DPNBUILD_NOHOSTMIGRATE


//	DNNTGetOperationVersion
//
//	Find the version number of a NameTable Operation

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTGetOperationVersion"

HRESULT DNNTGetOperationVersion(DIRECTNETOBJECT *const pdnObject,
								const DWORD dwMsgId,
								void *const pOpBuffer,
								const DWORD dwOpBufferSize,
								DWORD *const pdwVersion,
								DWORD *const pdwVersionNotUsed)
{
	HRESULT	hResultCode;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], pdwVersion [0x%p]",
			dwMsgId,pOpBuffer,dwOpBufferSize,pdwVersion);

	DNASSERT(pdwVersion != NULL);
	DNASSERT(pdwVersionNotUsed != NULL);

	hResultCode = DPN_OK;
	switch (dwMsgId)
	{
	case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT *>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER:
		{
			*pdwVersion = static_cast<UNALIGNED DN_NAMETABLE_ENTRY_INFO *>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_NAMETABLE_ENTRY_INFO *>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_PLAYER:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_PLAYER *>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_PLAYER *>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_CREATE_GROUP:
		{
			*pdwVersion = (reinterpret_cast<UNALIGNED DN_NAMETABLE_ENTRY_INFO*>((static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pOpBuffer)) + 1))->dwVersion;
			*pdwVersionNotUsed = (reinterpret_cast<UNALIGNED DN_NAMETABLE_ENTRY_INFO*>((static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pOpBuffer)) + 1))->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_GROUP:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_UPDATE_INFO:
		{
			*pdwVersion = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<UNALIGNED DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	default:
		{
			DPFERR("Invalid MessageID");
			DNASSERT(FALSE);
			hResultCode = DPNERR_UNSUPPORTED;
		}
	}
	if (hResultCode == DPN_OK)
	{
		DPFX(DPFPREP, 7,"*pdwVersion = [%ld]",*pdwVersion);
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNNTPerformOperation"

HRESULT DNNTPerformOperation(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 void *const pvBuffer)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pvBuffer [0x%p]",dwMsgId,pvBuffer);

	switch (dwMsgId)
	{
	case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_INSTRUCT_CONNECT");
			if ((hResultCode = DNConnectToPeer2(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Instructed connect failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_ADD_PLAYER");
			if ((hResultCode = DNConnectToPeer1(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Add player failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_PLAYER:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_DESTROY_PLAYER");
			if ((hResultCode = DNInstructedDisconnect(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Destroy player failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_CREATE_GROUP:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_CREATE_GROUP");
			if ((hResultCode = DNProcessCreateGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Create group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_GROUP:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_DESTROY_GROUP");
			if ((hResultCode = DNProcessDestroyGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Destroy group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP");
			if ((hResultCode = DNProcessAddPlayerToGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Add player to group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP");
			if ((hResultCode = DNProcessDeletePlayerFromGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Remove player from group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_UPDATE_INFO:
		{
			DPFX(DPFPREP, 7,"Perform DN_MSG_INTERNAL_UPDATE_INFO");
			if ((hResultCode = DNProcessUpdateInfo(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Update info failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	default:
		{
			DPFERR("Invalid MessageID");
			DNASSERT(FALSE);
			return(DPNERR_UNSUPPORTED);
		}
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNNTAddOperation
//
//	Add an operation to the NameTable operation list

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTAddOperation"

HRESULT DNNTAddOperation(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 void *const pOpBuffer,
						 const DWORD dwOpBufferSize,
						 const HANDLE hProtocol,
						 CServiceProvider *const pSP)
#ifndef	DPNBUILD_NOHOSTMIGRATE
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableOp	*pNTOp;
	BOOL			fReSync;

	DPFX(DPFPREP, 4,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], hProtocol [0x%lx], pSP [0x%p]",
			dwMsgId,pOpBuffer,dwOpBufferSize,hProtocol,pSP);

	pRefCountBuffer = NULL;
	pNTOp = NULL;
	fReSync = FALSE;

	//
	//	We will only need to worry about maintaining the operation list in PEER mode.
	//	Otherwise, just perform the operation
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DWORD			dwVersion;
		DWORD			dwVersionNotUsed;
		BOOL			fFound;
		CBilink			*pBilink;
		CNameTableOp	*pCurrent;

		dwVersion = 0;
		dwVersionNotUsed = 0;

		//
		//	Get version of this operation
		//
		if ((hResultCode = DNNTGetOperationVersion(	pdnObject,
													dwMsgId,
													pOpBuffer,
													dwOpBufferSize,
													&dwVersion,
													&dwVersionNotUsed)) != DPN_OK)
		{
			DPFERR("Could not determine operation version");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Create NameTableOp
		//
		if ((hResultCode = NameTableOpNew(pdnObject,&pNTOp)) != DPN_OK)
		{
			DPFERR("Could not create NameTableOp");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Keep operation in a RefCountBuffer.  If a protocol buffer was supplied (with handle)
		//	we will just release the buffer when we're done with it.  Otherwise, we will need
		//	to copy the buffer supplied.
		//
		if (hProtocol)
		{
			if ((hResultCode = RefCountBufferNew(pdnObject,0,NULL,NULL,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				hResultCode = DPN_OK;
				goto Failure;
			}
			pRefCountBuffer->SetBufferDesc(	static_cast<BYTE*>(pOpBuffer),
											dwOpBufferSize,
											DNFreeProtocolBuffer,
											hProtocol);
		}
		else
		{
			if ((hResultCode = RefCountBufferNew(pdnObject,dwOpBufferSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				hResultCode = DPN_OK;
				goto Failure;
			}
			memcpy(pRefCountBuffer->GetBufferAddress(),pOpBuffer,dwOpBufferSize);
		}

		pNTOp->SetMsgId(dwMsgId);
		pNTOp->SetRefCountBuffer(pRefCountBuffer);
		pNTOp->SetSP( pSP );
		pNTOp->SetVersion(dwVersion);

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;

		//
		//	Insert into the NameTableOp list
		//
		fFound = FALSE;
		pdnObject->NameTable.WriteLock();
		pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
		{
			pCurrent = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
			if (dwVersion < pCurrent->GetVersion())
			{
				pNTOp->m_bilinkNameTableOps.InsertBefore(&pCurrent->m_bilinkNameTableOps);
				pCurrent = NULL;
				fFound = TRUE;
				break;
			}
			if (dwVersion == pCurrent->GetVersion())
			{
				//
				//	This is a NEWER operation which will replace the current operation in the list
				//
				pNTOp->m_bilinkNameTableOps.InsertBefore(&pCurrent->m_bilinkNameTableOps);
				pCurrent->m_bilinkNameTableOps.RemoveFromList();
				if (pCurrent->GetRefCountBuffer())
				{
					pCurrent->GetRefCountBuffer()->Release();
					pCurrent->SetRefCountBuffer( NULL );
				}
				if (pCurrent->GetSP())
				{
					pCurrent->GetSP()->Release();
					pCurrent->SetSP( NULL );
				}
				pCurrent->ReturnSelfToPool();
				pCurrent = NULL;
				fFound = TRUE;
				break;
			}
			pCurrent = NULL;
			pBilink = pBilink->GetNext();
		}
		if (!fFound)
		{
			pNTOp->m_bilinkNameTableOps.InsertBefore(&pdnObject->NameTable.m_bilinkNameTableOps);
		}

		pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
		{
			pCurrent = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
			pBilink = pBilink->GetNext();
			if (pCurrent->GetVersion() > pdnObject->NameTable.GetVersion())
			{
				DPFX(DPFPREP, 8,"Current [%ld], NameTable [%ld], InUse [%ld]",pCurrent->GetVersion(),
						pdnObject->NameTable.GetVersion(),pCurrent->IsInUse());
				if ((pCurrent->GetVersion() == (pdnObject->NameTable.GetVersion() + 1))
						&& !pCurrent->IsInUse())
				{
					pCurrent->SetInUse();
					if ((pCurrent->GetVersion() % DN_NAMETABLE_OP_RESYNC_INTERVAL) == 0)
					{
						fReSync = TRUE;
					}
					pdnObject->NameTable.Unlock();

					hResultCode = DNNTPerformOperation(	pdnObject,
														pCurrent->GetMsgId(),
														pCurrent->GetRefCountBuffer()->GetBufferAddress() );

					pdnObject->NameTable.WriteLock();

				}
				else
				{
					//
					//	Once we find an operation that we won't perform, there is no point continuing
					//
					break;
				}
			}
		}

		//
		//	We will keep the operation buffer (if specified) so return DPNERR_PENDING
		//
		if (hProtocol)
		{
			hResultCode = DPNERR_PENDING;
		}
		else
		{
			hResultCode = DPN_OK;
		}

		pdnObject->NameTable.Unlock();

		//
		//	Send a re-sync to the host if required
		//
		if (fReSync)
		{
			DPFX(DPFPREP, 5,"Send NameTable version re-sync to Host");
			DNNTPlayerSendVersion(pdnObject);
		}
	}
	else
	{
		DNNTPerformOperation(pdnObject,dwMsgId,pOpBuffer);

		//
		//	We will not need to keep the operation buffer so return DPN_OK
		//
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return( hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTOp)
	{
		pNTOp->ReturnSelfToPool();
		pNTOp = NULL;
	}
	goto Exit;
}
#else
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableOp	*pNTOp;

	DPFX(DPFPREP, 4,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], hProtocol [0x%lx], pSP [0x%p]",
			dwMsgId,pOpBuffer,dwOpBufferSize,hProtocol,pSP);

	pRefCountBuffer = NULL;
	pNTOp = NULL;

	//
	//	We will only need to worry about maintaining the operation list in PEER mode.
	//	Otherwise, just perform the operation
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DWORD			dwVersion;
		DWORD			dwVersionNotUsed;

		dwVersion = 0;
		dwVersionNotUsed = 0;

		//
		//	Get version of this operation
		//
		if ((hResultCode = DNNTGetOperationVersion(	pdnObject,
													dwMsgId,
													pOpBuffer,
													dwOpBufferSize,
													&dwVersion,
													&dwVersionNotUsed)) != DPN_OK)
		{
			DPFERR("Could not determine operation version");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	This operation will either need to be performed immediately (and then discarded), or queued
		//
		pdnObject->NameTable.WriteLock();

		if (dwVersion == pdnObject->NameTable.GetVersion()+1)
		{
			CBilink			*pBilink;
			CNameTableOp	*pCurrent;

			pdnObject->NameTable.Unlock();

			hResultCode = DNNTPerformOperation(pdnObject,dwMsgId,pOpBuffer);

			//
			//	Perform any operations that are queued
			//
			pdnObject->NameTable.WriteLock();

			pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
			while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
			{
				pCurrent = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
				pBilink = pBilink->GetNext();

				DPFX(DPFPREP, 8,"Current [%ld], NameTable [%ld], InUse [%ld]",pCurrent->GetVersion(),
						pdnObject->NameTable.GetVersion(),pCurrent->IsInUse());
				if ((pCurrent->GetVersion() == (pdnObject->NameTable.GetVersion() + 1))
						&& !pCurrent->IsInUse())
				{
					pCurrent->SetInUse();
					pdnObject->NameTable.Unlock();

					hResultCode = DNNTPerformOperation(	pdnObject,
														pCurrent->GetMsgId(),
														pCurrent->GetRefCountBuffer()->GetBufferAddress() );

					pdnObject->NameTable.WriteLock();

					//
					//	If we're not supporting host migration,
					//	we can discard operations as soon as they've been performed
					//
					pCurrent->m_bilinkNameTableOps.RemoveFromList();
					if (pCurrent->GetRefCountBuffer())
					{
						pCurrent->GetRefCountBuffer()->Release();
						pCurrent->SetRefCountBuffer( NULL );
					}
					if (pCurrent->GetSP())
					{
						pCurrent->GetSP()->Release();
						pCurrent->SetSP( NULL );
					}
					pCurrent->ReturnSelfToPool();
				}
				else
				{
					//
					//	Once we find an operation that we won't perform, there is no point continuing
					//
					break;
				}
			}

			pdnObject->NameTable.Unlock();

			hResultCode = DPN_OK;
		}
		else
		{
			//
			//	Queue this operation for future execution
			//
			CNameTableOp	*pCurrent;
			CBilink			*pBilink;
			BOOL			fFound;

			//
			//	Create NameTableOp
			//
			if ((hResultCode = NameTableOpNew(pdnObject,&pNTOp)) != DPN_OK)
			{
				DPFERR("Could not create NameTableOp");
				DisplayDNError(0,hResultCode);
				hResultCode = DPN_OK;
				goto Failure;
			}

			//
			//	Keep operation in a RefCountBuffer.  If a protocol buffer was supplied (with handle)
			//	we will just release the buffer when we're done with it.  Otherwise, we will need
			//	to copy the buffer supplied.
			//
			if (hProtocol)
			{
				if ((hResultCode = RefCountBufferNew(pdnObject,0,NULL,NULL,&pRefCountBuffer)) != DPN_OK)
				{
					DPFERR("Could not create RefCountBuffer");
					DisplayDNError(0,hResultCode);
					hResultCode = DPN_OK;
					goto Failure;
				}
				pRefCountBuffer->SetBufferDesc(	static_cast<BYTE*>(pOpBuffer),
												dwOpBufferSize,
												DNFreeProtocolBuffer,
												hProtocol);
			}
			else
			{
				if ((hResultCode = RefCountBufferNew(pdnObject,dwOpBufferSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
				{
					DPFERR("Could not create RefCountBuffer");
					DisplayDNError(0,hResultCode);
					hResultCode = DPN_OK;
					goto Failure;
				}
				memcpy(pRefCountBuffer->GetBufferAddress(),pOpBuffer,dwOpBufferSize);
			}

			pNTOp->SetMsgId(dwMsgId);
			pNTOp->SetRefCountBuffer(pRefCountBuffer);
			pNTOp->SetSP( pSP );
			pNTOp->SetVersion(dwVersion);

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;

			//
			//	Insert into the NameTableOp list
			//
			fFound = FALSE;
//			pdnObject->NameTable.WriteLock();
			pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
			while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
			{
				pCurrent = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
				if (dwVersion < pCurrent->GetVersion())
				{
					pNTOp->m_bilinkNameTableOps.InsertBefore(&pCurrent->m_bilinkNameTableOps);
					pCurrent = NULL;
					fFound = TRUE;
					break;
				}
				if (dwVersion == pCurrent->GetVersion())
				{
					//
					//	This is a NEWER operation which will replace the current operation in the list
					//
					pNTOp->m_bilinkNameTableOps.InsertBefore(&pCurrent->m_bilinkNameTableOps);
					pCurrent->m_bilinkNameTableOps.RemoveFromList();
					if (pCurrent->GetRefCountBuffer())
					{
						pCurrent->GetRefCountBuffer()->Release();
						pCurrent->SetRefCountBuffer( NULL );
					}
					if (pCurrent->GetSP())
					{
						pCurrent->GetSP()->Release();
						pCurrent->SetSP( NULL );
					}
					pCurrent->ReturnSelfToPool();
					pCurrent = NULL;
					fFound = TRUE;
					break;
				}
				pCurrent = NULL;
				pBilink = pBilink->GetNext();
			}
			if (!fFound)
			{
				pNTOp->m_bilinkNameTableOps.InsertBefore(&pdnObject->NameTable.m_bilinkNameTableOps);
			}

			pdnObject->NameTable.Unlock();

			hResultCode = DPNERR_PENDING;
		}
	}
	else
	{
		DNNTPerformOperation(pdnObject,dwMsgId,pOpBuffer);

		//
		//	We will not need to keep the operation buffer so return DPN_OK
		//
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return( hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTOp)
	{
		pNTOp->ReturnSelfToPool();
		pNTOp = NULL;
	}
	goto Exit;
}
#endif // DPNBUILD_NOHOSTMIGRATE


//	DNNTFindOperation
//
//	Find a NameTable Operation

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTFindOperation"

HRESULT	DNNTFindOperation(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwVersion,
						  CNameTableOp **ppNTOp)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableOp	*pNTOp;

	DPFX(DPFPREP, 6,"Parameters: dwVersion [%ld = 0x%lx], ppNTOp [0x%p]",dwVersion,dwVersion,ppNTOp);

	DNASSERT(ppNTOp != NULL);

	hResultCode = DPNERR_DOESNOTEXIST;
	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if (pNTOp->GetVersion() == dwVersion)
		{
			*ppNTOp = pNTOp;
			hResultCode = DPN_OK;
			break;
		}
		else if (pNTOp->GetVersion() > dwVersion)
		{
			//
			//	Passed where it could have been, so there is no point in continuing
			//
			break;
		}
		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNNTRemoveOperations
//
//	Remove NameTable Operations

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTRemoveOperations"

void DNNTRemoveOperations(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwOldestVersion,
						  const BOOL fRemoveAll)
{
	CBilink			*pBilink;
	CNameTableOp	*pNTOp;

	DPFX(DPFPREP, 4,"Parameters: dwOldestVersion [%ld = 0x%lx], fRemoveAll [%ld]",dwOldestVersion,dwOldestVersion,fRemoveAll);

	DNASSERT(pdnObject != NULL);

	pdnObject->NameTable.WriteLock();
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		pBilink = pBilink->GetNext();

		if (fRemoveAll || (pNTOp->GetVersion() < dwOldestVersion))
		{
			pNTOp->m_bilinkNameTableOps.RemoveFromList();
			if (pNTOp->GetRefCountBuffer())
			{
				pNTOp->GetRefCountBuffer()->Release();
				pNTOp->SetRefCountBuffer( NULL );
			}
			if (pNTOp->GetSP())
			{
				pNTOp->GetSP()->Release();
				pNTOp->SetSP( NULL );
			}
			pNTOp->ReturnSelfToPool();
		}
	}
	pdnObject->NameTable.Unlock();

	DPFX(DPFPREP, 4,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\paramval.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       paramval.h
 *  Content:    DirectPlat8 Parameter Validation helper routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/28/00    rmt     Created
 *  04/17/00    rmt     More param validation
 *	04/19/00	mjn		Changed DN_RemoveClientFromGroup to DN_ValidateRemoveClientFromGroup (wrong function name)
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2  
 *	08/04/00	mjn		Added dwFlags to DN_ValidateGetConnectionInfoHelper()
 *	07/24/01	mjn		Added DPNBUILD_NOPARAMVAL compile flag
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *	10/08/01	vanceo	Added multicast interface method validation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __PARAMVAL_H
#define __PARAMVAL_H

#define DN_CHECK_LOCALHOST( x ) (x->NameTable.GetLocalPlayer() == x->NameTable.GetHostPlayer())

#ifndef	DPNBUILD_NOPARAMVAL

extern BOOL IsValidDirectPlay8Object( LPVOID lpvObject );

extern HRESULT DN_ValidateDestroyPlayer(PVOID pInterface,
							  const DPNID dnid,
							  const void *const pvDestroyData,
							  const DWORD dwDestroyDataSize,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateReturnBuffer(PVOID pInterface,
							 const DPNHANDLE hBufferHandle,
							 const DWORD dwFlags);

extern HRESULT DN_ValidateGetPlayerContext(PVOID pInterface,
								 const DPNID dpnid,
								 PVOID *const ppvPlayerContext,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateGetGroupContext(PVOID pInterface,
								const DPNID dpnid,
								PVOID *const ppvGroupContext,
								const DWORD dwFlags);

#ifndef DPNBUILD_NOLOBBY
extern HRESULT DN_ValidateRegisterLobby(PVOID pInterface,
							  const DPNHANDLE dpnhLobbyConnection, 	
							  const IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
							  const DWORD dwFlags);
#endif // ! DPNBUILD_NOLOBBY

extern HRESULT DN_ValidateTerminateSession(PVOID pInterface,
								 const void *const pvTerminateData,
								 const DWORD dwTerminateDataSize,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateGetHostAddress(PVOID pInterface,
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress,
							   const DWORD dwFlags);


#ifndef	DPNBUILD_NOSERVER
extern HRESULT DN_ValidateGetClientAddress(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateGetClientInfo(IDirectPlay8Server *pInterface,
							  const DPNID dpnid,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateSetServerInfo(IDirectPlay8Server *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);
#endif	// DPNBUILD_NOSERVER

extern HRESULT DN_ValidateSetPeerInfo( IDirectPlay8Peer *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateGetPeerInfo(IDirectPlay8Peer *pInterface,
							const DPNID dpnid,
							DPN_PLAYER_INFO *const pdpnPlayerInfo,
							DWORD *const pdwSize,
							const DWORD dwFlags);

extern HRESULT DN_ValidateGetPeerAddress(IDirectPlay8Peer *pInterface,
										 const DPNID dpnid,
										 IDirectPlay8Address **const ppAddress,
										 const DWORD dwFlags);

extern HRESULT DN_ValidateGetServerAddress(IDirectPlay8Client *pInterface,
										   IDirectPlay8Address **const ppAddress,
										   const DWORD dwFlags);

extern HRESULT DN_ValidateGetHostSendQueueInfo(IDirectPlay8Client *pInterface,
									 DWORD *const pdwNumMsgs,
									 DWORD *const pdwNumBytes,
									 const DWORD dwFlags );

extern HRESULT DN_ValidateGetServerInfo(IDirectPlay8Client *pInterface,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

extern HRESULT  DN_ValidateSetClientInfo(IDirectPlay8Client *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  const PVOID pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateGetConnectionInfoHelper(PVOID pv,
												  const DPNID dpnid,
												  DPN_CONNECTION_INFO *const pdpConnectionInfo,
												  BOOL fServerPlayer,
												  const DWORD dwFlags);

extern HRESULT DN_ValidateSetCaps(PVOID pv,
						const DPN_CAPS *const pdnCaps,
						const DWORD dwFlags);

extern HRESULT DN_ValidateGetCaps(PVOID pv,
								  DPN_CAPS *const pdnCaps,
								  const DWORD dwFlags);

extern HRESULT DN_ValidateGetSPCaps(PVOID pv,
									const GUID * const pguidSP,
									DPN_SP_CAPS *const pdnSPCaps,
									const DWORD dwFlags);

extern HRESULT DN_ValidateSetSPCaps(PVOID pv,
									const GUID * const pguidSP,
									const DPN_SP_CAPS *const pdnSPCaps,
									const DWORD dwFlags);

extern HRESULT DN_ValidateEnumHosts( PVOID pv,
						   const DPN_APPLICATION_DESC *const pApplicationDesc,
                           IDirectPlay8Address *const pAddrHost,
						   IDirectPlay8Address *const pDeviceInfo,
						   const VOID* const pUserEnumData,
						   const DWORD dwUserEnumDataSize,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   PVOID const pvAsyncContext,
						   DPNHANDLE *const pAsyncHandle,
						   const DWORD dwFlags );

HRESULT DN_ValidateRemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags);						

extern HRESULT DN_ValidateEnumGroupMembers(PVOID pInterface,
								 const DPNID dpnid,
								 DPNID *const prgdpnid,
								 DWORD *const pcdpnid,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateEnumClientsAndGroups(PVOID pInterface,
									 DPNID *const prgdpnid,
									 DWORD *const pcdpnid,
									 const DWORD dwFlags);

extern HRESULT DN_ValidateGetGroupInfo(PVOID pv,
							 const DPNID dpnid,
							 DPN_GROUP_INFO *const pdpnGroupInfo,
							 DWORD *const pdwSize,
							 const DWORD dwFlags);

extern HRESULT DN_ValidateSetGroupInfo( PVOID pv,
							  const DPNID dpnid,
							  const DPN_GROUP_INFO *const pdpnGroupInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateAddClientToGroup(PVOID pInterface,
								 const DPNID dpnidGroup,
								 const DPNID dpnidClient,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateRemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags);

extern HRESULT DN_ValidateDestroyGroup(PVOID pInterface,
							 const DPNID dpnidGroup,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags);

extern HRESULT DN_ValidateCreateGroup(PVOID pInterface,
							const DPN_GROUP_INFO *const pdpnGroupInfo,
							void *const pvGroupContext,
							void *const pvAsyncContext,
							DPNHANDLE *const phAsyncHandle,
							const DWORD dwFlags);

extern HRESULT DN_ValidateHost( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc,
                        IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,
  					    const DPN_SECURITY_DESC *const pdnSecurity,
  					    const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
					    void *const pvPlayerContext, const DWORD dwFlags);

extern HRESULT DN_ValidateEnumServiceProviders( PVOID pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidApplication,
									  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
									  DWORD *const pcbEnumData,
									  const DWORD *const pcReturned,
									  const DWORD dwFlags );

extern HRESULT DN_ValidateCancelAsyncOperation(PVOID pvInterface,
									 const DPNHANDLE hAsyncOp,
									 const DWORD dwFlags );

extern HRESULT DN_ValidateConnect( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc, IDirectPlay8Address *const pHostAddr,
            					   IDirectPlay8Address *const pDeviceInfo, const DPN_SECURITY_DESC *const pdnSecurity,
  						           const DPN_SECURITY_CREDENTIALS *const pdnCredentials, const void *const pvUserConnectData,
                                   const DWORD dwUserConnectDataSize, void *const pvPlayerContext,
          						   void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);

extern HRESULT DN_ValidateGetSendQueueInfo(PVOID pInterface, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes,const DWORD dwFlags);

extern HRESULT DN_ValidateSetApplicationDesc( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnApplicationDesc, const DWORD dwFlags);

extern HRESULT DN_ValidateGetApplicationDesc( PVOID pInterface, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags );

extern HRESULT DN_ValidateSendParams( PVOID pv, const DPN_BUFFER_DESC *const pBufferDesc, const DWORD cBufferDesc, const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);

#ifndef DPNBUILD_NOMULTICAST
extern HRESULT DN_ValidateJoin( IDirectPlay8Multicast *pInterface,
						   IDirectPlay8Address *const pGroupAddr,
						   IUnknown *const pDeviceInfo,
						   const DPN_SECURITY_DESC *const pdnSecurity,
						   const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						   void *const pvAsyncContext,
						   DPNHANDLE *const phAsyncHandle,
						   const DWORD dwFlags );

extern HRESULT DN_ValidateCreateSenderContext( IDirectPlay8Multicast *pInterface,
								  IDirectPlay8Address *const pSenderAddress,
								  void *const pvSenderContext,
								  const DWORD dwFlags );

extern HRESULT DN_ValidateDestroySenderContext( IDirectPlay8Multicast *pInterface,
								  IDirectPlay8Address *const pSenderAddress,
								  const DWORD dwFlags );

extern HRESULT DN_ValidateGetGroupAddress( IDirectPlay8Multicast *pInterface,
											 IDirectPlay8Address **const ppAddress,
											 const DWORD dwFlags );

extern HRESULT DN_ValidateEnumMulticastScopes( IDirectPlay8Multicast *pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidDevice,
									  const GUID *const pguidApplication,
									  DPN_MULTICAST_SCOPE_INFO *const pScopeInfoBuffer,
									  DWORD *const pcbEnumData,
									  const DWORD *const pcReturned,
									  const DWORD dwFlags );
#endif // ! DPNBUILD_NOMULTICAST

extern HRESULT DN_ValidBufferDescs( const DPN_BUFFER_DESC * const pbBufferDesc, const DWORD cBufferCount );

extern HRESULT DN_ValidConnectAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc );

extern HRESULT DN_ValidHostAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc );

extern HRESULT DN_ValidPlayerInfo( const DPN_PLAYER_INFO * const pdnPlayerInfo, BOOL fSet);

extern HRESULT DN_ValidGroupInfo( const DPN_GROUP_INFO * const pdnGroupInfo, BOOL fSet );

extern HRESULT DN_ValidSecurityCredentials( const DPN_SECURITY_CREDENTIALS * const pdnCredentials );

extern HRESULT DN_ValidSecurityDesc( const DPN_SECURITY_DESC * const pdnValidSecurityDesc );

extern HRESULT DN_ValidSPCaps( const DPN_SP_CAPS * const pdnSPCaps );

extern HRESULT DN_ValidConnectionInfo( const PDPN_CONNECTION_INFO * const pdnConnectionInfo );

extern HRESULT DN_ValidCaps( const DPN_CAPS * const pdnCaps );

#endif	// DPNBUILD_NOPARAMVAL

#endif	// __PARAMVAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\peer.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Peer.h
 *  Content:    Direct Net Peer interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  10/08/99	jtk		Split from DNCore.h
 *	12/03/99	jtk		Moved COM interface definitions to DNet.h
 *	01/15/00	mjn		Removed DN_PeerMessageHandler
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	04/06/00	mjn		Added GetPeerAddress to API
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__PEER_H__
#define	__PEER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for peer interface
//
extern IDirectPlay8PeerVtbl DN_PeerVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectNet - IDirectPlay8Peer
//
STDMETHODIMP DN_SetPeerInfo( IDirectPlay8Peer *pInterface,
							 const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags);

STDMETHODIMP DN_GetPeerInfo(IDirectPlay8Peer *pInterface,
							const DPNID dpnid,
							DPN_PLAYER_INFO *const pdpnPlayerInfo,
							DWORD *const pdwSize,
							const DWORD dwFlags);

STDMETHODIMP DN_GetPeerAddress(IDirectPlay8Peer *pInterface,
							   const DPNID dpnid,
							   IDirectPlay8Address **const ppAddress,
							   const DWORD dwFlags);

#endif	// __PEER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\pendingdel.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PendingDel.h
 *  Content:    DirectNet NameTable Pending Deletions Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/28/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__PENDINGDEL_H__
#define	__PENDINGDEL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable Pending Deletions

class CPendingDeletion
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CPendingDeletion::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CPendingDeletion* pPendingDel = (CPendingDeletion*)pvItem;

			pPendingDel->m_Sig[0] = 'N';
			pPendingDel->m_Sig[1] = 'T';
			pPendingDel->m_Sig[2] = 'P';
			pPendingDel->m_Sig[3] = 'D';

			pPendingDel->m_bilinkPendingDeletions.Initialize();

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CPendingDeletion::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CPendingDeletion* pPendingDel = (CPendingDeletion*)pvItem;

			pPendingDel->m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);
			pPendingDel->m_dpnid = 0;

			DNASSERT(pPendingDel->m_bilinkPendingDeletions.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CPendingDeletion::FPMRelease"
	static void FPMRelease(void* pvItem) 
		{ 
			const CPendingDeletion* pPendingDel = (CPendingDeletion*)pvItem;

			DNASSERT(pPendingDel->m_bilinkPendingDeletions.IsEmpty());
		};

	void ReturnSelfToPool( void )
		{
			g_PendingDeletionPool.Release( this );
		};

	void SetDPNID( const DPNID dpnid )
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID( void ) const
		{
			return( m_dpnid );
		};

	CBilink			m_bilinkPendingDeletions;

private:
	BYTE			m_Sig[4];
	DIRECTNETOBJECT	*m_pdnObject;
	DPNID			m_dpnid;
};

#undef DPF_MODNAME

#endif	// __PENDINGDEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\peer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Peer.cpp
 *  Content:    DNET peer interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/28/99	mjn		Disconnect handling happens when disconnect finishes instead of starts
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/11/00	mjn		Moved connect/disconnect stuff to Connect.h
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/22/00	mjn		Implemented DestroyClient in API
 *	01/28/00	mjn		Implemented ReturnBuffer in API
 *	02/01/00	mjn		Implemented GetCaps and SetCaps in API
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *  03/17/00    rmt     Added new caps functions
 *	04/04/00	mjn		Added TerminateSession to API
 *	04/05/00	mjn		Modified DestroyClient
 *	04/06/00	mjn		Added GetPeerAddress to API
 *				mjn		Added GetHostAddress to API
 *  04/17/00    rmt     Added more parameter validation
 *              rmt     Removed required for connection from Get/SetInfo / GetAddress
 *	04/19/00	mjn		SendTo API call accepts a range of DPN_BUFFER_DESCs and a count
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/23/00	mjn		Removed dwPriority from SendTo() API call
 *	07/09/00	mjn		Cleaned up DN_SetPeerInfo()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *  07/21/00    RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2
 *	09/13/00	mjn		Fixed return value from DN_GetPeerAddress() if peer not found
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *				mjn		Check deleted list in DN_GetPeerInfo()
 *	01/22/01	mjn		Check closing instead of disconnecting in DN_GetPeerInfo()
 *	07/24/01	mjn		Added DPNBUILD_NOPARAMVAL compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

typedef	STDMETHODIMP PeerQueryInterface( IDirectPlay8Peer *pInterface, DP8REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	PeerAddRef( IDirectPlay8Peer *pInterface );
typedef	STDMETHODIMP_(ULONG)	PeerRelease( IDirectPlay8Peer *pInterface );
typedef	STDMETHODIMP PeerInitialize( IDirectPlay8Peer *pInterface, LPVOID const lpvUserContext, const PFNDPNMESSAGEHANDLER lpfn, const DWORD dwFlags );
typedef	STDMETHODIMP PeerEnumServiceProviders( IDirectPlay8Peer *pInterface,const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,DWORD *const pcbEnumData,DWORD *const pcReturned,const DWORD dwFlags);
typedef	STDMETHODIMP PeerCancelAsyncOperation( IDirectPlay8Peer *pInterface,const DPNHANDLE hAsyncHandle, const DWORD dwFlags );
typedef STDMETHODIMP PeerConnect( IDirectPlay8Peer *pInterface,const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
typedef	STDMETHODIMP PeerGetSendQueueInfo( IDirectPlay8Peer *pInterface, const DPNID dpnid,DWORD *const lpdwNumMsgs, DWORD *const lpdwNumBytes, const DWORD dwFlags );
typedef	STDMETHODIMP PeerSendTo( IDirectPlay8Peer *pInterface, const DPNID dnid, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef	STDMETHODIMP PeerGetApplicationDesc( IDirectPlay8Peer *pInterface,DPN_APPLICATION_DESC *const pAppDescBuffer,DWORD *const lpcbDataSize,const DWORD dwFlags );
typedef STDMETHODIMP PeerGetHostAddress( IDirectPlay8Peer *pInterface, IDirectPlay8Address **const prgpAddress, DWORD *const pcAddress,const DWORD dwFlags);
typedef	STDMETHODIMP PeerHost( IDirectPlay8Peer *pInterface,const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags);
typedef	STDMETHODIMP PeerSetApplicationDesc( IDirectPlay8Peer *pInterface, const DPN_APPLICATION_DESC *const lpad, const DWORD dwFlags );
typedef	STDMETHODIMP PeerCreateGroup( IDirectPlay8Peer *pInterface, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerDestroyGroup( IDirectPlay8Peer *pInterface, const DPNID idGroup ,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerAddClientToGroup( IDirectPlay8Peer *pInterface, const DPNID idGroup, const DPNID idClient ,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerRemoveClientFromGroup( IDirectPlay8Peer *pInterface, const DPNID idGroup, const DPNID idClient,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerSetGroupInfo(IDirectPlay8Peer *pInterface, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef STDMETHODIMP PeerGetGroupInfo(IDirectPlay8Peer *pInterface, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags);
typedef STDMETHODIMP PeerEnumClientsAndGroups( IDirectPlay8Peer *pInterface, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags );
typedef	STDMETHODIMP PeerEnumGroupMembers( IDirectPlay8Peer *pInterface, const DPNID dnid, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags );
typedef	STDMETHODIMP PeerClose( IDirectPlay8Peer *pInterface,const DWORD dwFlags);
typedef	STDMETHODIMP PeerEnumHosts( IDirectPlay8Peer *pInterface,PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwRetryCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerDestroyClient( IDirectPlay8Peer *pInterface,const DPNID dnid,const void *const pvDestroyData,const DWORD dwDestroyDataSize,const DWORD dwFlags);
typedef STDMETHODIMP PeerReturnBuffer( IDirectPlay8Peer *pInterface, const DPNHANDLE hBufferHandle,const DWORD dwFlags);
typedef STDMETHODIMP PeerGetCaps(IDirectPlay8Peer *pInterface,DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP PeerSetCaps(IDirectPlay8Peer *pInterface,const DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP PeerGetPlayerContext(IDirectPlay8Peer *pInterface,const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags);
typedef STDMETHODIMP PeerGetGroupContext(IDirectPlay8Peer *pInterface,const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags);
typedef STDMETHODIMP PeerSetSPCaps(IDirectPlay8Peer *pInterface,const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
typedef STDMETHODIMP PeerGetSPCaps(IDirectPlay8Peer *pInterface,const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags);
typedef STDMETHODIMP PeerGetConnectionInfo(IDirectPlay8Peer *pInterface,const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags);
typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
typedef STDMETHODIMP PeerTerminateSession(IDirectPlay8Peer *pInterface,void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags);

IDirectPlay8PeerVtbl DN_PeerVtbl =
{
	(PeerQueryInterface*)			DN_QueryInterface,
	(PeerAddRef*)					DN_AddRef,
	(PeerRelease*)					DN_Release,
	(PeerInitialize*)				DN_Initialize,
	(PeerEnumServiceProviders*)		DN_EnumServiceProviders,
	(PeerCancelAsyncOperation*)		DN_CancelAsyncOperation,
	(PeerConnect*)					DN_Connect,
	(PeerSendTo*)					DN_SendTo,
	(PeerGetSendQueueInfo*)			DN_GetSendQueueInfo,
	(PeerHost*)						DN_Host,
	(PeerGetApplicationDesc*)		DN_GetApplicationDesc,
	(PeerSetApplicationDesc*)		DN_SetApplicationDesc,
	(PeerCreateGroup*)				DN_CreateGroup,
	(PeerDestroyGroup*)				DN_DestroyGroup,
	(PeerAddClientToGroup*)			DN_AddClientToGroup,
	(PeerRemoveClientFromGroup*)	DN_RemoveClientFromGroup,
	(PeerSetGroupInfo*)				DN_SetGroupInfo,
	(PeerGetGroupInfo*)				DN_GetGroupInfo,
	(PeerEnumClientsAndGroups*)		DN_EnumClientsAndGroups,
	(PeerEnumGroupMembers*)			DN_EnumGroupMembers,
									DN_SetPeerInfo,
									DN_GetPeerInfo,
									DN_GetPeerAddress,
	(PeerGetHostAddress*)			DN_GetHostAddress,
	(PeerClose*)					DN_Close,
	(PeerEnumHosts*)				DN_EnumHosts,
	(PeerDestroyClient*)			DN_DestroyPlayer,
	(PeerReturnBuffer*)				DN_ReturnBuffer,
	(PeerGetPlayerContext*)			DN_GetPlayerContext,
	(PeerGetGroupContext*)			DN_GetGroupContext,
	(PeerGetCaps*)					DN_GetCaps,
	(PeerSetCaps*)					DN_SetCaps,
    (PeerSetSPCaps*)                DN_SetSPCaps,
    (PeerGetSPCaps*)                DN_GetSPCaps,
    (PeerGetConnectionInfo*)        DN_GetConnectionInfo,
	(PeerRegisterLobby*)			DN_RegisterLobby,
	(PeerTerminateSession*)			DN_TerminateSession
};

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//	DN_SetPeerInfo
//
//	Set the info for the local player (peer) and propagate to other players

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetPeerInfo"

STDMETHODIMP DN_SetPeerInfo( IDirectPlay8Peer *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	BOOL				fConnected;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);
    	
    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateSetPeerInfo( pInterface , pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating get peer info hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

	pLocalPlayer = NULL;

	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnPlayerInfo->pwszName))
	{
		pwszName = pdpnPlayerInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnPlayerInfo->pvData) && (pdpnPlayerInfo->dwDataSize))
	{
		pvData = pdpnPlayerInfo->pvData;
		dwDataSize = pdpnPlayerInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	//
	//	If we are connected, we will update our entry if we are the Host, or request the Host to update us.
	//	Otherwise, we will just update the DefaultPlayer.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fConnected = TRUE;
	}
	else
	{
		fConnected = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fConnected)
	{
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR( "Could not get local player reference" );
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		if (pLocalPlayer->IsHost())
		{
			DPFX(DPFPREP, 3,"Host is updating peer info");

			hResultCode = DNHostUpdateInfo(	pdnObject,
											pLocalPlayer->GetDPNID(),
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnPlayerInfo->dwInfoFlags,
											pvAsyncContext,
											pLocalPlayer->GetDPNID(),
											0,
											&hAsyncOp,
											dwFlags );
			if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
			{
				DPFERR("Could not request host to update group");
			}
			else
			{
				if (!(dwFlags & DPNSETPEERINFO_SYNC))
				{
					DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
					*phAsyncHandle = hAsyncOp;

					//
					//	Release Async HANDLE since this operation has already completed (!)
					//
					CAsyncOp* pAsyncOp;
					if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOp, (PVOID*)&pAsyncOp )))
					{
						// Release the HandleTable reference
						pAsyncOp->Release();
					}
					hAsyncOp = 0;
				}
			}
		}
		else
		{
			DPFX(DPFPREP, 3,"Request host to update group info");

			hResultCode = DNRequestUpdateInfo(	pdnObject,
												pLocalPlayer->GetDPNID(),
												pwszName,
												dwNameSize,
												pvData,
												dwDataSize,
												pdpnPlayerInfo->dwInfoFlags,
												pvAsyncContext,
												&hAsyncOp,
												dwFlags);
			if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not request host to update group info");
			}
			else
			{
				if (!(dwFlags & DPNSETPEERINFO_SYNC))
				{
					DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
					*phAsyncHandle = hAsyncOp;
				}
			}
		}

		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

		// This function takes the lock internally
		pdnObject->NameTable.GetDefaultPlayer()->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,pdpnPlayerInfo->dwInfoFlags, FALSE);

		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DN_GetPeerInfo
//
//	Retrieve peer info from the local nametable.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetPeerInfo"

STDMETHODIMP DN_GetPeerInfo(IDirectPlay8Peer *pInterface,
							const DPNID dpnid,
							DPN_PLAYER_INFO *const pdpnPlayerInfo,
							DWORD *const pdwSize,
							const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	HRESULT				hResultCode;
	CPackedBuffer		packedBuffer;

	DPFX(DPFPREP, 2,"Parameters: dpnid [0x%lx], pdpnPlayerInfo [0x%p], dwFlags [0x%lx]",
			dpnid,pdpnPlayerInfo,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateGetPeerInfo( pInterface , dpnid, pdpnPlayerInfo, pdwSize, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating get peer info hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING) && !(pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_CONNECTED) )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !(pdnObject->dwFlags & (	DN_OBJECT_FLAG_CONNECTING
									| DN_OBJECT_FLAG_CONNECTED 
									| DN_OBJECT_FLAG_CLOSING 
									| DN_OBJECT_FLAG_DISCONNECTING) ) )
    {
    	DPFERR("You must be connected / disconnecting to use this function" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	    	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve name table entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}
	packedBuffer.Initialize(pdpnPlayerInfo,*pdwSize);

	pNTEntry->Lock();
	if (pNTEntry->IsGroup())
	{
	    DPFERR( "Specified ID is invalid" );
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = pNTEntry->PackInfo(&packedBuffer);

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetPeerAddress"

STDMETHODIMP DN_GetPeerAddress(IDirectPlay8Peer *pInterface,
							   const DPNID dpnid,
							   IDirectPlay8Address **const ppAddress,
							   const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	IDirectPlay8Address	*pAddress;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters : pInterface [0x%p], dpnid [0x%lx], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,dpnid,ppAddress,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateGetPeerAddress( pInterface , dpnid, ppAddress, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating get peer address info hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING) && !(pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_CONNECTED) )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !(pdnObject->dwFlags & (	DN_OBJECT_FLAG_CONNECTING
									| DN_OBJECT_FLAG_CONNECTED 
									| DN_OBJECT_FLAG_CLOSING 
									| DN_OBJECT_FLAG_DISCONNECTING) ) )
    {
    	DPFERR("You must be connected / disconnecting to use this function" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	    	

	pNTEntry = NULL;
	pAddress = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	if ((pNTEntry->GetAddress() == NULL) || (pNTEntry->IsGroup()) || !pNTEntry->IsAvailable())
	{
	    DPFERR( "Invalid ID specified.  Not a player" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = IDirectPlay8Address_Duplicate(pNTEntry->GetAddress(),ppAddress);

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\protocol.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Protocol.h
 *  Content:    Direct Net Protocol interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/01/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__PROTOCOL_H__
#define	__PROTOCOL_H__

#ifndef DPNBUILD_NOPROTOCOLTESTITF

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for peer interface
//
extern IDirectPlay8ProtocolVtbl DN_ProtocolVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

#endif // !DPNBUILD_NOPROTOCOLTESTITF

#endif	// __PROTOCOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\pools.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.h
 *  Content:    DirectNet Fixed Pools
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/15/00	mjn		Created
 *	01/19/00	mjn		Added SyncEventNew()
 *	02/29/00	mjn		Added ConnectionNew()
 *	03/02/00	mjn		Added GroupConnectionNew()
 *	04/08/00	mjn		Added AsyncOpNew()
 *	07/30/00	mjn		Added PendingDeletionNew()
 *	07/31/00	mjn		Added QueuedMsgNew()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/23/00	mjn		Added CNameTableOp
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__POOLS_H__
#define	__POOLS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CRefCountBuffer;
class CSyncEvent;
class CConnection;
class CGroupConnection;
class CGroupMember;
class CNameTableEntry;
class CAsyncOp;
class CPendingDeletion;
class CQueuedMsg;
class CWorkerJob;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

// DirectNet - Fixed Pools
HRESULT RefCountBufferNew(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwBufferSize,
						  PFNALLOC_REFCOUNT_BUFFER pfnAlloc,
						  PFNFREE_REFCOUNT_BUFFER pfnFree,
						  CRefCountBuffer **const ppNewRefCountBuffer);

HRESULT SyncEventNew(DIRECTNETOBJECT *const pdnObject,
					 CSyncEvent **const ppNewSyncEvent);

HRESULT ConnectionNew(DIRECTNETOBJECT *const pdnObject,
					  CConnection **const ppNewConnection);

HRESULT GroupConnectionNew(DIRECTNETOBJECT *const pdnObject,
						   CGroupConnection **const ppNewGroupConnection);

HRESULT GroupMemberNew(DIRECTNETOBJECT *const pdnObject,
					   CGroupMember **const ppNewGroupMember);

HRESULT NameTableEntryNew(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry **const ppNewNameTableEntry);

HRESULT AsyncOpNew(DIRECTNETOBJECT *const pdnObject,
				   CAsyncOp **const ppNewAsyncOp);

HRESULT PendingDeletionNew(DIRECTNETOBJECT *const pdnObject,
						   CPendingDeletion **const ppNewPendingDeletion);

HRESULT QueuedMsgNew(DIRECTNETOBJECT *const pdnObject,
					 CQueuedMsg **const ppNewQueuedMsg);

HRESULT WorkerJobNew(DIRECTNETOBJECT *const pdnObject,
					 CWorkerJob **const ppNewWorkerJob);

HRESULT NameTableOpNew(DIRECTNETOBJECT *const pdnObject,
					   CNameTableOp **const ppNewNameTableOp);


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL

PVOID EnumReplyMemoryBlockAlloc(void *const pvContext,
										const DWORD dwSize);

void EnumReplyMemoryBlockFree(void *const pvContext,
									void *const pvMemoryBlock);

HRESULT DN_PopulateCorePools( DIRECTNETOBJECT *const pdnObject,
							const XDP8CREATE_PARAMS * const pDP8CreateParams );

#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

#define EnumReplyMemoryBlockAlloc	MemoryBlockAlloc
#define EnumReplyMemoryBlockFree	MemoryBlockFree

#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL


#endif	// __POOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\protocol.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Protocol.cpp
 *  Content:    DNET protocol interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/01/00	ejs		Created
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#ifndef DPNBUILD_NOPROTOCOLTESTITF

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	STDMETHODIMP ProtocolQueryInterface( IDirectPlay8Protocol* pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	ProtocolAddRef( IDirectPlay8Protocol* pInterface );
typedef	STDMETHODIMP_(ULONG)	ProtocolRelease( IDirectPlay8Protocol* pInterface );

//**********************************************************************
// Function definitions
//**********************************************************************


//	DN_ProtocolInitialize
//
//	Initialize protocol

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolInitialize"
STDMETHODIMP DN_ProtocolInitialize(IDirectPlay8Protocol* pInterface, PVOID pvContext, PDN_PROTOCOL_INTERFACE_VTBL pfVTbl)
{
	HRESULT						hr;
	DIRECTNETOBJECT				*pdnObject;
	IDirectPlay8ThreadPoolWork	*pDPThreadPoolWork;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

#ifdef DPNBUILD_LIBINTERFACE
#if ((defined(DPNBUILD_ONLYONETHREAD)) && (! defined(DPNBUILD_MULTIPLETHREADPOOLS)))
	DPTPCF_GetObject(reinterpret_cast<void**>(&pDPThreadPoolWork));
	hr = S_OK;
#else // ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
	hr = DPTPCF_CreateObject(reinterpret_cast<void**>(&pDPThreadPoolWork));
#endif // ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
#else // ! DPNBUILD_LIBINTERFACE
	hr = COM_CoCreateInstance(CLSID_DirectPlay8ThreadPool,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_IDirectPlay8ThreadPoolWork,
								reinterpret_cast<void**>(&pDPThreadPoolWork),
								FALSE);
#endif // ! DPNBUILD_LIBINTERFACE
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Couldn't CoCreate a ThreadPool object for the Protocol to use.");
		return  hr;
	}

#ifndef DPNBUILD_ONLYONETHREAD
	hr = IDirectPlay8ThreadPoolWork_RequestTotalThreadCount(pDPThreadPoolWork, 4, 0);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Couldn't request thread count from ThreadPool");
		goto Exit;
	}
#endif // ! DPNBUILD_ONLYONETHREAD
	
	hr = DNPProtocolInitialize( pdnObject->pdnProtocolData, pvContext, pfVTbl, pDPThreadPoolWork, FALSE );

#ifndef DPNBUILD_ONLYONETHREAD
Exit:
#endif // ! DPNBUILD_ONLYONETHREAD
	IDirectPlay8ThreadPoolWork_Release(pDPThreadPoolWork);
	pDPThreadPoolWork = NULL;

	return  hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolShutdown"
STDMETHODIMP DN_ProtocolShutdown(IDirectPlay8Protocol* pInterface)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPProtocolShutdown(pdnObject->pdnProtocolData);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolAddSP"
STDMETHODIMP DN_ProtocolAddSP(IDirectPlay8Protocol* pInterface, IDP8ServiceProvider* pISP, HANDLE* phSPHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

		//Flags parameter for DNPAddServiceProvider is passed through as the
		//flags parameter in the SPINITIALIZEDATA structure to the SP
		//We pass the session type via it
	DWORD dwFlags;
	if (pdnObject->dwFlags &  DN_OBJECT_FLAG_PEER)
		dwFlags=SP_SESSION_TYPE_PEER;
	else if (pdnObject->dwFlags &  DN_OBJECT_FLAG_CLIENT)
		dwFlags=SP_SESSION_TYPE_CLIENT;
	else
	{
		DNASSERT(pdnObject->dwFlags &  DN_OBJECT_FLAG_SERVER);
		dwFlags=SP_SESSION_TYPE_SERVER;
	}
	return DNPAddServiceProvider(pdnObject->pdnProtocolData, pISP, phSPHandle, dwFlags);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolRemoveSP"
STDMETHODIMP DN_ProtocolRemoveSP(IDirectPlay8Protocol* pInterface, HANDLE hSPHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPRemoveServiceProvider(pdnObject->pdnProtocolData, hSPHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolConnect"
STDMETHODIMP DN_ProtocolConnect(IDirectPlay8Protocol* pInterface, IDirectPlay8Address* paLocalAddress, IDirectPlay8Address* paRemoteAddress, HANDLE hSPHandle, ULONG ulFlags, VOID* pvContext, HANDLE* phConnect)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPConnect(pdnObject->pdnProtocolData, paLocalAddress, paRemoteAddress, hSPHandle, ulFlags, pvContext, NULL, 0, phConnect);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolListen"
STDMETHODIMP DN_ProtocolListen(IDirectPlay8Protocol* pInterface, IDirectPlay8Address* paAddress, HANDLE hSPHandle, ULONG ulFlags, VOID* pvContext, HANDLE* phListen)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPListen(pdnObject->pdnProtocolData, paAddress, hSPHandle, ulFlags, pvContext, NULL, 0, phListen);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolSendData"
STDMETHODIMP DN_ProtocolSendData(IDirectPlay8Protocol* pInterface, HANDLE hEndpoint, UINT uiBufferCount, BUFFERDESC* pBuffers, UINT uiTimeout, ULONG ulFlags, VOID* pvContext, HANDLE* phSendHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPSendData(pdnObject->pdnProtocolData, hEndpoint, uiBufferCount, pBuffers, uiTimeout, ulFlags, pvContext, phSendHandle);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolDisconnectEP"
STDMETHODIMP DN_ProtocolDisconnectEP(IDirectPlay8Protocol* pInterface, HANDLE hEndPoint, VOID* pvContext, HANDLE* phDisconnect, DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPDisconnectEndPoint(pdnObject->pdnProtocolData, hEndPoint, pvContext, phDisconnect, dwFlags);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolCancel"
STDMETHODIMP DN_ProtocolCancel(IDirectPlay8Protocol* pInterface, HANDLE hCommand)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPCancelCommand(pdnObject->pdnProtocolData, hCommand);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolReleaseReceiveBuffer"
STDMETHODIMP DN_ProtocolReleaseReceiveBuffer(IDirectPlay8Protocol* pInterface, HANDLE hBuffer)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPReleaseReceiveBuffer(pdnObject->pdnProtocolData, hBuffer);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetEPCaps"
STDMETHODIMP DN_ProtocolGetEPCaps(IDirectPlay8Protocol* pInterface, HANDLE hEndpoint, VOID* pvBuffer)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPGetEPCaps(pdnObject->pdnProtocolData, hEndpoint, (DPN_CONNECTION_INFO*) pvBuffer);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolDebug"
STDMETHODIMP DN_ProtocolDebug(IDirectPlay8Protocol* pInterface, UINT uiOpcode, HANDLE hEndpoint, VOID* pvBuffer)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPDebug(pdnObject->pdnProtocolData, uiOpcode, hEndpoint, pvBuffer);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetCaps"
STDMETHODIMP DN_ProtocolGetCaps(IDirectPlay8Protocol* pInterface, DPN_CAPS* pCaps)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPGetProtocolCaps(pdnObject->pdnProtocolData, pCaps);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetCaps"
STDMETHODIMP DN_ProtocolSetCaps(IDirectPlay8Protocol* pInterface, DPN_CAPS* pCaps)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPSetProtocolCaps(pdnObject->pdnProtocolData, pCaps);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolEnumQuery"
STDMETHODIMP DN_ProtocolEnumQuery(IDirectPlay8Protocol* pInterface, IDirectPlay8Address* paHostAddress, IDirectPlay8Address* paDeviceAddress, HANDLE hSPHandle, BUFFERDESC* pBuffers, DWORD dwBufferCount, DWORD dwRetryCount, DWORD dwRetryInterval, DWORD dwTimeout, DWORD dwFlags, VOID* pvUserContext, HANDLE* phEnumHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPEnumQuery( pdnObject->pdnProtocolData, paHostAddress, paDeviceAddress, hSPHandle, pBuffers, dwBufferCount, dwRetryCount, dwRetryInterval, dwTimeout, dwFlags, pvUserContext, NULL, 0, phEnumHandle );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolEnumRespond"
STDMETHODIMP DN_ProtocolEnumRespond(IDirectPlay8Protocol* pInterface, HANDLE hSPHandle, HANDLE hQueryHandle, BUFFERDESC* pBuffers, DWORD dwBufferCount, DWORD dwFlags, VOID* pvUserContext, HANDLE* phEnumHandle)
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	return DNPEnumRespond( pdnObject->pdnProtocolData, hSPHandle, hQueryHandle, pBuffers, dwBufferCount, dwFlags, pvUserContext, phEnumHandle );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolCrackEPD"
STDMETHODIMP DN_ProtocolCrackEPD(IDirectPlay8Protocol* pInterface, HANDLE hEndPoint, long Flags, IDirectPlay8Address** ppAddr )
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	SPGETADDRESSINFODATA SPData;
	SPData.Flags = (SP_GET_ADDRESS_INFO_FLAGS)Flags;

	HRESULT hr = DNPCrackEndPointDescriptor( pdnObject->pdnProtocolData, hEndPoint, &SPData );
	*ppAddr = SPData.pAddress;
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProtocolGetListenAddressInfo"
STDMETHODIMP DN_ProtocolGetListenAddressInfo(IDirectPlay8Protocol* pInterface, HANDLE hCommand, long Flags, IDirectPlay8Address** ppAddr )
{
	DIRECTNETOBJECT		*pdnObject;

	DNASSERT(pInterface != NULL);
	pdnObject = (DIRECTNETOBJECT *)GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pdnObject != NULL);

	SPGETADDRESSINFODATA SPData;
	SPData.Flags = (SP_GET_ADDRESS_INFO_FLAGS)Flags;

	HRESULT hr = DNPGetListenAddressInfo( pdnObject->pdnProtocolData, hCommand, &SPData );
	*ppAddr = SPData.pAddress;
	return hr;
}

IDirectPlay8ProtocolVtbl DN_ProtocolVtbl =
{
	(ProtocolQueryInterface*)	DN_QueryInterface,
	(ProtocolAddRef*)			DN_AddRef,
	(ProtocolRelease*)			DN_Release,
								DN_ProtocolInitialize,
								DN_ProtocolShutdown,
								DN_ProtocolAddSP,
								DN_ProtocolRemoveSP,
								DN_ProtocolConnect,
								DN_ProtocolListen,
								DN_ProtocolSendData,
								DN_ProtocolDisconnectEP,
								DN_ProtocolCancel,
								DN_ProtocolReleaseReceiveBuffer,
								DN_ProtocolGetEPCaps,
								DN_ProtocolGetCaps,
								DN_ProtocolSetCaps,
								DN_ProtocolEnumQuery,
								DN_ProtocolEnumRespond,
								DN_ProtocolCrackEPD,
								DN_ProtocolGetListenAddressInfo,
								DN_ProtocolDebug,
};

#endif // !DPNBUILD_NOPROTOCOLTESTITF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\queuedmsg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       QueuedMsg.cpp
 *  Content:    Queued Message Objects
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/31/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CQueuedMsg::SetAsyncOp"

void CQueuedMsg::SetAsyncOp(CAsyncOp *const pAsyncOp)
{
	if (pAsyncOp)
	{
		pAsyncOp->AddRef();
	}
	m_pAsyncOp = pAsyncOp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dnet.rc
//
#ifndef DPNBUILD_NOIPX
#define IDS_FRIENDLYNAME_IPX            1
#endif // DPNBUILD_NOIPX
#define IDS_FRIENDLYNAME_TCPIP          2
#define IDD_IP_SETTINGS                 101
#define IDC_EDIT_IP_HOSTNAME            1000
#define IDC_SIP				1001

#ifndef DPNBUILD_NOSERIALSP
#define IDS_BAUD_9600                   9
#define IDS_BAUD_14400                  10
#define IDS_BAUD_19200                  11
#define IDS_BAUD_38400                  12
#define IDS_BAUD_56000                  13
#define IDS_BAUD_57600                  14
#define IDS_BAUD_115200                 15

#define IDS_STOPBITS_ONE                16
#define IDS_STOPBITS_ONE5               17
#define IDS_STOPBITS_TWO                18

#define IDS_PARITY_EVEN                 19
#define IDS_PARITY_MARK                 20
#define IDS_PARITY_NONE                 21
#define IDS_PARITY_ODD                  22
#define IDS_PARITY_SPACE                23

#define IDS_FLOW_NONE                   24
#define IDS_FLOW_XONXOFF                25
#define IDS_FLOW_RTS                    26
#define IDS_FLOW_DTR                    27
#define IDS_FLOW_RTSDTR                 28

#define IDS_FRIENDLYNAME_MODEM          29
#define IDS_FRIENDLYNAME_SERIAL         30
#define IDD_SERIAL_SETTINGS             201
#define IDD_OUTGOING_MODEM_SETTINGS     202
#define IDD_INCOMING_MODEM_SETTINGS     203
#define IDD_MODEM_STATUS                204
#define IDC_COMBO_SERIAL_DEVICE         2001
#define IDC_COMBO_SERIAL_BAUDRATE       2002
#define IDC_COMBO_SERIAL_STOPBITS       2003
#define IDC_COMBO_SERIAL_PARITY         2004
#define IDC_EDIT_MODEM_PHONE_NUMBER     2005
#define IDC_COMBO_SERIAL_FLOWCONTROL    2006
#define IDC_COMBO_OUTGOING_MODEM_DEVICE 2007
#define IDC_BUTTON_MODEM_CONFIGURE      2008
#define IDC_COMBO_INCOMING_MODEM_DEVICE 2009

#endif // !DPNBUILD_NOSERIALSP

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        300
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         3000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\request.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Request.cpp
 *  Content:    Requested operations
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/18/00	mjn		Created
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/16/00	mjn		Better locking during User notifications
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/26/00	mjn		Replaced DPNADDCLIENTTOGROUP_SYNC DPNADDPLAYERTOGROUP_SYNC
 *				mjn		Replaced DPNREMOVECLIENTFROMGROUP_SYNC with DPNREMOVEPLAYERFROMGROUP_SYNC
 *	07/26/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added DNProcessFailedRequest()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/07/00	mjn		Added DNRequestIntegrityCheck(),DNHostCheckIntegrity(),DNProcessCheckIntegrity(),DNHostFixIntegrity()
 *	08/08/00	mjn		Mark groups created after CREATE_GROUP
 *	08/09/00	mjn		Made requests and host operations more robust for host migration
 *	08/15/00	mjn		Keep request operations if HostPlayer or connection is unavailable
 *	09/05/00	mjn		Removed dwIndex from CNameTable::InsertEntry()
 *	09/13/00	mjn		Perform queued operations after creating group in DNConnectToHost2()
 *	09/26/00	mjn		Removed locking from CNameTable::SetVersion() and CNameTable::GetNewVersion()
 *	10/10/00	mjn		Return DPN_OK from Host operations if unable to get reference on local player
 *	10/13/00	mjn		Update version if FindPlayer fails in DNProcessXXX() functions
 *	01/09/01	mjn		Prevent asynchronous group/info operations from being cancelled
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	04/13/01	mjn		Remove requests from request list when operations received from host
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestWorker"

HRESULT DNRequestWorker(DIRECTNETOBJECT *const pdnObject,
							 DWORD dwMsgId,
							 CRefCountBuffer* pRefCountBuffer,
							 void *const pvRequestContext,
							 void *const pvUserContext,
							 DPNHANDLE *const phAsyncOp,
							 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pRequest;
	CAsyncOp			*pHandleParent;
	CSyncEvent			*pSyncEvent;
	CNameTableEntry		*pHostPlayer;
	CConnection			*pConnection;
	HRESULT	volatile	hrOperation;

	pRequest = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Create synchronization event if necessary
	//
	DBG_CASSERT(DPNOP_SYNC == DPNCREATEGROUP_SYNC);
	DBG_CASSERT(DPNOP_SYNC == DPNDESTROYGROUP_SYNC);
	DBG_CASSERT(DPNOP_SYNC == DPNADDPLAYERTOGROUP_SYNC);
	DBG_CASSERT(DPNOP_SYNC == DPNREMOVEPLAYERFROMGROUP_SYNC);
	DBG_CASSERT(DPNOP_SYNC == DPNSETGROUPINFO_SYNC);
	DBG_CASSERT(DPNOP_SYNC == DPNSETCLIENTINFO_SYNC);
	DBG_CASSERT(DPNOP_SYNC == DPNSETSERVERINFO_SYNC);
	DBG_CASSERT(DPNOP_SYNC == DPNSETPEERINFO_SYNC);
	if (dwFlags & DPNOP_SYNC)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) !=  DPN_OK)
		{
			DPFERR("Could not create synchronization event");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create user HANDLE");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	//
	//	Get host connection for request operation.
	//	We will procede even if we can't get it, just so that the operation will be re-tried at host migration
	//	or cancelled at close
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get host connection reference");
			DisplayDNError(0,hResultCode);
		}
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Send request
	//
	hResultCode = DNPerformRequest(	pdnObject,
									dwMsgId,
									pRefCountBuffer->BufferDescAddress(),
									pConnection,
									pHandleParent,
									&pRequest );

	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	//
	//	Wait for SyncEvent or create async user HANDLE
	//
	pRequest->SetContext( pvRequestContext );
	if (dwFlags & DPNOP_SYNC)
	{
		pRequest->SetSyncEvent( pSyncEvent );
		pRequest->SetResultPointer( &hrOperation );
		pRequest->Release();
		pRequest = NULL;

		pSyncEvent->WaitForEvent();
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;

		hResultCode = hrOperation;
	}
	else
	{
		pRequest->Release();
		pRequest = NULL;

		if (phAsyncOp)
		{
			*phAsyncOp = pHandleParent->GetHandle();
		}
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->SetContext( pvUserContext );
		pHandleParent->SetCannotCancel();
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;
	}

Exit:
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestCreateGroup"

HRESULT DNRequestCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 const PWSTR pwszName,
							 const DWORD dwNameSize,
							 const PVOID pvData,
							 const DWORD dwDataSize,
							 const DWORD dwGroupFlags,
							 void *const pvGroupContext,
							 void *const pvUserContext,
							 DPNHANDLE *const phAsyncOp,
							 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pwszName [%ls], pvData [0x%p], dwDataSize [%ld], dwGroupFlags [0x%lx], pvUserContext [0x%p], dwFlags [0x%lx]",
		pwszName,pvData,dwDataSize,dwGroupFlags,pvUserContext,dwFlags);

	DNASSERT(pdnObject != NULL);

	pRefCountBuffer = NULL;

	//
	//	Create REQUEST
	//

	// Create buffer
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP) + dwNameSize + dwDataSize,
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create new RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pMsg = static_cast<DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP*>(packedBuffer.GetHeadAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP))) != DPN_OK)
	{
		DPFERR("Could not reserve space at front of buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Flags
	pMsg->dwGroupFlags = dwGroupFlags;
	pMsg->dwInfoFlags = 0;

	// Add Name
	if (dwNameSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pwszName,dwNameSize)) != DPN_OK)
		{
			DPFERR("Could not add Name to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwNameOffset = packedBuffer.GetTailOffset();
		pMsg->dwNameSize = dwNameSize;
		pMsg->dwInfoFlags |= DPNINFO_NAME;
	}
	else
	{
		pMsg->dwNameOffset = 0;
		pMsg->dwNameSize = 0;
	}

	// Add Data
	if (dwDataSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pvData,dwDataSize)) != DPN_OK)
		{
			DPFERR("Could not add Data to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwDataOffset = packedBuffer.GetTailOffset();
		pMsg->dwDataSize = dwDataSize;
		pMsg->dwInfoFlags |= DPNINFO_DATA;
	}
	else
	{
		pMsg->dwDataOffset = 0;
		pMsg->dwDataSize = 0;
	}

	// Test against FAILED so DPNSUCCESS_PENDING doesn't show up as a failure
	if (FAILED(hResultCode = DNRequestWorker(pdnObject, DN_MSG_INTERNAL_REQ_CREATE_GROUP, pRefCountBuffer, pvGroupContext, pvUserContext, phAsyncOp, dwFlags)))
	{
		DPFERR("Could not perform request");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

Exit:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestDestroyGroup"

HRESULT DNRequestDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnidGroup,
							  PVOID const pvUserContext,
							  DPNHANDLE *const phAsyncOp,
							  const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], pvUserContext [0x%p], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,pvUserContext,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);

	pRefCountBuffer = NULL;

	//
	//	Create REQUEST
	//
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not allocate count buffer (request destroy group)");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidGroup = dpnidGroup;

	// Test against FAILED so DPNSUCCESS_PENDING doesn't show up as a failure
	if (FAILED(hResultCode = DNRequestWorker(pdnObject, DN_MSG_INTERNAL_REQ_DESTROY_GROUP, pRefCountBuffer, NULL, pvUserContext, phAsyncOp, dwFlags)))
	{
		DPFERR("Could not perform request");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

Exit:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestAddPlayerToGroup"

HRESULT DNRequestAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  const DPNID dpnidGroup,
								  const DPNID dpnidPlayer,
								  PVOID const pvUserContext,
								  DPNHANDLE *const phAsyncOp,
								  const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);

	pRefCountBuffer = NULL;

	//
	//	Create REQUEST
	//
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not allocate count buffer (request destroy group)");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidGroup = dpnidGroup;
	pMsg->dpnidPlayer = dpnidPlayer;

	// Test against FAILED so DPNSUCCESS_PENDING doesn't show up as a failure
	if (FAILED(hResultCode = DNRequestWorker(pdnObject, DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP, pRefCountBuffer, NULL, pvUserContext, phAsyncOp, dwFlags)))
	{
		DPFERR("Could not perform request");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

Exit:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestDeletePlayerFromGroup"

HRESULT DNRequestDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   const DPNID dpnidGroup,
									   const DPNID dpnidPlayer,
									   PVOID const pvUserContext,
									   DPNHANDLE *const phAsyncOp,
									   const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);

	pRefCountBuffer = NULL;

	//
	//	Create REQUEST
	//
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not allocate count buffer (request destroy group)");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidGroup = dpnidGroup;
	pMsg->dpnidPlayer = dpnidPlayer;

	// Test against FAILED so DPNSUCCESS_PENDING doesn't show up as a failure
	if (FAILED(hResultCode = DNRequestWorker(pdnObject, DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP, pRefCountBuffer, NULL, pvUserContext, phAsyncOp, dwFlags)))
	{
		DPFERR("Could not perform request");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

Exit:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestUpdateInfo"

HRESULT DNRequestUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							const DPNID dpnid,
							const PWSTR pwszName,
							const DWORD dwNameSize,
							const PVOID pvData,
							const DWORD dwDataSize,
							const DWORD dwInfoFlags,
							PVOID const pvUserContext,
							DPNHANDLE *const phAsyncOp,
							const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pwszName [0x%p], pvData [0x%p], dwInfoFlags [%ld], dwGroupFlags [0x%lx], pvUserContext [0x%p], dwFlags [0x%lx]",
		pwszName,pvData,dwDataSize,dwInfoFlags,pvUserContext,dwFlags);

	DNASSERT(pdnObject != NULL);

	pRefCountBuffer = NULL;

	//
	//	Create REQUEST
	//
	// Create buffer
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO) + dwNameSize + dwDataSize,
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create new RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pMsg = static_cast<DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO*>(packedBuffer.GetHeadAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO))) != DPN_OK)
	{
		DPFERR("Could not reserve space at front of buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Add Name
	if ((dwInfoFlags & DPNINFO_NAME) && dwNameSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pwszName,dwNameSize)) != DPN_OK)
		{
			DPFERR("Could not add Name to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwNameOffset = packedBuffer.GetTailOffset();
		pMsg->dwNameSize = dwNameSize;
	}
	else
	{
		pMsg->dwNameOffset = 0;
		pMsg->dwNameSize = 0;
	}

	// Add Data
	if ((dwInfoFlags & DPNINFO_DATA) && dwDataSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pvData,dwDataSize)) != DPN_OK)
		{
			DPFERR("Could not add Data to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwDataOffset = packedBuffer.GetTailOffset();
		pMsg->dwDataSize = dwDataSize;
	}
	else
	{
		pMsg->dwDataOffset = 0;
		pMsg->dwDataSize = 0;
	}

	// Remaining fields
	pMsg->dpnid = dpnid;
	pMsg->dwInfoFlags = dwInfoFlags;

	// Test against FAILED so DPNSUCCESS_PENDING doesn't show up as a failure
	if (FAILED(hResultCode = DNRequestWorker(pdnObject, DN_MSG_INTERNAL_REQ_UPDATE_INFO, pRefCountBuffer, NULL, pvUserContext, phAsyncOp, dwFlags)))
	{
		DPFERR("Could not perform request");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

Exit:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


//	DNRequestIntegrityCheck
//
//	In the case where a non-host player detects a disconnect from another non-host player,
//	the detecting player will request the host to perform an integrity check to prevent a
//	disjoint game from occurring.  The host will ping the disconnected player, and if a
//	response is received, the host will disconnect the detecting player.  If no response
//	is received, presumably the disconnected player is in fact dropping, and a DESTROY_PLAYER
//	message will be sent out.

#undef DPF_MODNAME
#define DPF_MODNAME "DNRequestIntegrityCheck"

HRESULT DNRequestIntegrityCheck(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidTarget)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableEntry	*pHostPlayer;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	CAsyncOp		*pRequest;
	DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: dpnidTarget [0x%lx]",dpnidTarget);

	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pNTEntry = NULL;
	pConnection = NULL;
	pRequest = NULL;

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Closing - aborting");
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Determine if player is still in NameTable - maybe the Host has already deleted him
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidTarget,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Target player not in NameTable");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Lock();
	if (!pNTEntry->IsAvailable())
	{
		pNTEntry->Unlock();
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Create request message
	//
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidTarget = dpnidTarget;

	//
	//	Get host connection for request operation
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not get host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get host connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	//
	//	Send request
	//
	if ((hResultCode = DNPerformRequest(pdnObject,
										DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK,
										pRefCountBuffer->BufferDescAddress(),
										pConnection,
										NULL,
										&pRequest)) != DPNERR_PENDING)
	{
		DPFERR("Could not perform request (INTEGRITY_CHECK)");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pRequest->Release();
	pRequest = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	goto Exit;
}


//	HOST OPERATIONS
//
//	The Host will perform an operation and if in PEER mode, will inform
//	other players of the operation.   These messages will contain the
//	DPNID of the player requesting the operation along with the HANDLE
//	supplied with the request.


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostProcessRequest"

HRESULT DNHostProcessRequest(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 PVOID const pv,
							 const DPNID dpnidRequesting)
{
	HRESULT	hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION			*pRequest;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pv [0x%p], dpnidRequesting [0x%lx]",
			dwMsgId,pv,dpnidRequesting);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);
	DNASSERT(dpnidRequesting != 0);

	pRequest = static_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pv);

	switch(dwMsgId)
	{
	case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP	*pCreateGroup;
			PWSTR	pwszName;
			PVOID	pvData;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_CREATE_GROUP");

			pCreateGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP*>(pRequest + 1);
			if (pCreateGroup->dwNameSize)
			{
				pwszName = reinterpret_cast<WCHAR*>(reinterpret_cast<BYTE*>(pCreateGroup) + pCreateGroup->dwNameOffset);
			}
			else
			{
				pwszName = NULL;
			}
			if (pCreateGroup->dwDataSize)
			{
				pvData = static_cast<void*>(reinterpret_cast<BYTE*>(pCreateGroup) + pCreateGroup->dwDataOffset);
			}
			else
			{
				pvData = NULL;
			}
			DNHostCreateGroup(	pdnObject,
								pwszName,
								pCreateGroup->dwNameSize,
								pvData,
								pCreateGroup->dwDataSize,
								pCreateGroup->dwInfoFlags,
								pCreateGroup->dwGroupFlags,
								NULL,
								NULL,
								dpnidRequesting,
								pRequest->hCompletionOp,
								NULL,
								0 );

			break;
		}

	case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP	*pDestroyGroup;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_DESTROY_GROUP");

			pDestroyGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP*>(pRequest + 1);

			DNHostDestroyGroup(	pdnObject,
								pDestroyGroup->dpnidGroup,
								NULL,
								dpnidRequesting,
								pRequest->hCompletionOp,
								NULL,
								0 );
								
			break;
		}

	case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP	*pAddPlayerToGroup;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP");

			pAddPlayerToGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP*>(pRequest + 1);

			DNHostAddPlayerToGroup(	pdnObject,
									pAddPlayerToGroup->dpnidGroup,
									pAddPlayerToGroup->dpnidPlayer,
									NULL,
									dpnidRequesting,
									pRequest->hCompletionOp,
									NULL,
									0 );

			break;
		}

	case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP	*pDeletePlayerFromGroup;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP");

			pDeletePlayerFromGroup = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP*>(pRequest + 1);

			DNHostDeletePlayerFromGroup(pdnObject,
										pDeletePlayerFromGroup->dpnidGroup,
										pDeletePlayerFromGroup->dpnidPlayer,
										NULL,
										dpnidRequesting,
										pRequest->hCompletionOp,
										NULL,
										0);

			break;
		}

	case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO	*pUpdateInfo;
			PWSTR	pwszName;
			PVOID	pvData;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_UPDATE_INFO");

			pUpdateInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO*>(pRequest + 1);
			if (pUpdateInfo->dwNameSize)
			{
				pwszName = reinterpret_cast<WCHAR*>(reinterpret_cast<BYTE*>(pUpdateInfo) + pUpdateInfo->dwNameOffset);
			}
			else
			{
				pwszName = NULL;
			}
			if (pUpdateInfo->dwDataSize)
			{
				pvData = reinterpret_cast<void*>(reinterpret_cast<BYTE*>(pUpdateInfo) + pUpdateInfo->dwDataOffset);
			}
			else
			{
				pvData = NULL;
			}
			DNHostUpdateInfo(pdnObject,
							pUpdateInfo->dpnid,
							pwszName,
							pUpdateInfo->dwNameSize,
							pvData,
							pUpdateInfo->dwDataSize,
							pUpdateInfo->dwInfoFlags,
							NULL,
							dpnidRequesting,
							pRequest->hCompletionOp,
							NULL,
							0);

			break;
		}

	case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
		{
			UNALIGNED DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK	*pIntegrityCheck;
			CNameTableEntry	*pLocalPlayer;

			DPFX(DPFPREP, 7,"DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK");

			pIntegrityCheck = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK*>(pRequest + 1);

			//
			//	If we submitted this request, this is being called during host migration,
			//	so remove it from the handle table since we will destroy the dropped player anyways.
			//	Otherwise, we will perform the integrity check
			//

			if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) == DPN_OK)
			{
				if (pLocalPlayer->GetDPNID() == dpnidRequesting)
				{
					CAsyncOp* pAsyncOp;
					if (SUCCEEDED(pdnObject->HandleTable.Destroy( pRequest->hCompletionOp, (PVOID*)&pAsyncOp )))
					{
						// Release the HandleTable reference
						pAsyncOp->Release();
					}
				}
				else
				{
					DNHostCheckIntegrity(pdnObject,pIntegrityCheck->dpnidTarget,dpnidRequesting);
				}
				pLocalPlayer->Release();
				pLocalPlayer = NULL;
			}
			break;
		}

	default:
		{
			DPFERR("How did we get here ?");
			DNASSERT(FALSE);
		}
	}

	DPFX(DPFPREP, 6,"Returning: DPN_OK");
	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostFailRequest"

void DNHostFailRequest(DIRECTNETOBJECT *const pdnObject,
					   const DPNID dpnid,
					   const DPNHANDLE hCompletionOp,
					   const HRESULT hr)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	CRefCountBuffer	*pRefCountBuffer;
	CConnection		*pConnection;
	DN_INTERNAL_MESSAGE_REQUEST_FAILED	*pMsg;

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != NULL);

	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pConnection = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_REQUEST_FAILED),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create new RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQUEST_FAILED*>(pRefCountBuffer->GetBufferAddress());
	pMsg->hCompletionOp = hCompletionOp;
	pMsg->hResultCode = hr;

	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
	{
		hResultCode = DNSendMessage(pdnObject,
									pConnection,
									DN_MSG_INTERNAL_REQUEST_FAILED,
									dpnid,
									pRefCountBuffer->BufferDescAddress(),
									1,
									pRefCountBuffer,
									0,
									DN_SENDFLAGS_RELIABLE,
									NULL,
									NULL);

		pConnection->Release();
		pConnection = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	return;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNHostCreateGroup"

HRESULT	DNHostCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  PWSTR pwszName,
						  const DWORD dwNameSize,
						  void *const pvData,
						  const DWORD dwDataSize,
						  const DWORD dwInfoFlags,
						  const DWORD dwGroupFlags,
						  void *const pvGroupContext,
						  void *const pvUserContext,
						  const DPNID dpnidOwner,
						  const DPNHANDLE hCompletionOp,
						  DPNHANDLE *const phAsyncOp,
						  const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	void			*pvContext;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CPackedBuffer	packedBuffer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CAsyncOp		*pRequest;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_CREATE_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pwszName [0x%p], dwNameSize [%ld], pvData [0x%p], dwDataSize [%ld], dwInfoFlags [0x%lx], dwGroupFlags [0x%lx], pvGroupContext [0x%p], pvUserContext [0x%p], dpnidOwner [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags,dwGroupFlags,pvGroupContext,pvUserContext,dpnidOwner,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);

	//
	//	If this is called from DN_CreateGroup(),
	//			hCompletion=0
	//			dpnidOwner = DPNID of Host
	//			pvGroupContext is valid
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidOwner = DPNID of requesting player
	//			pvGroupContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidOwner = DPNID of THIS (now Host) player
	//			pvGroupContext is invalid
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pWorkerJob = NULL;
	pHandleParent = NULL;
	pRequest = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidOwner)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Get group context if this is a Host Migration re-try by finding REQUEST AsyncOp
	//
	if ((fHostRequested) && (hCompletionOp != 0))
	{
		if ((hResultCode = pdnObject->HandleTable.Find( hCompletionOp,(PVOID*)&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		else
		{
			// We would normally AddRef pRequest in the success case, but since we need to release it
			// next we will eliminate both.
		}
		pvContext = pRequest->GetContext();
		// pRequest->Release(); // Don't need since we are balancing with HandleTable ref
		pRequest = NULL;
	}
	else
	{
		pvContext = pvGroupContext;
	}

	//
	//	Create and fill in NameTableEntry
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not create new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pNTEntry->MakeGroup();

	// This function takes the lock internally
	pNTEntry->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags, FALSE);

	pNTEntry->SetOwner( dpnidOwner );
	pNTEntry->SetContext( pvContext );

	if (dwGroupFlags & DPNGROUP_AUTODESTRUCT)
	{
		pNTEntry->MakeAutoDestructGroup();
	}

	//
	//	Add Group to NameTable
	//
#pragma TODO(minara,"Check to see if Autodestruct owner is still in NameTable")
#pragma TODO(minara,"This should happen after getting a NameTable version number - as DESTROY player will clean up")
#pragma TODO(minara,"We should send out a NOP in this case")

	hrOperation = pdnObject->NameTable.AddEntry(pNTEntry);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not add NameTableEntry to NameTable");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidOwner,hCompletionOp,hrOperation);
		}
	}
	else
	{
		BOOL	fNotify;

		fNotify = FALSE;
		pNTEntry->Lock();
		if (!pNTEntry->IsAvailable() && !pNTEntry->IsDisconnecting())
		{
			pNTEntry->MakeAvailable();
			pNTEntry->NotifyAddRef();
			pNTEntry->NotifyAddRef();
			pNTEntry->SetInUse();
			fNotify = TRUE;
		}
		pNTEntry->Unlock();

		if (fNotify)
		{
			DNUserCreateGroup(pdnObject,pNTEntry);

			pNTEntry->PerformQueuedOperations();

			pdnObject->NameTable.PopulateGroup( pNTEntry );
		}

		//
		//	Send CREATE_GROUP message
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Determine size of message
			packedBuffer.Initialize(NULL,0);
			packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP));
			pNTEntry->PackEntryInfo(&packedBuffer);

			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,packedBuffer.GetSizeRequired(),MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
			pMsg = static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(packedBuffer.GetHeadAddress());
			if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP))) != DPN_OK)
			{
				DPFERR("Could not reserve front of buffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			if ((hResultCode = pNTEntry->PackEntryInfo(&packedBuffer)) != DPN_OK)
			{
				DPFERR("Could not pack NameTableEntry");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg->dpnidRequesting = dpnidOwner;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND CreateGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_CREATE_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( pNTEntry->GetVersion() );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & DPNCREATEGROUP_SYNC) && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pRequest )))
			{
				pRequest->SetResult( hrOperation );

				// Release the HandleTable reference
				pRequest->Release();
			}
			pRequest = NULL;

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidOwner,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pHostCompletionOp )))
			{
				pHostCompletionOp->SetResult( hResultCode );

				// Release the HandleTable reference
				pHostCompletionOp->Release();
			}
			pHostCompletionOp = NULL;

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDestroyGroup"

HRESULT	DNHostDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnid,
						   void *const pvUserContext,
						   const DPNID dpnidRequesting,
						   const DPNHANDLE hCompletionOp,
						   DPNHANDLE *const phAsyncOp,
						   const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_DESTROY_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnid,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != 0);
	DNASSERT(dpnidRequesting != 0);

	//
	//	If this is called from DN_DestroyGroup(),
	//			hCompletion=0
	//			dpnidRequesting = DPNID of Host
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidRequesting = DPNID of requesting player
	//			pvUserContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidRequesting = DPNID of THIS (now Host) player
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Remove Group from NameTable
	//
	dwVersion = 0;
	hrOperation = pdnObject->NameTable.DeleteGroup(dpnid,&dwVersion);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not delete group from NameTable");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		//
		//	Send DESTROY_GROUP message
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_DESTROY_GROUP),MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidGroup = dpnid;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND DestroyGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_DESTROY_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & DPNDESTROYGROUP_SYNC) && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pRequest )))
			{
				pRequest->SetResult( hrOperation );

				// Release the HandleTable reference
				pRequest->Release();
			}
			pRequest = NULL;

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pHostCompletionOp )))
			{
				pHostCompletionOp->SetResult( hResultCode );

				// Release the HandleTable reference
				pHostCompletionOp->Release();
			}
			pHostCompletionOp = NULL;

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostAddPlayerToGroup"

HRESULT	DNHostAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnidGroup,
							   const DPNID dpnidPlayer,
							   void *const pvUserContext,
							   const DPNID dpnidRequesting,
							   const DPNHANDLE hCompletionOp,
							   DPNHANDLE *const phAsyncOp,
							   const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pPlayer;
	CNameTableEntry	*pGroup;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);
	DNASSERT(dpnidPlayer != 0);
	DNASSERT(dpnidRequesting != 0);

	//
	//	If this is called from DN_AddPlayerToGroup(),
	//			hCompletion=0
	//			dpnidRequesting = DPNID of Host
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidRequesting = DPNID of requesting player
	//			pvUserContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidRequesting = DPNID of THIS (now Host) player
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	See if the player and group are still in the NameTable
	//	(this has to happen after we set fHostRequested so we can gracefully handle errors)
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDGROUP;
		hrOperation = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		hrOperation = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Add Player To Group
	//
	dwVersion = 0;
	hrOperation = pdnObject->NameTable.AddPlayerToGroup(pGroup,pPlayer,&dwVersion);

	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not add player to group");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		//
		//	Send ADD_PLAYER_TO_GROUP message
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP),MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidGroup = dpnidGroup;
			pMsg->dpnidPlayer = dpnidPlayer;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND AddPlayerToGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & DPNADDPLAYERTOGROUP_SYNC) && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pRequest )))
			{
				pRequest->SetResult( hrOperation );

				// Release the HandleTable reference
				pRequest->Release();
			}
			pRequest = NULL;

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pHostCompletionOp )))
			{
				pHostCompletionOp->SetResult( hResultCode );

				// Release the HandleTable reference
				pHostCompletionOp->Release();
			}
			pHostCompletionOp = NULL;

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDeletePlayerFromGroup"

HRESULT	DNHostDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									const DPNID dpnidGroup,
									const DPNID dpnidPlayer,
									void *const pvUserContext,
									const DPNID dpnidRequesting,
									const DPNHANDLE hCompletionOp,
									DPNHANDLE *const phAsyncOp,
									const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pPlayer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnidGroup [0x%lx], dpnidPlayer [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnidGroup,dpnidPlayer,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidGroup != 0);
	DNASSERT(dpnidPlayer != 0);
	DNASSERT(dpnidRequesting != 0);

	//
	//	If this is called from DN_DeletePlayerFromGroup(),
	//			hCompletion=0
	//			dpnidRequesting = DPNID of Host
	//			pvUserContext is valid
	//
	//	If this is called by a REQUEST,
	//			hCompletion = REQUEST handle of requesting player
	//			dpnidRequesting = DPNID of requesting player
	//			pvUserContext is not valid
	//
	//	If this is called at HostMigration,
	//			hCompletion = REQUEST handle on THIS (now Host) player
	//			dpnidRequesting = DPNID of THIS (now Host) player
	//			pvUserContext is invalid
	//

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}

	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	See if the player and group are still in the NameTable
	//	(this has to happen after we set fHostRequested so we can gracefully handle errors)
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDGROUP;
		hrOperation = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		hrOperation = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Delete Player From Group
	//
	dwVersion = 0;
	hrOperation = pdnObject->NameTable.RemovePlayerFromGroup(pGroup,pPlayer,&dwVersion);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not delete player from group");
		DisplayDNError(0,hrOperation);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		//
		//	Send DELETE_PLAYER_FROM_GROUP message if successful
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			// Create buffer
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP),MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidGroup = dpnidGroup;
			pMsg->dpnidPlayer = dpnidPlayer;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND DeletePlayerFromGroup messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}
	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC) && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pRequest )))
			{
				pRequest->SetResult( hrOperation );

				// Release the HandleTable reference
				pRequest->Release();
			}
			pRequest = NULL;

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pHostCompletionOp )))
			{
				pHostCompletionOp->SetResult( hResultCode );

				// Release the HandleTable reference
				pHostCompletionOp->Release();
			}
			pHostCompletionOp = NULL;

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNHostUpdateInfo"

HRESULT	DNHostUpdateInfo(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 PWSTR pwszName,
						 const DWORD dwNameSize,
						 void *const pvData,
						 const DWORD dwDataSize,
						 const DWORD dwInfoFlags,
						 void *const pvUserContext,
						 const DPNID dpnidRequesting,
						 const DPNHANDLE hCompletionOp,
						 DPNHANDLE *const phAsyncOp,
						 const DWORD dwFlags)
{
	HRESULT			hResultCode;
	HRESULT			hrOperation;
	DWORD			dwSize;
	DWORD			dwVersion;
	BOOL			fHostRequested;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CPackedBuffer	packedBuffer;
	CRefCountBuffer	*pRefCountBuffer;
	CAsyncOp		*pHandleParent;
	CWorkerJob		*pWorkerJob;
	DN_INTERNAL_MESSAGE_UPDATE_INFO	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx], pwszName [0x%p], dwNameSize [%ld], pvData [0x%p], dwDataSize [%ld], dwInfoFlags [0x%lx], pvUserContext [0x%p], dpnidRequesting [0x%lx], hCompletionOp [0x%lx], phAsyncOp [0x%p], dwFlags [0x%lx]",
			dpnid,pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags,pvUserContext,dpnidRequesting,hCompletionOp,phAsyncOp,dwFlags);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != 0);
	DNASSERT(dpnidRequesting != 0);

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pHandleParent = NULL;
	pWorkerJob = NULL;

	//
	//	Determine if this is being requested by the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		return(DPN_OK);	// Ignore and continue (!)
	}
	if (pLocalPlayer->GetDPNID() == dpnidRequesting)
	{
		fHostRequested = TRUE;
	}
	else
	{
		fHostRequested = FALSE;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Update Info
	//
	hrOperation = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry);
	if (hrOperation != DPN_OK)
	{
		DPFERR("Could not find entry");
		DisplayDNError(0,hResultCode);
		if (!fHostRequested)
		{
			DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
		}
	}
	else
	{
		// This function takes the lock internally
		pNTEntry->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,dwInfoFlags, (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER)) ? TRUE : !fHostRequested);

		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.GetNewVersion( &dwVersion );
		pdnObject->NameTable.Unlock();

		//
		//	Send UPDATE_INFO message
		//
#ifndef DPNBUILD_NOSERVER
		if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER | DN_OBJECT_FLAG_SERVER))
#else
		if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER))
#endif // DPNBUILD_NOSERVER
		{
			// Create buffer
			dwSize = sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO) + dwNameSize + dwDataSize;
			if ((hResultCode = RefCountBufferNew(pdnObject,dwSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
			pMsg = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(packedBuffer.GetHeadAddress());
			if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO))) != DPN_OK)
			{
				DPFERR("Could not reserve front of buffer");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			if ((dwInfoFlags & DPNINFO_NAME) && (pwszName) && (dwNameSize))
			{
				if ((hResultCode = packedBuffer.AddToBack(pwszName,dwNameSize)) != DPN_OK)
				{
					DPFERR("Could not add Name to back of buffer");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pMsg->dwNameOffset = packedBuffer.GetTailOffset();
				pMsg->dwNameSize = dwNameSize;
			}
			else
			{
				pMsg->dwNameOffset = 0;
				pMsg->dwNameSize = 0;
			}
			if ((dwInfoFlags & DPNINFO_DATA) && (pvData) && (dwDataSize))
			{
				if ((hResultCode = packedBuffer.AddToBack(pvData,dwDataSize)) != DPN_OK)
				{
					DPFERR("Could not add Data to back of buffer");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pMsg->dwDataOffset = packedBuffer.GetTailOffset();
				pMsg->dwDataSize = dwDataSize;
			}
			else
			{
				pMsg->dwDataOffset = 0;
				pMsg->dwDataSize = 0;
			}
			pMsg->dpnid = dpnid;
			pMsg->dwInfoFlags = dwInfoFlags;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dpnidRequesting = dpnidRequesting;
			pMsg->hCompletionOp = hCompletionOp;

			//
			//	SEND UpdateInfo messages via WorkerThread
			//
			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create new WorkerJob");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}

#ifndef	DPNBUILD_NOSERVER
			if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
#endif	// DPNBUILD_NOSERVER
			{
				pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
				pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
			}
#ifndef	DPNBUILD_NOSERVER
			else if ((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER) && fHostRequested)
			{
				// Send to everyone except the server
				pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
				pWorkerJob->SetSendNameTableOperationDPNIDExclude( dpnidRequesting );
			}
			else
			{
				DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER);

				// This will be responding to a client that requested its
				// info updated via SetClientInfo

				// Use the Exclude DPNID as the address to send to
				pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT );
				pWorkerJob->SetSendNameTableOperationDPNIDExclude( dpnidRequesting );
			}
#endif	// DPNBUILD_NOSERVER
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_UPDATE_INFO );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If this was called by the local (Host) player,
	//	Check to see if this was an original operation or a re-try from HostMigration
	//
	//	If this was an original operation,
	//		See if we need an Async HANDLE for the user
	//	Otherwise
	//		Clean up the outstanding operation
	//
	if (fHostRequested)
	{
		if (hCompletionOp == 0)		// Original
		{
			DBG_CASSERT( DPNSETGROUPINFO_SYNC == DPNSETCLIENTINFO_SYNC );
			DBG_CASSERT( DPNSETCLIENTINFO_SYNC == DPNSETSERVERINFO_SYNC );
			DBG_CASSERT( DPNSETSERVERINFO_SYNC == DPNSETPEERINFO_SYNC );
			//
			//	If this fails, or is synchronous, return the operation result immediately
			//
			if (!(dwFlags & (DPNSETGROUPINFO_SYNC | DPNSETCLIENTINFO_SYNC | DPNSETSERVERINFO_SYNC | DPNSETPEERINFO_SYNC))
				 && (hrOperation == DPN_OK))
			{
				if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
				{
					DPFERR("Could not create Async HANDLE");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pHandleParent->SetCompletion( DNCompleteAsyncHandle );
				pHandleParent->SetContext( pvUserContext );
				pHandleParent->SetResult( hrOperation );
				pHandleParent->SetCannotCancel();
				*phAsyncOp = pHandleParent->GetHandle();
				pHandleParent->Release();
				pHandleParent = NULL;

				hResultCode = DPNERR_PENDING;
			}
			else
			{
				hResultCode = hrOperation;
			}
		}
		else						// Host Migration re-try
		{
			CAsyncOp	*pRequest;

			pRequest = NULL;

			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pRequest )))
			{
				pRequest->SetResult( hrOperation );

				// Release the HandleTable reference
				pRequest->Release();
			}
			pRequest = NULL;

			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (!fHostRequested)
	{
		DNHostFailRequest(pdnObject,dpnidRequesting,hCompletionOp,hrOperation);
	}
	else
	{
		//
		//	If a completion op was specified and this was requested by the Host, this is a
		//	retry of an operation during Host migration.  In this case, we want to set the
		//	result (failure code) of the completion op, and remove it from the HandleTable.
		//
		if (hCompletionOp)
		{
			CAsyncOp	*pHostCompletionOp;

			pHostCompletionOp = NULL;
			if (SUCCEEDED(pdnObject->HandleTable.Destroy( hCompletionOp, (PVOID*)&pHostCompletionOp )))
			{
				pHostCompletionOp->SetResult( hResultCode );

				// Release the HandleTable reference
				pHostCompletionOp->Release();
			}
			pHostCompletionOp = NULL;

			DNASSERT(pHostCompletionOp == NULL);
		}
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DNHostCheckIntegrity
//
//	The host has been asked to perform an integrity check.  We will send a message to the
//	target player with the DPNID of the requesting player.  If this is returned to us, we
//	will destroy the requesting player.

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostCheckIntegrity"

HRESULT	DNHostCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnidTarget,
							 const DPNID dpnidRequesting)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_INTEGRITY_CHECK	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: dpnidTarget [0x%lx], dpnidRequesting [0x%lx]",dpnidTarget,dpnidRequesting);

	pNTEntry = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	//
	//	Ensure that the target player is still in the NameTable, as we might have deleted him already
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidTarget,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find integrity check target in NameTable - probably deleted already");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get target player connection reference - probably deleted already");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Create the message
	//
	hResultCode = RefCountBufferNew(pdnObject,
									sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK),
									MemoryBlockAlloc,
									MemoryBlockFree,
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnidRequesting = dpnidRequesting;

	//
	//	Send message
	//
	if ((hResultCode = DNSendMessage(	pdnObject,
										pConnection,
										DN_MSG_INTERNAL_INTEGRITY_CHECK,
										dpnidTarget,
										pRefCountBuffer->BufferDescAddress(),
										1,
										pRefCountBuffer,
										0,
										DN_SENDFLAGS_RELIABLE,
										NULL,
										NULL )) != DPNERR_PENDING)
	{
		DPFERR("Could not send message - probably deleted already");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		hResultCode = DPN_OK;
		goto Failure;
	}

	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNHostFixIntegrity
//
//	The host has received a response from a player whose session integrity was being checked.
//	The player who requested this check will be dropped.
							 
#undef DPF_MODNAME
#define DPF_MODNAME "DNHostFixIntegrity"

HRESULT	DNHostFixIntegrity(DIRECTNETOBJECT *const pdnObject,
						   void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	UNALIGNED DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE	*pResponse;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION			*pMsg;

	DPFX(DPFPREP, 6,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pNTEntry = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	pResponse = static_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE*>(pvBuffer);

	//
	//	Get requesting player's connection - they may have already dropped
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pResponse->dpnidRequesting,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find player in NameTable - may have dropped");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get player connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Build terminate message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION),MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dwTerminateDataOffset = 0;
	pMsg->dwTerminateDataSize = 0;

	//
	//	Send message to player to exit
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_TERMINATE_SESSION,
								pResponse->dpnidRequesting,
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);

	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Disconnect player
	//
	hResultCode = DNHostDisconnect(pdnObject,pResponse->dpnidRequesting,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessCreateGroup"

HRESULT	DNProcessCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CAsyncOp		*pRequest;
	UNALIGNED DN_NAMETABLE_ENTRY_INFO				*pInfo;
	UNALIGNED DN_INTERNAL_MESSAGE_CREATE_GROUP	*pMsg;
	BOOL			fNotify;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pRequest = NULL;
	pLocalPlayer = NULL;
	pNTEntry = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pvBuffer);
	pInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(pMsg + 1);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Create Group
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not create new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pNTEntry->UnpackEntryInfo(pInfo,static_cast<BYTE*>(pvBuffer))) != DPN_OK)
	{
		DPFERR("Could not unpack NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Get async op if we requested this operation - it has the group context on it
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		pdnObject->HandleTable.Lock();
		if ((hResultCode = pdnObject->HandleTable.Find( pMsg->hCompletionOp,(PVOID*)&pRequest )) != DPN_OK)
		{
			pdnObject->HandleTable.Unlock();
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		else
		{
			pRequest->AddRef();
			pdnObject->HandleTable.Unlock();
		}
		pNTEntry->SetContext( pRequest->GetContext() );
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Add Group to NameTable
	//
	if ((hResultCode = pdnObject->NameTable.InsertEntry(pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not update NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion(pNTEntry->GetVersion());
	pdnObject->NameTable.Unlock();

	fNotify = FALSE;
	pNTEntry->Lock();
	if (!pNTEntry->IsAvailable() && !pNTEntry->IsDisconnecting())
	{
		pNTEntry->MakeAvailable();
		pNTEntry->NotifyAddRef();
		pNTEntry->NotifyAddRef();
		pNTEntry->SetInUse();
		fNotify = TRUE;
	}
	pNTEntry->Unlock();

	if (fNotify)
	{
		DNUserCreateGroup(pdnObject,pNTEntry);

		pNTEntry->PerformQueuedOperations();
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If this is a completion, set result and remove it from the request list and handle table
	//
	if (pRequest)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		if (SUCCEEDED(pdnObject->HandleTable.Destroy( pMsg->hCompletionOp, NULL )))
		{
			// Release the HandleTable reference
			pRequest->Release();
		}
		pRequest->Release();
		pRequest = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessDestroyGroup"

HRESULT	DNProcessDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  void *const pvBuffer)
{
	HRESULT			hResultCode;
	DWORD			dwVersion;
	CNameTableEntry	*pLocalPlayer;
	CAsyncOp		*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pvBuffer);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Destroy Group
	//
	dwVersion = pMsg->dwVersion;
	if ((hResultCode = pdnObject->NameTable.DeleteGroup(pMsg->dpnidGroup,&dwVersion)) != DPN_OK)
	{
		DPFERR("Could not delete group from NameTable");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}

	//
	//	If this is a completion, set the result and remove it from the request list and handle table
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Destroy( pMsg->hCompletionOp,(PVOID*)&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessAddPlayerToGroup"

HRESULT	DNProcessAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer)
{
	HRESULT			hResultCode;
	DWORD			dwVersion;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pPlayer;
	CAsyncOp		*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pvBuffer);

	//
	//	Get NameTable entries
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}


	//
	//	Add Player To Group
	//
	dwVersion = pMsg->dwVersion;
	if ((hResultCode = pdnObject->NameTable.AddPlayerToGroup(pGroup,pPlayer,&dwVersion)) != DPN_OK)
	{
		DPFERR("Could not add player to group");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	//
	//	If this is a completion, set result and remove it from the request list and handle table
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Destroy( pMsg->hCompletionOp,(PVOID*)&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessDeletePlayerFromGroup"

HRESULT	DNProcessDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   void *const pvBuffer)
{
	HRESULT			hResultCode;
	DWORD			dwVersion;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pGroup;
	CNameTableEntry	*pPlayer;
	CAsyncOp		*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pGroup = NULL;
	pPlayer = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pvBuffer);

	//
	//	Get NameTable entries
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidGroup,&pGroup)) != DPN_OK)
	{
		DPFERR("Could not find group");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnidPlayer,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);

		//
		//	Update version in any event (to prevent NameTable hangs)
		//
		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.SetVersion( pMsg->dwVersion );
		pdnObject->NameTable.Unlock();

		goto Failure;
	}

	//
	//	Delete Player From Group
	//
	dwVersion = pMsg->dwVersion;
	if ((hResultCode = pdnObject->NameTable.RemovePlayerFromGroup(pGroup,pPlayer,&dwVersion)) != DPN_OK)
	{
		DPFERR("Could not delete player from group");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pGroup->Release();
	pGroup = NULL;
	pPlayer->Release();
	pPlayer = NULL;

	//
	//	If this is a completion, set the result and remove it from the request list and handle table
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Destroy( pMsg->hCompletionOp,(PVOID*)&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessUpdateInfo"

HRESULT	DNProcessUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							void *const pvBuffer)
{
	HRESULT			hResultCode;
	PWSTR			pwszName;
	PVOID			pvData;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CAsyncOp		*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_UPDATE_INFO	*pMsg;
	BOOL			fDoUpdate = TRUE;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pvBuffer);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		//
		//	Update Info
		//
		if ((hResultCode = pdnObject->NameTable.FindEntry(pMsg->dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find NameTableEntry");
			DisplayDNError(0,hResultCode);

			//
			//	Update version in any event (to prevent NameTable hangs)
			//
			pdnObject->NameTable.WriteLock();
			pdnObject->NameTable.SetVersion( pMsg->dwVersion );
			pdnObject->NameTable.Unlock();

			goto Failure;
		}
	}
	else 
	{
		DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT);

		// We are either being told that the host info has changed by a call
		// on the Host to SetServerInfo, or we are being told that our own
		// request to the server to change this Client's info has completed.
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find Host NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if (pNTEntry->GetDPNID() == pMsg->dpnid)
		{
			DPFX(DPFPREP, 5,"Updating server info");
		}
		else if (pLocalPlayer->GetDPNID() == pMsg->dpnid)
		{
			fDoUpdate = FALSE;
			DPFX(DPFPREP, 5,"Completing updating client info");
		}
		else
		{
			DPFERR("Received UpdateInfo for bad DPNID");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	if (fDoUpdate)
	{
		if ((pMsg->dwInfoFlags & DPNINFO_NAME) && (pMsg->dwNameOffset))
		{
			pwszName = reinterpret_cast<WCHAR*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwNameOffset);
		}
		else
		{
			pwszName = NULL;
		}
		if ((pMsg->dwInfoFlags & DPNINFO_DATA) && (pMsg->dwDataOffset))
		{
			pvData = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwDataOffset);
		}
		else
		{
			pvData = NULL;
		}

		// This function takes the lock internally
		pNTEntry->UpdateEntryInfo(pwszName,pMsg->dwNameSize,pvData,pMsg->dwDataSize,pMsg->dwInfoFlags, TRUE);
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Set NameTable version
	//
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion(pMsg->dwVersion);
	pdnObject->NameTable.Unlock();

	//
	//	If this is a completion, set the result and remove it from the request list and handle table
	//
	if (pMsg->dpnidRequesting == pLocalPlayer->GetDPNID())
	{
		if ((hResultCode = pdnObject->HandleTable.Destroy( pMsg->hCompletionOp,(PVOID*)&pRequest )) != DPN_OK)
		{
			DPFERR("Could not find REQUEST AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( DPN_OK );
		pRequest->Release();
		pRequest = NULL;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessFailedRequest"

HRESULT DNProcessFailedRequest(DIRECTNETOBJECT *const pdnObject,
							   void *const pvBuffer)
{
	HRESULT		hResultCode;
	CAsyncOp	*pRequest;
	UNALIGNED DN_INTERNAL_MESSAGE_REQUEST_FAILED	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pRequest = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_REQUEST_FAILED*>(pvBuffer);

	//
	//	Update request using handle to HRESULT passed back by Host, and remove request from request list and handle table
	//
	if ((hResultCode = pdnObject->HandleTable.Destroy( pMsg->hCompletionOp, (PVOID*)&pRequest )) == DPN_OK)
	{
		DNASSERT( pMsg->hCompletionOp != 0 );

		DNEnterCriticalSection(&pdnObject->csActiveList);
		pRequest->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		pRequest->SetResult( pMsg->hResultCode );

		pRequest->Release();
		pRequest = NULL;
	}
	hResultCode = DPN_OK;

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNProcessCheckIntegrity
//
//	The host is performing an integrity check and is asking the local player (us) if we are still
//	in the session.  We will respond that we are, and the host will drop the requesting player.

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessCheckIntegrity"

HRESULT	DNProcessCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
								void *const pvBuffer)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pHostPlayer;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	UNALIGNED DN_INTERNAL_MESSAGE_INTEGRITY_CHECK				*pMsg;
	DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE	*pResponse;

	DPFX(DPFPREP, 6,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pHostPlayer = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	//
	//	Get host player connection to respond to
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not get host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get host player connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	//
	//	Create response
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE),MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pResponse = reinterpret_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE*>(pRefCountBuffer->GetBufferAddress());
	pMsg = static_cast<DN_INTERNAL_MESSAGE_INTEGRITY_CHECK*>(pvBuffer);
	pResponse->dpnidRequesting = pMsg->dpnidRequesting;

	//
	//	Send response
	//
	if ((hResultCode = DNSendMessage(	pdnObject,
										pConnection,
										DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE,
										pConnection->GetDPNID(),
										pRefCountBuffer->BufferDescAddress(),
										1,
										pRefCountBuffer,
										0,
										DN_SENDFLAGS_RELIABLE,
										NULL,
										NULL )) != DPNERR_PENDING)
	{
		DPFERR("Could not send integrity check response");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		goto Failure;
	}

	pConnection->Release();
	pConnection = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\queuedmsg.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       QueuedMsg.h
 *  Content:    Queued Message Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/31/00	mjn		Created
 *	09/12/00	mjn		Added m_OpType
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__QUEUED_MSG_H__
#define	__QUEUED_MSG_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	QUEUED_MSG_FLAG_VOICE		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef enum
{
	UNKNOWN,
	RECEIVE,
	ADD_PLAYER_TO_GROUP,
	REMOVE_PLAYER_FROM_GROUP,
	UPDATE_INFO
} QUEUED_MSG_TYPE;

class CAsyncOp;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Queued Messages

class CQueuedMsg
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CQueuedMsg::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CQueuedMsg* pQueuedMsg = (CQueuedMsg*)pvItem;

			pQueuedMsg->m_Sig[0] = 'Q';
			pQueuedMsg->m_Sig[1] = 'M';
			pQueuedMsg->m_Sig[2] = 'S';
			pQueuedMsg->m_Sig[3] = 'G';

			pQueuedMsg->m_bilinkQueuedMsgs.Initialize();

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CQueuedMsg::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CQueuedMsg* pQueuedMsg = (CQueuedMsg*)pvItem;

			pQueuedMsg->m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			pQueuedMsg->m_OpType = UNKNOWN;
			pQueuedMsg->m_dwFlags = 0;
			pQueuedMsg->m_pBuffer = NULL;
			pQueuedMsg->m_dwBufferSize = 0;
			pQueuedMsg->m_hCompletionOp = 0;
			pQueuedMsg->m_pAsyncOp = NULL;

			DNASSERT(pQueuedMsg->m_bilinkQueuedMsgs.IsEmpty());
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CQueuedMsg::FPMRelease"
	static void FPMRelease(void* pvItem) 
		{ 
			const CQueuedMsg* pQueuedMsg = (CQueuedMsg*)pvItem;

			DNASSERT(pQueuedMsg->m_bilinkQueuedMsgs.IsEmpty());
		};

	void ReturnSelfToPool( void )
		{
			g_QueuedMsgPool.Release( this );
		};

	void SetOpType( const QUEUED_MSG_TYPE OpType )
		{
			m_OpType = OpType;
		};

	QUEUED_MSG_TYPE GetOpType( void ) const
		{
			return( m_OpType );
		};

#ifndef DPNBUILD_NOVOICE
	void MakeVoiceMessage( void )
		{
			m_dwFlags |= QUEUED_MSG_FLAG_VOICE;
		};

	BOOL IsVoiceMessage( void ) const
		{
			if (m_dwFlags & QUEUED_MSG_FLAG_VOICE)
			{
				return( TRUE );
			}
			return( FALSE );
		};
#endif // DPNBUILD_NOVOICE

	void SetBuffer( BYTE *const pBuffer )
		{
			m_pBuffer = pBuffer;
		};

	BYTE *GetBuffer( void )
		{
			return( m_pBuffer );
		};

	void SetBufferSize( const DWORD dwBufferSize )
		{
			m_dwBufferSize = dwBufferSize;
		};

	DWORD GetBufferSize( void ) const
		{
			return( m_dwBufferSize );
		};

	void SetCompletionOp( const DPNHANDLE hCompletionOp)
		{
			m_hCompletionOp = hCompletionOp;
		};

	DPNHANDLE GetCompletionOp( void ) const
		{
			return( m_hCompletionOp );
		};

	void CQueuedMsg::SetAsyncOp( CAsyncOp *const pAsyncOp );

	CAsyncOp *GetAsyncOp( void )
		{
			return( m_pAsyncOp );
		};

	CBilink				m_bilinkQueuedMsgs;

private:
	BYTE				m_Sig[4];			// Signature
	QUEUED_MSG_TYPE		m_OpType;
	DWORD	volatile	m_dwFlags;

	BYTE				*m_pBuffer;
	DWORD				m_dwBufferSize;

	DPNHANDLE			m_hCompletionOp;

	CAsyncOp			*m_pAsyncOp;

	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __QUEUED_MSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\server.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Server.h
 *  Content:    DirectNet Server interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	10/08/99	jtk		Split from DNCore.h
 *	12/03/99	jtk		Moved COM interface definitions to DNet.h
 *	02/15/00	mjn		Use INFO flags in SetServerInfo and return context in GetClientInfo
 *	04/06/00	mjn		Added GetClientAddress to API
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SERVER_H__
#define	__SERVER_H__

#ifndef	DPNBUILD_NOSERVER

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for server interface
//
extern IDirectPlay8ServerVtbl DN_ServerVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectNet - IDirectPlay8Server
//
STDMETHODIMP DN_SetServerInfo(IDirectPlay8Server *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetClientInfo(IDirectPlay8Server *pInterface,
							  const DPNID dpnid,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetClientAddress(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags);

#endif	// DPNBUILD_NOSERVER

#endif	// __SERVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\server.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Server.cpp
 *  Content:    DNET server interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/22/00	mjn		Implemented DestroyClient in API
 *	01/28/00	mjn		Implemented ReturnBuffer in API
 *	02/01/00	mjn		Implemented GetCaps and SetCaps in API
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/15/00	mjn		Use INFO flags in SetServerInfo and return context in GetClientInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *  03/17/00    rmt     Added new caps functions
 *	04/04/00	mjn		Added TerminateSession to API
 *	04/05/00	mjn		Modified DestroyClient
 *	04/06/00	mjn		Added GetClientAddress to API
 *				mjn		Added GetHostAddress to API
 *  04/18/00    rmt     Added additional paramtere validation
 *	04/19/00	mjn		SendTo API call accepts a range of DPN_BUFFER_DESCs and a count
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/23/00	mjn		Removed dwPriority from SendTo() API call
 *	07/09/00	mjn		Cleaned up DN_SetServerInfo()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *				mjn		Check deleted list in DN_GetClientInfo()
 *	01/22/01	mjn		Check closing instead of disconnecting in DN_GetClientInfo()
 *	07/24/01	mjn		Added DPNBUILD_NOPARAMVAL compile flag
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#ifndef	DPNBUILD_NOSERVER

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

typedef	STDMETHODIMP ServerQueryInterface( IDirectPlay8Server *pInterface, DP8REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	ServerAddRef( IDirectPlay8Server *pInterface );
typedef	STDMETHODIMP_(ULONG)	ServerRelease( IDirectPlay8Server *pInterface );
typedef	STDMETHODIMP ServerInitialize( IDirectPlay8Server *pInterface, LPVOID const lpvUserContext, const PFNDPNMESSAGEHANDLER lpfn, const DWORD dwFlags );
typedef	STDMETHODIMP ServerEnumServiceProviders( IDirectPlay8Server *pInterface,const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,DWORD *const pcbEnumData,DWORD *const pcReturned,const DWORD dwFlags);
typedef	STDMETHODIMP ServerCancelAsyncOperation( IDirectPlay8Server *pInterface, const DPNHANDLE hAsyncHandle, const DWORD dwFlags );
typedef	STDMETHODIMP ServerGetSendQueueInfo( IDirectPlay8Server *pInterface, const DPNID dpnid,DWORD *const lpdwNumMsgs, DWORD *const lpdwNumBytes, const DWORD dwFlags );
typedef	STDMETHODIMP ServerGetApplicationDesc( IDirectPlay8Server *pInterface,DPN_APPLICATION_DESC *const pAppDescBuffer,DWORD *const lpcbDataSize,const DWORD dwFlags );
typedef	STDMETHODIMP ServerSetApplicationDesc( IDirectPlay8Server *pInterface, const DPN_APPLICATION_DESC *const lpad, const DWORD dwFlags );
typedef STDMETHODIMP ServerGetHostAddress( IDirectPlay8Server *pInterface, IDirectPlay8Address **const prgpAddress, DWORD *const pcAddress,const DWORD dwFlags);
typedef	STDMETHODIMP ServerHost( IDirectPlay8Server *pInterface,const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags);
typedef	STDMETHODIMP ServerSendTo( IDirectPlay8Server *pInterface, const DPNID dnid, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef	STDMETHODIMP ServerCreateGroup( IDirectPlay8Server *pInterface, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerDestroyGroup( IDirectPlay8Server *pInterface, const DPNID idGroup,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerAddClientToGroup( IDirectPlay8Server *pInterface, const DPNID idGroup, const DPNID idClient,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerRemoveClientFromGroup( IDirectPlay8Server *pInterface, const DPNID idGroup, const DPNID idClient,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerSetGroupInfo(IDirectPlay8Server *pInterface, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
typedef STDMETHODIMP ServerGetGroupInfo(IDirectPlay8Server *pInterface, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags);
typedef STDMETHODIMP ServerEnumClientsAndGroups( IDirectPlay8Server *pInterface, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags );
typedef	STDMETHODIMP ServerEnumGroupMembers( IDirectPlay8Server *pInterface, const DPNID dnid, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags );
typedef	STDMETHODIMP ServerClose( IDirectPlay8Server *pInterface,const DWORD dwFlags);
typedef STDMETHODIMP ServerDestroyClient( IDirectPlay8Server *pInterface,const DPNID dnid,const void *const pvDestroyData,const DWORD dwDestroyDataSize,const DWORD dwFlags);
typedef STDMETHODIMP ServerReturnBuffer( IDirectPlay8Server *pInterface, const DPNHANDLE hBufferHandle,const DWORD dwFlags);
typedef STDMETHODIMP ServerGetCaps(IDirectPlay8Server *pInterface,DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP ServerSetCaps(IDirectPlay8Server *pInterface,const DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP ServerGetPlayerContext(IDirectPlay8Server *pInterface,const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags);
typedef STDMETHODIMP ServerGetGroupContext(IDirectPlay8Server *pInterface,const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags);
typedef STDMETHODIMP ServerSetSPCaps(IDirectPlay8Server *pInterface,const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
typedef STDMETHODIMP ServerGetSPCaps(IDirectPlay8Server *pInterface,const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags);
typedef STDMETHODIMP ServerGetConnectionInfo(IDirectPlay8Server *pInterface,const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags);
typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);

//
// VTable for server interface
//
IDirectPlay8ServerVtbl DN_ServerVtbl =
{
	(ServerQueryInterface*)			DN_QueryInterface,
	(ServerAddRef*)					DN_AddRef,
	(ServerRelease*)				DN_Release,
	(ServerInitialize*)				DN_Initialize,
	(ServerEnumServiceProviders*)	DN_EnumServiceProviders,
	(ServerCancelAsyncOperation*)	DN_CancelAsyncOperation,
	(ServerGetSendQueueInfo*)		DN_GetSendQueueInfo,
	(ServerGetApplicationDesc*)		DN_GetApplicationDesc,
									DN_SetServerInfo,
									DN_GetClientInfo,
									DN_GetClientAddress,
	(ServerGetHostAddress*)			DN_GetHostAddress,
	(ServerSetApplicationDesc*)		DN_SetApplicationDesc,
	(ServerHost*)					DN_Host,
	(ServerSendTo*)					DN_SendTo,
	(ServerCreateGroup*)			DN_CreateGroup,
	(ServerDestroyGroup*)			DN_DestroyGroup,
	(ServerAddClientToGroup*)		DN_AddClientToGroup,
	(ServerRemoveClientFromGroup*)	DN_RemoveClientFromGroup,
	(ServerSetGroupInfo*)			DN_SetGroupInfo,
	(ServerGetGroupInfo*)			DN_GetGroupInfo,
	(ServerEnumClientsAndGroups*)	DN_EnumClientsAndGroups,
	(ServerEnumGroupMembers*)		DN_EnumGroupMembers,
	(ServerClose*)					DN_Close,
	(ServerDestroyClient*)			DN_DestroyPlayer,
	(ServerReturnBuffer*)			DN_ReturnBuffer,
	(ServerGetPlayerContext*)		DN_GetPlayerContext,
	(ServerGetGroupContext*)		DN_GetGroupContext,
	(ServerGetCaps*)				DN_GetCaps,
	(ServerSetCaps*)				DN_SetCaps,
    (ServerSetSPCaps*)              DN_SetSPCaps, 
    (ServerGetSPCaps*)              DN_GetSPCaps,
    (ServerGetConnectionInfo*)      DN_GetConnectionInfo,
	(ServerRegisterLobby*)			DN_RegisterLobby
};

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//	DN_SetServerInfo
//
//	Set the info for the server and propagate to client players

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetServerInfo"

STDMETHODIMP DN_SetServerInfo(IDirectPlay8Server *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	BOOL				fConnected;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateSetServerInfo( pInterface , pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating setserverinfo params hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif // !DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	
	
	pLocalPlayer = NULL;

	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnPlayerInfo->pwszName))
	{
		pwszName = pdpnPlayerInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnPlayerInfo->pvData) && (pdpnPlayerInfo->dwDataSize))
	{
		pvData = pdpnPlayerInfo->pvData;
		dwDataSize = pdpnPlayerInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	//
	//	If we are connected, we will update our entry.
	//	Otherwise, we will just update the DefaultPlayer.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fConnected = TRUE;
	}
	else
	{
		fConnected = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fConnected)
	{
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR( "Could not get local player reference" );
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		DPFX(DPFPREP, 3,"Host is updating server info");

		hResultCode = DNHostUpdateInfo(	pdnObject,
										pLocalPlayer->GetDPNID(),
										pwszName,
										dwNameSize,
										pvData,
										dwDataSize,
										pdpnPlayerInfo->dwInfoFlags,
										pvAsyncContext,
										pLocalPlayer->GetDPNID(),
										0,
										&hAsyncOp,
										dwFlags );
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to update group");
		}
		else
		{
			if (!(dwFlags & DPNSETSERVERINFO_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				CAsyncOp* pAsyncOp;
				if (SUCCEEDED(pdnObject->HandleTable.Destroy( hAsyncOp, (PVOID*)&pAsyncOp )))
				{
					// Release the HandleTable reference
					pAsyncOp->Release();
				}
				pAsyncOp = NULL;
				hAsyncOp = 0;
			}
		}

		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

		// This function takes the lock internally
		pdnObject->NameTable.GetDefaultPlayer()->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,pdpnPlayerInfo->dwInfoFlags, FALSE);

		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DN_GetClientInfo
//
//	Retrieve client info from the local nametable.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetClientInfo"

STDMETHODIMP DN_GetClientInfo(IDirectPlay8Server *pInterface,
							  const DPNID dpnid,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	CPackedBuffer		packedBuffer;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters: dpnid [0x%lx], pdpnPlayerInfo [0x%p], dwFlags [0x%lx]",
			dpnid,pdpnPlayerInfo,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateGetClientInfo( pInterface , dpnid, pdpnPlayerInfo, pdwSize, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating getclientinfo params hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif	// DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    {
    	DPFERR("You must be connected / disconnecting to use this function" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	    	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve name table entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}
	packedBuffer.Initialize(pdpnPlayerInfo,*pdwSize);

	pNTEntry->Lock();
	if (pNTEntry->IsGroup() || pNTEntry->IsHost())
	{
	    DPFERR( "Specified ID is invalid" );
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = pNTEntry->PackInfo(&packedBuffer);

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetClientAddress"

STDMETHODIMP DN_GetClientAddress(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	IDirectPlay8Address	*pAddress;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters : pInterface [0x%p], dpnid [0x%lx], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,dpnid,ppAddress,dwFlags);

    pdnObject = (DIRECTNETOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
    DNASSERT(pdnObject != NULL);

#ifndef	DPNBUILD_NOPARAMVAL
    if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    {
        if( FAILED( hResultCode = DN_ValidateGetClientAddress( pInterface , dpnid, ppAddress, dwFlags ) ) )
        {
        	DPFX(DPFPREP,  0, "Error validating getclientaddress params hr=[0x%lx]", hResultCode );
        	DPF_RETURN( hResultCode );
        }
    }
#endif	// DPNBUILD_NOPARAMVAL

    // Check to ensure message handler registered
    if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    {
    	DPFERR( "Object is not initialized" );
    	DPF_RETURN(DPNERR_UNINITIALIZED);
    }	

    if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    {
    	DPFERR("Object is connecting / starting to host" );
    	DPF_RETURN(DPNERR_CONNECTING);
    }

    if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    {
    	DPFERR("You must be connected / disconnecting to use this function" );
    	DPF_RETURN(DPNERR_NOCONNECTION);
    }	    	

	pNTEntry = NULL;
	pAddress = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	if ((pNTEntry->GetAddress() == NULL) || (pNTEntry->IsGroup()) || !pNTEntry->IsAvailable())
	{
	    DPFERR( "Specified player is not valid" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	hResultCode = IDirectPlay8Address_Duplicate(pNTEntry->GetAddress(),ppAddress);

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	goto Exit;
}

#endif	// DPNBUILD_NOSERVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\receive.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Receive.h
 *  Content:    DirectNet receive user data
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/27/00	mjn		Created
 *	04/20/00	mjn		ReceiveBuffers use CAsyncOp
 *	08/02/00	mjn		Added dwFlags to DNReceiveUserData()
 *				mjn		Added DNSendUserProcessCompletion()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added service provider to DNReceiveUserData()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__RECEIVE_H__
#define	__RECEIVE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT	DNReceiveUserData(DIRECTNETOBJECT *const pdnObject,
						  CConnection *const pConnection,
						  BYTE *const pBufferData,
						  const DWORD dwBufferSize,
						  const HANDLE hProtocol,
						  CRefCountBuffer *const pRefCountBuffer,
						  const DPNHANDLE hCompletionOp,
						  const DWORD dwFlags);

HRESULT DNSendUserProcessCompletion(DIRECTNETOBJECT *const pdnObject,
									CConnection *const pConnection,
									const DPNHANDLE hCompletionOp);

void DNFreeProtocolBuffer(void *const pv,void *const pvBuffer);

void DNCompleteReceiveBuffer(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __RECEIVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\servprov.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ServProv.cpp
 *  Content:    Service Provider Objects
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/17/00	mjn		Created
 *  04/04/00    rmt     Added set of SP caps from cache (if cache exists).
 *	04/10/00	mjn		Farm out RemoveSP to worker thread
 *	05/02/00	mjn		Fixed RefCount issue
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat 
 *	07/06/00	mjn		Fixes to support SP handle to Protocol
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2  
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/06/00	mjn		Added CWorkerJob
 *	08/20/00	mjn		Changed Initialize() to not add SP to DirectNet object bilink
 *	10/08/01	vanceo	Add multicast filter
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::Initialize"

HRESULT CServiceProvider::Initialize(DIRECTNETOBJECT *const pdnObject
#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_PREALLOCATEDMEMORYMODEL)))
									,const XDP8CREATE_PARAMS * const pDP8CreateParams
#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_PREALLOCATEDMEMORYMODEL
#ifndef DPNBUILD_ONLYONESP
									,const GUID *const pguid
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
									,const GUID *const pguidApplication
#endif // ! DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_PREALLOCATEDMEMORYMODEL
									)
{
	HRESULT							hResultCode;
	IDP8ServiceProvider				*pISP;
	BOOL							fAddedToProtocol;
#ifndef DPNBUILD_LIBINTERFACE
	SPISAPPLICATIONSUPPORTEDDATA	spAppSupData;
#endif // ! DPNBUILD_LIBINTERFACE


	DNASSERT(pdnObject != NULL);
#ifndef DPNBUILD_ONLYONESP
	DNASSERT(pguid != NULL);
#endif // ! DPNBUILD_ONLYONESP

	m_pdnObject = NULL;
#if ((defined(DPNBUILD_ONLYONESP)) && (defined(DPNBUILD_LIBINTERFACE)))
	m_lRefCount = 0;
#else // ! DPNBUILD_ONLYONESP or ! DPNBUILD_LIBINTERFACE
	m_lRefCount = 1;
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
	m_pISP = NULL;
	m_hProtocolSPHandle = NULL;

#ifndef DPNBUILD_ONLYONESP
	m_bilinkServiceProviders.Initialize();
#endif // ! DPNBUILD_ONLYONESP

	pISP = NULL;
	fAddedToProtocol = FALSE;

	m_pdnObject = pdnObject;

	//
	//	Instantiate SP
	//
#ifndef DPNBUILD_ONLYONESP
	if (IsEqualCLSID(*pguid, CLSID_DP8SP_TCPIP))
#endif // ! DPNBUILD_ONLYONESP
	{
		hResultCode = CreateIPInterface(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
										pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
										&pISP
										);
	}
#ifndef DPNBUILD_ONLYONESP
#ifndef DPNBUILD_NOIPX
	else if (IsEqualCLSID(*pguid, CLSID_DP8SP_IPX))
	{
		hResultCode = CreateIPXInterface(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
										pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
										&pISP
										);
	}
#endif // ! DPNBUILD_NOIPX
#ifndef DPNBUILD_NOSERIALSP
	else if (IsEqualCLSID(*pguid, CLSID_DP8SP_MODEM))
	{
		hResultCode = CreateModemInterface(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
										pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
										&pISP
										);
	}
	else if (IsEqualCLSID(*pguid, CLSID_DP8SP_SERIAL))
	{
		hResultCode = CreateSerialInterface(
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
										pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
										&pISP
										);
	}
#endif // ! DPNBUILD_NOSERIALSP
	else
	{
		hResultCode = COM_CoCreateInstance(*pguid,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDP8ServiceProvider,
											reinterpret_cast<void**>(&pISP),
											FALSE);
	}
#endif // ! DPNBUILD_ONLYONESP
	if (hResultCode != S_OK)
	{
		DPFX(DPFPREP,0,"Could not instantiate SP (err = 0x%lx)!",hResultCode);
		hResultCode = DPNERR_DOESNOTEXIST;
		DisplayDNError(0,hResultCode);
		goto Exit;
	}

	//
	//	Add SP to Protocol Layer
	//
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
	DNProtocolAddRef(pdnObject);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP

		//Flags parameter for DNPAddServiceProvider is passed through as the
		//flags parameter in the SPINITIALIZEDATA structure to the SP
		//We pass the session type via it
	DWORD dwFlags;
	if (pdnObject->dwFlags &  DN_OBJECT_FLAG_PEER)
		dwFlags=SP_SESSION_TYPE_PEER;
	else if (pdnObject->dwFlags &  DN_OBJECT_FLAG_CLIENT)
		dwFlags=SP_SESSION_TYPE_CLIENT;
	else
	{
		DNASSERT(pdnObject->dwFlags &  DN_OBJECT_FLAG_SERVER);
		dwFlags=SP_SESSION_TYPE_SERVER;
	}
	hResultCode = DNPAddServiceProvider(m_pdnObject->pdnProtocolData, pISP, 
												&m_hProtocolSPHandle, dwFlags);
	if (hResultCode!= DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not add service provider to protocol");
		DisplayDNError(1,hResultCode);
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
		DNProtocolRelease(pdnObject);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
		goto Failure;
	}

	fAddedToProtocol = TRUE;

#ifndef DPNBUILD_NOMULTICAST
	//
	//	If this is a multicast object, make sure the SP in question supports multicasting.
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_MULTICAST)
	{
		SPGETCAPSDATA	spGetCapsData;
		
		//
		//	Get the SP caps
		//
		memset( &spGetCapsData, 0x00, sizeof( SPGETCAPSDATA ) );
		spGetCapsData.dwSize = sizeof( SPGETCAPSDATA );
		spGetCapsData.hEndpoint = INVALID_HANDLE_VALUE;
		if ((hResultCode = IDP8ServiceProvider_GetCaps( pISP, &spGetCapsData )) != DPN_OK)
		{
			DPFERR("Could not get SP caps");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		//
		//	Check for the multicast support flag.
		//
		if (! (spGetCapsData.dwFlags & DPNSPCAPS_SUPPORTSMULTICAST))
		{
			DPFX(DPFPREP,1,"Service provider does not support multicasting.");
			hResultCode = DPNERR_UNSUPPORTED;
			goto Failure;
		}
	}
#endif // ! DPNBUILD_NOMULTICAST

#ifndef DPNBUILD_LIBINTERFACE
	//
	//	If an application GUID was given, make sure the SP can be used by that app.
	//
	if (pguidApplication != NULL)	// app GUID given
	{
		spAppSupData.pApplicationGuid = pguidApplication;
		spAppSupData.dwFlags = 0;
		if ((hResultCode = IDP8ServiceProvider_IsApplicationSupported(pISP,&spAppSupData)) != DPN_OK)	// SP doesn't support app
		{
			DPFX(DPFPREP,1,"Service provider does not support app (err = 0x%lx).", hResultCode);
			hResultCode = DPNERR_UNSUPPORTED;
			goto Failure;
		}
	}
#endif // ! DPNBUILD_LIBINTERFACE

	IDP8ServiceProvider_AddRef(pISP);
	m_pISP = pISP;
	IDP8ServiceProvider_Release(pISP);
	pISP = NULL;

#ifndef DPNBUILD_ONLYONESP
	m_guid = *pguid;
/*	REMOVE
	// Add to bilink
	AddRef();
	m_bilink.InsertBefore(&m_pdnObject->m_bilinkServiceProviders);
*/
#endif // ! DPNBUILD_ONLYONESP

	hResultCode = DPN_OK;

Exit:
	return(hResultCode);

Failure:

	if (fAddedToProtocol)
	{
		//
		// Ignore failure.
		//
		DNPRemoveServiceProvider(pdnObject->pdnProtocolData,m_hProtocolSPHandle);
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
		DNProtocolRelease(pdnObject);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
	}

	if (pISP)
	{
		IDP8ServiceProvider_Release(pISP);
		pISP = NULL;
	}
	goto Exit;
};


#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONESP)))
#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::Deinitialize"

void CServiceProvider::Deinitialize( void )
#else // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::Release"

void CServiceProvider::Release( void )
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
{
	HRESULT		hResultCode;

#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONESP)))
	DNASSERT(m_lRefCount == 0);
#else // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
	LONG		lRefCount;

	lRefCount = DNInterlockedDecrement(&m_lRefCount);
	DPFX(DPFPREP, 9,"[0x%p] new RefCount [%ld]",this,lRefCount);
	DNASSERT(lRefCount >= 0);
	if (lRefCount == 0)
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
	{
#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONESP)))
		hResultCode = DNPRemoveServiceProvider(m_pdnObject->pdnProtocolData,m_hProtocolSPHandle);
		if (hResultCode != DPN_OK)
#else // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
		CWorkerJob	*pWorkerJob;

		pWorkerJob = NULL;

		if ((hResultCode = WorkerJobNew(m_pdnObject,&pWorkerJob)) == DPN_OK)
		{
			pWorkerJob->SetJobType( WORKER_JOB_REMOVE_SERVICE_PROVIDER );
			DNASSERT( m_hProtocolSPHandle != NULL );
			pWorkerJob->SetRemoveServiceProviderHandle( m_hProtocolSPHandle );

			DNQueueWorkerJob(m_pdnObject,pWorkerJob);
			pWorkerJob = NULL;
		}
		else
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
		{
			DPFERR("Could not remove SP");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
		}
		if (m_pISP)
		{
			IDP8ServiceProvider_Release(m_pISP);
			m_pISP = NULL;
		}

		m_pdnObject = NULL;

		DNFree(this);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::GetInterfaceRef"

HRESULT CServiceProvider::GetInterfaceRef( IDP8ServiceProvider **ppIDP8SP )
{
	DNASSERT( ppIDP8SP != NULL );

	if (m_pISP == NULL)
	{
		return( DPNERR_GENERIC );
	}

	IDP8ServiceProvider_AddRef( m_pISP );
	*ppIDP8SP = m_pISP;

	return( DPN_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\request.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Request.h
 *  Content:    Request Operation Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/18/00	mjn		Created
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	08/05/00	mjn		Added DNProcessFailedRequest()
 *	08/07/00	mjn		Added DNRequestIntegrityCheck(),DNHostCheckIntegrity(),DNProcessCheckIntegrity(),DNHostFixIntegrity()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__REQUEST_H__
#define	__REQUEST_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNRequestCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 const PWSTR pwszName,
							 const DWORD dwNameSize,
							 const PVOID pvData,
							 const DWORD dwDataSize,
							 const DWORD dwGroupFlags,
							 void *const pvGroupContext,
							 void *const pvUserContext,
							 DPNHANDLE *const phAsyncOp,
							 const DWORD dwFlags);

HRESULT DNRequestDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnidGroup,
							  PVOID const pvUserContext,
							  DPNHANDLE *const phAsyncOp,
							  const DWORD dwFlags);

HRESULT DNRequestAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  const DPNID dpnidGroup,
								  const DPNID dpnidPlayer,
								  PVOID const pvUserContext,
								  DPNHANDLE *const phAsyncOp,
								  const DWORD dwFlags);

HRESULT DNRequestDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   const DPNID dpnidGroup,
									   const DPNID dpnidPlayer,
									   PVOID const pvUserContext,
									   DPNHANDLE *const phAsyncOp,
									   const DWORD dwFlags);

HRESULT DNRequestUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							const DPNID dpnid,
							const PWSTR pwszName,
							const DWORD dwNameSize,
							const PVOID pvData,
							const DWORD dwDataSize,
							const DWORD dwInfoFlags,
							PVOID const pvUserContext,
							DPNHANDLE *const phAsyncOp,
							const DWORD dwFlags);

HRESULT DNRequestIntegrityCheck(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidTarget);

HRESULT DNHostProcessRequest(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 PVOID const pv,
							 const DPNID dpnidRequesting);

void DNHostFailRequest(DIRECTNETOBJECT *const pdnObject,
					   const DPNID dpnid,
					   const DPNHANDLE hCompletionOp,
					   const HRESULT hr);

HRESULT	DNHostCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  PWSTR pwszName,
						  const DWORD dwNameSize,
						  void *const pvData,
						  const DWORD dwDataSize,
						  const DWORD dwInfoFlags,
						  const DWORD dwGroupFlags,
						  void *const pvGroupContext,
						  void *const pvUserContext,
						  const DPNID dpnidOwner,
						  const DPNHANDLE hCompletionOp,
						  DPNHANDLE *const phAsyncOp,
						  const DWORD dwFlags);

HRESULT	DNHostDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnid,
						   void *const pvUserContext,
						   const DPNID dpnidRequesting,
						   const DPNHANDLE hCompletionOp,
						   DPNHANDLE *const phAsyncOp,
						   const DWORD dwFlags);

HRESULT	DNHostAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnidGroup,
							   const DPNID dpnidPlayer,
							   void *const pvUserContext,
							   const DPNID dpnidRequesting,
							   const DPNHANDLE hCompletionOp,
							   DPNHANDLE *const phAsyncOp,
							   const DWORD dwFlags);

HRESULT	DNHostDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									const DPNID dpnidGroup,
									const DPNID dpnidPlayer,
									void *const pvUserContext,
									const DPNID dpnidRequesting,
									const DPNHANDLE hCompletionOp,
									DPNHANDLE *const phAsyncOp,
									const DWORD dwFlags);

HRESULT	DNHostUpdateInfo(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 PWSTR pwszName,
						 const DWORD dwNameSize,
						 void *const pvData,
						 const DWORD dwDataSize,
						 const DWORD dwInfoFlags,
						 void *const pvUserContext,
						 const DPNID dpnidRequesting,
						 const DPNHANDLE hCompletionOp,
						 DPNHANDLE *const phAsyncOp,
						 const DWORD dwFlags);

HRESULT	DNHostCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnidTarget,
							 const DPNID dpnidRequesting);

HRESULT	DNHostFixIntegrity(DIRECTNETOBJECT *const pdnObject,
						   void *const pvBuffer);

HRESULT	DNProcessCreateGroup(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer);

HRESULT	DNProcessDestroyGroup(DIRECTNETOBJECT *const pdnObject,
							  void *const pvBuffer);

HRESULT	DNProcessAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer);

HRESULT	DNProcessDeletePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									   void *const pvBuffer);

HRESULT	DNProcessUpdateInfo(DIRECTNETOBJECT *const pdnObject,
							void *const pvBuffer);

HRESULT DNProcessFailedRequest(DIRECTNETOBJECT *const pdnObject,
							   void *const pvBuffer);

HRESULT	DNProcessCheckIntegrity(DIRECTNETOBJECT *const pdnObject,
								void *const pvBuffer);


//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __REQUEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\servprov.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ServProv.h
 *  Content:    Service Provider Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/17/00	mjn		Created
 *	05/02/00	mjn		Fixed RefCount issue
 *	07/06/00	mjn		Fixes to support SP handle to Protocol
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/20/00	mjn		Changed m_bilink to m_bilinkServiceProviders
 *	10/15/01	vanceo	Added GetGUID
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SERV_PROV_H__
#define	__SERV_PROV_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;
typedef struct IDP8ServiceProvider	IDP8ServiceProvider;				// DPSP8.h

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for ServiceProvider objects

class CServiceProvider
{
public:
	CServiceProvider()		// Constructor
		{
		};

	~CServiceProvider()		// Destructor
		{
		};

	HRESULT Initialize(DIRECTNETOBJECT *const pdnObject
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
					,const XDP8CREATE_PARAMS * const pDP8CreateParams
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
#ifndef DPNBUILD_ONLYONESP
					,const GUID *const pguid
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_LIBINTERFACE
					,const GUID *const pguidApplication
#endif // ! DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
					);

#undef DPF_MODNAME
#define DPF_MODNAME "CServiceProvider::AddRef"

	void AddRef( void )
		{
			LONG	lRefCount;

#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONESP)))
			DNASSERT(m_lRefCount >= 0);
#else // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
			DNASSERT(m_lRefCount > 0);
#endif // DPNBUILD_LIBINTERFACE and DPNBUILD_ONLYONESP
			DNASSERT(m_pdnObject != NULL);

			lRefCount = DNInterlockedIncrement(&m_lRefCount);
			DPFX(DPFPREP, 9,"[0x%p] new RefCount [%ld]",this,lRefCount);

#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONESP)))
			DNProtocolAddRef(m_pdnObject);
#endif // DPNBUILD_LIBINTERFACE and DPNBUILD_ONLYONESP
		};

#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONESP)))
	void Deinitialize( void );

	void Release( void )
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			DNASSERT(m_pdnObject != NULL);

			lRefCount = DNInterlockedDecrement(&m_lRefCount);
			DPFX(DPFPREP, 9,"[0x%p] new RefCount [%ld]",this,lRefCount);

			DNProtocolRelease(m_pdnObject);
		};
#else // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
	void Release( void );
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP

#ifndef DPNBUILD_ONLYONESP
	BOOL CheckGUID( const GUID *const pGUID )
		{
			if (m_guid == *pGUID)
				return(TRUE);

			return(FALSE);
		};

	void GetGUID( GUID *const pGUID )
		{
			memcpy(pGUID, &m_guid, sizeof(m_guid));
		};
#endif // ! DPNBUILD_ONLYONESP

	HRESULT GetInterfaceRef( IDP8ServiceProvider **ppIDP8SP );

	HANDLE GetHandle( void )
		{
			return( m_hProtocolSPHandle );
		};

#ifndef DPNBUILD_ONLYONESP
	CBilink		m_bilinkServiceProviders;
#endif // ! DPNBUILD_ONLYONESP

private:
#ifndef DPNBUILD_ONLYONESP
	GUID				m_guid;
#endif // ! DPNBUILD_ONLYONESP
	LONG				m_lRefCount;
	IDP8ServiceProvider	*m_pISP;
	HANDLE				m_hProtocolSPHandle;
	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __SERV_PROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\sources.inc ===
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dncorei.h
PRECOMPILED_PCH=dncorei.pch
PRECOMPILED_OBJ=dncorei.obj

INCLUDES=..\;..\..\inc;..\..\protocol;..\..\common;..\..\dpnsvr\dpnsvlib;..\..\dnaddress;..\..\lobby;..\..\sp\wsock;..\..\sp\serial;..\..\sp\bluetooth;..\..\..\dvoice\inc;..\..\threadpool;$(DXROOT)\inc;;$(SDK_INC_PATH)

SOURCES= appdesc.cpp \
	 async.cpp \
	 asyncop.cpp \
	 cancel.cpp \
	 caps.cpp \
	 client.cpp \
	 common.cpp \
	 connection.cpp \
	 coreclassfac.cpp \
	 coreconnect.cpp \
	 corepools.cpp \
	 corereceive.cpp \
	 corevoice.cpp \
	 disconnect.cpp \
	 coredllmain.cpp \
	 enum_sp.cpp \
	 enumhosts.cpp \
	 globals.cpp \
	 groupcon.cpp \
	 groupmem.cpp \
         mcast.cpp \
	 memoryfpm.cpp \
	 migration.cpp \
	 msghandler.cpp \
	 nametable.cpp \
	 ntentry.cpp \
	 ntoplist.cpp \
	 paramval.cpp \
	 peer.cpp \
	 protocol.cpp \
	 queuedmsg.cpp \
	 request.cpp \
	 server.cpp \
	 servprov.cpp \
	 spmessages.cpp \
	 user.cpp \
	 verify.cpp \
	 worker.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\spmessages.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPMessages.h
 *  Content:    Direct SP callback interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/08/99	jtk		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SPMESSAGES_H__
#define	__SPMESSAGES_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// VTable for SPMessage callback functions
//
extern	IDP8SPCallbackVtbl SPMessagesVtbl;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#endif	// __SPMESSAGES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\spmessages.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPMessages.cpp
 *  Content:    Direct SP callback interface .CPP file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/08/99	jtk		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

static	STDMETHODIMP	SPQueryInterface(IDP8SPCallback *pInterface,REFIID riid,LPVOID *ppvObj);
static	STDMETHODIMP_(ULONG)	SPAddRef(IDP8SPCallback *pInterface);
static	STDMETHODIMP_(ULONG)	SPRelease(IDP8SPCallback *pInterface);
static	STDMETHODIMP	SPIndicateEvent(IDP8SPCallback *pInterface,SP_EVENT_TYPE dwEvent, LPVOID pParam);
static	STDMETHODIMP	SPCommandComplete(IDP8SPCallback *pInterface,HANDLE hCommand, HRESULT hResult, void *pContext);

//
// VTable for SPMessages interface
//
IDP8SPCallbackVtbl SPMessagesVtbl =
{
	SPQueryInterface,
	SPAddRef,
	SPRelease,
	SPIndicateEvent,
	SPCommandComplete
};

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "SPQueryInterface"
static	STDMETHODIMP	SPQueryInterface(IDP8SPCallback *pInterface,REFIID riid,LPVOID *ppvObj)
{
	DNASSERT(FALSE);

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPAddRef"
static	STDMETHODIMP_(ULONG)	SPAddRef(IDP8SPCallback *pInterface)
{
//	DNASSERT(FALSE);

	return(0);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPRelease"
static	STDMETHODIMP_(ULONG)	SPRelease(IDP8SPCallback *pInterface)
{
//	DNASSERT(FALSE);

	return(0);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPIndicateEvent"
static	STDMETHODIMP	SPIndicateEvent(IDP8SPCallback *pInterface,SP_EVENT_TYPE dwEvent, LPVOID pParam)
{
	DNASSERT(FALSE);

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SPCommandComplete"
static	STDMETHODIMP	SPCommandComplete(IDP8SPCallback *pInterface,HANDLE hCommand, HRESULT hResult, void *pContext )
{
	DNASSERT(FALSE);

	return(DPN_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\user.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       User.cpp
 *  Content:    DNET user call-back routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/02/99	mjn		Created
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Allow reply in DN_UserIndicateConnect
 *	01/08/00	mjn		DN_UserIndicateConnect provides failed buffer back to DN_UserConnectComplete
 *	01/10/00	mjn		Added DN_UserUpdateAppDesc
 *	01/16/00	mjn		Upgraded to new UserMessageHandler definition
 *	01/17/00	mjn		Added DN_UserHostMigrate
 *	01/17/00	mjn		Implemented send time
 *  01/18/00	rmt		Added calls into voice layer for events
 *	01/22/00	mjn		Added DN_UserHostDestroyPlayer
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	01/28/00	mjn		Added DN_UserConnectionTerminated
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/01/00	mjn		Implement Player/Group context values
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/04/00	mjn		Added DN_UserTerminateSession()
 *	04/05/00	mjn		Updated DN_UserHostDestroyPlayer()
 *	04/18/00	mjn		Added DN_UserReturnBuffer
 *				mjn		Added ppvReplyContext to DN_UserIndicateConnect
 *	04/19/00	mjn		Removed hAsyncOp (unused) from DPNMSG_INDICATE_CONNECT
 *	06/26/00	mjn		Added reasons for DELETE_PLAYER and DESTROY_GROUP
 *	07/29/00	mjn		Added DNUserIndicatedConnectAborted()
 *				mjn		DNUserConnectionTerminated() supercedes DN_TerminateSession()
 *				mjn		Added HRESULT to DNUserReturnBuffer()
 *	07/30/00	mjn		Added pAddressDevice to DNUserIndicateConnect()
 *				mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		DN_UserDestroyGroup() -> DNUserDestroyGroup()
 *				mjn		DN_UserDeletePlayer() -> DNUserDestroyPlayer()
 *				mjn		Removed DN_UserHostDestroyPlayer()
 *				mjn		Renamed DPN_MSGID_ASYNC_OPERATION_COMPLETE to DPN_MSGID_ASYNC_OP_COMPLETE
 *	08/01/00	mjn		DN_UserReceive() -> DNUserReceive()
 *	08/02/00	mjn		DN_UserAddPlayer() -> DNUserCreatePlayer()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/08/00	mjn		DN_UserCreateGroup() -> DNUserCreateGroup()
 *	08/20/00	mjn		Added DNUserEnumQuery() and DNUserEnumResponse()
 *	09/17/00	mjn		Changed parameters list of DNUserCreateGroup(),DNUserCreatePlayer(),
 *						DNUserAddPlayerToGroup(),DNUserRemovePlayerFromGroup()
 *	02/05/01	mjn		Added CCallbackThread
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *	10/16/01	vanceo		Added some multicast callbacks
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


// DNUserConnectComplete
//
//	Send a CONNECT_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserConnectComplete"

HRESULT DNUserConnectComplete(DIRECTNETOBJECT *const pdnObject,
							  const DPNHANDLE hAsyncOp,
							  PVOID const pvContext,
							  const HRESULT hr,
							  CRefCountBuffer *const pRefCountBuffer)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT			hResultCode;
	DPNMSG_CONNECT_COMPLETE	Msg;
	CNameTableEntry	*pLocalPlayer = NULL;

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	DPFX(DPFPREP, 6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx], pRefCountBuffer [0x%p]",
		hAsyncOp,pvContext,hr,pRefCountBuffer);
	
	Msg.dwSize = sizeof(DPNMSG_CONNECT_COMPLETE);
	Msg.pvUserContext = pvContext;
	Msg.hAsyncOp = hAsyncOp;
	Msg.hResultCode = hr;
	if (pRefCountBuffer)
	{
		Msg.pvApplicationReplyData = pRefCountBuffer->GetBufferAddress();
		Msg.dwApplicationReplyDataSize = pRefCountBuffer->GetBufferSize();
	}
	else
	{
		Msg.pvApplicationReplyData = NULL;
		Msg.dwApplicationReplyDataSize = 0;
	}
	if (pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer) == DPN_OK)
	{
		Msg.dpnidLocal = pLocalPlayer->GetDPNID();
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		Msg.dpnidLocal = 0;
	}

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CONNECT_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DNASSERT( pLocalPlayer == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserIndicateConnect
//
//	Send an INDICATE_CONNECT message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserIndicateConnect"

HRESULT DNUserIndicateConnect(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvConnectData,
							  const DWORD dwConnectDataSize,
							  void **const ppvReplyData,
							  DWORD *const pdwReplyDataSize,
							  void **const ppvReplyContext,
							  IDirectPlay8Address *const pAddressPlayer,
							  IDirectPlay8Address *const pAddressDevice,
							  void **const ppvPlayerContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT			hResultCode;
	DPNMSG_INDICATE_CONNECT	Msg;

	DPFX(DPFPREP, 6,"Parameters: pvConnectData [0x%p], dwConnectDataSize [%ld], ppvReplyData [0x%p], pdwReplyDataSize [0x%p]",
		pvConnectData,dwConnectDataSize,ppvReplyData,pdwReplyDataSize);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(ppvReplyData != NULL);
	DNASSERT(pdwReplyDataSize != NULL);

	Msg.dwSize = sizeof(DPNMSG_INDICATE_CONNECT);
	Msg.pvUserConnectData = pvConnectData;
	Msg.dwUserConnectDataSize = dwConnectDataSize;
	Msg.pvReplyData = NULL;
	Msg.dwReplyDataSize = 0;
	Msg.pvReplyContext = NULL;
	Msg.pvPlayerContext = NULL;
	Msg.pAddressPlayer = pAddressPlayer;
	Msg.pAddressDevice = pAddressDevice;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_INDICATE_CONNECT,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	*ppvReplyData = Msg.pvReplyData;
	*pdwReplyDataSize = Msg.dwReplyDataSize;
	*ppvReplyContext = Msg.pvReplyContext;
	*ppvPlayerContext = Msg.pvPlayerContext;

	if (hResultCode != DPN_OK)
	{
		hResultCode = DPNERR_HOSTREJECTEDCONNECTION;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserIndicatedConnectAborted
//
//	Send an INDICATED_CONNECT_ABORTED message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserIndicatedConnectAborted"

HRESULT DNUserIndicatedConnectAborted(DIRECTNETOBJECT *const pdnObject,
									  void *const pvPlayerContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT			hResultCode;
	DPNMSG_INDICATED_CONNECT_ABORTED	Msg;

	DPFX(DPFPREP, 6,"Parameters: pvPlayerContext [0x%p]",pvPlayerContext);

	DNASSERT(pdnObject != NULL);

	Msg.dwSize = sizeof(DPNMSG_INDICATED_CONNECT_ABORTED);
	Msg.pvPlayerContext = pvPlayerContext;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_INDICATED_CONNECT_ABORTED,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNUserCreatePlayer
//
//	Send a CREATE_PLAYER message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserCreatePlayer"

HRESULT DNUserCreatePlayer(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_CREATE_PLAYER	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	
#ifndef DPNBUILD_NOVOICE
	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, pNTEntry->GetDPNID(), 0 );
#endif // !DPNBUILD_NOVOICE

	Msg.dwSize = sizeof(DPNMSG_CREATE_PLAYER);
	Msg.dpnidPlayer = pNTEntry->GetDPNID();
	Msg.pvPlayerContext = pNTEntry->GetContext();

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CREATE_PLAYER,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	//
	//	Save context value on NameTableEntry
	//
	pNTEntry->Lock();
	pNTEntry->SetContext( Msg.pvPlayerContext );
	pNTEntry->SetCreated();
	pNTEntry->Unlock();

	pNTEntry->NotifyRelease();

	DPFX(DPFPREP, 7,"Set context [0x%p]",pNTEntry->GetContext());

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserDestroyPlayer
//
//	Send a DESTROY_PLAYER message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserDestroyPlayer"

HRESULT DNUserDestroyPlayer(DIRECTNETOBJECT *const pdnObject,
							CNameTableEntry *const pNTEntry)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_DESTROY_PLAYER	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pNTEntry != NULL);
	DNASSERT(pNTEntry->GetDPNID() != 0);
	DNASSERT(pNTEntry->GetDestroyReason() != 0);

#ifndef DPNBUILD_NOVOICE
	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, pNTEntry->GetDPNID(), 0 );
#endif // !DPNBUILD_NOVOICE

	Msg.dwSize = sizeof(DPNMSG_DESTROY_PLAYER);
	Msg.dpnidPlayer = pNTEntry->GetDPNID();
	Msg.pvPlayerContext = pNTEntry->GetContext();
	Msg.dwReason = pNTEntry->GetDestroyReason();

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_DESTROY_PLAYER,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserCreateGroup
//
//	Send an CREATE_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserCreateGroup"

HRESULT DNUserCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_CREATE_GROUP	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

#ifndef DPNBUILD_NOVOICE
	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, pNTEntry->GetDPNID(), 0 );
#endif // !DPNBUILD_NOVOICE

	Msg.dwSize = sizeof(DPNMSG_CREATE_GROUP);
	Msg.dpnidGroup = pNTEntry->GetDPNID();
	if (pNTEntry->IsAutoDestructGroup())
	{
		CNameTableEntry	*pOwner = NULL;

		Msg.dpnidOwner = pNTEntry->GetOwner();

		if (pdnObject->NameTable.FindEntry(pNTEntry->GetOwner(),&pOwner) == DPN_OK)
		{
			Msg.pvOwnerContext = pOwner->GetContext();

			pOwner->Release();
			pOwner = NULL;
		}

		DNASSERT( pOwner == NULL );
	}
	else
	{
		Msg.dpnidOwner = 0;
	}
	Msg.pvGroupContext = pNTEntry->GetContext();

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CREATE_GROUP,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	//
	//	Save context value on NameTableEntry
	//
	pNTEntry->Lock();
	pNTEntry->SetContext( Msg.pvGroupContext );
	pNTEntry->SetCreated();
	pNTEntry->Unlock();

	pNTEntry->NotifyRelease();

	DPFX(DPFPREP, 7,"Set context [0x%p]",pNTEntry->GetContext());

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserDestroyGroup
//
//	Send a DESTROY_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserDestroyGroup"

HRESULT DNUserDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_DESTROY_GROUP	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p]",pNTEntry);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pNTEntry != NULL);
	DNASSERT(pNTEntry->GetDPNID() != 0);
	DNASSERT(pNTEntry->GetDestroyReason() != 0);

#ifndef DPNBUILD_NOVOICE
	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, pNTEntry->GetDPNID(), 0 );
#endif // !DPNBUILD_NOVOICE

	Msg.dwSize = sizeof(DPNMSG_DESTROY_GROUP);
	Msg.dpnidGroup = pNTEntry->GetDPNID();
	Msg.pvGroupContext = pNTEntry->GetContext();
	Msg.dwReason = pNTEntry->GetDestroyReason();

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_DESTROY_GROUP,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserAddPlayerToGroup
//
//	Send an ADD_PLAYER_TO_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserAddPlayerToGroup"

HRESULT DNUserAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   CNameTableEntry *const pGroup,
							   CNameTableEntry *const pPlayer)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT		hResultCode;
	DPNMSG_ADD_PLAYER_TO_GROUP	Msg;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p], pPlayer [0x%p]",pGroup,pPlayer);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

#ifndef DPNBUILD_NOVOICE
	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, pGroup->GetDPNID(), pPlayer->GetDPNID() );
#endif // !DPNBUILD_NOVOICE

	Msg.dwSize = sizeof(DPNMSG_ADD_PLAYER_TO_GROUP);
	Msg.dpnidGroup = pGroup->GetDPNID();
	Msg.pvGroupContext = pGroup->GetContext();
	Msg.dpnidPlayer = pPlayer->GetDPNID();
	Msg.pvPlayerContext = pPlayer->GetContext();

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_ADD_PLAYER_TO_GROUP,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserRemovePlayerFromGroup
//
//	Send a REMOVE_PLAYER_FROM_GROUP message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserRemovePlayerFromGroup"

HRESULT DNUserRemovePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									CNameTableEntry *const pGroup,
									CNameTableEntry *const pPlayer)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT		hResultCode;
	DPNMSG_REMOVE_PLAYER_FROM_GROUP	Msg;

	DPFX(DPFPREP, 6,"Parameters: pGroup [0x%p], pPlayer [0x%p]",pGroup,pPlayer);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

#ifndef DPNBUILD_NOVOICE
	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, pGroup->GetDPNID(), pPlayer->GetDPNID());
#endif // !DPNBUILD_NOVOICE

	Msg.dwSize = sizeof(DPNMSG_REMOVE_PLAYER_FROM_GROUP);
	Msg.dpnidGroup = pGroup->GetDPNID();
	Msg.pvGroupContext = pGroup->GetContext();
	Msg.dpnidPlayer = pPlayer->GetDPNID();
	Msg.pvPlayerContext = pPlayer->GetContext();

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_REMOVE_PLAYER_FROM_GROUP,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateGroupInfo"

HRESULT DNUserUpdateGroupInfo(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid,
							  const PVOID pvContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_GROUP_INFO	MsgGroupInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgGroupInfo.dwSize = sizeof(DPNMSG_GROUP_INFO);
	MsgGroupInfo.dpnidGroup = dpnid;
	MsgGroupInfo.pvGroupContext = pvContext;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_GROUP_INFO,reinterpret_cast<BYTE*>(&MsgGroupInfo));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdatePeerInfo"

HRESULT DNUserUpdatePeerInfo(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnid,
							 const PVOID pvContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_PEER_INFO	MsgPeerInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgPeerInfo.dwSize = sizeof(DPNMSG_PEER_INFO);
	MsgPeerInfo.dpnidPeer = dpnid;
	MsgPeerInfo.pvPlayerContext = pvContext;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_PEER_INFO,reinterpret_cast<BYTE*>(&MsgPeerInfo));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#ifndef	DPNBUILD_NOSERVER

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateClientInfo"

HRESULT DNUserUpdateClientInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_CLIENT_INFO	MsgClientInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgClientInfo.dwSize = sizeof(DPNMSG_CLIENT_INFO);
	MsgClientInfo.dpnidClient = dpnid;
	MsgClientInfo.pvPlayerContext = pvContext;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CLIENT_INFO,reinterpret_cast<BYTE*>(&MsgClientInfo));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
#endif	// DPNBUILD_NOSERVER


#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateServerInfo"

HRESULT DNUserUpdateServerInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_SERVER_INFO	MsgServerInfo;

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%lx], pvContext [0x%p]",dpnid,pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	MsgServerInfo.dwSize = sizeof(DPNMSG_SERVER_INFO);
	MsgServerInfo.dpnidServer = dpnid;
	MsgServerInfo.pvPlayerContext = pvContext;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_SERVER_INFO,reinterpret_cast<BYTE*>(&MsgServerInfo));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserAsyncComplete
//
//	Send a DN_MSGID_ASYNC_OPERATION_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserAsyncComplete"

HRESULT DNUserAsyncComplete(DIRECTNETOBJECT *const pdnObject,
							const DPNHANDLE hAsyncOp,
							PVOID const pvContext,
							const HRESULT hr)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT			hResultCode;
	DPNMSG_ASYNC_OP_COMPLETE	Msg;

	DPFX(DPFPREP, 6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx]",hAsyncOp,pvContext,hr);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_ASYNC_OP_COMPLETE);
	Msg.hAsyncOp = hAsyncOp;
	Msg.pvUserContext = pvContext;
	Msg.hResultCode = hr;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_ASYNC_OP_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserSendComplete
//
//	Send a DN_MSGID_SEND_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserSendComplete"

HRESULT DNUserSendComplete(DIRECTNETOBJECT *const pdnObject,
						   const DPNHANDLE hAsyncOp,
						   PVOID const pvContext,
						   const DWORD dwStartTime,
						   const HRESULT hr,
						   const DWORD dwFirstFrameRTT,
						   const DWORD dwFirstFrameRetryCount)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_SEND_COMPLETE	Msg;
	DWORD				dwEndTime;

	DPFX(DPFPREP, 6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx]",hAsyncOp,pvContext,hr);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_SEND_COMPLETE);
	Msg.hAsyncOp = hAsyncOp;
	Msg.pvUserContext = pvContext;
	Msg.hResultCode = hr;
	dwEndTime = GETTIMESTAMP();
	Msg.dwSendTime = dwEndTime - dwStartTime;
	Msg.dwFirstFrameRTT = dwFirstFrameRTT;
	Msg.dwFirstFrameRetryCount = dwFirstFrameRetryCount;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_SEND_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserUpdateAppDesc
//
//	Send a DN_MSGID_APPLICATION_DESC message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserUpdateAppDesc"

HRESULT DNUserUpdateAppDesc(DIRECTNETOBJECT *const pdnObject)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT			hResultCode;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_APPLICATION_DESC,NULL);

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserReceive
//
//	Send a DN_MSGID_RECEIVE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserReceive"

HRESULT DNUserReceive(DIRECTNETOBJECT *const pdnObject,
					  CNameTableEntry *const pNTEntry,
					  BYTE *const pBufferData,
					  const DWORD dwBufferSize,
					  const DPNHANDLE hBufferHandle)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT			hResultCode;
	DPNMSG_RECEIVE	Msg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p], pBufferData [0x%p], dwBufferSize [%ld], hBufferHandle [0x%lx]",
			pNTEntry,pBufferData,dwBufferSize,hBufferHandle);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);
	DNASSERT(pNTEntry != NULL);

	Msg.dwSize = sizeof(DPNMSG_RECEIVE);
	Msg.pReceiveData = pBufferData;
	Msg.dwReceiveDataSize = dwBufferSize;
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		Msg.dpnidSender = 0;
	}
	else
	{
		Msg.dpnidSender = pNTEntry->GetDPNID();
	}
	Msg.pvPlayerContext = pNTEntry->GetContext();
	Msg.hBufferHandle = hBufferHandle;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_RECEIVE,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	if (hResultCode != DPNERR_PENDING)
	{
		hResultCode = DPN_OK;
	}

	pNTEntry->NotifyRelease();

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DN_UserHostMigrate
//
//	Send a DN_MSGID_HOST_MIGRATE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DN_UserHostMigrate"

HRESULT DN_UserHostMigrate(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnidNewHost,
						   const PVOID pvPlayerContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_HOST_MIGRATE	Msg;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

#ifndef DPNBUILD_NOVOICE
	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
#endif // !DPNBUILD_NOVOICE

	Msg.dwSize = sizeof(DPNMSG_HOST_MIGRATE);
	Msg.dpnidNewHost = dpnidNewHost;
	Msg.pvPlayerContext = pvPlayerContext;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_HOST_MIGRATE,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserTerminateSession
//
//	Send a DN_MSGID_CONNECTION_TERMINATED message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserTerminateSession"

HRESULT DNUserTerminateSession(DIRECTNETOBJECT *const pdnObject,
							   const HRESULT hr,
							   void *const pvTerminateData,
							   const DWORD dwTerminateDataSize)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT			hResultCode;
	DPNMSG_TERMINATE_SESSION	Msg;

	DPFX(DPFPREP, 6,"Parameters: hr [0x%lx],pvTerminateData [0x%p], dwTerminateDataSize [%ld]",
			hr,pvTerminateData,dwTerminateDataSize);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_TERMINATE_SESSION);
	Msg.hResultCode = hr;
	Msg.pvTerminateData = pvTerminateData;
	Msg.dwTerminateDataSize = dwTerminateDataSize;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_TERMINATE_SESSION,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserReturnBuffer
//
//	Send a DPN_MSGID_RETURN_BUFFER message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserReturnBuffer"

HRESULT DNUserReturnBuffer(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hr,
						   void *const pvBuffer,
						   void *const pvUserContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT					hResultCode;
	DPNMSG_RETURN_BUFFER	Msg;

	DPFX(DPFPREP, 6,"Parameters: hr [0x%lx], pvBuffer [0x%p], pvUserContext [0x%p]",hr,pvBuffer,pvUserContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_RETURN_BUFFER);
	Msg.hResultCode = hr;
	Msg.pvBuffer = pvBuffer;
	Msg.pvUserContext = pvUserContext;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_RETURN_BUFFER,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserEnumQuery
//
//	Send a DPN_MSGID_ENUM_QUERY message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserEnumQuery"

HRESULT DNUserEnumQuery(DIRECTNETOBJECT *const pdnObject,
						DPNMSG_ENUM_HOSTS_QUERY *const pMsg)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_ENUM_HOSTS_QUERY,reinterpret_cast<BYTE*>(pMsg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserEnumResponse
//
//	Send a DPN_MSGID_ENUM_RESPONSE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserEnumResponse"

HRESULT DNUserEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   DPNMSG_ENUM_HOSTS_RESPONSE *const pMsg)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_ENUM_HOSTS_RESPONSE,reinterpret_cast<BYTE*>(pMsg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#ifndef DPNBUILD_NOMULTICAST


// DNUserJoinComplete
//
//	Send a JOIN_COMPLETE message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserJoinComplete"

HRESULT DNUserJoinComplete(DIRECTNETOBJECT *const pdnObject,
							  const DPNHANDLE hAsyncOp,
							  PVOID const pvContext,
							  const HRESULT hr)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT			hResultCode;
	DPNMSG_JOIN_COMPLETE	Msg;

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	DPFX(DPFPREP, 6,"Parameters: hAsyncOp [0x%lx], pvContext [0x%p], hr [0x%lx]",
		hAsyncOp,pvContext,hr);

	Msg.dwSize = sizeof(DPNMSG_JOIN_COMPLETE);
	Msg.hAsyncOp = hAsyncOp;
	Msg.pvUserContext = pvContext;
	Msg.hResultCode = hr;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_JOIN_COMPLETE,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Deinitialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserReceiveMulticast
//
//	Send a DN_MSGID_RECEIVE_MULTICAST message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserReceiveMulticast"

HRESULT DNUserReceiveMulticast(DIRECTNETOBJECT *const pdnObject,
										void * const pvSenderContext,
										IDirectPlay8Address *const pSenderAddress,
										IDirectPlay8Address *const pDeviceAddress,
										BYTE *const pBufferData,
										const DWORD dwBufferSize,
										const DPNHANDLE hBufferHandle)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread				CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT						hResultCode;
	DPNMSG_RECEIVE_MULTICAST	Msg;

	DPFX(DPFPREP, 6,"Parameters: pvSenderContext [0x%p], pSenderAddress [0x%p], pDeviceAddress [0x%p], pBufferData [0x%p], dwBufferSize [%ld], hBufferHandle [0x%lx]",
			pvSenderContext,pSenderAddress,pDeviceAddress,pBufferData,dwBufferSize,hBufferHandle);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_RECEIVE_MULTICAST);
	Msg.pvSenderContext = pvSenderContext;
	Msg.pAddressSender = pSenderAddress;
	Msg.pAddressDevice = pDeviceAddress;
	Msg.pReceiveData = pBufferData;
	Msg.dwReceiveDataSize = dwBufferSize;
	Msg.hBufferHandle = hBufferHandle;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
			DPN_MSGID_RECEIVE_MULTICAST,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	if (hResultCode != DPNERR_PENDING)
	{
		hResultCode = DPN_OK;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

//	DNUserCreateSenderContext
//
//	Send a CREATE_SENDER_CONTEXT message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserCreateSenderContext"

HRESULT DNUserCreateSenderContext(DIRECTNETOBJECT *const pdnObject,
								  void *const pvContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_CREATE_SENDER_CONTEXT	Msg;

	DPFX(DPFPREP, 6,"Parameters: pvContext [0x%p]",pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_CREATE_SENDER_CONTEXT);
	Msg.pvSenderContext = pvContext;

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_CREATE_SENDER_CONTEXT,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// DNUserDestroySenderContext
//
//	Send a DESTROY_SENDER_CONTEXT message to the user's message handler

#undef DPF_MODNAME
#define DPF_MODNAME "DNUserDestroySenderContext"

HRESULT DNUserDestroySenderContext(DIRECTNETOBJECT *const pdnObject,
								   void *const pvContext)
{
#ifndef DPNBUILD_NOPARAMVAL
	CCallbackThread	CallbackThread;
#endif // ! DPNBUILD_NOPARAMVAL
	HRESULT				hResultCode;
	DPNMSG_DESTROY_SENDER_CONTEXT	Msg;

	DPFX(DPFPREP, 6,"Parameters: pvContext [0x%p]",pvContext);

	// ensure initialized (need message handler)
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED);

	Msg.dwSize = sizeof(DPNMSG_DESTROY_SENDER_CONTEXT);
	Msg.pvSenderContext = pvContext;
	//Msg.dwReason = pNTEntry->GetDestroyReason();

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		CallbackThread.Initialize();
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->InsertBefore(&pdnObject->m_bilinkCallbackThreads);
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = (pdnObject->pfnDnUserMessageHandler)(pdnObject->pvUserContext,
		DPN_MSGID_DESTROY_SENDER_CONTEXT,reinterpret_cast<BYTE*>(&Msg));

#ifndef DPNBUILD_NOPARAMVAL
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION)
	{
		DNEnterCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.GetCallbackThreadsBilink()->RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
		CallbackThread.Deinitialize();
	}
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

#endif // ! DPNBUILD_NOMULTICAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\verify.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Verify.cpp
 *  Content:    On-wire message verification
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/05/00	mjn		Created
 *	05/11/01	mjn		Ensure buffers are valid (not NULL) instead of just ASSERTing
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyApplicationDescInfo"

HRESULT DNVerifyApplicationDescInfo(void *const pOpBuffer,
									const DWORD dwOpBufferSize,
									void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DPN_APPLICATION_DESC_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	DNASSERT(pData != NULL);

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DPN_APPLICATION_DESC_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Application Description buffer is too small");
		goto Failure;
	}

	pInfo = static_cast<DPN_APPLICATION_DESC_INFO*>(pData);

	if (pInfo->dwSessionNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid session name offset");
		goto Failure;
	}
	if (pInfo->dwSessionNameOffset + pInfo->dwSessionNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid session name size");
		goto Failure;
	}

	if (pInfo->dwPasswordOffset > dwOpBufferSize)
	{
		DPFERR("Invalid password offset");
		goto Failure;
	}
	if (pInfo->dwPasswordOffset + pInfo->dwPasswordSize > dwOpBufferSize)
	{
		DPFERR("Invalid password size");
		goto Failure;
	}

	if (pInfo->dwReservedDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid reserved data offset");
		goto Failure;
	}
	if (pInfo->dwReservedDataOffset + pInfo->dwReservedDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid reserved data size");
		goto Failure;
	}

	if (pInfo->dwApplicationReservedDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid application reserved data offset");
		goto Failure;
	}
	if (pInfo->dwApplicationReservedDataOffset + pInfo->dwApplicationReservedDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid application reserved data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyNameTableEntryInfo"

HRESULT DNVerifyNameTableEntryInfo(void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_NAMETABLE_ENTRY_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	DNASSERT(pData != NULL);

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_NAMETABLE_ENTRY_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("NameTable Entry buffer is too small");
		goto Failure;
	}
	
	pInfo = static_cast<DN_NAMETABLE_ENTRY_INFO*>(pData);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	if (pInfo->dwURLOffset > dwOpBufferSize)
	{
		DPFERR("Invalid URL offset");
		goto Failure;
	}
	if (pInfo->dwURLOffset + pInfo->dwURLSize > dwOpBufferSize)
	{
		DPFERR("Invalid URL size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyNameTableInfo"

HRESULT DNVerifyNameTableInfo(void *const pOpBuffer,
							  const DWORD dwOpBufferSize,
							  void *const pData)
{
	HRESULT		hResultCode;
	DWORD		dw;
	UNALIGNED DN_NAMETABLE_INFO	*pInfo;
	UNALIGNED DN_NAMETABLE_ENTRY_INFO	*pNTEntryInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	DNASSERT(pOpBuffer != NULL);
	DNASSERT(pData != NULL);

	if (static_cast<BYTE*>(pData) + sizeof(DN_NAMETABLE_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("NameTable buffer is too small");
		goto Failure;
	}
	
	pInfo = static_cast<DN_NAMETABLE_INFO*>(pData);

	if (	reinterpret_cast<BYTE*>(pInfo+1) +
			(pInfo->dwEntryCount * sizeof(DN_NAMETABLE_ENTRY_INFO)) +
			(pInfo->dwMembershipCount * sizeof(DN_NAMETABLE_MEMBERSHIP_INFO)) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("NameTable buffer is too small");
		goto Failure;
	}

	pNTEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(pInfo+1);
	for (dw = 0 ; dw < pInfo->dwEntryCount ; dw++, pNTEntryInfo++)
	{
		if (DNVerifyNameTableEntryInfo(pOpBuffer,dwOpBufferSize,pNTEntryInfo) != DPN_OK)
		{
			DPFERR("Invalid NameTable Entry in NameTable");
			goto Failure;
		}
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyPlayerConnectInfo"

HRESULT DNVerifyPlayerConnectInfo(void *const pOpBuffer,
								  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO*>(pOpBuffer);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwPasswordOffset > dwOpBufferSize)
	{
		DPFERR("Invalid password offset");
		goto Failure;
	}
	if (pInfo->dwPasswordOffset + pInfo->dwPasswordSize > dwOpBufferSize)
	{
		DPFERR("Invalid password size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	if (pInfo->dwURLOffset > dwOpBufferSize)
	{
		DPFERR("Invalid URL offset");
		goto Failure;
	}
	if (pInfo->dwURLOffset + pInfo->dwURLSize > dwOpBufferSize)
	{
		DPFERR("Invalid URL size");
		goto Failure;
	}

	if (pInfo->dwConnectDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid connect data offset");
		goto Failure;
	}
	if (pInfo->dwConnectDataOffset + pInfo->dwConnectDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid connect data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyConnectInfo"

HRESULT DNVerifyConnectInfo(void *const pOpBuffer,
							const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_INFO	*pInfo;
	UNALIGNED DPN_APPLICATION_DESC_INFO	*pdnAppDescInfo;
	UNALIGNED DN_NAMETABLE_INFO			*pdnNTInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < (sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO) + sizeof(DPN_APPLICATION_DESC_INFO) + sizeof(DN_NAMETABLE_INFO)))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_INFO*>(pOpBuffer);
	pdnAppDescInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pInfo + 1);
	pdnNTInfo = reinterpret_cast<DN_NAMETABLE_INFO*>(pdnAppDescInfo + 1);

	if (pInfo->dwReplyOffset > dwOpBufferSize)
	{
		DPFERR("Invalid reply offset");
		goto Failure;
	}
	if (pInfo->dwReplyOffset + pInfo->dwReplySize > dwOpBufferSize)
	{
		DPFERR("Invalid reply size");
	}

	if (DNVerifyApplicationDescInfo(pOpBuffer,dwOpBufferSize,pdnAppDescInfo) != DPN_OK)
	{
		DPFERR("Invalid application description");
		goto Failure;
	}

	if (DNVerifyNameTableInfo(pOpBuffer,dwOpBufferSize,pdnNTInfo) != DPN_OK)
	{
		DPFERR("Invalid nametable");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifySendPlayerDPNID"

HRESULT DNVerifySendPlayerDPNID(void *const pOpBuffer,
								const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyConnectFailed"

HRESULT DNVerifyConnectFailed(void *const pOpBuffer,
							  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_FAILED	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_CONNECT_FAILED))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_FAILED*>(pOpBuffer);

	if (pInfo->dwReplyOffset > dwOpBufferSize)
	{
		DPFERR("Invalid reply offset");
		goto Failure;
	}
	if (pInfo->dwReplyOffset + pInfo->dwReplySize > dwOpBufferSize)
	{
		DPFERR("Invalid reply size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyInstructConnect"

HRESULT DNVerifyInstructConnect(void *const pOpBuffer,
								const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyInstructedConnectFailed"

HRESULT DNVerifyInstructedConnectFailed(void *const pOpBuffer,
										const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyConnectAttemptFailed"

HRESULT DNVerifyConnectAttemptFailed(void *const pOpBuffer,
									 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#ifndef DPNBUILD_NOHOSTMIGRATE

#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyNameTableVersion"

HRESULT DNVerifyNameTableVersion(void *const pOpBuffer,
								 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_NAMETABLE_VERSION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyResyncVersion"

HRESULT DNVerifyResyncVersion(void *const pOpBuffer,
							  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_RESYNC_VERSION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqNameTableOp"

HRESULT DNVerifyReqNameTableOp(void *const pOpBuffer,
							   const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyAckNameTableOp"

HRESULT DNVerifyAckNameTableOp(void *const pOpBuffer,
							   const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	DWORD		dw;
	UNALIGNED DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP	*pAck;
	UNALIGNED DN_NAMETABLE_OP_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pAck = static_cast<DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP*>(pOpBuffer);

	if (sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP) + (pAck->dwNumEntries * sizeof(DN_NAMETABLE_OP_INFO)) > dwOpBufferSize)
	{
		DPFERR("NameTable operation buffer is too small");
		goto Failure;
	}

	pInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(pAck+1);
	for (dw = 0 ; dw < pAck->dwNumEntries ; dw++)
	{
		if (pInfo->dwOpOffset > dwOpBufferSize)
		{
			DPFERR("Invalid nametable operation offset");
			goto Failure;
		}
		if (pInfo->dwOpOffset + pInfo->dwOpSize > dwOpBufferSize)
		{
			DPFERR("Invalid nametable operation size");
			goto Failure;
		}

		switch(pInfo->dwMsgId)
		{
		case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
			{
				if (DNVerifyInstructConnect(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_ADD_PLAYER:
			{
				if (DNVerifyNameTableEntryInfo(	static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,
												pInfo->dwOpSize,
												static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				if (DNVerifyDestroyPlayer(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_CREATE_GROUP:
			{
				if (DNVerifyCreateGroup(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,
										pInfo->dwOpSize,
										static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_DESTROY_GROUP:
			{
				if (DNVerifyDestroyGroup(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
			{
				if (DNVerifyAddPlayerToGroup(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
			{
				if (DNVerifyDeletePlayerFromGroup(static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,pInfo->dwOpSize) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		case DN_MSG_INTERNAL_UPDATE_INFO:
			{
				if (DNVerifyUpdateInfo(	static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset,
										pInfo->dwOpSize,
										static_cast<BYTE*>(pOpBuffer)+pInfo->dwOpOffset) != DPN_OK)
				{
					DPFERR("Invalid NameTable operation");
					goto Failure;
				}
				break;
			}
		default:
			{
				DPFERR("Invalid NameTable op - ignore and continue");
				break;
			}
		}
		pInfo++;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyHostMigrate"

HRESULT DNVerifyHostMigrate(void *const pOpBuffer,
							const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_HOST_MIGRATE))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}

#endif // !DPNBUILD_NOHOSTMIGRATE

#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyDestroyPlayer"

HRESULT DNVerifyDestroyPlayer(void *const pOpBuffer,
							  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_DESTROY_PLAYER))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyCreateGroup"

HRESULT DNVerifyCreateGroup(void *const pOpBuffer,
							const DWORD dwOpBufferSize,
							void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_CREATE_GROUP	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_INTERNAL_MESSAGE_CREATE_GROUP) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pData);

	if (reinterpret_cast<BYTE*>(pInfo+1) + sizeof(DN_NAMETABLE_ENTRY_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("NameTable entry info buffer is too small !");
		goto Failure;
	}

	if (DNVerifyNameTableEntryInfo(pOpBuffer,dwOpBufferSize,pInfo+1) != DPN_OK)
	{
		DPFERR("Invalid NameTable entry info");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyDestroyGroup"

HRESULT DNVerifyDestroyGroup(void *const pOpBuffer,
							 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_DESTROY_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyAddPlayerToGroup"

HRESULT DNVerifyAddPlayerToGroup(void *const pOpBuffer,
								 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyDeletePlayerFromGroup"

HRESULT DNVerifyDeletePlayerFromGroup(void *const pOpBuffer,
									  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyUpdateInfo"

HRESULT DNVerifyUpdateInfo(void *const pOpBuffer,
						   const DWORD dwOpBufferSize,
						   void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_UPDATE_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_INTERNAL_MESSAGE_UPDATE_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pData);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqCreateGroup"

HRESULT DNVerifyReqCreateGroup(void *const pOpBuffer,
							   const DWORD dwOpBufferSize,
							   void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP*>(pData);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqDestroyGroup"

HRESULT DNVerifyReqDestroyGroup(void *const pOpBuffer,
								const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqAddPlayerToGroup"

HRESULT DNVerifyReqAddPlayerToGroup(void *const pOpBuffer,
									const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqDeletePlayerFromGroup"

HRESULT DNVerifyReqDeletePlayerFromGroup(void *const pOpBuffer,
										 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqUpdateInfo"

HRESULT DNVerifyReqUpdateInfo(void *const pOpBuffer,
							  const DWORD dwOpBufferSize,
							  void *const pData)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld], pData [0x%p]",pOpBuffer,dwOpBufferSize,pData);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	if (static_cast<BYTE*>(pData) + sizeof(DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO) > static_cast<BYTE*>(pOpBuffer) + dwOpBufferSize)
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO*>(pData);

	if (pInfo->dwNameOffset > dwOpBufferSize)
	{
		DPFERR("Invalid name offset");
		goto Failure;
	}
	if (pInfo->dwNameOffset + pInfo->dwNameSize > dwOpBufferSize)
	{
		DPFERR("Invalid name size");
		goto Failure;
	}

	if (pInfo->dwDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid data offset");
		goto Failure;
	}
	if (pInfo->dwDataOffset + pInfo->dwDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyRequestFailed"

HRESULT DNVerifyRequestFailed(void *const pOpBuffer,
							  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQUEST_FAILED))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyTerminateSession"

HRESULT DNVerifyTerminateSession(void *const pOpBuffer,
								 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;
	UNALIGNED DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pInfo;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	pInfo = static_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pOpBuffer);

	if (pInfo->dwTerminateDataOffset > dwOpBufferSize)
	{
		DPFERR("Invalid terminate data offset");
		goto Failure;
	}
	if (pInfo->dwTerminateDataOffset + pInfo->dwTerminateDataSize > dwOpBufferSize)
	{
		DPFERR("Invalid terminate data size");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqProcessCompletion"

HRESULT DNVerifyReqProcessCompletion(void *const pOpBuffer,
									 const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyProcessCompletion"

HRESULT DNVerifyProcessCompletion(void *const pOpBuffer,
								  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_PROCESS_COMPLETION))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyReqIntegrityCheck"

HRESULT DNVerifyReqIntegrityCheck(void *const pOpBuffer,
								  const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyIntegrityCheck"

HRESULT DNVerifyIntegrityCheck(void *const pOpBuffer,
							   const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNVerifyIntegrityCheckResponse"

HRESULT DNVerifyIntegrityCheckResponse(void *const pOpBuffer,
									   const DWORD dwOpBufferSize)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP,6,"Parameters: pOpBuffer [0x%p], dwOpBufferSize [%ld]",pOpBuffer,dwOpBufferSize);

	if (dwOpBufferSize < sizeof(DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE))
	{
		DPFERR("Message buffer is too small !");
		goto Failure;
	}

	if (pOpBuffer == NULL)
	{
		DPFERR("No message buffer !");
		goto Failure;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP,6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	hResultCode = DPNERR_GENERIC;
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\syncevent.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SyncEvent.h
 *  Content:    Synchronization Events FPM Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/20/99	mjn		Created
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__SYNC_EVENT_H__
#define	__SYNC_EVENT_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

extern CFixedPool g_SyncEventPool;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for RefCount buffer

class CSyncEvent
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CSyncEvent::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CSyncEvent* pSyncEvent = (CSyncEvent*)pvItem;

			if ((pSyncEvent->m_hEvent = DNCreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
			{
				return(FALSE);
			}
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CSyncEvent::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CSyncEvent* pSyncEvent = (CSyncEvent*)pvItem;

			pSyncEvent->Reset();

			pSyncEvent->m_pIDPThreadPoolWork = (IDirectPlay8ThreadPoolWork*) pvContext;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CSyncEvent::FPMDealloc"
	static void FPMDealloc( void* pvItem )
		{
			CSyncEvent* pSyncEvent = (CSyncEvent*)pvItem;

			DNCloseHandle(pSyncEvent->m_hEvent);
			pSyncEvent->m_hEvent = NULL;
	};

	void ReturnSelfToPool( void )
		{
			g_SyncEventPool.Release( this );
		};

	HRESULT Reset( void ) const
		{
			if (DNResetEvent(m_hEvent) == 0)
			{
				return(DPNERR_GENERIC);
			}
			return(DPN_OK);
		}

	HRESULT Set( void ) const
		{
			if (DNSetEvent(m_hEvent) == 0)
			{
				return(DPNERR_GENERIC);
			}
			return(DPN_OK);
		}

	HRESULT WaitForEvent(void) const
		{
			return(IDirectPlay8ThreadPoolWork_WaitWhileWorking(m_pIDPThreadPoolWork,
																HANDLE_FROM_DNHANDLE(m_hEvent),
																0));
		}

private:
	DNHANDLE						m_hEvent;
	IDirectPlay8ThreadPoolWork				*m_pIDPThreadPoolWork;
};

#undef DPF_MODNAME

#endif	// __SYNC_EVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\voice.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       voice.h
 *  Content:    Direct Net Voice Transport Interface
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/17/00	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__VOICE_H__
#define	__VOICE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT, *PDIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for peer interface
//
//extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
#ifndef DPNBUILD_NOVOICE
HRESULT Voice_Notify( PDIRECTNETOBJECT pObject, DWORD dwMsgID, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD dwObjectType = DVTRANSPORT_OBJECTTYPE_BOTH );
HRESULT Voice_Receive(PDIRECTNETOBJECT pObject, DVID dvidFrom, DVID dvidTo, LPVOID lpvMessage, DWORD dwMessageLen );
#endif // !DPNBUILD_NOVOICE


//**********************************************************************
// Function prototypes
//**********************************************************************

#endif	// __VOICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addbase.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addtcp.cpp
 *  Content:    DirectPlay8Address TCP interace file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/12/2000	rmt		Split Get into GetByName and GetByIndex
 * 02/17/2000	rmt		Parameter validation work
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 *                      Added support for the new ANSI type
 *                      Added SetEqual function
 * 03/24/2000	rmt		Added IsEqual function
 * 04/21/2000   rmt     Bug #32952 - Does not run on Win95 GOLD pre-IE4
 * 05/01/2000   rmt     Bug #33074 - Debug accessing invalid memory
 * 05/17/2000   rmt     Bug #35051 - Incorrect function names in debug spew
 * 06/09/2000   rmt     Updates to split CLSID and allow whistler compat
 * 07/21/2000	rmt		Fixed bug w/directplay 4 address parsing
 * 02/07/2001	rmt		WINBUG #290631 - IA64: DirectPlay: Addressing BuildFromDPADDRESS should always return UNSUPPORTED
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


typedef	STDMETHODIMP BaseQueryInterface( IDirectPlay8Address *pInterface, DPNAREFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	BaseAddRef( IDirectPlay8Address *pInterface );
typedef	STDMETHODIMP_(ULONG)	BaseRelease( IDirectPlay8Address *pInterface );

//
// VTable for client interface
//
IDirectPlay8AddressVtbl DP8A_BaseVtbl =
{
	(BaseQueryInterface*)	DP8A_QueryInterface,
	(BaseAddRef*)			DP8A_AddRef,
	(BaseRelease*)			DP8A_Release,
							DP8A_BuildFromURLW,
							DP8A_BuildFromURLA,
							DP8A_Duplicate,
							DP8A_SetEqual,
							DP8A_IsEqual,
							DP8A_Clear,
							DP8A_GetURLW,
							DP8A_GetURLA,
							DP8A_GetSP,
							DP8A_GetUserData,
							DP8A_SetSP,
							DP8A_SetUserData,
							DP8A_GetNumComponents,
							DP8A_GetComponentByNameW,
							DP8A_GetComponentByIndexW,
							DP8A_AddComponentW,
							DP8A_GetDevice,
							DP8A_SetDevice,
                            DP8A_BuildFromDirectPlay4Address
};

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_IsEqual"
STDMETHODIMP DP8A_IsEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8ExternalAddress )
{
	HRESULT hr;
	WCHAR *wszFirstURL = NULL,
		  *wszSecondURL = NULL;
	DWORD dwFirstBufferSize = 0,
	      dwSecondBuffersize = 0;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pdp8ExternalAddress == NULL )
    {
        DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified" );
        DP8A_RETURN( DPNERR_INVALIDPOINTER );
    }

	if( !DP8A_VALID( pdp8ExternalAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
#endif // !DPNBUILD_NOPARAMVAL

	hr = IDirectPlay8Address_GetURLW( pInterface, wszFirstURL, &dwFirstBufferSize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  0, "Could not get URL size for current object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	wszFirstURL = (WCHAR*) DNMalloc(dwFirstBufferSize * sizeof(WCHAR));

	if( wszFirstURL == NULL )
	{
		DPFX(DPFPREP,  0, "Error allocating memory hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	hr = IDirectPlay8Address_GetURLW( pInterface, wszFirstURL, &dwFirstBufferSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Could not get URL for current object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	hr = IDirectPlay8Address_GetURLW( pdp8ExternalAddress, wszSecondURL, &dwSecondBuffersize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  0, "Could not get URL size for exterior object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	wszSecondURL = (WCHAR*) DNMalloc(dwSecondBuffersize * sizeof(WCHAR));

	if( wszSecondURL == NULL )
	{
		DPFX(DPFPREP,  0, "Error allocating memory hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	hr = IDirectPlay8Address_GetURLW( pdp8ExternalAddress, wszSecondURL, &dwSecondBuffersize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Could not get URL for exterior object hr=[0x%lx]", hr );
		goto ISEQUAL_ERROR;
	}

	if( _wcsicmp( wszFirstURL, wszSecondURL ) == 0 )
	{
		hr = DPNSUCCESS_EQUAL;
	}
	else
	{
		hr = DPNSUCCESS_NOTEQUAL;
	}

ISEQUAL_ERROR:

	if( wszFirstURL != NULL )
		DNFree(wszFirstURL);

	if( wszSecondURL != NULL )
		DNFree(wszSecondURL);

	DP8A_RETURN( hr );

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetEqual"
STDMETHODIMP DP8A_SetEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8ExternalAddress )
{
	HRESULT hr;
	WCHAR *wszURLBuffer = NULL;
	DWORD dwBufferSize = 0;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	if( pdp8ExternalAddress == NULL )
    {
        DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified" );
        DP8A_RETURN( DPNERR_INVALIDPOINTER );
    }

	if( !DP8A_VALID( pdp8ExternalAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}	
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

    // Get ourselves a reference for duration of the call
	IDirectPlay8Address_AddRef(pdp8ExternalAddress);

	hr = IDirectPlay8Address_GetURLW( pdp8ExternalAddress, wszURLBuffer, &dwBufferSize );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
	    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error getting contents of passed address hr=0x%x", hr );
        goto SETEQUAL_CLEANUP;
	}

	wszURLBuffer = (WCHAR*) DNMalloc(dwBufferSize * sizeof(WCHAR));

	if( wszURLBuffer == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error allocating memory" );
		goto SETEQUAL_CLEANUP;
	}

	hr = IDirectPlay8Address_GetURLW( pdp8ExternalAddress, wszURLBuffer, &dwBufferSize );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error getting contents of passed address w/buffer hr=0x%x", hr );
        goto SETEQUAL_CLEANUP;
	}

	hr = pdp8Address->SetURL( wszURLBuffer );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting address to match passed address hr=0x%x", hr );
        goto SETEQUAL_CLEANUP;
	}

SETEQUAL_CLEANUP:

    IDirectPlay8Address_Release(pdp8ExternalAddress);

    if( wszURLBuffer != NULL )
        DNFree(wszURLBuffer);

    DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_BuildFromDirectPlay4Address"
STDMETHODIMP DP8A_BuildFromDirectPlay4Address( IDirectPlay8Address *pInterface, void * pvDataBuffer, DWORD dwDataSize )
{
#ifdef DPNBUILD_NOLEGACYDP
	DPFX(DPFPREP, DP8A_ERRORLEVEL, "BuildFromDirectPlay4Address() is not supported!" );
	DP8A_RETURN( DPNERR_UNSUPPORTED );
#else // ! DPNBUILD_NOLEGACYDP

	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

    if( dwDataSize == 0 )
    {
    	DPFX(DPFPREP,  DP8A_ERRORLEVEL, "0 length addresses are not allowed" );
    	return DPNERR_INVALIDPARAM;
    }	

    if( pvDataBuffer == NULL ||
        !DNVALID_READPTR( pvDataBuffer, dwDataSize ) )
    {
        DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Specified buffer is invalid" );
        DP8A_RETURN( DPNERR_INVALIDPOINTER );
    }
#endif // !DPNBUILD_NOPARAMVAL
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

    hr = pdp8Address->SetDirectPlay4Address( pvDataBuffer, dwDataSize );

    DP8A_RETURN( hr );
#endif // ! DPNBUILD_NOLEGACYDP
}

// DP8A_BuildFromURLA
//
// Initializes this object with URL specified in ANSI
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_BuildFromURLA"
STDMETHODIMP DP8A_BuildFromURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress )
{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pszAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( !DNVALID_STRING_A( pszAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string specified for address" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );
	}
#endif // !DPNBUILD_NOPARAMVAL
	
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pszAddress = %hs", pszAddress );

	WCHAR *szShadowBuffer = NULL;

	DWORD dwStrSize = 0;

	if( pszAddress != NULL )
	{
		dwStrSize = strlen(pszAddress)+1;
		
		szShadowBuffer = (WCHAR*) DNMalloc(dwStrSize * sizeof(WCHAR));

		if( szShadowBuffer == NULL )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error allocating memory" );
			hr = DPNERR_OUTOFMEMORY;
			goto BUILDFROMURLW_RETURN;
		}

		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
			hr = DPNERR_CONVERSION;
			goto BUILDFROMURLW_RETURN;
		}
	}

	hr = pdp8Address->SetURL( szShadowBuffer );

BUILDFROMURLW_RETURN:

	if( szShadowBuffer )
		DNFree(szShadowBuffer);

	DP8A_RETURN( hr );	
}

// DP8A_BuildFromURLW
//
// Initializes this object with URL specified in Unicode
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_BuildFromURLW"
STDMETHODIMP DP8A_BuildFromURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress )

{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pwszAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( !DNVALID_STRING_W( pwszAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string specified for address" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress = %ls", pwszAddress );

	hr = pdp8Address->SetURL( pwszAddress );

	DP8A_RETURN( hr );	
}

// DP8A_Duplicate
//
// Creates and initializes another address object as a duplicate to this one.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_Duplicate"
STDMETHODIMP DP8A_Duplicate( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS *ppInterface )
{
	HRESULT hr;
	DP8ADDRESSOBJECT *pdp8AddressSource;
	LPDIRECTPLAY8ADDRESS lpdp8Address = NULL;
	DP8ADDRESSOBJECT *pdp8AddressDest;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( ppInterface == NULL ||
	   !DNVALID_WRITEPTR( ppInterface, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to pointer specified in ppInterface" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}
#endif // !DPNBUILD_NOPARAMVAL

	pdp8AddressSource = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "ppInterface = 0x%p", ppInterface );	

#ifdef DPNBUILD_LIBINTERFACE
	hr = DP8ACF_CreateInstance( IID_IDirectPlay8Address,
								(void **) &lpdp8Address );
#else // ! DPNBUILD_LIBINTERFACE
    hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_IDirectPlay8Address,
								(void **) &lpdp8Address,
								FALSE );
#endif // ! DPNBUILD_LIBINTERFACE
	if( FAILED( hr ) )
    {
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "CoCreate failed hr=0x%x", hr );
		goto DUPLICATE_FAIL;
    }

	pdp8AddressDest = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( lpdp8Address );

	hr = pdp8AddressDest->Copy( pdp8AddressSource );
	
    if( FAILED( hr ) )
    {
    	DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Copy failed hr=0x%x", hr );
    	goto DUPLICATE_FAIL;
    }


    *ppInterface = lpdp8Address;

    return DPN_OK;

DUPLICATE_FAIL:

	if( lpdp8Address != NULL )
		IDirectPlay8Address_Release(lpdp8Address);

	return hr;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetURLA"
STDMETHODIMP DP8A_GetURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress, PDWORD pdwAddressSize )

{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pdwAddressSize == NULL ||
	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}

	if( *pdwAddressSize > 0 &&
	   (pszAddress == NULL ||
	    !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressSize = 0x%p (%u)",
	     pszAddress, pdwAddressSize, *pdwAddressSize );

	hr = pdp8Address->BuildURLA( pszAddress, pdwAddressSize );

	DP8A_RETURN( hr );
}

// DP8A_GetURLW
//
// Retrieves the URL represented by this object in Unicode format
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetURLW"
STDMETHODIMP DP8A_GetURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressSize )
{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pdwAddressSize == NULL ||
	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}

	if( *pdwAddressSize > 0 &&
	   (pwszAddress == NULL ||
	    !DNVALID_WRITEPTR( pwszAddress, (*pdwAddressSize)*sizeof(WCHAR) ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressSize = 0x%p (%u)",
	     pwszAddress, pdwAddressSize, *pdwAddressSize );

	hr = pdp8Address->BuildURLW( pwszAddress, pdwAddressSize );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetSP"
STDMETHODIMP DP8A_GetSP( IDirectPlay8Address *pInterface, GUID * pguidSP )
{
#ifdef DPNBUILD_ONLYONESP
	DPFX(DPFPREP, 0, "Retrieving service provider GUID is not supported!");
	return DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONESP
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pguidSP == NULL ||
	   !DNVALID_WRITEPTR( pguidSP, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pguidSP" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidSP = 0x%p ", pguidSP );

	hr = pdp8Address->GetSP( pguidSP );

	DP8A_RETURN( hr );
#endif // ! DPNBUILD_ONLYONESP
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetUserData"
STDMETHODIMP DP8A_GetUserData( IDirectPlay8Address *pInterface, void * pBuffer, PDWORD pdwBufferSize )
{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pdwBufferSize == NULL ||
	   !DNVALID_WRITEPTR( pdwBufferSize, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pdwBufferSize" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	if( *pdwBufferSize > 0 &&
	   (pBuffer == NULL || !DNVALID_WRITEPTR( pBuffer, *pdwBufferSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pBuffer" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pBuffer = 0x%p pdwBufferSize = 0x%p(%u) ", pBuffer, pdwBufferSize, *pdwBufferSize );

	hr = pdp8Address->GetUserData( pBuffer, pdwBufferSize );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetSP"
STDMETHODIMP DP8A_SetSP( IDirectPlay8Address *pInterface, const GUID * const pguidSP )
{
#ifdef DPNBUILD_ONLYONESP
	DPFX(DPFPREP, 0, "Setting service provider GUID is not supported!");
	return DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONESP
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pguidSP == NULL ||
	   !DNVALID_READPTR( pguidSP, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pguidSP" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidSP = 0x%p", pguidSP );

	hr = pdp8Address->SetSP( pguidSP );

	DP8A_RETURN( hr );
#endif // ! DPNBUILD_ONLYONESP
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetDevice"
STDMETHODIMP DP8A_GetDevice( IDirectPlay8Address *pInterface, GUID * pguidSP )
{
#ifdef DPNBUILD_ONLYONEADAPTER
	DPFX(DPFPREP, 0, "Retrieving device GUID is not supported!");
	return DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONEADAPTER
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pguidSP == NULL ||
	   !DNVALID_WRITEPTR( pguidSP, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pguidDevice" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidDevice = 0x%p", pguidSP );	

	hr = pdp8Address->GetDevice( pguidSP );

	DP8A_RETURN( hr );
#endif // ! DPNBUILD_ONLYONEADAPTER
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetDevice"
STDMETHODIMP DP8A_SetDevice( IDirectPlay8Address *pInterface, const GUID * const pguidSP )
{
#ifdef DPNBUILD_ONLYONEADAPTER
	DPFX(DPFPREP, 0, "Setting device GUID is not supported!");
	return DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONEADAPTER
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pguidSP == NULL ||
	   !DNVALID_READPTR( pguidSP, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pguidDevice" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidDevice = 0x%p", pguidSP );		

	hr = pdp8Address->SetDevice( pguidSP );

	DP8A_RETURN( hr );
#endif // ! DPNBUILD_ONLYONEADAPTER
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_SetUserData"
STDMETHODIMP DP8A_SetUserData( IDirectPlay8Address *pInterface, const void * const pBuffer, const DWORD dwBufferSize )
{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( dwBufferSize > 0 &&
	   (pBuffer == NULL || !DNVALID_READPTR( pBuffer, dwBufferSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pBuffer" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pBuffer = 0x%p dwBufferSize = %u", pBuffer, dwBufferSize );		

	hr = pdp8Address->SetUserData( pBuffer, dwBufferSize );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetNumComponents"
STDMETHODIMP DP8A_GetNumComponents( IDirectPlay8Address *pInterface, PDWORD pdwNumComponents )
{
	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pdwNumComponents == NULL ||
	   !DNVALID_WRITEPTR( pdwNumComponents, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid ptr for num of components" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}
#endif // !DPNBUILD_NOPARAMVAL

	const DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	*pdwNumComponents = pdp8Address->GetNumComponents();

	DP8A_RETURN( DPN_OK );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetComponentByNameW"
STDMETHODIMP DP8A_GetComponentByNameW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pwszTag == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to tag.  A name must be specified" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}

	if( pdwComponentSize == NULL ||
	   !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD)) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Pointer to data size" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}

	if( pdwDataType == NULL ||
	   !DNVALID_READPTR( pdwDataType, sizeof(DWORD)) )	
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to data type" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
	}
	
	if( *pdwComponentSize > 0 &&
	   (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to component data" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	if( !DNVALID_STRING_W( pwszTag ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string specified for tag" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );				
	}	
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszTag = 0x%p pComponentBuffer = 0x%p, pdwComponentSize = 0x%p, pdwDataType = 0x%p",
		(pwszTag==NULL) ? NULL : pwszTag, pComponentBuffer, pdwComponentSize, pdwDataType );

	hr = pdp8Address->GetElement( pwszTag, pComponentBuffer, pdwComponentSize, pdwDataType );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_GetComponentByIndexW"
STDMETHODIMP DP8A_GetComponentByIndexW( IDirectPlay8Address *pInterface,
	const DWORD dwComponentID, WCHAR * pwszTag, PDWORD pdwNameLen,
	void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	
	
#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pdwNameLen == NULL || !DNVALID_WRITEPTR( pdwNameLen, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pdwNameLen" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	if( *pdwNameLen != 0 &&
	   (pwszTag == NULL || !DNVALID_WRITEPTR( pwszTag, *pdwNameLen*sizeof(WCHAR) ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pwszTag" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( pdwComponentSize == NULL || !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pdwComponentSize" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( *pdwComponentSize != 0 &&
	   (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pwszTag" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	

	if( pdwDataType == NULL || !DNVALID_WRITEPTR( pdwDataType, sizeof(DWORD) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for pdwDataType" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "dwComponentID = %u pwszTag = 0x%p pdwNameLen = 0x%p (%u)  pComponentBuffer = 0x%p, pdwComponentSize = 0x%p (%u), pdwDataType = 0x%p",
		dwComponentID, pwszTag, pdwNameLen, *pdwNameLen, pComponentBuffer, pdwComponentSize, *pdwComponentSize, pdwDataType );

	hr = pdp8Address->GetElement( dwComponentID, pwszTag, pdwNameLen, pComponentBuffer, pdwComponentSize, pdwDataType );

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_AddComponentW"
STDMETHODIMP DP8A_AddComponentW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType )

{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pwszTag == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for tag string" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( pComponentData == NULL ||
	   !DNVALID_READPTR( pComponentData, dwComponentSize ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer specified for component" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( !DNVALID_STRING_W( pwszTag ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string specified for tag" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );
	}

	if( dwDataType != DPNA_DATATYPE_STRING &&
	   dwDataType != DPNA_DATATYPE_DWORD &&
	   dwDataType != DPNA_DATATYPE_GUID &&
	   dwDataType != DPNA_DATATYPE_BINARY &&
	   dwDataType != DPNA_DATATYPE_STRING_ANSI )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid datatype specified" );
		DP8A_RETURN( DPNERR_INVALIDPARAM );
	}

	if( dwDataType == DPNA_DATATYPE_STRING )
	{
		if( !DNVALID_STRING_W( (const WCHAR * const) pComponentData ) )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string component specified" );
			DP8A_RETURN( DPNERR_INVALIDSTRING );
		}

		if( ((wcslen( (const WCHAR * const) pComponentData)+1)*sizeof(WCHAR)) != dwComponentSize )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "String size and component size don't match" );
			DP8A_RETURN( DPNERR_INVALIDPARAM );
		}
	}
	else if( dwDataType == DPNA_DATATYPE_STRING_ANSI )
	{
		if( !DNVALID_STRING_A( (const CHAR * const) pComponentData ) )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string component specified" );
			DP8A_RETURN( DPNERR_INVALIDSTRING );
		}

		if( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "String size and component size don't match" );
			DP8A_RETURN( DPNERR_INVALIDPARAM );
		}
	}
	else if( dwDataType == DPNA_DATATYPE_DWORD )
	{
		if( dwComponentSize != sizeof( DWORD ) )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid size for DWORD component" );
			DP8A_RETURN( DPNERR_INVALIDPARAM );
		}
	}
	else if( dwDataType == DPNA_DATATYPE_GUID )
	{
		if( dwComponentSize != sizeof( GUID ) )
		{
			DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid size for GUID component" );
			DP8A_RETURN( DPNERR_INVALIDPARAM );
		}	
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	if (dwDataType == DPNA_DATATYPE_STRING_ANSI)
	{
		WCHAR		wszStackTemp[128];
		WCHAR *		pwszTemp;


		// Allocate a buffer if the string is too large to convert in our
		// stack based buffer.
		if ((dwComponentSize * 2) > sizeof(wszStackTemp))
		{
			pwszTemp = (WCHAR*) DNMalloc(dwComponentSize * 2);
			if (pwszTemp == NULL)
			{
				DPFX(DPFPREP, 0, "Error allocating memory for conversion");
				DP8A_RETURN( DPNERR_OUTOFMEMORY );
			}
		}
		else
		{
			pwszTemp = wszStackTemp;
		}

		hr = STR_jkAnsiToWide(pwszTemp, (const char * const) pComponentData, dwComponentSize);
		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
			hr = DPNERR_CONVERSION;
		}
		else
		{
			DPFX(DPFPREP,  DP8A_PARAMLEVEL, "Converted ANSI string pwszTag = 0x%p pComponentData = 0x%p dwComponentSize = %d",
				pwszTag, pwszTemp, (dwComponentSize * 2) );

			hr = pdp8Address->SetElement( pwszTag, pwszTemp, (dwComponentSize * 2), DPNA_DATATYPE_STRING );
		}

		if (pwszTemp != wszStackTemp)
		{
			DNFree(pwszTemp);
			pwszTemp = NULL;
		}
	}
	else
	{
		DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszTag = 0x%p pComponentData = 0x%p dwComponentSize = %d dwDataType = %d",
			pwszTag, pComponentData, dwComponentSize, dwDataType );

		hr = pdp8Address->SetElement( pwszTag, pComponentData, dwComponentSize, dwDataType );
	}


	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_Clear"
STDMETHODIMP DP8A_Clear( IDirectPlay8Address *pInterface )
{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );	

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );

	hr = pdp8Address->Clear(  );

	DP8A_RETURN( hr );
}

#ifndef DPNBUILD_NOPARAMVAL

BOOL IsValidDP8AObject( LPVOID lpvObject )
#ifdef DPNBUILD_LIBINTERFACE
{
	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) lpvObject;

	if( pdp8Address == NULL ||
	   !DNVALID_READPTR( pdp8Address, sizeof( DP8ADDRESSOBJECT ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

#ifdef DPNBUILD_NOADDRESSIPINTERFACE
	if( pdp8Address->lpVtbl != &DP8A_BaseVtbl )
#else // ! DPNBUILD_NOADDRESSIPINTERFACE
	if( pdp8Address->lpVtbl != &DP8A_BaseVtbl &&
	   pdp8Address->lpVtbl != &DP8A_IPVtbl )
#endif // ! DPNBUILD_NOADDRESSIPINTERFACE
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

	return TRUE;
}
#else // ! DPNBUILD_LIBINTERFACE
{
	INTERFACE_LIST *pIntList = (INTERFACE_LIST *) lpvObject;
	
	if( !DNVALID_READPTR( lpvObject, sizeof( INTERFACE_LIST ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object pointer" );
		return FALSE;
	}

	if( pIntList->lpVtbl != &DP8A_BaseVtbl &&
#ifndef DPNBUILD_NOADDRESSIPINTERFACE
	   pIntList->lpVtbl != &DP8A_IPVtbl &&
#endif // ! DPNBUILD_NOADDRESSIPINTERFACE
	   pIntList->lpVtbl != &DP8A_UnknownVtbl )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

	if( pIntList->iid != IID_IDirectPlay8Address &&
#ifndef DPNBUILD_NOADDRESSIPINTERFACE
	   pIntList->iid != IID_IDirectPlay8AddressIP &&
#endif // ! DPNBUILD_NOADDRESSIPINTERFACE
	   pIntList->iid != IID_IUnknown )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unknown object" );
		return FALSE;
	}

	if( pIntList->pObject == NULL ||
	   !DNVALID_READPTR( pIntList->pObject, sizeof( OBJECT_DATA ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

	const DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( lpvObject );

	if( pdp8Address == NULL ||
	   !DNVALID_READPTR( pdp8Address, sizeof( DP8ADDRESSOBJECT ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return FALSE;
	}

	return TRUE;
}
#endif // ! DPNBUILD_LIBINTERFACE

#endif // ! DPNBUILD_NOPARAMVAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\worker.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       worker.h
 *  Content:    DIRECT NET WORKER THREAD HEADER FILE
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/09/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Added SendHostMigration functionality
 *	01/09/00	mjn		Send Connect Info rather than just NameTable at connect
 *	01/10/00	mjn		Added support to update application descriptions
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Removed user notification jobs
 *	01/23/00	mjn		Implemented TerminateSession
 *	01/24/00	mjn		Added support for NameTable operation list cleanup
 *	04/04/00	mjn		Added support for TerminateSession
 *	04/13/00	mjn		Added dwFlags for internal sends
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/19/00	mjn		Added support to send NameTable operations directly
 *	06/21/00	mjn		Added support to install the NameTable (from Host)
 *	07/06/00	mjn		Use SP handle instead of interface
 *	07/30/00	mjn		Added DN_WORKER_JOB_TERMINATE_SESSION
 *	08/02/00	mjn		Added DN_WORKER_JOB_ALTERNATE_SEND
 *	08/08/00	mjn		Added DNWTPerformListen()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__WORKER_H__
#define	__WORKER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

void DNQueueWorkerJob(DIRECTNETOBJECT *const pdnObject,
					  CWorkerJob *const pWorkerJob);


//
// DirectNet - Worker Thread Routines
//

void WINAPI DNGenericWorkerCallback(void *const pvContext,
							void *const pvTimerData,
							const UINT uiTimerUnique);


HRESULT DNWTSendInternal(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp);

HRESULT DNWTProcessSend(DIRECTNETOBJECT *const pdnObject,
						CWorkerJob *const pWorkerJob);

HRESULT	DNWTTerminateSession(DIRECTNETOBJECT *const pdnObject,
							 CWorkerJob *const pWorkerJob);

HRESULT DNWTSendNameTableVersion(DIRECTNETOBJECT *const pdnObject,
								 CWorkerJob *const pWorkerJob);

#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
HRESULT DNWTRemoveServiceProvider(DIRECTNETOBJECT *const pdnObject,
								  CWorkerJob *const pWorkerJob);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP

void DNWTSendNameTableOperation(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob);
void DNWTSendNameTableOperationClient(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob);
void DNWTInstallNameTable(DIRECTNETOBJECT *const pdnObject,
						  CWorkerJob *const pWorkerJob);

void DNWTPerformListen(DIRECTNETOBJECT *const pdnObject,
					   CWorkerJob *const pWorkerJob);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __WORKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\user.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       User.h
 *  Content:    DirectNet User Call Back Routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/16/00	mjn		Created
 *	01/17/00	mjn		Added DN_UserHostMigrate
 *	01/17/00	mjn		Implemented send time
 *	01/22/00	mjn		Added DN_UserHostDestroyPlayer
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	01/28/00	mjn		Added DN_UserConnectionTerminated
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/04/00	mjn		Added DN_UserTerminateSession()
 *	04/05/00	mjn		Updated DN_UserHostDestroyPlayer()
 *	04/18/00	mjn		Added DN_UserReturnBuffer
 *				mjn		Added ppvReplyContext to DN_UserIndicateConnect
 *	07/29/00	mjn		Added DNUserIndicatedConnectAborted()
 *				mjn		DNUserConnectionTerminated() supercedes DN_TerminateSession()
 *				mjn		Added HRESULT to DNUserReturnBuffer()
 *	07/30/00	mjn		Added pAddressDevice to DNUserIndicateConnect()
 *				mjn		Replaced DNUserConnectionTerminated() with DNUserTerminateSession()
 *	07/31/00	mjn		Revised DNUserDestroyGroup()
 *				mjn		Removed DN_UserHostDestroyPlayer()
 *	08/01/00	mjn		DN_UserReceive() -> DNUserReceive()
 *	08/02/00	mjn		DN_UserAddPlayer() -> DNUserCreatePlayer()
 *	08/08/00	mjn		DN_UserCreateGroup() -> DNUserCreateGroup()
 *	08/20/00	mjn		Added DNUserEnumQuery() and DNUserEnumResponse()
 *	09/17/00	mjn		Changed parameters list of DNUserCreateGroup(),DNUserCreatePlayer(),
 *						DNUserAddPlayerToGroup(),DNRemovePlayerFromGroup()
 *	07/24/01	mjn		Added DPNBUILD_NOSERVER compile flag
 *	10/16/01	vanceo		Added some multicast callbacks
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__USER_H__
#define	__USER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNUserConnectComplete(DIRECTNETOBJECT *const pdnObject,
							  const DPNHANDLE hAsyncOp,
							  PVOID const pvContext,
							  const HRESULT hr,
							  CRefCountBuffer *const pRefCountBuffer);

HRESULT DNUserIndicateConnect(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvConnectData,
							  const DWORD dwConnectDataSize,
							  void **const ppvReplyData,
							  DWORD *const pdwReplyDataSize,
							  void **const ppvReplyContext,
							  IDirectPlay8Address *const pAddressPlayer,
							  IDirectPlay8Address *const pAddressDevice,
							  void **const ppvPlayerContext);

HRESULT DNUserIndicatedConnectAborted(DIRECTNETOBJECT *const pdnObject,
									  void *const pvPlayerContext);

HRESULT DNUserCreatePlayer(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry);

HRESULT DNUserDestroyPlayer(DIRECTNETOBJECT *const pdnObject,
							CNameTableEntry *const pNTEntry);

HRESULT DNUserCreateGroup(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry);

HRESULT DNUserDestroyGroup(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pNTEntry);

HRESULT DNUserAddPlayerToGroup(DIRECTNETOBJECT *const pdnObject,
							   CNameTableEntry *const pGroup,
							   CNameTableEntry *const pPlayer);

HRESULT DNUserRemovePlayerFromGroup(DIRECTNETOBJECT *const pdnObject,
									CNameTableEntry *const pGroup,
									CNameTableEntry *const pPlayer);

HRESULT DNUserUpdateGroupInfo(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid,
							  const PVOID pvContext);

HRESULT DNUserUpdatePeerInfo(DIRECTNETOBJECT *const pdnObject,
							 const DPNID dpnid,
							 const PVOID pvContext);

#ifndef	DPNBUILD_NOSERVER
HRESULT DNUserUpdateClientInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext);
#endif	// DPNBUILD_NOSERVER

HRESULT DNUserUpdateServerInfo(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   const PVOID pvContext);

HRESULT DNUserAsyncComplete(DIRECTNETOBJECT *const pdnObject,
							const DPNHANDLE hAsyncOp,
							PVOID const pvContext,
							const HRESULT hr);

HRESULT DNUserSendComplete(DIRECTNETOBJECT *const pdnObject,
						   const DPNHANDLE hAsyncOp,
						   PVOID const pvContext,
						   const DWORD dwStartTime,
						   const HRESULT hr,
						   const DWORD dwFirstFrameRTT,
						   const DWORD dwFirstFrameRetryCount);

HRESULT DNUserUpdateAppDesc(DIRECTNETOBJECT *const pdnObject);

HRESULT DNUserReceive(DIRECTNETOBJECT *const pdnObject,
					  CNameTableEntry *const pNTEntry,
					  BYTE *const pBufferData,
					  const DWORD dwBufferSize,
					  const DPNHANDLE hBufferHandle);

HRESULT DN_UserHostMigrate(DIRECTNETOBJECT *const pdnObject,
						   const DPNID dpnidNewHost,
						   const PVOID pvPlayerContext);

HRESULT DNUserTerminateSession(DIRECTNETOBJECT *const pdnObject,
							   const HRESULT hr,
							   void *const pvTerminateData,
							   const DWORD dwTerminateDataSize);

HRESULT DNUserReturnBuffer(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hr,
						   void *const pvBuffer,
						   void *const pvUserContext);

HRESULT DNUserEnumQuery(DIRECTNETOBJECT *const pdnObject,
						DPNMSG_ENUM_HOSTS_QUERY *const pMsg);

HRESULT DNUserEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   DPNMSG_ENUM_HOSTS_RESPONSE *const pMsg);

#ifndef DPNBUILD_NOMULTICAST
HRESULT DNUserJoinComplete(DIRECTNETOBJECT *const pdnObject,
							  const DPNHANDLE hAsyncOp,
							  PVOID const pvContext,
							  const HRESULT hr);

HRESULT DNUserReceiveMulticast(DIRECTNETOBJECT *const pdnObject,
										void * const pvSenderContext,
										IDirectPlay8Address *const pSenderAddress,
										IDirectPlay8Address *const pDeviceAddress,
										BYTE *const pBufferData,
										const DWORD dwBufferSize,
										const DPNHANDLE hBufferHandle);

HRESULT DNUserCreateSenderContext(DIRECTNETOBJECT *const pdnObject,
								  void *const pvContext);

HRESULT DNUserDestroySenderContext(DIRECTNETOBJECT *const pdnObject,
								   void *const pvContext);
#endif // ! DPNBUILD_NOMULTICAST

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __USER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\worker.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       worker.cpp
 *  Content:    DNET worker thread routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/01/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Added SendHostMigration functionality
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/09/00	mjn		Send Connect Info rather than just NameTable at connect
 *	01/10/00	mjn		Added SendUpdateApplicationDesc functionality
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Removed user notification jobs
 *	01/23/00	mjn		Implemented TerminateSession
 *	01/24/00	mjn		Added support for NameTable operation list cleanup
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	04/04/00	mjn		Added DNWTSendTerminateSession
 *	04/10/00	mjn		Added DNWTRemoveServiceProvider
 *	04/13/00	mjn		Internal sends use new Protocol Interface VTBL functions
 *				mjn		Internal sends contain dwFlags field
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/19/00	mjn		Added support to send NameTable operations directly
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/05/00	mjn		Use GetConnectionRef() to send NameTable operations
 *	05/10/00	mjn		Ensure valid local player in DNWTProcessSend()
 *	06/07/00	mjn		Pull assert in send failure case (it was handled)
 *	06/21/00	mjn		Added support to install the NameTable (from Host)
 *	06/22/00	mjn		Fixed DNWTProcessSend() to properly handle voice messages
 *	07/06/00	mjn		Use SP handle instead of interface
 *	07/21/00	mjn		RefCount cleanup
 *	07/30/00	mjn		Added DN_WORKER_JOB_TERMINATE_SESSION
 *	08/02/00	mjn		Changed DNWTProcessSend() to pass voice messages to DNReceiveUserData()
 *				mjn		Added DN_WORKER_JOB_ALTERNATE_SEND
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added fInternal to DNPerformChildSend()
 *	08/06/00	mjn		Added CWorkerJob
 *				mjn		Added DNQueueWorkerJob()
 *				mjn		Made DNWTSendNameTableOperation() more robust
 *	08/07/00	mjn		Removed COM_CoInitialize() and COM_CoUninitialize() calls in DNWorkerThreadProc()
 *	08/08/00	mjn		Added WORKER_JOB_PERFORM_LISTEN,DNWTPerformListen()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	06/06/01	mjn		Added back in COM_CoInitialize() and COM_CoUninitialize() calls to DNWorkerThreadProc()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DNGenericWorkerCallback"

void WINAPI DNGenericWorkerCallback(void *const pvContext,
							void *const pvTimerData,
							const UINT uiTimerUnique)
{
	DIRECTNETOBJECT		*pdnObject;
	CWorkerJob			*pWorkerJob;


#ifdef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	pWorkerJob = (CWorkerJob*)pvContext;
	pdnObject = pWorkerJob->GetDNObject();
#else // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE
	BOOL				fOwnProcessingOfJobs;
	CBilink				blDelayedJobs;

	pdnObject = (DIRECTNETOBJECT*)pvContext;
	blDelayedJobs.Initialize();

	//
	//	Process all jobs on queue unless another thread is already doing it.
	//
	fOwnProcessingOfJobs = FALSE;
	do
	{
		pWorkerJob = NULL;
		DNEnterCriticalSection(&pdnObject->csWorkerQueue);
		if (pdnObject->m_bilinkWorkerJobs.GetNext() != &pdnObject->m_bilinkWorkerJobs)
		{
			//
			//	If someone else is processing worker jobs already, don't do anything. 
			//
			if ((fOwnProcessingOfJobs) || (! pdnObject->fProcessingWorkerJobs))
			{
				pdnObject->fProcessingWorkerJobs = TRUE;
				fOwnProcessingOfJobs = TRUE;
				pWorkerJob = CONTAINING_OBJECT(pdnObject->m_bilinkWorkerJobs.GetNext(),CWorkerJob,m_bilinkWorkerJobs);
				pWorkerJob->m_bilinkWorkerJobs.RemoveFromList();
			}
			else
			{
				DPFX(DPFPREP, 5, "Another thread is already processing worker jobs.");
			}
		}
		else
		{
			//
			//	Give up ownership of job processing.
			//
			if (fOwnProcessingOfJobs)
			{
				DPFX(DPFPREP, 5, "No more jobs.");
				pdnObject->fProcessingWorkerJobs = FALSE;
				fOwnProcessingOfJobs = FALSE;
			}
			else
			{
				DPFX(DPFPREP, 5, "No jobs to process.");
			}
		}
		DNLeaveCriticalSection(&pdnObject->csWorkerQueue);

		if (pWorkerJob == NULL)
		{
			break;
		}
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE

		DPFX(DPFPREP, 5,"Processing job 0x%p id [0x%lx]",pWorkerJob,pWorkerJob->GetJobType());
		switch(pWorkerJob->GetJobType())
		{
			case WORKER_JOB_INSTALL_NAMETABLE:
				{
					DPFX(DPFPREP, 5,"Job: WORKER_JOB_INSTALL_NAMETABLE");
					DNWTInstallNameTable(pdnObject,pWorkerJob);
					break;
				}
			case WORKER_JOB_INTERNAL_SEND:
				{
					DPFX(DPFPREP, 5,"Job: WORKER_JOB_INTERNAL_SEND");
					DNWTProcessSend(pdnObject,pWorkerJob);
					break;
				}
			case WORKER_JOB_PERFORM_LISTEN:
				{
					DPFX(DPFPREP, 5,"Job: WORKER_JOB_PERFORM_LISTEN");
					DNWTPerformListen(pdnObject,pWorkerJob);
					break;
				}
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
			case WORKER_JOB_REMOVE_SERVICE_PROVIDER:
				{
					HRESULT		hr;
					DWORD		dwRecursionDepthAllowed;
					DWORD		dwRecursionDepth;


					//
					//	Before we perform the job, make sure we're not in a recursive DoWork,
					//	WaitWhileWorking, or SleepWhileWorking call.  If we are, then delay the
					//	job to avoid deadlocks.  We need service providers to be removed at
					//	the top level of processing.
					//	There is one exception, in DN_Close we expect to be waiting for service
					//	provider removal, so allow a single level of recursion.  We can tell when
					//	we're inside Close by our thread ID matching the one stored off the DN
					//	object.  Note that dwClosingThreadID will be 0 until we enter Close.
					//
					DNEnterCriticalSection(&pdnObject->csDirectNetObject);
					if (pdnObject->dwClosingThreadID == GetCurrentThreadId())
					{
						DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING);
						dwRecursionDepthAllowed = 1;
					}
					else
					{
						DNASSERT((pdnObject->dwClosingThreadID == 0) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING));
						dwRecursionDepthAllowed = 0;
					}
					DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
					
					hr = IDirectPlay8ThreadPoolWork_GetWorkRecursionDepth(pdnObject->pIDPThreadPoolWork,
																		&dwRecursionDepth,
																		0);
					DNASSERT(hr == DPN_OK);
					if (dwRecursionDepth > dwRecursionDepthAllowed)
					{
						DPFX(DPFPREP, 1,"Re-queueing WORKER_JOB_REMOVE_SERVICE_PROVIDER 0x%p because this thread is recursively 'Work'ing (depth = %u).",
							pWorkerJob, dwRecursionDepth);
#ifdef DPNBUILD_NONSEQUENTIALWORKERQUEUE
						DNQueueWorkerJob(pdnObject, pWorkerJob);
#else // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE
						pWorkerJob->m_bilinkWorkerJobs.InsertBefore(&blDelayedJobs);
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE

						//
						//	Forget about the job so it's not returned to the pool below.
						//
						pWorkerJob = NULL;
					}
					else
					{
						DPFX(DPFPREP, 5,"Job: WORKER_JOB_REMOVE_SERVICE_PROVIDER 0x%p (work recursion depth = %u)",
							pWorkerJob, dwRecursionDepth);
						DNWTRemoveServiceProvider(pdnObject,pWorkerJob);
					}
					break;
				}
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
			case WORKER_JOB_SEND_NAMETABLE_OPERATION:
				{
					DPFX(DPFPREP, 5,"Job: WORKER_JOB_SEND_NAMETABLE_OPERATION");
					DNWTSendNameTableOperation(pdnObject,pWorkerJob);
					break;
				}
			case WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT:
				{
					DPFX(DPFPREP, 5,"Job: WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT");
					DNWTSendNameTableOperationClient(pdnObject,pWorkerJob);
					break;
				}
			case WORKER_JOB_SEND_NAMETABLE_VERSION:
				{
					DPFX(DPFPREP, 5,"Job: WORKER_JOB_SEND_NAMETABLE_VERSION");
					DNWTSendNameTableVersion(pdnObject,pWorkerJob);
					break;
				}
			case WORKER_JOB_TERMINATE_SESSION:
				{
					DPFX(DPFPREP, 5,"Job: WORKER_JOB_TERMINATE_SESSION");
					DNWTTerminateSession(pdnObject,pWorkerJob);
					break;
				}
			case WORKER_JOB_UNKNOWN:
			default:
				{
					DPFERR("Unknown Job !");
					DNASSERT(FALSE);
					break;
				}
		}

		//
		//	Return this job to the pool (clean up is automatic)
		//
		if (pWorkerJob != NULL)
		{
			pWorkerJob->ReturnSelfToPool();
			pWorkerJob = NULL;
		}

#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	}
	while (TRUE);

	//
	//	If we delayed any jobs, requeue them all now.
	//
	if (! blDelayedJobs.IsEmpty())
	{
		HRESULT		hResultCode;
		DWORD		dwMinRequeueCount;
		DWORD		dwRequeueCount;

		dwMinRequeueCount = 1000;	// wait at most 1 second
		DNEnterCriticalSection(&pdnObject->csWorkerQueue);
		do
		{
			pWorkerJob = CONTAINING_OBJECT(blDelayedJobs.GetNext(),CWorkerJob,m_bilinkWorkerJobs);
			pWorkerJob->m_bilinkWorkerJobs.RemoveFromList();
			dwRequeueCount = pWorkerJob->IncRequeueCount();
			if (dwRequeueCount < dwMinRequeueCount)
			{
				dwMinRequeueCount = dwRequeueCount;
			}
			pWorkerJob->m_bilinkWorkerJobs.InsertBefore(&pdnObject->m_bilinkWorkerJobs);
		}
		while (! blDelayedJobs.IsEmpty());
		DNLeaveCriticalSection(&pdnObject->csWorkerQueue);

		//
		// If we have an item we've never requeued yet, submit a work item to handle it
		// immediately.  Otherwise set a timer to handle the jobs in the future to prevent
		// us from picking up the same item over and over again because we're waiting on
		// the connection to drop, for example.
		//
#pragma TODO(vanceo, "Possibly select a CPU?")
		if (dwMinRequeueCount == 0)
		{
			DPFX(DPFPREP, 7,"Queuing work item to handle jobs");
			hResultCode = IDirectPlay8ThreadPoolWork_QueueWorkItem(pdnObject->pIDPThreadPoolWork,	// interface
																	-1,								// use any CPU
																	DNGenericWorkerCallback,		// callback
																	pdnObject,						// context
																	0);								// flags
		}
		else
		{
			PVOID	pvTimerDataIgnored;
			UINT	uiTimerUniqueIgnored;

			DPFX(DPFPREP, 7,"Scheduling timer to handle jobs");
			hResultCode = IDirectPlay8ThreadPoolWork_ScheduleTimer(pdnObject->pIDPThreadPoolWork,	// interface
																	-1,								// use any CPU
																	dwMinRequeueCount,				// use the requeue count as the delay in ms
																	DNGenericWorkerCallback,		// callback
																	pdnObject,						// context
																	&pvTimerDataIgnored,			// timer handle
																	&uiTimerUniqueIgnored,			// timer uniqueness
																	0);								// flags

			//
			// Ignore the timer handle since we will never attempt to cancel it.
			// Treat it as a really slow queued work item.
			//
		}
		DNASSERT(hResultCode == DPN_OK);

		//
		// Keep the threadpool object reference for the new work item/timer.
		//
	}
	else
	{
		//
		//	Release the threadpool object reference.
		//
		DNThreadPoolRelease(pdnObject);
	}
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE
}


//	DNQueueWorkerJob
//
//	Add a worker thread job to the end of the job queue, and signal the queue to run

#undef DPF_MODNAME
#define DPF_MODNAME "DNQueueWorkerJob"

void DNQueueWorkerJob(DIRECTNETOBJECT *const pdnObject,
					  CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	PVOID		pvContext;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p] (type=0x%x)",pWorkerJob,pWorkerJob->GetJobType());

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

#ifdef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	pvContext = pWorkerJob;
#else // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE
	DNEnterCriticalSection(&pdnObject->csWorkerQueue);
	pWorkerJob->m_bilinkWorkerJobs.InsertBefore(&pdnObject->m_bilinkWorkerJobs);
	DNLeaveCriticalSection(&pdnObject->csWorkerQueue);

	pvContext = pdnObject;

	//
	//	Add a reference on the DNet object to prevent the threadpool from unloading
	//	before all of the scheduled work items have executed.
	//
	DNThreadPoolAddRef(pdnObject);
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE


#pragma TODO(vanceo, "Possibly select a CPU?")

	hResultCode = IDirectPlay8ThreadPoolWork_QueueWorkItem(pdnObject->pIDPThreadPoolWork,	// interface
															-1,								// use any CPU
															DNGenericWorkerCallback,		// callback
															pvContext,						// context
															0);								// flags
	DNASSERT(hResultCode == DPN_OK);

	DPFX(DPFPREP, 6,"Returning");
}



//	DNWTSendInternal
//
//	Send an internal message. This will copy the message buffer and place the operation on the
//	working thread job queue

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendInternal"

HRESULT DNWTSendInternal(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp)
{
	HRESULT				hResultCode;
	DWORD				dw;
	DWORD				dwSize;
	CWorkerJob			*pWorkerJob;
	CRefCountBuffer		*pRefCountBuffer;
	DN_SEND_OP_DATA		*pSendOpData;

	DPFX(DPFPREP, 6,"Parameters: pAsyncOp [0x%p]",pAsyncOp);

	pRefCountBuffer = NULL;
	pWorkerJob = NULL;
	pSendOpData = NULL;

	//
	//	Create local buffer
	//
	if (pAsyncOp->IsUseParentOpData())
	{
		if (pAsyncOp->IsChild() && pAsyncOp->GetParent())
		{
			pSendOpData = pAsyncOp->GetParent()->GetLocalSendOpData();
		}
	}
	else
	{
		pSendOpData = pAsyncOp->GetLocalSendOpData();
	}
	if (pSendOpData == NULL)
	{
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	dwSize = 0;
	for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
	{
		dwSize += pSendOpData->BufferDesc[dw].dwBufferSize;
	}

	DPFX(DPFPREP, 7,"Allocating RefCount Buffer of [%ld] bytes",dwSize);
	if ((hResultCode = RefCountBufferNew(pdnObject,dwSize,MemoryBlockAlloc,MemoryBlockFree,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate space for local buffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Copy from scatter-gather buffers
	//
	dwSize = 0;
	for ( dw = 0 ; dw < pSendOpData->dwNumBuffers ; dw++ )
	{
		memcpy(	pRefCountBuffer->GetBufferAddress() + dwSize,
				pSendOpData->BufferDesc[dw].pBufferData,
				pSendOpData->BufferDesc[dw].dwBufferSize );
		dwSize += pSendOpData->BufferDesc[dw].dwBufferSize;
	}

	//	TODO - user context value of send ?
	DPFX(DPFPREP, 7,"Adding Internal Send to Job Queue");
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not create worker job");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pWorkerJob->SetJobType( WORKER_JOB_INTERNAL_SEND );
	pWorkerJob->SetInternalSendFlags( pAsyncOp->GetOpFlags() );
	pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	//
	//	Invoke send completion handler
	//
	DNPICompleteSend(	pdnObject,
						static_cast<void*>(pAsyncOp),
						DPN_OK,
						0,
						0);
	
	hResultCode = DPNERR_PENDING;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNWTProcessSend
//
//	Process an internal send message.  This will indicate a received user message, or process a received internal one.

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTProcessSend"

HRESULT DNWTProcessSend(DIRECTNETOBJECT *const pdnObject,
						CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	void		*pvData;
	DWORD		dwDataSize;
	void		*pvInternalData;
	DWORD		dwInternalDataSize;
	DWORD		*pdwMsgId;
	CNameTableEntry	*pLocalPlayer;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	pLocalPlayer = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	//
	//	Extract and clear RefCountBuffer from job
	//
	DNASSERT(pWorkerJob->GetRefCountBuffer() != NULL);
	pRefCountBuffer = pWorkerJob->GetRefCountBuffer();
	pWorkerJob->SetRefCountBuffer( NULL );

	//
	//	Get local player's connection (if still valid)
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Local player not in NameTable (shutting down ?)");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if ((hResultCode = pLocalPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Local player connection is not valid (shutting down?)");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	DNASSERT(pRefCountBuffer->GetBufferAddress() != NULL);
	pvData = pRefCountBuffer->GetBufferAddress();
	dwDataSize = pRefCountBuffer->GetBufferSize();

	if ((pWorkerJob->GetInternalSendFlags() & DN_SENDFLAGS_SET_USER_FLAG)
			&& !(pWorkerJob->GetInternalSendFlags() & DN_SENDFLAGS_SET_USER_FLAG_TWO))
	{
		//
		//	Internal message
		//
		DPFX(DPFPREP, 7,"Received INTERNAL message");

		// Extract internal message
		DNASSERT(dwDataSize >= sizeof(DWORD));
		pdwMsgId = static_cast<DWORD*>(pvData);
		dwInternalDataSize = dwDataSize - sizeof(DWORD);
		if (dwInternalDataSize > 0)
		{
			pvInternalData = static_cast<void*>(static_cast<BYTE*>(pvData) + sizeof(DWORD));
		}
		else
		{
			pvInternalData = NULL;
		}

		// Process internal message
		hResultCode = DNProcessInternalOperation(	pdnObject,
													*pdwMsgId,
													pvInternalData,
													dwInternalDataSize,
													pConnection,
													NULL,
													pRefCountBuffer);
	}
	else
	{
		//
		//	User or voice message
		//
		DPFX(DPFPREP, 7,"Received USER or Voice message");

		hResultCode = DNReceiveUserData(pdnObject,
										pConnection,
										static_cast<BYTE*>(pvData),
										dwDataSize,
										NULL,
										pRefCountBuffer,
										0,
										pWorkerJob->GetInternalSendFlags());
	}

	//
	//	Clean up
	//
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pConnection->Release();
	pConnection = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNWTTerminateSession
//
//	Disconnect the Local player from the session

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTTerminateSession"

HRESULT	DNWTTerminateSession(DIRECTNETOBJECT *const pdnObject,
							 CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	// Terminate session
	hResultCode = DNTerminateSession(pdnObject,pWorkerJob->GetTerminateSessionReason());

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNWTSendNameTableVersion
//
//	Send NAMETABLE_VERSION message to the host player

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendNameTableVersion"

HRESULT DNWTSendNameTableVersion(DIRECTNETOBJECT *const pdnObject,
								 CWorkerJob *const pWorkerJob)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableEntry	*pHostPlayer;
	CConnection		*pConnection;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	pRefCountBuffer = NULL;
	pHostPlayer = NULL;
	pConnection = NULL;

	//
	//	Extract and clear RefCountBuffer from job
	//
	DNASSERT(pWorkerJob->GetRefCountBuffer() != NULL);
	pRefCountBuffer = pWorkerJob->GetRefCountBuffer();
	pWorkerJob->SetRefCountBuffer( NULL );

	// Send message to host player
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get Connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_NAMETABLE_VERSION,
								pHostPlayer->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								1,
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send message to Host player");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
		goto Failure;
	}
	pConnection->Release();
	pConnection = NULL;
	pHostPlayer->Release();
	pHostPlayer = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))

//	DNWTRemoveServiceProvider
//
//	Remove a ServiceProvider from the Protocol

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTRemoveServiceProvider"

HRESULT DNWTRemoveServiceProvider(DIRECTNETOBJECT *const pdnObject,
								  CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pWorkerJob->GetRemoveServiceProviderHandle() != NULL);

	hResultCode = DNPRemoveServiceProvider(pdnObject->pdnProtocolData,pWorkerJob->GetRemoveServiceProviderHandle());

	DNProtocolRelease(pdnObject);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP


//	DNWTSendNameTableOperation
//
//	Send a NameTable operation to each connected player
//	This is based on the version number supplied and an excluded DPNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendNameTableOperation"

void DNWTSendNameTableOperation(DIRECTNETOBJECT *const pdnObject,
								CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CBilink		*pBilink;
	CNameTableEntry	*pNTEntry;
	DWORD		dwMsgId;
	DWORD		dwVersion;
	DPNID		dpnidExclude;
	DWORD		dwCount;
	DWORD		dwActual;
	DWORD		dw;
	CConnection **TargetList;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	pParent = NULL;
	pNTEntry = NULL;
	TargetList = NULL;

	dwMsgId = pWorkerJob->GetSendNameTableOperationMsgId();
	dwVersion = pWorkerJob->GetSendNameTableOperationVersion();
	dpnidExclude = pWorkerJob->GetSendNameTableOperationDPNIDExclude();

	hResultCode = DNCreateSendParent(	pdnObject,
										dwMsgId,
										pWorkerJob->GetRefCountBuffer()->BufferDescAddress(),
										1,
										DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_COALESCE,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pParent->SetRefCountBuffer(pWorkerJob->GetRefCountBuffer());

	//
	//	Lock NameTable
	//
	pdnObject->NameTable.ReadLock();

	//
	//	Determine recipient list
	//
	dwCount = 0;
	dwActual = 0;
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		if (	   !pNTEntry->IsDisconnecting()
				&& !pNTEntry->IsLocal()
				&& ((dwVersion == 0) || (pNTEntry->GetVersion() < dwVersion))
				&& ((dpnidExclude == 0) || (pNTEntry->GetDPNID() != dpnidExclude))
			)
		{
			dwCount++;
		}
		pBilink = pBilink->GetNext();
	}
	DPFX(DPFPREP, 7,"Number of targets [%ld]",dwCount);

	//
	//	Create target list
	//
	if (dwCount > 0)
	{
		if ((TargetList = reinterpret_cast<CConnection**>(MemoryBlockAlloc(pdnObject,dwCount * sizeof(CConnection*)))) == NULL)
		{
			DPFERR("Could not create target list");
			DNASSERT(FALSE);
			goto Failure;
		}

		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			if (	   !pNTEntry->IsDisconnecting()
					&& !pNTEntry->IsLocal()
					&& ((dwVersion == 0) || (pNTEntry->GetVersion() < dwVersion))
					&& ((dpnidExclude == 0) || (pNTEntry->GetDPNID() != dpnidExclude))
				)
			{
				DNASSERT(dwActual < dwCount);
				if ((hResultCode = pNTEntry->GetConnectionRef( &(TargetList[dwActual]) )) == DPN_OK)
				{
					dwActual++;
				}
			}
			pBilink = pBilink->GetNext();
		}
		DPFX(DPFPREP, 7,"Actual number of targets [%ld]",dwActual);
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	//
	//	Send to target list
	//
	if (TargetList)
	{
		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DNASSERT(TargetList[dw] != NULL);

			hResultCode = DNPerformChildSend(	pdnObject,
												pParent,
												TargetList[dw],
												0,
												NULL,
												TRUE);
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not perform part of group send - ignore and continue");
				DisplayDNError(0,hResultCode);
				DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
			}
			TargetList[dw]->Release();
			TargetList[dw] = NULL;
		}

		MemoryBlockFree(pdnObject,TargetList);
		TargetList = NULL;
	}

	pParent->Release();
	pParent = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning");
	return;

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (TargetList)
	{
		MemoryBlockFree(pdnObject,TargetList);
		TargetList = NULL;
	}
	goto Exit;
}

//	DNWTSendNameTableOperationClient
//
//	Send a NameTable operation to a single client
//	This is based on the version number supplied and a DPNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTSendNameTableOperationClient"

void DNWTSendNameTableOperationClient(DIRECTNETOBJECT *const pdnObject,
									  CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CNameTableEntry	*pNTEntry;
	DWORD		dwMsgId;
	DWORD		dwVersion;
	DPNID		dpnid;
	CConnection *pConnection;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	pParent = NULL;
	pNTEntry = NULL;
	pConnection = NULL;

	dwMsgId = pWorkerJob->GetSendNameTableOperationMsgId();
	dwVersion = pWorkerJob->GetSendNameTableOperationVersion();
	dpnid = pWorkerJob->GetSendNameTableOperationDPNIDExclude();

	hResultCode = DNCreateSendParent(	pdnObject,
										dwMsgId,
										pWorkerJob->GetRefCountBuffer()->BufferDescAddress(),
										1,
										DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_COALESCE,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pParent->SetRefCountBuffer(pWorkerJob->GetRefCountBuffer());

	//
	//	Lookup player
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get connection for player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DNPerformChildSend(	pdnObject,
										pParent,
										pConnection,
										0,
										NULL,
										TRUE);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not perform send - ignore and continue");
		DisplayDNError(0,hResultCode);
		DNASSERT(hResultCode != DPN_OK);	// it was sent guaranteed, it should not return immediately
	}
	pConnection->Release();
	pConnection = NULL;

	pParent->Release();
	pParent = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning");
	return;

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}

//	DNWTInstallNameTable
//
//	Install the Host sent NameTable and ApplicationDescription.  We will also be cracking open
//	LISTENs if required.  This has to be done on the worker thread due to the async->sync
//	behaviour of LISTEN.  We can't perform it on the SP's threads.

#undef DPF_MODNAME
#define DPF_MODNAME "DNWTInstallNameTable"

void DNWTInstallNameTable(DIRECTNETOBJECT *const pdnObject,
						  CWorkerJob *const pWorkerJob)
{
	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	DNASSERT(pWorkerJob->GetConnection() != NULL);
	DNASSERT(pWorkerJob->GetRefCountBuffer() != NULL);

	DNConnectToHost2(	pdnObject,
						pWorkerJob->GetRefCountBuffer()->GetBufferAddress(),
						pWorkerJob->GetConnection() );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNWTPerformListen"

void DNWTPerformListen(DIRECTNETOBJECT *const pdnObject,
					   CWorkerJob *const pWorkerJob)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pWorkerJob [0x%p]",pWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pWorkerJob != NULL);

	DNASSERT(pWorkerJob->GetAddress() != NULL);
	DNASSERT(pWorkerJob->GetAsyncOp() != NULL);

	hResultCode = DNPerformListen(pdnObject,pWorkerJob->GetAddress(),pWorkerJob->GetAsyncOp());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addbase.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addbase.h
 *  Content:    DirectPlay8Address Base interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses 
 * 03/24/2000	rmt		Added IsEqual function
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ADDBASE_H__
#define	__ADDBASE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for client interface
//
extern IDirectPlay8AddressVtbl DP8A_BaseVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// 
//
STDMETHODIMP DP8A_BuildFromURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress );
STDMETHODIMP DP8A_BuildFromURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress );
STDMETHODIMP DP8A_Duplicate( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS *ppInterface );
STDMETHODIMP DP8A_Clear( IDirectPlay8Address *pInterface );
STDMETHODIMP DP8A_GetURLW( IDirectPlay8Address *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressSize );
STDMETHODIMP DP8A_GetURLA( IDirectPlay8Address *pInterface, CHAR * pszAddress, PDWORD pdwAddressSize );
STDMETHODIMP DP8A_GetSP( IDirectPlay8Address *pInterface, GUID * pguidSP );
STDMETHODIMP DP8A_GetDevice( IDirectPlay8Address *pInterface, GUID * pguidSP );
STDMETHODIMP DP8A_GetUserData( IDirectPlay8Address *pInterface, void * pvUserData, PDWORD pdwBufferSize );
STDMETHODIMP DP8A_SetDevice( IDirectPlay8Address *pInterface, const GUID * const pguidSP );
STDMETHODIMP DP8A_SetSP( IDirectPlay8Address *pInterface, const GUID * const pguidSP );
STDMETHODIMP DP8A_SetUserData( IDirectPlay8Address *pInterface, const void * const pBuffer, const DWORD dwBufferSize );
STDMETHODIMP DP8A_GetNumComponents( IDirectPlay8Address *pInterface, PDWORD pdwNumComponents );
STDMETHODIMP DP8A_GetComponentByIndexW( IDirectPlay8Address *pInterface, const DWORD dwComponentID, WCHAR * pwszTag, PDWORD pdwNameLen, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
STDMETHODIMP DP8A_GetComponentByNameW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
STDMETHODIMP DP8A_AddComponentW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType );
STDMETHODIMP DP8A_BuildFromDirectPlay4Address( IDirectPlay8Address *pInterface, void * pvDataBuffer, DWORD dwDataSize );
STDMETHODIMP DP8A_SetEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8Address );
STDMETHODIMP DP8A_IsEqual( IDirectPlay8Address *pInterface, PDIRECTPLAY8ADDRESS pdp8Address );

#endif	// __CLIENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\workerjob.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       WorkerJob.h
 *  Content:    Worker Job Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/00	mjn		Created
 *	08/08/00	mjn		Added m_pAddress,m_pAsyncOp,WORKER_JOB_PERFORM_LISTEN
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__WORKER_JOB_H__
#define	__WORKER_JOB_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CAsyncOp;
class CConnection;
class CRefCountBuffer;

typedef struct IDirectPlay8Address	IDirectPlay8Address;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

typedef enum
{
//	WORKER_JOB_ABORT_CONNECT,
	WORKER_JOB_INSTALL_NAMETABLE,
	WORKER_JOB_INTERNAL_SEND,
	WORKER_JOB_PERFORM_LISTEN,
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
	WORKER_JOB_REMOVE_SERVICE_PROVIDER,
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
	WORKER_JOB_SEND_NAMETABLE_OPERATION,
	WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT,
	WORKER_JOB_SEND_NAMETABLE_VERSION,
	WORKER_JOB_TERMINATE_SESSION,
	WORKER_JOB_UNKNOWN
} WORKER_JOB_TYPE;

typedef struct
{
	DWORD				dwFlags;
} WORKER_JOB_INTERNAL_SEND_DATA;

#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
typedef struct
{
	HANDLE		hProtocolSPHandle;
} WORKER_JOB_REMOVE_SERVICE_PROVIDER_DATA;
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP

typedef struct
{
	DWORD			dwMsgId;
	DWORD			dwVersion;
	DPNID			dpnidExclude;
} WORKER_JOB_SEND_NAMETABLE_OPERATION_DATA;

typedef struct
{
	HRESULT		hrReason;
} WORKER_JOB_TERMINATE_SESSION_DATA;

typedef union
{
	WORKER_JOB_INTERNAL_SEND_DATA				InternalSend;
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
	WORKER_JOB_REMOVE_SERVICE_PROVIDER_DATA		RemoveServiceProvider;
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP
	WORKER_JOB_SEND_NAMETABLE_OPERATION_DATA	SendNameTableOperation;
	WORKER_JOB_TERMINATE_SESSION_DATA			TerminateSession;
} WORKER_JOB_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Worker Thread Jobs

class CWorkerJob
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::FPMAlloc"
	static BOOL FPMAlloc( void* pvItem, void* pvContext )
		{
			CWorkerJob* pWorkerJob = (CWorkerJob*)pvItem;

			pWorkerJob->m_Sig[0] = 'W';
			pWorkerJob->m_Sig[1] = 'J';
			pWorkerJob->m_Sig[2] = 'O';
			pWorkerJob->m_Sig[3] = 'B';

#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
			pWorkerJob->m_bilinkWorkerJobs.Initialize();
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::FPMInitialize"
	static void FPMInitialize( void* pvItem, void* pvContext )
		{
			CWorkerJob* pWorkerJob = (CWorkerJob*)pvItem;

			pWorkerJob->m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			pWorkerJob->m_JobType = WORKER_JOB_UNKNOWN;
			pWorkerJob->m_pAsyncOp = NULL;
			pWorkerJob->m_pConnection = NULL;
			pWorkerJob->m_pRefCountBuffer = NULL;
			pWorkerJob->m_pAddress = NULL;
#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
			pWorkerJob->m_dwRequeueCount = 0;

			DNASSERT(pWorkerJob->m_bilinkWorkerJobs.IsEmpty());
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::FPMRelease"
	static void FPMRelease( void* pvItem) 
		{ 
			const CWorkerJob* pWorkerJob = (CWorkerJob*)pvItem;

#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
			DNASSERT(pWorkerJob->m_bilinkWorkerJobs.IsEmpty());
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			if (m_pAsyncOp)
			{
				m_pAsyncOp->Release();
				m_pAsyncOp = NULL;
			}
			if (m_pConnection)
			{
				m_pConnection->Release();
				m_pConnection = NULL;
			}
			if (m_pRefCountBuffer)
			{
				m_pRefCountBuffer->Release();
				m_pRefCountBuffer = NULL;
			}
			if (m_pAddress)
			{
				IDirectPlay8Address_Release( m_pAddress );
				m_pAddress = NULL;
			}

			DNASSERT(m_pConnection == NULL);
			DNASSERT(m_pRefCountBuffer == NULL);

			g_WorkerJobPool.Release( this );
		};

	void SetJobType( const WORKER_JOB_TYPE JobType )
		{
			m_JobType = JobType;
		};

	WORKER_JOB_TYPE GetJobType( void ) const
		{
			return( m_JobType );
		};

	void SetConnection( CConnection *const pConnection )
		{
			if (pConnection)
			{
				pConnection->AddRef();
			}
			m_pConnection = pConnection;
		};

	CConnection *GetConnection( void )
		{
			return( m_pConnection );
		};

	void SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer )
		{
			if (pRefCountBuffer)
			{
				pRefCountBuffer->AddRef();
			}
			m_pRefCountBuffer = pRefCountBuffer;
		};

	CRefCountBuffer *GetRefCountBuffer( void )
		{
			return( m_pRefCountBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetInternalSendFlags"
	void SetInternalSendFlags( const DWORD dwFlags )
		{
			DNASSERT( m_JobType == WORKER_JOB_INTERNAL_SEND );

			m_JobData.InternalSend.dwFlags = dwFlags;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetInternalSendFlags"
	DWORD GetInternalSendFlags( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_INTERNAL_SEND );

			return( m_JobData.InternalSend.dwFlags );
		};

#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONESP)))
	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetRemoveServiceProviderHandle"
	void SetRemoveServiceProviderHandle( const HANDLE hProtocolSPHandle )
		{
			DNASSERT( m_JobType == WORKER_JOB_REMOVE_SERVICE_PROVIDER );

			m_JobData.RemoveServiceProvider.hProtocolSPHandle = hProtocolSPHandle;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetRemoveServiceProviderHandle"
	HANDLE GetRemoveServiceProviderHandle( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_REMOVE_SERVICE_PROVIDER );

			return( m_JobData.RemoveServiceProvider.hProtocolSPHandle );
		};
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONESP

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetSendNameTableOperationMsgId"
	void SetSendNameTableOperationMsgId( const DWORD dwMsgId )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			m_JobData.SendNameTableOperation.dwMsgId = dwMsgId;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetSendNameTableOperationMsgId"
	DWORD GetSendNameTableOperationMsgId( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			return( m_JobData.SendNameTableOperation.dwMsgId );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetSendNameTableOperationVersion"
	void SetSendNameTableOperationVersion( const DWORD dwVersion )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			m_JobData.SendNameTableOperation.dwVersion = dwVersion;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetSendNameTableOperationVersion"
	DWORD GetSendNameTableOperationVersion( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			return( m_JobData.SendNameTableOperation.dwVersion );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetSendNameTableOperationDPNIDExclude"
	void SetSendNameTableOperationDPNIDExclude( const DPNID dpnidExclude )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			m_JobData.SendNameTableOperation.dpnidExclude = dpnidExclude;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetSendNameTableOperationDPNIDExclude"
	DPNID GetSendNameTableOperationDPNIDExclude( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION ||
					  m_JobType == WORKER_JOB_SEND_NAMETABLE_OPERATION_CLIENT);

			return( m_JobData.SendNameTableOperation.dpnidExclude );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::SetTerminateSessionReason"
	void SetTerminateSessionReason( const HRESULT hrReason )
		{
			DNASSERT( m_JobType == WORKER_JOB_TERMINATE_SESSION );

			m_JobData.TerminateSession.hrReason = hrReason;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::GetTerminateSessionReason"
	HRESULT GetTerminateSessionReason( void )
		{
			DNASSERT( m_JobType == WORKER_JOB_TERMINATE_SESSION );

			return( m_JobData.TerminateSession.hrReason );
		};

	void SetAsyncOp( CAsyncOp *const pAsyncOp )
		{
			if (pAsyncOp)
			{
				pAsyncOp->AddRef();
			}
			m_pAsyncOp = pAsyncOp;
		};

	CAsyncOp *GetAsyncOp( void )
		{
			return( m_pAsyncOp );
		};

	void SetAddress( IDirectPlay8Address *const pAddress )
		{
			if (pAddress)
			{
				IDirectPlay8Address_AddRef( pAddress );
			}
			m_pAddress = pAddress;
		};

	IDirectPlay8Address *GetAddress( void )
		{
			return( m_pAddress );
		};

	DIRECTNETOBJECT *GetDNObject( void )
		{
			return( m_pdnObject );
		};

#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	#undef DPF_MODNAME
	#define DPF_MODNAME "CWorkerJob::IncRequeueCount"
	DWORD IncRequeueCount( void )
		{
			DWORD	dwPrevRequeueCount;

			dwPrevRequeueCount = m_dwRequeueCount;
			DNASSERT( dwPrevRequeueCount < 10000 );
			m_dwRequeueCount++;
			return( dwPrevRequeueCount );
		};


	CBilink				m_bilinkWorkerJobs;
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE


private:
	BYTE				m_Sig[4];			// Signature

	WORKER_JOB_TYPE		m_JobType;

	CAsyncOp			*m_pAsyncOp;
	CConnection			*m_pConnection;
	CRefCountBuffer		*m_pRefCountBuffer;
	IDirectPlay8Address	*m_pAddress;
#ifndef DPNBUILD_NONSEQUENTIALWORKERQUEUE
	DWORD				m_dwRequeueCount;
#endif // ! DPNBUILD_NONSEQUENTIALWORKERQUEUE

	WORKER_JOB_DATA		m_JobData;

	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __WORKER_JOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\core\verify.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Verify.h
 *  Content:    On-wire message verification header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	12/05/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__VERIFY_H__
#define	__VERIFY_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNVerifyApplicationDescInfo(void *const pOpBuffer,
									const DWORD dwOpBufferSize,
									void *const pData);

HRESULT DNVerifyNameTableEntryInfo(void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   void *const pData);

HRESULT DNVerifyNameTableInfo(void *const pOpBuffer,
							  const DWORD dwOpBufferSize,
							  void *const pData);

HRESULT DNVerifyPlayerConnectInfo(void *const pOpBuffer,
								  const DWORD dwOpBufferSize);

HRESULT DNVerifyConnectInfo(void *const pOpBuffer,
							const DWORD dwOpBufferSize);

HRESULT DNVerifySendPlayerDPNID(void *const pOpBuffer,
								const DWORD dwOpBufferSize);

HRESULT DNVerifyConnectFailed(void *const pOpBuffer,
							  const DWORD dwOpBufferSize);

HRESULT DNVerifyInstructConnect(void *const pOpBuffer,
								const DWORD dwOpBufferSize);

HRESULT DNVerifyInstructedConnectFailed(void *const pOpBuffer,
										const DWORD dwOpBufferSize);

HRESULT DNVerifyConnectAttemptFailed(void *const pOpBuffer,
									 const DWORD dwOpBufferSize);

#ifndef DPNBUILD_NOHOSTMIGRATE
HRESULT DNVerifyNameTableVersion(void *const pOpBuffer,
								 const DWORD dwOpBufferSize);

HRESULT DNVerifyResyncVersion(void *const pOpBuffer,
							  const DWORD dwOpBufferSize);

HRESULT DNVerifyReqNameTableOp(void *const pOpBuffer,
							   const DWORD dwOpBufferSize);

HRESULT DNVerifyAckNameTableOp(void *const pOpBuffer,
							   const DWORD dwOpBufferSize);

HRESULT DNVerifyHostMigrate(void *const pOpBuffer,
							const DWORD dwOpBufferSize);
#endif // DPNBUILD_NOHOSTMIGRATE

HRESULT DNVerifyDestroyPlayer(void *const pOpBuffer,
							  const DWORD dwOpBufferSize);

HRESULT DNVerifyCreateGroup(void *const pOpBuffer,
							const DWORD dwOpBufferSize,
							void *const pData);

HRESULT DNVerifyDestroyGroup(void *const pOpBuffer,
							 const DWORD dwOpBufferSize);

HRESULT DNVerifyAddPlayerToGroup(void *const pOpBuffer,
								 const DWORD dwOpBufferSize);

HRESULT DNVerifyDeletePlayerFromGroup(void *const pOpBuffer,
									  const DWORD dwOpBufferSize);

HRESULT DNVerifyUpdateInfo(void *const pOpBuffer,
						   const DWORD dwOpBufferSize,
						   void *const pData);

HRESULT DNVerifyReqCreateGroup(void *const pOpBuffer,
							   const DWORD dwOpBufferSize,
							   void *const pData);

HRESULT DNVerifyReqDestroyGroup(void *const pOpBuffer,
								const DWORD dwOpBufferSize);

HRESULT DNVerifyReqAddPlayerToGroup(void *const pOpBuffer,
									const DWORD dwOpBufferSize);

HRESULT DNVerifyReqDeletePlayerFromGroup(void *const pOpBuffer,
										 const DWORD dwOpBufferSize);

HRESULT DNVerifyReqUpdateInfo(void *const pOpBuffer,
							  const DWORD dwOpBufferSize,
							  void *const pData);

HRESULT DNVerifyRequestFailed(void *const pOpBuffer,
							  const DWORD dwOpBufferSize);

HRESULT DNVerifyTerminateSession(void *const pOpBuffer,
								 const DWORD dwOpBufferSize);

HRESULT DNVerifyReqProcessCompletion(void *const pOpBuffer,
									 const DWORD dwOpBufferSize);

HRESULT DNVerifyProcessCompletion(void *const pOpBuffer,
								  const DWORD dwOpBufferSize);

HRESULT DNVerifyReqIntegrityCheck(void *const pOpBuffer,
								  const DWORD dwOpBufferSize);

HRESULT DNVerifyIntegrityCheck(void *const pOpBuffer,
							   const DWORD dwOpBufferSize);

HRESULT DNVerifyIntegrityCheckResponse(void *const pOpBuffer,
									   const DWORD dwOpBufferSize);

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __VERIFY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addglobals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Globals.cpp
 *  Content:    Definition of global variables.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   07/21/99	mjn		Created
 *	 07/13/2000	rmt		Added critical sections to protect FPMs
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


//
//	Global Variables
//

#ifndef DPNBUILD_LIBINTERFACE
LONG g_lAddrObjectCount = 0;
#endif // ! DPNBUILD_LIBINTERFACE

CFixedPool fpmAddressObjects;
CFixedPool fpmAddressElements;

CStringCache *g_pcstrKeyCache = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addparse.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:   Parsing engine
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date         By      Reason
 *   ====       ==      ======
 *  02/04/2000	 rmt	  Created
 *  02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __ADDPARSE_H
#define __ADDPARSE_H

#include "Addcore.h"

class DP8ADDRESSPARSE
{
protected:

	typedef enum { 
		DP8AP_IDLE,
		DP8AP_KEY,
		DP8AP_VALUE,
		DP8AP_USERDATA
	} DP8AP_STATE;
	
public:

	DP8ADDRESSPARSE();
	~DP8ADDRESSPARSE();

	HRESULT ParseURL( DP8ADDRESSOBJECT *pdp8aObject, WCHAR *pstrURL );

protected:

	BOOL IsValidHex( WCHAR ch );
	static BOOL IsValidKeyChar(WCHAR ch);
	static BOOL IsValidKeyTerminator(WCHAR ch);
	BOOL IsValidValueChar(WCHAR ch);
	BOOL IsValidValueTerminator(WCHAR ch);
	static BOOL IsValidNumber(WCHAR ch );

	static WCHAR HexToChar( const WCHAR *sz );

	HRESULT FSM_Key();
	HRESULT FSM_Value();
	HRESULT FSM_UserData();
	HRESULT FSM_CommitEntry(DP8ADDRESSOBJECT *pdp8aObject);

	WCHAR *m_pwszCurrentLocation;	// Current Location in string

	WCHAR *m_pwszCurrentKey;		// Key will be placed here as we build
	WCHAR *m_pwszCurrentValue;		// Value will be placed here as we build
	BYTE *m_pbUserData;
	DWORD m_dwUserDataSize;
	DP8AP_STATE m_dp8State;		// Current State 
	BOOL m_fNonNumeric;
	DWORD m_dwLenURL;
	DWORD m_dwValueLen;
	
};

#endif // __ADDPARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addcore.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addcore.h
 *  Content:    DIRECTPLAY8ADDRESS CORE HEADER FILE
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/04/2000	rmt		Created
 *  02/17/2000	rmt		Added new defines for 
 *  02/17/2000	rmt		Parameter validation work 
 *  02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls 
 *  07/09/2000	rmt		Added signature bytes to start of address objects
 *  07/13/2000	rmt		Bug #39274 - INT 3 during voice run
 *  07/21/2000	rmt		Bug #39940 - Addressing library doesn't properly parse stopbits in URLs
 *   7/31/2000  RichGr  IA64: FPM_Release() overwrites first 8 bytes of chunk of memory on IA64.
 *                      Rearrange positions of members of affected structs so that's OK.  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ADDCORE_H
#define	__ADDCORE_H

class CStringCache;

// Length of a single byte of userdata 
#define DNURL_LENGTH_USERDATA_BYTE	1

// Header length (14 chars + null terminator)
#define DNURL_LENGTH_HEADER			15

// Includes escaped brackets
#define DNURL_LENGTH_GUID			42

// Just the number, in decimal
#define DNURL_LENGTH_DWORD			10

// The length of the seperator for user data
#define DNURL_LENGTH_USERDATA_SEPERATOR	1

// The right length for one byte of escaped data
#define DNURL_LENGTH_BINARY_BYTE	3

#ifdef DPNBUILD_ONLYONESP
// DPNA_KEY_PROVIDER DPNA_SEPARATOR_KEYVALUE CLSID_DP8SP_TCPIP encoded
#define DPNA_BUILTINPROVIDER				DPNA_KEY_PROVIDER L"=%7BEBFE7BA0-628D-11D2-AE0F-006097B01411%7D"
// Characters in the above string, not including NULL terminator
#define DNURL_LENGTH_BUILTINPROVIDER		(8 + 1 + DNURL_LENGTH_GUID)
#endif // DPNBUILD_ONLYONESP


#define DP8A_ENTERLEVEL			2
#define DP8A_INFOLEVEL			7
#define DP8A_ERRORLEVEL			0
#define DP8A_WARNINGLEVEL		1
#define DP8A_PARAMLEVEL			3

extern const WCHAR *g_szBaseStrings[];
extern const DWORD g_dwBaseRequiredTypes[];
extern const DWORD c_dwNumBaseStrings;

#ifndef DPNBUILD_NOPARAMVAL

#ifdef DBG
extern BOOL IsValidDP8AObject( LPVOID lpvObject );
#define DP8A_VALID(a) 	IsValidDP8AObject( a )
#else // !DBG
#define DP8A_VALID(a)  TRUE
#endif // !DBG

#endif // !DPNBUILD_NOPARAMVAL



#define DP8A_RETURN( x ) 	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Function returning hr=0x%x", x ); \
							return x;

extern CFixedPool fpmAddressObjects;
extern CFixedPool fpmAddressElements;

extern CStringCache *g_pcstrKeyCache;

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
#define DP8ADDRESS_ELEMENT_HEAP	0x00000001
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

#define DPASIGNATURE_ELEMENT		'LEAD'
#define DPASIGNATURE_ELEMENT_FREE	'LEA_'

#define DPASIGNATURE_ADDRESS		'BOAD'
#define DPASIGNATURE_ADDRESS_FREE	'BOA_'

// DP8ADDRESSELEMENT
//
// This structure contains all the information about a single element of the 
// address.  These address elements are allocated from a central, fixed
//
//  7/31/2000(RichGr) - IA64: FPM_Release() overwrites first 8 bytes.  Rearrange position of dwSignature so that's OK.
#define MAX_EMBEDDED_STRING_LENGTH		64 // in wide characters (i.e. 128 bytes)
typedef struct _DP8ADDRESSELEMENT
{
	DWORD dwTagSize;			// Size of the tag
	DWORD dwType;				// Element type DNADDRESS8_DATATYPE_XXXXXX
	DWORD dwDataSize;			// Size of the data
	DWORD dwStringSize;
	DWORD dwSignature;          // Element debug signature
	WCHAR *pszTag;	            // Tag for the element.  
	DWORD dwFlags;				// Flags DNADDRESSELEMENT_XXXX
	union 
	{
		GUID guidData;
		DWORD dwData;
		WCHAR szData[MAX_EMBEDDED_STRING_LENGTH];
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
		PVOID pvData;
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	} uData;					// Union 
	CBilink blAddressElements;	// Bilink of address elements
} DP8ADDRESSELEMENT, *PDP8ADDRESSELEMENT;

// DP8ADDRESSELEMENT
// 
// Data structure representing the address itself
class DP8ADDRESSOBJECT
{
public:
#ifdef DPNBUILD_LIBINTERFACE
	//
	// For lib interface builds, the interface Vtbl and refcount are embedded
	// in the object itself.
	//
	LPVOID		lpVtbl;		// must be first entry in structure
	LONG		lRefCount;
#endif // DPNBUILD_LIBINTERFACE

	HRESULT Cleanup();
	HRESULT Clear();
	HRESULT Copy( DP8ADDRESSOBJECT * const pAddressSource );
	HRESULT Init();
	HRESULT SetElement( const WCHAR * const pszTag, const void * const pvData, const DWORD dwDataSize, const DWORD dwDataType );
	HRESULT GetElement( DWORD dwIndex, WCHAR * pszTag, PDWORD pdwTagSize, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType );
	HRESULT GetElement( const WCHAR * const pszTag, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType );
#ifndef DPNBUILD_ONLYONESP
	HRESULT GetSP( GUID * pGuid );
	HRESULT SetSP( const GUID*  const pGuid );
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
	HRESULT GetDevice( GUID * pGuid );
	HRESULT SetDevice( const GUID* const pGuid );
#endif // ! DPNBUILD_ONLYONEADAPTER
	HRESULT SetUserData( const void * const pvData, const DWORD dwDataSize );
	HRESULT GetUserData( void * pvDataBuffer, PDWORD pdwDataSize );

	HRESULT BuildURLA( char * szURL, PDWORD pdwRequiredSize )	;
	HRESULT BuildURLW( WCHAR * szURL, PDWORD pdwRequiredSize )	;
	HRESULT SetURL( WCHAR * szURL );

	HRESULT GetElementType( const WCHAR * pszTag, PDWORD pdwType );

    HRESULT SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize );

	inline GetNumComponents() const { return m_dwElements; };

	inline void ENTERLOCK() { DNEnterCriticalSection( &m_csAddressLock ); };
	inline void LEAVELOCK() { DNLeaveCriticalSection( &m_csAddressLock ); };

	static void FPM_Element_BlockInit( void *pvItem, PVOID pvContext );
	static void FPM_Element_BlockRelease( void *pvItem );

	static BOOL FPM_BlockCreate( void *pvItem, PVOID pvContext );
	static void FPM_BlockInit( void *pvItem, PVOID pvContext );
	static void FPM_BlockRelease( void *pvItem );
	static void FPM_BlockDestroy( void *pvItem );
		
protected:

	HRESULT BuildURL_AddElements( WCHAR *szElements );
	static HRESULT BuildURL_AddHeader( WCHAR *szWorking );
	HRESULT BuildURL_AddUserData( WCHAR *szWorking );
	void BuildURL_AddString( WCHAR *szElements, WCHAR *szSource );
	HRESULT BuildURL_AddBinaryData( WCHAR *szSource, BYTE *bData, DWORD dwDataLen );

	HRESULT InternalGetElement( const WCHAR * const pszTag, PDP8ADDRESSELEMENT *ppaElement );
	HRESULT InternalGetElement( const DWORD dwIndex, PDP8ADDRESSELEMENT *ppaElement );
	HRESULT CalcComponentStringSize( PDP8ADDRESSELEMENT paddElement, PDWORD pdwSize );
	DWORD CalcExpandedStringSize( WCHAR *szString );
	DWORD CalcExpandedBinarySize( PBYTE pbData, DWORD dwDataSize );
	static BOOL IsEscapeChar( WCHAR ch );

	DWORD m_dwSignature;
#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION m_csAddressLock;
#endif // !DPNBUILD_ONLYONETHREAD
	DWORD m_dwStringSize;
	DWORD m_dwElements;
#ifndef DPNBUILD_ONLYONESP
	PDP8ADDRESSELEMENT m_pSP;
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
	PDP8ADDRESSELEMENT m_pAdapter;
#endif // ! DPNBUILD_ONLYONEADAPTER
	PVOID m_pvUserData;
	DWORD m_dwUserDataSize;
	DWORD m_dwUserDataStringSize;
	CBilink  m_blAddressElements;

};

typedef DP8ADDRESSOBJECT *PDP8ADDRESSOBJECT;

HRESULT DP8A_STRCACHE_Init();
void DP8A_STRCACHE_Free();
 

#endif // __ADDCORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addparse.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:   Parsing engine
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date         By      Reason
 *   ====       ==      ======
 *  02/04/2000	 rmt	  Created
 * 02/17/2000	rmt		Parameter validation work
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 *  07/21/2000	rmt		Bug #39940 - Addressing library doesn't properly parse stopbits in URLs 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::DP8ADDRESSPARSE"
DP8ADDRESSPARSE::DP8ADDRESSPARSE(
	):	m_pwszCurrentLocation(NULL),
		m_pwszCurrentKey(NULL),
		m_pwszCurrentValue(NULL),
		m_pbUserData(NULL),
		m_dwUserDataSize(0),
		m_dp8State(DP8AP_IDLE),
		m_dwLenURL(0)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::~DP8ADDRESSPARSE"
DP8ADDRESSPARSE::~DP8ADDRESSPARSE()
{
	if( m_pwszCurrentKey != NULL )
	{
		DNFree(m_pwszCurrentKey);
	}

	if( m_pwszCurrentValue != NULL )
	{
		DNFree(m_pwszCurrentValue);
	}

	if ( m_pbUserData != NULL )
	{
		DNFree(m_pbUserData);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::ParseURL"
HRESULT DP8ADDRESSPARSE::ParseURL( DP8ADDRESSOBJECT *dp8aObject, WCHAR *pstrURL )
{
	HRESULT hr;
	
	if( m_pwszCurrentKey != NULL )
	{
		DNFree(m_pwszCurrentKey);
		m_pwszCurrentKey = NULL;
	}

	if( m_pwszCurrentValue != NULL )
	{
		DNFree(m_pwszCurrentValue);
		m_pwszCurrentValue = NULL;
	}

	if( m_pbUserData != NULL )
	{
		DNFree(m_pbUserData);
		m_pbUserData = NULL;
	}	

	m_dwUserDataSize = 0;

	m_pwszCurrentLocation = pstrURL;

	m_dwLenURL = wcslen(pstrURL);

	if( m_dwLenURL < wcslen( DPNA_HEADER ) )
	{
		DPFX(DPFPREP,  0, "Invalid URL" );
		return DPNERR_INVALIDURL;
	}

	if( wcsncmp( pstrURL, DPNA_HEADER, wcslen(DPNA_HEADER) ) != 0 )
	{
		DPFX(DPFPREP,  0, "No header, invalid URL" );
		return DPNERR_INVALIDURL;
	}

	m_pwszCurrentLocation += wcslen( DPNA_HEADER );

	m_pwszCurrentKey = (WCHAR*) DNMalloc((m_dwLenURL+1)*sizeof(WCHAR));
	if( !m_pwszCurrentKey )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;
	}
	m_pwszCurrentValue = (WCHAR*) DNMalloc((m_dwLenURL+1)*sizeof(WCHAR));
	if( !m_pwszCurrentValue )
	{
		DNFree(m_pwszCurrentKey);
		m_pwszCurrentKey = NULL;
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;	
	}
	m_pbUserData = (BYTE*) DNMalloc(m_dwLenURL+1);
	if( !m_pbUserData )
	{
		DNFree(m_pwszCurrentKey);
		DNFree(m_pwszCurrentValue);
		m_pwszCurrentKey = NULL;
		m_pwszCurrentValue = NULL;
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;	
	}

	m_dp8State = DP8AP_IDLE;

	// Loop until the string is done
	while( *m_pwszCurrentLocation != L'\0' )
	{
		switch( m_dp8State )
		{
		case DP8AP_IDLE:
			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_USERDATA )
			{
				m_dp8State = DP8AP_USERDATA;
				m_pwszCurrentLocation++;
			}
			else
			{
				m_dp8State = DP8AP_KEY;
			}
			break;
		case DP8AP_KEY:

			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_USERDATA )
			{
				m_dp8State = DP8AP_USERDATA;
				m_pwszCurrentLocation++;
				break;
			}

			hr = FSM_Key();

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error parsing key hr = 0x%x", hr );
				return hr;	
			}

			// Parse ended with an equals
			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_KEYVALUE )
			{
				m_dp8State = DP8AP_VALUE;
				m_pwszCurrentLocation++;
			}
			else
			{
				DPFX(DPFPREP,  0, "keyname without associated value hr=0x%x", hr );
				return DPNERR_INVALIDURL;
			}

			break;
		case DP8AP_VALUE:

			hr = FSM_Value();

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error parsing value hr=0x%x", hr );
				return hr;
			}

			// Parse ended with an equals
			if( *m_pwszCurrentLocation == DPNA_SEPARATOR_COMPONENT )
			{
				m_dp8State = DP8AP_KEY;
				m_pwszCurrentLocation++;
			}
			else if( *m_pwszCurrentLocation == DPNA_SEPARATOR_USERDATA )
			{
				m_dp8State = DP8AP_USERDATA;
				m_pwszCurrentLocation++;
			}
			else if( *m_pwszCurrentLocation == L'\0' )
			{
				m_dp8State = DP8AP_IDLE;
			}
			else
			{
				DPFX(DPFPREP,  0, "Error parsing next key" );
				hr = DPNERR_INVALIDURL;
				return hr;
			}

			hr = FSM_CommitEntry(dp8aObject);

			if( hr == DPNERR_INVALIDPARAM )
			{
				DPFX(DPFPREP,  0, "Invalid value specified in URL hr=0x%x", hr );
				hr = DPNERR_INVALIDURL;
				return hr;
			}
			else if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error commiting entry hr=0x%x", hr );
				return hr;
			}

			break;
			
		case DP8AP_USERDATA:

			hr = FSM_UserData();

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error parsing user data hr=0x%x", hr );
				return hr;
			}

			hr = dp8aObject->SetUserData( m_pbUserData, m_dwUserDataSize );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error setting user data hr=0x%x", hr );
				return hr;
			}

			break;
		}
	}

	if( m_dp8State != DP8AP_IDLE &&
	    m_dp8State != DP8AP_USERDATA )
	{
		DPFX(DPFPREP,  0, "Parsing error hr=0x%x", hr );
		hr = DPNERR_INVALIDURL;
		return hr;
	}

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidKeyChar"
BOOL DP8ADDRESSPARSE::IsValidKeyChar( WCHAR ch )
{
	if( ch >= L'A' && ch <= L'Z' )
		return TRUE;

	if( ch >= L'a' && ch <= L'z' )
		return TRUE;

	if( ch >= L'0' && ch <= L'9' )
		return TRUE;

	if( ch == L'-' || ch == L'?' || ch == L'.' ||
		ch == L',' || ch == L'+' || ch == L'_' )
		return TRUE;

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidKeyTerminator"
BOOL DP8ADDRESSPARSE::IsValidKeyTerminator( WCHAR ch )
{
	if( ch == 0 )
		return TRUE;

	if( ch == DPNA_SEPARATOR_USERDATA )
		return TRUE;

	if( ch == DPNA_SEPARATOR_COMPONENT )
		return TRUE;

	if( ch == DPNA_SEPARATOR_KEYVALUE )
		return TRUE;

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_Key"
// FSM_Key
//
// Parse a keyname, or return an error on error
//
HRESULT DP8ADDRESSPARSE::FSM_Key()
{
	DWORD dwKeyLoc = 0;
	m_pwszCurrentKey[0] = 0;
	HRESULT hr = DPN_OK;

	while( 1 )
	{
		if( IsValidKeyChar(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentKey[dwKeyLoc] = *m_pwszCurrentLocation;
		}
		else if( IsValidKeyTerminator(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentKey[dwKeyLoc] = 0;
			break;
		}
		else
		{
			m_pwszCurrentKey[dwKeyLoc] = 0;
			hr = DPNERR_INVALIDURL;
			break;
		}

		dwKeyLoc++;
		m_pwszCurrentLocation++;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidNumber"
BOOL DP8ADDRESSPARSE::IsValidNumber( WCHAR ch )
{
	if( ch < L'0' ||
	   ch > L'9' )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::IsValidHex"
BOOL DP8ADDRESSPARSE::IsValidHex( WCHAR ch )
{
	if( IsValidNumber( ch ) )
		return TRUE;

	if( ch >= L'A' || ch <= L'F' )
		return TRUE;

	if( ch >= L'a' || ch <= L'f' )
		return TRUE;

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::HexToChar"
WCHAR DP8ADDRESSPARSE::HexToChar( const WCHAR *sz )
{
	WCHAR chResult = sz[0];

	// First digit
	if( sz[0] >= L'0' && sz[0] <= L'9' )
		chResult = sz[0]-L'0';

	if( sz[0] >= L'A' && sz[0] <= L'F' )
		chResult = sz[0]-L'A'+10;

	if( sz[0] >= L'a' && sz[0] <= L'f' )
		chResult = sz[0]-L'a'+10;

	chResult <<= 4;

	// Second digit
	if( sz[1] >= L'0' && sz[1] <= L'9' )
		chResult += sz[1]-'0';

	if( sz[1] >= L'A' && sz[1] <= L'F' )
		chResult += sz[1]-L'A'+10;

	if( sz[1] >= L'a' && sz[1] <= L'f' )
		chResult += sz[1]-L'a'+10;	

	return chResult;
		
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_Value"
HRESULT DP8ADDRESSPARSE::FSM_Value()
{
	m_fNonNumeric = FALSE;
	m_pwszCurrentValue[0] = 0;
	HRESULT hr = DPN_OK;

	m_dwValueLen = 0;

	while( 1 )
	{
		// Just add it
		if( IsValidKeyChar( *m_pwszCurrentLocation ) )
		{
			m_pwszCurrentValue[m_dwValueLen] = *m_pwszCurrentLocation;

			if( !IsValidNumber( *m_pwszCurrentLocation ) )
			{
				m_fNonNumeric = TRUE;
			}
		}
		// ESCAPE SEQUENCE
		else if( *m_pwszCurrentLocation == DPNA_ESCAPECHAR )
		{
			m_fNonNumeric = TRUE;

			if( *(m_pwszCurrentLocation+1) == DPNA_ESCAPECHAR )
			{
				m_pwszCurrentValue[m_dwValueLen] = DPNA_ESCAPECHAR;
				m_pwszCurrentLocation += 2;
			}
			
			if( wcslen( m_pwszCurrentLocation ) < 3 )
			{
				DPFX(DPFPREP,  0, "Unexpected end in escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			if( !IsValidHex( *(m_pwszCurrentLocation+1) ) ||
			   !IsValidHex( *(m_pwszCurrentLocation+2) ) )
			{
				DPFX(DPFPREP,  0, "Invalid escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			m_pwszCurrentLocation ++;			

			m_pwszCurrentValue[m_dwValueLen] = HexToChar(m_pwszCurrentLocation);

			m_pwszCurrentLocation ++;
		}
		else if( IsValidKeyTerminator(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentValue[m_dwValueLen] = 0;
			break;
		}
		else
		{
			m_pwszCurrentValue[m_dwValueLen] = 0;
			DPFX(DPFPREP,  0, "Unexpected character in URL" );
			hr = DPNERR_INVALIDURL;
			break;
		}

		m_dwValueLen++;
		m_pwszCurrentLocation++;
	}

	if( m_dwValueLen < 1 )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "0 length value" );
		return DPNERR_INVALIDURL;
	}	

	return hr;
}
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_UserData"
HRESULT DP8ADDRESSPARSE::FSM_UserData()
{
	m_pwszCurrentValue[0] = 0;
	HRESULT hr = DPN_OK;
	DWORD dwValueLoc = 0;

	while( 1 )
	{
		// Just add it
		if( IsValidKeyChar( *m_pwszCurrentLocation ) )
		{
			m_pbUserData[dwValueLoc] = (CHAR) *m_pwszCurrentLocation;
		}
		// ESCAPE SEQUENCE
		else if( *m_pwszCurrentLocation == DPNA_ESCAPECHAR )
		{
			if( *(m_pwszCurrentLocation+1) == DPNA_ESCAPECHAR )
			{
				m_pbUserData[dwValueLoc] = DPNA_ESCAPECHAR;
				m_pwszCurrentLocation += 2;
			}
			
			if( wcslen( m_pwszCurrentLocation ) < 3 )
			{
				DPFX(DPFPREP,  0, "Unexpected end in escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			if( !IsValidHex( *(m_pwszCurrentLocation+1) ) ||
			   !IsValidHex( *(m_pwszCurrentLocation+2) ) )
			{
				DPFX(DPFPREP,  0, "Invalid escape sequence" );
				hr = DPNERR_INVALIDURL;
				break;
			}

			m_pwszCurrentLocation ++;			

			m_pbUserData[dwValueLoc] = (CHAR) HexToChar(m_pwszCurrentLocation);

			m_pwszCurrentLocation ++;
		}
		else if( IsValidKeyTerminator(*m_pwszCurrentLocation) )
		{
			m_pwszCurrentValue[dwValueLoc] = 0;
			break;
		}
		else
		{
			m_pwszCurrentValue[dwValueLoc] = 0;
			hr = DPNERR_INVALIDURL;
			break;
		}

		dwValueLoc++;
		m_pwszCurrentLocation++;
	}


	m_dwUserDataSize = dwValueLoc;

	return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSPARSE::FSM_CommitEntry"
HRESULT DP8ADDRESSPARSE::FSM_CommitEntry(DP8ADDRESSOBJECT *pdp8aObject)
{
	DWORD dwDataType = 0xFFFFFFFF;
	
    // Ensure that datatype is correct in case the key is a reserved key
    for( DWORD dwIndex = 0; dwIndex < c_dwNumBaseStrings; dwIndex++ )
    {
	    if( _wcsicmp( g_szBaseStrings[dwIndex], m_pwszCurrentKey ) == 0 )
	    {
		    dwDataType = g_dwBaseRequiredTypes[dwIndex] ;
		    break;
	    }
    }

	// If it's numeric
	if( (dwDataType == DPNA_DATATYPE_DWORD || dwDataType == 0xFFFFFFFF) && !m_fNonNumeric && wcslen(m_pwszCurrentValue)<=10)
	{
		DWORD dwTmpValue;

		dwTmpValue = wcstoul( m_pwszCurrentValue, NULL, 10 );

		return pdp8aObject->SetElement( m_pwszCurrentKey, &dwTmpValue, sizeof(DWORD), DPNA_DATATYPE_DWORD );
	}

	// We've read a GUID
    if (dwDataType == DPNA_DATATYPE_GUID || dwDataType == 0xFFFFFFFF)
    {
		// L"{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}"
		typedef enum
		{
			OpenBrace,
			HexDWord1,
			HexWord1,
			HexWord2,
			DoubleHexBytes,
			HexBytes,
			CloseBrace,
			Invalid,
		} GUID_PARSE_STATE;

		GUID				guidValue;
		GUID_PARSE_STATE	GuidParseState;
		BOOL				fStateChange;
		ULARGE_INTEGER		uliValue;
		WCHAR *				pwcStateStart;
		WCHAR *				pwcCurrent;
		DWORD_PTR			dwLength;


		GuidParseState = OpenBrace;
		fStateChange = FALSE;
		uliValue.QuadPart = 0;
		pwcCurrent = m_pwszCurrentValue;
		pwcStateStart = pwcCurrent;

		//
		// Loop until we run out of string.
		//
		while ((*pwcCurrent) != 0)
		{
			switch (*pwcCurrent)
			{
				case L'0':
				case L'1':
				case L'2':
				case L'3':
				case L'4':
				case L'5':
				case L'6':
				case L'7':
				case L'8':
				case L'9':
				{
					uliValue.QuadPart = uliValue.QuadPart * 16 + ((*pwcCurrent) - L'0');
					break;
				}

				case L'a':
				case L'b':
				case L'c':
				case L'd':
				case L'e':
				case L'f':
				{
					uliValue.QuadPart = uliValue.QuadPart * 16 + ((*pwcCurrent) - L'a' + 10);
					break;
				}

				case L'A':
				case L'B':
				case L'C':
				case L'D':
				case L'E':
				case L'F':
				{
					uliValue.QuadPart = uliValue.QuadPart * 16 + ((*pwcCurrent) - L'A' + 10);
					break;
				}

				case L'{':
				case L'}':
				case L'-':
				{
					dwLength = ((DWORD_PTR) pwcCurrent) - ((DWORD_PTR) pwcStateStart);
					switch (GuidParseState)
					{
						case OpenBrace:
						{
							if (((*pwcCurrent) == L'{') &&
								(dwLength == 0))
							{
								fStateChange = TRUE;
							}
							else
							{
								GuidParseState = Invalid;
							}
							break;
						}

						case HexDWord1:
						{
							if (((*pwcCurrent) == L'-') &&
								(dwLength <= (sizeof(DWORD) * 2 * sizeof(WCHAR))))
							{
								guidValue.Data1 = uliValue.LowPart;
								fStateChange = TRUE;
							}
							else
							{
								GuidParseState = Invalid;
							}
							break;
						}

						case HexWord1:
						{
							if (((*pwcCurrent) == L'-') &&
								(dwLength <= (sizeof(WORD) * 2 * sizeof(WCHAR))))
							{
								guidValue.Data2 = (WORD) uliValue.LowPart;
								fStateChange = TRUE;
							}
							else
							{
								GuidParseState = Invalid;
							}
							break;
						}

						case HexWord2:
						{
							if (((*pwcCurrent) == L'-') &&
								(dwLength <= (sizeof(WORD) * 2 * sizeof(WCHAR))))
							{
								guidValue.Data3 = (WORD) uliValue.LowPart;
								fStateChange = TRUE;
							}
							else
							{
								GuidParseState = Invalid;
							}
							break;
						}

						case DoubleHexBytes:
						{
							if (((*pwcCurrent) == L'-') &&
								(dwLength == (2 * 2 * sizeof(WCHAR))))
							{
								guidValue.Data4[0] = (BYTE) ((uliValue.LowPart & 0x0000FF00) >> 8);
								guidValue.Data4[1] = (BYTE) (uliValue.LowPart & 0x000000FF);
								fStateChange = TRUE;
							}
							else
							{
								GuidParseState = Invalid;
							}
							break;
						}

						case HexBytes:
						{
							if (((*pwcCurrent) == L'}') &&
								(dwLength == (6 * 2 * sizeof(WCHAR))))
							{
								guidValue.Data4[2] = (BYTE) ((uliValue.HighPart & 0x0000FF00) >> 8);
								guidValue.Data4[3] = (BYTE)  (uliValue.HighPart & 0x000000FF);
								guidValue.Data4[4] = (BYTE) ((uliValue.LowPart & 0xFF000000) >> 24);
								guidValue.Data4[5] = (BYTE) ((uliValue.LowPart & 0x00FF0000) >> 16);
								guidValue.Data4[6] = (BYTE) ((uliValue.LowPart & 0x0000FF00) >> 8);
								guidValue.Data4[7] = (BYTE)  (uliValue.LowPart & 0x000000FF);
								fStateChange = TRUE;
							}
							else
							{
								GuidParseState = Invalid;
							}
							break;
						}

						default:
						{
							GuidParseState = Invalid;
							break;
						}
					} // end switch (on parse state)

					//
					// Move to next parse state (unless the string is bogus).
					//
					if (fStateChange)
					{
						fStateChange = FALSE;
						uliValue.QuadPart = 0;
						pwcStateStart = pwcCurrent + 1;
						(*((int*) (&GuidParseState)))++;
					}
					break;
				}
				
				default:
				{
					GuidParseState = Invalid;
					break;
				}
			} // end switch (on current character)

			if (GuidParseState == Invalid)
			{
				break;
			}

			pwcCurrent++;
			if ((pwcCurrent - m_pwszCurrentValue) > 38 * sizeof(WCHAR))
			{
				break;
			}
		} // end while (not at end of string)

		//
		// If we hit the end of the string when parsing the last element,
		// we've succeeded.  Commit the GUID.
		//
		if (GuidParseState == CloseBrace)
		{
			return pdp8aObject->SetElement( m_pwszCurrentKey, &guidValue, sizeof(GUID), DPNA_DATATYPE_GUID  );
		}
     }

	 // If there are no NULLs it's probably a string
     if( (
     		(dwDataType == DPNA_DATATYPE_STRING)
     		|| (dwDataType == 0xFFFFFFFF)
#ifndef DPNBUILD_ONLYONESP
     		|| (wcscmp(DPNA_KEY_PROVIDER,m_pwszCurrentKey)==0)
#endif // ! DPNBUILD_ONLYONESP
     	) &&
     	wcslen( m_pwszCurrentValue ) == m_dwValueLen )
     {
		 // Otherwise it's a string
    	 return pdp8aObject->SetElement( m_pwszCurrentKey, m_pwszCurrentValue, (wcslen(m_pwszCurrentValue)+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
     }

	 // Otherwise it's a binary (although the bytes were extended into WORDs/WCHARs.
   	 return pdp8aObject->SetElement( m_pwszCurrentKey, m_pwszCurrentValue, (m_dwValueLen * sizeof(WCHAR)), DPNA_DATATYPE_BINARY );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\adddllmain.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DllMain.cpp
 *  Content:    Defines the entry point for the DLL application.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   07/21/99	mjn		Created
 *	07/13/2000	rmt		Added critical sections to protect FPMs
 *  07/21/2000  RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *  01/04/2001	rodtoll	WinBug #94200 - Remove stray comments
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"

// Globals
#ifndef DPNBUILD_LIBINTERFACE
extern LONG g_lAddrObjectCount;
extern IClassFactoryVtbl DP8ACF_Vtbl;
#endif // ! DPNBUILD_LIBINTERFACE

DEBUG_ONLY(BOOL g_fAddrObjectInited = FALSE);

#ifndef DPNBUILD_ONLYONESP
#define WSA_INITED			0x00000001
#endif // ! DPNBUILD_ONLYONESP
#define ADDROBJ_INITED		0x00000002
#define ADDRELEM_INITED		0x00000004
#define STRCACHE_INITED		0x00000008

DWORD g_dwAddrInitFlags = 0;

void DNAddressDeInit();

#undef DPF_MODNAME
#define DPF_MODNAME "DNAddressInit"
BOOL DNAddressInit(HANDLE hModule)
{
#ifndef DPNBUILD_ONLYONESP
	WSADATA						wsaData;
#endif // ! DPNBUILD_ONLYONESP
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	XDP8STARTUP_PARAMS *		pStartupParams;


	//
	// The instance handle is actually a pointer to the initialization parameters.
	//
	pStartupParams = (XDP8STARTUP_PARAMS*) hModule;
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

#ifdef DBG
	DNASSERT(!g_fAddrObjectInited);
#endif // DBG

#ifndef DPNBUILD_ONLYONESP
	if( WSAStartup( MAKEWORD(1,1), &wsaData ) )
	{
		DPFX(DPFPREP,  0, "Unable to load winsock.  Error" );
		goto Failure;
	}
	g_dwAddrInitFlags |= WSA_INITED;
#endif // ! DPNBUILD_ONLYONESP
	
	if (!fpmAddressObjects.Initialize(   sizeof( DP8ADDRESSOBJECT ), 
									DP8ADDRESSOBJECT::FPM_BlockCreate, 
									DP8ADDRESSOBJECT::FPM_BlockInit, 
									DP8ADDRESSOBJECT::FPM_BlockRelease,
									DP8ADDRESSOBJECT::FPM_BlockDestroy ))
	{
		DPFX(DPFPREP, 0,"Failed to initialize address object pool");
		goto Failure;
	}
	g_dwAddrInitFlags |= ADDROBJ_INITED;

	if (!fpmAddressElements.Initialize( sizeof( DP8ADDRESSELEMENT ), NULL, 
									 DP8ADDRESSOBJECT::FPM_Element_BlockInit,
									 DP8ADDRESSOBJECT::FPM_Element_BlockRelease, NULL ))
	{
		DPFX(DPFPREP, 0,"Failed to allocate address element pool");
		goto Failure;
	}
	g_dwAddrInitFlags |= ADDRELEM_INITED;

	if (FAILED(DP8A_STRCACHE_Init()))
	{
		DPFX(DPFPREP, 0,"Failed to initialize string cache");
		goto Failure;
	}
	g_dwAddrInitFlags |= STRCACHE_INITED;

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if (DNAddress_PreallocateInterfaces(pStartupParams->dwNumAddressInterfaces) != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't pre-allocate %u address objects!",
			pStartupParams->dwNumAddressInterfaces);
		goto Failure;
	}
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

	DEBUG_ONLY(g_fAddrObjectInited = TRUE);

	return TRUE;

Failure:
	DNAddressDeInit();

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNAddressDeInit"
void DNAddressDeInit()
{
#ifdef DBG
	DNASSERT(g_fAddrObjectInited);
#endif // DBG

	DPFX(DPFPREP, 5, "Deinitializing Addressing");

	if (g_dwAddrInitFlags & STRCACHE_INITED)
	{
		DP8A_STRCACHE_Free();
	}
	if (g_dwAddrInitFlags & ADDRELEM_INITED)
	{
		fpmAddressElements.DeInitialize();
	}
	if (g_dwAddrInitFlags & ADDROBJ_INITED)
	{
		fpmAddressObjects.DeInitialize();
	}
#ifndef DPNBUILD_ONLYONESP
	if (g_dwAddrInitFlags & WSA_INITED)
	{
		WSACleanup();
	}
#endif // ! DPNBUILD_ONLYONESP

	g_dwAddrInitFlags = 0;

	DEBUG_ONLY(g_fAddrObjectInited = FALSE);
}

#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "DNAddressRegister"
BOOL DNAddressRegister(LPCWSTR wszDLLName)
{
	if( !CRegistry::Register( L"DirectPlay8Address.Address.1", L"DirectPlay8Address Object", 
							  wszDLLName, &CLSID_DirectPlay8Address, L"DirectPlay8Address.Address") )
	{
		DPFERR( "Could not register address object" );
		return FALSE;
	}

	else
	{
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNAddressUnRegister"
BOOL DNAddressUnRegister()
{
	if( !CRegistry::UnRegister(&CLSID_DirectPlay8Address) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister server object" );
		return FALSE;
	}
	else
	{
		return TRUE;
	}

}

#endif // !DPNBUILD_NOCOMREGISTER


#ifndef DPNBUILD_LIBINTERFACE

#undef DPF_MODNAME
#define DPF_MODNAME "DNAddressGetRemainingObjectCount"
DWORD DNAddressGetRemainingObjectCount()
{
	return g_lAddrObjectCount;
}

#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:    DNET COM class factory
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  02/04/2000	rmt		Adjusted for use in DPAddress
 *  02/17/2000	rmt		Parameter validation work 
 *  02/20/2000	rmt		Added parameter validation for IUnknown funcs
 *  03/21/2000  rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses 
 *  06/20/2000  rmt     Bugfix - QueryInterface had bug which was limiting interface list to 2 elements 
 *  07/09/2000	rmt		Added signature bytes to start of address objects
 *	07/13/2000	rmt		Added critical sections to protect FPMs
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  01/11/2001	rmt		MANBUG #48487 - DPLAY: Crashes if CoCreate() isn't called.   
 *  03/14/2001  rmt		WINBUG #342420 - Restore COM emulation layer to operation.  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifndef DPNBUILD_LIBINTERFACE
HRESULT DP8A_CreateInterface(LPOBJECT_DATA lpObject,REFIID riid, LPINTERFACE_LIST *const ppv);

// Globals
extern	LONG	g_lAddrObjectCount;
#endif // ! DPNBUILD_LIBINTERFACE


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#ifndef DPNBUILD_LIBINTERFACE
typedef	STDMETHODIMP IUnknownQueryInterface( IUnknown *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	IUnknownAddRef( IUnknown *pInterface );
typedef	STDMETHODIMP_(ULONG)	IUnknownRelease( IUnknown *pInterface );

//
// VTable for IUnknown interface
//
IUnknownVtbl  DP8A_UnknownVtbl =
{
	(IUnknownQueryInterface*)	DP8A_QueryInterface,
	(IUnknownAddRef*)			DP8A_AddRef,
	(IUnknownRelease*)			DP8A_Release
};

//
// VTable for Class Factory
//
IClassFactoryVtbl DP8ACF_Vtbl  =
{
	DPCF_QueryInterface, // dplay8\common\classfactory.cpp will implement these
	DPCF_AddRef,
	DPCF_Release,
	DP8ACF_CreateInstance,
	DPCF_LockServer
};
#endif // ! DPNBUILD_LIBINTERFACE


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#ifndef WINCE
#ifndef _XBOX

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlay8AddressCreate"
HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown)
{
#ifndef DPNBUILD_NOPARAMVAL
    if( pcIID == NULL || 
        !DNVALID_READPTR( pcIID, sizeof( GUID ) ) )
    {
        DPFERR( "Invalid pointer specified for interface GUID" );
        return DPNERR_INVALIDPOINTER;
    }

#ifdef DPNBUILD_NOADDRESSIPINTERFACE
    if( *pcIID == IID_IDirectPlay8AddressIP )
    {
        DPFERR("The IDirectPlay8AddressIP interface is not supported" );
        return DPNERR_UNSUPPORTED;
    }
    
    if( *pcIID != IID_IDirectPlay8Address )
    {
        DPFERR("Interface ID is not recognized" );
        return DPNERR_INVALIDPARAM;
    }
#else // ! DPNBUILD_NOADDRESSIPINTERFACE
    if( *pcIID != IID_IDirectPlay8Address && 
        *pcIID != IID_IDirectPlay8AddressIP )
    {
        DPFERR("Interface ID is not recognized" );
        return DPNERR_INVALIDPARAM;
    }
#endif // ! DPNBUILD_NOADDRESSIPINTERFACE

    if( ppvInterface == NULL || !DNVALID_WRITEPTR( ppvInterface, sizeof( void * ) ) )
    {
        DPFERR( "Invalid pointer specified to receive interface" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pUnknown != NULL )
    {
        DPFERR( "Aggregation is not supported by this object yet" );
        return DPNERR_INVALIDPARAM;
    }
#endif // !DPNBUILD_NOPARAMVAL

    return COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, *pcIID, ppvInterface, TRUE );
}

#endif // ! _XBOX
#endif // ! WINCE


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ACF_FreeObject"

HRESULT DP8ACF_FreeObject(LPVOID lpv)
{
	HRESULT				hResultCode = S_OK;
	DP8ADDRESSOBJECT	*pdnObject = (DP8ADDRESSOBJECT *) lpv;

	DNASSERT(pdnObject != NULL);

	pdnObject->Cleanup();

	DPFX(DPFPREP, 5,"free pdnObject [%p]",pdnObject);

	// Release the object
	fpmAddressObjects.Release( pdnObject );

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);

	return(hResultCode);
}



#ifdef DPNBUILD_LIBINTERFACE


STDMETHODIMP DP8ACF_CreateInstance(DPNAREFIID riid, LPVOID *ppv)
{
	HRESULT					hResultCode = S_OK;
	DP8ADDRESSOBJECT		*pdnObject = NULL;

	DPFX(DPFPREP, 3,"Parameters: riid [%p], ppv [%p]",riid,ppv);

#ifndef DPNBUILD_NOPARAMVAL
	if( ppv == NULL || !DNVALID_WRITEPTR( ppv, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  0, "Cannot pass NULL for new object param" );
		return E_INVALIDARG;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	// Object creation and initialization
	pdnObject = (DP8ADDRESSOBJECT *) fpmAddressObjects.Get();
	if (pdnObject == NULL)
	{
		DPFERR("FPM_Get() failed getting new address object");
		return(E_OUTOFMEMORY);
	}
	
	hResultCode = pdnObject->Init( );
	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP, 0,"Failed to init new address object hr=0x%x", hResultCode );
		fpmAddressObjects.Release( pdnObject );
		return hResultCode;
	}
	
	DPFX(DPFPREP, 5,"pdnObject [%p]",pdnObject);

	//
	// For lib interface builds, the Vtbl and reference count are embedded in the
	// object directly
	//
#ifndef DPNBUILD_NOADDRESSIPINTERFACE
	if (riid == IID_IDirectPlay8AddressIP)
	{
		pdnObject->lpVtbl = &DP8A_IPVtbl;
	}
	else
#endif // ! DPNBUILD_NOADDRESSIPINTERFACE
	{
		DNASSERT(riid == IID_IDirectPlay8Address);
		pdnObject->lpVtbl = &DP8A_BaseVtbl;
	}
	pdnObject->lRefCount = 1;

	*ppv = pdnObject;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);

	return(S_OK);
}


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT DNAddress_PreallocateInterfaces( const DWORD dwNumInterfaces )
{
	DWORD	dwAllocated;

	
	//
	// (Pre-)allocate address objects.
	//
	dwAllocated = fpmAddressObjects.Preallocate(dwNumInterfaces, NULL);
	if (dwAllocated < dwNumInterfaces)
	{
		DPFX(DPFPREP, 0, "Only preallocated %u of %u interfaces!",
			dwAllocated, dwNumInterfaces);
		return DPNERR_OUTOFMEMORY;
	}

	//
	// (Pre-)allocate a default number of elements for the objects.
	//
	dwAllocated = fpmAddressElements.Preallocate((5 * dwNumInterfaces), NULL);
	if (dwAllocated < (5 * dwNumInterfaces))
	{
		DPFX(DPFPREP, 0, "Only preallocated %u of %u address elements!",
			dwAllocated, (5 * dwNumInterfaces));
		return DPNERR_OUTOFMEMORY;
	}

	return DPN_OK;
}
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_QueryInterface"
STDMETHODIMP DP8A_QueryInterface(void *pInterface, DPNAREFIID riid, void **ppv)
{
	HRESULT		hResultCode;
	
	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], riid [0x%p], ppv [0x%p]",pInterface,&riid,ppv);

	DPFX(DPFPREP, 0, "Querying for an interface is not supported!");
	hResultCode = DPNERR_UNSUPPORTED;
	
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_AddRef"

STDMETHODIMP_(ULONG) DP8A_AddRef(LPVOID lpv)
{
	DP8ADDRESSOBJECT	*pdnObject;
	LONG				lResult;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

#ifndef DPNBUILD_NOPARAMVAL
	if( lpv == NULL || !DP8A_VALID(lpv) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return DPNERR_INVALIDOBJECT;
	}
#endif // !DPNBUILD_NOPARAMVAL

	pdnObject = static_cast<DP8ADDRESSOBJECT*>(lpv);
	lResult = DNInterlockedIncrement( &pdnObject->lRefCount );

	DPFX(DPFPREP, 3,"Returning: lResult = [%lx]",lResult);

	return(lResult);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_Release"

STDMETHODIMP_(ULONG) DP8A_Release(LPVOID lpv)
{
	DP8ADDRESSOBJECT	*pdnObject;
	LONG				lResult;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

#ifndef DPNBUILD_NOPARAMVAL
	if( lpv == NULL || !DP8A_VALID(lpv) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return DPNERR_INVALIDOBJECT;
	}
#endif // !DPNBUILD_NOPARAMVAL	

	pdnObject = static_cast<DP8ADDRESSOBJECT*>(lpv);

	DPFX(DPFPREP, 5,"Original : pdnObject->lRefCount = %ld",pdnObject->lRefCount);

	lResult = DNInterlockedDecrement( &pdnObject->lRefCount );
	if( lResult == 0 )
	{
		DPFX(DPFPREP, 5,"Free object");

		DP8ACF_FreeObject(pdnObject);
	}

	DPFX(DPFPREP, 3,"Returning: lResult = [%lx]",lResult);

	return(lResult);
}


#else // ! DPNBUILD_LIBINTERFACE


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ACF_CreateInstance"

STDMETHODIMP DP8ACF_CreateInstance(IClassFactory* pInterface, LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT					hResultCode = S_OK;
	LPINTERFACE_LIST		lpIntList = NULL;
	LPOBJECT_DATA			lpObjectData = NULL;
	DP8ADDRESSOBJECT		*pdnObject = NULL;

	DPFX(DPFPREP, 3,"Parameters: pInterface [%p], lpUnkOuter [%p], riid [%p], ppv [%p]",pInterface,lpUnkOuter,riid,ppv);

#ifndef DPNBUILD_NOPARAMVAL
	if( ppv == NULL || !DNVALID_WRITEPTR( ppv, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  0, "Cannot pass NULL for new object param" );
		return E_INVALIDARG;
	}
#endif // !DPNBUILD_NOPARAMVAL

	if (lpUnkOuter != NULL)
	{
		DPFX(DPFPREP,  0, "Aggregation is not supported, pUnkOuter must be NULL" );
		return(CLASS_E_NOAGGREGATION);
	}

	lpObjectData = (LPOBJECT_DATA) g_fpObjectDatas.Get();
	if (lpObjectData == NULL)
	{
		DPFERR("FPM_Get() failed");
		return(E_OUTOFMEMORY);
	}
	DPFX(DPFPREP, 5,"lpObjectData [%p]",lpObjectData);

	// Object creation and initialization
	pdnObject = (DP8ADDRESSOBJECT *) fpmAddressObjects.Get();
	if (pdnObject == NULL)
	{
		DPFERR("FPM_Get() failed getting new address object");
		g_fpObjectDatas.Release(lpObjectData);
		return(E_OUTOFMEMORY);
	}
	
	hResultCode = pdnObject->Init( );
	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP, 0,"Failed to init new address object hr=0x%x", hResultCode );
		fpmAddressObjects.Release( pdnObject );
		g_fpObjectDatas.Release(lpObjectData);
		return hResultCode;
	}
	
	DPFX(DPFPREP, 5,"pdnObject [%p]",pdnObject);

	lpObjectData->pvData = pdnObject;

	// Get requested interface
	if ((hResultCode = DP8A_CreateInterface(lpObjectData,riid,&lpIntList)) != S_OK)
	{
		DP8ACF_FreeObject(lpObjectData->pvData);
		g_fpObjectDatas.Release(lpObjectData);
		return(hResultCode);
	}
	DPFX(DPFPREP, 5,"Found interface");

	lpObjectData->pIntList = lpIntList;
	lpObjectData->lRefCount = 1;
	DNInterlockedIncrement(&lpIntList->lRefCount );
	DNInterlockedIncrement(&g_lAddrObjectCount);
	*ppv = lpIntList;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);

	return(S_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_CreateInterface"

static	HRESULT DP8A_CreateInterface(LPOBJECT_DATA lpObject, REFIID riid, LPINTERFACE_LIST *const ppv)
{
	LPINTERFACE_LIST	lpIntNew;
	LPVOID				lpVtbl;

	DPFX(DPFPREP, 3,"Parameters: lpObject [%p], riid [%p], ppv [%p]",lpObject,riid,ppv);

	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 5,"riid = IID_IUnknown");
		lpVtbl = &DP8A_UnknownVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8Address))
	{
		DPFX(DPFPREP, 5,"riid = IID_IDirectPlay8Address");
		lpVtbl = &DP8A_BaseVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8AddressIP))
	{
#ifdef DPNBUILD_NOADDRESSIPINTERFACE
		DPFERR("The IDirectPlay8AddressIP interface is not supported" );
		return(DPNERR_UNSUPPORTED);
#else // ! DPNBUILD_NOADDRESSIPINTERFACE
		DPFX(DPFPREP, 5,"riid = IID_IDirectPlay8AddressIP");
		lpVtbl = &DP8A_IPVtbl;
#endif // ! DPNBUILD_NOADDRESSIPINTERFACE
	}
	else
	{
		DPFX(DPFPREP, 5,"riid not found !");
		return(E_NOINTERFACE);
	}

	lpIntNew = (LPINTERFACE_LIST) g_fpInterfaceLists.Get();
	if (lpIntNew == NULL)
	{
		DPFERR("FPM_Get() failed");
		return(E_OUTOFMEMORY);
	}
	lpIntNew->lpVtbl = lpVtbl;
	lpIntNew->lRefCount = 0;
	lpIntNew->pIntNext = NULL;
	DBG_CASSERT( sizeof( lpIntNew->iid ) == sizeof( riid ) );
	memcpy( &(lpIntNew->iid), &riid, sizeof( lpIntNew->iid ) );
	lpIntNew->pObject = lpObject;

	*ppv = lpIntNew;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [S_OK], *ppv = [%p]",*ppv);

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_FindInterface"

LPINTERFACE_LIST DP8A_FindInterface(LPVOID lpv, REFIID riid)
{
	LPINTERFACE_LIST	lpIntList;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p], riid [%p]",lpv,riid);

	lpIntList = ((LPINTERFACE_LIST)lpv)->pObject->pIntList;	// Find first interface

	while (lpIntList != NULL)
	{
		if (IsEqualIID(riid,lpIntList->iid))
			break;
		lpIntList = lpIntList->pIntNext;
	}
	DPFX(DPFPREP, 3,"Returning: lpIntList = [%p]",lpIntList);

	return(lpIntList);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_QueryInterface"

STDMETHODIMP DP8A_QueryInterface(LPVOID lpv,DPNAREFIID riid,LPVOID *ppv)
{
	LPINTERFACE_LIST	lpIntList;
	LPINTERFACE_LIST	lpIntNew;
	HRESULT		hResultCode;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p], riid [%p], ppv [%p]",lpv,riid,ppv);

#ifndef DPNBUILD_NOPARAMVAL
	if( lpv == NULL || !DP8A_VALID(lpv) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return DPNERR_INVALIDOBJECT;
	}

	if( ppv == NULL || 
		!DNVALID_WRITEPTR(ppv, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for interface" );
		return DPNERR_INVALIDPOINTER;
	}
#endif // !DPNBUILD_NOPARAMVAL

	if ((lpIntList = DP8A_FindInterface(lpv,riid)) == NULL)
	{	// Interface must be created
		lpIntList = ((LPINTERFACE_LIST)lpv)->pObject->pIntList;

		if ((hResultCode = DP8A_CreateInterface(lpIntList->pObject,riid,&lpIntNew)) != S_OK)
		{
			return(hResultCode);
		}

		lpIntNew->pIntNext = lpIntList;
		((LPINTERFACE_LIST)lpv)->pObject->pIntList = lpIntNew;
		lpIntList = lpIntNew;
	}

	// Interface is being created or was cached
	// Increment object count
	if( lpIntList->lRefCount == 0 )
	{
		DNInterlockedIncrement( &lpIntList->pObject->lRefCount );
	}
	DNInterlockedIncrement( &lpIntList->lRefCount );
	*ppv = lpIntList;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [S_OK], *ppv = [%p]",*ppv);

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_AddRef"

STDMETHODIMP_(ULONG) DP8A_AddRef(LPVOID lpv)
{
	LPINTERFACE_LIST	lpIntList;
	LONG				lResult;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

#ifndef DPNBUILD_NOPARAMVAL
	if( lpv == NULL || !DP8A_VALID(lpv) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return DPNERR_INVALIDOBJECT;
	}
#endif // !DPNBUILD_NOPARAMVAL

	lpIntList = (LPINTERFACE_LIST)lpv;
	lResult = DNInterlockedIncrement( &lpIntList->lRefCount );

	DPFX(DPFPREP, 3,"Returning: lResult = [%lx]",lResult);

	return(lResult);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_Release"

STDMETHODIMP_(ULONG) DP8A_Release(LPVOID lpv)
{
	LPINTERFACE_LIST	lpIntList;
	LPINTERFACE_LIST	lpIntCurrent;
	LONG				lResult;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

#ifndef DPNBUILD_NOPARAMVAL
	if( lpv == NULL || !DP8A_VALID(lpv) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		return DPNERR_INVALIDOBJECT;
	}
#endif // !DPNBUILD_NOPARAMVAL	

	lpIntList = (LPINTERFACE_LIST)lpv;

	DPFX(DPFPREP, 5,"Original : lpIntList->lRefCount = %ld",lpIntList->lRefCount);
	DPFX(DPFPREP, 5,"Original : lpIntList->pObject->lRefCount = %ld",lpIntList->pObject->lRefCount);

	lResult = DNInterlockedDecrement( &lpIntList->lRefCount );
	if( lResult == 0 )
	{	// Decrease interface count
		if( DNInterlockedDecrement( &lpIntList->pObject->lRefCount ) == 0 )
		{	// Free object and all interfaces
			DPFX(DPFPREP, 5,"Free object");

			// Free object here
			DP8ACF_FreeObject(lpIntList->pObject->pvData);
			lpIntList = lpIntList->pObject->pIntList;	// Get head of interface list
			DPFX(DPFPREP, 5,"lpIntList->pObject [%p]",lpIntList->pObject);
			g_fpObjectDatas.Release(lpIntList->pObject);

			// Free Interfaces
			DPFX(DPFPREP, 5,"Free interfaces");
			while(lpIntList != NULL)
			{
				lpIntCurrent = lpIntList;
				lpIntList = lpIntList->pIntNext;
				DPFX(DPFPREP, 5,"\tinterface [%p]",lpIntCurrent);
				g_fpInterfaceLists.Release(lpIntCurrent);
			}

			DNInterlockedDecrement(&g_lAddrObjectCount);
			DPFX(DPFPREP, 3,"Returning: 0");
			return(0);
		}
	}

	DPFX(DPFPREP, 3,"Returning: lResult = [%lx]",lResult);

	return(lResult);
}

#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addcore.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addtcp.cpp
 *  Content:    DirectPlay8Address core implementation file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/10/2000	rmt		Updated to use DPNA_ defines instead of URL_
 * 02/12/2000	rmt		Split Get into GetByName and GetByIndex
 * 02/17/2000	rmt		Parameter validation work
 * 02/18/2000	rmt		Added type validation to all pre-defined elements
 * 02/21/2000	rmt		Updated to make core Unicode and remove ANSI calls
 * 02/23/2000	rmt		Fixed length calculations in GetURL
 *				rmt		Buffer too small error debug messages -> Warning level
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 *                      Added support for the new ANSI type
 *	05/04/00	mjn		delete temp var at end of SetElement()
 *	05/05/00	mjn		Better error cleanup in SetElement()
 *  06/06/00    rmt     Bug #36455 failure when calling with ANSI string shortcut for SP
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *  06/21/2000	rmt		Bug #37392 - Leak if replacing allocated element with new item same size as GUID
 *  06/27/2000	rmt		Bug #37630 - Service provider shortcuts / element names were case sensitive
 *  07/06/2000	rmt		Bug #38714 - ADDRESSING: GetURL doesn't return the # of chars written
 *  07/09/2000	rmt		Added signature bytes to start of address objects
 *  07/12/2000	rmt		Fixed some critical section related bugs:
 *						- Added leave in an error path where it wasn't being called
 *						- Moved critical section init/delete to constructor / destructor
 *  07/13/2000	rmt		Bug #39274 - INT 3 during voice run
 *						- Fixed point where a critical section was being re-initialized
 *				rmt		Added critical sections to protect FPMs					
 * 07/21/2000	rmt		Fixed bug w/directplay 4 address parsing 
 * 07/31/2000	rmt		Bug #41125 - Addressing() GetUserData when none available should return doesnotexist
 * 08/03/2000	rmt		Missing LEAVELOCK() was causing lockups.
 * 11/29/2000   aarono	B#226079 prefix, fix memory leak in failure path of SetElement
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


const WCHAR * g_szBaseStrings[] =
{
#ifndef DPNBUILD_ONLYONESP
	DPNA_KEY_PROVIDER,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
	DPNA_KEY_DEVICE,
#endif // ! DPNBUILD_ONLYONEADAPTER
	DPNA_KEY_HOSTNAME,
	DPNA_KEY_PORT,
#ifndef DPNBUILD_NOLOBBY
	DPNA_KEY_APPLICATION_INSTANCE,
	DPNA_KEY_PROGRAM,
#endif // ! DPNBUILD_NOLOBBY
#ifndef DPNBUILD_NOSERIALSP
	DPNA_KEY_BAUD,
	DPNA_KEY_FLOWCONTROL,
	DPNA_KEY_PARITY,
	DPNA_KEY_PHONENUMBER,
	DPNA_KEY_STOPBITS
#endif // !DPNBUILD_NOSERIALSP
};

const DWORD c_dwNumBaseStrings = LENGTHOF(g_szBaseStrings);

const DWORD g_dwBaseRequiredTypes[] =
{
#ifndef DPNBUILD_ONLYONESP
	DPNA_DATATYPE_GUID,
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
	DPNA_DATATYPE_GUID,
#endif // ! DPNBUILD_ONLYONEADAPTER
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_DWORD,
#ifndef DPNBUILD_NOLOBBY
	DPNA_DATATYPE_GUID,
	DPNA_DATATYPE_GUID,
#endif // ! DPNBUILD_NOLOBBY
#ifndef DPNBUILD_NOSERIALSP
	DPNA_DATATYPE_DWORD,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_STRING,
	DPNA_DATATYPE_STRING
#endif // !DPNBUILD_NOSERIALSP
};

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_STRCACHE_Init"
HRESULT DP8A_STRCACHE_Init()
{
	HRESULT hr;
	PWSTR	pstrTmp;
	DWORD	dwIndex;

	DNASSERT( g_pcstrKeyCache == NULL );
	g_pcstrKeyCache = (CStringCache*) DNMalloc(sizeof(CStringCache));
	if ( g_pcstrKeyCache == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to create addressing string cache!" );
		return DPNERR_OUTOFMEMORY;
	}
	g_pcstrKeyCache->Initialize();

	for( dwIndex = 0; dwIndex < c_dwNumBaseStrings; dwIndex++ )
	{
		hr = g_pcstrKeyCache->AddString( g_szBaseStrings[dwIndex], &pstrTmp );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Error adding base strings" );
			g_pcstrKeyCache->Deinitialize();
			DNFree(g_pcstrKeyCache);
			g_pcstrKeyCache = NULL;
			return hr;
		}
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8A_STRCACHE_Free"
// Nothing needs to be done.
void DP8A_STRCACHE_Free()
{
	if ( g_pcstrKeyCache != NULL )
	{
		g_pcstrKeyCache->Deinitialize();
		DNFree(g_pcstrKeyCache);
		g_pcstrKeyCache = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_Element_BlockInit"
void DP8ADDRESSOBJECT::FPM_Element_BlockInit( void *pvItem, PVOID pvContext )
{
	memset( pvItem, 0x00, sizeof( DP8ADDRESSELEMENT ) );
	((PDP8ADDRESSELEMENT) pvItem)->dwSignature = DPASIGNATURE_ELEMENT;

	((PDP8ADDRESSELEMENT) pvItem)->blAddressElements.Initialize();
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_Element_BlockRelease"
void DP8ADDRESSOBJECT::FPM_Element_BlockRelease( void *pvItem )
{
	((PDP8ADDRESSELEMENT) pvItem)->dwSignature = DPASIGNATURE_ELEMENT_FREE;

	DNASSERT(((PDP8ADDRESSELEMENT) pvItem)->blAddressElements.IsEmpty());
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_BlockCreate"
BOOL DP8ADDRESSOBJECT::FPM_BlockCreate( void *pvItem, PVOID pvContext )
{
	return DNInitializeCriticalSection( &((PDP8ADDRESSOBJECT) pvItem)->m_csAddressLock );
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_BlockInit"
void DP8ADDRESSOBJECT::FPM_BlockInit( void *pvItem, PVOID pvContext )
{
	((PDP8ADDRESSOBJECT) pvItem)->m_dwSignature = DPASIGNATURE_ADDRESS;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_BlockRelease"
void DP8ADDRESSOBJECT::FPM_BlockRelease( void *pvItem )
{
	((PDP8ADDRESSOBJECT) pvItem)->m_dwSignature = DPASIGNATURE_ADDRESS_FREE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FPM_BlockDestroy"
void DP8ADDRESSOBJECT::FPM_BlockDestroy( void *pvItem )
{
	DNDeleteCriticalSection( &((PDP8ADDRESSOBJECT) pvItem)->m_csAddressLock );
}

// InternalGetElement
//
// This function does the lookup for an element by index.
//
// Requires the object lock.
//
// Does not do parameter validation.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::InternalGetElement"
HRESULT DP8ADDRESSOBJECT::InternalGetElement( const DWORD dwIndex, PDP8ADDRESSELEMENT *ppaElement )
{
	CBilink *pblSearch;

	if( dwIndex >= m_dwElements )
		return DPNERR_DOESNOTEXIST;

	pblSearch = m_blAddressElements.GetNext();

	for( DWORD dwSearchIndex = 0; dwSearchIndex < dwIndex; dwSearchIndex++ )
	{
		pblSearch = pblSearch->GetNext();
	}
	
	*ppaElement = CONTAINING_OBJECT(pblSearch, DP8ADDRESSELEMENT, blAddressElements);

	return DPN_OK;

}

// InternalGetElement
//
// This function does the lookup for an element by name.
//
// Requires the object lock.
//
// Does not do parameter validation.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::InternalGetElement"
HRESULT DP8ADDRESSOBJECT::InternalGetElement( const WCHAR * const pszTag, PDP8ADDRESSELEMENT *ppaElement )
{
	CBilink *pblSearch;
	PDP8ADDRESSELEMENT paddElement;

	pblSearch = m_blAddressElements.GetNext();

	while( pblSearch != &m_blAddressElements )
	{
		paddElement = CONTAINING_OBJECT(pblSearch, DP8ADDRESSELEMENT, blAddressElements);

		if( _wcsicmp( pszTag, paddElement->pszTag ) == 0 )
		{
			*ppaElement = paddElement;
			return DPN_OK;
		}

		pblSearch = pblSearch->GetNext();
	}

	return DPNERR_DOESNOTEXIST;
}

// GetElement
//
// Implements retrieval of element by name
//
// Parameter validation must be performed BEFORE calling this function.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetElement"
HRESULT DP8ADDRESSOBJECT::GetElement( const WCHAR * const pszTag, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr;

	ENTERLOCK();
	
	hr = InternalGetElement( pszTag, &paddElement );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  1, "Unable to find specified element hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	DNASSERT( paddElement != NULL );

	*pdwDataType = paddElement->dwType;

	if( *pdwDataSize < paddElement->dwDataSize ||
	   pvDataBuffer == NULL )
	{
		*pdwDataSize = paddElement->dwDataSize;
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Specified buffers were too small hr=0x%x", hr );
		LEAVELOCK();		
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwDataSize = paddElement->dwDataSize;

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
	{
		memcpy( pvDataBuffer, paddElement->uData.pvData, paddElement->dwDataSize );
	}
	else
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	{
		memcpy( pvDataBuffer, &paddElement->uData, paddElement->dwDataSize );
	}

	LEAVELOCK();	

	return DPN_OK;	

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetElementType"
HRESULT DP8ADDRESSOBJECT::GetElementType( const WCHAR * pszTag, PDWORD pdwType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr;

	ENTERLOCK();

	hr = InternalGetElement( pszTag, &paddElement );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Unable to find specified element hr=0x%x" );
		LEAVELOCK();
		return hr;
	}

	*pdwType = paddElement->dwType;

	LEAVELOCK();

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetElement"
HRESULT DP8ADDRESSOBJECT::GetElement( const DWORD dwIndex, WCHAR * pszTag, PDWORD pdwTagSize, void * pvDataBuffer, PDWORD pdwDataSize, PDWORD pdwDataType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr;

	if( pdwTagSize == NULL || pdwDataSize == NULL || pdwDataType == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid Poiinter" );
		return DPNERR_INVALIDPOINTER;
	}

	ENTERLOCK();

	hr = InternalGetElement( dwIndex, &paddElement );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Unable to find specified element hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	DNASSERT( paddElement != NULL );

	*pdwDataType = paddElement->dwType;

	if( *pdwTagSize < (wcslen( paddElement->pszTag )+1) ||
	   *pdwDataSize < paddElement->dwDataSize ||
	   pszTag == NULL ||
	   pvDataBuffer == NULL )
	{
		*pdwTagSize = paddElement->dwTagSize;
		*pdwDataSize = paddElement->dwDataSize;
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Specified buffers were too small hr=0x%x", hr );
		LEAVELOCK();		
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwTagSize = paddElement->dwTagSize;
	*pdwDataSize = paddElement->dwDataSize;

	wcscpy( pszTag, paddElement->pszTag );

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
	if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
	{
		memcpy( pvDataBuffer, paddElement->uData.pvData, paddElement->dwDataSize );
	}
	else
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	{
		memcpy( pvDataBuffer, &paddElement->uData, paddElement->dwDataSize );
	}

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetElement"
HRESULT DP8ADDRESSOBJECT::SetElement( const WCHAR * const pszTag, const void * const pvData, const DWORD dwDataSize, const DWORD dwDataType )
{
	PDP8ADDRESSELEMENT paddElement = NULL;
	HRESULT hr = DPN_OK;
	BOOL fReplace = FALSE;

#ifdef DBG
	DNASSERT(pvData != NULL);
	switch( dwDataType )
	{
		case DPNA_DATATYPE_DWORD:
		{
			DNASSERT(dwDataSize == sizeof(DWORD));
			break;
		}

		case DPNA_DATATYPE_GUID:
		{
			DNASSERT(dwDataSize == sizeof(GUID));
			break;
		}

		case DPNA_DATATYPE_STRING:
		case DPNA_DATATYPE_BINARY:
		{
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Invalid data type %u!", dwDataType);
			DNASSERT(FALSE);
			break;
		}
	}
#endif // DBG


	ENTERLOCK();

    // We need to treat provider key differently, it can also take one of the provider
    // shortcut values.
    // For builds with a fixed SP, we don't even care what the value is.
    if( _wcsicmp( DPNA_KEY_PROVIDER, pszTag ) == 0 )
    {
#ifdef DPNBUILD_ONLYONESP
		DPFX(DPFPREP, 3, "Ignoring provider key.");
		goto APPEND_SUCCESS;
#else // ! DPNBUILD_ONLYONESP
        // If it's a GUID we're golden, otherwise..
        if( dwDataType != DPNA_DATATYPE_GUID )
        {
            if( dwDataType == DPNA_DATATYPE_STRING )
            {
                if( _wcsicmp( (const WCHAR * const) pvData, DPNA_VALUE_TCPIPPROVIDER ) == 0 )
                {
                    hr = SetSP( &CLSID_DP8SP_TCPIP );
                }
#ifndef DPNBUILD_NOIPX
                else if( _wcsicmp( (const WCHAR * const) pvData, DPNA_VALUE_IPXPROVIDER ) == 0 )
                {
                    hr= SetSP( &CLSID_DP8SP_IPX );
                }
#endif // ! DPNBUILD_NOIPX
#ifndef DPNBUILD_NOSERIALSP
                else if( _wcsicmp( (const WCHAR * const) pvData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
                {
                    hr = SetSP( &CLSID_DP8SP_MODEM );
                }
                else if( _wcsicmp( (const WCHAR * const) pvData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
                {
                    hr = SetSP( &CLSID_DP8SP_SERIAL );
                }
#endif // ! DPNBUILD_NOSERIALSP
                else
                {
                    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Provider must be specified as a GUID or a valid shortcut string" );
					hr = DPNERR_INVALIDPARAM;
					goto APPEND_ERROR;
                }

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Failed setting provider with shortcut hr=0x%x", hr );
                    goto APPEND_ERROR;
                }

                goto APPEND_SUCCESS;

            }
            else
            {
                DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Specified values is not a supported datatype for the given key" );
				hr = DPNERR_INVALIDPARAM;
				goto APPEND_ERROR;
            }
        }
#endif // ! DPNBUILD_ONLYONESP
    }
    else
    {
	    // Ensure that datatype is correct in case the key is a reserved key
	    for( DWORD dwIndex = 0; dwIndex < c_dwNumBaseStrings; dwIndex++ )
	    {
		    if( _wcsicmp( g_szBaseStrings[dwIndex], pszTag ) == 0 )
		    {
			    if( dwDataType != g_dwBaseRequiredTypes[dwIndex] )
			    {
				    DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Specified key is reserved and specified datatype is not correct for key" );
					hr = DPNERR_INVALIDPARAM;
					goto APPEND_ERROR;
			    }
			    break;
		    }
	    }
    }

	hr = InternalGetElement( pszTag, &paddElement );

	// If the element is not already in the address we need to add an element
	if( FAILED( hr ) )
	{
		paddElement = (PDP8ADDRESSELEMENT) fpmAddressElements.Get();

		if( paddElement == NULL )
		{
			DPFX(DPFPREP,  0, "Error getting new element" );
			hr = DPNERR_OUTOFMEMORY;
			goto APPEND_ERROR;
		}

		hr = g_pcstrKeyCache->AddString( pszTag, &paddElement->pszTag );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Unable to cache tag element hr=0x%x" );
			goto APPEND_ERROR;
		}

		// Set flag to 0 
		paddElement->dwFlags = 0;
	}
	// The element is already there.  Fill in the data.
	else
	{
		DNASSERT( paddElement != NULL );

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
		DNASSERT( dwDataSize <= sizeof(paddElement->uData) );
		// If the one we're replacing was on the heap AND
		// The new one doesn't need the heap or is a larger size..
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP &&
		   (dwDataSize <= sizeof(paddElement->uData) || dwDataSize > paddElement->dwDataSize) )
		{
            DNFree(paddElement->uData.pvData);
			paddElement->uData.pvData = NULL;
			paddElement->dwDataSize = 0;
		}
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

		// Reduce the object's string size so object string size will be correct
		m_dwStringSize -= paddElement->dwStringSize;
		fReplace = TRUE;
	}

	paddElement->dwTagSize = wcslen( pszTag )+1;

	// Can fit in the internal buffer
	if( dwDataSize <= sizeof( paddElement->uData ) )
	{
		memcpy( &paddElement->uData, pvData, dwDataSize );

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
		// Turn off heap flag in this case
		paddElement->dwFlags &= ~(DP8ADDRESS_ELEMENT_HEAP);
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	}
	else
	{
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
		DPFX(DPFPREP, 0, "Item is too large (%u > %u bytes)!",
			dwDataSize, sizeof( paddElement->uData ) );
		hr = DPNERR_OUTOFMEMORY;
		goto APPEND_ERROR;
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
		if( !fReplace || !(paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP) ||
		     paddElement->dwDataSize < dwDataSize )
		{
			paddElement->uData.pvData = DNMalloc(dwDataSize);

			if( paddElement->uData.pvData == NULL )
			{
				DPFX(DPFPREP,  0, "Error allocating memory" );
				hr = DPNERR_OUTOFMEMORY;
				goto APPEND_ERROR;
			}
		}

		memcpy( paddElement->uData.pvData, pvData, dwDataSize );

		paddElement->dwFlags |= DP8ADDRESS_ELEMENT_HEAP;
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	}

	paddElement->dwType = dwDataType;
	paddElement->dwDataSize = dwDataSize;
	paddElement->dwStringSize = 0;

	hr = CalcComponentStringSize( paddElement, &paddElement->dwStringSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Failed to determine string length hr=0x%x", hr );
		goto APPEND_ERROR;
	}

	m_dwStringSize += paddElement->dwStringSize;

	// Create shortcuts if appropriate
#ifndef DPNBUILD_ONLYONESP
	if( _wcsicmp( DPNA_KEY_PROVIDER, paddElement->pszTag ) == 0 )
	{
		m_pSP = paddElement;
	}
	else
#endif // ! DPNBUILD_ONLYONESP
	{
#ifndef DPNBUILD_ONLYONEADAPTER
		if( _wcsicmp( DPNA_KEY_DEVICE, paddElement->pszTag ) == 0 )
		{
			m_pAdapter = paddElement;
		}
#endif // ! DPNBUILD_ONLYONEADAPTER
	}

	if( !fReplace )
	{
#ifndef DPNBUILD_ONLYONESP
		// We are adding the SP
		if( m_pSP == paddElement )
		{
			paddElement->blAddressElements.InsertAfter( &m_blAddressElements );
		}
		// We are adding the adapter
		else
#endif // ! DPNBUILD_ONLYONESP
		{
#ifndef DPNBUILD_ONLYONEADAPTER
			if( m_pAdapter == paddElement )
			{
#ifndef DPNBUILD_ONLYONESP
				if( m_pSP != NULL )
				{
					paddElement->blAddressElements.InsertAfter( &m_pSP->blAddressElements);			
				}
				else
#endif // ! DPNBUILD_ONLYONESP
				{
					paddElement->blAddressElements.InsertAfter( &m_blAddressElements);			
				}
			}
			// Tack it onto the end
			else
#endif // ! DPNBUILD_ONLYONEADAPTER
			{
				paddElement->blAddressElements.InsertBefore( &m_blAddressElements );
			}
		}

		// Add one char length for seperator w/previous element
#ifndef DPNBUILD_ONLYONESP
		if( m_dwElements > 0 )
#endif // ! DPNBUILD_ONLYONESP
		{
			m_dwStringSize ++;
		}

		m_dwElements++;	

	}

APPEND_SUCCESS:
    
	LEAVELOCK();    

	return DPN_OK;

APPEND_ERROR:

	if( paddElement != NULL )
	{
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
			if( paddElement->uData.pvData )
			{
				DNFree(paddElement->uData.pvData);
				paddElement->uData.pvData = NULL;
			}
		}
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

		fpmAddressElements.Release( paddElement );
	}

	LEAVELOCK();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Init"
HRESULT DP8ADDRESSOBJECT::Init( )
{
	ENTERLOCK();

	m_dwElements = 0;
#ifndef DPNBUILD_ONLYONESP
	m_pSP = NULL;
#endif // ! DPNBUILD_ONLYONESP
#ifndef DPNBUILD_ONLYONEADAPTER
	m_pAdapter = NULL;
#endif // ! DPNBUILD_ONLYONEADAPTER
	m_pvUserData = NULL;
	m_dwUserDataSize = 0;
#ifdef DPNBUILD_ONLYONESP
	m_dwStringSize = DNURL_LENGTH_HEADER + DNURL_LENGTH_BUILTINPROVIDER;
#else // ! DPNBUILD_ONLYONESP
	m_dwStringSize = DNURL_LENGTH_HEADER;
#endif // ! DPNBUILD_ONLYONESP
	m_dwUserDataStringSize = 0;
	m_blAddressElements.Initialize();

	LEAVELOCK();
	
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Clear"
HRESULT DP8ADDRESSOBJECT::Clear( )
{
	CBilink 				*pbl;
	PDP8ADDRESSELEMENT paddElement;

	ENTERLOCK();	

	pbl = m_blAddressElements.GetNext();

	// Destroy Address Members address members
	while( !m_blAddressElements.IsEmpty() )
	{
		paddElement = CONTAINING_OBJECT(m_blAddressElements.GetNext(), DP8ADDRESSELEMENT, blAddressElements);

#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
			DNFree(paddElement->uData.pvData);
			paddElement->uData.pvData = NULL;
		}
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
		
		pbl->RemoveFromList();

		fpmAddressElements.Release( paddElement );

		pbl = m_blAddressElements.GetNext();
	}

	if( m_pvUserData != NULL )
	{
		DNFree(m_pvUserData);
		m_pvUserData = NULL;
		m_dwUserDataSize = 0;
	}

	LEAVELOCK();

	Init( );

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Copy"
HRESULT DP8ADDRESSOBJECT::Copy( DP8ADDRESSOBJECT * const pAddressSource )
{
	HRESULT				hResultCode;
	CBilink 				*pbl;
	PDP8ADDRESSELEMENT paddElement;

	pAddressSource->ENTERLOCK();

	pbl = pAddressSource->m_blAddressElements.GetNext();

	while( pbl != &pAddressSource->m_blAddressElements )
	{
		paddElement = CONTAINING_OBJECT(pbl, DP8ADDRESSELEMENT, blAddressElements);

		// This takes the lock internally.
		hResultCode = SetElement(paddElement->pszTag,
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
								&paddElement->uData,
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
								(( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP ) ? paddElement->uData.pvData : &paddElement->uData),
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
								paddElement->dwDataSize,
								paddElement->dwType);
		if (hResultCode != DPN_OK)
		{
			pAddressSource->LEAVELOCK();
			DPFX(DPFPREP, 0, "Couldn't set element!");
			return hResultCode;
		}

		pbl = pbl->GetNext();
	}

	// This takes the lock internally.
	hResultCode = SetUserData(pAddressSource->m_pvUserData, pAddressSource->m_dwUserDataSize);
	if (hResultCode != DPN_OK)
	{
		pAddressSource->LEAVELOCK();
		DPFX(DPFPREP, 0, "Couldn't set element!");
		return hResultCode;
	}
	
	pAddressSource->LEAVELOCK();

	return DPN_OK;

}


#ifndef DPNBUILD_ONLYONESP

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetSP"
HRESULT DP8ADDRESSOBJECT::GetSP( GUID * pGuid )
{
	if( pGuid == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		return DPNERR_INVALIDPOINTER;
	}

	ENTERLOCK();

	if( m_pSP == NULL )
	{
		DPFX(DPFPREP,  0, "No SP has been specified" );
		LEAVELOCK();
		return DPNERR_DOESNOTEXIST;
	}

	if( m_pSP->dwType != DPNA_DATATYPE_GUID )
	{
		DPFX(DPFPREP,  0, "SP was specified, but is not a GUID" );
		LEAVELOCK();
		return DPNERR_INVALIDPARAM;
	}

	memcpy( pGuid, &m_pSP->uData.guidData, sizeof( GUID ) );

	LEAVELOCK();

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetSP"
HRESULT DP8ADDRESSOBJECT::SetSP( const GUID* const pGuid )
{
	HRESULT hr;
	
	if( pGuid == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		return DPNERR_INVALIDPOINTER;
	}

	hr = SetElement( DPNA_KEY_PROVIDER, pGuid, sizeof( GUID ), DPNA_DATATYPE_GUID );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
	}

	return hr;
}

#endif // ! DPNBUILD_ONLYONESP

#ifndef DPNBUILD_ONLYONEADAPTER

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetDevice"
HRESULT DP8ADDRESSOBJECT::GetDevice( GUID * pGuid )
{
	if( pGuid == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		return DPNERR_INVALIDPOINTER;
	}

	ENTERLOCK();

	if( m_pAdapter == NULL )
	{
		DPFX(DPFPREP,  1, "No SP has been specified" );
		LEAVELOCK();
		return DPNERR_DOESNOTEXIST;
	}

	if( m_pAdapter->dwType != DPNA_DATATYPE_GUID )
	{
		DPFX(DPFPREP,  0, "SP was specified, but is not a GUID" );
		LEAVELOCK();		
		return DPNERR_INVALIDPARAM;
	}

	memcpy( pGuid, &m_pAdapter->uData.guidData, sizeof( GUID ) );
	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetDevice"
HRESULT DP8ADDRESSOBJECT::SetDevice( const GUID * const pGuid )
{
	HRESULT hr;
	
	if( pGuid == NULL )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		return DPNERR_INVALIDPOINTER;
	}

	hr = SetElement( DPNA_KEY_DEVICE, pGuid, sizeof( GUID ), DPNA_DATATYPE_GUID );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
	}

	return hr;
}

#endif // ! DPNBUILD_ONLYONEADAPTER


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetUserData"
HRESULT DP8ADDRESSOBJECT::SetUserData( const void * const pvData, const DWORD dwDataSize )
{
	if( pvData == NULL && dwDataSize > 0 )
	{
		DPFX(DPFPREP,  0, "Invalid param" );
		return DPNERR_INVALIDPARAM;
	}

	ENTERLOCK();

	if( m_dwUserDataSize > 0 )
	{
		// Remove escaped user data
		m_dwStringSize -= m_dwUserDataStringSize;
	}
	
	if( dwDataSize == 0 )
	{
		m_dwUserDataSize = 0;
		if( m_pvUserData != NULL )
			DNFree(m_pvUserData);
		m_pvUserData = NULL;
		LEAVELOCK();
		return DPN_OK;
	}

	PBYTE pNewDataBuffer;

	if( dwDataSize > m_dwUserDataSize )
	{
		pNewDataBuffer = (BYTE*) DNMalloc(dwDataSize);

		if( pNewDataBuffer == NULL )
		{
			DPFX(DPFPREP,  0, "Error allocating memory" );
			LEAVELOCK();			
			return DPNERR_OUTOFMEMORY;
		}

		if( m_pvUserData != NULL )
		{
			DNFree(m_pvUserData);
		}

		m_pvUserData = pNewDataBuffer;
	}

	m_dwUserDataStringSize = CalcExpandedBinarySize( (PBYTE) pvData, dwDataSize );

	m_dwStringSize += m_dwUserDataStringSize;
	m_dwStringSize += DNURL_LENGTH_USERDATA_SEPERATOR;

	memcpy( m_pvUserData, pvData, dwDataSize );
	m_dwUserDataSize = dwDataSize;

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::GetUserData"
HRESULT DP8ADDRESSOBJECT::GetUserData( void * pvDataBuffer, PDWORD pdwDataSize )
{
	if( pdwDataSize == NULL )
	{
		DPFX(DPFPREP,  0, "Must specify a pointer for the size" );
		return DPNERR_INVALIDPOINTER;
	}

	ENTERLOCK();

	if( m_dwUserDataSize == 0 )
	{
		LEAVELOCK();
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "No user data was specified for this address" );
		return DPNERR_DOESNOTEXIST;
	}

	if( *pdwDataSize < m_dwUserDataSize )
	{
		*pdwDataSize = m_dwUserDataSize;
		LEAVELOCK();		
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small" );
		return DPNERR_BUFFERTOOSMALL;
	}

	memcpy( pvDataBuffer, m_pvUserData, m_dwUserDataSize );

	LEAVELOCK();	

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::Cleanup"
HRESULT DP8ADDRESSOBJECT::Cleanup()
{
	Clear();
	
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::CalcExpandedBinarySize"
DWORD DP8ADDRESSOBJECT::CalcExpandedBinarySize( PBYTE pbData, DWORD dwDataSize )
{
	PBYTE pbCurrentLocation = pbData;
	DWORD dwCount = 0;


	for( DWORD dwIndex = 0; dwIndex < dwDataSize; dwIndex++ )
	{
		if( IsEscapeChar( (WCHAR) *pbCurrentLocation ) )
		{
			if( ((WCHAR) *pbCurrentLocation) == DPNA_ESCAPECHAR )
				dwCount += 2;
			else
				dwCount+=3;
		}
		else
		{
			dwCount++;
		}

		pbCurrentLocation++;
	}

	return dwCount;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::CalcExpandedStringSize"
DWORD DP8ADDRESSOBJECT::CalcExpandedStringSize( WCHAR *szString )
{
	WCHAR *szCurrentLocation = szString;
	DWORD dwCount = 0;

	while( *szCurrentLocation )
	{
		if( IsEscapeChar( *szCurrentLocation ) )
		{
			if( *szCurrentLocation == DPNA_ESCAPECHAR )
				dwCount += 2;
			else
				dwCount+=3;
		}
		else
		{
			dwCount++;
		}

		szCurrentLocation++;
	}

	return dwCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::CalcComponentStringSize"
HRESULT DP8ADDRESSOBJECT::CalcComponentStringSize( PDP8ADDRESSELEMENT paddElement, PDWORD pdwSize )
{
	if( paddElement == NULL )
		return DPNERR_INVALIDPOINTER;

	if( paddElement->dwType == DPNA_DATATYPE_GUID )
	{
		*pdwSize = DNURL_LENGTH_GUID;
	}
	else if( paddElement->dwType == DPNA_DATATYPE_DWORD )
	{
		WCHAR tmpString[DNURL_LENGTH_DWORD+1];
		
		swprintf( tmpString, L"%u", paddElement->uData.dwData );		
		
		*pdwSize = wcslen(tmpString);	
	}
	// No WWCHARs need to be escaped
	else if( paddElement->dwType == DPNA_DATATYPE_STRING )
	{
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
			*pdwSize = CalcExpandedStringSize( (WCHAR *) paddElement->uData.pvData );
		}
		else
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
		{
			*pdwSize = CalcExpandedStringSize( paddElement->uData.szData );		
		}
	}
	// Every WWCHAR needs to be escaped
	else
	{
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
		if( paddElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
		{
			*pdwSize = CalcExpandedBinarySize( (BYTE *) paddElement->uData.pvData, paddElement->dwDataSize );
		}
		else
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
		{
			*pdwSize = CalcExpandedBinarySize( (BYTE *) paddElement->uData.szData, paddElement->dwDataSize );		
		}	
	}

	// Add on the tag
	*pdwSize += paddElement->dwTagSize-1;

	// Add on the = and the ;
	(*pdwSize) ++;

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::IsEscapeChar"
BOOL DP8ADDRESSOBJECT::IsEscapeChar( WCHAR ch )
{
	if( ch >= L'A' && ch <= L'Z' )
		return FALSE;

	if( ch >= L'a' && ch <= L'z' )
		return FALSE;

	if( ch >= L'0' && ch <= L'9' )
		return FALSE;

	if( ch == L'-' || ch == L'?' || ch == L'.' ||
		ch == L',' || ch == 'L+' || ch == L'_' )
		return FALSE;

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddString"
void DP8ADDRESSOBJECT::BuildURL_AddString( WCHAR *szElements, WCHAR *szSource )
{
	WCHAR *szSourceLoc = szSource;
	WCHAR tmpEscape[4];
	DWORD dwIndex;

	while( *szSourceLoc )
	{
		if( IsEscapeChar( *szSourceLoc ) )
		{
			if( *szSourceLoc == DPNA_ESCAPECHAR )
			{
				wcscat( szElements, L"%%" );
			}
			else
			{
				swprintf( tmpEscape, L"%%%02.2X", (DWORD) *szSourceLoc );
				wcscat( szElements, tmpEscape );		
			}
		}
		else
		{
			dwIndex = wcslen(szElements);
			szElements[dwIndex] = *szSourceLoc;
			szElements[dwIndex+1] = 0;
		}

		szSourceLoc++;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddElements"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddElements( WCHAR *szElements )
{
	DP8ADDRESSELEMENT *pCurrentElement;
	CBilink *pblRunner;
	WCHAR tmpString[DNURL_LENGTH_GUID+2];
#ifdef DPNBUILD_ONLYONESP
	BOOL fFirstElement = FALSE; // built-in provider always comes first
#else // ! DPNBUILD_ONLYONESP
	BOOL fFirstElement = TRUE;
#endif // ! DPNBUILD_ONLYONESP
	DWORD dwTmpLength;

	pblRunner = m_blAddressElements.GetNext();

	while( pblRunner != &m_blAddressElements )
	{
		pCurrentElement = CONTAINING_OBJECT(pblRunner, DP8ADDRESSELEMENT, blAddressElements);

		if( !fFirstElement )
		{
			dwTmpLength = wcslen(szElements);
			szElements[dwTmpLength] = DPNA_SEPARATOR_COMPONENT;
			szElements[dwTmpLength+1] = 0;
		}

		wcscat( szElements, pCurrentElement->pszTag );

		dwTmpLength = wcslen(szElements);
		szElements[dwTmpLength] = DPNA_SEPARATOR_KEYVALUE;
		szElements[dwTmpLength+1] = 0;
	
		if( pCurrentElement->dwType == DPNA_DATATYPE_STRING )
		{
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
			if( pCurrentElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
			{
				BuildURL_AddString( szElements, (WCHAR *) pCurrentElement->uData.pvData );			
			}
			else
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
			{
				BuildURL_AddString( szElements, pCurrentElement->uData.szData );
			}
		}
		else if( pCurrentElement->dwType == DPNA_DATATYPE_GUID )
		{
			swprintf( tmpString, L"%%7B%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X%%7D",
    		       pCurrentElement->uData.guidData.Data1, pCurrentElement->uData.guidData.Data2, pCurrentElement->uData.guidData.Data3,
    		       pCurrentElement->uData.guidData.Data4[0], pCurrentElement->uData.guidData.Data4[1],
    		       pCurrentElement->uData.guidData.Data4[2], pCurrentElement->uData.guidData.Data4[3],
		           pCurrentElement->uData.guidData.Data4[4], pCurrentElement->uData.guidData.Data4[5],
		           pCurrentElement->uData.guidData.Data4[6], pCurrentElement->uData.guidData.Data4[7] );			
		    wcscat( szElements, tmpString );
		}
		else if( pCurrentElement->dwType == DPNA_DATATYPE_DWORD )
		{
			swprintf( tmpString, L"%u", pCurrentElement->uData.dwData );	
			wcscat( szElements, tmpString );
		}
		// Binary
		else
		{
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
			if( pCurrentElement->dwFlags & DP8ADDRESS_ELEMENT_HEAP )
			{
				BuildURL_AddBinaryData( szElements, (BYTE *) pCurrentElement->uData.pvData , pCurrentElement->dwDataSize );				
			}
			else
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
			{
				BuildURL_AddBinaryData( szElements, ((BYTE *) &pCurrentElement->uData), pCurrentElement->dwDataSize );
			}
		}

		fFirstElement = FALSE;
		
		pblRunner = pblRunner->GetNext();
	}

	return DPN_OK;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddHeader"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddHeader( WCHAR *szWorking )
{
	WCHAR *szReturn;

#ifdef DPNBUILD_ONLYONESP
	wcscpy( szWorking, DPNA_HEADER DPNA_BUILTINPROVIDER );
	szReturn = szWorking + DNURL_LENGTH_HEADER + DNURL_LENGTH_BUILTINPROVIDER;
#else // ! DPNBUILD_ONLYONESP
	wcscpy( szWorking, DPNA_HEADER );
	szReturn = szWorking + DNURL_LENGTH_HEADER;
#endif // ! DPNBUILD_ONLYONESP

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddUserData"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddUserData(WCHAR * szWorking)
{
	return BuildURL_AddBinaryData( szWorking, (BYTE *) m_pvUserData, m_dwUserDataSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURL_AddBinaryData"
HRESULT DP8ADDRESSOBJECT::BuildURL_AddBinaryData( WCHAR *szSource, BYTE *bData, DWORD dwDataLen )
{
	WCHAR *pwszCurrentDest = szSource + wcslen(szSource);
	BYTE *pbCurrentData = bData;
	DWORD dwDataRemaining = dwDataLen;


	dwDataRemaining = dwDataLen;
	while ( dwDataRemaining > 0 )
	{
		if( IsEscapeChar( (WCHAR) *pbCurrentData ) )
		{
			if( ((WCHAR) *pbCurrentData) == DPNA_ESCAPECHAR )
			{
				wcscpy(pwszCurrentDest, L"%%");
				pwszCurrentDest += 2;
			}
			else
			{
				pwszCurrentDest += swprintf( pwszCurrentDest, L"%%%02.2X", (DWORD) *pbCurrentData );
			}
		}
		else
		{
			*pwszCurrentDest = (WCHAR) *pbCurrentData;
			pwszCurrentDest++;
		}

		pbCurrentData++;
		dwDataRemaining--;
	}

	// Ensure the string is NULL terminated if we added anything.
	if ( dwDataLen > 0 )
	{
		*pwszCurrentDest = 0;
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURLA"
HRESULT DP8ADDRESSOBJECT::BuildURLA( char * szURL, PDWORD pdwRequiredSize )
{
	HRESULT		hr;
	WCHAR		wszStackTemp[256];
	WCHAR *		pwszTemp;
	DWORD		dwSize;


	ENTERLOCK();

	if( *pdwRequiredSize < m_dwStringSize || szURL == NULL )
	{
		*pdwRequiredSize = m_dwStringSize;
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small" );
		LEAVELOCK();
		return DPNERR_BUFFERTOOSMALL;
	}

	// Allocate a buffer if the string is too large to convert in our
	// stack based buffer.
	if ((m_dwStringSize * sizeof(WCHAR)) > sizeof(wszStackTemp))
	{
		pwszTemp = (WCHAR*) DNMalloc(m_dwStringSize * sizeof(WCHAR));
		if (pwszTemp == NULL)
		{
			DPFX(DPFPREP, 0, "Error allocating memory for conversion");
			LEAVELOCK();
			return DPNERR_OUTOFMEMORY;
		}
		dwSize = m_dwStringSize;
	}
	else
	{
		pwszTemp = wszStackTemp;
		dwSize = sizeof(wszStackTemp) / sizeof(WCHAR);
	}

	// BuildURLW takes the lock again.
	hr = BuildURLW( pwszTemp, &dwSize );
	if( FAILED( hr ) )
	{
		LEAVELOCK();
		return hr;
	}
		
	hr = STR_jkWideToAnsi(szURL, pwszTemp, dwSize);
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
		hr = DPNERR_CONVERSION;
	}
	else
	{
		*pdwRequiredSize = dwSize;
	}

	if (pwszTemp != wszStackTemp)
	{
		DNFree(pwszTemp);
		pwszTemp = NULL;
	}

	LEAVELOCK();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::BuildURLW"
HRESULT DP8ADDRESSOBJECT::BuildURLW( WCHAR * szURL, PDWORD pdwRequiredSize )
{
	HRESULT hr;

	ENTERLOCK();

	if( *pdwRequiredSize < m_dwStringSize || szURL == NULL )
	{
		*pdwRequiredSize = m_dwStringSize;
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small" );
		LEAVELOCK();
		return DPNERR_BUFFERTOOSMALL;
	}

	hr = BuildURL_AddHeader( szURL );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error adding header hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	hr = BuildURL_AddElements( szURL );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error adding elements hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}
	
	hr = BuildURL_AddUserData( szURL );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error adding user data hr=0x%x", hr );
		LEAVELOCK();		
		return hr;
	}

	LEAVELOCK();

	*pdwRequiredSize = m_dwStringSize;

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetURL"
HRESULT DP8ADDRESSOBJECT::SetURL( WCHAR * szURL )
{
	HRESULT hr;

	DP8ADDRESSPARSE dp8aParser;

	hr = Clear();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to clear existing address hr=0x%x", hr );
		return hr;
	}

	ENTERLOCK();	

	hr = dp8aParser.ParseURL(this, szURL);

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error parsing the URL hr=0x%x", hr );
		LEAVELOCK();
		return hr;
	}

	LEAVELOCK();	

	return hr;
}


#ifndef DPNBUILD_NOLEGACYDP

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ADDRESSOBJECT::SetDirectPlay4Address"
HRESULT DP8ADDRESSOBJECT::SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize )
{
    PBYTE pbCurrentLocation;
    PDPADDRESS pdpAddressChunk;
    LONG lRemaining;
    HRESULT hr = DPN_OK;
    DWORD dwCurrentChunkSize;
    DWORD dwNumElementsParsed = 0;

    ENTERLOCK();

    hr = Clear();

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Failed to clear old address data hr=[0x%lx]", hr );
        LEAVELOCK();
        return hr;
    }

    pbCurrentLocation = (PBYTE) pvDataBuffer;
    lRemaining = dwDataSize;

    while( lRemaining > 0 )
    {
        pdpAddressChunk = (PDPADDRESS) pbCurrentLocation;

        if( sizeof( DPADDRESS ) > lRemaining )
        {
            DPFX(DPFPREP,  0, "Error parsing address, unexpected end of address" );
			LEAVELOCK();
            return DPNERR_INVALIDADDRESSFORMAT;
        }

        dwCurrentChunkSize = sizeof( DPADDRESS ) + pdpAddressChunk->dwDataSize;

        if( ((LONG) dwCurrentChunkSize) > lRemaining )
        {
            DPFX(DPFPREP,  0, "Error parsing address, unexpected end during data" );
			LEAVELOCK();
            return DPNERR_INVALIDADDRESSFORMAT;
        }

        hr = AddDP4Element( pdpAddressChunk, this );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error adding next element" );
            break;
        }

        lRemaining -= dwCurrentChunkSize;

        pbCurrentLocation += dwCurrentChunkSize;
    }

    LEAVELOCK();

    return hr;
}

#endif // ! DPNBUILD_NOLEGACYDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addtcp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addtcp.cpp
 *  Content:    DirectPlay8Address TCP interface file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/12/2000	rmt		Completed first implementation
 * 02/17/2000	rmt		Parameter validation work
 * 02/20/2000	rmt		Changed ports to USHORTs
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls
 * 02/23/2000	rmt		Further parameter validation
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses
 * 03/24/2000	rmt		Added IsEqual function
 *	05/04/00	mjn		Fixed leak in DP8ATCP_GetSockAddress()
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 * 08/03/2000 	rmt		Bug #41246 - Remove IP versions of Duplicate, SetEqual, IsEqual, BuildURL
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


#ifndef DPNBUILD_NOADDRESSIPINTERFACE


typedef	STDMETHODIMP TCPQueryInterface( IDirectPlay8AddressIP *pInterface, DPNAREFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	TCPAddRef( IDirectPlay8AddressIP *pInterface );
typedef	STDMETHODIMP_(ULONG)	TCPRelease( IDirectPlay8AddressIP *pInterface );
//
// VTable for client interface
//
IDirectPlay8AddressIPVtbl DP8A_IPVtbl =
{
	(TCPQueryInterface*)		DP8A_QueryInterface,
	(TCPAddRef*)				DP8A_AddRef,
	(TCPRelease*)				DP8A_Release,
								DP8ATCP_BuildFromSockAddr,
								DP8ATCP_BuildAddressW,
								DP8ATCP_BuildLocalAddress,
								DP8ATCP_GetSockAddress,
								DP8ATCP_GetLocalAddress,
								DP8ATCP_GetAddressW,
};

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_BuildLocalAddress"
STDMETHODIMP DP8ATCP_BuildLocalAddress( IDirectPlay8AddressIP *pInterface, const GUID * const pguidAdapter, const USHORT usPort )
{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );		

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	if( pguidAdapter == NULL ||
	   !DNVALID_READPTR( pguidAdapter, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  0, "Invalid pointer" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );	
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidAdapter: 0x%p usPort: %u", pguidAdapter, (DWORD)usPort );	

	hr = pdp8Address->Clear();
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Failed to clear current address hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}

#ifndef DPNBUILD_ONLYONESP
	hr = pdp8Address->SetSP( &CLSID_DP8SP_TCPIP );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting service provider hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
#endif // ! DPNBUILD_ONLYONESP

#ifndef DPNBUILD_ONLYONEADAPTER
	hr = pdp8Address->SetDevice( pguidAdapter );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting device hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	DWORD dwTmpPort = usPort;

	hr = pdp8Address->SetElement( DPNA_KEY_PORT, &dwTmpPort, sizeof( DWORD ), DPNA_DATATYPE_DWORD );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
	
	DP8A_RETURN( hr );	
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_BuildFromSockAddr"
STDMETHODIMP DP8ATCP_BuildFromSockAddr( IDirectPlay8AddressIP *pInterface, const SOCKADDR * const pSockAddr )
{
	HRESULT hr;
	DWORD dwTmpPort;
	WCHAR wszHostName[16]; // Should be xxx.xxx.xxx.xxx + null
	sockaddr_in *saIPAddress;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}
	
	if( pSockAddr == NULL ||
	   !DNVALID_READPTR( pSockAddr, sizeof( SOCKADDR ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to sockaddr" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( pSockAddr->sa_family != AF_INET )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Only IPv4 addresses are supported" );
		DP8A_RETURN( DPNERR_INVALIDPARAM );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pSockAddr: 0x%p", pSockAddr );	

	saIPAddress = (sockaddr_in * ) pSockAddr;

	hr = pdp8Address->Clear();
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Failed clearing object hr=0x%x", hr );
		goto BUILDFROMSOCKADDR_ERROR;
	}

#ifndef DPNBUILD_ONLYONESP
	hr = pdp8Address->SetSP( &CLSID_DP8SP_TCPIP );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting service provider hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
#endif // ! DPNBUILD_ONLYONESP

	// Sockaddr is in network byte order, convert to host order
	dwTmpPort = ntohs(saIPAddress->sin_port);

	DNinet_ntow(saIPAddress->sin_addr, wszHostName);

	DNASSERT(wcslen(wszHostName) < 16);

	hr = pdp8Address->SetElement( DPNA_KEY_HOSTNAME, wszHostName, 16 * sizeof(WCHAR), DPNA_DATATYPE_STRING );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Failed to set hostname hr=0x%x", hr );
		DP8A_RETURN( hr );
	}	

	hr = pdp8Address->SetElement( DPNA_KEY_PORT, &dwTmpPort, sizeof(DWORD), DPNA_DATATYPE_DWORD );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Failed setting port hr=0x%x", hr );
		DP8A_RETURN( hr );
	}

	DP8A_RETURN( DPN_OK );

BUILDFROMSOCKADDR_ERROR:

	DP8A_RETURN( hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_BuildAddressW"
STDMETHODIMP DP8ATCP_BuildAddressW( IDirectPlay8AddressIP *pInterface, const WCHAR * const pwszAddress, const USHORT usPort )
{
	HRESULT hr;

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	if( pwszAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer to address" );
		DP8A_RETURN( E_POINTER );		
	}

	if( !DNVALID_STRING_W( pwszAddress ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid string for address" );
		DP8A_RETURN( DPNERR_INVALIDSTRING );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress: 0x%p, usPort = %u", pwszAddress, (DWORD)usPort );

	hr = pdp8Address->Clear();
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error clearing current address hr=0x%x", hr );
		DP8A_RETURN( hr );		
	}

#ifndef DPNBUILD_ONLYONESP
	hr = pdp8Address->SetSP( &CLSID_DP8SP_TCPIP );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error setting service provider hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
#endif // ! DPNBUILD_ONLYONESP

	hr = pdp8Address->SetElement( DPNA_KEY_HOSTNAME, pwszAddress, (wcslen(pwszAddress)+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}	

	DWORD dwTmpPort = usPort;
	
	hr = pdp8Address->SetElement( DPNA_KEY_PORT, &dwTmpPort, sizeof( DWORD ), DPNA_DATATYPE_DWORD );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Adding SP element failed hr=0x%x", hr );
		DP8A_RETURN( hr );	
	}
	
	DP8A_RETURN( hr );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_GetSockAddress"
STDMETHODIMP DP8ATCP_GetSockAddress( IDirectPlay8AddressIP *pInterface, SOCKADDR *pSockAddr, PDWORD pdwBufferSize )
{
	HRESULT hr;
	WCHAR *swzAddress = NULL;		// Unicode version of hostname
	CHAR *szAddress = NULL; 		// ANSI version of hostname
	DWORD dwAddressSize = 0;
	USHORT usPort;
	in_addr iaTmp;
	DWORD dwRequiredSize;
	sockaddr_in *psinCurAddress;
#ifndef _XBOX
	LPHOSTENT lpHostEntry;
	in_addr *piaTmp;
	DWORD dwNumElements;
	DWORD dwIndex;
	SOCKADDR *pCurLoc;
#endif // ! _XBOX

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	if( pdwBufferSize == NULL ||
	   !DNVALID_WRITEPTR( pdwBufferSize, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for pdwBufferSize" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( *pdwBufferSize > 0 &&
	   (pSockAddr == NULL || !DNVALID_WRITEPTR( pSockAddr, *pdwBufferSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for sockaddress" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}
#endif // !DPNBUILD_NOPARAMVAL

	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pSockAddr = 0x%p, pdwBufferSize = 0x%p (%d)", pSockAddr, pdwBufferSize, *pdwBufferSize );	

	hr = DP8ATCP_GetAddressW( pInterface, swzAddress, &dwAddressSize, &usPort );

	if( hr != DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve size required hr=0x%x", hr );
		goto GETSOCKADDRESS_ERROR;
	}

	swzAddress = (WCHAR*) DNMalloc(dwAddressSize * sizeof(WCHAR));

	if( swzAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error allocating memory hr=0x%x", hr );
		hr = DPNERR_OUTOFMEMORY;
		goto GETSOCKADDRESS_ERROR;
	}

	hr = DP8ATCP_GetAddressW( pInterface, swzAddress, &dwAddressSize, &usPort );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve address hr=0x%x", hr );
		goto GETSOCKADDRESS_ERROR;
	}	

	szAddress = (CHAR*) DNMalloc(dwAddressSize * sizeof(CHAR));

	if( szAddress == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error allocating memory hr=0x%x", hr );
		hr = DPNERR_OUTOFMEMORY;
		goto GETSOCKADDRESS_ERROR;	
	}

	if( FAILED( hr = STR_jkWideToAnsi( szAddress, swzAddress, dwAddressSize ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Error converting address to ANSI hr=0x%x", hr );
		hr = DPNERR_CONVERSION;
		goto GETSOCKADDRESS_ERROR;
	}

	iaTmp.s_addr = inet_addr( szAddress );

    if( iaTmp.s_addr != INADDR_NONE || strcmp( szAddress, "255.255.255.255" ) == 0 )
    {
        dwRequiredSize = sizeof( SOCKADDR );

	    if( *pdwBufferSize < dwRequiredSize )
	    {
		    *pdwBufferSize = dwRequiredSize;
		    DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small" );
		    hr = DPNERR_BUFFERTOOSMALL;
		    goto GETSOCKADDRESS_ERROR;
	    }

        memset( pSockAddr, 0x00, sizeof( SOCKADDR ) );

        psinCurAddress = (sockaddr_in *) pSockAddr;

   		psinCurAddress->sin_family = AF_INET;
		psinCurAddress->sin_port = htons(usPort);
		psinCurAddress->sin_addr = iaTmp;

		hr = DPN_OK;

		goto GETSOCKADDRESS_ERROR;
    }

#ifdef _XBOX
#pragma TODO(vanceo, "Use Xbox specific name lookup if available")
	DPFX(DPFPREP, 0, "Unable to resolve IP address \"%hs\"!", szAddress);
	hr = DPNERR_INVALIDHOSTADDRESS;
	goto GETSOCKADDRESS_ERROR;
#else // ! _XBOX
	lpHostEntry = gethostbyname( szAddress );	

	if( lpHostEntry == NULL )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid host specified hr=0x%x" , hr );
		hr = DPNERR_INVALIDHOSTADDRESS;
		goto GETSOCKADDRESS_ERROR;
	}

	// Count addresses
	for( dwNumElements = 0; ; dwNumElements++ )
	{
		piaTmp = ((LPIN_ADDR)lpHostEntry->h_addr_list[dwNumElements]);

		if( piaTmp == NULL )
			break;
	}

	dwRequiredSize = dwNumElements * sizeof( SOCKADDR );

	if( *pdwBufferSize < dwRequiredSize )
	{
		*pdwBufferSize = dwRequiredSize;
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small" );
		hr = DPNERR_BUFFERTOOSMALL;
		goto GETSOCKADDRESS_ERROR;
	}

	*pdwBufferSize = dwRequiredSize;

	pCurLoc = pSockAddr;

	memset( pCurLoc, 0x00, *pdwBufferSize );

	// Build addresses and copy them to the buffer
	for( dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
	{
		psinCurAddress = (sockaddr_in *) pCurLoc;
		psinCurAddress->sin_family = AF_INET;
		psinCurAddress->sin_port = htons(usPort);
		psinCurAddress->sin_addr = *((LPIN_ADDR)lpHostEntry->h_addr_list[dwIndex]);
		
		pCurLoc++;
	}

	DNFree(swzAddress);
	DNFree(szAddress);

	DP8A_RETURN( DPN_OK );
#endif // ! _XBOX

GETSOCKADDRESS_ERROR:

	if( swzAddress != NULL )
		DNFree(swzAddress);

	if( szAddress != NULL )
		DNFree(szAddress);

	DP8A_RETURN( hr );
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_GetLocalAddress"
STDMETHODIMP DP8ATCP_GetLocalAddress( IDirectPlay8AddressIP *pInterface, GUID * pguidAdapter, PUSHORT pusPort )
{
	HRESULT hr;
#ifndef DPNBUILD_ONLYONEADAPTER
	GUID guidDevice;
#endif // ! DPNBUILD_ONLYONEADAPTER
	DWORD dwPort;
	DWORD dwType;
	DWORD dwSize;
#ifndef DPNBUILD_ONLYONESP
	GUID guidSP;
#endif // ! DPNBUILD_ONLYONESP

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	if( pguidAdapter == NULL ||
	   !DNVALID_WRITEPTR( pguidAdapter, sizeof( GUID ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for adapter" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( pusPort == NULL ||
	   !DNVALID_WRITEPTR( pusPort, sizeof( USHORT ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for port" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pguidAdapter = 0x%p pusPort = 0x%p",
	     pguidAdapter, pusPort );

#ifndef DPNBUILD_ONLYONESP
	hr = pdp8Address->GetSP( &guidSP );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "No provider SP specified hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;		
		DP8A_RETURN( hr );		
	}

	if( guidSP != CLSID_DP8SP_TCPIP )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Not an IP address" );
		hr = DPNERR_INVALIDADDRESSFORMAT;
		DP8A_RETURN( hr );
	}
#endif // ! DPNBUILD_ONLYONESP

#ifndef DPNBUILD_ONLYONEADAPTER
	hr = pdp8Address->GetElementType( DPNA_KEY_DEVICE, &dwType );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "This device element doesn't exist hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;		
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_GUID )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Address: The device is not a GUID hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	hr = pdp8Address->GetElementType( DPNA_KEY_PORT, &dwType );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "This address does not have a port element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_DWORD )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Address: The port is not a dword hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}

	dwSize = sizeof(DWORD);

	hr = pdp8Address->GetElement( DPNA_KEY_PORT, &dwPort, &dwSize, &dwType );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve port element hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}

#ifdef DPNBUILD_ONLYONEADAPTER
	// Just return GUID_NULL
	memset(pguidAdapter, 0, sizeof(GUID));
#else // ! DPNBUILD_ONLYONEADAPTER
	dwSize = sizeof(GUID);

	hr = pdp8Address->GetElement( DPNA_KEY_DEVICE, &guidDevice, &dwSize, &dwType );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve device element hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}	

	*pguidAdapter = guidDevice;
#endif // ! DPNBUILD_ONLYONEADAPTER
	*pusPort = (USHORT) dwPort;

	DP8A_RETURN( DPN_OK );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP8ATCP_GetAddressW"
STDMETHODIMP DP8ATCP_GetAddressW( IDirectPlay8AddressIP *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, PUSHORT pusPort )
{
	HRESULT hr;
	DWORD dwPort;
	DWORD dwType;
	DWORD dwSize;
#ifndef DPNBUILD_ONLYONESP
	GUID guidSP;
#endif // ! DPNBUILD_ONLYONESP

	DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Enter" );

#ifndef DPNBUILD_NOPARAMVAL
	if( pInterface == NULL ||
	   !DP8A_VALID( pInterface ) )
	{
		DPFX(DPFPREP,  DP8A_ENTERLEVEL, "Invalid object" );
		DP8A_RETURN( DPNERR_INVALIDOBJECT );
	}

	if( pdwAddressLength == NULL ||
	   !DNVALID_WRITEPTR( pdwAddressLength, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for pdwAddressLength" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}

	if( *pdwAddressLength > 0 &&
	   (pwszAddress == NULL || !DNVALID_WRITEPTR( pwszAddress, (*pdwAddressLength)*sizeof(WCHAR) ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for pwszAddress" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );	
	}

	if( pusPort == NULL ||
	   !DNVALID_WRITEPTR( pusPort, sizeof( USHORT ) ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid pointer for port" );
		DP8A_RETURN( DPNERR_INVALIDPOINTER );
	}	
#endif // !DPNBUILD_NOPARAMVAL

	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
	
	DPFX(DPFPREP,  DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressLength = 0x%p (%u) pusPort = 0x%p (%u)",
	     pwszAddress, pdwAddressLength, *pdwAddressLength, pusPort, (DWORD)*pusPort );

#ifndef DPNBUILD_ONLYONESP
	hr = pdp8Address->GetSP( &guidSP );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "No provider SP specified hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );		
	}

	if( guidSP != CLSID_DP8SP_TCPIP )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Not an IP address" );
		hr = DPNERR_INVALIDADDRESSFORMAT;
		DP8A_RETURN( hr );
	}
#endif // ! DPNBUILD_ONLYONESP

	hr = pdp8Address->GetElementType( DPNA_KEY_HOSTNAME, &dwType );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "This address does not have a hostname element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;				
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_STRING )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Address: The host name is not a string hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}

	hr = pdp8Address->GetElementType( DPNA_KEY_PORT, &dwType );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "This address does not have a port element hr=0x%x", hr );
		hr = DPNERR_INCOMPLETEADDRESS;
		DP8A_RETURN( hr );
	}

	if( dwType != DPNA_DATATYPE_DWORD )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Invalid Address: The port is not a dword hr=0x%x", hr );
		hr = DPNERR_GENERIC;		
		DP8A_RETURN( hr );
	}

	dwSize = sizeof(DWORD);

	hr = pdp8Address->GetElement( DPNA_KEY_PORT, &dwPort, &dwSize, &dwType );
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve port element hr=0x%x", hr );
		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}

	*pdwAddressLength *= 2;

	hr = pdp8Address->GetElement( DPNA_KEY_HOSTNAME, pwszAddress, pdwAddressLength, &dwType );

	*pdwAddressLength /= 2;

	if( hr == DPNERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  DP8A_WARNINGLEVEL, "Buffer too small hr=0x%x", hr );
		DP8A_RETURN( hr );
	}
	else if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DP8A_ERRORLEVEL, "Unable to retrieve hostname element hr=0x%x", hr );
 		hr = DPNERR_GENERIC;
		DP8A_RETURN( hr );
	}	

	*pusPort = (USHORT) dwPort;
	
	DP8A_RETURN( DPN_OK );		
}


#endif // ! DPNBUILD_NOADDRESSIPINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\classfac.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.h
 *  Content:    DirectNet class factory header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	 10/08/99	jtk		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CLASSFAC_H__
#define	__CLASSFAC_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

#ifndef DPNBUILD_LIBINTERFACE
// 
// VTable for IUnknown
extern IUnknownVtbl  DP8A_UnknownVtbl;
#endif // ! DPNBUILD_LIBINTERFACE

//**********************************************************************
// Function prototypes
//**********************************************************************

//	DirectNet - IUnknown
STDMETHODIMP			DP8A_QueryInterface(LPVOID lpv, DPNAREFIID riid,LPVOID *ppvObj);
STDMETHODIMP_(ULONG)	DP8A_AddRef(LPVOID lphObj);
STDMETHODIMP_(ULONG)	DP8A_Release(LPVOID lphObj);

// Class Factory
#ifndef DPNBUILD_LIBINTERFACE
STDMETHODIMP			DP8ACF_CreateInstance(IClassFactory* pInterface, LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID *ppv);
#endif // ! DPNBUILD_LIBINTERFACE


#endif	// __CLASSFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\addtcp.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       addbase.h
 *  Content:    DirectPlay8Address TCP interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/17/2000	rmt		Parameter validation work 
 * 02/20/2000	rmt		Changed ports to USHORTs
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls  
 * 03/21/2000   rmt     Renamed all DirectPlayAddress8's to DirectPlay8Addresses 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ADDTCP_H__
#define	__ADDTCP_H__


#ifndef DPNBUILD_NOADDRESSIPINTERFACE


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for client interface
//
extern IDirectPlay8AddressIPVtbl DP8A_IPVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectPlay8AddressTCP 
//
STDMETHODIMP DP8ATCP_BuildFromSockAddr( IDirectPlay8AddressIP *pInterface, const SOCKADDR * const pSockAddr );
STDMETHODIMP DP8ATCP_BuildAddressW( IDirectPlay8AddressIP *pInterface, const WCHAR * const pwszAddress, const USHORT usPort );
STDMETHODIMP DP8ATCP_GetSockAddress( IDirectPlay8AddressIP *pInterface, SOCKADDR *pSockAddr, PDWORD pdwBufferSize );
STDMETHODIMP DP8ATCP_GetLocalAddress( IDirectPlay8AddressIP *pInterface, GUID * pguidAdapter, USHORT *psPort );
STDMETHODIMP DP8ATCP_GetAddressW( IDirectPlay8AddressIP *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, USHORT *psPort );
STDMETHODIMP DP8ATCP_BuildLocalAddress( IDirectPlay8AddressIP *pInterface, const GUID * const pguidAdapter, const USHORT psPort );



#endif // ! DPNBUILD_NOADDRESSIPINTERFACE

#endif // __ADDTCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\dplegacy.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplegacy.h
 *  Content:    Definitions for old DirectPlay's address type
 *
 *              WARNING: This file duplicates definitions found in dplobby.h
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/21/2000	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLEGACY_H
#define __DPLEGACY_H

#include "dplegacyguid.h"

typedef struct _DPADDRESS
{
    GUID                guidDataType;
    DWORD               dwDataSize;
} DPADDRESS, *PDPADDRESS, *LPDPADDRESS;

typedef struct DPCOMPORTADDRESS{
    DWORD dwComPort;
    DWORD dwBaudRate;
    DWORD dwStopBits;
    DWORD dwParity;
    DWORD dwFlowControl;
} DPCOMPORTADDRESS, *PDPCOMPORTADDRESS;

#define DPCPA_NOFLOW        0           // no flow control
#define DPCPA_XONXOFFFLOW   1           // software flow control
#define DPCPA_RTSFLOW       2           // hardware flow control with RTS
#define DPCPA_DTRFLOW       3           // hardware flow control with DTR
#define DPCPA_RTSDTRFLOW    4           // hardware flow control with RTS and DTR

#define DPNA_DATATYPE_DPCOMPORTADDRESS      0x00002000
#define DPNA_DATATYPE_NOP                   0x00004000

class DPLEGACYMAPGUIDTOSTRING
{
public:
    DPLEGACYMAPGUIDTOSTRING( const GUID &guidType, const WCHAR *const wszKeyName, DWORD dwDataType
        ): m_guidType(guidType), m_wszKeyName(wszKeyName), m_dwDataType(dwDataType)
    {
    };

    GUID                m_guidType;
    const WCHAR * const m_wszKeyName;
    DWORD               m_dwDataType;
};

typedef DPLEGACYMAPGUIDTOSTRING *PDPLEGACYMAPGUIDTOSTRING;

HRESULT AddDP4Element( PDPADDRESS pdpAddressElement, PDP8ADDRESSOBJECT pdpAddress );

#endif // __DPLEGACY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\dpnaddrextern.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnaddrextern.h
 *  Content:    DirectPlay Address Library external functions to be called
 *              by other DirectPlay components.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	 07/20/2001	masonb	Created
 *
 ***************************************************************************/

BOOL DNAddressInit(HANDLE hModule);
void DNAddressDeInit();
#ifndef DPNBUILD_NOCOMREGISTER
BOOL DNAddressRegister(LPCWSTR wszDLLName);
BOOL DNAddressUnRegister();
#endif // !DPNBUILD_NOCOMREGISTER
#ifdef DPNBUILD_LIBINTERFACE
STDMETHODIMP DP8ACF_CreateInstance(DPNAREFIID riid, LPVOID *ppv);

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT DNAddress_PreallocateInterfaces( const DWORD dwNumInterfaces );
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
#else // ! DPNBUILD_LIBINTERFACE
DWORD DNAddressGetRemainingObjectCount();

extern IClassFactoryVtbl DP8ACF_Vtbl;
#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\dnaddri.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnaddri.h
 *  Content:    DirectPlay Address master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNADDRI_H__
#define __DNADDRI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#include <xtl.h>
#else // ! _XBOX or XBOX_ON_DESKTOP
#include <windows.h>
#include <winsock.h>
#include <stdio.h>
#include <stdlib.h>
#endif // ! _XBOX or XBOX_ON_DESKTOP
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#ifndef DPNBUILD_NOVOICE
#include "dvoice.h"
#endif // !DPNBUILD_NOVOICE

// 
// DirectPlay private includes
//
#include "osind.h"
#include "classbilink.h"
#include "fixedpool.h"
#include "dneterrors.h"
#include "dndbg.h"
#include "comutil.h"
#include "creg.h"
#include "strutils.h"
#include "ClassFactory.h"

// 
// Addr private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_ADDR

#include "addbase.h"
#include "addcore.h"
#include "addparse.h"
#include "addtcp.h"
#include "classfac.h"
#include "strcache.h"
#ifndef DPNBUILD_NOLEGACYDP
#include "dplegacy.h"
#endif // ! DPNBUILD_NOLEGACYDP
#include "dpnaddrextern.h"

#endif // __DNADDRI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\sources.inc ===
TARGETNAME=dpnaddr
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnaddri.h
PRECOMPILED_PCH=dnaddri.pch
PRECOMPILED_OBJ=dnaddri.obj

INCLUDES=..\;..\..\inc;..\..\common;..\..\..\dvoice\inc;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES=addcore.cpp \
        addclassfac.cpp \
        adddllmain.cpp \
        addglobals.cpp \
        addtcp.cpp \
        addbase.cpp \
        strcache.cpp \
        addparse.cpp \
        dplegacy.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\dplegacy.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplegacy.cpp
 *  Content:    Definitions for old DirectPlay's address type
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/21/2000	rmt		Created
 *  07/21/2000	rmt		Minor bug fixes to dplay4 address parsing.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"

#ifndef DPNBUILD_NOLEGACYDP

#define DPLEGACY_ELEMENTS           11      

DPLEGACYMAPGUIDTOSTRING dpLegacyMap [DPLEGACY_ELEMENTS] =
{
    DPLEGACYMAPGUIDTOSTRING( DPAID_ServiceProvider, DPNA_KEY_PROVIDER, DPNA_DATATYPE_GUID ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_ComPort, DPNA_KEY_PORT, DPNA_DATATYPE_DPCOMPORTADDRESS ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_INet, DPNA_KEY_HOSTNAME, DPNA_DATATYPE_STRING_ANSI ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_INetW, DPNA_KEY_HOSTNAME, DPNA_DATATYPE_STRING ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_INetPort, DPNA_KEY_PORT, DPNA_DATATYPE_DWORD ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_LobbyProvider, L"lobbyprovider", DPNA_DATATYPE_GUID ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_Modem, L"modemname", DPNA_DATATYPE_STRING_ANSI ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_ModemW, L"modemname", DPNA_DATATYPE_STRING ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_Phone, DPNA_KEY_PHONENUMBER, DPNA_DATATYPE_STRING_ANSI ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_PhoneW, DPNA_KEY_PHONENUMBER, DPNA_DATATYPE_STRING ),
    DPLEGACYMAPGUIDTOSTRING( DPAID_TotalSize, DPNA_KEY_PORT, DPNA_DATATYPE_NOP )
};

#undef DPF_MODNAME
#define DPF_MODNAME "AddDP4Element"

HRESULT AddDP4Element( PDPADDRESS pdpAddressElement, PDP8ADDRESSOBJECT pdpAddress )
{
    DWORD dwIndex;
    HRESULT hr = DPN_OK;
    PDPCOMPORTADDRESS pPortAddress;
    WCHAR chPortBuffer[30];

    // Loop through entries
    for( dwIndex = 0 ; dwIndex < sizeof( dpLegacyMap ) / sizeof( DPLEGACYMAPGUIDTOSTRING ); dwIndex++ )
    {
        if( dpLegacyMap[dwIndex].m_guidType == pdpAddressElement->guidDataType )
        {
            switch( dpLegacyMap[dwIndex].m_dwDataType )
            {
            case DPNA_DATATYPE_STRING_ANSI:

#ifndef DPNBUILD_NOPARAMVAL
				// TODO: MASONB: Are these supposed to all be using element 1?
                if( !DNVALID_STRING_A( (char *) &pdpAddressElement[1] ) )
                {
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                }
                else
#endif // !DPNBUILD_NOPARAMVAL
                {
                    WCHAR *		pwszTemp;

					
                    pwszTemp = (WCHAR*) DNMalloc(pdpAddressElement->dwDataSize * 2);
                    if (pwszTemp == NULL)
                    {
                        DPFX(DPFPREP, 0, "Error allocating memory for conversion");
                        hr = DPNERR_OUTOFMEMORY;
                        break;
                    }

                    hr = STR_jkAnsiToWide(pwszTemp, (const char * const) &pdpAddressElement[1], pdpAddressElement->dwDataSize);
                    if( FAILED( hr ) )
                    {
                        DPFX(DPFPREP,  0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
                        hr = DPNERR_CONVERSION;
                    }
                    else
                    {
                        hr = pdpAddress->SetElement( dpLegacyMap[dwIndex].m_wszKeyName, pwszTemp, (pdpAddressElement->dwDataSize * 2), DPNA_DATATYPE_STRING );
                    }

                    DNFree(pwszTemp);
                }

                break;

            case DPNA_DATATYPE_DPCOMPORTADDRESS:

                pPortAddress = (PDPCOMPORTADDRESS) &pdpAddressElement[1];

                swprintf( chPortBuffer, L"COM%u", pPortAddress->dwComPort );

                hr = pdpAddress->SetElement( DPNA_KEY_STOPBITS, chPortBuffer, (wcslen( chPortBuffer )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Unable to specify port element hr=[0x%lx]", hr );
                    break;
                }

                hr = pdpAddress->SetElement( DPNA_KEY_BAUD, &pPortAddress->dwBaudRate, sizeof( DWORD ), DPNA_DATATYPE_DWORD );

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Unable to specify baudrate element hr=[0x%lx]", hr );
                    break;
                }

                switch( pPortAddress->dwStopBits )
                {
                case ONESTOPBIT:
                    hr = pdpAddress->SetElement( DPNA_KEY_STOPBITS, &DPNA_STOP_BITS_ONE, (wcslen( DPNA_STOP_BITS_ONE )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case ONE5STOPBITS:
                    hr = pdpAddress->SetElement( DPNA_KEY_STOPBITS, &DPNA_STOP_BITS_ONE_FIVE, (wcslen( DPNA_STOP_BITS_ONE_FIVE )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case TWOSTOPBITS:
                    hr = pdpAddress->SetElement( DPNA_KEY_STOPBITS, &DPNA_STOP_BITS_TWO, (wcslen( DPNA_STOP_BITS_TWO )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                default:
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                }

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Error converting stopbits element hr=[0x%lx]", hr );
                    break;
                }

                switch( pPortAddress->dwParity )
                {
                case NOPARITY:
                    hr = pdpAddress->SetElement( DPNA_KEY_PARITY, &DPNA_PARITY_NONE, (wcslen( DPNA_PARITY_NONE )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case ODDPARITY:
                    hr = pdpAddress->SetElement( DPNA_KEY_PARITY, &DPNA_PARITY_ODD, (wcslen( DPNA_PARITY_ODD )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case EVENPARITY:
                    hr = pdpAddress->SetElement( DPNA_KEY_PARITY, &DPNA_PARITY_EVEN, (wcslen( DPNA_PARITY_EVEN )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case MARKPARITY:
                    hr = pdpAddress->SetElement( DPNA_KEY_PARITY, &DPNA_PARITY_MARK, (wcslen( DPNA_PARITY_MARK )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                default:
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                }

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Error converting parity element hr=[0x%lx]", hr );
                    break;
                }

                switch( pPortAddress->dwFlowControl )
                {
                case DPCPA_NOFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_NONE, (wcslen( DPNA_KEY_FLOWCONTROL )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case DPCPA_XONXOFFFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_XONXOFF, (wcslen( DPNA_FLOW_CONTROL_XONXOFF )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case DPCPA_RTSFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_RTS, (wcslen( DPNA_FLOW_CONTROL_RTS )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case DPCPA_DTRFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_DTR, (wcslen( DPNA_FLOW_CONTROL_DTR )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                case DPCPA_RTSDTRFLOW:
                    hr = pdpAddress->SetElement( DPNA_KEY_FLOWCONTROL, &DPNA_FLOW_CONTROL_RTSDTR, (wcslen( DPNA_FLOW_CONTROL_RTSDTR )+1)*sizeof(WCHAR), DPNA_DATATYPE_STRING );
                    break;
                default:
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                }

                if( FAILED( hr ) )
                {
                    DPFX(DPFPREP,  0, "Error converting flow control element hr=[0x%lx]", hr );
                    break;
                }

                break;
            case DPNA_DATATYPE_DWORD:
                if( pdpAddressElement->dwDataSize != sizeof( DWORD ) )
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                else
                    hr = pdpAddress->SetElement( dpLegacyMap[dwIndex].m_wszKeyName, (LPVOID) &pdpAddressElement[1], pdpAddressElement->dwDataSize, DPNA_DATATYPE_DWORD );
                break;
            case DPNA_DATATYPE_GUID:
                if( pdpAddressElement->dwDataSize != sizeof( GUID ) )
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                else
                    hr = pdpAddress->SetElement( dpLegacyMap[dwIndex].m_wszKeyName, (LPVOID) &pdpAddressElement[1], pdpAddressElement->dwDataSize, DPNA_DATATYPE_GUID );
                break;
            case DPNA_DATATYPE_STRING:
#ifndef DPNBUILD_NOPARAMVAL
                if( !DNVALID_STRING_W( (WCHAR *) &pdpAddressElement[1] ) )
                    hr = DPNERR_INVALIDADDRESSFORMAT;
                else
#endif // !DPNBUILD_NOPARAMVAL
                    hr = pdpAddress->SetElement( dpLegacyMap[dwIndex].m_wszKeyName, (LPVOID) &pdpAddressElement[1], pdpAddressElement->dwDataSize, DPNA_DATATYPE_STRING );
                break;
            case DPNA_DATATYPE_NOP:
            	hr = DPN_OK;
            	break;
            default:
                hr = DPNERR_INVALIDADDRESSFORMAT;
                break;
            }
            break;
        }
    }

    if( dwIndex == DPLEGACY_ELEMENTS )
    {
        DPFX(DPFPREP,  0, "Address contains an element which cannot be mapped" );
        return DPNERR_INVALIDADDRESSFORMAT;
    }

    return hr;
}

#endif // ! DPNBUILD_NOLEGACYDP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\dplegacyguid.h ===
// {F2F0CE00-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ComPort, 
0xf2f0ce00, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {01FD92E0-A2FF-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_ModemW, 
0x1fd92e0, 0xa2ff, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {C4A54DA0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_INet, 
0xc4a54da0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {E63232A0-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_INetW, 
0xe63232a0, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);


// {E4524541-8EA5-11d1-8A96-006097B01411}
DEFINE_GUID(DPAID_INetPort, 
0xe4524541, 0x8ea5, 0x11d1, 0x8a, 0x96, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\strcache.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       strcache.h
 *  Content:   Class for caching strings
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef __STRCACHE_H
#define __STRCACHE_H

class CStringCache
{
public:
	void Initialize(void);
	void Deinitialize(void);

	HRESULT AddString( const WCHAR *pszString, WCHAR * *ppszSlot );
	
protected:
	HRESULT GetString( const WCHAR *pszString, WCHAR * *ppszSlot );
	HRESULT GrowCache( DWORD dwNewSize );

	WCHAR ** m_ppszStringCache;
	DWORD m_dwNumElements;
	DWORD m_dwNumSlots;
};

#endif // __STRCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvlib\dnsvlibi.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnSVLIBi.h
 *  Content:    DirectPlay DPNSvrLib master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNSVLIBI_H__
#define __DNSVLIBI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"

#ifdef UNICODE
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLW
#else
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLA
#endif // UNICODE

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "dneterrors.h"

//
// Dpnsvr includes
//
#include "dpnsdef.h"
#include "dpnsvmsg.h"

// 
// Dpnsvlib private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR

#include "dpnsvrq.h"
#include "dpnsvlib.h"


#endif // __DNSVLIBI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dnaddress\strcache.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       strcache.cpp
 *  Content:   Class for caching strings
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 02/04/2000	rmt		Created
 * 02/17/2000	rmt		Parameter validation work 
 * 02/21/2000	 rmt	Updated to make core Unicode and remove ANSI calls  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnaddri.h"


// # of slots to grow the cache at each opportunity
#define STRINGCACHE_GROW_SLOTS				10

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::Initialize"

void CStringCache::Initialize( void )
{
	m_ppszStringCache = NULL;
	m_dwNumElements = 0;
	m_dwNumSlots = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::Deinitialize"

void CStringCache::Deinitialize( void )
{
	for( DWORD dwIndex = 0; dwIndex < m_dwNumElements; dwIndex++ )
	{
		DNFree(m_ppszStringCache[dwIndex]);
	}

	DNFree(m_ppszStringCache);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::AddString"

HRESULT CStringCache::AddString( const WCHAR *pszString, WCHAR * *ppszSlot )
{
	HRESULT hr;
	PWSTR pszSlot;

	hr = GetString( pszString, &pszSlot );

	if( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Internal Error hr=0x%x", hr );
		return hr;
	}

	// Entry was found
	if( pszSlot != NULL )
	{
		*ppszSlot = pszSlot;
		return DPN_OK;
	}
	else
	{
		if( m_dwNumElements == m_dwNumSlots )
		{
			hr = GrowCache( m_dwNumSlots + STRINGCACHE_GROW_SLOTS );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Failed to grow string cache hr=0x%x", hr );
				return hr;
			}
		}

		m_ppszStringCache[m_dwNumElements] = (WCHAR*) DNMalloc((wcslen(pszString)+1)*sizeof(WCHAR));

		if( m_ppszStringCache[m_dwNumElements] == NULL )
		{
			DPFX(DPFPREP,  0, "Failed to alloc mem" );
			return DPNERR_OUTOFMEMORY;
		}

		wcscpy( m_ppszStringCache[m_dwNumElements], pszString );
		*ppszSlot = m_ppszStringCache[m_dwNumElements];

		m_dwNumElements++;

		return DPN_OK;
		
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::GetString"

HRESULT CStringCache::GetString( const WCHAR *pszString, WCHAR * *ppszSlot )
{
	*ppszSlot = NULL;
	
	for( DWORD dwIndex = 0; dwIndex < m_dwNumElements; dwIndex++ )
	{
		if( wcscmp( m_ppszStringCache[dwIndex], pszString ) == 0 )
		{
			*ppszSlot = m_ppszStringCache[dwIndex];
			return DPN_OK;
		}
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CStringCache::GrowCache"

HRESULT CStringCache::GrowCache( DWORD dwNewSize )
{
	WCHAR **ppszNewCache;

	ppszNewCache = (WCHAR**) DNMalloc(dwNewSize * sizeof(WCHAR*));

	if( ppszNewCache == NULL )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		return DPNERR_OUTOFMEMORY;
	}

	memcpy( ppszNewCache, m_ppszStringCache, sizeof( WCHAR * ) * m_dwNumElements );
	m_dwNumSlots = dwNewSize;

	if( m_ppszStringCache != NULL )
		DNFree(m_ppszStringCache);	

	m_ppszStringCache = ppszNewCache;

	return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvlib\dpnsvlib.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enumsvr.h
 *  Content:    DirectPlay8 <--> DPNSVR Utility functions
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/24/00	rmt		Created
 *  05/30/00    rmt     Bug #33622 DPNSVR does not shutdown when not in use
 *	09/04/00	mjn		Changed DPNSVR_Register() and DPNSVR_UnRegister() to use guids directly (rather than ApplicationDesc)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPNSVLIB_H
#define __DPNSVLIB_H

#define DPNSVR_REGISTER_ATTEMPTS	3
#define DPNSVR_REGISTER_SLEEP		300

typedef void (*PSTATUSHANDLER)(PVOID pvData,PVOID pvUserContext);
typedef void (*PTABLEHANDLER)(PVOID pvData,PVOID pvUserContext);

BOOL DPNSVR_IsRunning();

HRESULT DPNSVR_WaitForStartup( HANDLE hWaitHandle );
HRESULT DPNSVR_SendMessage( LPVOID pvMessage, DWORD dwSize );
HRESULT DPNSVR_StartDPNSVR( );
HRESULT DPNSVR_Register(const GUID *const pguidApplication,
						const GUID *const pguidInstance,
						IDirectPlay8Address *const prgpDeviceInfo);
HRESULT DPNSVR_UnRegister(const GUID *const pguidApplication,
						  const GUID *const pguidInstance);
HRESULT DPNSVR_RequestTerminate( const GUID *pguidInstance );
HRESULT DPNSVR_RequestStatus( const GUID *pguidInstance, PSTATUSHANDLER pStatusHandler, PVOID pvContext );
HRESULT DPNSVR_RequestTable( const GUID *pguidInstance, PTABLEHANDLER pTableHandler, PVOID pvContext );

#endif // __DPNSVLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvlib\dpnsvlib.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enumsvr.cpp
 *  Content:    DirectPlay8 <--> DPNSVR Utility functions
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/24/00	rmt		Created
 *  03/25/00    rmt     Updated to handle new status/table format for n providers
 *	09/04/00	mjn		Changed DPNSVR_Register() and DPNSVR_UnRegister() to use guids directly (rather than ApplicationDesc)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnsvlibi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR


#define DPNSVR_WAIT_STARTUP				30000


#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_IsRunning"
BOOL DPNSVR_IsRunning()
{
	DNHANDLE hRunningHandle = NULL;

	//
	//	Check to see if running by opening the running event
	//
	hRunningHandle = DNOpenEvent( SYNCHRONIZE, FALSE, GLOBALIZE_STR STRING_GUID_DPNSVR_RUNNING );
	if( hRunningHandle != NULL )
	{
		DNCloseHandle(hRunningHandle);
		return( TRUE );
	}
	return( FALSE );
}


#undef DPF_MODNAME 
#define DPF_MODNAME "DPNSVR_WaitForStartup"
HRESULT DPNSVR_WaitForStartup( DNHANDLE hWaitHandle )
{
	HRESULT	hr;
	LONG	lWaitResult;

	DPFX(DPFPREP,4,"Parameters: (none)" );

	//
	//	Wait for startup.. just in case it's starting up.
	//
	if ((lWaitResult = DNWaitForSingleObject( hWaitHandle,DPNSVR_WAIT_STARTUP )) == WAIT_TIMEOUT)
	{
		DPFX(DPFPREP,5,"Timed out waiting for DPNSVR to startup" );
		hr = DPNERR_TIMEDOUT;
	}
	else
	{
		DPFX(DPFPREP,5,"DPNSVR has started up" );
		hr = DPN_OK;
	}

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr );
	return( hr );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_SendMessage"
HRESULT DPNSVR_SendMessage( void *pvMessage, DWORD dwSize )
{
	HRESULT			hr;
	CDPNSVRIPCQueue ipcQueue;

	DPFX(DPFPREP,4,"Parameters: pvMessage [0x%p],dwSize [%ld]",pvMessage,dwSize);

	if ((hr = ipcQueue.Open( &GUID_DPNSVR_QUEUE,DPNSVR_MSGQ_SIZE,DPNSVR_MSGQ_OPEN_FLAG_NO_CREATE )) == DPN_OK)
	{
		if ((hr = ipcQueue.Send(static_cast<BYTE*>(pvMessage),
								dwSize,
								DPNSVR_TIMEOUT_REQUEST,
								DPNSVR_MSGQ_MSGFLAGS_USER1,
								0 )) != DPN_OK)
		{
			DPFX(DPFPREP,5,"Send failed to DPNSVR request queue");
		}

		ipcQueue.Close();
	}
	else
	{
		DPFX(DPFPREP,5,"Could not open DPNSVR request queue");
	}

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr );
	return( hr );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_WaitForResult"
HRESULT DPNSVR_WaitForResult( CDPNSVRIPCQueue *pQueue )
{
	HRESULT		hr;
	BYTE		*pBuffer = NULL;
	DWORD		dwBufferSize = 0;
    DPNSVR_MSGQ_HEADER	MsgHeader;
    DPNSVR_MSG_RESULT	*pMsgResult;

	DPFX(DPFPREP,4,"Parameters: pQueue [0x%p]",pQueue);

	DNASSERT( pQueue != NULL );

    if( DNWaitForSingleObject( pQueue->GetReceiveSemaphoreHandle(),DPNSVR_TIMEOUT_RESULT ) == WAIT_TIMEOUT )
    {
        DPFX(DPFPREP,5,"Wait for response timed out" );
		hr = DPNERR_TIMEDOUT;
		goto Failure;
    }

	while((hr = pQueue->GetNextMessage( &MsgHeader,pBuffer,&dwBufferSize )) == DPNERR_BUFFERTOOSMALL )
	{
		if (pBuffer)
		{
			delete [] pBuffer;
			pBuffer = NULL;
		}
		pBuffer = new BYTE[dwBufferSize];
		if( pBuffer==NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
	}
	if (hr != DPN_OK)
	{
		goto Failure;
	}
	if (pBuffer == NULL)
	{
		DPFERR( "Getting message failed" );
		hr = DPNERR_GENERIC;
		goto Failure;
	}

	pMsgResult = reinterpret_cast<DPNSVR_MSG_RESULT*>(pBuffer);
	if( pMsgResult->dwType != DPNSVR_MSGID_RESULT )
	{
		DPFERR( "Invalid message from DPNSVR" );
		DPFX(DPFPREP,5,"Recieved [0x%lx]",pMsgResult->dwType );
		hr = DPNERR_GENERIC;
		goto Failure;
	}

	hr = pMsgResult->hrCommandResult;

Exit:
	if( pBuffer )
	{
		delete [] pBuffer;
		pBuffer = NULL;
	}

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr );
	return( hr );

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_StartDPNSVR"
HRESULT DPNSVR_StartDPNSVR( void )
{
	HRESULT		hr;
	DNHANDLE	hRunningEvent = NULL;
	DNHANDLE	hStartupEvent = NULL;
    DNPROCESS_INFORMATION	pi;

#if !defined(WINCE) || defined(WINCE_ON_DESKTOP)
	TCHAR	szSystemDir[MAX_PATH+1];
	DWORD	dwSystemDirLen;
	TCHAR	*pszApplicationName = NULL;
	DWORD	dwApplicationNameLen;
    STARTUPINFO si;
#endif	//!WINCE

#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)
	TCHAR	szDPNSVR[] = _T("dpnsvr.exe"); 
#else
	// CreateProcess will attempt to add a terminating NULL so this must be writeable
#if !defined(DBG) || !defined( DIRECTX_REDIST )
	TCHAR	szDPNSVR[] = _T("\"dpnsvr.exe\""); 
#else
	// For redist debug builds we append a 'd' to the name to allow both debug and retail to be installed on the system
	TCHAR	szDPNSVR[] = _T("\"dpnsvrd.exe\""); 
#endif //  !defined(DBG) || !defined( DIRECTX_REDIST )
#endif

	DPFX(DPFPREP,4,"Parameters: (none)");

#if !defined(WINCE) || defined(WINCE_ON_DESKTOP)
	//
	//	Get Windows system directory name
	//
	if ((dwSystemDirLen = GetSystemDirectory(szSystemDir,MAX_PATH+1)) == 0)
	{
		DPFERR("Could not get system directory");
		hr = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Create application name for CreateProcess
	//
	dwApplicationNameLen = dwSystemDirLen + (1 + _tcslen(_T("dpnsvrd.exe")) + 1);	// slash and NULL terminator
	if ((pszApplicationName = static_cast<TCHAR*>(DNMalloc(dwApplicationNameLen * sizeof(TCHAR)))) == NULL)
	{
		DPFERR("Could not allocate space for application name");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pszApplicationName[0] = _T('\0');
	_tcscat(pszApplicationName,szSystemDir);
	_tcscat(pszApplicationName,_T("\\"));
#if !defined(DBG) || !defined( DIRECTX_REDIST )
	_tcscat(pszApplicationName,_T("dpnsvr.exe")); 
#else
	//
	//	For redist debug builds we append a 'd' to the name to allow both debug and retail to be installed on the system
	//
	_tcscat(pszApplicationName,_T("dpnsvrd.exe")); 
#endif	//  !defined(DBG) || !defined( DIRECTX_REDIST )
#endif	//!WINCE

	//
	//	Create startup event which we will wait on once we launch DPNSVR
	//
	if ((hStartupEvent = DNCreateEvent( DNGetNullDacl(),TRUE,FALSE,GLOBALIZE_STR STRING_GUID_DPNSVR_STARTUP )) == NULL)
	{
		DPFERR("Could not create DPNSVR startup event");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	//	Attempt to open the running event
	//
	if ((hRunningEvent = DNOpenEvent( SYNCHRONIZE, FALSE, GLOBALIZE_STR STRING_GUID_DPNSVR_RUNNING )) != NULL)
	{
		DPFX(DPFPREP,5,"DPNSVR is already running");

		hr = DPNSVR_WaitForStartup(hStartupEvent);
		goto Failure;
	}

#if !defined(WINCE) || defined(WINCE_ON_DESKTOP)
	memset(&si,0x00,sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);
#endif // !WINCE

    DPFX(DPFPREP,5,"Launching DPNSVR" );
#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)
	//
	//	WinCE AV's on a NULL first param and requires that Environment and CurrentDirectory be NULL.
	//	It also ignores STARTUPINFO.
	//
    if( !DNCreateProcess(szDPNSVR, NULL,  NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, NULL, &pi) )
#else // !WINCE
	if( !DNCreateProcess(pszApplicationName, szDPNSVR,  NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi) )
#endif // WINCE
    {
		DPFERR("CreateProcess() failed!");
        DPFX(DPFPREP,5,"Error = [0x%lx]",GetLastError());
		hr = DPNERR_GENERIC;
		goto Failure;
    }

	DNCloseHandle( pi.hProcess );
	DNCloseHandle( pi.hThread );

    DPFX(DPFPREP,5,"DPNSVR started" );

	hr = DPNSVR_WaitForStartup(hStartupEvent);
	
Exit:
	if ( hRunningEvent != NULL )
	{
		DNCloseHandle( hRunningEvent );
		hRunningEvent = NULL;
	}
	if ( hStartupEvent != NULL )
	{
		DNCloseHandle( hStartupEvent );
		hStartupEvent = NULL;
	}
#if !defined(WINCE) || defined(WINCE_ON_DESKTOP)
	if (pszApplicationName)
	{
		DNFree(pszApplicationName);
		pszApplicationName = NULL;
	}
#endif // !WINCE

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr );
	return( hr );

Failure:
	goto Exit;
}


// DPNSVR_Register
//
// This function asks the DPNSVR process to add the application specified to it's list of applications and forward
// enumeration requests from the main port to the specified addresses.
//
// If the DPNSVR process is not running, it will be started by this function.
//
#undef DPF_MODNAME 
#define DPF_MODNAME "DPNSVR_Register"
HRESULT DPNSVR_Register(const GUID *const pguidApplication,
						const GUID *const pguidInstance,
						IDirectPlay8Address *const pAddress)
{
	HRESULT		hr;
	BOOL		fQueueOpen = FALSE;
	BYTE		*pSendBuffer = NULL;
	DWORD		dwSendBufferSize = 0;
	DWORD		dwURLSize = 0;
	GUID		guidSP;
	CDPNSVRIPCQueue appQueue;
	DPNSVR_MSG_OPENPORT *pMsgOpen;

	DPFX(DPFPREP,2,"Parameters: pguidApplication [0x%p],pguidInstance [0x%p],pAddress [0x%p]",
			pguidApplication,pguidInstance,pAddress);

	DNASSERT( pguidApplication != NULL );
	DNASSERT( pguidInstance != NULL );
	DNASSERT( pAddress != NULL );

	//
	//	Get SP and URL size from address
	//
	if ((hr = IDirectPlay8Address_GetSP( pAddress,&guidSP )) != DPN_OK)
	{
		DPFERR("Could not get SP from address");
		DisplayDNError(0,hr);
		goto Failure;
	}

	if ((hr = IDirectPlay8Address_GetURLA( pAddress,reinterpret_cast<char*>(pSendBuffer),&dwURLSize )) != DPNERR_BUFFERTOOSMALL)
	{
		DPFERR("Could not get URL from address");
		DisplayDNError(0,hr);
		goto Failure;
	}
	dwSendBufferSize = sizeof( DPNSVR_MSG_OPENPORT ) + dwURLSize;

	//
	//	Create message buffer
	//
	pSendBuffer  = new BYTE[dwSendBufferSize];
	if( pSendBuffer == NULL )
	{
		DPFERR("Could not allocate send buffer");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	//	Attempt to launch DPNSVR if it has not yet been launched
	//
	if ((hr = DPNSVR_StartDPNSVR()) != DPN_OK)
	{
		DPFERR("Could not start DPNSVR");
		DisplayDNError(0,hr);
		goto Failure;
	}

	//
	//	Open queue
	//
    if ((hr = appQueue.Open( pguidInstance,DPNSVR_MSGQ_SIZE,0 )) != DPN_OK)
	{
		DPFERR("Could not open DPNSVR request queue");
		DisplayDNError(0,hr);
		goto Failure;
	}
	fQueueOpen = TRUE;

	//
	//	Create open port message
	pMsgOpen = (DPNSVR_MSG_OPENPORT*) pSendBuffer;
	pMsgOpen->Header.dwType = DPNSVR_MSGID_OPENPORT;
	pMsgOpen->Header.guidInstance = *pguidInstance;
	pMsgOpen->dwProcessID = GetCurrentProcessId();
	pMsgOpen->guidApplication = *pguidApplication;
	pMsgOpen->guidSP = guidSP;
	pMsgOpen->dwAddressSize = dwURLSize;

	if ((hr = IDirectPlay8Address_GetURLA( pAddress,(char *)&pMsgOpen[1],&dwURLSize )) != DPN_OK)
	{
		DPFERR("Could not get URL from address");
		DisplayDNError(0,hr);
		goto Failure;
	}

	//
	//	Send request to DPNSVR
	//
	if ((hr = DPNSVR_SendMessage( pSendBuffer,dwSendBufferSize )) != DPN_OK)
	{
		DPFERR("Could not send message to DPNSVR");
		DisplayDNError(0,hr);
		goto Failure;
	}

	//
	//	Wait for DPNSVR to respond
	//
	if ((hr = DPNSVR_WaitForResult( &appQueue )) != DPN_OK)
	{
		DPFERR("Could not get response from DPNSVR");
		DisplayDNError(0,hr);
		goto Failure;
	}

Exit:
	if( pSendBuffer != NULL )
	{
		delete [] pSendBuffer;
		pSendBuffer = NULL;
	}
	if (fQueueOpen)
	{
		appQueue.Close();
		fQueueOpen = FALSE;
	}

	DPFX(DPFPREP,2,"Returning: [0x%lx]",hr);
	return( hr );

Failure:
	goto Exit;
}


#undef DPF_MODNAME 
#define DPF_MODNAME "DPNSVR_UnRegister"
HRESULT DPNSVR_UnRegister(const GUID *const pguidApplication,const GUID *const pguidInstance)
{
	HRESULT			hr;
	BOOL			fQueueOpen = FALSE;
	CDPNSVRIPCQueue	appQueue;
	DPNSVR_MSG_CLOSEPORT MsgClose;

	DPFX(DPFPREP,2,"Parameters: pguidApplication [0x%p],pguidInstance [0x%p]",pguidApplication,pguidInstance);

	DNASSERT( pguidApplication != NULL );
	DNASSERT( pguidInstance != NULL );

	//
	//	Ensure DPNSVR is running
	//
	if( !DPNSVR_IsRunning() )
	{
		DPFX(DPFPREP,3,"DPNSVR is not running" );
		hr = DPNERR_INVALIDAPPLICATION;
		goto Failure;
	}

	//
	//	Open DPNSVR request queue
	//
    if ((hr = appQueue.Open( pguidInstance,DPNSVR_MSGQ_SIZE,0 )) != DPN_OK)
	{
		DPFERR("Could not open DPNSVR queue");
		DisplayDNError(0,hr);
		goto Failure;
	}
	fQueueOpen = TRUE;

	//
	//	Create close port message
	//
	MsgClose.Header.dwType = DPNSVR_MSGID_CLOSEPORT;
	MsgClose.Header.guidInstance = *pguidInstance;
	MsgClose.dwProcessID = GetCurrentProcessId();
	MsgClose.guidApplication = *pguidApplication;

	//
	//	Send message to DPNSVR
	//
	if ((hr = DPNSVR_SendMessage( &MsgClose,sizeof(DPNSVR_MSG_CLOSEPORT) )) != DPN_OK)
	{
		DPFERR("Could not send message to DPNSVR");
		DisplayDNError(0,hr);
		goto Failure;
	}

	//
	//	Wait for DPNSVR to respond
	//
	if ((hr = DPNSVR_WaitForResult( &appQueue )) != DPN_OK)
	{
		DPFERR("Could not get response from DPNSVR");
		DisplayDNError(0,hr);
		goto Failure;
	}

Exit:
	if (fQueueOpen)
	{
		appQueue.Close();
		fQueueOpen = FALSE;
	}

	DPFX(DPFPREP,2,"Returning: [0x%lx]",hr);
	return( hr );

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_RequestTerminate"
HRESULT DPNSVR_RequestTerminate( const GUID *pguidInstance )
{
	HRESULT			hr;
	BOOL			fQueueOpen = FALSE;
	CDPNSVRIPCQueue appQueue;
	DPNSVR_MSG_COMMAND MsgCommand;

	DPFX(DPFPREP,2,"Parameters: pguidInstance [0x%p]",pguidInstance);

	DNASSERT( pguidInstance != NULL );

	//
	//	Ensure DPNSVR is running
	//
	if( !DPNSVR_IsRunning() )
	{
		DPFX(DPFPREP,3,"DPNSVR is not running" );
		hr = DPNERR_INVALIDAPPLICATION;
		goto Failure;
	}

	//
	//	Open DPNSVR request queue
	//
    if ((hr = appQueue.Open( pguidInstance,DPNSVR_MSGQ_SIZE,0 )) != DPN_OK)
	{
		DPFERR("Could not open DPNSVR queue");
		DisplayDNError(0,hr);
		goto Failure;
	}
	fQueueOpen = TRUE;

	//
	//	Create terminate message
	//
	MsgCommand.Header.dwType = DPNSVR_MSGID_COMMAND;
	MsgCommand.Header.guidInstance = *pguidInstance;
	MsgCommand.dwCommand = DPNSVR_COMMAND_KILL;
	MsgCommand.dwParam1 = 0;
	MsgCommand.dwParam2 = 0;

	//
	//	Send message to DPNSVR
	//
	if ((hr = DPNSVR_SendMessage( &MsgCommand,sizeof(DPNSVR_MSG_COMMAND) )) != DPN_OK)
	{
		DPFERR("Could not send message to DPNSVR");
		DisplayDNError(0,hr);
		goto Failure;
	}

	//
	//	Wait for DPNSVR to respond
	//
	if ((hr = DPNSVR_WaitForResult( &appQueue )) != DPN_OK)
	{
		DPFERR("Could not get response from DPNSVR");
		DisplayDNError(0,hr);
		goto Failure;
	}

Exit:
	if (fQueueOpen)
	{
		appQueue.Close();
		fQueueOpen = FALSE;
	}

	DPFX(DPFPREP,2,"Returning: [0x%lx]",hr);
	return hr;

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_RequestStatus"
HRESULT DPNSVR_RequestStatus( const GUID *pguidInstance,PSTATUSHANDLER pStatusHandler,PVOID pvContext )
{
	HRESULT				hr;
	CDPNSVRIPCQueue		appQueue;
	DPNSVR_MSG_COMMAND	dpnCommand;
	DNHANDLE			hStatusMutex = NULL;
	DNHANDLE			hStatusSharedMemory = NULL;
	void				*pServerStatus = NULL;
	DWORD				dwSize;
	BOOL				fOpened = FALSE;
	BOOL				fHaveMutex = FALSE;

	//
	//	Ensure DPNSVR is running
	//
	if( !DPNSVR_IsRunning() )
	{
		DPFERR( "DPNSVR is not running" );
		hr = DPNERR_INVALIDAPPLICATION;
		goto Failure;
	}

	//
	//	Open DPNSVR request queue
	//
	if ((hr = appQueue.Open( pguidInstance,DPNSVR_MSGQ_SIZE,0 )) != DPN_OK)
	{
		DPFERR( "Failed to open DPNSVR request queue" );
		DisplayDNError( 0,hr );
		goto Failure;
	}
	fOpened = TRUE;

	//
	//	Create request
	//
	dpnCommand.Header.dwType = DPNSVR_MSGID_COMMAND;
	dpnCommand.Header.guidInstance = *pguidInstance;
	dpnCommand.dwCommand = DPNSVR_COMMAND_STATUS;
	dpnCommand.dwParam1 = 0;
	dpnCommand.dwParam2 = 0;

	//
	//	Send command request to DPNSVR
	//
	if ((hr = DPNSVR_SendMessage( &dpnCommand,sizeof(DPNSVR_MSG_COMMAND) )) != DPN_OK)
	{
		DPFERR( "Failed to send command to DPNSVR request queue" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

	//
	//	Wait for DPNSVR to respond
	//
	if ((hr = DPNSVR_WaitForResult( &appQueue )) != DPN_OK)
	{
		DPFERR( "Failed to receive response from DPNSVR" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

#ifdef WINNT
	hStatusMutex = DNOpenMutex( SYNCHRONIZE, FALSE, GLOBALIZE_STR STRING_GUID_DPNSVR_STATUSSTORAGE );
#else
	hStatusMutex = DNOpenMutex( MUTEX_ALL_ACCESS, FALSE, GLOBALIZE_STR STRING_GUID_DPNSVR_STATUSSTORAGE );
#endif // WINNT
	if( hStatusMutex == NULL )
	{
		DPFERR( "Server exited before table was retrieved" );
		hr = DPNERR_INVALIDAPPLICATION;
		goto Failure;
	}

	//
	//	Get mutex for shared memory
	//
    DNWaitForSingleObject( hStatusMutex, INFINITE );
	fHaveMutex = TRUE;

	//
	//	Map shared memory
	//
    if ((hStatusSharedMemory = DNOpenFileMapping(FILE_MAP_READ,FALSE,STRING_GUID_DPNSVR_STATUS_MEMORY)) == NULL)
	{
		hr = GetLastError();
		DPFERR( "Unable to open file mapping" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

	if ((pServerStatus = MapViewOfFile(	HANDLE_FROM_DNHANDLE(hStatusSharedMemory),
										FILE_MAP_READ,
										0,
										0,
										sizeof(DPNSVR_STATUSHEADER)) ) == NULL)
	{
		hr = GetLastError();
		DPFERR(  "Unable to map view of file" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

	dwSize = sizeof(DPNSVR_STATUSHEADER) + (static_cast<DPNSVR_STATUSHEADER*>(pServerStatus)->dwSPCount * sizeof(DPNSVR_SPSTATUS));

	UnmapViewOfFile( pServerStatus );
	pServerStatus = NULL;
	if ((pServerStatus = MapViewOfFile(	HANDLE_FROM_DNHANDLE(hStatusSharedMemory),
										FILE_MAP_READ,
										0,
										0,
										dwSize) ) == NULL)
	{
		hr = GetLastError();
		DPFERR(  "Unable to re-map view of file" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

	(*pStatusHandler)(pServerStatus,pvContext);

	DNReleaseMutex( hStatusMutex );
	fHaveMutex = FALSE;

	hr = DPN_OK;

Exit:
	if ( hStatusMutex )
	{
		if ( fHaveMutex )
		{
			DNReleaseMutex( hStatusMutex );
			fHaveMutex = FALSE;
		}
        DNCloseHandle( hStatusMutex );
		hStatusMutex = NULL;
	}
	if ( fOpened )
	{
		appQueue.Close();
		fOpened = FALSE;
	}
	if( pServerStatus )
	{
		UnmapViewOfFile(pServerStatus);
		pServerStatus = NULL;
	}
	if( hStatusSharedMemory )
	{
	    DNCloseHandle(hStatusSharedMemory);
		hStatusSharedMemory = NULL;
	}

	return( hr );

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPNSVR_RequestTable"
HRESULT DPNSVR_RequestTable( const GUID *pguidInstance,PTABLEHANDLER pTableHandler,PVOID pvContext )
{
	HRESULT				hr;
	CDPNSVRIPCQueue		appQueue;
	DPNSVR_MSG_COMMAND	dpnCommand;
	DNHANDLE			hTableMutex = NULL;
	DNHANDLE			hSharedMemory = NULL;
	void				*pServerTable = NULL;
	DWORD				dwSize;
	BOOL				fOpened = FALSE;
	BOOL				fHaveMutex = FALSE;

	//
	//	Ensure DPNSVR is running
	//
	if( !DPNSVR_IsRunning() )
	{
		DPFERR( "DPNSVR is not running" );
		hr = DPNERR_INVALIDAPPLICATION;
		goto Failure;
	}

	//
	//	Open DPNSVR request queue
	//
	if ((hr = appQueue.Open( pguidInstance,DPNSVR_MSGQ_SIZE,0 )) != DPN_OK)
	{
		DPFERR( "Failed to open DPNSVR request queue" );
		DisplayDNError( 0,hr );
		goto Failure;
	}
	fOpened = TRUE;

	//
	//	Create request
	//
	dpnCommand.Header.dwType = DPNSVR_MSGID_COMMAND;
	dpnCommand.Header.guidInstance = *pguidInstance;
	dpnCommand.dwCommand = DPNSVR_COMMAND_TABLE;
	dpnCommand.dwParam1 = 0;
	dpnCommand.dwParam2 = 0;

	//
	//	Send command request to DPNSVR
	//
	if ((hr = DPNSVR_SendMessage( &dpnCommand,sizeof(DPNSVR_MSG_COMMAND) )) != DPN_OK)
	{
		DPFERR( "Failed to send command to DPNSVR request queue" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

	//
	//	Wait for DPNSVR to respond
	//
	if ((hr = DPNSVR_WaitForResult( &appQueue )) != DPN_OK)
	{
		DPFERR( "Failed to receive response from DPNSVR" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

#ifdef WINNT
	hTableMutex = DNOpenMutex( SYNCHRONIZE, FALSE, GLOBALIZE_STR STRING_GUID_DPNSVR_TABLESTORAGE );
#else
	hTableMutex = DNOpenMutex( MUTEX_ALL_ACCESS, FALSE, GLOBALIZE_STR STRING_GUID_DPNSVR_TABLESTORAGE );
#endif // WINNT
	if( hTableMutex == NULL )
	{
		DPFERR( "Server exited before table was retrieved" );
		hr = DPNERR_INVALIDAPPLICATION;
		goto Failure;
	}

	//
	//	Get mutex for shared memory
	//
    DNWaitForSingleObject( hTableMutex, INFINITE );
	fHaveMutex = TRUE;

	//
	//	Map shared memory
	//
    if ((hSharedMemory = DNOpenFileMapping(FILE_MAP_READ,FALSE,STRING_GUID_DPNSVR_TABLE_MEMORY)) == NULL)
	{
		hr = GetLastError();
		DPFERR( "Unable to open file mapping" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

	if ((pServerTable = MapViewOfFile(	HANDLE_FROM_DNHANDLE(hSharedMemory),
										FILE_MAP_READ,
										0,
										0,
										sizeof(DPNSVR_TABLEHEADER)) ) == NULL)
	{
		hr = GetLastError();
		DPFERR(  "Unable to map view of file" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

	dwSize = static_cast<DPNSVR_TABLEHEADER*>(pServerTable)->dwTableSize;

	UnmapViewOfFile( pServerTable );
	pServerTable = NULL;
	if ((pServerTable = MapViewOfFile(	HANDLE_FROM_DNHANDLE(hSharedMemory),
										FILE_MAP_READ,
										0,
										0,
										dwSize) ) == NULL)
	{
		hr = GetLastError();
		DPFERR(  "Unable to re-map view of file" );
		DisplayDNError( 0,hr );
		goto Failure;
	}

	(*pTableHandler)(pServerTable,pvContext);

	DNReleaseMutex( hTableMutex );
	fHaveMutex = FALSE;

	hr = DPN_OK;

Exit:
	if ( hTableMutex )
	{
		if ( fHaveMutex )
		{
			DNReleaseMutex( hTableMutex );
			fHaveMutex = FALSE;
		}
        DNCloseHandle( hTableMutex );
		hTableMutex = NULL;
	}
	if ( fOpened )
	{
		appQueue.Close();
		fOpened = FALSE;
	}
	if( pServerTable )
	{
		UnmapViewOfFile(pServerTable);
		pServerTable = NULL;
	}
	if( hSharedMemory )
	{
	    DNCloseHandle(hSharedMemory);
		hSharedMemory = NULL;
	}

	return( hr );

Failure:
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvlib\sources.inc ===
TARGETNAME=dpnsvlib
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnsvlibi.h
PRECOMPILED_PCH=dnsvlibi.pch
PRECOMPILED_OBJ=dnsvlibi.obj

INCLUDES=..\;..\..\..\common;..\..\..\inc;..\..\inc;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES=dpnsvlib.cpp \
        dpnsvrq.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvlib\dpnsvrq.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPNSVRQ.h
 *  Content:    DirectPlay8 Server Queues Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   03/19/00	rmt		Modified from dplmsgq
 *   04/03/2001	RichGr	Bug #325752 - Improved Queue mutex so opens, updates and closes don't clash.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPNSVRQ_H__
#define	__DPNSVRQ_H__

#define	DPNSVR_MSGQ_SIGNATURE					'QMSD'

//**********************************************************************
// Constant definitions
//**********************************************************************

#define DPNSVR_MSGQ_OBJECT_IDCHAR_FILEMAP	'F'
#define DPNSVR_MSGQ_OBJECT_IDCHAR_MUTEX		'M'
#define DPNSVR_MSGQ_OBJECT_IDCHAR_EVENT		'E'
#define DPNSVR_MSGQ_OBJECT_IDCHAR_EVENT2	'V'
#define DPNSVR_MSGQ_OBJECT_IDCHAR_SEMAPHORE	'S'

//
//	Message Queue Flags
//
#define	DPNSVR_MSGQ_FLAG_AVAILABLE				0x00001
#define	DPNSVR_MSGQ_FLAG_RECEIVING				0x00010

#define DPNSVR_MSGQ_OPEN_FLAG_NO_CREATE		0x10000

//
//	Message Queue File Size
//
#define DPNSVR_MSGQ_SIZE						0x010000

//
//	Internal Message IDs
//
#define	DPNSVR_MSGQ_MSGID_SEND					0x0001
#define	DPNSVR_MSGQ_MSGID_TERMINATE				0x0003
#define DPNSVR_MSGQ_MSGID_IDLE					0x0004

#define DPNSVR_MSGQ_MSGFLAGS_QUEUESYSTEM		0x0001
#define DPNSVR_MSGQ_MSGFLAGS_USER1				0x0002
#define DPNSVR_MSGQ_MSGFLAGS_USER2				0x0004


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack(push,4)
//
//	Message Queue File Map Info
//
typedef struct _DPNSVR_MSGQ_INFO
{
	DWORD	dwFlags;			// Queue usage flags
	DWORD	dwStartOffset;
	DWORD	dwEndOffset;
	DWORD	dwFreeBytes;
	DWORD	dwQueueSize;
	LONG	lRefCount;			// Number of connections
} DPNSVR_MSGQ_INFO, *PDPNSVR_MSGQ_INFO;


//
//	Message Queue Send Message
//
typedef	struct _DPNSVR_MSGQ_SEND
{
	DWORD		dwCurrentSize;		// Size of this frame (in BYTES)
	DWORD		dwTotalSize;		// Total size of message
	DWORD		dwMsgId;			// Message ID
	DPNHANDLE	hSender;
	DWORD		dwFlags;
	DWORD		dwCurrentOffset;	// Offset of this frame in message
} DPNSVR_MSGQ_HEADER, *PDPNSVR_MSGQ_HEADER;

//
//	Message Queue Terminate Message
//
typedef struct _DPNSVR_MSGQ_TERMINATE
{
	DWORD	dwMsgId;
} DPNSVR_MSGQ_TERMINATE, *PDPNSVR_MSGQ_TERMINATE;

#pragma pack(pop)


//
//	Message Handler Callback
//
typedef HRESULT (*PFNDPNSVRMSGQMESSAGEHANDLER)(DPNHANDLE,const PVOID,DWORD,BYTE *const,const DWORD);

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

class CDPNSVRIPCQueue
{
public:
	CDPNSVRIPCQueue()
		{
			m_hFileMap = NULL;
			m_hEvent = NULL;
			m_hQueueGUIDMutex = NULL;
			m_hSemaphore = NULL;
			m_pFileMapAddress = NULL;
			m_pInfo = NULL;
			m_pData = NULL;
			m_hSender = NULL;
			m_pfnMessageHandler = NULL;
			m_pvSenderContext = NULL;
			m_hReceiveThreadRunningEvent = NULL;
		};

	~CDPNSVRIPCQueue() { };

	void SetMessageHandler(DPNHANDLE hSender,PFNDPNSVRMSGQMESSAGEHANDLER pfn)
	{
		m_hSender = hSender;
		m_pfnMessageHandler = pfn;
	};

	void SetSenderContext(PVOID pvSenderContext)
	{
		m_pvSenderContext = pvSenderContext;
	};

	HRESULT CallMessageHandler(const PVOID pvSenderContext,DWORD dwMessageFlags,BYTE *const pBuffer,const DWORD dwBufferSize)
	{
		return((m_pfnMessageHandler)(m_hSender,pvSenderContext,dwMessageFlags,pBuffer,dwBufferSize));
	};

    HRESULT Open(const GUID * const pguidQueueName, const DWORD dwQueueSize, const DWORD dwFlags);
	void Close(void);
    void  CloseHandles(void);

	LONG GetRefCount(void)
	{
		DWORD	lRefCount;

		if (m_pInfo == NULL)
		{
			return(0);
		}

		Lock();
		lRefCount = m_pInfo->lRefCount;
		Unlock();

		return(lRefCount);
	};

	HRESULT AddData( BYTE *const pBuffer,const DWORD dwSize );

	HRESULT Send(BYTE *const pBuffer,const DWORD dwSize,const DWORD dwTimeOut,const DWORD dwMessageFlags,const DWORD dwFlags);

	void Lock(void)
	{
		DNWaitForSingleObject(m_hQueueGUIDMutex,INFINITE);
	};

	void Unlock(void)
	{
		DNReleaseMutex(m_hQueueGUIDMutex);
	};

	void WaitForMessages(void)
	{
		DNWaitForSingleObject(m_hSemaphore,INFINITE);
	};

	void IndicateMessage(void)
	{
		DNReleaseSemaphore(m_hSemaphore,1,NULL);
	};

	BOOL WaitForConsumption(const DWORD dwTimeOut)
	{
		DWORD	dwError;

		dwError = DNWaitForSingleObject(m_hEvent,dwTimeOut);
		if (dwError==WAIT_OBJECT_0)
		{
			return(TRUE);
		}
		return(FALSE);
	};

	void IndicateConsumption(void)
	{
		//DNSetEvent(m_hEvent);		// Will auto-reset (i.e. pulse)
		DNReleaseSemaphore( m_hEvent, 1, NULL );
	};

	void MakeAvailable(void)
	{
		Lock();
		m_pInfo->dwFlags |= DPNSVR_MSGQ_FLAG_AVAILABLE;
		Unlock();
	};

	HRESULT MakeUnavailable(void)
	{

		HRESULT		hResultCode;

		Lock();
		if (m_pInfo->dwFlags & DPNSVR_MSGQ_FLAG_AVAILABLE)
		{
			m_pInfo->dwFlags &= (~DPNSVR_MSGQ_FLAG_AVAILABLE);
			hResultCode = DPN_OK;
		}
		else
		{
			hResultCode = DPNERR_ALREADYCONNECTED;
		}
		Unlock();

		return(hResultCode);
	};

	void MakeReceiving(void)
	{
		Lock();
		m_pInfo->dwFlags |= DPNSVR_MSGQ_FLAG_RECEIVING;
		Unlock();
		DNSetEvent(m_hReceiveThreadRunningEvent);
	};

	void MakeNotReceiving(void)
	{
		DNResetEvent(m_hReceiveThreadRunningEvent);
		Lock();
		m_pInfo->dwFlags &= (~DPNSVR_MSGQ_FLAG_RECEIVING);
		Unlock();
	};

	BOOL WaitForReceiveThread(const DWORD dwTimeOut)
	{
		DWORD	dwError;

		dwError = DNWaitForSingleObject(m_hReceiveThreadRunningEvent,dwTimeOut);
		if (dwError==WAIT_OBJECT_0)
		{
			return(TRUE);
		}
		return(FALSE);
	};

	BOOL IsOpen(void) const
		{
			if (m_hFileMap!= NULL)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	BOOL IsAvailable(void) const
	{
		if (m_pInfo->dwFlags & DPNSVR_MSGQ_FLAG_AVAILABLE)
		{
			return(TRUE);
		}
		return(FALSE);
	};

	BOOL IsReceiving(void) const
	{
		if (m_pInfo->dwFlags & DPNSVR_MSGQ_FLAG_RECEIVING)
		{
			return(TRUE);
		}
	};

	HRESULT GetNextMessage( PDPNSVR_MSGQ_HEADER pMsgHeader, PBYTE pbPayload, DWORD *pdwBufferSize );

	void Terminate(void);

    DNHANDLE GetReceiveSemaphoreHandle() { return m_hSemaphore; };


private:
	// GetData
	//
	// Get dwSize bytes from the queue.  If the queue is empty this function will return
	// DPNERR_DOESNOTEXIST.  Once this function returns the dwSize bytes will be consumed
	//
	// Needs LOCK()
	//
	HRESULT GetData( BYTE *pbData, DWORD dwSize );

	// Consume
	//
	// Marks dwSize bytes as consumed
	//
	// Needs LOCK()
	void Consume( const DWORD dwSize );

	DWORD	            m_dwSig;			// Signature (ensure initialized)
	PBYTE	            m_pFileMapAddress;	// File Mapping address
	DPNSVR_MSGQ_INFO   *m_pInfo;	        // Message queue file mapping info
	PBYTE			    m_pData;			// Message data starts here 
	DNHANDLE	        m_hReceiveThreadRunningEvent;

	//	Notes:
	//		Each message queue has four shared memory items: file map, mutex, event, semaphore.
	//		The file map is a circular queue of messages.
	//		The mutex controls access to the file map.
	//		The event signals when an item has been taken off the queue by the consumer.
	//		The semaphore indicates to the consumer that there are messages in the queue

	DNHANDLE            m_hFileMap;			// File Mapping handle
	DNHANDLE            m_hQueueGUIDMutex;	// Mutex handle
	DNHANDLE            m_hEvent;			// Event handle
	DNHANDLE            m_hSemaphore;		// Semaphore handle

	PFNDPNSVRMSGQMESSAGEHANDLER	 m_pfnMessageHandler;
	DPNHANDLE	        m_hSender;

	PVOID	            m_pvSenderContext;	// For all SEND messages
};

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __DPLMSGQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrapp.cpp ===
#include "dnsvri.h"

HRESULT	CApplication::Initialize( GUID *const pguidApplication,GUID *const pguidInstance,const DWORD dwProcessID )
{
	m_dwProcessID = dwProcessID;

	m_guidApplication = *pguidApplication;
	m_guidInstance = *pguidInstance;

	return( DPN_OK );
}


//
//	Walk mapping list and remove mappings
//

void CApplication::RemoveMappings( void )
{
	CBilink	*pBilink;
	CAppListenMapping	*pMapping;

	pBilink = m_blListenMapping.GetNext();
	while ( pBilink != &m_blListenMapping )
	{
		pMapping = CONTAINING_OBJECT( pBilink,CAppListenMapping,m_blListenMapping );
		pBilink = pBilink->GetNext();

		pMapping->Disassociate();
		pMapping->Release();
		pMapping = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dnsvri.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnSVRi.h
 *  Content:    DirectPlay DPNSvr master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNSVRI_H__
#define __DNSVRI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"
#include "dneterrors.h"

#ifdef UNICODE
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLW
#else
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLA
#endif // UNICODE

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "classbilink.h"
#include "fixedpool.h"
#include "comutil.h"
#include "packbuff.h"

// 
// Dpnsvlib private includes
//
#include "dpnsdef.h"
#include "dpnsvmsg.h"
#include "dpnsvrq.h"
#include "dpnsvlib.h"

//
// Dpnsvr private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR

#include "dpnsvrapp.h"
#include "dpnsvrservprov.h"
#include "dpnsvrlisten.h"
#include "dpnsvrmapping.h"
#include "dpnsvrserver.h"

#endif // __DNSVRI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvlib\dpnsvrq.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPNSVRQ.cpp
 *  Content:    DirectPlay8 Server Queues Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   03/19/00	rmt		Modified from dplmsgq
 *   06/28/2000	rmt		Prefix Bug #38044
 *  07/06/00	rmt		Bug #38111 - Fixed prefix bug
 *   07/21/2000	rmt		Removed assert that wasn't needed
 *   08/05/2000 RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/31/2000	rmt		Prefix Bug #171825, 171828
 *  04/03/2001	RichGr	Bug #325752 - Improved Queue mutex so opens, updates and closes don't clash.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnsvlibi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR


//	DirectPlay8Server Message Queues
//
//	We will use shared memory circular message buffers to implement this.
//	Each MsgQ has a set of synchronization objects to control access to the MsgQs.
//	The head of the shared memory file contains state information about the MsgQ:
//		pStartAddress
//		dwTotalUsableSpace
//		dwFirstMsgOffset
//		dwNextFreeOffset
//		dwFreeSpaceAtEnd
//		dwTotalFreeSpace
//	Messages are DWORD aligned in the MsgQ.
//	Each message in the MsgQ has a header:
//		dwMsgId
//		dwCurrentOffset
//		dwCurrentSize
//		dwTotalSize
//	Messages which fit in one frame have dwCurrentSize = dwTotalSize and dwCurrentOffset = 0.
//	Messages over multiple frames have dwCurrentSize < dwTotalSize.


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************




//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::Open
//
//	Entry:	const DWORD		dwPID			Id associated with this queue (user supplied)
//			const CHAR		cSuffix			Suffix character associated with this Q (user supp.)
//			const DWORD		dwQueueSize		Size of file map to use when implementing msg queue
//			const DWORD		dwFlags			TBA
//
//	Exit:		HRESULT:	DPN_OK		If able to open an existing message queue,
//											or create a message queue if one didn't exist
//							DPNERR_OUTOFMEMORY
// ------------------------------

// String of GUID in length
#define QUEUE_NAME_LENGTH       64

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::Open"

HRESULT CDPNSVRIPCQueue::Open(const GUID * const pguidQueueName,const DWORD dwQueueSize,const DWORD dwFlags)
{
	HRESULT		hResultCode;
    DWORD       dwRet = 0;
	BOOL		bQueueExists = FALSE;
	DWORD		dwFileMapSize;
    TCHAR       szObjectName[QUEUE_NAME_LENGTH];
	TCHAR*		pszCursor = szObjectName;

	DPFX(DPFPREP,6,"Parameters: dwQueueSize [%d], dwFlags [0x%x]",dwQueueSize,dwFlags);

	_tcscpy(pszCursor, GLOBALIZE_STR);
	pszCursor += _tcslen(GLOBALIZE_STR);

    // Build GUID string name 
    wsprintf( 
    	pszCursor, 
    	_T("{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}"), 
    	pguidQueueName->Data1, 
    	pguidQueueName->Data2, 
    	pguidQueueName->Data3, 
        pguidQueueName->Data4[0], 
        pguidQueueName->Data4[1], 
        pguidQueueName->Data4[2], 
        pguidQueueName->Data4[3],
        pguidQueueName->Data4[4], 
        pguidQueueName->Data4[5], 
        pguidQueueName->Data4[6], 
        pguidQueueName->Data4[7] );

	DPFX(DPFPREP, 7, "Shared object name [%s]", szObjectName);

    // If there is no mutex, it is created.  If it already exists, we get a handle to it.
	*pszCursor = DPNSVR_MSGQ_OBJECT_IDCHAR_MUTEX;
	m_hQueueGUIDMutex = DNCreateMutex(DNGetNullDacl(), FALSE, szObjectName);
    if (m_hQueueGUIDMutex == NULL)
    {
   	    DPFERR("CreateMutex() failed" );
		hResultCode = DPNERR_OUTOFMEMORY;
        goto Failure;
    }

    // Wait for the mutex.
    dwRet = DNWaitForSingleObject(m_hQueueGUIDMutex, INFINITE);

    if (dwRet != WAIT_ABANDONED && dwRet != WAIT_OBJECT_0)
    {
   	    DPFERR("WaitForSingleObject() failed" );
		hResultCode = DPNERR_GENERIC;
        goto Failure;
    }

	// Create Receive Thread Running Event
	//	This will be set by the receive thread once it has spun up.  We need it for synchronization
	m_hReceiveThreadRunningEvent = DNCreateEvent(NULL,TRUE,FALSE,NULL);
	if (m_hReceiveThreadRunningEvent == NULL)
	{
		DPFERR("Could not create receive thread");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	// Set the filemap size big enough that the largest message (text) will be dwQueueSize
	// so we add on the MsgQ info structure at the front and 1 Msg header
	dwFileMapSize = dwQueueSize + sizeof(DPNSVR_MSGQ_INFO) + sizeof(DPNSVR_MSGQ_HEADER);
	dwFileMapSize = (dwFileMapSize + 3) & 0xfffffffc;	// DWORD align

	// Create File Mapping Object
	*pszCursor = DPNSVR_MSGQ_OBJECT_IDCHAR_FILEMAP;
	m_hFileMap = DNCreateFileMapping(INVALID_HANDLE_VALUE,DNGetNullDacl(),
		PAGE_READWRITE,(DWORD)0,dwQueueSize,szObjectName);
	if (m_hFileMap == NULL)
	{
		DPFERR("CreateFileMapping() failed");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}
	if (GetLastError() == ERROR_ALREADY_EXISTS)
		bQueueExists = TRUE;

	if ((dwFlags & DPNSVR_MSGQ_OPEN_FLAG_NO_CREATE) && !bQueueExists)
	{
		DPFERR("Open existing queue failed - does not exist");
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	// Map file
	m_pFileMapAddress = reinterpret_cast<BYTE*>(MapViewOfFile(HANDLE_FROM_DNHANDLE(m_hFileMap),FILE_MAP_ALL_ACCESS,0,0,0));
	if (m_pFileMapAddress == NULL)
	{
		DPFERR("MapViewOfFile() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	// Create semaphore object
	*pszCursor = DPNSVR_MSGQ_OBJECT_IDCHAR_SEMAPHORE;
	m_hSemaphore = DNCreateSemaphore(DNGetNullDacl(),0,
		(dwQueueSize/sizeof(DPNSVR_MSGQ_HEADER))+1,szObjectName);
	if (m_hSemaphore == NULL)
	{
		DPFERR("CreateSemaphore() failed");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	// Create another semaphore (was an event, but we want to make sure we don't miss any).
	*pszCursor = DPNSVR_MSGQ_OBJECT_IDCHAR_EVENT;
	m_hEvent = DNCreateSemaphore( DNGetNullDacl(), 0, (dwQueueSize/sizeof(DPNSVR_MSGQ_HEADER))+1, szObjectName );

	if( m_hEvent == NULL )
	{
		DPFERR( "CreateSemaphore() failed" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	// Update structure elements
	m_pInfo = reinterpret_cast<DPNSVR_MSGQ_INFO*>(m_pFileMapAddress);

	// Initialize msg queue if it didn't exist
	if ( !bQueueExists)
	{
		m_pInfo->dwFlags = dwFlags & 0x0000ffff;	// Just last two bytes
		m_pInfo->dwStartOffset = 0;
		m_pInfo->dwEndOffset = 0;
		m_pInfo->dwQueueSize = dwQueueSize - sizeof(DPNSVR_MSGQ_INFO);
		m_pInfo->dwFreeBytes = m_pInfo->dwQueueSize;
		m_pInfo->lRefCount = 0;
	}

	m_pData = (BYTE *) &m_pInfo[1];
	m_dwSig = DPNSVR_MSGQ_SIGNATURE;

	// Increment user count
	m_pInfo->lRefCount++;

    DNReleaseMutex(m_hQueueGUIDMutex);

	// If we made it this far, everything was okay
	hResultCode = DPN_OK;

Exit:

	DPFX(DPFPREP, 6, "Returning: [0x%lx]", hResultCode);
	return hResultCode;

Failure:

	// There was a problem - close handles
	DPFERR("Errors encountered - closing");

    CloseHandles();

    if (m_hQueueGUIDMutex)
    {    
        DNReleaseMutex(m_hQueueGUIDMutex);
        DNCloseHandle(m_hQueueGUIDMutex);
        m_hQueueGUIDMutex = NULL;
    }


    goto Exit;
}


//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::Close
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::Close"

void CDPNSVRIPCQueue::Close(void)
{
    DWORD       dwRet = 0;


	DPFX(DPFPREP, 6,"Parameters: (none)");

    // Wait for mutex to be signalled.
    if (m_hQueueGUIDMutex)
    {    
        dwRet = DNWaitForSingleObject(m_hQueueGUIDMutex, INFINITE);

        if (dwRet != WAIT_ABANDONED && dwRet != WAIT_OBJECT_0)
        {
   	        DPFERR("WaitForSingleObject() failed" );
            return;
        }
    }

    CloseHandles();

    if (m_hQueueGUIDMutex)
    {    
        DNReleaseMutex(m_hQueueGUIDMutex);
        DNCloseHandle(m_hQueueGUIDMutex);
        m_hQueueGUIDMutex = NULL;
    }

	DPFX(DPFPREP, 6,"Returning");
    return;
}


//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::CloseHandles
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::CloseHandles"

void  CDPNSVRIPCQueue::CloseHandles()
{

	DPFX(DPFPREP, 6, "Parameters: (none)");

	if( m_pInfo != NULL )
	{
		// Decrement user count
		m_pInfo->lRefCount--;
	
        // If the RefCount on the memory-mapped Queue object is 0, then no-one else
        // has it open and we can mark the signature and set the rest of the header info to zero. 
        if (m_pInfo->lRefCount == 0)
        {
		    DPFX(DPFPREP, 7, "Finished with memory-mapped Queue object - clear it");
		    m_pInfo->dwFlags = 0;
		    m_pInfo->dwStartOffset = 0;
		    m_pInfo->dwEndOffset = 0;
		    m_pInfo->dwQueueSize = 0;
		    m_pInfo->dwFreeBytes = 0;
        }
	}

	if (m_hEvent != NULL)
	{
		DPFX(DPFPREP, 9,"Close Event [0x%p]",m_hEvent);
		DNCloseHandle(m_hEvent);
		m_hEvent = NULL;
	}

	if (m_hSemaphore != NULL)
	{
		DPFX(DPFPREP, 9,"Close Semaphore [0x%p]",m_hSemaphore);
		DNCloseHandle(m_hSemaphore);
		m_hSemaphore = NULL;
	}

	if (m_pFileMapAddress != NULL)
	{
		DPFX(DPFPREP, 9,"UnMap View of File [0x%p]",m_pFileMapAddress);
		UnmapViewOfFile(m_pFileMapAddress);
		m_pFileMapAddress = NULL;
	}

	if (m_hFileMap != NULL)
	{
		DPFX(DPFPREP, 9,"Close FileMap [0x%p]",m_hFileMap);
		DNCloseHandle(m_hFileMap);
		m_hFileMap = NULL;
	}

	if (m_hReceiveThreadRunningEvent != NULL)
	{
		DPFX(DPFPREP, 9,"Close Event [0x%p]",m_hReceiveThreadRunningEvent);
		DNCloseHandle(m_hReceiveThreadRunningEvent);
		m_hReceiveThreadRunningEvent = NULL;
	}

	m_pInfo = NULL;

	DPFX(DPFPREP, 6, "Returning");

    return;
}


//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::Terminate
//
//	Entry:		Nothing
//
//	Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::Terminate"

void CDPNSVRIPCQueue::Terminate(void)
{
	DWORD	dwMsgId = DPNSVR_MSGQ_MSGID_TERMINATE;
	BOOL	bDone = FALSE;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(m_pInfo != NULL);

	while (!bDone)
	{
		// Wait until there's enough space for the message
		while (sizeof(DWORD) > m_pInfo->dwFreeBytes)
			WaitForConsumption(INFINITE);

		Lock();

		// Ensure there is space once we get the lock
		// (someone else might have beaten us here)
		if (sizeof(DWORD) <= m_pInfo->dwFreeBytes)
		{
			AddData(reinterpret_cast<BYTE*>(&dwMsgId),sizeof(DWORD));
			bDone = TRUE;

			IndicateMessage();
		}

		Unlock();
	}

	DPFX(DPFPREP, 6,"Returning");
}


// GetNextMessage
//
// Attempts to retrieve the next message from the queue
//
// pMsgHeader must be large enough to hold a message header.
//
// If no message is present in the queue then this function fills pMsgHeader with an
// idle message header
//
HRESULT CDPNSVRIPCQueue::GetNextMessage( PDPNSVR_MSGQ_HEADER pMsgHeader, BYTE *pbPayload, DWORD *pdwBufferSize )
{
	HRESULT hr;

	Lock();

	hr = GetData( (BYTE *) pMsgHeader, sizeof( DPNSVR_MSGQ_HEADER ) );

	// If there is no header on the queue fill in the header with an 
	// idle message
	if( hr == DPNERR_DOESNOTEXIST )
	{
		pMsgHeader->dwCurrentSize = sizeof( DPNSVR_MSGQ_HEADER );
		pMsgHeader->dwTotalSize = sizeof( DPNSVR_MSGQ_HEADER );
		pMsgHeader->dwMsgId = DPNSVR_MSGQ_MSGID_IDLE;
		pMsgHeader->hSender = 0;
		pMsgHeader->dwFlags = DPNSVR_MSGQ_MSGFLAGS_QUEUESYSTEM;
		pMsgHeader->dwCurrentOffset = 0;

		Unlock();

		return DPN_OK;
	}
	//// DBG
	else if( FAILED( hr ) )
	{
		DNASSERT( FALSE );
	}
	else if( pMsgHeader->dwMsgId == 0xFFFFFFFF )
	{
		DNASSERT( FALSE );
	}

	DWORD dwPayloadSize = pMsgHeader->dwCurrentSize;

	// Otherwise it's a valid message of some kind
	if( *pdwBufferSize < dwPayloadSize || pbPayload == NULL )
	{
		*pdwBufferSize = dwPayloadSize;
		Unlock();
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwBufferSize = dwPayloadSize;

	Consume( sizeof(DPNSVR_MSGQ_HEADER) );

	// There is no payload, only a header.  Return here.
	if( dwPayloadSize == 0 )
	{
		Unlock();
		return DPN_OK;
	}

	hr = GetData( pbPayload, dwPayloadSize );

	if( FAILED( hr ) )
	{
		DPFERR("Error getting IPC queue message payload" );
		DNASSERT( FALSE );
		Unlock();
		return hr;
	}

	Consume( dwPayloadSize );
	
	Unlock();

	return DPN_OK;
}

// Consume
//
// Marks dwSize bytes as consumed
//
// Needs LOCK()
void CDPNSVRIPCQueue::Consume( const DWORD dwSize )
{
	DWORD dwAlignedSize = (dwSize + 3) & (~0x3);

	m_pInfo->dwStartOffset += dwAlignedSize;

	if( m_pInfo->dwStartOffset >= m_pInfo->dwQueueSize )
	{
		m_pInfo->dwStartOffset -= m_pInfo->dwQueueSize;
	}

	m_pInfo->dwFreeBytes += dwAlignedSize;

	DNASSERT( m_pInfo->dwFreeBytes <= m_pInfo->dwFreeBytes );

	IndicateConsumption();
}

// GetData
//
// Get dwSize bytes from the queue.  If the queue is empty this function will return
// DPNERR_DOESNOTEXIST.  Once this function returns the dwSize bytes will be consumed
//
// REQUIRES LOCK
//
HRESULT CDPNSVRIPCQueue::GetData( BYTE *pbData, DWORD dwSize )
{
	if( m_pInfo->dwQueueSize == m_pInfo->dwFreeBytes )
	{
		return DPNERR_DOESNOTEXIST;
	}

	if( pbData == NULL )
	{
		return DPNERR_BUFFERTOOSMALL;
	}

	// Calculate aligned size 
	DWORD dwAlignedSize = (dwSize + 3) & (~0x3);

	// Data block we want is wrapped
	if( m_pInfo->dwStartOffset+dwAlignedSize > m_pInfo->dwQueueSize )
	{
		DWORD cbBytesLeft = m_pInfo->dwQueueSize - m_pInfo->dwStartOffset;
		DWORD cbSecondBlockAligned = dwAlignedSize - (cbBytesLeft);
		DWORD cbSecondBlock = dwSize - (cbBytesLeft);

		DNASSERT( dwAlignedSize > cbBytesLeft);

		memcpy( pbData, m_pData + m_pInfo->dwStartOffset, cbBytesLeft);
		memcpy( pbData + cbBytesLeft, m_pData , cbSecondBlock );
	}
	// Data block is contiguous
	else
	{
		memcpy( pbData, m_pData + m_pInfo->dwStartOffset, dwSize );
	}		

	return DPN_OK;
}


//**********************************************************************
// ------------------------------
//	CMessageQueue::AddData
//
//	Entry:		BYTE *const pBuffer
//				const DWORD dwSize
//
//	Exit:		HRESULT
// ------------------------------
//
// REQUIRES LOCK!!
//
#undef DPF_MODNAME
#define DPF_MODNAME "CMessageQueue::AddData"

HRESULT CDPNSVRIPCQueue::AddData(BYTE *const pBuffer,
							   const DWORD dwSize)
{
	HRESULT		hResultCode;
	DWORD		dwAlignedSize;

	DPFX(DPFPREP, 6,"Parameters: pBuffer [0x%p], dwSize [%ld]",pBuffer,dwSize);

	dwAlignedSize = (dwSize + 3) & (~0x3);

	// Check to ensure there is space
	if( dwAlignedSize > m_pInfo->dwFreeBytes )
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Exit;
	}

	// We have a wrapping condition
	if( (m_pInfo->dwEndOffset+dwAlignedSize) > m_pInfo->dwQueueSize )
	{
		DWORD cbBytesLeft = m_pInfo->dwQueueSize - m_pInfo->dwEndOffset;
		DWORD cbSecondBlockAligned = dwAlignedSize - cbBytesLeft;
		DWORD cbSecondBlock = dwSize - cbBytesLeft;

		DNASSERT( dwAlignedSize > cbBytesLeft );

		memcpy( m_pData + m_pInfo->dwEndOffset, pBuffer, cbBytesLeft );
		memcpy( m_pData, pBuffer + cbBytesLeft, cbSecondBlock );

		m_pInfo->dwEndOffset = cbSecondBlockAligned;
	}
	// Queue is in the middle
	else
	{
		memcpy( m_pData + m_pInfo->dwEndOffset, pBuffer, dwSize );
		m_pInfo->dwEndOffset += dwAlignedSize;
	}

	m_pInfo->dwFreeBytes -= dwAlignedSize;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
//	CDPNSVRIPCQueue::Send
//
//	Entry:		BYTE *const pBuffer
//				const DWORD dwSize
//				const DWORD dwFlags
//
//	Exit:		HRESULT
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CDPNSVRIPCQueue::Send"

HRESULT CDPNSVRIPCQueue::Send(BYTE *const pBuffer,
							const DWORD dwSize,
							const DWORD dwTimeOut,
							const DWORD dwMsgFlags,
							const DWORD dwFlags)
{
	HRESULT			hResultCode;
	DWORD			dwMsgSize;		// DWORD aligned
	DWORD			dwTotalMsgSize;	// Msg + Header - DWORD aligned
	DPNSVR_MSGQ_HEADER	Header;
	BOOL			bDone;
	DWORD			dwTimeRemaining;
	DWORD			dwTimeStart;
	DWORD			dwTimeFinish;

	DPFX(DPFPREP, 6,"Parameters: pBuffer [0x%p], dwSize [%ld], dwFlags [0x%lx]",pBuffer,dwSize,dwFlags);

	dwTimeRemaining = dwTimeOut;

	// Need DWORD aligned size
	dwMsgSize = (dwSize + 3) & 0xfffffffc;
	dwTotalMsgSize = dwMsgSize + sizeof(DPNSVR_MSGQ_HEADER);

	// Place the message into the MsgQ
	// Check to see if fragmentation is required
	// If we're at the end of the MsgQ and there isn't enough space for a Msg Header, REALIGN
	if (dwTotalMsgSize <= m_pInfo->dwQueueSize)
	{
		DPFX(DPFPREP, 7,"Message does not need to be fragmented");

		Header.dwMsgId = DPNSVR_MSGQ_MSGID_SEND;
		Header.dwCurrentOffset = 0;
		Header.dwCurrentSize = dwSize;
		Header.dwTotalSize = dwSize;
		Header.hSender = m_hSender;
		Header.dwFlags = dwMsgFlags;

		bDone = FALSE;

		while ( !bDone)
		{
			// Wait until there's enough space for the message
			while (dwTotalMsgSize > m_pInfo->dwFreeBytes)
			{
				if (dwTimeOut != INFINITE)
				{
					dwTimeStart = GETTIMESTAMP();
				}

				if (!WaitForConsumption(dwTimeRemaining))
				{
					return(DPNERR_TIMEDOUT);
				}

				if (dwTimeOut != INFINITE)
				{
					dwTimeFinish = GETTIMESTAMP();
					if ((dwTimeFinish - dwTimeStart) > dwTimeRemaining)
					{
						return(DPNERR_TIMEDOUT);
					}
					dwTimeRemaining -= (dwTimeFinish - dwTimeStart);
				}
			}

			Lock();

			// Ensure there is space once we get the lock
			// (someone else might have beaten us here)
			if (dwTotalMsgSize <= m_pInfo->dwFreeBytes)
			{
				AddData(reinterpret_cast<BYTE*>(&Header),sizeof(DPNSVR_MSGQ_HEADER));
				AddData(pBuffer,dwSize);
				bDone = TRUE;

				IndicateMessage();
			}

			Unlock();
			hResultCode = DPN_OK;
		}
	}
	else
	{
		DPFX(DPFPREP, 7,"Message needs to be fragmented");
		DNASSERT(FALSE);
#pragma TODO(a-minara,"Implement this")
		hResultCode = DPNERR_GENERIC;
	}


	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrapp.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsvrapp.h
 *  Content:    DirectPlay8 DPNSVR application header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/12/02	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPNSVRAPP_H__
#define	__DPNSVRAPP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

class CApplication
{
public:
	CApplication()
	{
		m_lRefCount = 1;
		m_lListenCount = 0;

		m_dwProcessID = 0;

		m_blApplication.Initialize();
		m_blListenMapping.Initialize();
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplication::~CApplication"
	~CApplication()
	{
		DNASSERT( m_blApplication.IsEmpty() );
		DNASSERT( m_blListenMapping.IsEmpty() );
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplication::AddRef"
	void AddRef( void )
	{
		long	lRefCount;

		lRefCount = InterlockedIncrement( const_cast<long*>(&m_lRefCount) );
        DPFX(DPFPREP,9,"New refcount [0x%lx]",lRefCount);
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplication::Release"
	void Release( void )
	{
		long	lRefCount;

		lRefCount = InterlockedDecrement( const_cast<long*>(&m_lRefCount) );
        DPFX(DPFPREP,9,"New refcount [0x%lx]",lRefCount);

		if (lRefCount == 0)
		{
			delete this;
		}
	};

	HRESULT	Initialize( GUID *const pguidApplication,GUID *const pguidInstance,const DWORD dwProcessID );

	void IncListenCount( void )
	{
		long	lRefCount;

		lRefCount = InterlockedIncrement( const_cast<long*>(&m_lListenCount) );
	};

	void DecListenCount( void )
	{
		long	lRefCount;

		lRefCount = InterlockedDecrement( const_cast<long*>(&m_lListenCount) );
	};

	BOOL IsEqualApplication( GUID *const pguidApplication )
	{
		if (*pguidApplication == m_guidApplication)
		{
			return( TRUE );
		}
		return( FALSE );
	};

	BOOL IsEqualInstance( GUID *const pguidInstance )
	{
		if (*pguidInstance == m_guidInstance)
		{
			return( TRUE );
		}
		return( FALSE );
	};

	BOOL IsRunning( void )
	{
        DNHANDLE hProcess;

        if ((hProcess = DNOpenProcess( PROCESS_QUERY_INFORMATION, FALSE, m_dwProcessID )) == NULL)
        {
			if (GetLastError() != ERROR_ACCESS_DENIED)
			{
				//
				//	Unless we don't have permission to open the process, it's all over
				//
				return( FALSE );
			}
        }
        else
        {
            DNCloseHandle( hProcess );
        }
		return( TRUE );
	};

	void RemoveMappings( void );

	GUID *GetApplicationGuidPtr( void )
	{
		return( &m_guidApplication );
	};

	GUID *GetInstanceGuidPtr( void )
	{
		return( &m_guidInstance );
	};

	CBilink		m_blApplication;
	CBilink		m_blListenMapping;	// Listens for this application

private:
	long	volatile	m_lRefCount;		// Object ref count
	long	volatile	m_lListenCount;		// Number of listens running for this app
	GUID				m_guidApplication;
	GUID				m_guidInstance;
	DWORD				m_dwProcessID;		// Process ID of this instance of the application
};

#endif	// __DPNSVRAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrlisten.cpp ===
#include "dnsvri.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CListen::Initialize"
HRESULT CListen::Initialize( void )
{
	HRESULT		hr;

	if (!DNInitializeCriticalSection( &m_cs ))
	{
		DPFERR( "Could not initialize critical section" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	m_fInitialized = TRUE;
	hr = DPN_OK;

Exit:
	return( hr );

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CListen::Deinitialize"
void CListen::Deinitialize( void )
{
	DNDeleteCriticalSection( &m_cs );
}


//
//	Start a new listen for DPNSVR.  This should only be called if a new adapter is being listened on.
//	We will add this listen to the bilink of listens open on the DPNSVR object.
//

#undef DPF_MODNAME
#define DPF_MODNAME "CListen::Start"
HRESULT CListen::Start( CServProv *const pServProv,GUID *const pguidDevice )
{
	HRESULT 	hr = DPN_OK;
	DWORD		dwPort = DPNA_DPNSVR_PORT;


	DPFX(DPFPREP,4,"Parameters: pServProv [0x%p], pguidDevice [0x%p]",pServProv,pguidDevice);

	DNASSERT( pServProv != NULL );
	DNASSERT( pguidDevice != NULL );

	//
	//	Build up basic listen address
	//
	hr = COM_CoCreateInstance(	CLSID_DirectPlay8Address,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_IDirectPlay8Address,
								(void **) &(m_dpspListenData.pAddressDeviceInfo),
								FALSE );
	if( FAILED( hr ) )
	{
		DPFERR("Could not start listen");
		DisplayDNError(0,hr);
	    goto Failure;
	}

    hr = IDirectPlay8Address_SetSP(m_dpspListenData.pAddressDeviceInfo,pServProv->GetSPGuidPtr());
    if( FAILED( hr ) )
    {
		DPFERR("Could not set SP on address");
		DisplayDNError(0,hr);
//		hr = DPNERR_GENERIC;
	    goto Failure;
	}
	
	hr = IDirectPlay8Address_SetDevice(m_dpspListenData.pAddressDeviceInfo,pguidDevice);
	if( FAILED( hr ) )
	{
		DPFERR("Could not set adapter on address");
		DisplayDNError(0,hr);
//		hr = DPNERR_GENERIC;
	    goto Failure;
	}

	hr = IDirectPlay8Address_AddComponent(m_dpspListenData.pAddressDeviceInfo,DPNA_KEY_PORT,&dwPort,sizeof(DWORD),DPNA_DATATYPE_DWORD);
	if( FAILED( hr ) )
	{
		DPFERR("Could not set port on address");
		DisplayDNError(0,hr);
//		hr = DPNERR_GENERIC;
	    goto Failure;
	}

	//
	//	Create completion event to wait on
	//
	m_hListenComplete = DNCreateEvent(NULL,TRUE,FALSE,NULL);
	if (m_hListenComplete == NULL)
	{
		DPFERR("Could not create completion event");
		hr = DPNERR_OUTOFMEMORY;
	    goto Failure;
	}

	//
	//	Update this object
	//
	pServProv->AddRef();
	m_pServProv = pServProv;
	m_guidDevice = *pguidDevice;

	//
	//	Setup listen command for SP
	//
    m_dpspListenData.dwFlags = DPNSPF_BINDLISTENTOGATEWAY;

	AddRef();
    m_dpspListenData.pvContext = this;

	//
	//	Call SP listen
	//
	AddRef();
    hr = IDP8ServiceProvider_Listen( pServProv->GetDP8SPPtr(), &m_dpspListenData );
    if( hr != DPNERR_PENDING && hr != DPN_OK )
    {
    	// Release app reference, will not be tracked
		DPFERR("SP Listen failed");
		DisplayDNError(0,hr);
		Release();
		goto Failure;
    }

	//
	//	Wait for this listen to start.  When this returns, m_hrListen will be set to the status of the listen
	//
	DNWaitForSingleObject( m_hListenComplete, INFINITE );

	hr = m_hrListen; 

	//
	//	If the listen returns anything other than DPN_OK, we should clean up
	//
	if (m_hrListen != DPN_OK)
	{
		DPFX(DPFPREP,5,"SP Listen status indicated listen failed");
		DisplayDNError(0,m_hrListen);

		m_dpspListenData.dwCommandDescriptor = NULL;
		m_dpspListenData.hCommand = NULL;

		goto Failure;
	}

Exit:
	if (m_hListenComplete)
	{
		DNCloseHandle( m_hListenComplete );
		m_hListenComplete = NULL;
	}
	if (m_dpspListenData.pAddressDeviceInfo)
	{
	    IDirectPlay8Address_Release(m_dpspListenData.pAddressDeviceInfo);
		m_dpspListenData.pAddressDeviceInfo = NULL;
	}
	if (m_dpspListenData.pvContext)
	{
		(static_cast<CListen*>(m_dpspListenData.pvContext))->Release();
		m_dpspListenData.pvContext = NULL;
	}

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
    return( hr );

Failure:
	if (m_pServProv)
	{
		m_pServProv->Release();
		m_pServProv = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CListen::Stop"
HRESULT CListen::Stop( void )
{
	HRESULT		hr;

	DPFX(DPFPREP,4,"Parameters: (none)");

	DNASSERT( m_blAppMapping.IsEmpty() );
	DNASSERT( m_lAppCount == 0 );

	DNASSERT( m_pServProv != NULL );

	m_blListen.RemoveFromList();
	Release();

	hr = IDP8ServiceProvider_CancelCommand( m_pServProv->GetDP8SPPtr(),m_dpspListenData.hCommand,m_dpspListenData.dwCommandDescriptor );

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrmain.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsvr.cpp
 *  Content:    Main file for DPNSVR.EXE
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/14/00     rodtoll Created it
 * 03/23/00     rodtoll Changed app to windows app + moved command-line help / status
 *                      to message boxes.
 * 03/24/00     rodtoll Updated to make all strings loaded from resource
 * 08/30/2000	rodtoll	Whistler Bug #170675 - PREFIX Bug 
 * 10/30/2000	rodtoll	Bug #46203 - DPNSVR does not call COM_Uninit
 ***************************************************************************/

#include "dnsvri.h"


#undef DPF_MODNAME
#define DPF_MODNAME "WinMain"
int APIENTRY _tWinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPTSTR     lpCmdLine,
                     int       nCmdShow)

{
	HRESULT hr;
    CDirectPlayServer8 *pdp8Server = NULL ;
    BOOL fTestMode = FALSE;

    if (DNOSIndirectionInit(0) == FALSE)
	{
		DPFX(DPFPREP,  0, "Error initializing OS indirection layer");
		goto DPNSVR_ERROR_INIT;
	}

	hr = COM_Init();
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error initializing COM layer hr=0x%x", hr );
		goto DPNSVR_ERROR_INIT;
	}

    hr = COM_CoInitialize(NULL);
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error initializing COM hr=0x%x", hr );
		goto DPNSVR_ERROR_INIT;
	}

    if( lstrlen( lpCmdLine ) > 0 )
    {
		DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

		if (CSTR_EQUAL == CompareString(lcid, NORM_IGNORECASE, lpCmdLine, -1, TEXT("/KILL"), -1))
        {
			GUID	guidTemp;

			if ((hr = DNCoCreateGuid( &guidTemp )) != DPN_OK)
			{
				DPFERR("Could not create GUID");
				DisplayDNError(0,hr);
			}

			DPNSVR_RequestTerminate( &guidTemp );
        }
        else
        {
            goto DPNSVR_MAIN_EXIT;
        }
    }
    else
    {
		pdp8Server = new CDirectPlayServer8();
		if( pdp8Server == NULL )
		{
			DPFX(DPFPREP,  0, "Error out of memory!" );
			goto DPNSVR_ERROR_INIT;
		}

        hr = pdp8Server->Initialize();
        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error initializing server hr=[0x%lx]", hr );
        }
        else
        {
			pdp8Server->RunServer();
			pdp8Server->Deinitialize();
        }
    }

DPNSVR_MAIN_EXIT:

	if( pdp8Server != NULL )
	{
		delete pdp8Server;
	}

DPNSVR_ERROR_INIT:

    COM_CoUninitialize();
	COM_Free();
	
    DNOSIndirectionDeinit();

   	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrmapping.cpp ===
#include "dnsvri.h"

#undef DPF_MODNAME
#define DPF_MODNAME "CAppListenMapping::Associate"
void CAppListenMapping::Associate( CApplication *const pApp,CListen *const pListen,IDirectPlay8Address *const pAddress )
{
	DPFX(DPFPREP,4,"Parameters: pApp [0x%p], pListen [0x%p], pAddress [0x%p]",pApp,pListen,pAddress);

	DNASSERT( pApp != NULL );
	DNASSERT( pListen != NULL );
	DNASSERT( pAddress != NULL );

	//
	//	Take references
	//
	pApp->IncListenCount();
	pApp->AddRef();
	m_pApp = pApp;

	pListen->IncAppCount();
	pListen->AddRef();
	m_pListen = pListen;

	IDirectPlay8Address_AddRef( pAddress );
	m_pAddress = pAddress;

	//
	//	Put in mapping bilinks
	//
	pListen->Lock();
	m_blListenMapping.InsertBefore( &m_pApp->m_blListenMapping );
	m_blAppMapping.InsertBefore( &m_pListen->m_blAppMapping );
	pListen->Unlock();
	
	DPFX(DPFPREP,4,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "CAppListenMapping::Disassociate"
void CAppListenMapping::Disassociate( void )
{
	DNASSERT( m_pListen != NULL );
	DNASSERT( m_pApp != NULL );
	DNASSERT( m_pAddress != NULL );

	m_pListen->Lock();
	m_blListenMapping.RemoveFromList();
	m_blAppMapping.RemoveFromList();
	m_pListen->Unlock();

	m_pListen->DecAppCount();
	m_pListen->Release();
	m_pListen = NULL;

	m_pApp->DecListenCount();
	m_pApp->Release();
	m_pApp = NULL;

	IDirectPlay8Address_Release( m_pAddress );
	m_pAddress = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrlisten.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsvrlisten.h
 *  Content:    DirectPlay8 DPNSVR listen header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/12/02	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPNSVRLISTEN_H__
#define	__DPNSVRLISTEN_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CServProv;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

class CListen
{
public:
	CListen( void )
	{
		m_lRefCount = 1;
		m_lAppCount = 0;
		m_fInitialized = FALSE;

		m_hrListen = E_FAIL;

		m_blListen.Initialize();
		m_blAppMapping.Initialize();

		memset(&m_guidDevice,0x0,sizeof(GUID));

		memset(&m_dpspListenData,0x0,sizeof(SPLISTENDATA));
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CListen::~CListen"
	~CListen( void )
	{
		DNASSERT( m_pServProv == NULL );
		DNASSERT( m_blListen.IsEmpty() );
		DNASSERT( m_blAppMapping.IsEmpty() );

		if (m_fInitialized)
		{
			Deinitialize();
		}
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CListen::AddRef"
	void AddRef()
	{
		long	lRefCount;

		DNASSERT( m_lRefCount > 0 );

		lRefCount = DNInterlockedIncrement( const_cast<long*>(&m_lRefCount) );
        DPFX(DPFPREP,9,"New refcount [0x%lx]",lRefCount);
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CListen::Release"
	void Release()
	{
		long	lRefCount;

		DNASSERT( m_lRefCount > 0 );

		lRefCount = DNInterlockedDecrement( const_cast<long*>(&m_lRefCount) );
        DPFX(DPFPREP,9,"New refcount [0x%lx]",lRefCount);

		if( lRefCount == 0 )
		{
			if (m_pServProv)
			{
				m_pServProv->Release();
				m_pServProv = NULL;
			}
			delete this;
		}
	};

	HRESULT	Initialize( void );

	void Deinitialize( void );

	void IncAppCount( void )
	{
		long	lRefCount;

		lRefCount = DNInterlockedIncrement( const_cast<long*>(&m_lAppCount) );
	};


	void DecAppCount( void )
	{
		long	lRefCount;

		lRefCount = DNInterlockedDecrement( const_cast<long*>(&m_lAppCount) );
		if (lRefCount == 0)
		{
			Stop();
		}
	};

	void Lock( void )
	{
		DNEnterCriticalSection( &m_cs );
	};

	void Unlock( void )
	{
		DNLeaveCriticalSection( &m_cs );
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CListen::SetCompleteEvent"
	void SetCompleteEvent( const HRESULT hr )
	{
		DNASSERT( m_hListenComplete != NULL );

		m_hrListen = hr;
		DNSetEvent( m_hListenComplete );
	};

	BOOL IsEqualDevice( GUID *const pguidDevice )
	{
		if (*pguidDevice == m_guidDevice)
		{
			return( TRUE );
		}
		return( FALSE );
	};

	GUID *GetDeviceGuidPtr( void )
	{
		return( &m_guidDevice );
	};

	HRESULT Start( CServProv *const pServProv,GUID *const pguidDevice );
	HRESULT Stop( void );

	CBilink					m_blListen;			// bilink of listens
	CBilink					m_blAppMapping;		// Applications on this listen

private:
	long	volatile		m_lRefCount;		// Object ref count
	long	volatile		m_lAppCount;		// Number of applications using this listen
	BOOL					m_fInitialized;		// Initialized() called?
	GUID					m_guidDevice;		// Device guid
	HRESULT					m_hrListen;			// Status of listen
	DNHANDLE				m_hListenComplete;	// Completion event for listen
	CServProv				*m_pServProv;		// SP object of this listen
    SPLISTENDATA 			m_dpspListenData;	// SP listen data

	DNCRITICAL_SECTION		m_cs;				// Lock
};

#endif	// __DPNSVRLISTEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrserver.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsvr8.h
 *  Content:    DirectPlay8 Server Object
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/14/00     rodtoll Created it
 * 03/23/00     rodtoll Removed local requests, updated to use new data sturctures
 * 03/24/00		rodtoll	Removed printf
 * 03/25/00     rodtoll Updated so uses SP caps to determine which SPs to load
 *              rodtoll Now supports N SPs and only loads those supported
 * 05/09/00     rodtoll Bug #33622 DPNSVR.EXE does not shutdown when not in use
 * 06/28/2000	rmt		Prefix Bug #38044
 * 07/09/2000	rmt		Added guard bytes
 * 09/01/2000	masonb	Modified ServerThread to call _endthread to clean up thread handle
 * 01/22/2001	rodtoll	WINBUG #290103 - Crash due to initialization error.  
 * 04/04/2001	RichGr	Bug #349042 - Clean up properly if EnumerateAndBuildServiceList() fails.
 *
 ***************************************************************************/

#include "dnsvri.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_DPNSVR


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Initialize"
HRESULT CDirectPlayServer8::Initialize( void )
{
    HRESULT     hr;
	BOOL		fCriticalSection = FALSE;
	BOOL		fRequestQueue = FALSE;
	DWORD		dw = 0;

	DPFX(DPFPREP,4,"Parameters: (none)");

	DNASSERT( m_State == Uninitialized );

	//
	//	Initialize Critical Section
	//
	if (!DNInitializeCriticalSection( &m_cs ))
	{
		DPFERR( "Could not initialize critical section" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	fCriticalSection = TRUE;

	//
	//	Ensure that only one instance of DPNSVR is running
	//
	if ((m_hSingleInstance = DNCreateEvent( DNGetNullDacl(),TRUE,FALSE,GLOBALIZE_STR STRING_GUID_DPNSVR_RUNNING )) == NULL)
	{
		DPFERR( "Could not create DPNSVR single instance event" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	if( GetLastError() == ERROR_ALREADY_EXISTS )
	{
		DPFERR( "Can only run one instance of server" );
		hr = DPNERR_DUPLICATECOMMAND;
		goto Failure;
    }

	//
	//	Create the startup event (if not already created by someone else) so that we can signal that DPNSVR is running
	//
    if ((m_hStartup = DNCreateEvent( DNGetNullDacl(),TRUE,FALSE,GLOBALIZE_STR STRING_GUID_DPNSVR_STARTUP )) == NULL)
    {
		DPFERR( "Could not create startup event" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
    }

	//
	//	Open DPNSVR request queue
	//
	if ((hr = m_RequestQueue.Open( &GUID_DPNSVR_QUEUE,DPNSVR_MSGQ_SIZE,0 )) != DPN_OK)
	{
		DPFERR( "Could not open DPNSVR request queue" );
		goto Failure;
	}
	fRequestQueue = TRUE;

	//
	//	Create status and table info mutexes
	//
	if ((m_hTableMutex = DNCreateMutex( DNGetNullDacl(),FALSE,GLOBALIZE_STR STRING_GUID_DPNSVR_TABLESTORAGE )) == NULL)
	{
        DPFERR( "Could not create table info mutex" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	if ((m_hStatusMutex = DNCreateMutex( DNGetNullDacl(),FALSE,GLOBALIZE_STR STRING_GUID_DPNSVR_STATUSSTORAGE )) == NULL)
	{
        DPFERR( "Could not create status info mutex" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	m_dwStartTicks = GetTickCount();
	ResetActivity();

	m_State = Initialized;

	//
	//	Set single instance and startup events so waiting processes can send requests
	//
	DNSetEvent( m_hSingleInstance );
	DNSetEvent( m_hStartup );

Exit:
	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
    return( hr );

Failure:
	if (fCriticalSection)
	{
		DNDeleteCriticalSection( &m_cs );
		fCriticalSection = FALSE;
	}
	if (m_hSingleInstance)
	{
		DNCloseHandle( m_hSingleInstance );
		m_hSingleInstance = NULL;
	}
	if (m_hStartup)
	{
		DNCloseHandle( m_hStartup );
		m_hStartup = NULL;
	}
	if (fRequestQueue)
	{
		m_RequestQueue.Close();
		fRequestQueue = FALSE;
	}
	if (m_hTableMutex)
	{
		DNCloseHandle( m_hTableMutex );
		m_hTableMutex = NULL;
	}
	if (m_hStatusMutex)
	{
		DNCloseHandle( m_hStatusMutex );
		m_hStatusMutex = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Deinitialize"
void CDirectPlayServer8::Deinitialize( void )
{
	CBilink			*pBilink;
	CServProv		*pServProv = NULL;
	CApplication	*pApp = NULL;

	if ( m_State != Uninitialized )
	{

		//
		//	Clean up global objects so that another DPNSVR can start right away
		//
		if (m_hSingleInstance)
		{
			DNCloseHandle( m_hSingleInstance );
			m_hSingleInstance = NULL;
		}
		if (m_hStartup)
		{
			DNCloseHandle( m_hStartup );
			m_hStartup = NULL;
		}
		if (m_hTableMutex)
		{
			DNCloseHandle( m_hTableMutex );
			m_hTableMutex = NULL;
		}
		if (m_hStatusMutex)
		{
			DNCloseHandle( m_hStatusMutex );
			m_hStatusMutex = NULL;
		}

		//
		//	Cleanup any mappings made
		//
		if (m_pStatusMapView)
		{
			UnmapViewOfFile( m_pStatusMapView );
			m_pStatusMapView = NULL;
		}
		if (m_hStatusMappedFile)
		{
			DNCloseHandle( m_hStatusMappedFile );
			m_hStatusMappedFile = NULL;
		}
		if (m_pTableMapView)
		{
			UnmapViewOfFile( m_pTableMapView );
			m_pTableMapView = NULL;
		}
		if (m_hTableMappedFile)
		{
			DNCloseHandle( m_hTableMappedFile );
			m_hTableMappedFile = NULL;
		}

		//
		//	Remove application mappings
		//
        DPFX(DPFPREP,5,"Checking for orphaned applications");
		pBilink = m_blApplication.GetNext();
		while ( pBilink != &m_blApplication )
		{
			pApp = CONTAINING_OBJECT( pBilink,CApplication,m_blApplication );
			pBilink = pBilink->GetNext();

	        DPFX(DPFPREP,5,"Found orphaned application - removing");

			//
			//	Walk mapping list and remove mappings
			//
			pApp->RemoveMappings();

			pApp->m_blApplication.RemoveFromList();
			pApp->Release();
			pApp = NULL;
		}

		//
		//	Unload any service providers
		//
        DPFX(DPFPREP,5,"Checking for service providers");
		pBilink = m_blServProv.GetNext();
		while ( pBilink != &m_blServProv )
		{
			pServProv = CONTAINING_OBJECT( pBilink,CServProv,m_blServProv );
			pBilink = pBilink->GetNext();

	        DPFX(DPFPREP,5,"Found service provider - removing");

			pServProv->m_blServProv.RemoveFromList();
			pServProv->Release();
			pServProv = NULL;
		}

		//
		//	Misc. clean up
		//
		m_RequestQueue.Close();
		DNDeleteCriticalSection( &m_cs );

		m_State = Uninitialized;
	}
}


//
//	This gets the status of the SP's currently loaded.
//	This is pretty busted since the buffer is owned by DPNSVR, yet used by everyone else!
//	This should be changed to have the app pass in a buffer which DPNSVR fills in (or return an error if too small)
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Command_Status"
HRESULT CDirectPlayServer8::Command_Status( void )
{
	HRESULT		hr;
	CBilink		*pBilink;
	CServProv	*pServProv = NULL;
	DWORD		dwServProvCount;
	DWORD		dw;
    DPNSVR_STATUSHEADER		*pStatusHeader;
    DPNSVR_SPSTATUS			*pStatus;

	DPFX(DPFPREP,4,"Parameters: (none)");

	//
	//	Determine the number of SP's we have
	//
	dwServProvCount = 0;
	pBilink = m_blServProv.GetNext();
	while ( pBilink != &m_blServProv )
	{
		dwServProvCount++;
		pBilink = pBilink->GetNext();
	}

	//
	//	Is the mapped file big enough for this or will we need to grow it?
	//
	if ((dwServProvCount > m_dwServProvCount) || (dwServProvCount == 0))
	{
		DWORD		dwSize;
		DNHANDLE	hMappedFile = NULL;
		void		*pMapView = NULL;

		//
		//	Create new mapped file
		//
		dwSize = sizeof(DPNSVR_STATUSHEADER) + (dwServProvCount * sizeof(DPNSVR_SPSTATUS));

		if ((hMappedFile = DNCreateFileMapping(	INVALID_HANDLE_VALUE,
												DNGetNullDacl(),
												PAGE_READWRITE,
												0,
												dwSize,
												GLOBALIZE_STR STRING_GUID_DPNSVR_STATUS_MEMORY )) == NULL)
		{
			hr = GetLastError();

			DPFERR( "Could not create file mapping" );
			DisplayDNError( 0,hr );
			goto Failure;
		}

		if ((pMapView = MapViewOfFile(	HANDLE_FROM_DNHANDLE(hMappedFile),
										FILE_MAP_READ | FILE_MAP_WRITE,
										0,
										0,
										dwSize )) == NULL)
		{
			hr = GetLastError();

			DPFERR( "Could not map view of file" );
			DisplayDNError( 0,hr );
			DNCloseHandle(hMappedFile);
			hMappedFile = NULL;
			goto Failure;
		}

		//
		//	Clean up old mapped file
		//
		if (m_pStatusMapView)
		{
			UnmapViewOfFile( m_pStatusMapView );
			m_pStatusMapView = NULL;
		}
		if (m_hStatusMappedFile)
		{
			DNCloseHandle( m_hStatusMappedFile );
			m_hStatusMappedFile = NULL;
		}

		//
		//	Update
		//
		m_pStatusMapView = pMapView;
		pMapView = NULL;

		m_hStatusMappedFile = hMappedFile;
		hMappedFile = NULL;

		m_dwServProvCount = dwServProvCount;

		DNASSERT( hMappedFile == NULL );
		DNASSERT( pMapView == NULL );
	}

	//
	//	Update mapped file
	//
	pStatusHeader = static_cast<DPNSVR_STATUSHEADER*>(m_pStatusMapView);
	pStatus = reinterpret_cast<DPNSVR_SPSTATUS*>(pStatusHeader + 1);

	DNWaitForSingleObject( m_hStatusMutex, INFINITE );

	pStatusHeader->dwSPCount = dwServProvCount;
	pStatusHeader->dwStartTime = m_dwStartTicks;
	
	dw = 0;
	pBilink = m_blServProv.GetNext();
	while ( (dw < dwServProvCount) && (pBilink != &m_blServProv))
	{
		pServProv = CONTAINING_OBJECT( pBilink,CServProv,m_blServProv );

		pServProv->DumpStatus( pStatus );

		pStatus++;
		dw++;
		pBilink = pBilink->GetNext();
	}
	
	DNReleaseMutex( m_hStatusMutex );

	hr = DPN_OK;

Exit:
	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
	return( hr );

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::Command_Table"
HRESULT CDirectPlayServer8::Command_Table( void )
{
	HRESULT		hr;
	CBilink		*pBilinkSP;
	CBilink		*pBilinkListen;
	CBilink		*pBilinkMapping;
	CServProv	*pServProv = NULL;
	CListen		*pListen = NULL;
	CAppListenMapping *pMapping = NULL;
	DWORD		dwSize;
	DWORD		dwSPCount;
	DWORD		dwListenCount;
	DWORD		dwAppCount;
	DWORD		dwURLSize;
	CPackedBuffer		PackedBuffer;
	DPNSVR_TABLEHEADER	*pTableHeader;
	DPNSVR_TABLESPENTRY	*pTableSPEntry;
	DPNSVR_TABLELISTENENTRY	*pTableListenEntry;
	DPNSVR_TABLEAPPENTRY	*pTableAppEntry;

	DPFX(DPFPREP,4,"Parameters: (none)");

	//
	//	Determine table size
	//
	dwSize = sizeof(DPNSVR_TABLEHEADER);

	pBilinkSP = m_blServProv.GetNext();
	while ( pBilinkSP != &m_blServProv )
	{
		pServProv = CONTAINING_OBJECT( pBilinkSP,CServProv,m_blServProv );
		pBilinkSP = pBilinkSP->GetNext();

		dwSize += sizeof(DPNSVR_TABLESPENTRY);

		pBilinkListen = pServProv->m_blListen.GetNext();
		while ( pBilinkListen != &pServProv->m_blListen )
		{
			pListen = CONTAINING_OBJECT( pBilinkListen,CListen,m_blListen );
			pBilinkListen = pBilinkListen->GetNext();

			dwSize += sizeof(DPNSVR_TABLELISTENENTRY);

			pListen->Lock();
			pBilinkMapping = pListen->m_blAppMapping.GetNext();
			while ( pBilinkMapping != &pListen->m_blAppMapping )
			{
				pMapping = CONTAINING_OBJECT( pBilinkMapping,CAppListenMapping,m_blAppMapping );
				pBilinkMapping = pBilinkMapping->GetNext();

				dwSize += sizeof(DPNSVR_TABLEAPPENTRY);

				dwURLSize = 0;
				if ((hr = IDirectPlay8Address_GetURLA(pMapping->GetAddress(),NULL,&dwURLSize)) == DPNERR_BUFFERTOOSMALL)
				{
					dwSize += dwURLSize;
				}
			}
			pListen->Unlock();
		}
	}

	//
	//	Is the mapped file big enough for this or will we need to grow it?
	//
	if (dwSize > m_dwTableSize)
	{
		DNHANDLE	hMappedFile = NULL;
		void		*pMapView = NULL;

		//
		//	Create new mapped file
		//
		if ((hMappedFile = DNCreateFileMapping(	INVALID_HANDLE_VALUE,
												DNGetNullDacl(),
												PAGE_READWRITE,
												0,
												dwSize,
												GLOBALIZE_STR STRING_GUID_DPNSVR_TABLE_MEMORY )) == NULL)
		{
			hr = GetLastError();

			DPFERR( "Could not create file mapping" );
			DisplayDNError( 0,hr );
			goto Failure;
		}

		if ((pMapView = MapViewOfFile(	HANDLE_FROM_DNHANDLE(hMappedFile),
										FILE_MAP_READ | FILE_MAP_WRITE,
										0,
										0,
										dwSize )) == NULL)
		{
			hr = GetLastError();

			DPFERR( "Could not map view of file" );
			DisplayDNError( 0,hr );
			DNCloseHandle(hMappedFile);
			hMappedFile = NULL;
			goto Failure;
		}

		//
		//	Clean up old mapped file
		//
		if (m_pTableMapView)
		{
			UnmapViewOfFile( m_pTableMapView );
			m_pTableMapView = NULL;
		}
		if (m_hTableMappedFile)
		{
			DNCloseHandle( m_hTableMappedFile );
			m_hTableMappedFile = NULL;
		}

		//
		//	Update
		//
		m_pTableMapView = pMapView;
		pMapView = NULL;

		m_hTableMappedFile = hMappedFile;
		hMappedFile = NULL;

		m_dwTableSize = dwSize;

		DNASSERT( hMappedFile == NULL );
		DNASSERT( pMapView == NULL );
	}

	//
	//	Update mapped file
	//
	DNWaitForSingleObject( m_hStatusMutex, INFINITE );

	PackedBuffer.Initialize( m_pTableMapView,m_dwTableSize,FALSE );
	
	dwSPCount = 0;
	pTableHeader = static_cast<DPNSVR_TABLEHEADER*>(PackedBuffer.GetHeadAddress());
	if ((hr = PackedBuffer.AddToFront(NULL,sizeof(DPNSVR_TABLEHEADER),FALSE)) != DPN_OK)
	{
		DNReleaseMutex( m_hStatusMutex );
		goto Failure;
	}

	pBilinkSP = m_blServProv.GetNext();
	while ( pBilinkSP != &m_blServProv )
	{
		pServProv = CONTAINING_OBJECT( pBilinkSP,CServProv,m_blServProv );
		pBilinkSP = pBilinkSP->GetNext();

		dwSPCount++;

		pTableSPEntry = static_cast<DPNSVR_TABLESPENTRY*>(PackedBuffer.GetHeadAddress());
		if ((hr = PackedBuffer.AddToFront(NULL,sizeof(DPNSVR_TABLESPENTRY),FALSE)) != DPN_OK)
		{
			DNReleaseMutex( m_hStatusMutex );
			goto Failure;
		}

		dwListenCount = 0;
		pBilinkListen = pServProv->m_blListen.GetNext();
		while ( pBilinkListen != &pServProv->m_blListen )
		{
			pListen = CONTAINING_OBJECT( pBilinkListen,CListen,m_blListen );
			pBilinkListen = pBilinkListen->GetNext();

			dwListenCount++;
			pTableListenEntry = static_cast<DPNSVR_TABLELISTENENTRY*>(PackedBuffer.GetHeadAddress());
			if ((hr = PackedBuffer.AddToFront(NULL,sizeof(DPNSVR_TABLELISTENENTRY),FALSE)) != DPN_OK)
			{
				DNReleaseMutex( m_hStatusMutex );
				goto Failure;
			}

			dwAppCount = 0;
			pListen->Lock();
			pBilinkMapping = pListen->m_blAppMapping.GetNext();
			while ( pBilinkMapping != &pListen->m_blAppMapping )
			{
				pMapping = CONTAINING_OBJECT( pBilinkMapping,CAppListenMapping,m_blAppMapping );
				pBilinkMapping = pBilinkMapping->GetNext();

				dwAppCount++;
				pTableAppEntry = static_cast<DPNSVR_TABLEAPPENTRY*>(PackedBuffer.GetHeadAddress());
				if ((hr = PackedBuffer.AddToFront(NULL,sizeof(DPNSVR_TABLEAPPENTRY),FALSE)) != DPN_OK)
				{
					pListen->Unlock();
					DNReleaseMutex( m_hStatusMutex );
					goto Failure;
				}

				pTableAppEntry->dwURLOffset = 0;
				dwURLSize = 0;
				if ((hr = IDirectPlay8Address_GetURLA(pMapping->GetAddress(),NULL,&dwURLSize)) == DPNERR_BUFFERTOOSMALL)
				{
					if ((hr = PackedBuffer.AddToBack(NULL,dwURLSize,FALSE)) == DPN_OK)
					{
						if ((hr = IDirectPlay8Address_GetURLA(	pMapping->GetAddress(),
																static_cast<char*>(PackedBuffer.GetTailAddress()),
																&dwURLSize)) == DPN_OK)
						{
							pTableAppEntry->dwURLOffset = PackedBuffer.GetTailOffset();
						}
					}
				}
				pTableAppEntry->guidApplication = *pMapping->GetApplication()->GetApplicationGuidPtr();
				pTableAppEntry->guidInstance = *pMapping->GetApplication()->GetInstanceGuidPtr();
			}
			pListen->Unlock();
			pTableListenEntry->guidDevice = *pListen->GetDeviceGuidPtr();
			pTableListenEntry->dwAppCount = dwAppCount;
		}

		pTableSPEntry->guidSP = *pServProv->GetSPGuidPtr();
		pTableSPEntry->dwListenCount = dwListenCount;
	}
	pTableHeader->dwSPCount = dwSPCount;

	DNReleaseMutex( m_hStatusMutex );

	hr = DPN_OK;

Exit:
	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
	return( hr );

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::FindApplication"
HRESULT CDirectPlayServer8::FindApplication( GUID *const pguidApplication,GUID *const pguidInstance, CApplication **const ppApp )
{
	HRESULT			hr;
	CBilink			*pBilink;
	CApplication	*pApp = NULL;

	DNASSERT( pguidApplication != NULL );
	DNASSERT( pguidInstance != NULL );
	DNASSERT( ppApp != NULL );

	hr = DPNERR_DOESNOTEXIST;

	pBilink = m_blApplication.GetNext();
	while (pBilink != &m_blApplication)
	{
		pApp = CONTAINING_OBJECT( pBilink,CApplication,m_blApplication );
		if (pApp->IsEqualApplication( pguidApplication ) && pApp->IsEqualInstance( pguidInstance ))
		{
			pApp->AddRef();
			*ppApp = pApp;
			hr = DPN_OK;
			break;
		}
		pBilink = pBilink->GetNext();
	}

	return( hr );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::FindServProv"
HRESULT CDirectPlayServer8::FindServProv( GUID *const pguidSP, CServProv **const ppServProv )
{
	HRESULT		hr;
	CBilink		*pBilink;
	CServProv	*pServProv = NULL;

	DNASSERT( pguidSP != NULL );
	DNASSERT( ppServProv != NULL );

	hr = DPNERR_DOESNOTEXIST;

	pBilink = m_blServProv.GetNext();
	while (pBilink != &m_blServProv)
	{
		pServProv = CONTAINING_OBJECT( pBilink,CServProv,m_blServProv );
		if (pServProv->IsEqual( pguidSP ))
		{
			pServProv->AddRef();
			*ppServProv = pServProv;
			hr = DPN_OK;
			break;
		}
		pBilink = pBilink->GetNext();
	}

	return( hr );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::OpenPort"
HRESULT CDirectPlayServer8::OpenPort( DPNSVR_MSG_OPENPORT *const pOpenPort )
{
	HRESULT			hr;
	GUID			guidDevice;
	CBilink			*pBilink;
	CApplication	*pApp = NULL;
	CServProv		*pServProv = NULL;
	CListen			*pListen = NULL;
	CAppListenMapping	*pMapping = NULL;
	IDirectPlay8Address	*pAddress = NULL;
	BOOL			fNewApp = FALSE;
	BOOL			fNewServProv = FALSE;

	DPFX(DPFPREP,4,"Parameters: pOpenPort [0x%p]",pOpenPort);

	//
	//	Find application or create one
	//
	if ((hr = FindApplication( &pOpenPort->guidApplication,&pOpenPort->Header.guidInstance,&pApp )) != DPN_OK)
	{
		DNASSERT( hr == DPNERR_DOESNOTEXIST );

		pApp = new CApplication;
		if (pApp == NULL)
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		if ((hr = pApp->Initialize( &pOpenPort->guidApplication,&pOpenPort->Header.guidInstance,pOpenPort->dwProcessID )) != DPN_OK)
		{
			goto Failure;
		}
		fNewApp = TRUE;
	}

	//
	//	Find service provider or create one
	//
	if ((hr = FindServProv( &pOpenPort->guidSP,&pServProv )) != DPN_OK)
	{
		DNASSERT( hr == DPNERR_DOESNOTEXIST );

		pServProv = new CServProv;
		if (pServProv == NULL)
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		if ((hr = pServProv->Initialize( &pOpenPort->guidSP )) != DPN_OK)
		{
			goto Failure;
		}

		fNewServProv = TRUE;
	}

	//
	//	Create address from message
	//
	hr = COM_CoCreateInstance(	CLSID_DirectPlay8Address,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_IDirectPlay8Address,
								(void **) &(pAddress),
								FALSE );
	if( FAILED( hr ) )
	{
		DPFERR("Could not create address");
		DisplayDNError(0,hr);
	    goto Failure;
	}

	if ((hr = IDirectPlay8Address_BuildFromURLA( pAddress,reinterpret_cast<char*>(pOpenPort + 1) )) != DPN_OK)
	{
		DPFERR("Could not build address");
		DisplayDNError(0,hr);
	    goto Failure;
	}

	//
	//	Find listen or start it up
	//
	if ((hr = IDirectPlay8Address_GetDevice(pAddress,&guidDevice)) == DPN_OK)
	{
		if ((hr = pServProv->FindListen( &guidDevice,&pListen )) != DPN_OK)
		{
			DNASSERT( hr == DPNERR_DOESNOTEXIST );

			if ((hr = pServProv->StartListen( &guidDevice,&pListen )) != DPN_OK)
			{
				DPFERR("Could not start listen");
				DisplayDNError(0,hr);
				goto Failure;
			}
		}
	}

	//
	//	Ensure there isn't already a mapping for this application/listen combo
	//
	pListen->Lock();
	pBilink = pApp->m_blListenMapping.GetNext();
	while ( pBilink != &pApp->m_blListenMapping )
	{
		pMapping = CONTAINING_OBJECT( pBilink,CAppListenMapping,m_blListenMapping );
		if (pMapping->GetListen() == pListen)
		{
			pListen->Unlock();
			DPFERR("Listen already mapped for this application");
			hr = DPNERR_ALREADYREGISTERED;
			goto Failure;
		}

		pMapping = NULL;
		pBilink = pBilink->GetNext();
	}
	pListen->Unlock();

	//
	//	Associate listen with application
	//
	pMapping = new CAppListenMapping;
	if (pMapping == NULL)
	{
		DPFERR("Could not create mapping");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pMapping->Associate( pApp,pListen,pAddress );

	if (fNewApp)
	{
		pApp->AddRef();
		pApp->m_blApplication.InsertAfter( &m_blApplication );
	}

	if (fNewServProv)
	{
		pServProv->AddRef();
		pServProv->m_blServProv.InsertAfter( &m_blServProv );
	}

Exit:
	if (pApp)
	{
		pApp->Release();
		pApp = NULL;
	}
	if (pServProv)
	{
		pServProv->Release();
		pServProv = NULL;
	}
	if (pListen)
	{
		pListen->Release();
		pListen = NULL;
	}
	if (pAddress)
	{
		IDirectPlay8Address_Release(pAddress);
		pAddress = NULL;
	}

	DNASSERT( pApp == NULL );
	DNASSERT( pServProv == NULL );
	DNASSERT( pListen == NULL );
	DNASSERT( pAddress == NULL );

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
	return( hr );

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::ClosePort"
HRESULT CDirectPlayServer8::ClosePort( DPNSVR_MSG_CLOSEPORT *const pClosePort )
{
	HRESULT			hr;
	CApplication	*pApp = NULL;
	CAppListenMapping	*pMapping = NULL;

	DPFX(DPFPREP,4,"Parameters: pClosePort [0x%p]",pClosePort);

	//
	//	Find application
	//
	if ((hr = FindApplication( &pClosePort->guidApplication,&pClosePort->Header.guidInstance,&pApp )) != DPN_OK)
	{
		DPFERR("Could not find application");
		goto Failure;
	}

	//
	//	Walk mapping list and remove mappings
	//
	pApp->RemoveMappings();

	pApp->m_blApplication.RemoveFromList();
	pApp->Release();

	pApp->Release();
	pApp = NULL;

Exit:
	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
	return( hr );

Failure:
	if (pApp)
	{
		pApp->Release();
		pApp = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::RunCommand"
HRESULT CDirectPlayServer8::RunCommand( const DPNSVR_MSG_COMMAND* const pCommand )
{
	HRESULT hr;

	DPFX(DPFPREP,4,"Parameters: [0x%p]",pCommand);

	switch( pCommand->dwCommand )
	{
	case DPNSVR_COMMAND_STATUS:
		{
			DPFX(DPFPREP,5,"DPNSVR_COMMAND_STATUS");
			hr = Command_Status();
		}
		break;

	case DPNSVR_COMMAND_KILL:
		{
			DPFX(DPFPREP,5,"DPNSVR_COMMAND_KILL");
			hr = Command_Kill();
		}
		break;

	case DPNSVR_COMMAND_TABLE:
		{
			DPFX(DPFPREP,5,"DPNSVR_COMMAND_TABLE");
			hr = Command_Table();
		}
		break;

	default:
		{	
			DPFX(DPFPREP,5,"UNKNOWN COMMAND");
			hr = DPNERR_INVALIDPARAM;
		}
		break;
	}

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
	return( hr );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::RespondToRequest"
HRESULT CDirectPlayServer8::RespondToRequest( const GUID *pguidInstance,HRESULT hrResult,DWORD dwContext )
{
    HRESULT			hr;
	BOOL			fQueueOpen = FALSE;
    CDPNSVRIPCQueue	queue;
    DPNSVR_MSG_RESULT MsgResult;

	DPFX(DPFPREP,4,"Parameters: pguidInstance [0x%p],hrResult [0x%lx],dwContext [0x%lx]",pguidInstance,hrResult,dwContext);

	DNASSERT( pguidInstance != NULL );

	//
	//	Open queue
	//
    if ((hr = queue.Open( pguidInstance,DPNSVR_MSGQ_SIZE,DPNSVR_MSGQ_OPEN_FLAG_NO_CREATE )) != DPN_OK)
    {
		DPFERR("Could not open queue");
		DisplayDNError(0,hr);
		goto Failure;
    }
	fQueueOpen = TRUE;

	//
	//	Create result message
	//
    MsgResult.dwType = DPNSVR_MSGID_RESULT;
    MsgResult.dwCommandContext = dwContext;
    MsgResult.hrCommandResult = hrResult;

	//
	//	Send result message
	//
    if ((hr = queue.Send(	reinterpret_cast<BYTE*>(&MsgResult),
							sizeof(DPNSVR_MSG_RESULT),
							DPNSVR_TIMEOUT_RESULT,
							DPNSVR_MSGQ_MSGFLAGS_USER1,
							0 )) != DPN_OK)
    {
		DPFERR("Could not send message");
		DisplayDNError(0,hr);
		goto Failure;
    }

Exit:
	if (fQueueOpen)
	{
		queue.Close();
		fQueueOpen = FALSE;
	}

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
    return( hr );

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::RemoveZombies"
void CDirectPlayServer8::RemoveZombies( void )
{
	CBilink		*pBilink;
	CApplication	*pApp = NULL;

    DPFX(DPFPREP,4,"Parameters: (none)");

	pBilink = m_blApplication.GetNext();
	while ( pBilink != &m_blApplication )
	{
		pApp = CONTAINING_OBJECT( pBilink,CApplication,m_blApplication );
		pBilink = pBilink->GetNext();

		if (!pApp->IsRunning())
		{
		    DPFX(DPFPREP,5,"Found zombie application");

			pApp->m_blApplication.RemoveFromList();
			pApp->RemoveMappings();
			pApp->Release();
			pApp = NULL;
		}
	}

    DPFX(DPFPREP,4,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectPlayServer8::RunServer"
void CDirectPlayServer8::RunServer( void )
{
    LONG		lWaitResult;
    HRESULT		hr;
	PBYTE		pbBuffer = NULL;
	DWORD		dwBufferSize = 0;
	DWORD		dwSize;
    DPNSVR_MSGQ_HEADER dpHeader;
	DPNSVR_MSG_HEADER		*pMsgHeader;

    DPFX(DPFPREP,4,"Parameters: (none)");

    while( m_State == Initialized )
    {
        lWaitResult = DNWaitForSingleObject( m_RequestQueue.GetReceiveSemaphoreHandle(),DPNSVR_TIMEOUT_ZOMBIECHECK );

        if( lWaitResult == WAIT_TIMEOUT )
        {
            if( !InUse() )
            {
				DPFX(DPFPREP,5,"DPNSVR not in use ... shutting down");
				m_State = Closing;
				continue;
            }

			DPFX(DPFPREP,5,"Checking for zombies");
			RemoveZombies();
            continue;
        }
		else if( lWaitResult == WAIT_ABANDONED )
		{
			DPFX(DPFPREP,5,"Wait abandoned!");
		}

		//
		//	Get a message from the queue
		//
        DPFX(DPFPREP,5,"Checking for messages");
		while( 1 ) 
		{
			dwSize = dwBufferSize;

			hr = m_RequestQueue.GetNextMessage( &dpHeader, pbBuffer, &dwSize );

			if( hr == DPNERR_BUFFERTOOSMALL )
			{
				if( pbBuffer )
				{
					delete [] pbBuffer;
					pbBuffer = NULL;
				}
				
				pbBuffer = new BYTE[dwSize];
				if( pbBuffer == NULL )
				{
					DPFX(DPFPREP,  0, "Error allocating memory" );
					goto Failure;
				}

				dwBufferSize = dwSize;
			}
			else if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Error getting next message hr=0x%x", hr );
				goto Failure;
			}
			else if( dwSize == 0 )
			{
				continue;
			}
			else
			{
				break;
			}
		}

		//
		//	Process the message
		//
		pMsgHeader = reinterpret_cast<DPNSVR_MSG_HEADER*>(pbBuffer);
		switch( pMsgHeader->dwType )
		{
		case DPNSVR_MSGID_OPENPORT:
			{
				DPFX(DPFPREP,5,"DPNSVR_MSGID_OPENPORT");

				ResetActivity();

				hr = OpenPort( reinterpret_cast<DPNSVR_MSG_OPENPORT*>(pbBuffer) );
				RespondToRequest( &pMsgHeader->guidInstance, hr, pMsgHeader->dwCommandContext );
			}
			break;

		case DPNSVR_MSGID_CLOSEPORT:
			{
				DPFX(DPFPREP,5,"DPNSVR_MSGID_CLOSEPORT");

				ResetActivity();

				hr = ClosePort( reinterpret_cast<DPNSVR_MSG_CLOSEPORT*>(pbBuffer) );
				RespondToRequest( &pMsgHeader->guidInstance, hr, pMsgHeader->dwCommandContext );
			}
			break;

		case DPNSVR_MSGID_COMMAND:
			{
				DPFX(DPFPREP,5,"DPNSVR_MSGID_COMMAND");

				ResetActivity();
			
				hr = RunCommand( reinterpret_cast<DPNSVR_MSG_COMMAND*>(pbBuffer) );
				RespondToRequest( &pMsgHeader->guidInstance, hr, pMsgHeader->dwCommandContext );
			}

			break;

		default:
			{
				DPFX(DPFPREP,5,"UNKNOWN MESSAGE");
				DPFX(DPFPREP,5,"Unknown message type [%d]", pMsgHeader->dwType );
			}
			break;
		}
        DPFX(DPFPREP,5,"Result = [0x%lx]", hr );
    }

Exit:
	if( pbBuffer )
	{
		delete[] pbBuffer;
		pbBuffer = NULL;
	}

	DPFX(DPFPREP,4,"Returning");
	return;

Failure:
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrmapping.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsvrmapping.h
 *  Content:    DirectPlay8 DPNSVR application/listen mapping header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/12/02	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPNSVRMAPPING_H__
#define	__DPNSVRMAPPING_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CApplication;
class CListen;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

class CAppListenMapping
{
public:
	CAppListenMapping()
	{
		m_lRefCount = 1;

		m_pApp = NULL;
		m_pListen = NULL;
		m_pAddress = NULL;
		m_blAppMapping.Initialize();
		m_blListenMapping.Initialize();
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAppListenMapping::~CAppListenMapping"
	~CAppListenMapping()
	{
		DNASSERT( m_pApp == NULL );
		DNASSERT( m_pListen == NULL );
		DNASSERT( m_pAddress == NULL );
		DNASSERT( m_blAppMapping.IsEmpty() );
		DNASSERT( m_blListenMapping.IsEmpty() );
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAppListenMapping::AddRef"
	void AddRef( void )
	{
		long	lRefCount;

		lRefCount = InterlockedIncrement( const_cast<long*>(&m_lRefCount) );
        DPFX(DPFPREP,9,"New refcount [0x%lx]",lRefCount);
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAppListenMapping::Release"
	void Release( void )
	{
		long	lRefCount;

		lRefCount = InterlockedDecrement( const_cast<long*>(&m_lRefCount) );
        DPFX(DPFPREP,9,"New refcount [0x%lx]",lRefCount);

		if (lRefCount == 0)
		{
			delete this;
		}
	};

	CApplication *GetApplication( void )
	{
		return( m_pApp );
	};

	CListen *GetListen( void )
	{
		return( m_pListen );
	};

	IDirectPlay8Address *GetAddress( void )
	{
		return( m_pAddress );
	};

	void Associate( CApplication *const pApp,CListen *const pListen,IDirectPlay8Address *const pAddress );
	void Disassociate( void );

	CBilink				m_blAppMapping;
	CBilink				m_blListenMapping;

private:
	long	volatile	m_lRefCount;	// Object ref count

	CApplication		*m_pApp;		// Application
	CListen				*m_pListen;		// Listen

	IDirectPlay8Address	*m_pAddress;	// Address to forward enums to
};

#endif	// __DPNSVRMAPPING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\sources.inc ===
TARGETNAME=dpnsvr
TARGETTYPE=PROGRAM

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnsvri.h
PRECOMPILED_PCH=dnsvri.pch
PRECOMPILED_OBJ=dnsvri.obj

INCLUDES=..\;..\..\..\inc;..\..\inc;..\..\..\common;..\..\dpnsvlib;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES=dpnsvr.rc \
        dpnsvrmain.cpp \
	dpnsvrserver.cpp \
	dpnsvrservprov.cpp \
	dpnsvrlisten.cpp \
	dpnsvrapp.cpp \
	dpnsvrmapping.cpp

TARGETLIBS=$(TARGETLIBS) \
	 ..\..\..\guids\$(PLAT_DIR)\$(O)\guids.lib \
	 ..\..\..\common\$(PLAT_DIR)\$(O)\common.lib \
   	 ..\..\..\dpnsvr\dpnsvlib\$(PLAT_DIR)\$(O)\dpnsvlib.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrservprov.cpp ===
#include "dnsvri.h"

void *DP8SPCallback[] =
{
    (void *)CServProv::CallbackQueryInterface,
    (void *)CServProv::CallbackAddRef,
    (void *)CServProv::CallbackRelease,
	(void *)CServProv::CallbackIndicateEvent,
	(void *)CServProv::CallbackCommandComplete
};

#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::CallbackQueryInterface"
HRESULT CServProv::CallbackQueryInterface( IDP8SPCallback *pSP, REFIID riid, LPVOID * ppvObj )
{
	HRESULT	hr;

	DNASSERT( !"This function should never get called!" );

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDP8SPCallback)))
	{
		hr = E_NOINTERFACE;		
	}
	else
	{
	    *ppvObj = pSP;
	    hr = DPN_OK;
	}
    return(hr);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::CallbackAddRef"
ULONG CServProv::CallbackAddRef( IDP8SPCallback *pSP )
{
    return 1;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::CallbackRelease"
ULONG CServProv::CallbackRelease( IDP8SPCallback *pSP )
{
    return 1;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::CallbackIndicateEvent"
HRESULT CServProv::CallbackIndicateEvent( IDP8SPCallback *pSP,SP_EVENT_TYPE spetEvent,LPVOID pvData )
{
	CServProv	*pServProv = reinterpret_cast<CServProv*>(pSP);
    HRESULT		hr;

	DPFX(DPFPREP,4,"Parameters: pSP [0x%p], spetEvent [%ld], pvData [0x%p]",pSP,spetEvent,pvData);

    switch( spetEvent )
    {
    case SPEV_CONNECT:
		{
//			SPIE_CONNECT	*pSPConnect = static_cast<SPIE_CONNECT*>(pvData);

			DPFX(DPFPREP,5,"SPEV_CONNECT");
			InterlockedIncrement( const_cast<LONG*>(&pServProv->m_lConnectCount) );

			hr = DPN_OK;
		}
		break;

    case SPEV_DISCONNECT:
		{
//			SPIE_DISCONNECT	*pSPDisconnect = static_cast<SPIE_DISCONNECT*>(pvData);

			DPFX(DPFPREP,5,"SPEV_DISCONNECT");
			InterlockedIncrement( const_cast<LONG*>(&pServProv->m_lDisconnectCount) );

			hr = DPN_OK;
		}
        break;

    case SPEV_LISTENSTATUS:
		{
			SPIE_LISTENSTATUS	*pSPListenStatus = static_cast<SPIE_LISTENSTATUS*>(pvData);

			DPFX(DPFPREP,5,"SPEV_LISTENSTATUS");
			hr = pServProv->HandleListenStatus( pSPListenStatus );
		}
        break;

    case SPEV_ENUMQUERY:
		{
			SPIE_QUERY	*pSPQuery = static_cast<SPIE_QUERY*>(pvData);

			DPFX(DPFPREP,5,"SPEV_ENUMQUERY");
			InterlockedIncrement( const_cast<LONG*>(&pServProv->m_lEnumQueryCount) );

			hr = pServProv->HandleEnumQuery( pSPQuery );
		}
        break;

    case SPEV_QUERYRESPONSE:
		{
//			SPIE_QUERYRESPONSE	*pSPQueryResponse = static_cast<SPIE_QUERYRESPONSE*>(pvData);

			DPFX(DPFPREP,5,"SPEV_QUERYRESPONSE");
			InterlockedIncrement( const_cast<LONG*>(&pServProv->m_lEnumResponseCount) );

			hr = DPN_OK;
		}
        break;

    case SPEV_DATA:
		{
//			SPIE_DATA	*pSPData = static_cast<SPIE_DATA*>(pvData);

			DPFX(DPFPREP,5,"SPEV_DATA");
			InterlockedIncrement( const_cast<LONG*>(&pServProv->m_lDataCount) );

			hr = DPN_OK;
		}
        break;

    case SPEV_UNKNOWN:
		{
			DPFX(DPFPREP,5,"SPEV_UNKNOWN");
			DPFX(DPFPREP,5,"Response = Ignore" );

			hr = DPN_OK;
		}
		break;

	default:
		{
			DPFX(DPFPREP,5,"UNKNOWN CALLBACK!");
			DPFX(DPFPREP,5,"Response = Ignore" );

			hr = DPN_OK;
		}
		break;
    }

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
    return(hr);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::CallbackCommandComplete"
HRESULT CServProv::CallbackCommandComplete( IDP8SPCallback *pSP,HANDLE hCommand,HRESULT hrResult,LPVOID pvData )
{
	DPFX(DPFPREP,4,"Parameters: pSP [0x%p], hCommand [0x%lx], hrResult [0x%lx], pvData [0x%p]",pSP,hCommand,hrResult,pvData);

	//
	//	Right now, the (probably busted) assumption is that only listens will complete
	//	with pvData being set to a non-NULL value
	//
	if (pvData != NULL)
	{
		//
		//	Release the SP's reference on this
		//
		(static_cast<CListen*>(pvData))->Release();
	}

 	DPFX(DPFPREP,4,"Returning: DPN_OK");
	return( DPN_OK );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::HandleListenStatus"
HRESULT CServProv::HandleListenStatus( SPIE_LISTENSTATUS *const pListenStatus )
{
	CListen	*pListen;
	
	DPFX(DPFPREP,4,"Parameters: pListenStatus [0x%p]",pListenStatus);

	DNASSERT(pListenStatus->pUserContext != NULL);
	pListen = static_cast<CListen*>(pListenStatus->pUserContext);

	//
	//	Save the result of this operation and set the completion event
	//
	DPFX(DPFPREP,5,"Listen Status [0x%lx]", pListenStatus->hResult );
	pListen->SetCompleteEvent( pListenStatus->hResult );

	DPFX(DPFPREP,4,"Returning: DPN_OK");
    return( DPN_OK );
}


//
//	Forward incoming enum queries.  The context of the SPIE_QUERY structure is the context
//	handed to the SP listen call (i.e. the pointer to our CListen structure).  We will walk through
//	the applications mapped to this listen and forward this enum query to them.
//
//	ASSUMPTION: The listen won't end (complete) before this thread returns as we assume that
//				the CListen structure is still valid (i.e. the SP has a ref count on it)
//

#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::HandleEnumQuery"
HRESULT CServProv::HandleEnumQuery( SPIE_QUERY *const pEnumQuery )
{
	HRESULT			hr;
	CBilink			*pBilink;
	CListen			*pListen = NULL;
	CAppListenMapping	*pMapping = NULL;
    SPPROXYENUMQUERYDATA spProxyEnum;

	DPFX(DPFPREP,4,"Parameters: pEnumQuery [0x%p]",pEnumQuery);

	DNASSERT( pEnumQuery->pUserContext != NULL );
	pListen = static_cast<CListen*>(pEnumQuery->pUserContext);

    spProxyEnum.dwFlags = 0;
    spProxyEnum.pIncomingQueryData = pEnumQuery;

	//
	//	Run through mappings and pass along enum query.
	//	We will need to lock the listen object so that its mappings can't be touched.
	//	We will hold the lock through the calls to the SP.  I know ... bad ... so sue me.
	//		It's either that or do a malloc to keep an array of references.
	//
	pListen->Lock();
	pBilink = pListen->m_blAppMapping.GetNext();
	while (pBilink != &pListen->m_blAppMapping)
	{
		pMapping = CONTAINING_OBJECT( pBilink,CAppListenMapping,m_blAppMapping );

		IDirectPlay8Address_AddRef( pMapping->GetAddress() );
		spProxyEnum.pDestinationAdapter = pMapping->GetAddress();

	    if ((hr = IDP8ServiceProvider_ProxyEnumQuery( m_pDP8SP,&spProxyEnum )) != DPN_OK)
		{
			DPFERR("Could not forward enum");
			DisplayDNError(0,hr);
		}

		IDirectPlay8Address_Release( spProxyEnum.pDestinationAdapter );
		spProxyEnum.pDestinationAdapter = NULL;

		pBilink = pBilink->GetNext();
	}
	pListen->Unlock();

	DPFX(DPFPREP,4,"Returning: DPN_OK");
	return( DPN_OK );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::Initialize"
HRESULT CServProv::Initialize( GUID *const pguidSP )
{
	HRESULT				hr;
	SPINITIALIZEDATA	spInitData;
	SPGETCAPSDATA		spGetCapsData;
	BOOL				fInitialized = FALSE;

	DPFX(DPFPREP,4,"Parameters: pguidSP [0x%p]",pguidSP);

	//
	//	Create SP interface
	//
	hr = COM_CoCreateInstance(	*pguidSP,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_IDP8ServiceProvider,
								(void **) &(m_pDP8SP),
								FALSE );
	if( FAILED( hr ) )
	{
		DPFERR("Could not create service provider");
		DisplayDNError(0,hr);
	    goto Failure;
	}

	//
	//	Initialize SP interface
	//
	spInitData.dwFlags = 0;
	spInitData.pIDP = reinterpret_cast<IDP8SPCallback*>(&m_pDP8SPCallbackVtbl);

	if ((hr = IDP8ServiceProvider_Initialize(m_pDP8SP,&spInitData)) != DPN_OK)
	{
		DPFERR("Could not initialize service provider");
		DisplayDNError(0,hr);
		goto Failure;
	}
	fInitialized = TRUE;

	//
	//	Ensure this SP supports DPNSVR
	//
	memset(&spGetCapsData, 0, sizeof(SPGETCAPSDATA));
	spGetCapsData.dwSize = sizeof(SPGETCAPSDATA);
	spGetCapsData.hEndpoint = INVALID_HANDLE_VALUE;
	if ((hr = IDP8ServiceProvider_GetCaps( m_pDP8SP,&spGetCapsData )) != DPN_OK)
	{
		DPFERR("Could not get service provider caps");
		DisplayDNError(0,hr);
		goto Failure;
	}

	if (!(spGetCapsData.dwFlags & DPNSPCAPS_SUPPORTSDPNSRV))
	{
		DPFERR("Service provider does not support DPNSVR");
		hr = DPNERR_UNSUPPORTED;
		goto Failure;
	}

	m_guidSP = *pguidSP;

Exit:
	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
	return( hr );

Failure:
	if (m_pDP8SP)
	{
		if (fInitialized)
		{
			IDP8ServiceProvider_Close( m_pDP8SP );
		}
		IDP8ServiceProvider_Release( m_pDP8SP );
		m_pDP8SP = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::FindListen"
HRESULT CServProv::FindListen( GUID *const pguidDevice,CListen **const ppListen )
{
	HRESULT	hr;
	CBilink	*pBilink;
	CListen	*pListen = NULL;

	DPFX(DPFPREP,4,"Parameters: pguidDevice [0x%p], ppListen [0x%p]",pguidDevice,ppListen);

	DNASSERT( pguidDevice != NULL );
	DNASSERT( ppListen != NULL );

	hr = DPNERR_DOESNOTEXIST;

	pBilink = m_blListen.GetNext();
	while ( pBilink != &m_blListen )
	{
		pListen = CONTAINING_OBJECT( pBilink,CListen,m_blListen );
		if (pListen->IsEqualDevice( pguidDevice ))
		{
			pListen->AddRef();
			*ppListen = pListen;
			hr = DPN_OK;
			break;
		}
		pBilink = pBilink->GetNext();
	}

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
	return( hr );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CServProv::StartListen"
HRESULT CServProv::StartListen( GUID *const pguidDevice,CListen **const ppListen )
{
	HRESULT		hr;
	CListen		*pListen = NULL;

	DPFX(DPFPREP,4,"Parameters: pguidDevice [0x%p], ppListen [0x%p]",pguidDevice,ppListen);

	DNASSERT( pguidDevice != NULL );
	DNASSERT( ppListen != NULL );

	pListen = new CListen;
	if (pListen == NULL)
	{
		DPFERR("Could not create new listen");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	if ((hr = pListen->Initialize()) != DPN_OK)
	{
		DPFERR("Could not initialize listen");
		DisplayDNError(0,hr);
		goto Failure;
	}

	if ((hr = pListen->Start( this,pguidDevice )) != DPN_OK)
	{
		DPFERR("Could not start listen");
		DisplayDNError(0,hr);
		goto Failure;
	}

	if (ppListen)
	{
		pListen->AddRef();
		*ppListen = pListen;
	}

	pListen->m_blListen.InsertAfter( &m_blListen );
	pListen = NULL;

Exit:
	if (pListen)
	{
		pListen->Release();
		pListen = NULL;
	}

	DPFX(DPFPREP,4,"Returning: [0x%lx]",hr);
	return( hr );

Failure:
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrserver.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsvrserver.h
 *  Content:    DirectPlay8 DPNSVR server header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/14/00    rodtoll Created it
 *	03/23/00    rodtoll Removed local requests, updated to use new data sturctures
 *	03/25/00    rodtoll Updated so uses SP caps to determine which SPs to load
 *              rodtoll Now supports N SPs and only loads those supported
 *	05/09/00    rodtoll Bug #33622 DPNSVR.EXE does not shutdown when not in use 
 *	07/09/00	rodtoll	Added guard bytes
 *  07/12/02	mjn		Replaced dpsvr8.h with dpnsvrserver.h
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPNSVRSERVER_H__
#define	__DPNSVRSERVER_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define DPNSVRSIGNATURE_SERVEROBJECT		'BOSD'
#define DPNSVRSIGNATURE_SERVEROBJECT_FREE	'BOS_'

#define DPNSVR_TIMEOUT_ZOMBIECHECK			5000
#define	DPNSVR_TIMEOUT_SHUTDOWN				20000

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef enum
{
	Uninitialized,
	Initialized,
	Closing
} DPNSVR_STATE;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

#include "dpnsdef.h"
#include "dpnsvrq.h"

class CDirectPlayServer8
{
public:
	CDirectPlayServer8()
	{
		m_dwSignature = DPNSVRSIGNATURE_SERVEROBJECT;
		m_State = Uninitialized;

		m_hSingleInstance = NULL;
		m_hStartup = NULL;

		m_hStatusMutex = NULL;
		m_hTableMutex = NULL;

		m_hStatusMappedFile = NULL;
		m_pStatusMapView = NULL;

		m_dwServProvCount = 0;

		m_hTableMappedFile = NULL;
		m_pTableMapView = NULL;
		m_dwTableSize = 0;

		m_hMappedFile = NULL;
		m_hTableMappedFile = NULL;
		m_pMappedTable = NULL;
		m_dwNumServices = 0;
		m_dwSizeStatusBlock = 0;

		m_blApplication.Initialize();
		m_blServProv.Initialize();
	}

	~CDirectPlayServer8()
	{
		m_dwSignature = DPNSVRSIGNATURE_SERVEROBJECT_FREE;
	}



    HRESULT Initialize( void );
	void Deinitialize( void );

	void RunServer( void );

private:
	
	void Lock( void )
	{
		DNEnterCriticalSection( &m_cs );
	};

	void Unlock( void )
	{
		DNLeaveCriticalSection( &m_cs );
	};

	HRESULT Command_Kill( void )
	{
		m_State = Closing;
		return DPN_OK;
	};

    HRESULT Command_Status( void );
    HRESULT Command_Table( void );
    HRESULT Command_ProcessMessage( LPVOID pvMessage );

    static HRESULT RespondToRequest( const GUID *pguidInstance, HRESULT hrResult, DWORD dwContext );

	HRESULT FindApplication( GUID *const pguidApplication,GUID *const pguidInstance, CApplication **const ppApp );
	HRESULT FindServProv( GUID *const pguidSP, CServProv **const ppServProv );
	
	BOOL CDirectPlayServer8::InUse( void )
	{
		//
		//	Not in use if there are no apps and nothing has happened for a while
		//
		if ( m_blApplication.IsEmpty() )
		{
			if( (GetTickCount() - m_dwLastActivity) > DPNSVR_TIMEOUT_SHUTDOWN )
			{
				return( FALSE );
			}
		}
		return( TRUE );
	};

	void ResetActivity( void )
	{
		m_dwLastActivity = GetTickCount();
	};

    HRESULT OpenPort( DPNSVR_MSG_OPENPORT *const pOpenPort );
	HRESULT ClosePort( DPNSVR_MSG_CLOSEPORT *const pClosePort );
	HRESULT RunCommand( const DPNSVR_MSG_COMMAND* const pCommand );

	void RemoveZombies( void );

private:
	DWORD					m_dwSignature;
	DPNSVR_STATE			m_State;

	DNHANDLE				m_hSingleInstance;	// Single DPNSVR instance event
	DNHANDLE				m_hStartup;			// Start up event

    DWORD					m_dwStartTicks;		// Time DPNSVR started up

	CDPNSVRIPCQueue			m_RequestQueue;		// DPNSVR request queue

	DNHANDLE				m_hTableMutex;		// Table info mutex
	DNHANDLE				m_hStatusMutex;		// Status info mutex

    DNHANDLE				m_hStatusMappedFile;// Status memory mapped file
	void					*m_pStatusMapView;	// Status memory mapped file view

	DWORD					m_dwServProvCount;	// Number of SP's

	DNHANDLE				m_hTableMappedFile;	// Table memory mapped file
	void					*m_pTableMapView;	// Table memory mapped file view
    DWORD					m_dwTableSize;		// Table size (in bytes)

	DNHANDLE				m_hMappedFile;
    PBYTE					m_pMappedTable;
	DWORD					m_dwNumServices;
	DWORD					m_dwSizeStatusBlock;
	DWORD_PTR				m_dwLastActivity;

	CBilink					m_blApplication;	// Applications registered
	CBilink					m_blServProv;		// Service providers in use

	DNCRITICAL_SECTION		m_cs;				// Lock
};

#endif // __DPNSVRSERVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\inc\dpnsvmsg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsvmsg.h
 *  Content:    DirectPlay8 Server Object Messages 
 *              Definitions of DPNSVR <--> DirectPlay8 Applications
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/20/00     rodtoll Created it
 * 03/23/00     rodtoll Removed port entries -- no longer needed
 * 03/24/00		rodtoll	Updated, only sending one entry per message
 *				rodtoll	Removed SP field, can be extracted from URL
 ***************************************************************************/

#ifndef __DPNSVMSG_H
#define __DPNSVMSG_H

// DirectPlay8 Server Message IDs
#define DPNSVR_MSGID_OPENPORT	0x01
#define DPNSVR_MSGID_CLOSEPORT	0x02
#define DPNSVR_MSGID_RESULT		0x03
#define DPNSVR_MSGID_COMMAND	0x04

#define DPNSVR_COMMAND_STATUS	0x01
#define DPNSVR_COMMAND_KILL		0x02
#define DPNSVR_COMMAND_TABLE	0x03

typedef struct _DPNSVR_MSG_HEADER
{
    DWORD       dwType;
	DWORD		dwCommandContext;
	GUID		guidInstance;
} DPNSVR_MSG_HEADER;

// DirectPlay8 Server Message Structures
typedef struct _DPNSVR_MSG_OPENPORT
{
	DPNSVR_MSG_HEADER	Header;
    DWORD       dwProcessID;		// Process ID of requesting process
	GUID		guidSP;
    GUID        guidApplication;	// Application GUID of app requesting open
    DWORD       dwAddressSize;		// # of addresses after this header in the message
} DPNSVR_MSG_OPENPORT;

typedef struct _DPNSVR_MSG_CLOSEPORT
{
	DPNSVR_MSG_HEADER	Header;
    DWORD       dwProcessID;		// Process ID of requesting process
	GUID		guidSP;
    GUID        guidApplication;	// Application GUID of app requesting close
} DPNSVR_MSG_CLOSEPORT;

typedef struct _DPNSVR_MSG_COMMAND
{
	DPNSVR_MSG_HEADER	Header;
	DWORD		dwCommand;			// = DPNSVCOMMAND_XXXXXXXX
	DWORD		dwParam1;
	DWORD		dwParam2;
} DPNSVR_MSG_COMMAND;

typedef struct _DPNSVR_MSG_RESULT
{
    DWORD       dwType;             // = DPNSVMSGID_RESULT
    DWORD       dwCommandContext;   // User supplied context
    HRESULT     hrCommandResult;    // Result of command
} DPNSVR_MSG_RESULT;


#endif // __DPNSVMSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\forwarders\dnaddress\sources.inc ===
TARGETNAME=dpnaddr
TARGETTYPE=DYNLINK
DLLENTRY=DllMain
DLLDEF=..\dnadd.def

# This causes any other directory that is building in a concurrent thread to finish
# before this directory is built.  This is necessary to ensure that dpnet.lib has
# been produced since we use it prior to the link phase via LINKLIBS.  Apparently
# when a DLL forwards to another DLL, the DEF file is parsed at compile time and the
# LIB being forwarded to is needed at that time.
SYNCHRONIZE_DRAIN=1

LINKLIBS=$(LINKLIBS) \
!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
         ..\..\..\core\$(PLAT_DIR)\$(O)\dpnetd.lib
!ELSE
         ..\..\..\core\$(PLAT_DIR)\$(O)\dpnet.lib
!ENDIF

INCLUDES=..\;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES= \
	dnadd.rc \
	adddllmain.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\forwarders\dnaddress\adddllmain.cpp ===
#include <windows.h>
#include "unknwn.h"

extern	HRESULT WINAPI DirectPlay8Create( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);

STDAPI_(BOOL) DllMain( HANDLE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
#ifdef	WIN95
	//
	//	This is a fix to ensure that dpnet.dll gets loaded so GetProcAddress() doesn't fail on Win9x for
	//	legacy calls to DirectPlay8AddressCreate().  This code should never get executed, nor get optimized out.
	//
	if ((hModule == NULL) && (ul_reason_for_call == 0x12345678) && (lpReserved == NULL))
	{
		DirectPlay8Create( NULL, NULL, NULL );
	}
#endif	// WIN95

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\inc\dpnsdef.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsdef.cpp
 *  Content:    DirectPlay8 Server Definitions
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 03/14/00     rodtoll Created it
 * 03/23/00     rodtoll Updated to match new data structure and add new GUID
 * 03/25/00     rodtoll Changed status format to support N provider
 *              rodtoll New GUID for mutex guarding status
 ***************************************************************************/

#ifndef __DPNSDEF_H
#define __DPNSDEF_H


// STRING_GUID_DPNSVR_STATUS_MEMORY - Name of shared memory location used to 
// write data on current status to.  
#define STRING_GUID_DPNSVR_STATUS_MEMORY _T("{A7B81E49-A7DD-4066-A970-E07C67D8DFB1}")

DEFINE_GUID(GUID_DPNSVR_STATUS_MEMORY, 
0xa7b81e49, 0xa7dd, 0x4066, 0xa9, 0x70, 0xe0, 0x7c, 0x67, 0xd8, 0xdf, 0xb1);

// STRING_GUID_DPNSVR_TABLE_MEMBORY - Name of shared memory location used to
// write table to.
//
#define STRING_GUID_DPNSVR_TABLE_MEMORY _T("{733A46D6-B5DB-47e7-AE67-464577CD687C}")

DEFINE_GUID(GUID_DPNSVR_TABLE_MEMORY, 
0x733a46d6, 0xb5db, 0x47e7, 0xae, 0x67, 0x46, 0x45, 0x77, 0xcd, 0x68, 0x7c);

// STRING_GUID_DPNSVR_STATUSSTORAGE
//
// Mutex protecting status storage
//
#define STRING_GUID_DPNSVR_STATUSSTORAGE _T("{9F84FFA4-680E-48d8-9DBA-4AA8591AB8E3}")

DEFINE_GUID(GUID_DPNSVR_STATUSSTORAGE, 
0x9f84ffa4, 0x680e, 0x48d8, 0x9d, 0xba, 0x4a, 0xa8, 0x59, 0x1a, 0xb8, 0xe3);


// STRING_GUID_DPSVR_TABLESTORAGE -
//
// Mutex protecting table storage
#define STRING_GUID_DPNSVR_TABLESTORAGE _T("{23AD69B4-E81C-4292-ABD4-2EAF9A262E91}")

DEFINE_GUID(GUID_DPNSVR_TABLESTORAGE, 
0x23ad69b4, 0xe81c, 0x4292, 0xab, 0xd4, 0x2e, 0xaf, 0x9a, 0x26, 0x2e, 0x91);

// STRING_GUID_DPNSVR_QUEUE -
//
// Queue name for IPC server queue
#define STRING_GUID_DPNSVR_QUEUE    _T("{CCD83B99-7091-43df-A062-7EC62A66207A}")

DEFINE_GUID(GUID_DPNSVR_QUEUE, 
0xccd83b99, 0x7091, 0x43df, 0xa0, 0x62, 0x7e, 0xc6, 0x2a, 0x66, 0x20, 0x7a);

// STRING_GUID_DPNSVR_RUNNING
//
// Used for name of event that determines if it's running
#define STRING_GUID_DPNSVR_RUNNING  _T("{D8CF6BF0-3CFA-4e4c-BA39-40A1E7AFBCD7}")

DEFINE_GUID(GUID_DPNSVR_RUNNING, 
0xd8cf6bf0, 0x3cfa, 0x4e4c, 0xba, 0x39, 0x40, 0xa1, 0xe7, 0xaf, 0xbc, 0xd7);

// STRING_GUID_DPNSVR_STARTUP
//
// Name of manual reset event that is signalled once server has started;
//
#define STRING_GUID_DPNSVR_STARTUP _T("{0CBA5850-FD98-4cf8-AC49-FC3ED287ACF1}")

DEFINE_GUID(GUID_DPNSVR_STARTUP, 
0xcba5850, 0xfd98, 0x4cf8, 0xac, 0x49, 0xfc, 0x3e, 0xd2, 0x87, 0xac, 0xf1);

typedef UNALIGNED struct _DPNSVR_STATUSHEADER
{
    DWORD       dwStartTime;
    DWORD       dwSPCount;
} DPNSVR_STATUSHEADER;

typedef UNALIGNED struct _DPNSVR_SPSTATUS
{
    GUID        guidSP;
    DWORD       dwNumListens;
    long		lConnectCount;
    long		lDisconnectCount;
    long		lEnumQueryCount;
    long		lEnumResponseCount;
    long		lDataCount;
} DPNSVR_SPSTATUS;


// DPNSVR TABLE
//
// The following structures are used for dumping the current contents of
// the port / application structure table.
//
// The table format in memory is as follows:
//
//	[TABLEHEADER]
//		[SERVPROV(1)]
//			[LISTEN(SP1,1)]
//				[APP(SP1,L1,1)]
//				[APP(SP1,L1,2)]
//			[LISTEN(SP1,2)]
//				[APP(SP1,L2,1)]
//		[SERVPROV(2)]
//			[LISTEN(SP2,1)]
//				[APP(SP2,L1,1)]
//			[LISTEN(SP2,2)]
//				[APP(SP2,L2,1)]
//				[APP(SP2,L2,2)]
//	[URL(SP2,L2,A2)][URL(SP2,L2,A1)][URL(SP2,L1,A1)][URL(SP1,L2,A1)][URL(SP1,L1,A2)][URL(SP1,L1,A1)]
//

typedef UNALIGNED struct _DPNSVR_TABLEHEADER
{
	DWORD		dwTableSize;
	DWORD		dwSPCount;
} DPNSVR_TABLEHEADER;

typedef	UNALIGNED struct _DPNSVR_TABLESPENTRY
{
	GUID		guidSP;
	DWORD		dwListenCount;
} DPNSVR_TABLESPENTRY;

typedef UNALIGNED struct _DPNSVR_TABLELISTENENTRY
{
	GUID		guidDevice;
	DWORD		dwAppCount;
} DPNSVR_TABLELISTENENTRY;

typedef UNALIGNED struct _DPNSVR_TABLEAPPENTRY
{
	GUID		guidApplication;
	GUID		guidInstance;
	DWORD		dwURLOffset;
} DPNSVR_TABLEAPPENTRY;

#define DPNSVR_TIMEOUT_REQUEST		3000
#define DPNSVR_TIMEOUT_RESULT		3000

#endif // __DPNSDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\dpnsvr\dpnsvr\dpnsvrservprov.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnsvrservprov.h
 *  Content:    DirectPlay8 DPNSVR service provider header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/12/02	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPNSVRSERVPROV_H__
#define	__DPNSVRSERVPROV_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CListen;

//**********************************************************************
// Variable definitions
//**********************************************************************

extern	void *DP8SPCallback[];

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

class CServProv
{
public:
	static HRESULT	CallbackQueryInterface( IDP8SPCallback *pSP, REFIID riid, LPVOID * ppvObj );
	static ULONG	CallbackAddRef( IDP8SPCallback *pSP );
	static ULONG	CallbackRelease( IDP8SPCallback *pSP );
	static HRESULT	CallbackIndicateEvent( IDP8SPCallback *pSP,SP_EVENT_TYPE spetEvent,LPVOID pvData );
	static HRESULT	CallbackCommandComplete( IDP8SPCallback *pSP,HANDLE hCommand,HRESULT hrResult,LPVOID pvData );

	CServProv()
	{
		m_lRefCount = 1;

		memset(&m_guidSP,0x0,sizeof(GUID));
		m_pDP8SP = NULL;
		m_pDP8SPCallbackVtbl = &DP8SPCallback;

		m_lConnectCount = 0;
		m_lDisconnectCount = 0;
		m_lEnumQueryCount = 0;
		m_lEnumResponseCount = 0;
		m_lDataCount = 0;

		m_blServProv.Initialize();
		m_blListen.Initialize();
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CServProv::~CServProv"
	~CServProv()
	{
		DNASSERT( m_pDP8SP == NULL );
		DNASSERT( m_blServProv.IsEmpty() );
		DNASSERT( m_blListen.IsEmpty() );
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CServProv::AddRef"
	void AddRef( void )
	{
		long	lRefCount;

		lRefCount = InterlockedIncrement( const_cast<long*>(&m_lRefCount) );
        DPFX(DPFPREP,9,"New refcount [0x%lx]",lRefCount);
	};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CServProv::Release"
	void Release( void )
	{
		long	lRefCount;

		lRefCount = InterlockedDecrement( const_cast<long*>(&m_lRefCount) );
        DPFX(DPFPREP,9,"New refcount [0x%lx]",lRefCount);

		if (lRefCount == 0)
		{
			if ( m_pDP8SP )
			{
				IDP8ServiceProvider_Close( m_pDP8SP );
				IDP8ServiceProvider_Release( m_pDP8SP );
				m_pDP8SP = NULL;
			}
			delete this;
		}
	};

	HRESULT Initialize( GUID *const pguidSP );

	BOOL IsEqual( GUID *const pguidSP )
	{
		if (*pguidSP == m_guidSP)
		{
			return( TRUE );
		}
		return( FALSE );
	};

	GUID *GetSPGuidPtr( void )
	{
		return( &m_guidSP );
	};

	IDP8ServiceProvider *GetDP8SPPtr( void )
	{
		return( m_pDP8SP );
	};

	HRESULT HandleListenStatus( SPIE_LISTENSTATUS *const pListenStatus );
	HRESULT HandleEnumQuery( SPIE_QUERY *const pEnumQuery );

	HRESULT CServProv::FindListen( GUID *const pguidDevice,CListen **const ppListen );
	HRESULT CServProv::StartListen( GUID *const pguidDevice,CListen **const ppListen );

	void DumpStatus( DPNSVR_SPSTATUS *const pStatus )
	{
		pStatus->guidSP = m_guidSP;
		pStatus->lConnectCount = m_lConnectCount;
		pStatus->lDataCount = m_lDataCount;
		pStatus->lDisconnectCount = m_lDisconnectCount;
		pStatus->lEnumResponseCount = m_lEnumResponseCount;
		pStatus->lEnumQueryCount = m_lEnumQueryCount;

		pStatus->dwNumListens = 0;
	};

private:
	void				*m_pDP8SPCallbackVtbl;	// SP Callback interface

public:
	CBilink	m_blServProv;
	CBilink	m_blListen;

private:
	long	volatile	m_lRefCount;			// Object ref count

	GUID				m_guidSP;				// SP guid
	IDP8ServiceProvider	*m_pDP8SP;				// SP interface

	long	volatile	m_lConnectCount;		// incoming packet statistics
	long	volatile	m_lDisconnectCount;
	long	volatile	m_lEnumQueryCount;
	long	volatile	m_lEnumResponseCount;
	long	volatile	m_lDataCount;
};

#endif	// __DPNSVRSERVPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\forwarders\lobby\sources.inc ===
TARGETNAME=dpnlobby
TARGETTYPE=DYNLINK
DLLENTRY=DllMain
DLLDEF=..\dplobby.def

# This causes any other directory that is building in a concurrent thread to finish
# before this directory is built.  This is necessary to ensure that dpnet.lib has
# been produced since we use it prior to the link phase via LINKLIBS.  Apparently
# when a DLL forwards to another DLL, the DEF file is parsed at compile time and the
# LIB being forwarded to is needed at that time.
SYNCHRONIZE_DRAIN=1

LINKLIBS=$(LINKLIBS) \
!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
         ..\..\..\core\$(PLAT_DIR)\$(O)\dpnetd.lib
!ELSE
         ..\..\..\core\$(PLAT_DIR)\$(O)\dpnet.lib
!ENDIF

INCLUDES=..\;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES= \
	dplobby.rc \
	dpldllmain.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\guids\guids.cpp ===
#include "dpnbuild.h"
#include <objbase.h>
#include <initguid.h>
#include "dplay8.h"
#include "dpaddr.h"
#include "dplobby8.h"
#include "dpsp8.h"
#include "dpprot.h"
#include "dpnsdef.h"

#ifndef DPNBUILD_NOVOICE
#include "dvoice.h"
#endif // !DPNBUILD_NOVOICE
#ifndef WINCE
#include "dplegacyguid.h"
#endif // !WINCE
#ifndef DPNBUILD_NONATHELP
#include "dpnathlp.h"
#endif // ! DPNBUILD_NONATHELP

// Linking uuid.lib on WinCE pulls in more IID's than we use
DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\forwarders\lobby\dpldllmain.cpp ===
#include <windows.h>
#include "unknwn.h"

extern	HRESULT WINAPI DirectPlay8Create( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);

STDAPI_(BOOL) DllMain( HANDLE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
#ifdef	WIN95
	//
	//	This is a fix to ensure that dpnet.dll gets loaded so GetProcAddress() doesn't fail on Win9x for
	//	legacy calls to DirectPlay8LobbyCreate().  This code should never get executed, nor get optimized out.
	//
	if ((hModule == NULL) && (ul_reason_for_call == 0x12345678) && (lpReserved == NULL))
	{
		DirectPlay8Create( NULL, NULL, NULL );
	}
#endif	// WIN95

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\guids\sources.inc ===
TARGETNAME=guids
TARGETTYPE=LIBRARY

INCLUDES=..\..\..\dvoice\inc;..\..\dpnsvr\inc;..\..\inc;..\..\core;..\..\dnaddress;..\..\..\dpnathlp\inc;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES=guids.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\inc\dpaddr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpaddr.h
 *  Content:   DirectPlayAddress include file
//@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	==========================
 *	01/31/2000	rmt		created
 *  02/12/2000  rmt		Split Get into GetByIndex and GetByName
 *  02/14/2000  vanceo	Hid remaining references to Internal
 *  02/17/2000	rmt		Added dnet header def and removed error codes (see dplay8.h for error codes for them)
 *  02/21/2000	rmt		Cleared out redundant interfaces, added defines, added new macros
 *  03/22/2000  rmt     Updated to add SetEqual, BuildFromDPAddress and new ANSI data type
 *  03/24/2000	rmt		Added IsEqual function
 *  05/04/2000  rmt     Bug #34155 - Incorrect defines
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *  08/03/2000 	rmt		Bug #41246 - Remove IP versions of Duplicate, SetEqual, IsEqual, BuildURL
 *  08/07/2000  rmt     Bug #41185 - Header Cleanup
 *  03/17/2001	rmt		WINBUG #342420 - Commented out create functions 
 *  10/08/2001	vanceo	Add scope component
 *  11/06/2001	vanceo	Add processor component
//@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DIRECTPLAYADDRESS__
#define __DIRECTPLAYADDRESS__

//@@BEGIN_MSINTERNAL
#ifdef _XBOX
#ifdef XBOX_ON_DESKTOP
#include <ole2.h>	   // for DECLARE_INTERFACE_ and HRESULT
#endif // XBOX_ON_DESKTOP
#undef DECLARE_INTERFACE_
#define DECLARE_INTERFACE_(iface, baseiface)	DECLARE_INTERFACE(iface)
#else // ! _XBOX
//@@END_MSINTERNAL
#include <ole2.h>	   // for DECLARE_INTERFACE_ and HRESULT
//@@BEGIN_MSINTERNAL
#endif // ! _XBOX
//@@END_MSINTERNAL

#ifdef __cplusplus
extern "C" {
#endif

#include "dplay8.h"


//@@BEGIN_MSINTERNAL
#ifndef _XBOX
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DirectPlay8Address CLSIDs
 *
 ****************************************************************************/

// {934A9523-A3CA-4bc5-ADA0-D6D95D979421}
DEFINE_GUID(CLSID_DirectPlay8Address,
0x934a9523, 0xa3ca, 0x4bc5, 0xad, 0xa0, 0xd6, 0xd9, 0x5d, 0x97, 0x94, 0x21);

//@@BEGIN_MSINTERNAL
#endif // ! _XBOX
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DirectPlay8Address Interface IIDs
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
#ifdef _XBOX


typedef DWORD	DPNAREFIID;

#define IID_IDirectPlay8Address		0x80000001
#define IID_IDirectPlay8AddressIP	0x80000002


#else // ! _XBOX
//@@END_MSINTERNAL


typedef REFIID	DPNAREFIID;

// {83783300-4063-4c8a-9DB3-82830A7FEB31}
DEFINE_GUID(IID_IDirectPlay8Address,
0x83783300, 0x4063, 0x4c8a, 0x9d, 0xb3, 0x82, 0x83, 0xa, 0x7f, 0xeb, 0x31);

// {E5A0E990-2BAD-430b-87DA-A142CF75DE58}
DEFINE_GUID(IID_IDirectPlay8AddressIP,
0xe5a0e990, 0x2bad, 0x430b, 0x87, 0xda, 0xa1, 0x42, 0xcf, 0x75, 0xde, 0x58);


//@@BEGIN_MSINTERNAL
#endif // ! _XBOX
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DirectPlay8Address Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDirectPlay8Address			*PDIRECTPLAY8ADDRESS, *LPDIRECTPLAY8ADDRESS;
typedef struct IDirectPlay8AddressIP		*PDIRECTPLAY8ADDRESSIP, *LPDIRECTPLAY8ADDRESSIP;


/****************************************************************************
 *
 * DirectPlay8Address Forward Declarations For External Types
 *
 ****************************************************************************/

typedef struct sockaddr SOCKADDR;
//@@BEGIN_MSINTERNAL
#ifdef XBOX_ON_DESKTOP
typedef struct _XNADDR	XNADDR;
#endif // XBOX_ON_DESKTOP
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DirectPlay8Address Constants
 *
 ****************************************************************************/
//
// Asynchronous operation flags
//
#define DPNA_DATATYPE_STRING				0x00000001
#define DPNA_DATATYPE_DWORD					0x00000002
#define DPNA_DATATYPE_GUID					0x00000003
#define DPNA_DATATYPE_BINARY				0x00000004
#define DPNA_DATATYPE_STRING_ANSI           0x00000005

#define DPNA_DPNSVR_PORT					6073

#define DPNA_INDEX_INVALID					0xFFFFFFFF

/****************************************************************************
 *
 * DirectPlay8Address Address Elements
 *
 ****************************************************************************/

#define DPNA_SEPARATOR_KEYVALUE				L'='
#define DPNA_SEPARATOR_USERDATA				L'#'
#define DPNA_SEPARATOR_COMPONENT			L';'
#define DPNA_ESCAPECHAR						L'%'

// Header
#define DPNA_HEADER		                    L"x-directplay:/"

// key names for address components
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOLOBBY
//@@END_MSINTERNAL
#define DPNA_KEY_APPLICATION_INSTANCE		L"applicationinstance"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOLOBBY
#ifndef DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
#define DPNA_KEY_DEVICE						L"device"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
#define DPNA_KEY_HOSTNAME					L"hostname"
#define DPNA_KEY_PORT						L"port"
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONEPROCESSOR
//@@END_MSINTERNAL
#define DPNA_KEY_PROCESSOR					L"processor"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifndef DPNBUILD_NOLOBBY
//@@END_MSINTERNAL
#define DPNA_KEY_PROGRAM					L"program"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOLOBBY
//@@END_MSINTERNAL
#define DPNA_KEY_PROVIDER					L"provider"
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
#define DPNA_KEY_SCOPE						L"scope"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOMULTICAST
#ifndef DPNBUILD_NONATHELP
//@@END_MSINTERNAL
#define DPNA_KEY_TRAVERSALMODE			L"traversalmode"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NONATHELP
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERIALSP
//@@END_MSINTERNAL
#define DPNA_KEY_BAUD						L"baud"
#define DPNA_KEY_FLOWCONTROL				L"flowcontrol"
#define DPNA_KEY_PARITY						L"parity"
#define DPNA_KEY_PHONENUMBER				L"phonenumber"
#define DPNA_KEY_STOPBITS					L"stopbits"

// values for baud rate
#define DPNA_BAUD_RATE_9600					9600
#define DPNA_BAUD_RATE_14400				14400
#define DPNA_BAUD_RATE_19200				19200
#define DPNA_BAUD_RATE_38400				38400
#define DPNA_BAUD_RATE_56000				56000
#define DPNA_BAUD_RATE_57600				57600
#define DPNA_BAUD_RATE_115200				115200

// values for stop bits
#define DPNA_STOP_BITS_ONE					L"1"
#define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
#define DPNA_STOP_BITS_TWO					L"2"

// values for parity
#define DPNA_PARITY_NONE					L"NONE"
#define DPNA_PARITY_EVEN					L"EVEN"
#define DPNA_PARITY_ODD						L"ODD"
#define DPNA_PARITY_MARK					L"MARK"
#define DPNA_PARITY_SPACE					L"SPACE"

// values for flow control
#define DPNA_FLOW_CONTROL_NONE				L"NONE"
#define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
#define DPNA_FLOW_CONTROL_RTS				L"RTS"
#define DPNA_FLOW_CONTROL_DTR				L"DTR"
#define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERIALSP

#ifndef DPNBUILD_NONATHELP
//@@END_MSINTERNAL
// values for traversal mode
#define DPNA_TRAVERSALMODE_NONE					0
#define DPNA_TRAVERSALMODE_PORTREQUIRED			1
#define DPNA_TRAVERSALMODE_PORTRECOMMENDED	2
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NONATHELP
//@@END_MSINTERNAL



//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
// Shortcut values
//
// These can be used instead of the corresponding CLSID_DP8SP_XXXX guids
//
#define DPNA_VALUE_TCPIPPROVIDER            L"IP"
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOIPX
//@@END_MSINTERNAL
#define DPNA_VALUE_IPXPROVIDER              L"IPX"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOIPX
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERIALSP
//@@END_MSINTERNAL
#define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
#define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERIALSP
#endif // ! DPNBUILD_ONLYONESP
//@@END_MSINTERNAL


//// ANSI DEFINITIONS

// Header
#define DPNA_HEADER_A						"x-directplay:/"
#define DPNA_SEPARATOR_KEYVALUE_A			'='
#define DPNA_SEPARATOR_USERDATA_A			'#'
#define DPNA_SEPARATOR_COMPONENT_A			';'
#define DPNA_ESCAPECHAR_A					'%'

// key names for address components
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOLOBBY
//@@END_MSINTERNAL
#define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOLOBBY
#ifndef DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
#define DPNA_KEY_DEVICE_A					"device"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
#define DPNA_KEY_HOSTNAME_A					"hostname"
#define DPNA_KEY_PORT_A						"port"
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONEPROCESSOR
//@@END_MSINTERNAL
#define DPNA_KEY_PROCESSOR_A				"processor"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifndef DPNBUILD_NOLOBBY
//@@END_MSINTERNAL
#define DPNA_KEY_PROGRAM_A					"program"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOLOBBY
//@@END_MSINTERNAL
#define DPNA_KEY_PROVIDER_A					"provider"
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
#define DPNA_KEY_SCOPE_A					"scope"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOMULTICAST
#ifndef DPNBUILD_NONATHELP
//@@END_MSINTERNAL
#define DPNA_KEY_TRAVERSALMODE_A			"traversalmode"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NONATHELP
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERIALSP
//@@END_MSINTERNAL
#define DPNA_KEY_BAUD_A						"baud"
#define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
#define DPNA_KEY_PARITY_A					"parity"
#define DPNA_KEY_PHONENUMBER_A				"phonenumber"
#define DPNA_KEY_STOPBITS_A					"stopbits"

// values for stop bits
#define DPNA_STOP_BITS_ONE_A				"1"
#define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
#define DPNA_STOP_BITS_TWO_A				"2"

// values for parity
#define DPNA_PARITY_NONE_A					"NONE"
#define DPNA_PARITY_EVEN_A					"EVEN"
#define DPNA_PARITY_ODD_A					"ODD"
#define DPNA_PARITY_MARK_A					"MARK"
#define DPNA_PARITY_SPACE_A					"SPACE"

// values for flow control
#define DPNA_FLOW_CONTROL_NONE_A			"NONE"
#define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
#define DPNA_FLOW_CONTROL_RTS_A				"RTS"
#define DPNA_FLOW_CONTROL_DTR_A				"DTR"
#define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERIALSP
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
// Shortcut values
//
// These can be used instead of the corresponding CLSID_DP8SP_XXXX guids
//
#define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOIPX
//@@END_MSINTERNAL
#define DPNA_VALUE_IPXPROVIDER_A            "IPX"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOIPX
//@@END_MSINTERNAL
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERIALSP
//@@END_MSINTERNAL
#define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
#define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERIALSP
#endif // ! DPNBUILD_ONLYONESP
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DirectPlay8Address Functions
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
#ifdef _XBOX

extern HRESULT WINAPI XDirectPlay8AddressCreate( DPNAREFIID riid, void **ppvInterface );

extern HRESULT WINAPI XDirectPlay8AddressCreateFromXnAddr( XNADDR *pxnaddr, IDirectPlay8Address **ppInterface );

#else // ! _XBOX
//@@END_MSINTERNAL

/*
 * 
 * This function is no longer supported.  It is recommended that CoCreateInstance be used to create 
 * DirectPlay8 address objects. 
 *
 * HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
 *
 */

//@@BEGIN_MSINTERNAL
#endif // ! _XBOX
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DirectPlay8Address Application Interfaces
 *
 ****************************************************************************/

//
// COM definition for IDirectPlay8Address Generic Interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Address
DECLARE_INTERFACE_(IDirectPlay8Address,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ DPNAREFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;

	/*** IDirectPlay8Address methods ***/
	STDMETHOD(BuildFromURLW)(THIS_ WCHAR *pwszSourceURL ) PURE;
	STDMETHOD(BuildFromURLA)(THIS_ CHAR *pszSourceURL ) PURE;
	STDMETHOD(Duplicate)(THIS_ PDIRECTPLAY8ADDRESS *ppdpaNewAddress ) PURE;
	STDMETHOD(SetEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
	STDMETHOD(IsEqual)(THIS_ PDIRECTPLAY8ADDRESS pdpaAddress ) PURE;
	STDMETHOD(Clear)(THIS ) PURE;
	STDMETHOD(GetURLW)(THIS_ WCHAR *pwszURL, PDWORD pdwNumChars ) PURE;
	STDMETHOD(GetURLA)(THIS_ CHAR *pszURL, PDWORD pdwNumChars) PURE;
	STDMETHOD(GetSP)(THIS_ GUID *pguidSP ) PURE;
	STDMETHOD(GetUserData)(THIS_ void *pvUserData, PDWORD pdwBufferSize) PURE;
	STDMETHOD(SetSP)(THIS_ const GUID * const pguidSP ) PURE;
	STDMETHOD(SetUserData)(THIS_ const void * const pvUserData, const DWORD dwDataSize) PURE;
	STDMETHOD(GetNumComponents)(THIS_ PDWORD pdwNumComponents ) PURE;
	STDMETHOD(GetComponentByName)(THIS_ const WCHAR * const pwszName, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType ) PURE;
	STDMETHOD(GetComponentByIndex)(THIS_ const DWORD dwComponentID, WCHAR * pwszName, PDWORD pdwNameLen, void *pvBuffer, PDWORD pdwBufferSize, PDWORD pdwDataType ) PURE;
	STDMETHOD(AddComponent)(THIS_ const WCHAR * const pwszName, const void * const lpvData, const DWORD dwDataSize, const DWORD dwDataType ) PURE;	
	STDMETHOD(GetDevice)(THIS_  GUID * ) PURE;
	STDMETHOD(SetDevice)(THIS_  const GUID * const) PURE;
	STDMETHOD(BuildFromDPADDRESS)( THIS_ LPVOID pvAddress, DWORD dwDataSize ) PURE;
};

//
// COM definition for IDirectPlay8AddressIP Generic Interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8AddressIP
DECLARE_INTERFACE_(IDirectPlay8AddressIP,IUnknown)
{
    /*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ DPNAREFIID, PVOID *) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;

	/*** IDirectPlay8AddressIP methods ***/

	// Constructs a IDirectPlay8 TCP Address from a SOCKADDR structure
	STDMETHOD(BuildFromSockAddr)(THIS_ const SOCKADDR * const ) PURE;

	// Constructs a TCP Address from a string (hostname) and port
	STDMETHOD(BuildAddress)(THIS_ const WCHAR * const wszAddress, const USHORT usPort ) PURE;

	// Builds a local TCP Address
	STDMETHOD(BuildLocalAddress)(THIS_ const GUID * const pguidAdapter, const USHORT usPort ) PURE;

	// Gets the address from the structure in SOCKADR format
	STDMETHOD(GetSockAddress)(THIS_ SOCKADDR *, PDWORD ) PURE;

	// Gets the local afddress
	STDMETHOD(GetLocalAddress)(THIS_ GUID *pguidAdapter, USHORT *pusPort ) PURE;

	// Gets the remote address
	STDMETHOD(GetAddress)(THIS_ WCHAR *wszAddress, PDWORD pdwAddressLength, USHORT *psPort ) PURE;
};


/****************************************************************************
 *
 * IDirectPlay8 application interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay8Address_QueryInterface(p,a,b)				(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8Address_AddRef(p)							(p)->lpVtbl->AddRef(p)
#define IDirectPlay8Address_Release(p)							(p)->lpVtbl->Release(p)
#define IDirectPlay8Address_BuildFromURLW(p,a)					(p)->lpVtbl->BuildFromURLW(p,a)
#define IDirectPlay8Address_BuildFromURLA(p,a)					(p)->lpVtbl->BuildFromURLA(p,a)
#define IDirectPlay8Address_Duplicate(p,a)						(p)->lpVtbl->Duplicate(p,a)
#define IDirectPlay8Address_SetEqual(p,a)						(p)->lpVtbl->SetEqual(p,a)
#define IDirectPlay8Address_IsEqual(p,a)						(p)->lpVtbl->IsEqual(p,a)
#define IDirectPlay8Address_Clear(p)							(p)->lpVtbl->Clear(p)
#define IDirectPlay8Address_GetURLW(p,a,b)						(p)->lpVtbl->GetURLW(p,a,b)
#define IDirectPlay8Address_GetURLA(p,a,b)						(p)->lpVtbl->GetURLA(p,a,b)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
#define IDirectPlay8Address_GetSP(p,a)							(p)->lpVtbl->GetSP(p,a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
#define IDirectPlay8Address_GetUserData(p,a,b)					(p)->lpVtbl->GetUserData(p,a,b)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
#define IDirectPlay8Address_SetSP(p,a)							(p)->lpVtbl->SetSP(p,a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
#define IDirectPlay8Address_SetUserData(p,a,b)					(p)->lpVtbl->SetUserData(p,a,b)
#define IDirectPlay8Address_GetNumComponents(p,a)				(p)->lpVtbl->GetNumComponents(p,a)
#define IDirectPlay8Address_GetComponentByName(p,a,b,c,d)		(p)->lpVtbl->GetComponentByName(p,a,b,c,d)
#define IDirectPlay8Address_GetComponentByIndex(p,a,b,c,d,e,f)	(p)->lpVtbl->GetComponentByIndex(p,a,b,c,d,e,f)
#define IDirectPlay8Address_AddComponent(p,a,b,c,d)				(p)->lpVtbl->AddComponent(p,a,b,c,d)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
#define IDirectPlay8Address_SetDevice(p,a)						(p)->lpVtbl->SetDevice(p,a)
#define IDirectPlay8Address_GetDevice(p,a)						(p)->lpVtbl->GetDevice(p,a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NOLEGACYDP
//@@END_MSINTERNAL
#define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)	(p)->lpVtbl->BuildFromDirectPlay4Address(p,a,b)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOLEGACYDP
//@@END_MSINTERNAL

#define IDirectPlay8AddressIP_QueryInterface(p,a,b)				(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8AddressIP_AddRef(p)							(p)->lpVtbl->AddRef(p)
#define IDirectPlay8AddressIP_Release(p)						(p)->lpVtbl->Release(p)
#define IDirectPlay8AddressIP_BuildFromSockAddr(p,a)			(p)->lpVtbl->BuildFromSockAddr(p,a)
#define IDirectPlay8AddressIP_BuildAddress(p,a,b)				(p)->lpVtbl->BuildAddress(p,a,b)
#define IDirectPlay8AddressIP_BuildLocalAddress(p,a,b)			(p)->lpVtbl->BuildLocalAddress(p,a,b)
#define IDirectPlay8AddressIP_GetSockAddress(p,a,b)				(p)->lpVtbl->GetSockAddress(p,a,b)
#define IDirectPlay8AddressIP_GetLocalAddress(p,a,b)			(p)->lpVtbl->GetLocalAddress(p,a,b)
#define IDirectPlay8AddressIP_GetAddress(p,a,b,c)				(p)->lpVtbl->GetAddress(p,a,b,c)

#else /* C++ */

#define IDirectPlay8Address_QueryInterface(p,a,b)				(p)->QueryInterface(a,b)
#define IDirectPlay8Address_AddRef(p)							(p)->AddRef()
#define IDirectPlay8Address_Release(p)							(p)->Release()
#define IDirectPlay8Address_BuildFromURLW(p,a)					(p)->BuildFromURLW(a)
#define IDirectPlay8Address_BuildFromURLA(p,a)					(p)->BuildFromURLA(a)
#define IDirectPlay8Address_Duplicate(p,a)						(p)->Duplicate(a)
#define IDirectPlay8Address_SetEqual(p,a)						(p)->SetEqual(a)
#define IDirectPlay8Address_IsEqual(p,a)						(p)->IsEqual(a)
#define IDirectPlay8Address_Clear(p)							(p)->Clear()
#define IDirectPlay8Address_GetURLW(p,a,b)						(p)->GetURLW(a,b)
#define IDirectPlay8Address_GetURLA(p,a,b)						(p)->GetURLA(a,b)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
#define IDirectPlay8Address_GetSP(p,a)							(p)->GetSP(a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
#define IDirectPlay8Address_GetUserData(p,a,b)					(p)->GetUserData(a,b)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
#define IDirectPlay8Address_SetSP(p,a)							(p)->SetSP(a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONESP
//@@END_MSINTERNAL
#define IDirectPlay8Address_SetUserData(p,a,b)					(p)->SetUserData(a,b)
#define IDirectPlay8Address_GetNumComponents(p,a)				(p)->GetNumComponents(a)
#define IDirectPlay8Address_GetComponentByName(p,a,b,c,d)		(p)->GetComponentByName(a,b,c,d)
#define IDirectPlay8Address_GetComponentByIndex(p,a,b,c,d,e,f)	(p)->GetComponentByIndex(a,b,c,d,e,f)
#define IDirectPlay8Address_AddComponent(p,a,b,c,d)				(p)->AddComponent(a,b,c,d)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
#define IDirectPlay8Address_SetDevice(p,a)						(p)->SetDevice(a)
#define IDirectPlay8Address_GetDevice(p,a)						(p)->GetDevice(a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NOLEGACYDP
//@@END_MSINTERNAL
#define IDirectPlay8Address_BuildFromDirectPlay4Address(p,a,b)	(p)->BuildFromDirectPlay4Address(a,b)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOLEGACYDP
//@@END_MSINTERNAL

#define IDirectPlay8AddressIP_QueryInterface(p,a,b)				(p)->QueryInterface(a,b)
#define IDirectPlay8AddressIP_AddRef(p)							(p)->AddRef()
#define IDirectPlay8AddressIP_Release(p)						(p)->Release()
#define IDirectPlay8AddressIP_BuildFromSockAddr(p,a)			(p)->BuildFromSockAddr(a)
#define IDirectPlay8AddressIP_BuildAddress(p,a,b)				(p)->BuildAddress(a,b)
#define IDirectPlay8AddressIP_BuildLocalAddress(p,a,b)			(p)->BuildLocalAddress(a,b)
#define IDirectPlay8AddressIP_GetSockAddress(p,a,b)				(p)->GetSockAddress(a,b)
#define IDirectPlay8AddressIP_GetLocalAddress(p,a,b)			(p)->GetLocalAddress(a,b)
#define IDirectPlay8AddressIP_GetAddress(p,a,b,c)				(p)->GetAddress(a,b,c)

#endif


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\inc\dplay8.h ===
/*==========================================================================
 *
 *	Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *	File:		DPlay8.h
 *	Content:	DirectPlay8 include file
//@@BEGIN_MSINTERNAL
 *	History:
 *	Date		By		Reason
 *	==========================
 *	10/12/98	jwo		created
 *	11/06/98	ejs		removed BUFFERELEMENT, reversed fields in BUFFERDESC, defined new ERRORs
 *	11/10/98	ejs		started adding upper-edge COM interface for DirectPlay8
 *	07/20/99	mjn		added interface GUIDs for DirectPlay8 peer,client and server
 *	07/29/99	mjn		changed DPNID typedef from HANDLE to DWORD
 *	08/09/99	mjn		added DPN_SERVICE_PROVIDER_INFO structure for SP and adapter enumeration
 *	12/03/99	jtk		Replaced IID_IDirectPlay8 with the Client, Server, and Peer interfaces
 *	01/08/00	mjn		Added DPNERR's and fixed DPN_APPLICATION_DESC
 *	01/09/00	mjn		Added dwSize to DPN_APPLICATION_DESC
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/16/00	mjn		New DPlay8 MessageHandler and associated structures
 *	01/18/00	mjn		Added DPNGROUP_AUTODESTRUCT flag
 *	01/22/00	mjn		Added ability for Host to destroy a player
 *	01/24/00	mjn		Reordered error codes and DPN_MSGID's
 *	01/24/00	mjn		Added DPNERR_NOHOSTPLAYER error
 *	01/27/00	vpo		Removed all remaing traces of LP pointers.
 *	01/28/00	mjn		Implemented ReturnBuffer in API and DPN_MSGID_CONNECTION_TERMINATED
 *	02/01/00	mjn		Added GetCaps and SetCaps to APIs and player context values to messages
 *	02/13/00	jtk		Renamed to DPlay8.h
 *	02/15/00	mjn		Added INFO flags and MS_INTERNAL stuff
 *	02/17/00	rmt		Added additional error codes for address library
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *	02/17/00	mjn		Reordered parameters in EnumServiceProviders,EnumHosts,Connect,Host
 *	03/17/00	rmt		Added Get/SetSPCaps, GetConnectionInfo and supporting structures
 *				rmt		Updated Caps structure.
 *				rmt		Updated Security structures to add dwSize member
 *	03/22/00	mjn		changed dpid's to dpnid's
 *				mjn		removed DPNGROUP_ALLPLAYERS and added DPNID_ALL_PLAYERS_GROUP
 *				mjn		added dwPriority to Send and SendTo
 *				mjn		removed pDpnid from CreateGroup
 *				mjn		replaced HANDLE with DPNHANDLE
 *				mjn		Added dpnid to GetSendQueueInfo for Server and Peer interfaces
 *				mjn		Changed RegisterMessageHandler to Initialize
 *	03/23/00	mjn		Added pvGroupContext to CreateGroup
 *				mjn		Added pvPlayerContext to Host and Connect
 *				mjn		Added RegisterLobby API Call
 *	03/24/00	rmt		Added IsEqual function return codes
 *				mjn		Added pvPlayerContext to INDICATE_CONNECT and renamed pvUserContext to pvReplyContext
 *	03/25/00	rmt		Added new fields to caps
 *	04/04/00	rmt		Added new flag to enable/disable param validation on Initialize call
 *				rmt		Added new flag to enable/disable DPNSVR functionality in session.
 *	04/04/00	mjn		Added DPNERR_INVALIDVERSION
 *	04/05/00	mjn		Added TerminateSession() API Call
 *	04/04/00	aarono	made security structures internal, since not yet supported
 *	04/05/00	mjn		Modified DPNMSG_HOST_DESTROY_PLAYER structure
 *				mjn		Modified DestroyClient to take void* instead of BYTE* for data
 *				mjn		Added typedefs for security structures
 *	04/06/00	mjn		Added Address to INDICATE_CONNECT message
 *				mjn		Added GetClientAddress, GetServerAddress, GetPeerAddress to API
 *				mjn		Added GetHostAddress to API
 *	04/17/00	mjn		Removed DPNPLAYER_SERVER
 *				mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC in API
 *	04/18/00	mjn		Added ResponseData to DPNMSG_ENUM_HOSTS_QUERY
 *				mjn		Added DPN_MSGID_RETURN_BUFFER and DPNMSG_RETURN_BUFFER
 *				mjn		Removed TerminateSession from Server interface.
 *	04/19/00	mjn		SendTo and Send API calls accept a range of DPN_BUFFER_DESCs and a count
 *				mjn		Removed DPN_BUFFER_DESC from DPNMSG_ENUM_HOSTS_QUERY and DPNMSG_ENUM_HOSTS_RESPONSE structs
 *				mjn		Removed hAsyncOp (unused) from DPNMSG_INDICATE_CONNECT
 *	05/02/00	mjn		Removed DPN_ACCEPTED and DPN_REJECTED #define's
 *	05/03/00	mjn		Added DPNENUMSERVICEPROVIDERS_ALL flag
 *	05/04/00	rmt		Bug #34156 - No PDPNID or PDPNHANDLE defined
 *	05/31/00	mjn		Added SYNC flags for EACH API call which supports synchronous operation
 *	06/05/00	mjn		Added short-cut interface macros and converted errors to HEX
 *	06/09/00	rmt		Updates to split CLSID and allow whistler compat and support external create funcs
 *	06/12/00	mjn		MSINTERNAL'd out DPNSEND_ENCRYPTED,DPNSEND_SIGNED,DPNGROUP_MULTICAST and DPNENUM_GROUP_MULTICAST flags
 *	06/15/00	rmt		Bug #36380 - Removing old CLSID
 *	06/23/00	mjn		Added DPNSEND_PRIORITY_HIGH and DPNSEND_PRIORITY_LOW flags
 *				mjn		Removed dwPriority from Send() and SendTo() API calls
 *	06/26/00	mjn		Added dwReason to DPNMSG_DESTROY_PLAYER and DPNMSG_DESTROY_GROUP structures and added reason constants
 *				mjn		MAJOR API/FLAGS/CONSTANTS/STRUCTURES RENAME
 *	06/27/00	mjn		Added DPNGETSENDQUEUEINFO_PRIORITY_HIGH and DPNGETSENDQUEUEINFO_PRIORITY_LOW flags
 *				mjn		Dropped pvPlayerContext from IDirectPlay8Client::Connect()
 *				mjn		Added DPNENUMHOSTS_DONTSENDADDRESS,DPNSEND_NONSEQUENTIAL and DPNGETSENDQUEUEINFO_PRIORITY_NORMAL flags
 *				mjn		Renumbered SEND flags
 *	07/09/00	rmt		Bug #38323 When registering lobby object w/DP8 object must be able to specify connection to update
 *	07/29/00	mjn		Added DPN_MSGID_INDICATED_CONNECT_ABORTED and DPNMSG_INDICATED_CONNECT_ABORTED structure
 *				mjn		Added pvTerminateData and dwTerminateDataSize to DPNMSG_CONNECTION_TERMINATED structure
 *				mjn		Added hResultCode to DPNMSG_RETURN_BUFFER structure
 *				mjn		Added hResultCode to DPNMSG_TERMINATE_SESSION structure
 *				mjn		Added dwMaxResponseDataSize to DPNMSG_ENUM_HOSTS_QUERY structure
 *				mjn		Changed dwRetryCount to dwEnumCount in EnumHosts API call (no impact - just name change)
 *				mjn		Added DPNERR_ENUMQUERYTOOLARGE,DPNERR_ENUMRESPONSETOOLARGE,DPNERR_HOSTTERMINATEDSESSION
 *				mjn		Reordered DPN_MSGID's alphabetically
 *	07/30/00	mjn		Added pAddressDevice to DPNMSG_INDICATE_CONNECT
 *	07/31/00	mjn		Added DPNDESTROYPLAYERREASON_SESSIONTERMINATED,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER,DPNDESTROYGROUPREASON_SESSIONTERMINATED
 *				mjn		Added DPNERR_PLAYERNOTREACHABLE
 *				mjn		Renamed pAddress to pAddressPlayer in DPNMSG_INDICATE_CONNECT
 *				mjn		Renamed DPN_MSGID_ASYNC_OPERATION_COMPLETE to DPN_MSGID_ASYNC_OP_COMPLETE
 *				mjn		Renamed dwDefaultEnumRetryCount to dwDefaultEnumCount in DPN_SP_CAPS
 *				mjn		Removed DPNENUM_ALL
 *				mjn		Removed DPN_MSGID_HOST_DESTROY_PLAYER
 *				mjn		Removed DPN_MSGID_CONNECTION_TERMINATED
 *				mjn		Removed ALL_ADAPTERS_GUID
 * 08/03/2000 	rmt		Bug #41246 - Registering lobby in wrong state returns ambiguous return codes
 *	08/03/00	mjn		Added dwFlags to GetPeerAddress(),GetServerAddress(),GetClientAddress(),GetLocalHostAddresses(),
 *						Close(),ReturnBuffer(),GetPlayerContext(),GetGroupContext(),GetCaps(),GetSPCaps(),GetConnectionInfo()
 *				mjn		Removed DPNMSG_CONNECTION_TERMINATED,DPNMSG_HOST_DESTROY_PLAYER
 *				mjn		Added dwRoundTripTime to DPNMSG_ENUM_HOSTS_RESPONSE
 *				mjn		Changed GUID *pGuid to GUID guid in DPN_SERVICE_PROVIDER_INFO and added pvReserved,dwReserved
 * 08/06/2000	rmt		Bug #41185 - Cleanup dplay8.h header file.
 * 08/08/2000	rmt		Bug #41724 - Users should only have to include one header
 *				rmt		Bug #41705 - DPNERR_PENDING should be defined as STATUS_PENDING
 * 09/26/2000	masonb	Removed Private Protocol Testing interface, placed in core as private header dpprot.h
 * 10/04/2000	mjn		Added DPNERR_DATATOOLARGE
 * 03/17/2001	rmt		WINBUG #342420 - Commented out create functions
 * 03/22/2001	masonb	Added internal connect info structure for performance tuning
 * 10/05/2001	vanceo	Added IDirectPlay8Multicast interface
 * 10/31/2001	vanceo	Added IDirectPlay8ThreadPool interface
 * 07/22/2002	simonpow Added signing flags
//@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DIRECTPLAY8_H__
#define __DIRECTPLAY8_H__

//@@BEGIN_MSINTERNAL
#ifdef _XBOX
#ifdef XBOX_ON_DESKTOP
#include <ole2.h>	   // for DECLARE_INTERFACE_ and HRESULT
#endif // XBOX_ON_DESKTOP
#undef DECLARE_INTERFACE_
#define DECLARE_INTERFACE_(iface, baseiface)	DECLARE_INTERFACE(iface)
#else // ! _XBOX
//@@END_MSINTERNAL
#include <ole2.h>	   // for DECLARE_INTERFACE_ and HRESULT
//@@BEGIN_MSINTERNAL
#endif // ! _XBOX
//@@END_MSINTERNAL

#include "dpaddr.h"

//@@BEGIN_MSINTERNAL
#if defined(WINCE) && !defined(DPNBUILD_WINCE_FINAL)
#define DX_EXPIRE_YEAR			2002
#define DX_EXPIRE_MONTH			3 /* Jan=1, Feb=2, etc .. */
#define DX_EXPIRE_DAY			1
#define DX_EXPIRE_TEXT			TEXT("This pre-release version of DirectPlay has expired, please upgrade to the latest version.")
#endif // WINCE && !DPNBUILD_WINCE_FINAL
//@@END_MSINTERNAL

#ifdef __cplusplus
extern "C" {
#endif





//@@BEGIN_MSINTERNAL
#ifndef _XBOX
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DirectPlay8 CLSIDs
 *
 ****************************************************************************/

// {743F1DC6-5ABA-429f-8BDF-C54D03253DC2}
DEFINE_GUID(CLSID_DirectPlay8Client,
0x743f1dc6, 0x5aba, 0x429f, 0x8b, 0xdf, 0xc5, 0x4d, 0x3, 0x25, 0x3d, 0xc2);

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERVER
//@@END_MSINTERNAL
// {DA825E1B-6830-43d7-835D-0B5AD82956A2}
DEFINE_GUID(CLSID_DirectPlay8Server,
0xda825e1b, 0x6830, 0x43d7, 0x83, 0x5d, 0xb, 0x5a, 0xd8, 0x29, 0x56, 0xa2);
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERVER
//@@END_MSINTERNAL

// {286F484D-375E-4458-A272-B138E2F80A6A}
DEFINE_GUID(CLSID_DirectPlay8Peer,
0x286f484d, 0x375e, 0x4458, 0xa2, 0x72, 0xb1, 0x38, 0xe2, 0xf8, 0xa, 0x6a);


//@@BEGIN_MSINTERNAL
// CLSIDs added for DirectX 9

#ifndef DPNBUILD_NOMULTICAST
// {C1B3D036-A5E9-43ee-8F46-69D57669D003}
DEFINE_GUID(CLSID_DirectPlay8Multicast, 
0xc1b3d036, 0xa5e9, 0x43ee, 0x8f, 0x46, 0x69, 0xd5, 0x76, 0x69, 0xd0, 0x3);
#endif // ! DPNBUILD_NOMULTICAST

// {FC47060E-6153-4b34-B975-8E4121EB7F3C}
DEFINE_GUID(CLSID_DirectPlay8ThreadPool, 
0xfc47060e, 0x6153, 0x4b34, 0xb9, 0x75, 0x8e, 0x41, 0x21, 0xeb, 0x7f, 0x3c);


#endif // ! _XBOX
//@@END_MSINTERNAL




/****************************************************************************
 *
 * DirectPlay8 Interface IIDs
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
#ifdef _XBOX

typedef DWORD	DP8REFIID;

#define IID_IDirectPlay8Client			0x00000001
#ifndef DPNBUILD_NOSERVER
#define IID_IDirectPlay8Server			0x00000002
#endif // ! DPNBUILD_NOSERVER
#define IID_IDirectPlay8Peer			0x00000003
#ifndef DPNBUILD_NOMULTICAST
#define IID_IDirectPlay8Multicast		0x00000004	// Xbox does not support multicast
#endif // ! DPNBUILD_NOMULTICAST
#define IID_IDirectPlay8ThreadPool		0x00000005	// Xbox does not support thread pool
#define IID_IDirectPlay8ThreadPoolWork	0x00000006


#else // ! _XBOX


//@@END_MSINTERNAL
typedef REFIID	DP8REFIID;


// {5102DACD-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Client,
0x5102dacd, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERVER
//@@END_MSINTERNAL
// {5102DACE-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Server,
0x5102dace, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERVER
//@@END_MSINTERNAL

// {5102DACF-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Peer,
0x5102dacf, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);


//@@BEGIN_MSINTERNAL
// IIDs added for DirectX 9

#ifndef DPNBUILD_NOMULTICAST
// {5102DAD0-241B-11d3-AEA7-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Multicast,
0x5102dad0, 0x241b, 0x11d3, 0xae, 0xa7, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
#endif // ! DPNBUILD_NOMULTICAST

// {0D22EE73-4A46-4a0d-89B2-045B4D666425}
DEFINE_GUID(IID_IDirectPlay8ThreadPool, 
0xd22ee73, 0x4a46, 0x4a0d, 0x89, 0xb2, 0x4, 0x5b, 0x4d, 0x66, 0x64, 0x25);

// {0D22EE74-4A46-4a0d-89B2-045B4D666425}
DEFINE_GUID(IID_IDirectPlay8ThreadPoolWork, 
0xd22ee74, 0x4a46, 0x4a0d, 0x89, 0xb2, 0x4, 0x5b, 0x4d, 0x66, 0x64, 0x25);
//@@END_MSINTERNAL



/****************************************************************************
 *
 * DirectPlay8 Service Provider GUIDs
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOIPX
//@@END_MSINTERNAL

// {53934290-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_IPX,
0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOIPX
#ifndef DPNBUILD_NOSERIALSP
//@@END_MSINTERNAL

// {6D4A3650-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_MODEM,
0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);


// {743B5D60-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_SERIAL,
0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERIALSP
//@@END_MSINTERNAL

// {EBFE7BA0-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(CLSID_DP8SP_TCPIP,
0xebfe7ba0, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);


//@@BEGIN_MSINTERNAL
// Service providers added for DirectX 9

#ifndef DPNBUILD_NOBLUETOOTHSP

// {995513AF-3027-4b9a-956E-C772B3F78006}
DEFINE_GUID(CLSID_DP8SP_BLUETOOTH, 
0x995513af, 0x3027, 0x4b9a, 0x95, 0x6e, 0xc7, 0x72, 0xb3, 0xf7, 0x80, 0x6);

#endif // !DPNBUILD_NOBLUETOOTHSP 


#ifndef DPNBUILD_NOMULTICAST

/****************************************************************************
 *
 * DirectPlay8 Pre-defined Multicast Scope GUIDs
 *
 ****************************************************************************/

// {83539631-B559-4815-8E4E-39CE60EBF27A}
DEFINE_GUID(GUID_DP8MULTICASTSCOPE_PRIVATE,
0x83539631, 0xb559, 0x4815, 0x8e, 0x4e, 0x39, 0xce, 0x60, 0xeb, 0xf2, 0x7a);

// {83539632-B559-4815-8E4E-39CE60EBF27A}
DEFINE_GUID(GUID_DP8MULTICASTSCOPE_LOCAL,
0x83539632, 0xb559, 0x4815, 0x8e, 0x4e, 0x39, 0xce, 0x60, 0xeb, 0xf2, 0x7a);

// {83539633-B559-4815-8E4E-39CE60EBF27A}
DEFINE_GUID(GUID_DP8MULTICASTSCOPE_GLOBAL,
0x83539633, 0xb559, 0x4815, 0x8e, 0x4e, 0x39, 0xce, 0x60, 0xeb, 0xf2, 0x7a);

#endif // ! DPNBUILD_NOMULTICAST


#endif // ! _XBOX
//@@END_MSINTERNAL




/****************************************************************************
 *
 * DirectPlay8 Interface Pointer definitions
 *
 ****************************************************************************/

typedef	struct IDirectPlay8Client			*PDIRECTPLAY8CLIENT;

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERVER
//@@END_MSINTERNAL
typedef	struct IDirectPlay8Server			*PDIRECTPLAY8SERVER;
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERVER
//@@END_MSINTERNAL

typedef	struct IDirectPlay8Peer				*PDIRECTPLAY8PEER;

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
typedef	struct IDirectPlay8Multicast		*PDIRECTPLAY8MULTICAST;
#endif // ! DPNBUILD_NOMULTICAST

typedef	struct IDirectPlay8ThreadPool		*PDIRECTPLAY8THREADPOOL;

typedef	struct IDirectPlay8ThreadPoolWork	*PDIRECTPLAY8THREADPOOLWORK;
//@@END_MSINTERNAL




/****************************************************************************
 *
 * DirectPlay8 Forward Declarations For External Types
 *
 ****************************************************************************/

typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
typedef struct IDirectPlay8Address				IDirectPlay8Address;
//@@BEGIN_MSINTERNAL
#ifdef XBOX_ON_DESKTOP
typedef struct _XNKID	XNKID;
typedef struct _XNKEY	XNKEY;
#endif // XBOX_ON_DESKTOP
//@@END_MSINTERNAL



/****************************************************************************
 *
 * DirectPlay8 Callback Functions
 *
 ****************************************************************************/

//
// Callback Function Type Definition
//
typedef HRESULT (WINAPI *PFNDPNMESSAGEHANDLER)(PVOID,DWORD,PVOID);
//@@BEGIN_MSINTERNAL
typedef void (WINAPI *PFNDPTNWORKCALLBACK)(void * const pvContext, void * const pvTimerData, const UINT uiTimerUnique);
//@@END_MSINTERNAL



/****************************************************************************
 *
 * DirectPlay8 Datatypes (Non-Structure / Non-Message)
 *
 ****************************************************************************/

//
// Player IDs.  Used to uniquely identify a player in a session
//
typedef DWORD	DPNID,		*PDPNID;

//
// Used as identifiers for operations
//
typedef	DWORD	DPNHANDLE,	*PDPNHANDLE;




/****************************************************************************
 *
 * DirectPlay8 Message Identifiers
 *
 ****************************************************************************/

#define DPN_MSGID_OFFSET					0xFFFF0000
#define DPN_MSGID_ADD_PLAYER_TO_GROUP		( DPN_MSGID_OFFSET | 0x0001 )
#define DPN_MSGID_APPLICATION_DESC			( DPN_MSGID_OFFSET | 0x0002 )
#define DPN_MSGID_ASYNC_OP_COMPLETE			( DPN_MSGID_OFFSET | 0x0003 )
#define DPN_MSGID_CLIENT_INFO				( DPN_MSGID_OFFSET | 0x0004 )
#define DPN_MSGID_CONNECT_COMPLETE			( DPN_MSGID_OFFSET | 0x0005 )
#define DPN_MSGID_CREATE_GROUP				( DPN_MSGID_OFFSET | 0x0006 )
#define DPN_MSGID_CREATE_PLAYER				( DPN_MSGID_OFFSET | 0x0007 )
#define DPN_MSGID_DESTROY_GROUP				( DPN_MSGID_OFFSET | 0x0008 )
#define DPN_MSGID_DESTROY_PLAYER			( DPN_MSGID_OFFSET | 0x0009 )
#define DPN_MSGID_ENUM_HOSTS_QUERY			( DPN_MSGID_OFFSET | 0x000a )
#define DPN_MSGID_ENUM_HOSTS_RESPONSE		( DPN_MSGID_OFFSET | 0x000b )
#define DPN_MSGID_GROUP_INFO				( DPN_MSGID_OFFSET | 0x000c )
#define DPN_MSGID_HOST_MIGRATE				( DPN_MSGID_OFFSET | 0x000d )
#define DPN_MSGID_INDICATE_CONNECT			( DPN_MSGID_OFFSET | 0x000e )
#define DPN_MSGID_INDICATED_CONNECT_ABORTED	( DPN_MSGID_OFFSET | 0x000f )
#define DPN_MSGID_PEER_INFO					( DPN_MSGID_OFFSET | 0x0010 )
#define DPN_MSGID_RECEIVE					( DPN_MSGID_OFFSET | 0x0011 )
#define DPN_MSGID_REMOVE_PLAYER_FROM_GROUP	( DPN_MSGID_OFFSET | 0x0012 )
#define DPN_MSGID_RETURN_BUFFER				( DPN_MSGID_OFFSET | 0x0013 )
#define DPN_MSGID_SEND_COMPLETE				( DPN_MSGID_OFFSET | 0x0014 )
#define DPN_MSGID_SERVER_INFO				( DPN_MSGID_OFFSET | 0x0015 )
#define DPN_MSGID_TERMINATE_SESSION			( DPN_MSGID_OFFSET | 0x0016 )

//@@BEGIN_MSINTERNAL
// Messages added for DirectX 9
#define DPN_MSGID_CREATE_THREAD				( DPN_MSGID_OFFSET | 0x0017 )
#define DPN_MSGID_DESTROY_THREAD			( DPN_MSGID_OFFSET | 0x0018 )
#ifndef DPNBUILD_NOMULTICAST
#define DPN_MSGID_CREATE_SENDER_CONTEXT		( DPN_MSGID_OFFSET | 0x0019 )
#define DPN_MSGID_DESTROY_SENDER_CONTEXT	( DPN_MSGID_OFFSET | 0x001a )
#define DPN_MSGID_JOIN_COMPLETE				( DPN_MSGID_OFFSET | 0x001b )
#define DPN_MSGID_RECEIVE_MULTICAST			( DPN_MSGID_OFFSET | 0x001c )
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL



/****************************************************************************
 *
 * DirectPlay8 Constants
 *
 ****************************************************************************/

#define DPNID_ALL_PLAYERS_GROUP				0

//
// DESTROY_GROUP reasons
//
#define DPNDESTROYGROUPREASON_NORMAL				0x0001
#define DPNDESTROYGROUPREASON_AUTODESTRUCTED		0x0002
#define DPNDESTROYGROUPREASON_SESSIONTERMINATED		0x0003

//
// DESTROY_PLAYER reasons
//
#define DPNDESTROYPLAYERREASON_NORMAL				0x0001
#define DPNDESTROYPLAYERREASON_CONNECTIONLOST		0x0002
#define DPNDESTROYPLAYERREASON_SESSIONTERMINATED	0x0003
#define DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER	0x0004

#define DPN_MAX_APPDESC_RESERVEDDATA_SIZE			64



/****************************************************************************
 *
 * DirectPlay8 Flags
 *
 ****************************************************************************/

//
// Asynchronous operation flags (for Async Ops)
//
#define DPNOP_SYNC								0x80000000

//
// Add player to group flags (for AddPlayerToGroup)
//
#define DPNADDPLAYERTOGROUP_SYNC				DPNOP_SYNC

//
// Cancel flags
//
#define DPNCANCEL_CONNECT						0x00000001
#define DPNCANCEL_ENUM							0x00000002
#define DPNCANCEL_SEND							0x00000004
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
#define DPNCANCEL_JOIN							0x00000008
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
#define DPNCANCEL_ALL_OPERATIONS				0x00008000
//@@BEGIN_MSINTERNAL
// Flags added for DirectX 9
#define DPNCANCEL_PLAYER_SENDS					0x80000000
#define DPNCANCEL_PLAYER_SENDS_PRIORITY_HIGH	0x00010000
#define DPNCANCEL_PLAYER_SENDS_PRIORITY_NORMAL	0x00020000
#define DPNCANCEL_PLAYER_SENDS_PRIORITY_LOW		0x00040000

//
// Close flags (for Close, added for DirectX 9)
//
#define DPNCLOSE_IMMEDIATE						0x00000001
//@@END_MSINTERNAL

//
// Connect flags (for Connect)
//
#define DPNCONNECT_SYNC							DPNOP_SYNC
#define DPNCONNECT_OKTOQUERYFORADDRESSING		0x0001

//
// Create group flags (for CreateGroup)
//
#define DPNCREATEGROUP_SYNC						DPNOP_SYNC

//
// Destroy group flags (for DestroyGroup)
//
#define DPNDESTROYGROUP_SYNC					DPNOP_SYNC

//
// Enumerate clients and groups flags (for EnumPlayersAndGroups)
//
#define DPNENUM_PLAYERS							0x0001
#define DPNENUM_GROUPS							0x0010

//
// Enum hosts flags (for EnumHosts)
//
#define DPNENUMHOSTS_SYNC						DPNOP_SYNC
#define DPNENUMHOSTS_OKTOQUERYFORADDRESSING		0x0001
#define DPNENUMHOSTS_NOBROADCASTFALLBACK		0x0002

//
// Enum service provider flags (for EnumSP)
//
#define DPNENUMSERVICEPROVIDERS_ALL				0x0001

//
// Get send queue info flags (for GetSendQueueInfo)
//
#define DPNGETSENDQUEUEINFO_PRIORITY_NORMAL		0x0001
#define DPNGETSENDQUEUEINFO_PRIORITY_HIGH		0x0002
#define DPNGETSENDQUEUEINFO_PRIORITY_LOW		0x0004

//
// Group information flags (for Group Info)
//
#define DPNGROUP_AUTODESTRUCT					0x0001

//
// Host flags (for Host)
//
#define DPNHOST_OKTOQUERYFORADDRESSING			0x0001

//
// Set info
//
#define DPNINFO_NAME							0x0001
#define DPNINFO_DATA							0x0002

//
// Initialize flags (for Initialize)
//
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOPARAMVAL
//@@END_MSINTERNAL
#define DPNINITIALIZE_DISABLEPARAMVAL			0x0001
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOPARAMVAL
// Flags added for DirectX 9
#define DPNINITIALIZE_HINT_LANSESSION				0x0002
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//
// Join flags (for Join)
//
#define DPNJOIN_SYNC							DPNOP_SYNC
#define DPNJOIN_ALLOWUNKNOWNSENDERS				0x0001
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL

//
// Register Lobby flags
//
#define DPNLOBBY_REGISTER						0x0001
#define DPNLOBBY_UNREGISTER						0x0002

//
// Player information flags (for Player Info / Player Messages)
//
#define DPNPLAYER_LOCAL							0x0002
#define DPNPLAYER_HOST							0x0004

//
// Remove player from group flags (for RemovePlayerFromGroup)
//
#define DPNREMOVEPLAYERFROMGROUP_SYNC			DPNOP_SYNC

//
// Send flags (for Send/SendTo)
//
#define DPNSEND_SYNC							DPNOP_SYNC
#define DPNSEND_NOCOPY							0x0001
#define DPNSEND_NOCOMPLETE						0x0002
#define DPNSEND_COMPLETEONPROCESS				0x0004
#define DPNSEND_GUARANTEED						0x0008
#define DPNSEND_NONSEQUENTIAL					0x0010
#define DPNSEND_NOLOOPBACK						0x0020
#define DPNSEND_PRIORITY_LOW					0x0040
#define DPNSEND_PRIORITY_HIGH					0x0080
//@@BEGIN_MSINTERNAL
// Flag added for DirectX 9
#define DPNSEND_COALESCE						0x0100
//@@END_MSINTERNAL

//
// Session Flags (for DPN_APPLICATION_DESC)
//
#define DPNSESSION_CLIENT_SERVER				0x0001
#define DPNSESSION_MIGRATE_HOST					0x0004
#define DPNSESSION_NODPNSVR						0x0040
#define DPNSESSION_REQUIREPASSWORD				0x0080
//@@BEGIN_MSINTERNAL
// Flag added for DirectX 9
#define DPNSESSION_NOENUMS						0x0100
#define DPNSESSION_FAST_SIGNED					0x0200
#define DPNSESSION_FULL_SIGNED					0x0400
//@@END_MSINTERNAL

//
// Set client info flags (for SetClientInfo)
//
#define DPNSETCLIENTINFO_SYNC					DPNOP_SYNC

//
// Set group info flags (for SetGroupInfo)
//
#define DPNSETGROUPINFO_SYNC					DPNOP_SYNC

//
// Set peer info flags (for SetPeerInfo)
//
#define DPNSETPEERINFO_SYNC						DPNOP_SYNC

//
// Set server info flags (for SetServerInfo)
//
#define DPNSETSERVERINFO_SYNC					DPNOP_SYNC

//
// SP capabilities flags
//
#define DPNSPCAPS_SUPPORTSDPNSRV				0x0001
#define DPNSPCAPS_SUPPORTSBROADCAST				0x0002
#define DPNSPCAPS_SUPPORTSALLADAPTERS			0x0004
//@@BEGIN_MSINTERNAL
// Flags added for DirectX 9
#define DPNSPCAPS_SUPPORTSTHREADPOOL			0x0008
#define DPNSPCAPS_NETWORKSIMULATOR				0x0010
#ifndef DPNBUILD_NOMULTICAST
#define DPNSPCAPS_SUPPORTSMULTICAST				0x0020
#endif // ! DPNBUILD_NOMULTICAST
#ifndef DPNBUILD_MANDATORYTHREADS
#define DPNSPCAPS_HASMANDATORYTHREADS			0x0040
#endif // DPNBUILD_MANDATORYTHREADS

//
// SP information flags (added for DirectX 9)
//
#define DPNSPINFO_NETWORKSIMULATORDEVICE		0x0001
#ifndef DPNBUILD_NOMULTICAST
#define DPNSPINFO_DEFAULTMULTICASTDEVICE		0x0002
#endif // ! DPNBUILD_NOMULTICAST

//
// Thread information flags (added for DirectX 9)
//
#ifdef DPNBUILD_MANDATORYTHREADS
#define DPNTHREAD_MANDATORY						0x0001
#endif // DPNBUILD_MANDATORYTHREADS
//@@END_MSINTERNAL




/****************************************************************************
 *
 * DirectPlay8 Structures (Non-Message)
 *
 ****************************************************************************/

//
// Application description
//
typedef struct	_DPN_APPLICATION_DESC
{
	DWORD	dwSize;							// Size of this structure
	DWORD	dwFlags;						// Flags (DPNSESSION_...)
	GUID	guidInstance;					// Instance GUID
	GUID	guidApplication;				// Application GUID
	DWORD	dwMaxPlayers;					// Maximum # of players allowed (0=no limit)
	DWORD	dwCurrentPlayers;				// Current # of players allowed
	WCHAR	*pwszSessionName;				// Name of the session
	WCHAR	*pwszPassword;					// Password for the session
	PVOID	pvReservedData;					
	DWORD	dwReservedDataSize;
	PVOID	pvApplicationReservedData;
	DWORD	dwApplicationReservedDataSize;
} DPN_APPLICATION_DESC, *PDPN_APPLICATION_DESC;

//
// Generic Buffer Description
//
typedef struct	_BUFFERDESC
{
	DWORD	dwBufferSize;		
	BYTE * 	pBufferData;		
} BUFFERDESC, DPN_BUFFER_DESC, *PDPN_BUFFER_DESC;

typedef BUFFERDESC	FAR * PBUFFERDESC;

//
// DirectPlay8 capabilities
//
typedef struct	_DPN_CAPS
{
	DWORD	dwSize;						// Size of this structure
	DWORD	dwFlags;						// Flags
	DWORD	dwConnectTimeout;			// ms before a connect request times out
	DWORD	dwConnectRetries;				// # of times to attempt the connection
	DWORD	dwTimeoutUntilKeepAlive;		// ms of inactivity before a keep alive is sent
} DPN_CAPS, *PDPN_CAPS;

//@@BEGIN_MSINTERNAL
//
// Extended capabilities structures (added for DirectX 9)
//
typedef struct	_DPN_CAPS_EX
{
	DWORD	dwSize;						// Size of this structure
	DWORD	dwFlags;						// Flags
	DWORD	dwConnectTimeout;			// ms before a connect request times out
	DWORD	dwConnectRetries;				// # of times to attempt the connection
	DWORD	dwTimeoutUntilKeepAlive;		// ms of inactivity before a keep alive is sent
	DWORD	dwMaxRecvMsgSize;			// maximum size in bytes of message that can be received
	DWORD	dwNumSendRetries;			// maximum number of send retries before link is considered dead
	DWORD	dwMaxSendRetryInterval;		// maximum period in msec between send retries
	DWORD	dwDropThresholdRate;			// percentage of dropped packets before throttling
	DWORD	dwThrottleRate;				// percentage amount to reduce send window when throttling
	DWORD	dwNumHardDisconnectSends;	// number of hard disconnect frames to send when close immediate flag is specified
	DWORD	dwMaxHardDisconnectPeriod;	// maximum period between hard disconnect sends
} DPN_CAPS_EX, *PDPN_CAPS_EX;
//@@END_MSINTERNAL

//
// Connection Statistics information
//
typedef struct _DPN_CONNECTION_INFO
{
	DWORD	dwSize;
	DWORD	dwRoundTripLatencyMS;
	DWORD	dwThroughputBPS;
	DWORD	dwPeakThroughputBPS;

	DWORD	dwBytesSentGuaranteed;
	DWORD	dwPacketsSentGuaranteed;
	DWORD	dwBytesSentNonGuaranteed;
	DWORD	dwPacketsSentNonGuaranteed;

	DWORD	dwBytesRetried;		// Guaranteed only
	DWORD	dwPacketsRetried;	// Guaranteed only
	DWORD	dwBytesDropped;		// Non Guaranteed only
	DWORD	dwPacketsDropped;	// Non Guaranteed only

	DWORD	dwMessagesTransmittedHighPriority;
	DWORD	dwMessagesTimedOutHighPriority;
	DWORD	dwMessagesTransmittedNormalPriority;
	DWORD	dwMessagesTimedOutNormalPriority;
	DWORD	dwMessagesTransmittedLowPriority;
	DWORD	dwMessagesTimedOutLowPriority;

	DWORD	dwBytesReceivedGuaranteed;
	DWORD	dwPacketsReceivedGuaranteed;
	DWORD	dwBytesReceivedNonGuaranteed;
	DWORD	dwPacketsReceivedNonGuaranteed;
	DWORD	dwMessagesReceived;

} DPN_CONNECTION_INFO, *PDPN_CONNECTION_INFO;

//@@BEGIN_MSINTERNAL

typedef struct _DPN_CONNECTION_INFO_INTERNAL
{
	DWORD	dwSize;
	DWORD	dwRoundTripLatencyMS;
	DWORD	dwThroughputBPS;
	DWORD	dwPeakThroughputBPS;

	DWORD	dwBytesSentGuaranteed;
	DWORD	dwPacketsSentGuaranteed;
	DWORD	dwBytesSentNonGuaranteed;
	DWORD	dwPacketsSentNonGuaranteed;

	DWORD	dwBytesRetried;		// Guaranteed only
	DWORD	dwPacketsRetried;	// Guaranteed only
	DWORD	dwBytesDropped;		// Non Guaranteed only
	DWORD	dwPacketsDropped;	// Non Guaranteed only

	DWORD	dwMessagesTransmittedHighPriority;
	DWORD	dwMessagesTimedOutHighPriority;
	DWORD	dwMessagesTransmittedNormalPriority;
	DWORD	dwMessagesTimedOutNormalPriority;
	DWORD	dwMessagesTransmittedLowPriority;
	DWORD	dwMessagesTimedOutLowPriority;

	DWORD	dwBytesReceivedGuaranteed;
	DWORD	dwPacketsReceivedGuaranteed;
	DWORD	dwBytesReceivedNonGuaranteed;
	DWORD	dwPacketsReceivedNonGuaranteed;
	DWORD	dwMessagesReceived;

	// Members not in DPN_CONNECTION_INFO ///////////////////////////////////////////////////

	// Adaptive Algorithm Parameters
	UINT	uiDropCount;		// localized packet drop count (recent drops)
	UINT	uiThrottleEvents;	// count of temporary backoffs for all reasons
	UINT	uiAdaptAlgCount;	// Acknowledge count remaining before running adaptive algorithm
	UINT	uiWindowFilled;		// Count of times we fill the send window
	UINT	uiPeriodAcksBytes;	// frames acked since change in tuning
	UINT	uiPeriodXmitTime;	// time link has been transmitting since change in tuning
	DWORD	dwLastThroughputBPS;// the calculated throughput from the last period
	UINT	uiLastBytesAcked;	// the number of bytes acked in the last period

	// Current Transmit Parameters:
	UINT	uiWindowF;			// window size (frames)
	UINT	uiWindowB;			// window size (bytes)
	UINT	uiUnackedFrames;		// outstanding frame count
	UINT	uiUnackedBytes;		// outstanding byte count
	UINT	uiBurstGap;			// number of ms to wait between bursts
	INT		iBurstCredit;		// Either credit or deficit from previous Transmit Burst
	UINT	uiRetryTimeout;		// The time until we consider a frame lost and in need of retransmission

	// Last Known Good Transmit Parameters --  Values which we believe are safe...
	UINT	uiGoodWindowF;
	UINT	uiGoodWindowB;
	UINT	uiGoodBurstGap;
	UINT	uiGoodRTT;

	// Restore Parameters - We will restore to these when we un-throttle if we are throttled
	UINT	uiRestoreWindowF;
	UINT	uiRestoreWindowB;
	UINT	uiRestoreBurstGap;

	// Link State Parameters
	BYTE	bNextSend;			// Next serial number to assign to a frame
	BYTE	bNextReceive;		// Next frame serial we expect to receive
	ULONG	ulReceiveMask;		// mask representing first 32 frames in our rcv window
	ULONG	ulReceiveMask2;		// second 32 frames in our window
	ULONG	ulSendMask;			// mask representing unreliable send frames that have timed out and need
	ULONG	ulSendMask2;		// to be reported to receiver as missing.

	// Informational Parameters
	DWORD	uiQueuedMessageCount;// Number of messages waiting on all three send queues
	UINT	uiCompleteMsgCount;	// Count of messages on the CompleteList
	ULONG	ulEPFlags;			// End Point Flags

} DPN_CONNECTION_INFO_INTERNAL, *PDPN_CONNECTION_INFO_INTERNAL;

typedef struct _DPN_CONNECTION_INFO_INTERNAL2
{
	DWORD	dwSize;
	DWORD	dwRoundTripLatencyMS;
	DWORD	dwThroughputBPS;
	DWORD	dwPeakThroughputBPS;

	DWORD	dwBytesSentGuaranteed;
	DWORD	dwPacketsSentGuaranteed;
	DWORD	dwBytesSentNonGuaranteed;
	DWORD	dwPacketsSentNonGuaranteed;

	DWORD	dwBytesRetried;		// Guaranteed only
	DWORD	dwPacketsRetried;	// Guaranteed only
	DWORD	dwBytesDropped;		// Non Guaranteed only
	DWORD	dwPacketsDropped;	// Non Guaranteed only

	DWORD	dwMessagesTransmittedHighPriority;
	DWORD	dwMessagesTimedOutHighPriority;
	DWORD	dwMessagesTransmittedNormalPriority;
	DWORD	dwMessagesTimedOutNormalPriority;
	DWORD	dwMessagesTransmittedLowPriority;
	DWORD	dwMessagesTimedOutLowPriority;

	DWORD	dwBytesReceivedGuaranteed;
	DWORD	dwPacketsReceivedGuaranteed;
	DWORD	dwBytesReceivedNonGuaranteed;
	DWORD	dwPacketsReceivedNonGuaranteed;
	DWORD	dwMessagesReceived;

	// Members not in DPN_CONNECTION_INFO ///////////////////////////////////////////////////

	// Adaptive Algorithm Parameters
	UINT	uiDropCount;		// localized packet drop count (recent drops)
	UINT	uiThrottleEvents;	// count of temporary backoffs for all reasons
	UINT	uiAdaptAlgCount;	// Acknowledge count remaining before running adaptive algorithm
	UINT	uiWindowFilled;		// Count of times we fill the send window
	UINT	uiPeriodAcksBytes;	// frames acked since change in tuning
	UINT	uiPeriodXmitTime;	// time link has been transmitting since change in tuning
	DWORD	dwLastThroughputBPS;// the calculated throughput from the last period
	UINT	uiLastBytesAcked;	// the number of bytes acked in the last period

	// Current Transmit Parameters:
	UINT	uiWindowF;			// window size (frames)
	UINT	uiWindowB;			// window size (bytes)
	UINT	uiUnackedFrames;		// outstanding frame count
	UINT	uiUnackedBytes;		// outstanding byte count
	UINT	uiBurstGap;			// number of ms to wait between bursts
	INT		iBurstCredit;		// Either credit or deficit from previous Transmit Burst
	UINT	uiRetryTimeout;		// The time until we consider a frame lost and in need of retransmission

	// Last Known Good Transmit Parameters --  Values which we believe are safe...
	UINT	uiGoodWindowF;
	UINT	uiGoodWindowB;
	UINT	uiGoodBurstGap;
	UINT	uiGoodRTT;

	// Restore Parameters - We will restore to these when we un-throttle if we are throttled
	UINT	uiRestoreWindowF;
	UINT	uiRestoreWindowB;
	UINT	uiRestoreBurstGap;

	// Link State Parameters
	BYTE	bNextSend;			// Next serial number to assign to a frame
	BYTE	bNextReceive;		// Next frame serial we expect to receive
	ULONG	ulReceiveMask;		// mask representing first 32 frames in our rcv window
	ULONG	ulReceiveMask2;		// second 32 frames in our window
	ULONG	ulSendMask;			// mask representing unreliable send frames that have timed out and need
	ULONG	ulSendMask2;		// to be reported to receiver as missing.

	// Informational Parameters
	DWORD	uiQueuedMessageCount;// Number of messages waiting on all three send queues
	UINT	uiCompleteMsgCount;	// Count of messages on the CompleteList
	ULONG	ulEPFlags;			// End Point Flags

	// Members not in DPN_CONNECTION_INFO_INTERNAL ///////////////////////////////////////////////////

	// Dropped Frame Parameters
	DWORD	dwDropBitMask;		// bit mask of dropped frames (32 frame max)
	DWORD 	uiTotalThrottleEvents;	//number of times we've throttled back
} DPN_CONNECTION_INFO_INTERNAL2, *PDPN_CONNECTION_INFO_INTERNAL2;

//@@END_MSINTERNAL

//
// Group information strucutre
//
typedef struct	_DPN_GROUP_INFO
{
	DWORD	dwSize;				// size of this structure
	DWORD	dwInfoFlags;		// information contained
	PWSTR	pwszName;			// Unicode Name
	PVOID	pvData;				// data block
	DWORD	dwDataSize;			// size in BYTES of data block
	DWORD	dwGroupFlags;		// group flags (DPNGROUP_...)
} DPN_GROUP_INFO, *PDPN_GROUP_INFO;

//
// Player information structure
//
typedef struct	_DPN_PLAYER_INFO
{
	DWORD	dwSize;				// size of this structure
	DWORD	dwInfoFlags;		// information contained
	PWSTR	pwszName;			// Unicode Name
	PVOID	pvData;				// data block
	DWORD	dwDataSize;			// size in BYTES of data block
	DWORD	dwPlayerFlags;		// player flags (DPNPLAYER_...)
} DPN_PLAYER_INFO, *PDPN_PLAYER_INFO;

typedef struct _DPN_SECURITY_CREDENTIALS	DPN_SECURITY_CREDENTIALS, *PDPN_SECURITY_CREDENTIALS;
typedef struct _DPN_SECURITY_DESC			DPN_SECURITY_DESC, *PDPN_SECURITY_DESC;

//
// Service provider & adapter enumeration structure
//
typedef struct _DPN_SERVICE_PROVIDER_INFO
{
	DWORD		dwFlags;
	GUID		guid;		// SP Guid
	WCHAR		*pwszName;	// Friendly Name
	PVOID		pvReserved;	
	DWORD		dwReserved;
} DPN_SERVICE_PROVIDER_INFO, *PDPN_SERVICE_PROVIDER_INFO;

//
// Service provider caps structure
//
typedef struct _DPN_SP_CAPS
{
	DWORD	dwSize;							// Size of this structure
	DWORD	dwFlags;						// Flags (DPNSPCAPS_...)
	DWORD	dwNumThreads;					// # of worker threads to use
	DWORD	dwDefaultEnumCount;				// default # of enum requests
	DWORD	dwDefaultEnumRetryInterval;		// default ms between enum requests
	DWORD	dwDefaultEnumTimeout;			// default enum timeout
	DWORD	dwMaxEnumPayloadSize;			// maximum size in bytes for enum payload data
	DWORD	dwBuffersPerThread;				// number of receive buffers per thread
	DWORD	dwSystemBufferSize;				// amount of buffering to do in addition to posted receive buffers
} DPN_SP_CAPS, *PDPN_SP_CAPS;

//@@BEGIN_MSINTERNAL

//
// Security credentials
//
typedef struct _DPN_SECURITY_CREDENTIALS
{
	DWORD	dwSize;
	DWORD	dwFlags;
} DPN_SECURITY_CREDENTIALS, *PDPN_SECURITY_CREDENTIALS;

//
// Security description
//
typedef struct _DPN_SECURITY_DESC
{
	DWORD	dwSize;
	DWORD	dwFlags;
} DPN_SECURITY_DESC, *PDPN_SECURITY_DESC;

//@@END_MSINTERNAL


//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//
// Multicast scope enumeration structure
//
typedef struct _DPN_MULTICAST_SCOPE_INFO
{
	DWORD		dwFlags;
	GUID		guid;		// Scope guid
	WCHAR		*pwszName;	// Friendly name
	PVOID		pvReserved;	
	DWORD		dwReserved;
} DPN_MULTICAST_SCOPE_INFO, *PDPN_MULTICAST_SCOPE_INFO;
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL



/****************************************************************************
 *
 * IDirectPlay8 message handler call back structures
 *
 ****************************************************************************/

//
// Add player to group structure for message handler
// (DPN_MSGID_ADD_PLAYER_TO_GROUP)
//
typedef struct	_DPNMSG_ADD_PLAYER_TO_GROUP
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidGroup;			// DPNID of group
	PVOID	pvGroupContext;		// Group context value
	DPNID	dpnidPlayer;		// DPNID of added player
	PVOID	pvPlayerContext;	// Player context value
} DPNMSG_ADD_PLAYER_TO_GROUP, *PDPNMSG_ADD_PLAYER_TO_GROUP;

//
// Async operation completion structure for message handler
// (DPN_MSGID_ASYNC_OP_COMPLETE)
//
typedef struct	_DPNMSG_ASYNC_OP_COMPLETE
{
	DWORD		dwSize;			// Size of this structure
	DPNHANDLE	hAsyncOp;		// DirectPlay8 async operation handle
	PVOID		pvUserContext;	// User context supplied
	HRESULT		hResultCode;	// HRESULT of operation
} DPNMSG_ASYNC_OP_COMPLETE, *PDPNMSG_ASYNC_OP_COMPLETE;

//
// Client info structure for message handler
// (DPN_MSGID_CLIENT_INFO)
//
typedef struct	_DPNMSG_CLIENT_INFO
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidClient;		// DPNID of client
	PVOID	pvPlayerContext;	// Player context value
} DPNMSG_CLIENT_INFO, *PDPNMSG_CLIENT_INFO;

//
// Connect complete structure for message handler
// (DPN_MSGID_CONNECT_COMPLETE)
//
typedef struct	_DPNMSG_CONNECT_COMPLETE
{
	DWORD		dwSize;						// Size of this structure
	DPNHANDLE	hAsyncOp;					// DirectPlay8 Async operation handle
	PVOID		pvUserContext;				// User context supplied at Connect
	HRESULT		hResultCode;				// HRESULT of connection attempt
	PVOID		pvApplicationReplyData;		// Connection reply data from Host/Server
	DWORD		dwApplicationReplyDataSize;	// Size (in bytes) of pvApplicationReplyData

//@@BEGIN_MSINTERNAL
	// Fields added for DirectX 9
	DPNID		dpnidLocal;					// DPNID of local player
//@@END_MSINTERNAL
} DPNMSG_CONNECT_COMPLETE, *PDPNMSG_CONNECT_COMPLETE;

//
// Create group structure for message handler
// (DPN_MSGID_CREATE_GROUP)
//
typedef struct	_DPNMSG_CREATE_GROUP
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidGroup;			// DPNID of new group
	DPNID	dpnidOwner;			// Owner of newgroup
	PVOID	pvGroupContext;		// Group context value

//@@BEGIN_MSINTERNAL
	// Fields added for DirectX 9
	PVOID	pvOwnerContext;		// Owner context value
//@@END_MSINTERNAL
} DPNMSG_CREATE_GROUP, *PDPNMSG_CREATE_GROUP;

//
// Create player structure for message handler
// (DPN_MSGID_CREATE_PLAYER)
//
typedef struct	_DPNMSG_CREATE_PLAYER
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidPlayer;		// DPNID of new player
	PVOID	pvPlayerContext;	// Player context value
} DPNMSG_CREATE_PLAYER, *PDPNMSG_CREATE_PLAYER;

//
// Destroy group structure for message handler
// (DPN_MSGID_DESTROY_GROUP)
//
typedef struct	_DPNMSG_DESTROY_GROUP
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidGroup;			// DPNID of destroyed group
	PVOID	pvGroupContext;		// Group context value
	DWORD	dwReason;			// Information only
} DPNMSG_DESTROY_GROUP, *PDPNMSG_DESTROY_GROUP;

//
// Destroy player structure for message handler
// (DPN_MSGID_DESTROY_PLAYER)
//
typedef struct	_DPNMSG_DESTROY_PLAYER
{
	DWORD	dwSize;				// Size of this structure
	DPNID	dpnidPlayer;		// DPNID of leaving player
	PVOID	pvPlayerContext;	// Player context value
	DWORD	dwReason;			// Information only
} DPNMSG_DESTROY_PLAYER, *PDPNMSG_DESTROY_PLAYER;

//
// Enumeration request received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_QUERY)
//
typedef	struct	_DPNMSG_ENUM_HOSTS_QUERY
{
	DWORD				dwSize;				 // Size of this structure.
	IDirectPlay8Address *pAddressSender;		// Address of client who sent the request
	IDirectPlay8Address	*pAddressDevice;		// Address of device request was received on
	PVOID				pvReceivedData;		 // Request data (set on client)
	DWORD				dwReceivedDataSize;	 // Request data size (set on client)
	DWORD				dwMaxResponseDataSize;	// Max allowable size of enum response
	PVOID				pvResponseData;			// Optional query repsonse (user set)
	DWORD				dwResponseDataSize;		// Optional query response size (user set)
	PVOID				pvResponseContext;		// Optional query response context (user set)
} DPNMSG_ENUM_HOSTS_QUERY, *PDPNMSG_ENUM_HOSTS_QUERY;

//
// Enumeration response received structure for message handler
// (DPN_MSGID_ENUM_HOSTS_RESPONSE)
//
typedef	struct	_DPNMSG_ENUM_HOSTS_RESPONSE
{
	DWORD						dwSize;					 // Size of this structure
	IDirectPlay8Address			*pAddressSender;			// Address of host who responded
	IDirectPlay8Address			*pAddressDevice;			// Device response was received on
	const DPN_APPLICATION_DESC	*pApplicationDescription;	// Application description for the session
	PVOID						pvResponseData;			 // Optional response data (set on host)
	DWORD						dwResponseDataSize;		 // Optional response data size (set on host)
	PVOID						pvUserContext;				// Context value supplied for enumeration
	DWORD						dwRoundTripLatencyMS;		// Round trip latency in MS
} DPNMSG_ENUM_HOSTS_RESPONSE, *PDPNMSG_ENUM_HOSTS_RESPONSE;

//
// Group info structure for message handler
// (DPN_MSGID_GROUP_INFO)
//
typedef struct	_DPNMSG_GROUP_INFO
{
	DWORD	dwSize;					// Size of this structure
	DPNID	dpnidGroup;				// DPNID of group
	PVOID	pvGroupContext;			// Group context value
} DPNMSG_GROUP_INFO, *PDPNMSG_GROUP_INFO;

//
// Migrate host structure for message handler
// (DPN_MSGID_HOST_MIGRATE)
//
typedef struct	_DPNMSG_HOST_MIGRATE
{
	DWORD	dwSize;					// Size of this structure
	DPNID	dpnidNewHost;			// DPNID of new Host player
	PVOID	pvPlayerContext;		// Player context value
} DPNMSG_HOST_MIGRATE, *PDPNMSG_HOST_MIGRATE;

//
// Indicate connect structure for message handler
// (DPN_MSGID_INDICATE_CONNECT)
//
typedef struct	_DPNMSG_INDICATE_CONNECT
{
	DWORD				dwSize;					// Size of this structure
	PVOID				pvUserConnectData;		// Connecting player data
	DWORD				dwUserConnectDataSize;	// Size (in bytes) of pvUserConnectData
	PVOID				pvReplyData;			// Connection reply data
	DWORD				dwReplyDataSize;		// Size (in bytes) of pvReplyData
	PVOID				pvReplyContext;			// Buffer context for pvReplyData
	PVOID				pvPlayerContext;		// Player context preset
	IDirectPlay8Address	*pAddressPlayer;		// Address of connecting player
	IDirectPlay8Address	*pAddressDevice;		// Address of device receiving connect attempt
} DPNMSG_INDICATE_CONNECT, *PDPNMSG_INDICATE_CONNECT;

//
// Indicated connect aborted structure for message handler
// (DPN_MSGID_INDICATED_CONNECT_ABORTED)
//
typedef struct	_DPNMSG_INDICATED_CONNECT_ABORTED
{
	DWORD		dwSize;				// Size of this structure
	PVOID		pvPlayerContext;	// Player context preset from DPNMSG_INDICATE_CONNECT
} DPNMSG_INDICATED_CONNECT_ABORTED, *PDPNMSG_INDICATED_CONNECT_ABORTED;

//
// Peer info structure for message handler
// (DPN_MSGID_PEER_INFO)
//
typedef struct	_DPNMSG_PEER_INFO
{
	DWORD	dwSize;					// Size of this structure
	DPNID	dpnidPeer;				// DPNID of peer
	PVOID	pvPlayerContext;		// Player context value
} DPNMSG_PEER_INFO, *PDPNMSG_PEER_INFO;

//
// Receive structure for message handler
// (DPN_MSGID_RECEIVE)
//
typedef struct	_DPNMSG_RECEIVE
{
	DWORD		dwSize;				// Size of this structure
	DPNID		dpnidSender;		// DPNID of sending player
	PVOID		pvPlayerContext;	// Player context value of sending player
	PBYTE		pReceiveData;		// Received data
	DWORD		dwReceiveDataSize;	// Size (in bytes) of pReceiveData
	DPNHANDLE	hBufferHandle;		// Buffer handle for pReceiveData
} DPNMSG_RECEIVE, *PDPNMSG_RECEIVE;

//
// Remove player from group structure for message handler
// (DPN_MSGID_REMOVE_PLAYER_FROM_GROUP)
//
typedef struct	_DPNMSG_REMOVE_PLAYER_FROM_GROUP
{
	DWORD	dwSize;					// Size of this structure
	DPNID	dpnidGroup;				// DPNID of group
	PVOID	pvGroupContext;			// Group context value
	DPNID	dpnidPlayer;			// DPNID of deleted player
	PVOID	pvPlayerContext;		// Player context value
} DPNMSG_REMOVE_PLAYER_FROM_GROUP, *PDPNMSG_REMOVE_PLAYER_FROM_GROUP;

//
// Returned buffer structure for message handler
// (DPN_MSGID_RETURN_BUFFER)
//
typedef struct	_DPNMSG_RETURN_BUFFER
{
	DWORD		dwSize;				// Size of this structure
	HRESULT		hResultCode;		// Return value of operation
	PVOID		pvBuffer;			// Buffer being returned
	PVOID		pvUserContext;		// Context associated with buffer
} DPNMSG_RETURN_BUFFER, *PDPNMSG_RETURN_BUFFER;

//
// Send complete structure for message handler
// (DPN_MSGID_SEND_COMPLETE)
//
typedef struct	_DPNMSG_SEND_COMPLETE
{
	DWORD		dwSize;					// Size of this structure
	DPNHANDLE	hAsyncOp;				// DirectPlay8 Async operation handle
	PVOID		pvUserContext;			// User context supplied at Send/SendTo
	HRESULT		hResultCode;			// HRESULT of send
	DWORD		dwSendTime;				// Send time in ms

//@@BEGIN_MSINTERNAL
	// Fields added for DirectX 9
	DWORD		dwFirstFrameRTT;		// RTT of the first frame in the message
	DWORD		dwFirstFrameRetryCount;	// Retry count of the first frame
//@@END_MSINTERNAL
} DPNMSG_SEND_COMPLETE, *PDPNMSG_SEND_COMPLETE;

//
// Server info structure for message handler
// (DPN_MSGID_SERVER_INFO)
//
typedef struct	_DPNMSG_SERVER_INFO
{
	DWORD	dwSize;					// Size of this structure
	DPNID	dpnidServer;			// DPNID of server
	PVOID	pvPlayerContext;		// Player context value
} DPNMSG_SERVER_INFO, *PDPNMSG_SERVER_INFO;

//
// Terminated session structure for message handler
// (DPN_MSGID_TERMINATE_SESSION)
//
typedef struct	_DPNMSG_TERMINATE_SESSION
{
	DWORD		dwSize;				// Size of this structure
	HRESULT		hResultCode;		// Reason
	PVOID		pvTerminateData;	// Data passed from Host/Server
	DWORD		dwTerminateDataSize;// Size (in bytes) of pvTerminateData
} DPNMSG_TERMINATE_SESSION, *PDPNMSG_TERMINATE_SESSION;


//@@BEGIN_MSINTERNAL
//
// Message structures added for DirectX 9
//

//
// Create thread info structure for message handler
// (DPN_MSGID_CREATE_THREAD)
//
typedef struct	_DPNMSG_CREATE_THREAD
{
	DWORD	dwSize;				// Size of this structure
	DWORD	dwFlags;			// Flags describing this thread
	DWORD	dwProcessorNum;		// Index of processor to which thread is bound
	PVOID	pvUserContext;		// Thread context value
} DPNMSG_CREATE_THREAD, *PDPNMSG_CREATE_THREAD;

//
// Destroy thread info structure for message handler
// (DPN_MSGID_DESTROY_THREAD)
//
typedef struct	_DPNMSG_DESTROY_THREAD
{
	DWORD	dwSize;				// Size of this structure
	DWORD	dwProcessorNum;		// Index of processor to which thread was bound
	PVOID	pvUserContext;		// Thread context value
} DPNMSG_DESTROY_THREAD, *PDPNMSG_DESTROY_THREAD;

#ifndef DPNBUILD_NOMULTICAST
//
// Create sender context structure for message handler
// (DPN_MSGID_CREATE_SENDER_CONTEXT)
//
typedef struct	_DPNMSG_CREATE_SENDER_CONTEXT
{
	DWORD	dwSize;				// Size of this structure
	PVOID	pvSenderContext;	// Sender context value
} DPNMSG_CREATE_SENDER_CONTEXT, *PDPNMSG_CREATE_SENDER_CONTEXT;

//
// Destroy sender context structure for message handler
// (DPN_MSGID_DESTROY_SENDER_CONTEXT)
//
typedef struct	_DPNMSG_DESTROY_SENDER_CONTEXT
{
	DWORD	dwSize;				// Size of this structure
	PVOID	pvSenderContext;	// Sender context value
} DPNMSG_DESTROY_SENDER_CONTEXT, *PDPNMSG_DESTROY_SENDER_CONTEXT;

//
// Join complete structure for message handler
// (DPN_MSGID_JOIN_COMPLETE)
//
typedef struct	_DPNMSG_JOIN_COMPLETE
{
	DWORD				dwSize;				// Size of this structure
	DPNHANDLE			hAsyncOp;			// DirectPlay8 Async operation handle
	PVOID				pvUserContext;		// User context supplied at Join
	HRESULT				hResultCode;		// HRESULT of join attempt
} DPNMSG_JOIN_COMPLETE, *PDPNMSG_JOIN_COMPLETE;

//
// Data received from unknown group sender structure for message handler
// (DPN_MSGID_RECEIVE_MULTICAST)
//
typedef	struct	_DPNMSG_RECEIVE_MULTICAST
{
	DWORD				dwSize;				// Size of this structure.
	PVOID				pvSenderContext;	// Pointer to user supplied sender context, or NULL if not known
	IDirectPlay8Address	*pAddressSender;	// Address of client who sent the request
	IDirectPlay8Address	*pAddressDevice;	// Address of device request was received on
	PBYTE				pReceiveData;		// Received data
	DWORD				dwReceiveDataSize;	// Size (in bytes) of pReceiveData
	DPNHANDLE			hBufferHandle;		// Buffer handle for pReceiveData
} DPNMSG_RECEIVE_MULTICAST, *PDPNMSG_RECEIVE_MULTICAST;
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL



/****************************************************************************
 *
 * DirectPlay8 Functions
 *
 ****************************************************************************/


//@@BEGIN_MSINTERNAL
#ifdef _XBOX

#define XDP8STARTUP_BYPASSXNETSTARTUP		0x01	// prevents automatic initialization of the Xbox networking stack by DirectPlay
#define XDP8STARTUP_BYPASSSECURITY			0x02	// allows insecure communication to untrusted hosts

typedef struct _XDP8STARTUP_PARAMS
{
	DWORD		dwFlags;						// initialization flags (XDP8STARTUP_xxx)
	DWORD		dwNumCoreInterfaces;			// maximum number of IID_IDirectPlay8Client, IID_IDirectPlay8Server, or IID_IDirectPlay8Peer interfaces that will be created by the application
	DWORD		dwNumAddressInterfaces;			// maximum number of IID_IDirectPlay8Address interfaces that will be created by the application
	DWORD		dwMaxMemUsage;					// maximum amount of memory DirectPlay can allocate
} XDP8STARTUP_PARAMS, *PXDP8STARTUP_PARAMS;

extern HRESULT WINAPI XDirectPlay8Startup( const XDP8STARTUP_PARAMS * const pDP8StartupParams );

extern HRESULT WINAPI XDirectPlay8Cleanup( void );


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
typedef struct _XDP8CREATE_PARAMS
{
	DP8REFIID	riidInterfaceType;						// interface type ID (IID_IDirectPlay8Client, IID_IDirectPlay8Server, IID_IDirectPlay8Peer)
	DWORD		dwMaxNumPlayers;						// maximum number of players/clients for Peer/Server, ignored for Client
	DWORD		dwMaxPlayerNameLength;					// maximum length of a player name, in WCHARs, including NULL termination, or 0 if DPN_PLAYER_INFO names are not used
	DWORD		dwMaxPlayerDataSize;					// maximum size of player data
	DWORD		dwMaxNumGroups;							// maximum number of groups that will be created for Peer/Server, ignored for Client
	DWORD		dwMaxGroupNameLength;					// maximum length of a group name, in WCHARs, including NULL termination, or 0 if DPN_GROUP_INFO names are not used
	DWORD		dwMaxGroupDataSize;						// maximum size of group data
	DWORD		dwMaxAppDescSessionNameLength;			// maximum length of the application description structure's session name, in WCHARs, including NULL termination, or 0 if DPN_APPLICATION_DESC names are not used
	DWORD		dwMaxAppDescPasswordNameLength;			// maximum length of the application description structure's password, in WCHARs, including NULL termination, or 0 if DPN_APPLICATION_DESC passwords are not used
	DWORD		dwMaxAppDescAppReservedDataSize;		// maximum size of application description structure's application reserved data, in bytes
	DWORD		dwMaxSendsPerPlayer;					// maximum number of messages that can be sent per player/client/server at any one time
	DWORD		dwMaxReceivesPerPlayer;					// maximum number of messages that can be received per player/client/server at any one time (including receive buffers kept by returning DPNSUCCESS_PENDING)
	DWORD		dwMaxMessageSize;						// maximum message size (send or receive), in bytes
	DWORD		dwNumSimultaneousEnumHosts;				// maximum number of simultaneous EnumHosts initiated by non-host Peer/Client
	DWORD		dwMaxEnumHostsResponseDataSize;			// maximum enum hosts response data size
} XDP8CREATE_PARAMS, *PXDP8CREATE_PARAMS;

extern HRESULT WINAPI XDirectPlay8Create( const XDP8CREATE_PARAMS * const pDP8CreateParams, void **ppvInterface );
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
extern HRESULT WINAPI XDirectPlay8Create( DP8REFIID riidInterfaceType, void **ppvInterface );
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL


extern HRESULT WINAPI XDirectPlay8DoWork( const DWORD dwAllowedTimeSlice );

extern HRESULT WINAPI XDirectPlay8BuildAppDescReservedData( const XNKID * const pSessionID, const XNKEY * const pKeyExchangeKey, PVOID pvReservedData, DWORD * const pcbReservedDataSize );


#else // ! _XBOX
//@@END_MSINTERNAL

/*
 * This function is no longer supported.  It is recommended that CoCreateInstance be used to create 
 * DirectPlay8 objects.
 *
 * extern HRESULT WINAPI DirectPlay8Create( const CLSID * pcIID, void **ppvInterface, IUnknown *pUnknown );
 * 
 */
 
//@@BEGIN_MSINTERNAL
#endif // ! _XBOX
//@@END_MSINTERNAL



/****************************************************************************
 *
 * DirectPlay8 Application Interfaces
 *
 ****************************************************************************/

//
// COM definition for DirectPlay8 Client interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Client
DECLARE_INTERFACE_(IDirectPlay8Client,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ DP8REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Client methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags) PURE;
	STDMETHOD(EnumHosts)				(THIS_ PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(Connect)					(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(GetApplicationDesc)		(THIS_ DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetClientInfo)			(THIS_ const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetServerInfo)			(THIS_ DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(GetServerAddress)			(THIS_ IDirectPlay8Address **const pAddress,const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS *const pdpCaps,const DWORD dwFlags) PURE;
	STDMETHOD(SetCaps)					(THIS_ const DPN_CAPS *const pdpCaps, const DWORD dwFlags) PURE;
	STDMETHOD(SetSPCaps)				(THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
	STDMETHOD(GetSPCaps)				(THIS_ const GUID * const pguidSP,DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags) PURE;
	STDMETHOD(GetConnectionInfo)		(THIS_ DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags) PURE;
	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, struct IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
};

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERVER
//@@END_MSINTERNAL
//
// COM definition for DirectPlay8 Server interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Server
DECLARE_INTERFACE_(IDirectPlay8Server,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ DP8REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Server methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,PDWORD const pcbEnumData,PDWORD const pcReturned,const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ const DPNID dpnid,DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(GetApplicationDesc)		(THIS_ DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetServerInfo)			(THIS_ const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetClientInfo)			(THIS_ const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(GetClientAddress)			(THIS_ const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags) PURE;
	STDMETHOD(GetLocalHostAddresses)	(THIS_ IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags) PURE;
	STDMETHOD(SetApplicationDesc)		(THIS_ const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags) PURE;
	STDMETHOD(Host)						(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(SendTo)					(THIS_ const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(CreateGroup)				(THIS_ const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(DestroyGroup)				(THIS_ const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(AddPlayerToGroup)			(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(RemovePlayerFromGroup)	(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(SetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(EnumPlayersAndGroups)		(THIS_ DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(EnumGroupMembers)			(THIS_ const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(DestroyClient)			(THIS_ const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetPlayerContext)			(THIS_ const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupContext)			(THIS_ const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS *const pdpCaps,const DWORD dwFlags) PURE;
	STDMETHOD(SetCaps)					(THIS_ const DPN_CAPS *const pdpCaps, const DWORD dwFlags) PURE;
	STDMETHOD(SetSPCaps)				(THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
	STDMETHOD(GetSPCaps)				(THIS_ const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags) PURE;
	STDMETHOD(GetConnectionInfo)		(THIS_ const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags) PURE;
	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, struct IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
};
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERVER
//@@END_MSINTERNAL

//
// COM definition for DirectPlay8 Peer interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Peer
DECLARE_INTERFACE_(IDirectPlay8Peer,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ DP8REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Peer methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, DWORD *const pcbEnumData, DWORD *const pcReturned, const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(Connect)					(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(SendTo)					(THIS_ const DPNID dpnid,const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ const DPNID dpnid, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(Host)						(THIS_ const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetApplicationDesc)		(THIS_ DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetApplicationDesc)		(THIS_ const DPN_APPLICATION_DESC *const pad, const DWORD dwFlags) PURE;
	STDMETHOD(CreateGroup)				(THIS_ const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(DestroyGroup)				(THIS_ const DPNID idGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(AddPlayerToGroup)			(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(RemovePlayerFromGroup)	(THIS_ const DPNID idGroup, const DPNID idClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(SetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupInfo)				(THIS_ const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(EnumPlayersAndGroups)		(THIS_ DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(EnumGroupMembers)			(THIS_ const DPNID dpnid, DPNID *const prgdpnid, DWORD *const pcdpnid, const DWORD dwFlags) PURE;
	STDMETHOD(SetPeerInfo)				(THIS_ const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetPeerInfo)				(THIS_ const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags) PURE;
	STDMETHOD(GetPeerAddress)			(THIS_ const DPNID dpnid,IDirectPlay8Address **const ppAddress,const DWORD dwFlags) PURE;
	STDMETHOD(GetLocalHostAddresses)	(THIS_ IDirectPlay8Address **const prgpAddress,DWORD *const pcAddress,const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(EnumHosts)				(THIS_ PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwEnumCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags) PURE;
	STDMETHOD(DestroyPeer)				(THIS_ const DPNID dpnidClient, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle,const DWORD dwFlags) PURE;
	STDMETHOD(GetPlayerContext)			(THIS_ const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupContext)			(THIS_ const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)					(THIS_ DPN_CAPS *const pdpCaps,const DWORD dwFlags) PURE;
	STDMETHOD(SetCaps)					(THIS_ const DPN_CAPS *const pdpCaps, const DWORD dwFlags) PURE;
	STDMETHOD(SetSPCaps)				(THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
	STDMETHOD(GetSPCaps)				(THIS_ const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags) PURE;
	STDMETHOD(GetConnectionInfo)		(THIS_ const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags) PURE;
	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, struct IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
	STDMETHOD(TerminateSession)			(THIS_ void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags) PURE;
};


//@@BEGIN_MSINTERNAL
#ifndef _XBOX

//
// COM definition for DirectPlay8 Thread Pool interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8ThreadPool
DECLARE_INTERFACE_(IDirectPlay8ThreadPool,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ DP8REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8ThreadPool methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(GetThreadCount)			(THIS_ const DWORD dwProcessorNum, DWORD *const pdwNumThreads, const DWORD dwFlags) PURE;
	STDMETHOD(SetThreadCount)			(THIS_ const DWORD dwProcessorNum, const DWORD dwNumThreads, const DWORD dwFlags) PURE;
	STDMETHOD(DoWork)					(THIS_ const DWORD dwAllowedTimeSlice, const DWORD dwFlags) PURE;
};

#endif // ! _XBOX

//
// COM definition for DirectPlay8 Thread Pool Work interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8ThreadPoolWork
DECLARE_INTERFACE_(IDirectPlay8ThreadPoolWork,IUnknown)
{
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DPNBUILD_MULTIPLETHREADPOOLS)))
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ DP8REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
	/*** IDirectPlay8ThreadPoolWork methods ***/
	STDMETHOD(QueueWorkItem)			(THIS_ const DWORD dwCPU, const PFNDPTNWORKCALLBACK pfnWorkCallback, PVOID const pvCallbackContext, const DWORD dwFlags) PURE;
	STDMETHOD(ScheduleTimer)			(THIS_ const DWORD dwCPU, const DWORD dwDelay, const PFNDPTNWORKCALLBACK pfnWorkCallback, PVOID const pvCallbackContext, void **const ppvTimerData, UINT *const puiTimerUnique, const DWORD dwFlags) PURE;
	STDMETHOD(StartTrackingFileIo)		(THIS_ const DWORD dwCPU, const HANDLE hFile, const DWORD dwFlags) PURE;
	STDMETHOD(StopTrackingFileIo)		(THIS_ const DWORD dwCPU, const HANDLE hFile, const DWORD dwFlags) PURE;
	STDMETHOD(CreateOverlapped)			(THIS_ const DWORD dwCPU, const PFNDPTNWORKCALLBACK pfnWorkCallback, PVOID const pvCallbackContext, OVERLAPPED **const ppOverlapped, const DWORD dwFlags) PURE;
	STDMETHOD(SubmitIoOperation)		(THIS_ OVERLAPPED *const pOverlapped, const DWORD dwFlags) PURE;
	STDMETHOD(ReleaseOverlapped)		(THIS_ OVERLAPPED *const pOverlapped, const DWORD dwFlags) PURE;
	STDMETHOD(CancelTimer)				(THIS_ void *const pvTimerData, const UINT uiTimerUnique, const DWORD dwFlags) PURE;
	STDMETHOD(ResetCompletingTimer)		(THIS_ void *const pvTimerData, const DWORD dwNewDelay, const PFNDPTNWORKCALLBACK pfnNewWorkCallback, PVOID const pvNewCallbackContext, UINT *const puiNewTimerUnique, const DWORD dwFlags) PURE;
	STDMETHOD(WaitWhileWorking)			(THIS_ const HANDLE hWaitObject, const DWORD dwFlags) PURE;
	STDMETHOD(SleepWhileWorking)		(THIS_ const DWORD dwTimeout, const DWORD dwFlags) PURE;
	STDMETHOD(RequestTotalThreadCount)	(THIS_ const DWORD dwNumThreads, const DWORD dwFlags) PURE;
	STDMETHOD(GetThreadCount)			(THIS_ const DWORD dwCPU, DWORD *const pdwNumThreads, const DWORD dwFlags) PURE;
	STDMETHOD(GetWorkRecursionDepth)	(THIS_ DWORD *const pdwDepth, const DWORD dwFlags) PURE;
	STDMETHOD(Preallocate)				(THIS_ const DWORD dwNumWorkItems, const DWORD dwNumTimers, const DWORD dwNumIoOperations, const DWORD dwFlags) PURE;
#ifdef DPNBUILD_MANDATORYTHREADS
	STDMETHOD(CreateMandatoryThread)	(THIS_ LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, LPDWORD lpThreadId, HANDLE *const phThread, const DWORD dwFlags) PURE;
#endif // DPNBUILD_MANDATORYTHREADS
};

#ifndef DPNBUILD_NOMULTICAST
//
// COM definition for DirectPlay8 Multicast interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Multicast
DECLARE_INTERFACE_(IDirectPlay8Multicast,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ DP8REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Multicast methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags) PURE;
	STDMETHOD(Join)						(THIS_ IDirectPlay8Address *const pGroupAddr,IUnknown *const pDeviceInfo, const DPN_SECURITY_DESC *const pdnSecurity, const DPN_SECURITY_CREDENTIALS *const pdnCredentials, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(Close)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(CreateSenderContext)		(THIS_ IDirectPlay8Address *const pSenderAddress,void *const pvSenderContext, const DWORD dwFlags) PURE;
	STDMETHOD(DestroySenderContext)		(THIS_ IDirectPlay8Address *const pSenderAddress,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPN_BUFFER_DESC *const prgBufferDesc, const DWORD cBufferDesc, const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(GetGroupAddress)			(THIS_ IDirectPlay8Address **const ppAddress, const DWORD dwFlags) PURE;
	STDMETHOD(GetSendQueueInfo)			(THIS_ DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags) PURE;
	STDMETHOD(CancelAsyncOperation)		(THIS_ const DPNHANDLE hAsyncHandle, const DWORD dwFlags) PURE;
	STDMETHOD(ReturnBuffer)				(THIS_ const DPNHANDLE hBufferHandle, const DWORD dwFlags) PURE;
	STDMETHOD(EnumServiceProviders)		(THIS_ const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags) PURE;
	STDMETHOD(EnumMulticastScopes)		(THIS_ const GUID *const pguidServiceProvider, const GUID *const pguidDevice, const GUID *const pguidApplication, DPN_MULTICAST_SCOPE_INFO *const pScopeInfoBuffer, PDWORD const pcbEnumData, PDWORD const pcReturned, const DWORD dwFlags) PURE;
	STDMETHOD(GetSPCaps)				(THIS_ const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags) PURE;
	STDMETHOD(SetSPCaps)				(THIS_ const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags ) PURE;
};
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL



/****************************************************************************
 *
 * IDirectPlay8 application interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay8Client_QueryInterface(p,a,b)					(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8Client_AddRef(p)								(p)->lpVtbl->AddRef(p)
#define IDirectPlay8Client_Release(p)								(p)->lpVtbl->Release(p)
#define IDirectPlay8Client_Initialize(p,a,b,c)						(p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectPlay8Client_EnumServiceProviders(p,a,b,c,d,e,f)		(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define IDirectPlay8Client_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->lpVtbl->EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)
#define IDirectPlay8Client_CancelAsyncOperation(p,a,b)				(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define IDirectPlay8Client_Connect(p,a,b,c,d,e,f,g,h,i,j)			(p)->lpVtbl->Connect(p,a,b,c,d,e,f,g,h,i,j)
#define IDirectPlay8Client_Send(p,a,b,c,d,e,f)						(p)->lpVtbl->Send(p,a,b,c,d,e,f)
#define IDirectPlay8Client_GetSendQueueInfo(p,a,b,c)				(p)->lpVtbl->GetSendQueueInfo(p,a,b,c)
#define IDirectPlay8Client_GetApplicationDesc(p,a,b,c)				(p)->lpVtbl->GetApplicationDesc(p,a,b,c)
#define IDirectPlay8Client_SetClientInfo(p,a,b,c,d)					(p)->lpVtbl->SetClientInfo(p,a,b,c,d)
#define IDirectPlay8Client_GetServerInfo(p,a,b,c)					(p)->lpVtbl->GetServerInfo(p,a,b,c)
#define IDirectPlay8Client_GetServerAddress(p,a,b)					(p)->lpVtbl->GetServerAddress(p,a,b)
#define IDirectPlay8Client_Close(p,a)								(p)->lpVtbl->Close(p,a)
#define IDirectPlay8Client_ReturnBuffer(p,a,b)						(p)->lpVtbl->ReturnBuffer(p,a,b)
#define IDirectPlay8Client_GetCaps(p,a,b)							(p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay8Client_SetCaps(p,a,b)							(p)->lpVtbl->SetCaps(p,a,b)
#define IDirectPlay8Client_SetSPCaps(p,a,b,c)						(p)->lpVtbl->SetSPCaps(p,a,b,c)
#define IDirectPlay8Client_GetSPCaps(p,a,b,c)						(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define IDirectPlay8Client_GetConnectionInfo(p,a,b)					(p)->lpVtbl->GetConnectionInfo(p,a,b)
#define IDirectPlay8Client_RegisterLobby(p,a,b,c)					(p)->lpVtbl->RegisterLobby(p,a,b,c)

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERVER
//@@END_MSINTERNAL
#define IDirectPlay8Server_QueryInterface(p,a,b)					(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8Server_AddRef(p)								(p)->lpVtbl->AddRef(p)
#define IDirectPlay8Server_Release(p)								(p)->lpVtbl->Release(p)
#define IDirectPlay8Server_Initialize(p,a,b,c)						(p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectPlay8Server_EnumServiceProviders(p,a,b,c,d,e,f)		(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define IDirectPlay8Server_CancelAsyncOperation(p,a,b)				(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define IDirectPlay8Server_GetSendQueueInfo(p,a,b,c,d)				(p)->lpVtbl->GetSendQueueInfo(p,a,b,c,d)
#define IDirectPlay8Server_GetApplicationDesc(p,a,b,c)				(p)->lpVtbl->GetApplicationDesc(p,a,b,c)
#define IDirectPlay8Server_SetServerInfo(p,a,b,c,d)					(p)->lpVtbl->SetServerInfo(p,a,b,c,d)
#define IDirectPlay8Server_GetClientInfo(p,a,b,c,d)					(p)->lpVtbl->GetClientInfo(p,a,b,c,d)
#define IDirectPlay8Server_GetClientAddress(p,a,b,c)				(p)->lpVtbl->GetClientAddress(p,a,b,c)
#define IDirectPlay8Server_GetLocalHostAddresses(p,a,b,c)			(p)->lpVtbl->GetLocalHostAddresses(p,a,b,c)
#define IDirectPlay8Server_SetApplicationDesc(p,a,b)				(p)->lpVtbl->SetApplicationDesc(p,a,b)
#define IDirectPlay8Server_Host(p,a,b,c,d,e,f,g)					(p)->lpVtbl->Host(p,a,b,c,d,e,f,g)
#define IDirectPlay8Server_SendTo(p,a,b,c,d,e,f,g)					(p)->lpVtbl->SendTo(p,a,b,c,d,e,f,g)
#define IDirectPlay8Server_CreateGroup(p,a,b,c,d,e)					(p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay8Server_DestroyGroup(p,a,b,c,d)					(p)->lpVtbl->DestroyGroup(p,a,b,c,d)
#define IDirectPlay8Server_AddPlayerToGroup(p,a,b,c,d,e)			(p)->lpVtbl->AddPlayerToGroup(p,a,b,c,d,e)
#define IDirectPlay8Server_RemovePlayerFromGroup(p,a,b,c,d,e)		(p)->lpVtbl->RemovePlayerFromGroup(p,a,b,c,d,e)
#define IDirectPlay8Server_SetGroupInfo(p,a,b,c,d,e)				(p)->lpVtbl->SetGroupInfo(p,a,b,c,d,e)
#define IDirectPlay8Server_GetGroupInfo(p,a,b,c,d)					(p)->lpVtbl->GetGroupInfo(p,a,b,c,d)
#define IDirectPlay8Server_EnumPlayersAndGroups(p,a,b,c)			(p)->lpVtbl->EnumPlayersAndGroups(p,a,b,c)
#define IDirectPlay8Server_EnumGroupMembers(p,a,b,c,d)				(p)->lpVtbl->EnumGroupMembers(p,a,b,c,d)
#define IDirectPlay8Server_Close(p,a)								(p)->lpVtbl->Close(p,a)
#define IDirectPlay8Server_DestroyClient(p,a,b,c,d)					(p)->lpVtbl->DestroyClient(p,a,b,c,d)
#define IDirectPlay8Server_ReturnBuffer(p,a,b)						(p)->lpVtbl->ReturnBuffer(p,a,b)
#define IDirectPlay8Server_GetPlayerContext(p,a,b,c)				(p)->lpVtbl->GetPlayerContext(p,a,b,c)
#define IDirectPlay8Server_GetGroupContext(p,a,b,c)					(p)->lpVtbl->GetGroupContext(p,a,b,c)
#define IDirectPlay8Server_GetCaps(p,a,b)							(p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay8Server_SetCaps(p,a,b)							(p)->lpVtbl->SetCaps(p,a,b)
#define IDirectPlay8Server_SetSPCaps(p,a,b,c)						(p)->lpVtbl->SetSPCaps(p,a,b,c)
#define IDirectPlay8Server_GetSPCaps(p,a,b,c)						(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define IDirectPlay8Server_GetConnectionInfo(p,a,b,c)				(p)->lpVtbl->GetConnectionInfo(p,a,b,c)
#define IDirectPlay8Server_RegisterLobby(p,a,b,c)					(p)->lpVtbl->RegisterLobby(p,a,b,c)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERVER
//@@END_MSINTERNAL

#define IDirectPlay8Peer_QueryInterface(p,a,b)						(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8Peer_AddRef(p)									(p)->lpVtbl->AddRef(p)
#define IDirectPlay8Peer_Release(p)									(p)->lpVtbl->Release(p)
#define IDirectPlay8Peer_Initialize(p,a,b,c)						(p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectPlay8Peer_EnumServiceProviders(p,a,b,c,d,e,f)		(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define IDirectPlay8Peer_CancelAsyncOperation(p,a,b)				(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define IDirectPlay8Peer_Connect(p,a,b,c,d,e,f,g,h,i,j,k)			(p)->lpVtbl->Connect(p,a,b,c,d,e,f,g,h,i,j,k)
#define IDirectPlay8Peer_SendTo(p,a,b,c,d,e,f,g)					(p)->lpVtbl->SendTo(p,a,b,c,d,e,f,g)
#define IDirectPlay8Peer_GetSendQueueInfo(p,a,b,c,d)				(p)->lpVtbl->GetSendQueueInfo(p,a,b,c,d)
#define IDirectPlay8Peer_Host(p,a,b,c,d,e,f,g)						(p)->lpVtbl->Host(p,a,b,c,d,e,f,g)
#define IDirectPlay8Peer_GetApplicationDesc(p,a,b,c)				(p)->lpVtbl->GetApplicationDesc(p,a,b,c)
#define IDirectPlay8Peer_SetApplicationDesc(p,a,b)					(p)->lpVtbl->SetApplicationDesc(p,a,b)
#define IDirectPlay8Peer_CreateGroup(p,a,b,c,d,e)					(p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay8Peer_DestroyGroup(p,a,b,c,d)					(p)->lpVtbl->DestroyGroup(p,a,b,c,d)
#define IDirectPlay8Peer_AddPlayerToGroup(p,a,b,c,d,e)				(p)->lpVtbl->AddPlayerToGroup(p,a,b,c,d,e)
#define IDirectPlay8Peer_RemovePlayerFromGroup(p,a,b,c,d,e)			(p)->lpVtbl->RemovePlayerFromGroup(p,a,b,c,d,e)
#define IDirectPlay8Peer_SetGroupInfo(p,a,b,c,d,e)					(p)->lpVtbl->SetGroupInfo(p,a,b,c,d,e)
#define IDirectPlay8Peer_GetGroupInfo(p,a,b,c,d)					(p)->lpVtbl->GetGroupInfo(p,a,b,c,d)
#define IDirectPlay8Peer_EnumPlayersAndGroups(p,a,b,c)				(p)->lpVtbl->EnumPlayersAndGroups(p,a,b,c)
#define IDirectPlay8Peer_EnumGroupMembers(p,a,b,c,d)				(p)->lpVtbl->EnumGroupMembers(p,a,b,c,d)
#define IDirectPlay8Peer_SetPeerInfo(p,a,b,c,d)						(p)->lpVtbl->SetPeerInfo(p,a,b,c,d)
#define IDirectPlay8Peer_GetPeerInfo(p,a,b,c,d)						(p)->lpVtbl->GetPeerInfo(p,a,b,c,d)
#define IDirectPlay8Peer_GetPeerAddress(p,a,b,c)					(p)->lpVtbl->GetPeerAddress(p,a,b,c)
#define IDirectPlay8Peer_GetLocalHostAddresses(p,a,b,c)				(p)->lpVtbl->GetLocalHostAddresses(p,a,b,c)
#define IDirectPlay8Peer_Close(p,a)									(p)->lpVtbl->Close(p,a)
#define IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)			(p)->lpVtbl->EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)
#define IDirectPlay8Peer_DestroyPeer(p,a,b,c,d)						(p)->lpVtbl->DestroyPeer(p,a,b,c,d)
#define IDirectPlay8Peer_ReturnBuffer(p,a,b)						(p)->lpVtbl->ReturnBuffer(p,a,b)
#define IDirectPlay8Peer_GetPlayerContext(p,a,b,c)					(p)->lpVtbl->GetPlayerContext(p,a,b,c)
#define IDirectPlay8Peer_GetGroupContext(p,a,b,c)					(p)->lpVtbl->GetGroupContext(p,a,b,c)
#define IDirectPlay8Peer_GetCaps(p,a,b)								(p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay8Peer_SetCaps(p,a,b)								(p)->lpVtbl->SetCaps(p,a,b)
#define IDirectPlay8Peer_SetSPCaps(p,a,b,c)							(p)->lpVtbl->SetSPCaps(p,a,b,c)
#define IDirectPlay8Peer_GetSPCaps(p,a,b,c)							(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define IDirectPlay8Peer_GetConnectionInfo(p,a,b,c)					(p)->lpVtbl->GetConnectionInfo(p,a,b,c)
#define IDirectPlay8Peer_RegisterLobby(p,a,b,c)						(p)->lpVtbl->RegisterLobby(p,a,b,c)
#define IDirectPlay8Peer_TerminateSession(p,a,b,c)					(p)->lpVtbl->TerminateSession(p,a,b,c)

//@@BEGIN_MSINTERNAL
#define IDirectPlay8ThreadPool_QueryInterface(p,a,b)				(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8ThreadPool_AddRef(p)							(p)->lpVtbl->AddRef(p)
#define IDirectPlay8ThreadPool_Release(p)							(p)->lpVtbl->Release(p)
#define IDirectPlay8ThreadPool_Initialize(p,a,b,c)					(p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectPlay8ThreadPool_Close(p,a)							(p)->lpVtbl->Close(p,a)
#define IDirectPlay8ThreadPool_GetThreadCount(p,a,b,c)				(p)->lpVtbl->GetThreadCount(p,a,b,c)
#define IDirectPlay8ThreadPool_SetThreadCount(p,a,b,c)				(p)->lpVtbl->SetThreadCount(p,a,b,c)
#define IDirectPlay8ThreadPool_DoWork(p,a,b)						(p)->lpVtbl->DoWork(p,a,b)

#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONETHREAD)) && (! defined(DPNBUILD_MULTIPLETHREADPOOLS)))
#define IDirectPlay8ThreadPoolWork_AddRef(p)
#define IDirectPlay8ThreadPoolWork_Release(p)
#else // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
#define IDirectPlay8ThreadPoolWork_QueryInterface(p,a,b)			(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8ThreadPoolWork_AddRef(p)						(p)->lpVtbl->AddRef(p)
#define IDirectPlay8ThreadPoolWork_Release(p)						(p)->lpVtbl->Release(p)
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
#define IDirectPlay8ThreadPoolWork_QueueWorkItem(p,a,b,c,d)			(p)->lpVtbl->QueueWorkItem(p,a,b,c,d)
#define IDirectPlay8ThreadPoolWork_ScheduleTimer(p,a,b,c,d,e,f,g)	(p)->lpVtbl->ScheduleTimer(p,a,b,c,d,e,f,g)
#define IDirectPlay8ThreadPoolWork_StartTrackingFileIo(p,a,b,c)		(p)->lpVtbl->StartTrackingFileIo(p,a,b,c)
#define IDirectPlay8ThreadPoolWork_StopTrackingFileIo(p,a,b,c)		(p)->lpVtbl->StopTrackingFileIo(p,a,b,c)
#define IDirectPlay8ThreadPoolWork_CreateOverlapped(p,a,b,c,d,e)	(p)->lpVtbl->CreateOverlapped(p,a,b,c,d,e)
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
#define IDirectPlay8ThreadPoolWork_SubmitIoOperation(p,a,b)			((HRESULT) DPN_OK)
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
#define IDirectPlay8ThreadPoolWork_SubmitIoOperation(p,a,b)			(p)->lpVtbl->SubmitIoOperation(p,a,b)
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
#define IDirectPlay8ThreadPoolWork_ReleaseOverlapped(p,a,b)			(p)->lpVtbl->ReleaseOverlapped(p,a,b)
#define IDirectPlay8ThreadPoolWork_CancelTimer(p,a,b,c)				(p)->lpVtbl->CancelTimer(p,a,b,c)
#define IDirectPlay8ThreadPoolWork_ResetCompletingTimer(p,a,b,c,d,e,f)	(p)->lpVtbl->ResetCompletingTimer(p,a,b,c,d,e,f)
#define IDirectPlay8ThreadPoolWork_WaitWhileWorking(p,a,b)			(p)->lpVtbl->WaitWhileWorking(p,a,b)
#define IDirectPlay8ThreadPoolWork_SleepWhileWorking(p,a,b)			(p)->lpVtbl->SleepWhileWorking(p,a,b)
#define IDirectPlay8ThreadPoolWork_RequestTotalThreadCount(p,a,b)	(p)->lpVtbl->RequestTotalThreadCount(p,a,b)
#define IDirectPlay8ThreadPoolWork_GetThreadCount(p,a,b,c)			(p)->lpVtbl->GetThreadCount(p,a,b,c)
#define IDirectPlay8ThreadPoolWork_GetWorkRecursionDepth(p,a,b)		(p)->lpVtbl->GetWorkRecursionDepth(p,a,b)
#define IDirectPlay8ThreadPoolWork_Preallocate(p,a,b,c,d)			(p)->lpVtbl->Preallocate(p,a,b,c,d)
#ifdef DPNBUILD_MANDATORYTHREADS
#define IDirectPlay8ThreadPoolWork_CreateMandatoryThread(p,a,b,c,d,e,f,g)	(p)->lpVtbl->CreateMandatoryThread(p,a,b,c,d,e,f,g)
#endif // DPNBUILD_MANDATORYTHREADS

#ifndef DPNBUILD_NOMULTICAST
#define IDirectPlay8Multicast_QueryInterface(p,a,b)					(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8Multicast_AddRef(p)								(p)->lpVtbl->AddRef(p)
#define IDirectPlay8Multicast_Release(p)							(p)->lpVtbl->Release(p)
#define IDirectPlay8Multicast_Initialize(p,a,b,c)					(p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectPlay8Multicast_Join(p,a,b,c,d,e,f,g)					(p)->lpVtbl->Join(p,a,b,c,d,e,f,g)
#define IDirectPlay8Multicast_Close(p,a)							(p)->lpVtbl->Close(p,a)
#define IDirectPlay8Multicast_CreateSenderContext(p,a,b,c)			(p)->lpVtbl->CreateSenderContext(p,a,b,c)
#define IDirectPlay8Multicast_DestroySenderContext(p,a,b,c)			(p)->lpVtbl->DestroySenderContext(p,a,b,c)
#define IDirectPlay8Multicast_Send(p,a,b,c,d,e,f)					(p)->lpVtbl->SendTo(p,a,b,c,d,e,f)
#define IDirectPlay8Multicast_GetGroupAddress(p,a,b)				(p)->lpVtbl->GetGroupAddress(p,a,b)
#define IDirectPlay8Multicast_GetSendQueueInfo(p,a,b,c)				(p)->lpVtbl->GetSendQueueInfo(p,a,b,c)
#define IDirectPlay8Multicast_CancelAsyncOperation(p,a,b)			(p)->lpVtbl->CancelAsyncOperation(p,a,b)
#define IDirectPlay8Multicast_ReturnBuffer(p,a,b)					(p)->lpVtbl->ReturnBuffer(p,a,b)
#define IDirectPlay8Multicast_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->lpVtbl->EnumServiceProviders(p,a,b,c,d,e,f)
#define IDirectPlay8Multicast_EnumMulticastScopes(p,a,b,c,d,e,f,g)	(p)->lpVtbl->EnumMulticastScopes(p,a,b,c,d,e,f,g)
#define IDirectPlay8Multicast_GetSPCaps(p,a,b,c)					(p)->lpVtbl->GetSPCaps(p,a,b,c)
#define IDirectPlay8Multicast_SetSPCaps(p,a,b,c)					(p)->lpVtbl->SetSPCaps(p,a,b,c)
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL

#else /* C++ */

#define IDirectPlay8Client_QueryInterface(p,a,b)					(p)->QueryInterface(a,b)
#define IDirectPlay8Client_AddRef(p)								(p)->AddRef()
#define IDirectPlay8Client_Release(p)								(p)->Release()
#define IDirectPlay8Client_Initialize(p,a,b,c)						(p)->Initialize(a,b,c)
#define IDirectPlay8Client_EnumServiceProviders(p,a,b,c,d,e,f)		(p)->EnumServiceProviders(a,b,c,d,e,f)
#define IDirectPlay8Client_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)		(p)->EnumHosts(a,b,c,d,e,f,g,h,i,j,k)
#define IDirectPlay8Client_CancelAsyncOperation(p,a,b)				(p)->CancelAsyncOperation(a,b)
#define IDirectPlay8Client_Connect(p,a,b,c,d,e,f,g,h,i,j)			(p)->Connect(a,b,c,d,e,f,g,h,i,j)
#define IDirectPlay8Client_Send(p,a,b,c,d,e,f)						(p)->Send(a,b,c,d,e,f)
#define IDirectPlay8Client_GetSendQueueInfo(p,a,b,c)				(p)->GetSendQueueInfo(a,b,c)
#define IDirectPlay8Client_GetApplicationDesc(p,a,b,c)				(p)->GetApplicationDesc(a,b,c)
#define IDirectPlay8Client_SetClientInfo(p,a,b,c,d)					(p)->SetClientInfo(a,b,c,d)
#define IDirectPlay8Client_GetServerInfo(p,a,b,c)					(p)->GetServerInfo(a,b,c)
#define IDirectPlay8Client_GetServerAddress(p,a,b)					(p)->GetServerAddress(a,b)
#define IDirectPlay8Client_Close(p,a)								(p)->Close(a)
#define IDirectPlay8Client_ReturnBuffer(p,a,b)						(p)->ReturnBuffer(a,b)
#define IDirectPlay8Client_GetCaps(p,a,b)							(p)->GetCaps(a,b)
#define IDirectPlay8Client_SetCaps(p,a,b)							(p)->SetCaps(a,b)
#define IDirectPlay8Client_SetSPCaps(p,a,b,c)						(p)->SetSPCaps(a,b,c)
#define IDirectPlay8Client_GetSPCaps(p,a,b,c)						(p)->GetSPCaps(a,b,c)
#define IDirectPlay8Client_GetConnectionInfo(p,a,b)					(p)->GetConnectionInfo(a,b)
#define IDirectPlay8Client_RegisterLobby(p,a,b,c)					(p)->RegisterLobby(a,b,c)

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSERVER
//@@END_MSINTERNAL
#define IDirectPlay8Server_QueryInterface(p,a,b)					(p)->QueryInterface(a,b)
#define IDirectPlay8Server_AddRef(p)								(p)->AddRef()
#define IDirectPlay8Server_Release(p)								(p)->Release()
#define IDirectPlay8Server_Initialize(p,a,b,c)						(p)->Initialize(a,b,c)
#define IDirectPlay8Server_EnumServiceProviders(p,a,b,c,d,e,f)		(p)->EnumServiceProviders(a,b,c,d,e,f)
#define IDirectPlay8Server_CancelAsyncOperation(p,a,b)				(p)->CancelAsyncOperation(a,b)
#define IDirectPlay8Server_GetSendQueueInfo(p,a,b,c,d)				(p)->GetSendQueueInfo(a,b,c,d)
#define IDirectPlay8Server_GetApplicationDesc(p,a,b,c)				(p)->GetApplicationDesc(a,b,c)
#define IDirectPlay8Server_SetServerInfo(p,a,b,c,d)					(p)->SetServerInfo(a,b,c,d)
#define IDirectPlay8Server_GetClientInfo(p,a,b,c,d)					(p)->GetClientInfo(a,b,c,d)
#define IDirectPlay8Server_GetClientAddress(p,a,b,c)				(p)->GetClientAddress(a,b,c)
#define IDirectPlay8Server_GetLocalHostAddresses(p,a,b,c)			(p)->GetLocalHostAddresses(a,b,c)
#define IDirectPlay8Server_SetApplicationDesc(p,a,b)				(p)->SetApplicationDesc(a,b)
#define IDirectPlay8Server_Host(p,a,b,c,d,e,f,g)					(p)->Host(a,b,c,d,e,f,g)
#define IDirectPlay8Server_SendTo(p,a,b,c,d,e,f,g)					(p)->SendTo(a,b,c,d,e,f,g)
#define IDirectPlay8Server_CreateGroup(p,a,b,c,d,e)					(p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay8Server_DestroyGroup(p,a,b,c,d)					(p)->DestroyGroup(a,b,c,d)
#define IDirectPlay8Server_AddPlayerToGroup(p,a,b,c,d,e)			(p)->AddPlayerToGroup(a,b,c,d,e)
#define IDirectPlay8Server_RemovePlayerFromGroup(p,a,b,c,d,e)		(p)->RemovePlayerFromGroup(a,b,c,d,e)
#define IDirectPlay8Server_SetGroupInfo(p,a,b,c,d,e)				(p)->SetGroupInfo(a,b,c,d,e)
#define IDirectPlay8Server_GetGroupInfo(p,a,b,c,d)					(p)->GetGroupInfo(a,b,c,d)
#define IDirectPlay8Server_EnumPlayersAndGroups(p,a,b,c)			(p)->EnumPlayersAndGroups(a,b,c)
#define IDirectPlay8Server_EnumGroupMembers(p,a,b,c,d)				(p)->EnumGroupMembers(a,b,c,d)
#define IDirectPlay8Server_Close(p,a)								(p)->Close(a)
#define IDirectPlay8Server_DestroyClient(p,a,b,c,d)					(p)->DestroyClient(a,b,c,d)
#define IDirectPlay8Server_ReturnBuffer(p,a,b)						(p)->ReturnBuffer(a,b)
#define IDirectPlay8Server_GetPlayerContext(p,a,b,c)				(p)->GetPlayerContext(a,b,c)
#define IDirectPlay8Server_GetGroupContext(p,a,b,c)					(p)->GetGroupContext(a,b,c)
#define IDirectPlay8Server_GetCaps(p,a,b)							(p)->GetCaps(a,b)
#define IDirectPlay8Server_SetCaps(p,a,b)							(p)->SetCaps(a,b)
#define IDirectPlay8Server_SetSPCaps(p,a,b,c)						(p)->SetSPCaps(a,b,c)
#define IDirectPlay8Server_GetSPCaps(p,a,b,c)						(p)->GetSPCaps(a,b,c)
#define IDirectPlay8Server_GetConnectionInfo(p,a,b,c)				(p)->GetConnectionInfo(a,b,c)
#define IDirectPlay8Server_RegisterLobby(p,a,b,c)					(p)->RegisterLobby(a,b,c)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSERVER
//@@END_MSINTERNAL

#define IDirectPlay8Peer_QueryInterface(p,a,b)						(p)->QueryInterface(a,b)
#define IDirectPlay8Peer_AddRef(p)									(p)->AddRef()
#define IDirectPlay8Peer_Release(p)									(p)->Release()
#define IDirectPlay8Peer_Initialize(p,a,b,c)						(p)->Initialize(a,b,c)
#define IDirectPlay8Peer_EnumServiceProviders(p,a,b,c,d,e,f)		(p)->EnumServiceProviders(a,b,c,d,e,f)
#define IDirectPlay8Peer_CancelAsyncOperation(p,a,b)				(p)->CancelAsyncOperation(a,b)
#define IDirectPlay8Peer_Connect(p,a,b,c,d,e,f,g,h,i,j,k)			(p)->Connect(a,b,c,d,e,f,g,h,i,j,k)
#define IDirectPlay8Peer_SendTo(p,a,b,c,d,e,f,g)					(p)->SendTo(a,b,c,d,e,f,g)
#define IDirectPlay8Peer_GetSendQueueInfo(p,a,b,c,d)				(p)->GetSendQueueInfo(a,b,c,d)
#define IDirectPlay8Peer_Host(p,a,b,c,d,e,f,g)						(p)->Host(a,b,c,d,e,f,g)
#define IDirectPlay8Peer_GetApplicationDesc(p,a,b,c)				(p)->GetApplicationDesc(a,b,c)
#define IDirectPlay8Peer_SetApplicationDesc(p,a,b)					(p)->SetApplicationDesc(a,b)
#define IDirectPlay8Peer_CreateGroup(p,a,b,c,d,e)					(p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay8Peer_DestroyGroup(p,a,b,c,d)					(p)->DestroyGroup(a,b,c,d)
#define IDirectPlay8Peer_AddPlayerToGroup(p,a,b,c,d,e)				(p)->AddPlayerToGroup(a,b,c,d,e)
#define IDirectPlay8Peer_RemovePlayerFromGroup(p,a,b,c,d,e)			(p)->RemovePlayerFromGroup(a,b,c,d,e)
#define IDirectPlay8Peer_SetGroupInfo(p,a,b,c,d,e)					(p)->SetGroupInfo(a,b,c,d,e)
#define IDirectPlay8Peer_GetGroupInfo(p,a,b,c,d)					(p)->GetGroupInfo(a,b,c,d)
#define IDirectPlay8Peer_EnumPlayersAndGroups(p,a,b,c)				(p)->EnumPlayersAndGroups(a,b,c)
#define IDirectPlay8Peer_EnumGroupMembers(p,a,b,c,d)				(p)->EnumGroupMembers(a,b,c,d)
#define IDirectPlay8Peer_SetPeerInfo(p,a,b,c,d)						(p)->SetPeerInfo(a,b,c,d)
#define IDirectPlay8Peer_GetPeerInfo(p,a,b,c,d)						(p)->GetPeerInfo(a,b,c,d)
#define IDirectPlay8Peer_GetPeerAddress(p,a,b,c)					(p)->GetPeerAddress(a,b,c)
#define IDirectPlay8Peer_GetLocalHostAddresses(p,a,b,c)				(p)->GetLocalHostAddresses(a,b,c)
#define IDirectPlay8Peer_Close(p,a)									(p)->Close(a)
#define IDirectPlay8Peer_EnumHosts(p,a,b,c,d,e,f,g,h,i,j,k)			(p)->EnumHosts(a,b,c,d,e,f,g,h,i,j,k)
#define IDirectPlay8Peer_DestroyPeer(p,a,b,c,d)						(p)->DestroyPeer(a,b,c,d)
#define IDirectPlay8Peer_ReturnBuffer(p,a,b)						(p)->ReturnBuffer(a,b)
#define IDirectPlay8Peer_GetPlayerContext(p,a,b,c)					(p)->GetPlayerContext(a,b,c)
#define IDirectPlay8Peer_GetGroupContext(p,a,b,c)					(p)->GetGroupContext(a,b,c)
#define IDirectPlay8Peer_GetCaps(p,a,b)								(p)->GetCaps(a,b)
#define IDirectPlay8Peer_SetCaps(p,a,b)								(p)->SetCaps(a,b)
#define IDirectPlay8Peer_SetSPCaps(p,a,b,c)							(p)->SetSPCaps(a,b,c)
#define IDirectPlay8Peer_GetSPCaps(p,a,b,c)							(p)->GetSPCaps(a,b,c)
#define IDirectPlay8Peer_GetConnectionInfo(p,a,b,c)					(p)->GetConnectionInfo(a,b,c)
#define IDirectPlay8Peer_RegisterLobby(p,a,b,c)						(p)->RegisterLobby(a,b,c)
#define IDirectPlay8Peer_TerminateSession(p,a,b,c)					(p)->TerminateSession(a,b,c)

//@@BEGIN_MSINTERNAL
#define IDirectPlay8ThreadPool_QueryInterface(p,a,b)				(p)->QueryInterface(a,b)
#define IDirectPlay8ThreadPool_AddRef(p)							(p)->AddRef()
#define IDirectPlay8ThreadPool_Release(p)							(p)->Release()
#define IDirectPlay8ThreadPool_Initialize(p,a,b,c)					(p)->Initialize(a,b,c)
#define IDirectPlay8ThreadPool_Close(p,a)							(p)->Close(a)
#define IDirectPlay8ThreadPool_GetThreadCount(p,a,b,c)				(p)->GetThreadCount(a,b,c)
#define IDirectPlay8ThreadPool_SetThreadCount(p,a,b,c)				(p)->SetThreadCount(a,b,c)
#define IDirectPlay8ThreadPool_DoWork(p,a,b)						(p)->DoWork(a,b)

#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONETHREAD)) && (! defined(DPNBUILD_MULTIPLETHREADPOOLS)))
#define IDirectPlay8ThreadPoolWork_AddRef(p)
#define IDirectPlay8ThreadPoolWork_Release(p)
#else // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
#define IDirectPlay8ThreadPoolWork_QueryInterface(p,a,b)			(p)->QueryInterface(a,b)
#define IDirectPlay8ThreadPoolWork_AddRef(p)						(p)->AddRef()
#define IDirectPlay8ThreadPoolWork_Release(p)						(p)->Release()
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
#define IDirectPlay8ThreadPoolWork_QueueWorkItem(p,a,b,c,d)			(p)->QueueWorkItem(a,b,c,d)
#define IDirectPlay8ThreadPoolWork_ScheduleTimer(p,a,b,c,d,e,f,g)	(p)->ScheduleTimer(a,b,c,d,e,f,g)
#define IDirectPlay8ThreadPoolWork_StartTrackingFileIo(p,a,b,c)		(p)->StartTrackingFileIo(p,a,b,c)
#define IDirectPlay8ThreadPoolWork_StopTrackingFileIo(p,a,b,c)		(p)->StopTrackingFileIo(a,b,c)
#define IDirectPlay8ThreadPoolWork_CreateOverlapped(p,a,b,c,d,e)	(p)->CreateOverlapped(a,b,c,d,e)
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
#define IDirectPlay8ThreadPoolWork_SubmitIoOperation(p,a,b)			((HRESULT) DPN_OK)
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
#define IDirectPlay8ThreadPoolWork_SubmitIoOperation(p,a,b)			(p)->SubmitIoOperation(a,b)
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
#define IDirectPlay8ThreadPoolWork_ReleaseOverlapped(p,a,b)			(p)->ReleaseOverlapped(a,b)
#define IDirectPlay8ThreadPoolWork_CancelTimer(p,a,b,c)				(p)->CancelTimer(a,b,c)
#define IDirectPlay8ThreadPoolWork_ResetCompletingTimer(p,a,b,c,d,e,f)	(p)->ResetCompletingTimer(a,b,c,d,e,f)
#define IDirectPlay8ThreadPoolWork_WaitWhileWorking(p,a,b)			(p)->WaitWhileWorking(a,b)
#define IDirectPlay8ThreadPoolWork_SleepWhileWorking(p,a,b)			(p)->SleepWhileWorking(a,b)
#define IDirectPlay8ThreadPoolWork_RequestTotalThreadCount(p,a,b)	(p)->RequestTotalThreadCount(a,b)
#define IDirectPlay8ThreadPoolWork_GetThreadCount(p,a,b,c)			(p)->GetThreadCount(a,b,c)
#define IDirectPlay8ThreadPoolWork_GetWorkRecursionDepth(p,a,b)		(p)->GetWorkRecursionDepth(a,b)
#define IDirectPlay8ThreadPoolWork_Preallocate(p,a,b,c,d)			(p)->Preallocate(a,b,c,d)
#ifdef DPNBUILD_MANDATORYTHREADS
#define IDirectPlay8ThreadPoolWork_CreateMandatoryThread(p,a,b,c,d,e,f,g)	(p)->CreateMandatoryThread(a,b,c,d,e,f,g)
#endif // DPNBUILD_MANDATORYTHREADS

#ifndef DPNBUILD_NOMULTICAST
#define IDirectPlay8Multicast_QueryInterface(p,a,b)					(p)->QueryInterface(a,b)
#define IDirectPlay8Multicast_AddRef(p)								(p)->AddRef()
#define IDirectPlay8Multicast_Release(p)							(p)->Release()
#define IDirectPlay8Multicast_Initialize(p,a,b,c)					(p)->Initialize(a,b,c)
#define IDirectPlay8Multicast_Join(p,a,b,c,d,e,f,g)					(p)->Join(a,b,c,d,e,f,g)
#define IDirectPlay8Multicast_Close(p,a)							(p)->Close(a)
#define IDirectPlay8Multicast_CreateSenderContext(p,a,b,c)			(p)->CreateSenderContext(a,b,c)
#define IDirectPlay8Multicast_DestroySenderContext(p,a,b,c)			(p)->DestroySenderContext(a,b,c)
#define IDirectPlay8Multicast_Send(p,a,b,c,d,e,f)					(p)->SendTo(a,b,c,d,e,f)
#define IDirectPlay8Multicast_GetGroupAddress(p,a,b)				(p)->GetGroupAddress(a,b)
#define IDirectPlay8Multicast_GetSendQueueInfo(p,a,b,c)				(p)->GetSendQueueInfo(a,b,c)
#define IDirectPlay8Multicast_CancelAsyncOperation(p,a,b)			(p)->CancelAsyncOperation(a,b)
#define IDirectPlay8Multicast_ReturnBuffer(p,a,b)					(p)->ReturnBuffer(a,b)
#define IDirectPlay8Multicast_EnumServiceProviders(p,a,b,c,d,e,f)	(p)->EnumServiceProviders(a,b,c,d,e,f)
#define IDirectPlay8Multicast_EnumMulticastScopes(p,a,b,c,d,e,f,g)	(p)->EnumMulticastScopes(a,b,c,d,e,f,g)
#define IDirectPlay8Multicast_GetSPCaps(p,a,b,c)					(p)->GetSPCaps(a,b,c)
#define IDirectPlay8Multicast_SetSPCaps(p,a,b,c)					(p)->SetSPCaps(a,b,c)
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL

#endif



/****************************************************************************
 *
 * DIRECTPLAY8 ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DPN_FACILITY_CODE				0x015
#define _DPNHRESULT_BASE				0x8000
#define MAKE_DPNHRESULT( code )			MAKE_HRESULT( 1, _DPN_FACILITY_CODE, ( code + _DPNHRESULT_BASE ) )

#define DPN_OK							S_OK

#define DPNSUCCESS_EQUAL				MAKE_HRESULT( 0, _DPN_FACILITY_CODE, ( 0x5 + _DPNHRESULT_BASE ) )
//@@BEGIN_MSINTERNAL
#define DPNSUCCESS_NOPLAYERSINGROUP		MAKE_HRESULT( 0, _DPN_FACILITY_CODE, ( 0x8 + _DPNHRESULT_BASE ) )	// added for DirectX 9
//@@END_MSINTERNAL
#define DPNSUCCESS_NOTEQUAL				MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0A + _DPNHRESULT_BASE ) )
#define DPNSUCCESS_PENDING				MAKE_HRESULT( 0, _DPN_FACILITY_CODE, (0x0e + _DPNHRESULT_BASE ) )

#define DPNERR_ABORTED					MAKE_DPNHRESULT(  0x30 )
#define DPNERR_ADDRESSING				MAKE_DPNHRESULT(  0x40 )
#define DPNERR_ALREADYCLOSING			MAKE_DPNHRESULT(  0x50 )
#define DPNERR_ALREADYCONNECTED			MAKE_DPNHRESULT(  0x60 )
#define DPNERR_ALREADYDISCONNECTING		MAKE_DPNHRESULT(  0x70 )
#define DPNERR_ALREADYINITIALIZED		MAKE_DPNHRESULT(  0x80 )
#define DPNERR_ALREADYREGISTERED		MAKE_DPNHRESULT(  0x90 )
#define DPNERR_BUFFERTOOSMALL			MAKE_DPNHRESULT( 0x100 )
#define DPNERR_CANNOTCANCEL				MAKE_DPNHRESULT( 0x110 )
#define DPNERR_CANTCREATEGROUP			MAKE_DPNHRESULT( 0x120 )
#define DPNERR_CANTCREATEPLAYER			MAKE_DPNHRESULT( 0x130 )
#define DPNERR_CANTLAUNCHAPPLICATION	MAKE_DPNHRESULT( 0x140 )
#define DPNERR_CONNECTING				MAKE_DPNHRESULT( 0x150 )
#define DPNERR_CONNECTIONLOST			MAKE_DPNHRESULT( 0x160 )
#define DPNERR_CONVERSION				MAKE_DPNHRESULT( 0x170 )
#define DPNERR_DATATOOLARGE				MAKE_DPNHRESULT( 0x175 )
#define DPNERR_DOESNOTEXIST				MAKE_DPNHRESULT( 0x180 )
#define DPNERR_DPNSVRNOTAVAILABLE		MAKE_DPNHRESULT( 0x185 )
#define DPNERR_DUPLICATECOMMAND			MAKE_DPNHRESULT( 0x190 )
#define DPNERR_ENDPOINTNOTRECEIVING		MAKE_DPNHRESULT( 0x200 )
#define DPNERR_ENUMQUERYTOOLARGE		MAKE_DPNHRESULT( 0x210 )
#define DPNERR_ENUMRESPONSETOOLARGE		MAKE_DPNHRESULT( 0x220 )
#define DPNERR_EXCEPTION				MAKE_DPNHRESULT( 0x230 )
#define DPNERR_GENERIC					E_FAIL
#define DPNERR_GROUPNOTEMPTY			MAKE_DPNHRESULT( 0x240 )
#define DPNERR_HOSTING					MAKE_DPNHRESULT( 0x250 )
#define DPNERR_HOSTREJECTEDCONNECTION	MAKE_DPNHRESULT( 0x260 )
#define DPNERR_HOSTTERMINATEDSESSION	MAKE_DPNHRESULT( 0x270 )
#define DPNERR_INCOMPLETEADDRESS		MAKE_DPNHRESULT( 0x280 )
#define DPNERR_INVALIDADDRESSFORMAT		MAKE_DPNHRESULT( 0x290 )
#define DPNERR_INVALIDAPPLICATION		MAKE_DPNHRESULT( 0x300 )
#define DPNERR_INVALIDCOMMAND			MAKE_DPNHRESULT( 0x310 )
#define DPNERR_INVALIDDEVICEADDRESS		MAKE_DPNHRESULT( 0x320 )
#define DPNERR_INVALIDENDPOINT			MAKE_DPNHRESULT( 0x330 )
#define DPNERR_INVALIDFLAGS				MAKE_DPNHRESULT( 0x340 )
#define DPNERR_INVALIDGROUP			 	MAKE_DPNHRESULT( 0x350 )
#define DPNERR_INVALIDHANDLE			MAKE_DPNHRESULT( 0x360 )
#define DPNERR_INVALIDHOSTADDRESS		MAKE_DPNHRESULT( 0x370 )
#define DPNERR_INVALIDINSTANCE			MAKE_DPNHRESULT( 0x380 )
#define DPNERR_INVALIDINTERFACE			MAKE_DPNHRESULT( 0x390 )
#define DPNERR_INVALIDOBJECT			MAKE_DPNHRESULT( 0x400 )
#define DPNERR_INVALIDPARAM				E_INVALIDARG
#define DPNERR_INVALIDPASSWORD			MAKE_DPNHRESULT( 0x410 )
#define DPNERR_INVALIDPLAYER			MAKE_DPNHRESULT( 0x420 )
#define DPNERR_INVALIDPOINTER			E_POINTER
#define DPNERR_INVALIDPRIORITY			MAKE_DPNHRESULT( 0x430 )
#define DPNERR_INVALIDSTRING			MAKE_DPNHRESULT( 0x440 )
#define DPNERR_INVALIDURL				MAKE_DPNHRESULT( 0x450 )
#define DPNERR_INVALIDVERSION			MAKE_DPNHRESULT( 0x460 )
#define DPNERR_NOCAPS					MAKE_DPNHRESULT( 0x470 )
#define DPNERR_NOCONNECTION				MAKE_DPNHRESULT( 0x480 )
#define DPNERR_NOHOSTPLAYER				MAKE_DPNHRESULT( 0x490 )
#define DPNERR_NOINTERFACE				E_NOINTERFACE
#define DPNERR_NOMOREADDRESSCOMPONENTS	MAKE_DPNHRESULT( 0x500 )
#define DPNERR_NORESPONSE				MAKE_DPNHRESULT( 0x510 )
#define DPNERR_NOTALLOWED				MAKE_DPNHRESULT( 0x520 )
#define DPNERR_NOTHOST					MAKE_DPNHRESULT( 0x530 )
#define DPNERR_NOTREADY					MAKE_DPNHRESULT( 0x540 )
#define DPNERR_NOTREGISTERED			MAKE_DPNHRESULT( 0x550 )
#define DPNERR_OUTOFMEMORY				E_OUTOFMEMORY
#define DPNERR_PENDING					DPNSUCCESS_PENDING
#define DPNERR_PLAYERALREADYINGROUP		MAKE_DPNHRESULT( 0x560 )
#define DPNERR_PLAYERLOST				MAKE_DPNHRESULT( 0x570 )
#define DPNERR_PLAYERNOTINGROUP			MAKE_DPNHRESULT( 0x580 )
#define DPNERR_PLAYERNOTREACHABLE		MAKE_DPNHRESULT( 0x590 )
#define DPNERR_SENDTOOLARGE				MAKE_DPNHRESULT( 0x600 )
#define DPNERR_SESSIONFULL				MAKE_DPNHRESULT( 0x610 )
#define DPNERR_TABLEFULL				MAKE_DPNHRESULT( 0x620 )
#define DPNERR_TIMEDOUT					MAKE_DPNHRESULT( 0x630 )
#define DPNERR_UNINITIALIZED			MAKE_DPNHRESULT( 0x640 )
#define DPNERR_UNSUPPORTED				E_NOTIMPL
#define DPNERR_USERCANCEL				MAKE_DPNHRESULT( 0x650 )

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\inc\dplobby8.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLobby.h
 *  Content:    DirectPlay8 Lobby Include File
 *@@BEGIN_MSINTERNAL
 *  History:
 *  Date        By      Reason
 *  ====        ==      ======
 *  02/21/00	mjn		Created
 *	03/22/2000	jtk		Changed interface names
 *  04/25/2000  rmt     Bug #s 33138, 33145, 33150
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  05/03/00    rmt     Bug #33879 -- Status messsage missing from field
 *  05/04/00    rmt     Bug #34146 - No PDIRECTPLAY8LOBBIEDAPPLICATION defined.
 *  05/08/00    rmt     Bug #34301 - Addd flag to SetAppAvailable to allow user to specify multiple client connects.
 *              rmt     Bug #34492 - Added hrReason field to disconnect message
 *  06/07/00	rmt		Bug #36382 - Splitting CLSID to fix whistler issues (CoCreate changed behaviour)
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *  06/15/2000  rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  03/17/2001	rmt		WINBUG #342420 - Commented out create functions 
 *  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DPLOBBY_H__
#define	__DPLOBBY_H__

#include <ole2.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 *
 * DirectPlay8Lobby CLSIDs
 *
 ****************************************************************************/

// {667955AD-6B3B-43ca-B949-BC69B5BAFF7F}
DEFINE_GUID(CLSID_DirectPlay8LobbiedApplication, 
0x667955ad, 0x6b3b, 0x43ca, 0xb9, 0x49, 0xbc, 0x69, 0xb5, 0xba, 0xff, 0x7f);

// {3B2B6775-70B6-45af-8DEA-A209C69559F3}
DEFINE_GUID(CLSID_DirectPlay8LobbyClient, 
0x3b2b6775, 0x70b6, 0x45af, 0x8d, 0xea, 0xa2, 0x9, 0xc6, 0x95, 0x59, 0xf3);

/****************************************************************************
 *
 * DirectPlay8Lobby Interface IIDs
 *
 ****************************************************************************/

// {819074A3-016C-11d3-AE14-006097B01411}
DEFINE_GUID(IID_IDirectPlay8LobbiedApplication,
0x819074a3, 0x16c, 0x11d3, 0xae, 0x14, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {819074A2-016C-11d3-AE14-006097B01411}
DEFINE_GUID(IID_IDirectPlay8LobbyClient,
0x819074a2, 0x16c, 0x11d3, 0xae, 0x14, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

/****************************************************************************
 *
 * DirectPlay8Lobby Interface Pointer 
 *
 ****************************************************************************/

typedef struct IDirectPlay8LobbiedApplication	*PDIRECTPLAY8LOBBIEDAPPLICATION;
typedef struct IDirectPlay8LobbyClient		    *PDIRECTPLAY8LOBBYCLIENT;

/****************************************************************************
 *
 * DirectPlay8 Lobby Message IDs
 *
 ****************************************************************************/

#define	DPL_MSGID_LOBBY						0x8000
#define	DPL_MSGID_RECEIVE					(0x0001 | DPL_MSGID_LOBBY)
#define	DPL_MSGID_CONNECT					(0x0002 | DPL_MSGID_LOBBY)
#define DPL_MSGID_DISCONNECT				(0x0003 | DPL_MSGID_LOBBY)
#define	DPL_MSGID_SESSION_STATUS			(0x0004 | DPL_MSGID_LOBBY)
#define DPL_MSGID_CONNECTION_SETTINGS       (0x0005 | DPL_MSGID_LOBBY)

/****************************************************************************
 *
 * DirectPlay8Lobby Constants
 *
 ****************************************************************************/

//
// Specifies that operation should be performed on all open connections
//
#define DPLHANDLE_ALLCONNECTIONS			0xFFFFFFFF

// 
// The associated game session has suceeded in connecting / hosting
//
#define	DPLSESSION_CONNECTED				0x0001

// The associated game session failed connecting / hosting
//
#define	DPLSESSION_COULDNOTCONNECT			0x0002

//
// The associated game session has disconnected
//
#define	DPLSESSION_DISCONNECTED				0x0003

//
// The associated game session has terminated 
//
#define	DPLSESSION_TERMINATED				0x0004

// 
// The associated game session's host has migrated 
//
#define DPLSESSION_HOSTMIGRATED				0x0005

//
// The associated game session's host has migrated to the local client
//
#define DPLSESSION_HOSTMIGRATEDHERE			0x0006


/****************************************************************************
 *
 * DirectPlay8 Lobby Flags
 *
 ****************************************************************************/

//
// Do not automatically make the lobby app unavailable when a connection is established
//
#define DPLAVAILABLE_ALLOWMULTIPLECONNECT   0x0001

//
// Launch a new instance of the application to connect to
// 
#define	DPLCONNECT_LAUNCHNEW				0x0001

// 
// Launch a new instance of the application if one is not waiting
//
#define	DPLCONNECT_LAUNCHNOTFOUND			0x0002

//
// When starting the associated game session, start it as a host
//
#define DPLCONNECTSETTINGS_HOST             0x0001

// 
// Disable parameter validation
//
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOPARAMVAL
//@@END_MSINTERNAL
#define DPLINITIALIZE_DISABLEPARAMVAL		0x0001
//@@BEGIN_MSINTERNAL
#endif // !DPNBUILD_NOPARAMVAL
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DirectPlay8Lobby Structures (Non-Message)
 *
 ****************************************************************************/

// 
// Information on a registered game
//
typedef struct _DPL_APPLICATION_INFO {
	GUID	guidApplication;            // GUID of the application
	PWSTR	pwszApplicationName;        // Name of the application
	DWORD	dwNumRunning;               // # of instances of this application running
	DWORD	dwNumWaiting;               // # of instances of this application waiting 
	DWORD	dwFlags;                    // Flags
} DPL_APPLICATION_INFO,  *PDPL_APPLICATION_INFO;

//
// Settings to be used for connecting / hosting a game session
//
typedef struct _DPL_CONNECTION_SETTINGS {
    DWORD                   dwSize;                 // Size of this structure
    DWORD                   dwFlags;                // Connection settings flags (DPLCONNECTSETTINGS_...)
    DPN_APPLICATION_DESC    dpnAppDesc;             // Application desc for the associated DirectPlay session
    IDirectPlay8Address     *pdp8HostAddress;       // Address of host to connect to
    IDirectPlay8Address     **ppdp8DeviceAddresses; // Address of device to connect from / host on
    DWORD                   cNumDeviceAddresses;    // # of addresses specified in ppdp8DeviceAddresses
	PWSTR					pwszPlayerName;         // Name to give the player
} DPL_CONNECTION_SETTINGS, *PDPL_CONNECTION_SETTINGS;

//
// Information for performing a lobby connect
// (ConnectApplication)
//
typedef struct _DPL_CONNECT_INFO {
	DWORD	                    dwSize;             // Size of this structure
	DWORD	                    dwFlags;            // Flags (DPLCONNECT_...)
	GUID	                    guidApplication;    // GUID of application to launch
    PDPL_CONNECTION_SETTINGS	pdplConnectionSettings;
                                                    // Settings application should use
	PVOID	                    pvLobbyConnectData; // User defined data block
	DWORD	                    dwLobbyConnectDataSize;
                                                    // Size of user defined data block
} DPL_CONNECT_INFO,  *PDPL_CONNECT_INFO;

//
// Information for registering an application
// (RegisterApplication)
//
typedef struct  _DPL_PROGRAM_DESC {
	DWORD	dwSize;
	DWORD	dwFlags;
	GUID	guidApplication;		                // Application GUID
	PWSTR	pwszApplicationName;	                // Unicode application name
	PWSTR	pwszCommandLine;		                // Unicode command line arguments
	PWSTR	pwszCurrentDirectory;               	// Unicode current directory
	PWSTR	pwszDescription;		                // Unicode application description
	PWSTR	pwszExecutableFilename;	                // Unicode filename of application executable
	PWSTR	pwszExecutablePath;		                // Unicode path of application executable
	PWSTR	pwszLauncherFilename;	                // Unicode filename of launcher executable
	PWSTR	pwszLauncherPath;		                // Unicode path of launcher executable
} DPL_PROGRAM_DESC, *PDPL_PROGRAM_DESC;

/****************************************************************************
 *
 * DirectPlay8 Lobby Message Structures
 *
 ****************************************************************************/

//
// A connection was established 
// (DPL_MSGID_CONNECT)
//
typedef struct _DPL_MESSAGE_CONNECT
{
	DWORD		                dwSize;                     // Size of this structure
	DPNHANDLE	                hConnectId;                 // Handle of new connection
    PDPL_CONNECTION_SETTINGS	pdplConnectionSettings;	    // Connection settings for this connection
	PVOID		                pvLobbyConnectData;         // User defined lobby data block
	DWORD		                dwLobbyConnectDataSize;     // Size of user defined lobby data block
	PVOID						pvConnectionContext;        // Context value for this connection (user set)
} DPL_MESSAGE_CONNECT, *PDPL_MESSAGE_CONNECT;

// 
// Connection settings have been updated
// (DPL_MSGID_CONNECTION_SETTINGS)
//
typedef struct _DPL_MESSAGE_CONNECTION_SETTINGS
{
    DWORD                       dwSize;                     // Size of this structure
    DPNHANDLE                   hSender;                    // Handle of the connection for these settings
    PDPL_CONNECTION_SETTINGS    pdplConnectionSettings;     // Connection settings
	PVOID					    pvConnectionContext;        // Context value for this connection
} DPL_MESSAGE_CONNECTION_SETTINGS, *PDPL_MESSAGE_CONNECTION_SETTINGS;

//
// A connection has been disconnected
// (DPL_MSGID_DISCONNECT)
//
typedef struct _DPL_MESSAGE_DISCONNECT
{
	DWORD		dwSize;                                     // Size of this structure
	DPNHANDLE	hDisconnectId;                              // Handle of the connection that was terminated
	HRESULT     hrReason;                                   // Reason the connection was broken
	PVOID		pvConnectionContext;                        // Context value for this connection
} DPL_MESSAGE_DISCONNECT, *PDPL_MESSAGE_DISCONNECT;

//
// Data was received through a connection
// (DPL_MSGID_RECEIVE)
//
typedef struct _DPL_MESSAGE_RECEIVE
{
	DWORD		dwSize;                                     // Size of this structure
	DPNHANDLE	hSender;                                    // Handle of the connection that is from
	BYTE		*pBuffer;                                   // Contents of the message
	DWORD		dwBufferSize;                               // Size of the message context 
	PVOID		pvConnectionContext;                        // Context value for this connection
} DPL_MESSAGE_RECEIVE, *PDPL_MESSAGE_RECEIVE;

//
// Current status of the associated connection
// (DPL_MSGID_SESSION_STATUS)
//
typedef struct _DPL_MESSAGE_SESSION_STATUS
{
	DWORD		dwSize;                                     // Size of this structure
	DPNHANDLE	hSender;                                    // Handle of the connection that this is from
	DWORD		dwStatus;                                   // Status (DPLSESSION_...)
	PVOID		pvConnectionContext;                        // Context value for this connection
} DPL_MESSAGE_SESSION_STATUS, *PDPL_MESSAGE_SESSION_STATUS;

/****************************************************************************
 *
 * DirectPlay8Lobby Create
 *
 ****************************************************************************/
 
/*
 * This function is no longer supported.  It is recommended that CoCreateInstance be used to create 
 * DirectPlay8 lobby objects. 
 *
 * extern HRESULT WINAPI DirectPlay8LobbyCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
 *
 */

/****************************************************************************
 *
 * DirectPlay8 Functions
 *
 ****************************************************************************/

//
// COM definition for DirectPlayLobbyClient
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8LobbyClient
DECLARE_INTERFACE_(IDirectPlay8LobbyClient,IUnknown)
{
    // IUnknown methods
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
    // IDirectPlayLobbyClient methods
	STDMETHOD(Initialize)	            (THIS_ const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,const DWORD dwFlags) PURE;
	STDMETHOD(EnumLocalPrograms)		(THIS_ GUID *const pGuidApplication,BYTE *const pEnumData,DWORD *const pdwEnumData,DWORD *const pdwItems, const DWORD dwFlags) PURE;
	STDMETHOD(ConnectApplication)		(THIS_ DPL_CONNECT_INFO *const pdplConnectionInfo,const PVOID pvConnectionContext,DPNHANDLE *const hApplication,const DWORD dwTimeOut,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPNHANDLE hConnection,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags) PURE;
	STDMETHOD(ReleaseApplication)		(THIS_ const DPNHANDLE hConnection, const DWORD dwFlags ) PURE;
	STDMETHOD(Close)    				(THIS_ const DWORD dwFlags ) PURE;
	STDMETHOD(GetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags ) PURE;	
	STDMETHOD(SetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags ) PURE;
};


//
// COM definition for DirectPlayLobbiedApplication
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8LobbiedApplication
DECLARE_INTERFACE_(IDirectPlay8LobbiedApplication,IUnknown)
{
    // IUnknown methods
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid,LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
    // IDirectPlayLobbiedApplication methods
	STDMETHOD(Initialize)	            (THIS_ const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,DPNHANDLE * const pdpnhConnection, const DWORD dwFlags) PURE;
	STDMETHOD(RegisterProgram)			(THIS_ PDPL_PROGRAM_DESC pdplProgramDesc,const DWORD dwFlags) PURE;
	STDMETHOD(UnRegisterProgram)		(THIS_ GUID *pguidApplication,const DWORD dwFlags) PURE;
	STDMETHOD(Send)						(THIS_ const DPNHANDLE hConnection,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags) PURE;
	STDMETHOD(SetAppAvailable)			(THIS_ const BOOL fAvailable, const DWORD dwFlags ) PURE;
	STDMETHOD(UpdateStatus)				(THIS_ const DPNHANDLE hConnection, const DWORD dwStatus, const DWORD dwFlags ) PURE;
	STDMETHOD(Close)				    (THIS_ const DWORD dwFlags ) PURE;
	STDMETHOD(GetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags ) PURE;
	STDMETHOD(SetConnectionSettings)    (THIS_ const DPNHANDLE hConnection, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags ) PURE;
};


/****************************************************************************
 *
 * DirectPlayLobby Interface Macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay8LobbyClient_QueryInterface(p,a,b)    		        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8LobbyClient_AddRef(p)                		        (p)->lpVtbl->AddRef(p)
#define IDirectPlay8LobbyClient_Release(p)						        (p)->lpVtbl->Release(p)
#define IDirectPlay8LobbyClient_Initialize(p,a,b,c)	                    (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectPlay8LobbyClient_EnumLocalPrograms(p,a,b,c,d,e)	        (p)->lpVtbl->EnumLocalPrograms(p,a,b,c,d,e)
#define IDirectPlay8LobbyClient_ConnectApplication(p,a,b,c,d,e)	        (p)->lpVtbl->ConnectApplication(p,a,b,c,d,e)
#define IDirectPlay8LobbyClient_Send(p,a,b,c,d)					        (p)->lpVtbl->Send(p,a,b,c,d)
#define IDirectPlay8LobbyClient_ReleaseApplication(p,a,b)		        (p)->lpVtbl->ReleaseApplication(p,a,b)
#define IDirectPlay8LobbyClient_Close(p,a)						        (p)->lpVtbl->Close(p,a)
#define IDirectPlay8LobbyClient_GetConnectionSettings(p,a,b,c,d)        (p)->lpVtbl->GetConnectionSettings(p,a,b,c,d)
#define IDirectPlay8LobbyClient_SetConnectionSettings(p,a,b,c)          (p)->lpVtbl->SetConnectionSettings(p,a,b,c)

#define IDirectPlay8LobbiedApplication_QueryInterface(p,a,b)			(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay8LobbiedApplication_AddRef(p)						(p)->lpVtbl->AddRef(p)
#define IDirectPlay8LobbiedApplication_Release(p)						(p)->lpVtbl->Release(p)
#define IDirectPlay8LobbiedApplication_Initialize(p,a,b,c,d)            (p)->lpVtbl->Initialize(p,a,b,c,d)
#define IDirectPlay8LobbiedApplication_RegisterProgram(p,a,b)			(p)->lpVtbl->RegisterProgram(p,a,b)
#define IDirectPlay8LobbiedApplication_UnRegisterProgram(p,a,b)			(p)->lpVtbl->UnRegisterProgram(p,a,b)
#define IDirectPlay8LobbiedApplication_Send(p,a,b,c,d)					(p)->lpVtbl->Send(p,a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetAppAvailable(p,a,b)			(p)->lpVtbl->SetAppAvailable(p,a,b)
#define IDirectPlay8LobbiedApplication_UpdateStatus(p,a,b,c)			(p)->lpVtbl->UpdateStatus(p,a,b,c)
#define IDirectPlay8LobbiedApplication_Close(p,a)						(p)->lpVtbl->Close(p,a)
#define IDirectPlay8LobbiedApplication_GetConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetConnectionSettings(p,a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetConnectionSettings(p,a,b,c)   (p)->lpVtbl->SetConnectionSettings(p,a,b,c)

#else	/* C++ */

#define IDirectPlay8LobbyClient_QueryInterface(p,a,b)    		        (p)->QueryInterface(a,b)
#define IDirectPlay8LobbyClient_AddRef(p)                		        (p)->AddRef()
#define IDirectPlay8LobbyClient_Release(p)						        (p)->Release()
#define IDirectPlay8LobbyClient_Initialize(p,a,b,c)	                    (p)->Initialize(a,b,c)
#define IDirectPlay8LobbyClient_EnumLocalPrograms(p,a,b,c,d,e)	        (p)->EnumLocalPrograms(a,b,c,d,e)
#define IDirectPlay8LobbyClient_ConnectApplication(p,a,b,c,d,e)	        (p)->ConnectApplication(a,b,c,d,e)
#define IDirectPlay8LobbyClient_Send(p,a,b,c,d)					        (p)->Send(a,b,c,d)
#define IDirectPlay8LobbyClient_ReleaseApplication(p,a,b)		        (p)->ReleaseApplication(a,b)
#define IDirectPlay8LobbyClient_Close(p,a)						        (p)->Close(a)
#define IDirectPlay8LobbyClient_GetConnectionSettings(p,a,b,c,d)        (p)->GetConnectionSettings(a,b,c,d)
#define IDirectPlay8LobbyClient_SetConnectionSettings(p,a,b,c)          (p)->SetConnectionSettings(a,b,c)

#define IDirectPlay8LobbiedApplication_QueryInterface(p,a,b)			(p)->QueryInterface(a,b)
#define IDirectPlay8LobbiedApplication_AddRef(p)						(p)->AddRef()
#define IDirectPlay8LobbiedApplication_Release(p)						(p)->Release()
#define IDirectPlay8LobbiedApplication_Initialize(p,a,b,c,d)            (p)->Initialize(a,b,c,d)
#define IDirectPlay8LobbiedApplication_RegisterProgram(p,a,b)			(p)->RegisterProgram(a,b)
#define IDirectPlay8LobbiedApplication_UnRegisterProgram(p,a,b)			(p)->UnRegisterProgram(a,b)
#define IDirectPlay8LobbiedApplication_Send(p,a,b,c,d)					(p)->Send(a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetAppAvailable(p,a,b)			(p)->SetAppAvailable(a,b)
#define IDirectPlay8LobbiedApplication_UpdateStatus(p,a,b,c)			(p)->UpdateStatus(a,b,c)
#define IDirectPlay8LobbiedApplication_Close(p,a)						(p)->Close(a)
#define IDirectPlay8LobbiedApplication_GetConnectionSettings(p,a,b,c,d) (p)->GetConnectionSettings(a,b,c,d)
#define IDirectPlay8LobbiedApplication_SetConnectionSettings(p,a,b,c)   (p)->SetConnectionSettings(a,b,c)

#endif

#ifdef __cplusplus
}
#endif

#endif	// __DPLOBBY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\inc\dpsp8.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DPSP8.h
 *  Content:	Service provider include file
//@@BEGIN_MSINTERNAL
 *  History:
 *	Date   By  Reason
 *	============
 *	10/12/98	jwo		created
 *	03/22/2000	jtk		Changed interface names
 *	05/16/2000	jtk		Derived from DNSP.h
 *	07/17/2001	vanceo	MSINTERNAL cleanup so header can be released
 *	10/08/2001	vanceo	Add multicast support
//@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DIRECTPLAY_SERVICE_PROVIDER_8__
#define __DIRECTPLAY_SERVICE_PROVIDER_8__

#ifdef _XBOX
//@@BEGIN_MSINTERNAL
#ifdef XBOX_ON_DESKTOP
#include <ole2.h>	   // for DECLARE_INTERFACE_ and HRESULT
#endif // XBOX_ON_DESKTOP
//@@END_MSINTERNAL
#undef DECLARE_INTERFACE_
#define DECLARE_INTERFACE_(iface, baseiface)	DECLARE_INTERFACE(iface)
#else // ! _XBOX
#include <ole2.h>	   // for DECLARE_INTERFACE_ and HRESULT
#endif // ! _XBOX

#ifdef __cplusplus
extern "C" {
#endif



/****************************************************************************
 *
 * DirectPlay8 Interface IIDs
 *
 ****************************************************************************/

//
// GUIDS used by DP8ServiceProvider objects
//
// {85F1A470-61D5-11D2-AE0F-006097B01411}
DEFINE_GUID(IID_IDP8ServiceProvider, 0x85f1a470, 0x61d5, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);

// {85F1A472-61D5-11D2-AE0F-006097B01411}
DEFINE_GUID(IID_IDP8SPCallback, 0x85f1a472, 0x61d5, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);


/****************************************************************************
 *
 * DirectPlay8 Interface Pointer definitions
 *
 ****************************************************************************/

typedef struct IDP8SPCallback		IDP8SPCallback;
typedef struct IDP8ServiceProvider	IDP8ServiceProvider;


//**************************************************************************
// Constant definitions
//**************************************************************************

//
// Registry key under HKLM where the service provider info lives
//
#define DPN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
#define DPN_REG_LOCAL_SP_SUB				L"\\Service Providers"
#define DPN_REG_LOCAL_SP_SUBKEY				DPN_REG_LOCAL_SP_ROOT DPN_REG_LOCAL_SP_SUB

//
// Registry values used by DirectPlay
//
#define DPN_REG_KEYNAME_FRIENDLY_NAME			L"Friendly Name"
#define DPN_REG_KEYNAME_GUID					L"GUID"


//
// Enumerated values for service provider events
//
typedef	enum _SP_EVENT_TYPE
{
	SPEV_UNKNOWN = 0,
	SPEV_DATA,
	SPEV_CONNECT,
	SPEV_DISCONNECT,
	SPEV_ENUMQUERY,
	SPEV_QUERYRESPONSE,
	SPEV_LISTENSTATUS,
	SPEV_LISTENADDRESSINFO,
	SPEV_ENUMADDRESSINFO,
	SPEV_CONNECTADDRESSINFO,
	SPEV_DATA_UNCONNECTED,
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
	SPEV_DATA_UNKNOWNSENDER,
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
} SP_EVENT_TYPE;

/* Flags */

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOSPUI
//@@END_MSINTERNAL
#define DPNSPF_OKTOQUERY					0x00000002		// OK for SP to ask the user for clarification on addresses
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOSPUI
//@@END_MSINTERNAL
#define DPNSPF_NOBROADCASTFALLBACK			0x00000010		// don't allow SP to fallback to broadcast with insufficient information
															// (only if the SP supports broadcast)
#define DPNSPF_BINDLISTENTOGATEWAY			0x00000020		// when performing a 'listen' attempt create a mapping between the local
															// 'port' to the same 'port' on the network 'gateway'.
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
#define DPNSPF_ADDITIONALMULTIPLEXADAPTERS	0x00000040		// there will be more adapters for this connect operation
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
#define DPNSPF_LISTEN_MULTICAST				0x00000080		// the listen is a multicast listen operation
#define DPNSPF_LISTEN_ALLOWUNKNOWNSENDERS	0x00000100		// allow and indicate data from an unknown multicast sender
#define DPNSPF_CONNECT_MULTICAST_SEND		0x00000200		// the connect is a multicast send operation
#define DPNSPF_CONNECT_MULTICAST_RECEIVE	0x00000400		// the connect is a multicast receive operation
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
#define DPNSPF_SESSIONDATA					0x00000800		// the operation has session data available
#define DPNSPF_LISTEN_DISALLOWENUMS			0x00001000		// don't pass enums up from listens


//
// flags for getting address information
//
typedef	enum
{
	SP_GET_ADDRESS_INFO_LOCAL_ADAPTER = 0x00000001,			// local adapter address
	SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES,				// local adapter address (in 'host' form to be passed to connect/enum)
	SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS,			// local adapter address as mapped on the 'gateway' (in 'host' form for connect/enum)
	SP_GET_ADDRESS_INFO_REMOTE_HOST,						// address of other end of an endpoint (in 'host' form to be passed to connect/enum)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
	SP_GET_ADDRESS_INFO_MULTICAST_GROUP,					// group address for multicast listen endpoint (in 'host' form to be passed to connect)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
} SP_GET_ADDRESS_INFO_FLAGS;



//
// SP updates
//
typedef enum
{
	SP_UPDATE_HOST_MIGRATE,
	SP_UPDATE_ALLOW_ENUMS,
	SP_UPDATE_DISALLOW_ENUMS
} SP_UPDATE_TYPE;


//
// Flags passed to Initialize method in dwFlags param of SPINITIALIZEDATA
//
typedef enum
{
	SP_SESSION_TYPE_SERVER=0x01,
	SP_SESSION_TYPE_CLIENT=0x02,
	SP_SESSION_TYPE_PEER=0x04
} SP_INITIALIZE_FLAGS;

//**************************************************************************
// Structure definitions
//**************************************************************************

//
// data received from the SP
//
typedef	struct	_SPRECEIVEDBUFFER
{
	struct _SPRECEIVEDBUFFER	*pNext;						// link to next item in list
	DWORD						dwProtocolData;				// reserved for protocol
	PVOID						pServiceProviderDescriptor;	// reserved for protocol
	BUFFERDESC					BufferDesc;					// received buffer description
} SPRECEIVEDBUFFER, *PSPRECEIVEDBUFFER;

//
// connect indication
//
typedef struct	_SPIE_CONNECT
{	
	HANDLE	hEndpoint;			// handle of the new endpoint
	void	*pEndpointContext;	// user context associated with this endpoint
	void	*pCommandContext;	// user context for associated command
} SPIE_CONNECT, *PSPIE_CONNECT;

//
// disconnect indication
//
typedef	struct	_SPIE_DISCONNECT
{
	HANDLE	hEndpoint;			// handle of endpoint being disconnected
	void	*pEndpointContext;	// user context associated with this endpoint
} SPIE_DISCONNECT, *PSPIE_DISCONNECT;

//
// user data indication
//
typedef struct _SPIE_DATA
{
	HANDLE				hEndpoint;			// EP from which this data was received
	void				*pEndpointContext;	// user context associated with this endpoint
	SPRECEIVEDBUFFER	*pReceivedData;		// pointer to received data
} SPIE_DATA, *PSPIE_DATA;

//
// enum data indication
//
typedef struct _SPIE_QUERY
{
	IDirectPlay8Address	*pAddressSender;		// address from which the query came (may be NULL)
	IDirectPlay8Address	*pAddressDevice;		// address of device on which query was received
	SPRECEIVEDBUFFER	*pReceivedData;			// pointer to received data
	void				*pUserContext;			// user context passed into listen command
} SPIE_QUERY, *PSPIE_QUERY;

//
// enum response data indication
//
typedef	struct	_SPIE_QUERYRESPONSE
{
	IDirectPlay8Address		*pAddressSender;		// address from which the query came (may be NULL)
	IDirectPlay8Address		*pAddressDevice;		// address of device on which query response was received
	SPRECEIVEDBUFFER		*pReceivedData;			// pointer to received data
	DWORD					dwRoundTripTime;		// round trip time for enum (milliseconds)
	void					*pUserContext;			// user context passed into enum command
} SPIE_QUERYRESPONSE, *PSPIE_QUERYRESPONSE;


//
// event sent to indicate status of 'listen' on an adapter
//
typedef	struct	_SPIE_LISTENSTATUS
{
	GUID		ListenAdapter;		// adapter GUID
	HRESULT		hResult;			// result of listen
	HANDLE		hCommand;			// handle of associated command
	void		*pUserContext;		// user context passed into command
	HANDLE		hEndpoint;			// handle of endpoint associated with this listen
} SPIE_LISTENSTATUS, *PSPIE_LISTENSTATUS;


//
// event sent to indicate address info for 'listen' on an adapter
//
typedef	struct	_SPIE_LISTENADDRESSINFO
{
	IDirectPlay8Address		*pDeviceAddress;		// device address used to complete this command
	HRESULT					hCommandStatus;			// command status
	void					*pCommandContext;		// command context
} SPIE_LISTENADDRESSINFO, *PSPIE_LISTENADDRESSINFO;


//
// event sent to indicate address info for 'enum' on an adapter
//
typedef	struct	_SPIE_ENUMADDRESSINFO
{
	IDirectPlay8Address		*pHostAddress;			// host address used to complete this command
	IDirectPlay8Address		*pDeviceAddress;		// device address used to complete this command
	HRESULT					hCommandStatus;			// command status
	void					*pCommandContext;		// command context
} SPIE_ENUMADDRESSINFO, *PSPIE_ENUMADDRESSINFO;


//
// event sent to indicate status of 'connect' on an adapter
//
typedef	struct	_SPIE_CONNECTADDRESSINFO
{
	IDirectPlay8Address		*pHostAddress;			// host address used to complete this command
	IDirectPlay8Address		*pDeviceAddress;		// device address used to complete this command
	HRESULT					hCommandStatus;			// command status
	void					*pCommandContext;		// command context
} SPIE_CONNECTADDRESSINFO, *PSPIE_CONNECTADDRESSINFO;

//
// user data indication where sender does not have a valid connection
//
typedef struct _SPIE_DATA_UNCONNECTED
{
	void					*pvListenCommandContext;	// user context for associated command
	SPRECEIVEDBUFFER		*pReceivedData;				// pointer to received data
	DWORD					dwSenderAddressHash;		// hashed address of sender of data
	PVOID					pvReplyBuffer;				// buffer the user can fill with a reply
	DWORD					dwReplyBufferSize;			// size of the buffer user can fill with a reply, and place for user to return size used if replying
} SPIE_DATA_UNCONNECTED, *PSPIE_DATA_UNCONNECTED;

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
//
// user multicast data indication where sender is unknown
//
typedef struct _SPIE_DATA_UNKNOWNSENDER
{
	IDirectPlay8Address		*pSenderAddress;			// address of sender of data
	void					*pvListenCommandContext;	// user context for associated command
	SPRECEIVEDBUFFER		*pReceivedData;				// pointer to received data
} SPIE_DATA_UNKNOWNSENDER, *PSPIE_DATA_UNKNOWNSENDER;
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL






typedef struct	_SPINITIALIZEDATA
{
	IDP8SPCallback	*pIDP;		// pointer to callback interface
	DWORD			dwFlags;	// flags
} SPINITIALIZEDATA, *PSPINITIALIZEDATA;


typedef	struct	_SPGETCAPSDATA
{
	DWORD		dwSize;							// size of this structure

	HANDLE		hEndpoint;						// Handle of endpoint to check.  If this parameter
												// is NULL, the best-case capabilities of the SP are
												// returned.

	DWORD		dwUserFrameSize;				// Maximum data payload allowed in an outgoing
												// message from this SP.  It is the SP's responsibility
												// to account for any extra header information it's
												// going to attach when sending a message, and for any
												// underlying protocol overhead (IP packet headers).

	DWORD		dwEnumFrameSize;				// maximum payload for an enum query (NOT ENUM RESPONSE!)

	DWORD		dwLocalLinkSpeed;				// speed of link in bits per second

	DWORD		dwIOThreadCount;				// count of threads in operation by this SP

	DWORD		dwDefaultEnumRetryCount;		// default retry count

	DWORD		dwDefaultEnumRetryInterval;		// default retry interval

	DWORD		dwDefaultEnumTimeout;			// default timeout

	DWORD		dwFlags;						// SP flags

	DWORD		dwBuffersPerThread;				// buffers per thread
	
	DWORD		dwSystemBufferSize;				// system buffer size
} SPGETCAPSDATA, *PSPGETCAPSDATA;


typedef	struct	_SPSETCAPSDATA
{
	DWORD	dwSize;					// size of this structure

	DWORD	dwIOThreadCount;		// number of threads in operation by this SP
	DWORD	dwBuffersPerThread;		// buffers per thread
	DWORD	dwSystemBufferSize;		// system buffer size
} SPSETCAPSDATA, *PSPSETCAPSDATA;


typedef	struct	_SPGETADDRESSINFODATA
{
	HANDLE				hEndpoint;		// handle of endpoint to check
	IDirectPlay8Address	*pAddress;		// returned pointer to output address
	SP_GET_ADDRESS_INFO_FLAGS	Flags;	// flags
} SPGETADDRESSINFODATA, *PSPGETADDRESSINFODATA;


typedef struct	_SPENUMQUERYDATA
{
	IDirectPlay8Address	*pAddressHost;			// address to which to send
	IDirectPlay8Address	*pAddressDeviceInfo;	// device to enumerate on
	BUFFERDESC			*pBuffers;				// pointer to buffers to send
	DWORD				dwBufferCount;			// count of buffers to send
	DWORD				dwTimeout;				// how long to wait for replies (0 means default)
	DWORD				dwRetryCount;			// how many times to send it (0 means default)
	DWORD				dwRetryInterval;		// how long to wait between retries (0 means default)
	DWORD				dwFlags;				// enum query flags
	void				*pvContext;				// caller's toy, returned in the completion indication
	HANDLE				hCommand;				// Returned
	DWORD				dwCommandDescriptor;	// Returned

	// Added for DX9, ignored unless DPNSPF_SESSIONDATA flag used
	void				*pvSessionData;		// pointer to session data
	DWORD				dwSessionDataSize;			// size of session data
} SPENUMQUERYDATA, *PSPENUMQUERYDATA;


typedef struct	_SPENUMRESPONDDATA
{
	SPIE_QUERY		*pQuery;				// pointer to the query indication to which you're responding
	BUFFERDESC		*pBuffers;				// pointer to reply buffers to send
	DWORD			dwBufferCount;			// count of reply buffers to send
	DWORD			dwFlags;				// enum respond flags, must be zero
	void			*pvContext;				// caller's toy, returned in the completion indication
	HANDLE			hCommand;				// Returned
	DWORD			dwCommandDescriptor;	// Returned
} SPENUMRESPONDDATA, *PSPENUMRESPONDDATA;


typedef struct	_SPCONNECTDATA
{
	IDirectPlay8Address	*pAddressHost;			// address to which to connect
	IDirectPlay8Address	*pAddressDeviceInfo;	// address with which to connect
	DWORD				dwReserved;				// unused, must be zero
	DWORD				dwFlags;				// connect flags
	void				*pvContext;				// caller's toy, returned in the completion indication
	HANDLE				hCommand;				// Returned
	DWORD				dwCommandDescriptor;	// Returned

	// Added for DX9, ignored unless DPNSPF_SESSIONDATA flag used
	void				*pvSessionData;		// pointer to session data
	DWORD				dwSessionDataSize;			// size of session data
} SPCONNECTDATA, *PSPCONNECTDATA;


typedef struct	_SPDISCONNECTDATA
{
	HANDLE			hEndpoint;				// handle to the endpoint to disconnect
	DWORD			dwFlags;				// disconnect flags, must be zero
	void			*pvContext;				// caller's toy, returned in the completion indication
	HANDLE			hCommand;				// Returned
	DWORD			dwCommandDescriptor;	// Returned
} SPDISCONNECTDATA, *PSPDISCONNECTDATA;


typedef struct	_SPLISTENDATA
{
	IDirectPlay8Address	*pAddressDeviceInfo;	// address to listen on
	DWORD				dwFlags;				// listen flags
	void				*pvContext;				// caller's toy, returned in the completion indication
	HANDLE				hCommand;				// Returned
	DWORD				dwCommandDescriptor;	// Returned

	// Added for DX9, ignored unless DPNSPF_SESSIONDATA flag used
	void				*pvSessionData;		// pointer to session data
	DWORD				dwSessionDataSize;			// size of session data
} SPLISTENDATA, *PSPLISTENDATA;


typedef struct	_SPSENDDATA
{
	HANDLE			hEndpoint;				// handle of endpoint on which to send the data
	BUFFERDESC		*pBuffers;				// data to send
	DWORD			dwBufferCount;			// count of buffers to send
	DWORD			dwFlags;				// send flags
	void			*pvContext;				// caller's toy, returned in the completion indication
	HANDLE			hCommand;				// Returned
	DWORD			dwCommandDescriptor;	// Returned
} SPSENDDATA, *PSPSENDDATA;


typedef struct	_SPUPDATEDATA
{
	SP_UPDATE_TYPE	UpdateType;				// identifier describing update type
	HANDLE			hEndpoint;				// handle to endpoint being updated
} SPUPDATEDATA,	*PSPUPDATEDATA;


typedef	struct	_SPENUMMULTICASTSCOPESDATA			SPENUMMULTICASTSCOPESDATA,			*PSPENUMMULTICASTSCOPESDATA;

typedef struct	_SPSHAREENDPOINTINFODATA			SPSHAREENDPOINTINFODATA,			*PSPSHAREENDPOINTINFODATA;

typedef struct	_SPGETENDPOINTBYADDRESSDATA			SPGETENDPOINTBYADDRESSDATA,			*PSPGETENDPOINTBYADDRESSDATA;

//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL

typedef struct _DPN_MULTICAST_SCOPE_INFO			DPN_MULTICAST_SCOPE_INFO,			*PDPN_MULTICAST_SCOPE_INFO;

struct	_SPENUMMULTICASTSCOPESDATA
{
	const GUID					*pguidAdapter;		// pointer to GUID of adapter on which to enumerate scopes
	DPN_MULTICAST_SCOPE_INFO	*pScopeData;		// buffer in which to store scopes returned
	DWORD						dwScopeDataSize;	// size of buffer in bytes, size required/written returned
	DWORD						dwScopeCount;		// number of scopes returned
	DWORD						dwFlags;			// flags, must be zero
};

struct	_SPSHAREENDPOINTINFODATA
{
	IDP8ServiceProvider		*pDP8ServiceProvider;	// existing service provider whose endpoint data should be shared
	DWORD					dwFlags;				// flags, must be zero
};

struct	_SPGETENDPOINTBYADDRESSDATA
{
	IDirectPlay8Address		*pAddressHost;			// address of remote host
	IDirectPlay8Address		*pAddressDeviceInfo;	// address of device with which endpoint is connected
	DWORD					dwFlags;				// flags, must be zero
	HANDLE					hEndpoint;				// handle to endpoint returned
	PVOID					pvEndpointContext;		// user's endpoint context returned
};
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL


typedef	struct	_SPISAPPLICATIONSUPPORTEDDATA	SPISAPPLICATIONSUPPORTEDDATA,	*PSPISAPPLICATIONSUPPORTEDDATA;
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_LIBINTERFACE
//@@END_MSINTERNAL
struct	_SPISAPPLICATIONSUPPORTEDDATA
{
	const GUID	*pApplicationGuid;	// pointer to GUID of application to check
	DWORD		dwFlags;			// flags, must be zero
};
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_LIBINTERFACE
//@@END_MSINTERNAL


typedef	struct	_SPENUMADAPTERSDATA		SPENUMADAPTERSDATA,		*PSPENUMADAPTERSDATA;
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
struct	_SPENUMADAPTERSDATA
{
	DPN_SERVICE_PROVIDER_INFO	*pAdapterData;		// buffer in which to store adapters returned
	DWORD						dwAdapterDataSize;	// size of buffer in bytes, size required/written returned
	DWORD						dwAdapterCount;		// number of adapters returned
	DWORD						dwFlags;			// flags, must be zero
};
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL


typedef	struct	_SPPROXYENUMQUERYDATA	SPPROXYENUMQUERYDATA,	*PSPPROXYENUMQUERYDATA;
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_SINGLEPROCESS
//@@END_MSINTERNAL
struct	_SPPROXYENUMQUERYDATA
{
	DWORD				dwFlags;					// flags, must be zero
	SPIE_QUERY			*pIncomingQueryData;		// pointer to incoming enum query to be proxied
	IDirectPlay8Address	*pDestinationAdapter;		// pointer to address of destination adapter
};
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_SINGLEPROCESS
//@@END_MSINTERNAL



//**************************************************************************
// Variable definitions
//**************************************************************************

//**************************************************************************
// Function prototypes
//**************************************************************************

//**************************************************************************
// Function definitions
//**************************************************************************


/***************************************************************************
 * IDP8SPCallback interface
 ***************************************************************************/

#undef INTERFACE
#define INTERFACE IDP8SPCallback
DECLARE_INTERFACE_( IDP8SPCallback, IUnknown )
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)		(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)		(THIS) PURE;
	STDMETHOD_(ULONG,Release)		(THIS) PURE;
	/*** IDP8SPCallback methods ***/
	STDMETHOD(IndicateEvent) 		(THIS_ SP_EVENT_TYPE,LPVOID) PURE;
	STDMETHOD(CommandComplete) 		(THIS_ HANDLE,HRESULT,LPVOID) PURE;
};


/***************************************************************************
 * IDP8SPCallback interface macros
 ***************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDP8SPCallback_QueryInterface(p,a,b)		(p)->lpVtbl->QueryInterface(p,a,b)
#define IDP8SPCallback_AddRef(p)					(p)->lpVtbl->AddRef(p)
#define IDP8SPCallback_Release(p)			   		(p)->lpVtbl->Release(p)
#define IDP8SPCallback_IndicateEvent(p,a,b)	  		(p)->lpVtbl->IndicateEvent(p,a,b)
#define IDP8SPCallback_CommandComplete(p,a,b,c)		(p)->lpVtbl->CommandComplete(p,a,b,c)

#else /* C++ */

#define IDP8SPCallback_QueryInterface(p,a,b)		(p)->QueryInterface(a,b)
#define IDP8SPCallback_AddRef(p)					(p)->AddRef()
#define IDP8SPCallback_Release(p)			   		(p)->Release()
#define IDP8SPCallback_IndicateEvent(p,a,b)			(p)->IndicateEvent(a,b)
#define IDP8SPCallback_CommandComplete(p,a,b,c)		(p)->CommandComplete(a,b,c)

#endif


/***************************************************************************
 * IDP8ServiceProvider interface
 ***************************************************************************/

#undef INTERFACE
#define INTERFACE IDP8ServiceProvider
DECLARE_INTERFACE_( IDP8ServiceProvider, IUnknown )
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)	   		(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)	   		(THIS) PURE;
	/*** IDP8ServiceProvider methods ***/
	STDMETHOD(Initialize)				(THIS_ PSPINITIALIZEDATA) PURE;
	STDMETHOD(Close)  					(THIS) PURE;
	STDMETHOD(Connect)		  			(THIS_ PSPCONNECTDATA) PURE;
	STDMETHOD(Disconnect)		  		(THIS_ PSPDISCONNECTDATA) PURE;
	STDMETHOD(Listen)					(THIS_ PSPLISTENDATA) PURE;
	STDMETHOD(SendData)					(THIS_ PSPSENDDATA) PURE;
	STDMETHOD(EnumQuery)				(THIS_ PSPENUMQUERYDATA) PURE;
	STDMETHOD(EnumRespond)				(THIS_ PSPENUMRESPONDDATA) PURE;
	STDMETHOD(CancelCommand)			(THIS_ HANDLE, DWORD) PURE;
	STDMETHOD(EnumMulticastScopes)		(THIS_ PSPENUMMULTICASTSCOPESDATA) PURE;
	STDMETHOD(ShareEndpointInfo)		(THIS_ PSPSHAREENDPOINTINFODATA) PURE;
	STDMETHOD(GetEndpointByAddress)		(THIS_ PSPGETENDPOINTBYADDRESSDATA) PURE;
	STDMETHOD(Update)					(THIS_ PSPUPDATEDATA) PURE;
	STDMETHOD(GetCaps)					(THIS_ PSPGETCAPSDATA) PURE;
	STDMETHOD(SetCaps)					(THIS_ PSPSETCAPSDATA) PURE;
	STDMETHOD(ReturnReceiveBuffers)		(THIS_ PSPRECEIVEDBUFFER) PURE;
	STDMETHOD(GetAddressInfo)			(THIS_ PSPGETADDRESSINFODATA) PURE;
	STDMETHOD(IsApplicationSupported)	(THIS_ PSPISAPPLICATIONSUPPORTEDDATA) PURE;
	STDMETHOD(EnumAdapters)				(THIS_ PSPENUMADAPTERSDATA) PURE;
	STDMETHOD(ProxyEnumQuery)			(THIS_ PSPPROXYENUMQUERYDATA) PURE;
};

/***************************************************************************
 * IDP8ServiceProvider interface macros
 ***************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDP8ServiceProvider_QueryInterface(p,a,b)			(p)->lpVtbl->QueryInterface(p,a,b)
#define IDP8ServiceProvider_AddRef(p)						(p)->lpVtbl->AddRef(p)
#define IDP8ServiceProvider_Release(p)						(p)->lpVtbl->Release(p)
#define IDP8ServiceProvider_Initialize(p,a)					(p)->lpVtbl->Initialize(p,a)
#define IDP8ServiceProvider_Close(p)						(p)->lpVtbl->Close(p)
#define IDP8ServiceProvider_Connect(p,a)					(p)->lpVtbl->Connect(p,a)
#define IDP8ServiceProvider_Disconnect(p,a)					(p)->lpVtbl->Disconnect(p,a)
#define IDP8ServiceProvider_Listen(p,a)						(p)->lpVtbl->Listen(p,a)
#define IDP8ServiceProvider_SendData(p,a)					(p)->lpVtbl->SendData(p,a)
#define IDP8ServiceProvider_EnumQuery(p,a)					(p)->lpVtbl->EnumQuery(p,a)
#define IDP8ServiceProvider_EnumRespond(p,a)				(p)->lpVtbl->EnumRespond(p,a)
#define IDP8ServiceProvider_CancelCommand(p,a,b)			(p)->lpVtbl->CancelCommand(p,a,b)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
#define IDP8ServiceProvider_EnumMulticastScopes(p,a)		(p)->lpVtbl->EnumMulticastScopes(p,a)
#define IDP8ServiceProvider_ShareEndpointInfo(p,a)			(p)->lpVtbl->ShareEndpointInfo(p,a)
#define IDP8ServiceProvider_GetEndpointByAddress(p,a)		(p)->lpVtbl->GetEndpointByAddress(p,a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
#define IDP8ServiceProvider_Update(p,a)						(p)->lpVtbl->Update(p,a)
#define IDP8ServiceProvider_GetCaps(p,a)					(p)->lpVtbl->GetCaps(p,a)
#define IDP8ServiceProvider_SetCaps(p,a)					(p)->lpVtbl->SetCaps(p,a)
#define IDP8ServiceProvider_ReturnReceiveBuffers(p,a)		(p)->lpVtbl->ReturnReceiveBuffers(p,a)
#define IDP8ServiceProvider_GetAddressInfo(p,a)				(p)->lpVtbl->GetAddressInfo(p,a)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_LIBINTERFACE
//@@END_MSINTERNAL
#define IDP8ServiceProvider_IsApplicationSupported(p,a)		(p)->lpVtbl->IsApplicationSupported(p,a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
#define IDP8ServiceProvider_EnumAdapters(p,a)				(p)->lpVtbl->EnumAdapters(p,a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_SINGLEPROCESS
//@@END_MSINTERNAL
#define IDP8ServiceProvider_ProxyEnumQuery(p,a)				(p)->lpVtbl->ProxyEnumQuery(p,a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_SINGLEPROCESS
//@@END_MSINTERNAL

#else /* C++ */

#define IDP8ServiceProvider_QueryInterface(p,a,b)			(p)->QueryInterface(a,b)
#define IDP8ServiceProvider_AddRef(p)						(p)->AddRef()
#define IDP8ServiceProvider_Release(p)						(p)->Release()
#define IDP8ServiceProvider_Initialize(p,a)					(p)->Initialize(a)
#define IDP8ServiceProvider_Close(p)						(p)->Close()
#define IDP8ServiceProvider_Connect(p,a)					(p)->Connect(a)
#define IDP8ServiceProvider_Disconnect(p,a)					(p)->Disconnect(a)
#define IDP8ServiceProvider_Listen(p,a)						(p)->Listen(a)
#define IDP8ServiceProvider_SendData(p,a)					(p)->SendData(a)
#define IDP8ServiceProvider_EnumQuery(p,a)					(p)->EnumQuery(a)
#define IDP8ServiceProvider_EnumRespond(p,a)				(p)->EnumRespond(a)
#define IDP8ServiceProvider_CancelCommand(p,a,b)			(p)->CancelCommand(a,b)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
#define IDP8ServiceProvider_EnumMulticastScopes(p,a)		(p)->EnumMulticastScopes(a)
#define IDP8ServiceProvider_ShareEndpointInfo(p,a)			(p)->ShareEndpointInfo(a)
#define IDP8ServiceProvider_GetEndpointByAddress(p,a)		(p)->GetEndpointByAddress(p,a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_NOMULTICAST
//@@END_MSINTERNAL
#define IDP8ServiceProvider_Update(p,a)						(p)->Update(a)
#define IDP8ServiceProvider_GetCaps(p,a)					(p)->GetCaps(a)
#define IDP8ServiceProvider_SetCaps(p,a)					(p)->SetCaps(a)
#define IDP8ServiceProvider_ReturnReceiveBuffers(p,a)		(p)->ReturnReceiveBuffers(a)
#define IDP8ServiceProvider_GetAddressInfo(p,a)				(p)->GetAddressInfo(a)
//@@BEGIN_MSINTERNAL
#ifndef DPNBUILD_LIBINTERFACE
//@@END_MSINTERNAL
#define IDP8ServiceProvider_IsApplicationSupported(p,a)		(p)->IsApplicationSupported(a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_ONLYONEADAPTER
//@@END_MSINTERNAL
#define IDP8ServiceProvider_EnumAdapters(p,a)				(p)->EnumAdapters(a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_SINGLEPROCESS
//@@END_MSINTERNAL
#define IDP8ServiceProvider_ProxyEnumQuery(p,a)				(p)->ProxyEnumQuery(a)
//@@BEGIN_MSINTERNAL
#endif // ! DPNBUILD_SINGLEPROCESS
//@@END_MSINTERNAL

#endif	// C++

#ifdef __cplusplus
};
#endif

#endif	// __DIRECTPLAY_SERVICE_PROVIDER_8__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\classfac.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.h
 *  Content:    DirectPlay Lobby class factory header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   06/07/00	rodtoll	Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CLASSFAC_H__
#define	__CLASSFAC_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _INTERFACE_LIST	INTERFACE_LIST;
typedef struct _OBJECT_DATA		OBJECT_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************


//**********************************************************************
// Function prototypes
//**********************************************************************

//	DirectPlay - IUnknown
STDMETHODIMP			DPL_QueryInterface(LPVOID lpv, REFIID riid,LPVOID *ppvObj);
STDMETHODIMP_(ULONG)	DPL_AddRef(LPVOID lphObj);
STDMETHODIMP_(ULONG)	DPL_Release(LPVOID lphObj);

// Class Factory
STDMETHODIMP			DPLCF_CreateInstance(IClassFactory* pInterface, LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID *ppv);

// Class Factory - supporting

HRESULT	DPLCF_CreateObject(LPVOID *lplpv,REFIID riid);
HRESULT	DPLCF_FreeObject(LPVOID lpv);

HRESULT	DPL_CreateInterface(OBJECT_DATA* lpObject,REFIID riid,INTERFACE_LIST** const ppv);
INTERFACE_LIST*	DPL_FindInterface(LPVOID lpv, REFIID riid);

#endif	// __CLASSFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\inc\dpnbuild.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnbuild.h
 *
 *  Content:	DirectPlay build specific defines header.
 *
 *  History:
 *   Date	  By		Reason
 *  ========  ========  =========
 *  11/08/01  VanceO	Created to reduce the build nightmare.
 *
 ******************************************************************************/


//=============================================================================
// Global defines for all build types
//=============================================================================

//
// Defining CINTERFACE lets us use C-style COM interfaces.  This is handy
// because it allows us to manually build up the vtable which lets us re-use
// functions easily where appropriate.  The downside is that we have an extra
// "->lpVtbl" to type in front of COM calls, but macros like 
// IDirectPlay8Address_Release() hide this.
//
#ifndef	CINTERFACE
#define CINTERFACE
#endif	// CINTERFACE

//
// All debug builds get thread pool statistics and all retail builds do not
// include the Protocol test interface.
//
#ifdef DBG
#define DPNBUILD_THREADPOOLSTATISTICS
#define DPNBUILD_WINSOCKSTATISTICS
#else // ! DBG
#define DPNBUILD_NOPROTOCOLTESTITF
#endif // ! DBG


#ifdef WINCE

	//========================================================================
	// Windows CE specific defines
	//========================================================================
	#ifdef WINNT
	#error("WINCE and WINNT cannot both be defined!")
	#endif // WINNT
	#ifdef WIN95
	#error("WINCE and WIN95 cannot both be defined!")
	#endif // WIN95
	#ifdef _XBOX
	#error("WINCE and _XBOX cannot both be defined!")
	#endif // _XBOX

	//
	// Windows CE builds Unicode.
	//
	#ifndef UNICODE
	#define UNICODE
	#endif // ! UNICODE

	#ifndef _UNICODE
	#define _UNICODE
	#endif // ! _UNICODE

	//
	// Eliminate unavailable components and non-CE features
	//
	#define DPNBUILD_NOCOMEMULATION
	#define DPNBUILD_NOHNETFWAPI
	#define DPNBUILD_NOIMAGEHLP
	#define DPNBUILD_NOIPV6
	#define DPNBUILD_NOIPX
	#define DPNBUILD_NOLEGACYDP
	#define DPNBUILD_NOLOCALNAT
	#define DPNBUILD_NOMISSEDTIMERSHINT
	#define DPNBUILD_NOMULTICAST
	#define DPNBUILD_NOSERIALSP
	#define DPNBUILD_NOSPUI
	#define DPNBUILD_NOVOICE
	#define DPNBUILD_NOWINMM
	#define DPNBUILD_NOWINSOCK2
	#define DPNBUILD_ONLYONENATHELP
	#define DPNBUILD_ONLYONEPROCESSOR


	#ifdef DBG

		//===================================================================
		// Debug CE build specific defines
		//===================================================================


	#else // ! DBG

		//===================================================================
		// Retail CE build specific defines
		//===================================================================

		//
		// Don't include parameter validation.
		//
		#define DPNBUILD_NOPARAMVAL

	#endif // ! DBG

#else // ! WINCE
	#ifdef _XBOX

		//===================================================================
		// Xbox specific defines
		//===================================================================
		#ifdef WINNT
		#error("_XBOX and WINNT cannot both be defined!")
		#endif // WINNT
		#ifdef WIN95
		#error("_XBOX and WIN95 cannot both be defined!")
		#endif // WIN95

		//
		// The Xbox NT build environment tries to build Unicode, so stop it.
		//
		#ifdef UNICODE
		#undef UNICODE
		#endif // UNICODE

		#ifdef _UNICODE
		#undef _UNICODE
		#endif // _UNICODE

		//
		// Eliminate unavailable components and non-Xbox features
		//
		#define DPNBUILD_FIXEDMEMORYMODEL
		#define DPNBUILD_LIBINTERFACE
		#define DPNBUILD_NOADDRESSIPINTERFACE
		#define DPNBUILD_NOBLUETOOTHSP
		#define DPNBUILD_NOCOMEMULATION
		#define DPNBUILD_NOCOMREGISTER
		#define DPNBUILD_NOHNETFWAPI
		#define DPNBUILD_NOIMAGEHLP
		#define DPNBUILD_NOIPV6
		#define DPNBUILD_NOIPX
		#define DPNBUILD_NOLEGACYDP
		#define DPNBUILD_NOLOBBY
		#define DPNBUILD_NOLOCALNAT
		#define DPNBUILD_NOMULTICAST
		#define DPNBUILD_NONATHELP
		#define DPNBUILD_NOREGISTRY
		#define DPNBUILD_NOSERIALSP
		#define DPNBUILD_NOSPUI
		#define DPNBUILD_NOVOICE
		#define DPNBUILD_NOWINMM
		#define DPNBUILD_ONLYONEADAPTER
		#define DPNBUILD_ONLYONENATHELP
		#define DPNBUILD_ONLYONEPROCESSOR
		#define DPNBUILD_ONLYONESP
		#define DPNBUILD_ONLYONETHREAD
		#define DPNBUILD_ONLYWINSOCK2
		#define DPNBUILD_SINGLEPROCESS
		#define DPNBUILD_XNETSECURITY


		#ifdef DBG

			//==============================================================
			// Debug Xbox build specific defines
			//==============================================================


		#else // ! DBG

			//==============================================================
			// Retail Xbox build specific defines
			//==============================================================

			//
			// Don't include parameter validation.
			//
			#define DPNBUILD_NOPARAMVAL

		#endif // ! DBG

	#else // ! _XBOX

		//===================================================================
		// Desktop specific defines
		//===================================================================

		//
		// _WIN32_DCOM allows us to use CoInitializeEx.
		//
		#ifndef	_WIN32_DCOM
		#define _WIN32_DCOM
		#endif

		//
		// Desktop can handle async sends just fine.
		//
		#define DPNBUILD_ASYNCSPSENDS

		//
		// Multicast support is not ready for prime-time yet.
		//
		#define DPNBUILD_NOMULTICAST
		
		#ifdef WINNT

			//==============================================================
			// Windows NT specific defines
			//==============================================================
			#ifdef WIN95
			#error("WINNT and WIN95 cannot both be defined!")
			#endif // WIN95

			//
			// Windows NT builds Unicode
			//
			#define UNICODE
			#define _UNICODE

			//
			// When building under Visual C++ 6.0, we need to make sure
			// certain "advanced" features are available.  There's probably a
			// better way to tell what environment is being used, but for
			// now, we'll use ! DPNBUILD_ENV_NT.
			//
			#ifndef DPNBUILD_ENV_NT
			#define _WIN32_WINNT 0x0500
			#endif // ! DPNBUILD_ENV_NT


			//
			// No bluetooth support on NT.
			//
			#define DPNBUILD_NOBLUETOOTHSP
			
			//
			// 64-bit Windows never supported legacy DPlay (other than via
			// WOW).
			//
			#ifdef _WIN64
			#define DPNBUILD_NOLEGACYDP
			#endif // _WIN64

			//
			// NT doesn't need to support Winsock 1.
			//
			#define DPNBUILD_ONLYWINSOCK2


			#ifdef DBG

				//===========================================================
				// Debug NT build specific defines
				//===========================================================


			#else // ! DBG

				//===========================================================
				// Retail NT build specific defines
				//===========================================================


			#endif // ! DBG

		#else // ! WINNT

			//===============================================================
			// Windows 9x specific defines
			//===============================================================
			#ifndef WIN95
			#error("One of WINCE, _XBOX, WINNT, or WIN95 must be defined!")
			#endif // ! WIN95


			//
			// No bluetooth support on 9x
			//
			#define DPNBUILD_NOBLUETOOTHSP

			//
			// Windows 9x is single processor only.
			//
			#define DPNBUILD_ONLYONEPROCESSOR
		
			//
			// Windows 9x will never support IPv6.
			//
			#define DPNBUILD_NOIPV6


			#ifdef DBG

				//===========================================================
				// Debug 9x build specific defines
				//===========================================================


			#else // ! DBG

				//===========================================================
				// Retail 9x build specific defines
				//===========================================================


			#endif // ! DBG

		#endif // ! WINNT

	#endif // ! _XBOX

#endif // ! WINCE



//=============================================================================
// Print the current settings
//=============================================================================

#pragma message("Defines in use:")

//
// _ARM_ - Compile for ARM processors
//
#ifdef _ARM_
#pragma message("     _ARM_")
#endif

//
// _AMD64_ - Compile for AMD64 processors
//
#ifdef _AMD64_
#pragma message("     _AMD64_")
#endif

//
// DX_FINAL_RELEASE - Controls whether or not the DX time bomb is present
//
#ifdef DX_FINAL_RELEASE
#pragma message("     DX_FINAL_RELEASE")
#endif

//
// _IA64_ - Compile for IA64 processors
//
#ifdef _IA64_
#pragma message("     _IA64_")
#endif

//
// UNICODE - Set to make the build Unicode.
//
#ifdef UNICODE
#pragma message("     UNICODE")
#endif

//
// _WIN64 - 64-bit windows
//
#ifdef _WIN64
#pragma message("     _WIN64")
#endif

//
// WINCE - Not _WIN64, _XBOX, WINNT, or WIN95
//
#ifdef WINCE
#pragma message("     WINCE")
#endif

//
// WINNT - Not WINCE, _XBOX, or WIN95
//
#ifdef WINNT
#pragma message("     WINNT")
#endif

//
// WIN95 - Not WINCE, _XBOX, or WINNT
//
#ifdef WIN95
#pragma message("     WIN95")
#endif

//
// WINCE_ON_DESKTOP - Used to make a desktop CE-like build
//
#ifdef WINCE_ON_DESKTOP
#pragma message("     WINCE_ON_DESKTOP")
#endif

//
// _X86_ - Compile for Intel x86 processors
//
#ifdef _X86_
#pragma message("     _X86_")
#endif

//
// _XBOX - Not _WIN64, WINCE, WINNT, or WIN95
//
#ifdef _XBOX
#pragma message("     _XBOX")
#endif

//
// XBOX_ON_DESKTOP - Used to make a desktop Xbox-like build
//
#ifdef XBOX_ON_DESKTOP
#pragma message("     XBOX_ON_DESKTOP")
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


//
// DPNBUILD_ASYNCSPSENDS - Have the SP implement asynchronous sends
//
#ifdef DPNBUILD_ASYNCSPSENDS
#pragma message("     DPNBUILD_ASYNCSPSENDS")
#endif

//
// DPNBUILD_COALESCEALWAYS - Always attempt to coalesce frames (don't use with DPNBUILD_COALESCENEVER)
//
#ifdef DPNBUILD_COALESCEALWAYS
#pragma message("     DPNBUILD_COALESCEALWAYS")
#endif

//
// DPNBUILD_COALESCENEVER - Never attempt to coalesce frames (don't use with DPNBUILD_COALESCEALWAYS)
//
#ifdef DPNBUILD_COALESCENEVER
#pragma message("     DPNBUILD_COALESCENEVER")
#endif

//
// DPNBUILD_DONTCHECKFORMISSEDTIMERS - Don't have the unified thread pool check for missed short timers
//
#ifdef DPNBUILD_DONTCHECKFORMISSEDTIMERS
#pragma message("     DPNBUILD_DONTCHECKFORMISSEDTIMERS")
#endif

//
// DPNBUILD_DYNAMICTIMERSETTINGS - Store timer settings at run time so they can be dynamically changed
//
#ifdef DPNBUILD_DYNAMICTIMERSETTINGS
#pragma message("     DPNBUILD_DYNAMICTIMERSETTINGS")
#endif

//
// DPNBUILD_ENV_NT - Building under the NT build environment
//
#ifdef DPNBUILD_ENV_NT
#pragma message("     DPNBUILD_ENV_NT")
#endif

//
// DPNBUILD_FIXEDMEMORYMODEL - Set a cap on the maximum amount of memory that can be allocated
//
#ifdef DPNBUILD_FIXEDMEMORYMODEL
#pragma message("     DPNBUILD_FIXEDMEMORYMODEL")
#endif

//
// DPNBUILD_LIBINTERFACE - Use a lib interface instead of a COM style interface
//
#ifdef DPNBUILD_LIBINTERFACE
#pragma message("     DPNBUILD_LIBINTERFACE")
#endif

//
// DPNBUILD_MANDATORYTHREADS - Support thread pool "mandatory" threads
//
#ifdef DPNBUILD_MANDATORYTHREADS
#pragma message("     DPNBUILD_MANDATORYTHREADS")
#endif

//
// DPNBUILD_NOADDRESSIPINTERFACE - Don't support the IDirectPlay8AddressIP interface
//
#ifdef DPNBUILD_NOADDRESSIPINTERFACE
#pragma message("     DPNBUILD_NOADDRESSIPINTERFACE")
#endif

//
// DPNBUILD_NOBLUETOOTH - Stop bluetooth SP being incorporated
//
#ifdef DPNBUILD_NOBLUETOOTH
#pragma message("     DPNBUILD_NOBLUETOOTH")
#endif

//
// DPNBUILD_NOCOMEMULATION - Set for platforms that don't need the COM emulation layer
//
#ifdef DPNBUILD_NOCOMEMULATION
#pragma message("     DPNBUILD_NOCOMEMULATION")
#endif

//
// DPNBUILD_NOCOMREGISTER - Don't implement DllRegisterServer and DllUnregisterServer
//
#ifdef DPNBUILD_NOCOMREGISTER
#pragma message("     DPNBUILD_NOCOMREGISTER")
#endif

//
// DPNBUILD_NOHNETFWAPI - Used in NAT Help when Home Networking firewall traversal API isn't available
//
#ifdef DPNBUILD_NOHNETFWAPI
#pragma message("     DPNBUILD_NOHNETFWAPI")
#endif

//
// DPNBUILD_NOHOSTMIGRATE - Removes the Peer Host Migration feature
//
#ifdef DPNBUILD_NOHOSTMIGRATE
#pragma message("     DPNBUILD_NOHOSTMIGRATE")
#endif

//
// DPNBUILD_NOICSADAPTERSELECTIONLOGIC - Don't let the SP try to be smart about the adapter to use for enumerating/connecting on Internet Connection Sharing machines
//
#ifdef DPNBUILD_NOICSADAPTERSELECTIONLOGIC
#pragma message("     DPNBUILD_NOICSADAPTERSELECTIONLOGIC")
#endif

//
// DPNBUILD_NOIMAGEHLP - Set for platforms where Imagehlp.dll is not available
//
#ifdef DPNBUILD_NOIMAGEHLP
#pragma message("     DPNBUILD_NOIMAGEHLP")
#endif

//
// DPNBUILD_NOIPX - Remove the IPX service provider
//
#ifdef DPNBUILD_NOIPX
#pragma message("     DPNBUILD_NOIPX")
#endif

//
// DPNBUILD_NOIPV6 - Remove the IPv6 service provider
//
#ifdef DPNBUILD_NOIPV6
#pragma message("     DPNBUILD_NOIPV6")
#endif

//
// DPNBUILD_NOLEGACYDP - Remove IDirectPlay4 addressing support
//
#ifdef DPNBUILD_NOLEGACYDP
#pragma message("     DPNBUILD_NOLEGACYDP")
#endif

//
// DPNBUILD_NOLOBBY - Remove lobby support from core.
//
#ifdef DPNBUILD_NOLOBBY
#pragma message("     DPNBUILD_NOLOBBY")
#endif

//
// DPNBUILD_NOLOCALNAT - Remove support for a local Internet gateway
//
#ifdef DPNBUILD_NOLOCALNAT
#pragma message("     DPNBUILD_NOLOCALNAT")
#endif

//
// DPNBUILD_NOMISSEDTIMERSHINT - Don't have the unified thread pool try to hint about possible missed short timers
//
#ifdef DPNBUILD_NOMISSEDTIMERSHINT
#pragma message("     DPNBUILD_NOMISSEDTIMERSHINT")
#endif

//
// DPNBUILD_NOMULTICAST - Used to disable multicast capabilities
//
#ifdef DPNBUILD_NOMULTICAST
#pragma message("     DPNBUILD_NOMULTICAST")
#endif

//
// DPNBUILD_NONATHELP - Remove use of NatHelp from DPlay
//
#ifdef DPNBUILD_NONATHELP
#pragma message("     DPNBUILD_NONATHELP")
#endif

//
// DPNBUILD_NOPARAMVAL - Parameter validation - ON for CE & Xbox Retail, OFF for Debug
//
#ifdef DPNBUILD_NOPARAMVAL
#pragma message("     DPNBUILD_NOPARAMVAL")
#endif

//
// DPNBUILD_NOPROTOCOLTESTITF - Removes the Protocol testing interface.  ON in Retail, OFF in Debug
//
#ifdef DPNBUILD_NOPROTOCOLTESTITF
#pragma message("     DPNBUILD_NOPROTOCOLTESTITF")
#endif

//
// DPNBUILD_NOREGISTRY - Removes registry based override parameters from DPlay
//
#ifdef DPNBUILD_NOREGISTRY
#pragma message("     DPNBUILD_NOREGISTRY")
#endif

//
// DPNBUILD_NOSERIALSP - Remove the Serial and Modem service providers
//
#ifdef DPNBUILD_NOSERIALSP
#pragma message("     DPNBUILD_NOSERIALSP")
#endif

//
// DPNBUILD_NOSERVER - Removes the IDirectPlay8Server interface, allowing only Client and Peer-to-Peer
//
#ifdef DPNBUILD_NOSERVER
#pragma message("     DPNBUILD_NOSERVER")
#endif

//
// DPNBUILD_NOSPUI - No UI in the Service Providers
//
#ifdef DPNBUILD_NOSPUI
#pragma message("     DPNBUILD_NOSPUI")
#endif

//
// DPNBUILD_NOVOICE - Removes DirectPlay Voice support from DirectPlay
//
#ifdef DPNBUILD_NOVOICE
#pragma message("     DPNBUILD_NOVOICE")
#endif

//
// DPNBUILD_NOWAITABLETIMERSON9X - Don't use waitable timer objects in Windows 9x builds
//
#ifdef DPNBUILD_NOWAITABLETIMERSON9X
#pragma message("     DPNBUILD_NOWAITABLETIMERSON9X")
#endif

//
// DPNBUILD_NOWINMM - Set for platforms where winmm.dll is not available
//
#ifdef DPNBUILD_NOWINMM
#pragma message("     DPNBUILD_NOWINMM")
#endif

//
// DPNBUILD_NOWINSOCK2 - Force the IP Service Provider to only use Winsock 1 features
//
#ifdef DPNBUILD_NOWINSOCK2
#pragma message("     DPNBUILD_NOWINSOCK2")
#endif

//
// DPNBUILD_ONLYONEADAPTER - Uses simplified code that assumes only a single adapter/device exists per SP
//
#ifdef DPNBUILD_ONLYONEADAPTER
#pragma message("     DPNBUILD_ONLYONEADAPTER")
#endif

//
// DPNBUILD_ONLYONENATHELP - Uses simplified code that assumes only a single NAT Help provider exists
//
#ifdef DPNBUILD_ONLYONENATHELP
#pragma message("     DPNBUILD_ONLYONENATHELP")
#endif

//
// DPNBUILD_ONLYONEPROCESSOR - Uses simplified code that assumes that only one processor exists
//
#ifdef DPNBUILD_ONLYONEPROCESSOR
#pragma message("     DPNBUILD_ONLYONEPROCESSOR")
#endif

//
// DPNBUILD_ONLYONESP - Uses simplified code that assumes only a single service provider exists
//
#ifdef DPNBUILD_ONLYONESP
#pragma message("     DPNBUILD_ONLYONESP")
#endif

//
// DPNBUILD_ONLYONETHREAD - Uses simplified code that assumes only one thread will ever access DPlay
//
#ifdef DPNBUILD_ONLYONETHREAD
#pragma message("     DPNBUILD_ONLYONETHREAD")
#endif

//
// DPNBUILD_ONLYWINSOCK2 - Force the IP Service Provider to only use Winsock 2 features
//
#ifdef DPNBUILD_ONLYWINSOCK2
#pragma message("     DPNBUILD_ONLYWINSOCK2")
#endif

//
// DPNBUILD_PREALLOCATEDMEMORYMODEL - Pre-allocate a fixed working set of memory up front, don't allow additional allocations
//
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
#pragma message("     DPNBUILD_PREALLOCATEDMEMORYMODEL")
#endif

//
// DPNBUILD_SINGLEPROCESS - Integrates DPNSVR code into the main DLL and assumes only a single process will use DPlay at a time
//
#ifdef DPNBUILD_SINGLEPROCESS
#pragma message("     DPNBUILD_SINGLEPROCESS")
#endif

//
// DPNBUILD_SOFTTHREADAFFINITY - Only sets an ideal processor for thread pool threads instead of a hard affinity mask
//
#ifdef DPNBUILD_SOFTTHREADAFFINITY
#pragma message("     DPNBUILD_SOFTTHREADAFFINITY")
#endif

//
// DPNBUILD_THREADPOOLSTATISTICS - Tracks statistics regarding the thread pool for debugging/tuning
//
#ifdef DPNBUILD_THREADPOOLSTATISTICS
#pragma message("     DPNBUILD_THREADPOOLSTATISTICS")
#endif

//
// DPNBUILD_USEASSUME - Uses the __assume compiler key word for DNASSERTs in retail builds
//
#ifdef DPNBUILD_USEASSUME
#pragma message("     DPNBUILD_USEASSUME")
#endif

//
// DPNBUILD_USEIOCOMPLETIONPORTS - Uses I/O completion ports in the thread pool
//
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
#pragma message("     DPNBUILD_USEIOCOMPLETIONPORTS")
#endif

//
// DPNBUILD_WINSOCKSTATISTICS - Track statistics regarding the Winsock for debugging/tuning
//
#ifdef DPNBUILD_WINSOCKSTATISTICS
#pragma message("     DPNBUILD_WINSOCKSTATISTICS")
#endif

//
// DPNBUILD_XNETSECURITY - Supports XNet security features
//
#ifdef DPNBUILD_XNETSECURITY
#pragma message("     DPNBUILD_XNETSECURITY")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dnlobbyi.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNLOBBYI.h
 *  Content:    DirectPlay Lobby master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNLOBBYI_H__
#define __DNLOBBYI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <tchar.h>
#include <tlhelp32.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dplobby8.h"
#include "dpaddr.h"

#ifdef UNICODE
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLW
#else
#define IDirectPlay8Address_GetURL IDirectPlay8Address_GetURLA
#endif // UNICODE

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dneterrors.h"
#include "dndbg.h"
#include "comutil.h"
#include "classbilink.h"
#include "packbuff.h"
#include "strutils.h"
#include "creg.h"
#include "FixedPool.h"
#include "ClassFactory.h"
#include "HandleTable.h"

// 
// DirectPlay Core includes
//
#include "message.h"

// 
// Lobby private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_LOBBY

#include "classfac.h"
#include "verinfo.h"	//	For TIME BOMB

#include "DPLApp.h"
#include "DPLClient.h"
#include "DPLCommon.h"
#include "DPLConnect.h"
#include "DPLConset.h"
#include "DPLMsgQ.h"
#include "DPLobby8Int.h"
#include "DPLParam.h"
#include "DPLProc.h"
#include "DPLProt.h"
#include "DPLReg.h"

#include "dpnlobbyextern.h"


#endif // __DNLOBBYI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplapp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLApp.cpp
 *  Content:    DirectPlay Lobbied Application Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *  03/22/2000	jtk		Changed interface names
 *  04/18/2000	rmt     Added additional parameter validation
 *  04/25/2000	rmt     Bug #s 33138, 33145, 33150 
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  05/03/00    rmt     DPL_UnRegister was not implemented!!
 *  05/08/00    rmt     Bug #34301 - Add flag to SetAppAvail to allow for multiple connects
 *   06/15/00   rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances  
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  07/14/2000	rmt		Bug #39257 - LobbyClient::ReleaseApp returns E_OUTOFMEMORY when called when no one connected
 *				rmt		Bug #39487 - Remove WaitForConnect
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/15/2000	rmt		Bug #42273 - DPLAY8: Samples sometimes get a DPNERR_ALREADYREGISTERED error.  (Double connections)
 *  08/18/2000	rmt		Bug #42751 - DPLOBBY8: Prohibit more than one lobby client or lobby app per process
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************



typedef STDMETHODIMP AppQueryInterface(IDirectPlay8LobbiedApplication *pInterface,REFIID ridd,PVOID *ppvObj);
typedef STDMETHODIMP_(ULONG)	AppAddRef(IDirectPlay8LobbiedApplication *pInterface);
typedef STDMETHODIMP_(ULONG)	AppRelease(IDirectPlay8LobbiedApplication *pInterface);
typedef STDMETHODIMP AppRegisterMessageHandler(IDirectPlay8LobbiedApplication *pInterface,const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,	DPNHANDLE * const pdpnhConnection, const DWORD dwFlags);
typedef	STDMETHODIMP AppSend(IDirectPlay8LobbiedApplication *pInterface,const DPNHANDLE hTarget,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags);
typedef STDMETHODIMP AppClose(IDirectPlay8LobbiedApplication *pInterface, const DWORD dwFlags);
typedef STDMETHODIMP AppGetConnectionSettings(IDirectPlay8LobbiedApplication *pInterface, const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags );	
typedef STDMETHODIMP AppSetConnectionSettings(IDirectPlay8LobbiedApplication *pInterface, const DPNHANDLE hTarget, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags );

IDirectPlay8LobbiedApplicationVtbl DPL_8LobbiedApplicationVtbl =
{
	(AppQueryInterface*)			DPL_QueryInterface,
	(AppAddRef*)					DPL_AddRef,
	(AppRelease*)					DPL_Release,
	(AppRegisterMessageHandler*)	DPL_RegisterMessageHandler,
									DPL_RegisterProgram,
									DPL_UnRegisterProgram,
	(AppSend*)						DPL_Send,
									DPL_SetAppAvailable,
									DPL_UpdateStatus,
	(AppClose*)						DPL_Close,
	(AppGetConnectionSettings*)     DPL_GetConnectionSettings,
	(AppSetConnectionSettings*)     DPL_SetConnectionSettings	
};


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RegisterProgram"

STDMETHODIMP DPL_RegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
								 DPL_PROGRAM_DESC *const pdplProgramDesc,
								 const DWORD dwFlags)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pdplProgramDesc [0x%p], dwFlags [0x%lx]",
			pInterface,pdplProgramDesc,dwFlags);

#ifndef DPNBUILD_NOPARAMVAL
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;	

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateRegisterProgram( pInterface , pdplProgramDesc, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating register params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPLWriteProgramDesc(pdplProgramDesc);

	DPF_RETURN(hResultCode);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_UnRegisterProgram"

STDMETHODIMP DPL_UnRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
								   GUID *const pGuidApplication,
								   const DWORD dwFlags)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pGuidApplication [0x%p], dwFlags [0x%lx]",
			pInterface,pGuidApplication,dwFlags);

#ifndef DPNBUILD_NOPARAMVAL
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;		

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateUnRegisterProgram( pInterface , pGuidApplication, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating unregister params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}		
#endif // !DPNBUILD_NOPARAMVAL

	hResultCode = DPLDeleteProgramDesc( pGuidApplication );

	DPF_RETURN(hResultCode);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetAppAvailable"
STDMETHODIMP DPL_SetAppAvailable(IDirectPlay8LobbiedApplication *pInterface, const BOOL fAvailable, const DWORD dwFlags )
{
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	HRESULT					hResultCode;

	DPFX(DPFPREP, 3,"Parameters: (none)");

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
#ifndef DPNBUILD_NOPARAMVAL
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateSetAppAvailable( pInterface, fAvailable, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating makeappavail params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	
#endif // !DPNBUILD_NOPARAMVAL

    if( fAvailable )
    {
    	// Indicate that we are waiting
    	pdpLobbyObject->pReceiveQueue->MakeAvailable();

    	if( dwFlags & DPLAVAILABLE_ALLOWMULTIPLECONNECT )
    	{
    	    pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_MULTICONNECT;
    	}
    	else
    	{
    	    pdpLobbyObject->dwFlags &= ~(DPL_OBJECT_FLAG_MULTICONNECT);
    	}
    }
    else
    {
        pdpLobbyObject->pReceiveQueue->MakeUnavailable();
    }

	hResultCode = DPN_OK;

	DPF_RETURN(hResultCode);
}



//	DPL_UpdateStatus
//
//	Send session status information to the lobby client.  This should be called whenever
//	the lobbied application connects to the game, fails to connect, disconnects, or is
//	terminated (booted).

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_UpdateStatus"

STDMETHODIMP DPL_UpdateStatus(IDirectPlay8LobbiedApplication *pInterface,
							  const DPNHANDLE hLobbyClient,
							  const DWORD dwStatus, const DWORD dwFlags )
{
	HRESULT								hResultCode;
	DIRECTPLAYLOBBYOBJECT				*pdpLobbyObject;
	DPL_CONNECTION						*pdplConnection;
	DPL_INTERNAL_MESSAGE_UPDATE_STATUS	Msg;
	DPNHANDLE							*hTargets = NULL;
	DWORD								dwNumTargets = 0;
	DWORD								dwTargetIndex = 0;


	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], hLobbyClient [0x%lx], dwStatus [0x%lx]",
			pInterface,hLobbyClient,dwStatus);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
#ifndef DPNBUILD_NOPARAMVAL
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateUpdateStatus( pInterface, hLobbyClient, dwStatus, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating updatestatus params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	
#endif // !DPNBUILD_NOPARAMVAL

	Msg.dwMsgId = DPL_MSGID_INTERNAL_UPDATE_STATUS;
	Msg.dwStatus = dwStatus;

	if( hLobbyClient == DPLHANDLE_ALLCONNECTIONS )
	{
		dwNumTargets = 0;

		// We need loop so if someone adds a connection during our run
		// it gets added to our list
		//
		while( 1 )
		{
			hResultCode = DPLConnectionEnum( pdpLobbyObject, hTargets, &dwNumTargets );

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( hTargets )
				{
					delete [] hTargets;
				}

				hTargets = new DPNHANDLE[dwNumTargets];

				if( hTargets == NULL )
				{
					DPFERR("Error allocating memory" );
					hResultCode = DPNERR_OUTOFMEMORY;
					dwNumTargets = 0;
					goto EXIT_AND_CLEANUP;
				}

				memset( hTargets, 0x00, sizeof(DPNHANDLE)*dwNumTargets);

				continue;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error getting list of connections hr=0x%x", hResultCode );
				break;
			}
			else
			{
				break;
			}
		}

		// Failed getting connection information
		if( FAILED( hResultCode ) )
		{
			if( hTargets )
			{
				delete [] hTargets;
				hTargets = NULL;
			}
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

	}
	else
	{
		hTargets = new DPNHANDLE[1]; // We use array delete below so we need array new

		if( hTargets == NULL )
		{
			DPFERR("Error allocating memory" );
			hResultCode = DPNERR_OUTOFMEMORY;
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

		dwNumTargets = 1;
		hTargets[0] = hLobbyClient;
	}
		
	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hTargets[dwTargetIndex],&pdplConnection,TRUE)) != DPN_OK)
		{
			DPFERR("Invalid send target");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDHANDLE;
			goto EXIT_AND_CLEANUP;
		}

		DNASSERT(pdplConnection->pSendQueue != NULL);

		if (!pdplConnection->pSendQueue->IsReceiving())
		{
			DPFERR("Other side is not listening");
			hResultCode = DPNERR_INVALIDHANDLE;
			goto EXIT_AND_CLEANUP;
		}

		hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(&Msg),
												   sizeof(DPL_INTERNAL_MESSAGE_UPDATE_STATUS),
												   INFINITE,
												   DPL_MSGQ_MSGFLAGS_USER1,
												   0);

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error sending to connection 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
		}
	}

EXIT_AND_CLEANUP:

	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if( hTargets[dwTargetIndex] )
			DPLConnectionRelease(pdpLobbyObject,hTargets[dwTargetIndex]);
	}

	if( hTargets )
		delete [] hTargets;

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLAttemptLobbyConnection"

HRESULT DPLAttemptLobbyConnection(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject)
{
	PTSTR	pszCommandLine;
	TCHAR	*c;
	DWORD	dwCommandLineSize;
	TCHAR	pszObjectName[(sizeof(DWORD)*2)*2 + 1 + 1];
	DNHANDLE hSyncEvent;
	HRESULT	hResultCode;
	DNHANDLE hFileMap;
	DPL_SHARED_CONNECT_BLOCK	*pSharedBlock;
	DWORD	dwError;
	DWORD	dwReturnValue;

	DPFX(DPFPREP, 3,"Parameters: (none)");

	// Need a copy of the command line
	dwCommandLineSize = (_tcslen(GetCommandLine()) + 1) * sizeof(TCHAR);
	if ((pszCommandLine = static_cast<PTSTR>(DNMalloc(dwCommandLineSize))) == NULL)
	{
		DPFERR("Allocating memory failed");
		return(DPNERR_OUTOFMEMORY);
	}
	_tcscpy(pszCommandLine,GetCommandLine());

	DPFX(DPFPREP, 5,"Got command line [%s]",pszCommandLine);

	// Try to find Lobby Launch ID string
	c = _tcsstr(pszCommandLine,DPL_ID_STR);
	if (c == NULL)
	{
		DNFree(pszCommandLine);
		return(DPNERR_GENERIC);
	}
	c += _tcslen(DPL_ID_STR);
	c--; // We are going to overwrite the '=' with a IDCHAR below
	_tcsncpy(pszObjectName,c,(sizeof(DWORD)*2)*2 + 1);
	pszObjectName[(sizeof(DWORD)*2)*2 + 1] = _T('\0');		// Ensure null terminated

	DPFX(DPFPREP, 5,"Got object name [%s]",pszObjectName);

	DNFree(pszCommandLine);

	// Try to open shared memory
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_FILEMAP;
	hFileMap = DNCreateFileMapping(INVALID_HANDLE_VALUE,(LPSECURITY_ATTRIBUTES) NULL,
		PAGE_READWRITE,0,sizeof(DPL_SHARED_CONNECT_BLOCK),pszObjectName);
	if (hFileMap == NULL)
	{
		DPFERR("CreateFileMapping() failed");
		dwError = GetLastError();
		DNASSERT(FALSE);
		return(DPNERR_GENERIC);
	}

	// Ensure it existed already
	dwError = GetLastError();
	if (dwError != ERROR_ALREADY_EXISTS)
	{
		DPFERR("File mapping did not already exist");
//		DNASSERT(FALSE);
		DNCloseHandle(hFileMap);
		return(DPNERR_GENERIC);
	}

	// Map file
	pSharedBlock = reinterpret_cast<DPL_SHARED_CONNECT_BLOCK*>(MapViewOfFile(HANDLE_FROM_DNHANDLE(hFileMap),FILE_MAP_ALL_ACCESS,0,0,0));
	if (pSharedBlock == NULL)
	{
		DPFERR("MapViewOfFile() failed");
		dwError = GetLastError();
		DNASSERT(FALSE);
		DNCloseHandle(hFileMap);
		return(DPNERR_GENERIC);
	}


	// Try to open connection event
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_EVENT;
	hSyncEvent = DNOpenEvent(EVENT_MODIFY_STATE,FALSE,pszObjectName);
	if (hSyncEvent == NULL)
	{
		DPFERR("OpenEvent() failed");
		dwError = GetLastError();
		DNASSERT(FALSE);
		UnmapViewOfFile(pSharedBlock);
		DNCloseHandle(hFileMap);
		return(DPNERR_GENERIC);
	}
	DPFX(DPFPREP, 5,"Opened sync event");

	DNResetEvent(pdpLobbyObject->hConnectEvent);

	// Look for lobby launch -- set lobby launch value if connection is received
	pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_LOOKINGFORLOBBYLAUNCH;

	// Make application available for connection by lobby client
	DNASSERT(pdpLobbyObject->pReceiveQueue != NULL);

	// Signal lobby client
	pSharedBlock->dwPID = pdpLobbyObject->dwPID;
	DNSetEvent(hSyncEvent);

	dwReturnValue = DNWaitForSingleObject(pdpLobbyObject->hConnectEvent,DPL_LOBBYLAUNCHED_CONNECT_TIMEOUT);

	// Turn off the looking for lobby launch flag
	pdpLobbyObject->dwFlags &= ~(DPL_OBJECT_FLAG_LOOKINGFORLOBBYLAUNCH);

	if (dwReturnValue == WAIT_OBJECT_0)
	{
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_TIMEDOUT;
	}

	// Clean up
	DNCloseHandle(hSyncEvent);
	UnmapViewOfFile(pSharedBlock);
	DNCloseHandle(hFileMap);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplclassfac.cpp
 *  Content:    DirectPlay Lobby COM Class Factory
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   03/22/2000	jtk		Changed interface names
 *   04/18/2000 rmt     Updated object create to set param validation flag
 *   05/09/2000 rmt     Bug #34306 QueryInterface on lobbyclient for lobbiedapp works (and shouldn't).
 *   06/07/2000	rmt		Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *   06/20/2000 rmt     Bugfix - QueryInterface had bug which was limiting interface list to 2 elements
 *   07/08/2000	rmt		Added guard bytes
 *   08/05/2000 RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *   08/08/2000	rmt		Removed assert which wasn't needed
 *   01/11/2001	rmt		MANBUG #48487 - DPLAY: Crashes if CoCreate() isn't called.   
 *   03/14/2001 rmt		WINBUG #342420 - Restore COM emulation layer to operation. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	STDMETHODIMP IUnknownQueryInterface( IUnknown *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	IUnknownAddRef( IUnknown *pInterface );
typedef	STDMETHODIMP_(ULONG)	IUnknownRelease( IUnknown *pInterface );

//
// VTable for IUnknown interface
//
IUnknownVtbl  DN_LobbyUnknownVtbl =
{
	(IUnknownQueryInterface*)	DPL_QueryInterface,
	(IUnknownAddRef*)			DPL_AddRef,
	(IUnknownRelease*)			DPL_Release
};


//
// VTable for Class Factory
//
IClassFactoryVtbl DPLCF_Vtbl =
{
	DPCF_QueryInterface, // dnet\common\classfactory.cpp will provide these
	DPCF_AddRef,
	DPCF_Release,
	DPLCF_CreateInstance,
	DPCF_LockServer
};

//**********************************************************************
// Variable definitions
//**********************************************************************

#ifndef DPNBUILD_LIBINTERFACE
//
// Globals
//
extern	LONG	g_lLobbyObjectCount;
#endif // ! DPNBUILD_LIBINTERFACE

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_CreateObject"

HRESULT DPLCF_CreateObject(IClassFactory *pInterface, LPVOID *lplpv, REFIID riid)
{

	HRESULT					hResultCode = S_OK;
	PDIRECTPLAYLOBBYOBJECT	pdpLobbyObject = NULL;
	const _IDirectPlayClassFactory*	lpcfObj = (_PIDirectPlayClassFactory)pInterface;


	DPFX(DPFPREP, 3,"Parameters: lplpv [%p]",lplpv);

	/*
	*
	*	TIME BOMB
	*
	*/

#ifndef DX_FINAL_RELEASE
{
#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
	SYSTEMTIME st;
	GetSystemTime(&st);

	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
	{
		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
//		return E_FAIL;
	}
}
#endif // !DX_FINAL_RELEASE

	if ((pdpLobbyObject = (PDIRECTPLAYLOBBYOBJECT)DNMalloc(sizeof(DIRECTPLAYLOBBYOBJECT))) == NULL)
	{
		return(E_OUTOFMEMORY);
	}
	DPFX(DPFPREP, 5,"pdpLobbyObject [%p]",pdpLobbyObject);

	// Set allocatable elements to NULL to simplify free'ing later on
	pdpLobbyObject->dwSignature = DPLSIGNATURE_LOBBYOBJECT;
	pdpLobbyObject->hReceiveThread = NULL;
	pdpLobbyObject->dwFlags = 0;
	pdpLobbyObject->hConnectEvent = NULL;
	pdpLobbyObject->pfnMessageHandler = NULL;
	pdpLobbyObject->pvUserContext = NULL;
	pdpLobbyObject->lLaunchCount = 0;
	pdpLobbyObject->dpnhLaunchedConnection = NULL;

	pdpLobbyObject->pReceiveQueue = NULL;

	pdpLobbyObject->dwPID = GetCurrentProcessId();

	pdpLobbyObject->m_dwConnectionCount = 0;
	pdpLobbyObject->m_blConnections.Initialize();

	if (FAILED(pdpLobbyObject->m_HandleTable.Initialize()))
	{
		DPLCF_FreeObject(pdpLobbyObject);
		return(hResultCode);
	}
	pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_HANDLETABLE_INITED;

	if (!DNInitializeCriticalSection(&pdpLobbyObject->m_cs))
	{
		DPLCF_FreeObject(pdpLobbyObject);
		hResultCode = DPNERR_OUTOFMEMORY;
		return(hResultCode);
	}
	pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_CRITSEC_INITED;

	if ((pdpLobbyObject->hConnectEvent = DNCreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
	{
		DPLCF_FreeObject(pdpLobbyObject);
		hResultCode = DPNERR_OUTOFMEMORY;
		return(hResultCode);
	}

	if ((pdpLobbyObject->hLobbyLaunchConnectEvent = DNCreateEvent(NULL,TRUE,FALSE,NULL)) == NULL )
	{
		DPLCF_FreeObject(pdpLobbyObject);
		hResultCode = DPNERR_OUTOFMEMORY;
		return(hResultCode);
	}

	DPFX(DPFPREP, 5,"InitializeHandles() succeeded");

	if (IsEqualIID(riid,IID_IDirectPlay8LobbyClient) || 
		(riid == IID_IUnknown && lpcfObj->clsid == CLSID_DirectPlay8LobbyClient ) )
	{
		DPFX(DPFPREP, 5,"DirectPlay Lobby Client");
		pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_LOBBYCLIENT;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8LobbiedApplication) || 
		     (riid == IID_IUnknown && lpcfObj->clsid == CLSID_DirectPlay8LobbiedApplication ) )
	{
		DPFX(DPFPREP, 5,"DirectPlay Lobbied Application");
		pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_LOBBIEDAPPLICATION;
	}
	else
	{
		DPFX(DPFPREP, 5,"Invalid DirectPlay Lobby Interface");
		DPLCF_FreeObject(pdpLobbyObject);
		return(E_NOTIMPL);
	}
	
	pdpLobbyObject->dwFlags |= DPL_OBJECT_FLAG_PARAMVALIDATION;

	*lplpv = pdpLobbyObject;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *lplpv = [%p]",hResultCode,*lplpv);
	return(hResultCode);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_FreeObject"

HRESULT DPLCF_FreeObject(LPVOID lpv)
{
	HRESULT					hResultCode = S_OK;
	PDIRECTPLAYLOBBYOBJECT	pdpLobbyObject = NULL;

	if (lpv != NULL)
	{
		pdpLobbyObject = (PDIRECTPLAYLOBBYOBJECT)lpv;

		if (pdpLobbyObject->pReceiveQueue)
		{
			delete pdpLobbyObject->pReceiveQueue;
			pdpLobbyObject->pReceiveQueue = NULL;
		}

		if (pdpLobbyObject->hLobbyLaunchConnectEvent)
		{
			DNCloseHandle(pdpLobbyObject->hLobbyLaunchConnectEvent);
			pdpLobbyObject->hLobbyLaunchConnectEvent = 0;
		}

		if (pdpLobbyObject->hConnectEvent)
		{
			DNCloseHandle(pdpLobbyObject->hConnectEvent);
			pdpLobbyObject->hConnectEvent = 0;
		}

		if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_HANDLETABLE_INITED)
		{
			pdpLobbyObject->m_HandleTable.Deinitialize();
		}

		if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_CRITSEC_INITED)
		{
			DNDeleteCriticalSection(&pdpLobbyObject->m_cs);
		}

		pdpLobbyObject->dwSignature = DPLSIGNATURE_LOBBYOBJECT_FREE;

		pdpLobbyObject->dwFlags = 0;

		DPFX(DPFPREP, 5,"free pdpLobbyObject [%p]",pdpLobbyObject);
		DNFree(pdpLobbyObject);
	}
	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx]",hResultCode);

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLCF_CreateInstance"

STDMETHODIMP DPLCF_CreateInstance(IClassFactory *pInterface,
								  LPUNKNOWN lpUnkOuter,
								  REFIID riid,
								  LPVOID *ppv)
{
	HRESULT					hResultCode = S_OK;
	LPINTERFACE_LIST		lpIntList = NULL;
	LPOBJECT_DATA			lpObjectData = NULL;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], lpUnkOuter [0x%p], riid [0x%p], ppv [0x%p]",pInterface,lpUnkOuter,riid,ppv);

	if (lpUnkOuter != NULL)
	{
		return(CLASS_E_NOAGGREGATION);
	}

	lpObjectData = (LPOBJECT_DATA)g_fpObjectDatas.Get();
	if (lpObjectData == NULL)
	{
		DPFERR("Failed to get new object data from pool");
		return(E_OUTOFMEMORY);
	}
	DPFX(DPFPREP, 5,"lpObjectData [%p]",lpObjectData);

	// Object creation and initialization
	if ((hResultCode = DPLCF_CreateObject(pInterface,&lpObjectData->pvData,riid)) != S_OK)
	{
		g_fpObjectDatas.Release(lpObjectData);
		return(hResultCode);
	}
	DPFX(DPFPREP, 5,"Created and initialized object");

	// Get requested interface
	if ((hResultCode = DPL_CreateInterface(lpObjectData,riid,&lpIntList)) != S_OK)
	{
		DPLCF_FreeObject(lpObjectData->pvData);
		g_fpObjectDatas.Release(lpObjectData);
		return(hResultCode);
	}
	DPFX(DPFPREP, 5,"Found interface");

	lpObjectData->pIntList = lpIntList;
	lpObjectData->lRefCount = 1;
	DNInterlockedIncrement(&lpIntList->lRefCount );
	DNInterlockedIncrement(&g_lLobbyObjectCount);
	*ppv = lpIntList;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);

	return(S_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_CreateInterface"

static	HRESULT DPL_CreateInterface(LPOBJECT_DATA lpObject,
									REFIID riid,
									LPINTERFACE_LIST *const ppv)
{
	LPINTERFACE_LIST	lpIntNew;
	LPVOID				lpVtbl;

	DPFX(DPFPREP, 3,"Parameters: lpObject [%p], riid [%p], ppv [%p]",lpObject,riid,ppv);

	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 5,"riid = IID_IUnknown");
		lpVtbl = &DN_LobbyUnknownVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8LobbyClient))
	{
		DPFX(DPFPREP, 5,"riid = IID_IDirectPlay8LobbyClient");
		lpVtbl = &DPL_Lobby8ClientVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8LobbiedApplication))
	{
		DPFX(DPFPREP, 5,"riid = IID_IDirectPlay8LobbiedApplication");
		lpVtbl = &DPL_8LobbiedApplicationVtbl;
	}
	else
	{
		DPFX(DPFPREP, 5,"riid not found !");
		return(E_NOINTERFACE);
	}

	lpIntNew = (LPINTERFACE_LIST)g_fpInterfaceLists.Get();
	if (lpIntNew == NULL)
	{
		DPFERR("Failed to get new interface list from pool");
		return(E_OUTOFMEMORY);
	}
	lpIntNew->lpVtbl = lpVtbl;
	lpIntNew->lRefCount = 0;
	lpIntNew->pIntNext = NULL;
	DBG_CASSERT( sizeof( lpIntNew->iid ) == sizeof( riid ) );
	memcpy( &(lpIntNew->iid), &riid, sizeof( lpIntNew->iid ) );
	lpIntNew->pObject = lpObject;

	*ppv = lpIntNew;

	DPFX(DPFPREP, 3,"Returning: hResultCode = [S_OK], *ppv = [%p]",*ppv);

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_FindInterface"

LPINTERFACE_LIST DPL_FindInterface(LPVOID lpv, REFIID riid)
{
	LPINTERFACE_LIST	lpIntList;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p], riid [%p]",lpv,riid);

	lpIntList = ((LPINTERFACE_LIST)lpv)->pObject->pIntList;	// Find first interface

	while (lpIntList != NULL)
	{
		if (IsEqualIID(riid,lpIntList->iid))
			break;
		lpIntList = lpIntList->pIntNext;
	}
	DPFX(DPFPREP, 3,"Returning: lpIntList = [%p]",lpIntList);

	return(lpIntList);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_QueryInterface"

STDMETHODIMP DPL_QueryInterface(LPVOID lpv,REFIID riid,LPVOID *ppv)
{
	LPINTERFACE_LIST	lpIntList;
	LPINTERFACE_LIST	lpIntNew;
	HRESULT		hResultCode;
    PDIRECTPLAYLOBBYOBJECT pdpLobbyObject;		

	DPFX(DPFPREP, 3,"Parameters: lpv [0x%p], riid [0x%p], ppv [0x%p]",lpv,riid,ppv);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
   		lpIntList = (LPINTERFACE_LIST)lpv;
	    
#ifndef DPNBUILD_NOPARAMVAL
		// TODO: MASONB: Why no paramval flag wrapping this?
    	if( FAILED( hResultCode = DPL_ValidateQueryInterface( lpv,riid,ppv ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating QueryInterface params hr=[0x%lx]", hResultCode );
    	    DPF_RETURN(hResultCode);
    	}

    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION && 
    	    riid == IID_IDirectPlay8LobbyClient )
    	{
    	    DPFERR( "Cannot request lobbyclient interface from lobbyapp object" );
    	    return DPNERR_NOINTERFACE;
    	}
    	
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBYCLIENT &&
    	    riid == IID_IDirectPlay8LobbiedApplication )
    	{
    	    DPFERR( "Cannot request lobbied application interface from lobbyclient object" );
    	    return DPNERR_NOINTERFACE;
    	}    	
    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
    	DPF_RETURN(DPNERR_INVALIDOBJECT);
	}		
#endif // !DPNBUILD_NOPARAMVAL

    if ((lpIntList = DPL_FindInterface(lpv,riid)) == NULL)
	{	// Interface must be created
		lpIntList = ((LPINTERFACE_LIST)lpv)->pObject->pIntList;
		if ((hResultCode = DPL_CreateInterface(lpIntList->pObject,riid,&lpIntNew)) != S_OK)
		{
			DPF_RETURN(hResultCode);
		}
		lpIntNew->pIntNext = lpIntList;
		((LPINTERFACE_LIST)lpv)->pObject->pIntList = lpIntNew;
		lpIntList = lpIntNew;
	}
	if (lpIntList->lRefCount == 0)		// New interface exposed
	{
		DNInterlockedIncrement( &lpIntList->pObject->lRefCount );
	}
	DNInterlockedIncrement( &lpIntList->lRefCount );
	*ppv = lpIntList;

	DPF_RETURN(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_AddRef"

STDMETHODIMP_(ULONG) DPL_AddRef(LPVOID lpv)
{
	LPINTERFACE_LIST	lpIntList;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

  	lpIntList = (LPINTERFACE_LIST)lpv;

#ifndef DPNBUILD_NOPARAMVAL
    HRESULT hResultCode;
    PDIRECTPLAYLOBBYOBJECT pdpLobbyObject;	

	TRY
	{
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
	    
		// TODO: MASONB: Why no paramval flag wrapping this?
    	if( FAILED( hResultCode = DPL_ValidateAddRef( lpv ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating AddRef params hr=[0x%lx]", hResultCode );
    	    DPF_RETURN(0);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
    	DPF_RETURN(0);
	}		
#endif // !DPNBUILD_NOPARAMVAL

	DNInterlockedIncrement( &lpIntList->lRefCount );

	DPF_RETURN(lpIntList->lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Release"

STDMETHODIMP_(ULONG) DPL_Release(LPVOID lpv)
{
	LPINTERFACE_LIST	lpIntList;
	LPINTERFACE_LIST	lpIntCurrent;
    PDIRECTPLAYLOBBYOBJECT pdpLobbyObject;

	DPFX(DPFPREP, 3,"Parameters: lpv [%p]",lpv);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
   		lpIntList = (LPINTERFACE_LIST)lpv;
	    
#ifndef DPNBUILD_NOPARAMVAL
	    HRESULT hResultCode;
    	if( FAILED( hResultCode = DPL_ValidateRelease( lpv ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating release params hr=[0x%lx]", hResultCode );
        	DPF_RETURN(0);
    	}
	}	
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
    	DPF_RETURN(0);
	}	
#endif // !DPNBUILD_NOPARAMVAL

	DPFX(DPFPREP, 5,"Original : lpIntList->lRefCount = %ld",lpIntList->lRefCount);
	DPFX(DPFPREP, 5,"Original : lpIntList->pObject->lRefCount = %ld",lpIntList->pObject->lRefCount);

	if( DNInterlockedDecrement( &lpIntList->lRefCount ) == 0 )
	{	// Decrease interface count
		if( DNInterlockedDecrement( &lpIntList->pObject->lRefCount ) == 0 )
		{	// Free object and all interfaces
			DPFX(DPFPREP, 5,"Free object");

			if( pdpLobbyObject->pReceiveQueue )
			{
			    DPFX(DPFPREP,  0, "*******************************************************************" );
			    DPFX(DPFPREP,  0, "ERROR: Releasing object without calling close!" );
			    DPFX(DPFPREP,  0, "You MUST call Close before destroying the object" );
			    DPFX(DPFPREP,  0, "*******************************************************************" );
			    
			    DPL_Close( lpv, 0 );
			}

			// Free object here
			DPLCF_FreeObject(lpIntList->pObject->pvData);
			lpIntList = lpIntList->pObject->pIntList;	// Get head of interface list
			DPFX(DPFPREP, 5,"lpIntList->pObject [%p]",lpIntList->pObject);
			g_fpObjectDatas.Release(lpIntList->pObject);

			// Free Interfaces
			DPFX(DPFPREP, 5,"Free interfaces");
			while(lpIntList != NULL)
			{
				lpIntCurrent = lpIntList;
				lpIntList = lpIntList->pIntNext;
				DPFX(DPFPREP, 5,"\tinterface [%p]",lpIntCurrent);
				g_fpInterfaceLists.Release(lpIntCurrent);
			}

			DNInterlockedDecrement(&g_lLobbyObjectCount);
			DPFX(DPFPREP, 3,"Returning: 0");
			return(0);
		}
	}

	DPFX(DPFPREP, 3,"Returning: lpIntList->lRefCount = [%lx]",lpIntList->lRefCount);

	DPF_RETURN(lpIntList->lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplapp.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLApp.h
 *  Content:    DirectPlay Lobbied Application Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   03/22/2000	jtk		Changed interface names
 *   04/25/2000 rmt     Bug #s 33138, 33145, 33150 
  *  05/08/00   rmt     Bug #34301 - Add flag to SetAppAvail to allow for multiple connects
 *   06/15/00   rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *   07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLAPP_H__
#define	__DPLAPP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DIRECTPLAYLOBBYOBJECT DIRECTPLAYLOBBYOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DPL_LOBBYLAUNCHED_CONNECT_TIMEOUT	4000

//
// VTable for lobbied application interface
//
extern IDirectPlay8LobbiedApplicationVtbl DPL_8LobbiedApplicationVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

STDMETHODIMP DPL_RegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
							 PDPL_PROGRAM_DESC pdplProgramDesc,
							 const DWORD dwFlags);

STDMETHODIMP DPL_UnRegisterProgram(IDirectPlay8LobbiedApplication *pInterface,
							   GUID *pguidApplication,
							   const DWORD dwFlags);

STDMETHODIMP DPL_SetAppAvailable(IDirectPlay8LobbiedApplication *pInterface, const BOOL fAvailable, const DWORD dwFlags );

STDMETHODIMP DPL_WaitForConnection(IDirectPlay8LobbiedApplication *pInterface,
								   const DWORD dwMilliseconds, 
								   const DWORD dwFlags );

STDMETHODIMP DPL_UpdateStatus(IDirectPlay8LobbiedApplication *pInterface,
							  const DPNHANDLE hLobby,
							  const DWORD dwStatus,
							  const DWORD dwFlags );

HRESULT DPLAttemptLobbyConnection(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject);

#endif	// __DPLAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplclient.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNLClient.cpp
 *  Content:    DirectNet Lobby Client Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *  03/22/2000	jtk		Changed interface names
 *	04/05/2000	jtk		Changed GetValueSize to GetValueLength
 *  04/13/00	rmt     First pass param validation 
 *  04/25/2000	rmt     Bug #s 33138, 33145, 33150 
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  05/01/2000  rmt     Bug #33678 
 *  05/03/00    rmt     Bug #33879 -- Status messsage missing from field 
 *  05/30/00    rmt     Bug #35618 -- ConnectApp with ShortTimeout returns DPN_OK
 *  06/07/00    rmt     Bug #36452 -- Calling ConnectApplication twice could result in disconnection
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances  
 *  07/06/00	rmt		Updated for new registry parameters
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  07/14/2000	rmt		Bug #39257 - LobbyClient::ReleaseApp returns E_OUTOFMEMORY when called when no one connected
 *  07/21/2000	rmt		Bug #39578 - LobbyClient sample errors and quits -- memory corruption due to length vs. size problem
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  12/15/2000	rmt		Bug #48445 - Specifying empty launcher name results in error
 * 	04/19/2001	simonpow	Bug #369842 - Altered CreateProcess calls to take app name and cmd
 *							line as 2 separate arguments rather than one.
 *  06/16/2001	rodtoll	WINBUG #416983 -  RC1: World has full control to HKLM\Software\Microsoft\DirectPlay\Applications on Personal
 *						Implementing mirror of keys into HKCU.  Algorithm is now:
 *						- Read of entries tries HKCU first, then HKLM
 *						- Enum of entires is combination of HKCU and HKLM entries with duplicates removed.  HKCU takes priority.
 *						- Write of entries is HKLM and HKCU.  (HKLM may fail, but is ignored).
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

typedef STDMETHODIMP ClientQueryInterface(IDirectPlay8LobbyClient *pInterface,REFIID ridd,PVOID *ppvObj);
typedef STDMETHODIMP_(ULONG)	ClientAddRef(IDirectPlay8LobbyClient *pInterface);
typedef STDMETHODIMP_(ULONG)	ClientRelease(IDirectPlay8LobbyClient *pInterface);
typedef STDMETHODIMP ClientRegisterMessageHandler(IDirectPlay8LobbyClient *pInterface,const PVOID pvUserContext,const PFNDPNMESSAGEHANDLER pfn,const DWORD dwFlags);
typedef	STDMETHODIMP ClientSend(IDirectPlay8LobbyClient *pInterface,const DPNHANDLE hTarget,BYTE *const pBuffer,const DWORD pBufferSize,const DWORD dwFlags);
typedef STDMETHODIMP ClientClose(IDirectPlay8LobbyClient *pInterface,const DWORD dwFlags);
typedef STDMETHODIMP ClientGetConnectionSettings(IDirectPlay8LobbyClient *pInterface, const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags );	
typedef STDMETHODIMP ClientSetConnectionSettings(IDirectPlay8LobbyClient *pInterface, const DPNHANDLE hTarget, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags );

IDirectPlay8LobbyClientVtbl DPL_Lobby8ClientVtbl =
{
	(ClientQueryInterface*)			DPL_QueryInterface,
	(ClientAddRef*)					DPL_AddRef,
	(ClientRelease*)				DPL_Release,
	(ClientRegisterMessageHandler*)	DPL_RegisterMessageHandlerClient,
									DPL_EnumLocalPrograms,
									DPL_ConnectApplication,
	(ClientSend*)					DPL_Send,
									DPL_ReleaseApplication,
	(ClientClose*)					DPL_Close,
	(ClientGetConnectionSettings*)  DPL_GetConnectionSettings,
	(ClientSetConnectionSettings*)  DPL_SetConnectionSettings
};


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#define DPL_ENUM_APPGUID_BUFFER_INITIAL			8
#define DPL_ENUM_APPGUID_BUFFER_GROWBY			4	

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_EnumLocalPrograms"

STDMETHODIMP DPL_EnumLocalPrograms(IDirectPlay8LobbyClient *pInterface,
								   GUID *const pGuidApplication,
								   BYTE *const pEnumData,
								   DWORD *const pdwEnumDataSize,
								   DWORD *const pdwEnumDataItems,
								   const DWORD dwFlags )
{
	HRESULT			hResultCode;
	CMessageQueue	MessageQueue;
	CPackedBuffer	PackedBuffer;
	CRegistry		RegistryEntry;
	CRegistry		SubEntry;
	DWORD			dwSizeRequired;
	DWORD			dwMaxKeyLen;
	PWSTR			pwszKeyName = NULL;

	// Application name variables
	PWSTR			pwszApplicationName = NULL;
	DWORD			dwMaxApplicationNameLength;		// Includes null terminator
	DWORD			dwApplicationNameLength;		// Includes null terminator

	// Executable name variables
	PWSTR			pwszExecutableFilename = NULL;
	DWORD			dwMaxExecutableFilenameLength; // Includes null terminator
	DWORD			dwExecutableFilenameLength;	   // Includes null terminator

	DWORD			*pdwPID;
	DWORD			dwMaxPID;
	DWORD			dwNumPID;
	DWORD			dwEnumIndex;
	DWORD			dwEnumCount;
	DWORD			dwKeyLen;
	DWORD			dw;
	DPL_APPLICATION_INFO	dplAppInfo;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	GUID			*pAppLoadedList = NULL;			// List of GUIDs of app's we've enumerated
	DWORD			dwSizeAppLoadedList = 0;		// size of list pAppLoadedList
	DWORD			dwLengthAppLoadedList = 0;		// # of elements in list

	HKEY			hkCurrentBranch = HKEY_LOCAL_MACHINE;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pGuidApplication [0x%p], pEnumData [0x%p], pdwEnumDataSize [0x%p], pdwEnumDataItems [0x%p], dwFlags [0x%lx]",
			pInterface,pGuidApplication,pEnumData,pdwEnumDataSize,pdwEnumDataItems,dwFlags);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
#ifndef DPNBUILD_NOPARAMVAL
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateEnumLocalPrograms( pInterface, pGuidApplication, pEnumData, pdwEnumDataSize, pdwEnumDataItems, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating enum local programs params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}		
#endif // !DPNBUILD_NOPARAMVAL

	dwSizeRequired = *pdwEnumDataSize;
	PackedBuffer.Initialize(pEnumData,dwSizeRequired);
	pwszApplicationName = NULL;
	pwszExecutableFilename = NULL;
	pdwPID = NULL;
	dwMaxPID = 0;

	dwLengthAppLoadedList = 0;
	dwSizeAppLoadedList = DPL_ENUM_APPGUID_BUFFER_INITIAL;
	pAppLoadedList = static_cast<GUID*>(DNMalloc(sizeof(GUID)*dwSizeAppLoadedList));

	if( !pAppLoadedList )
	{
	    DPFERR("Failed allocating memory" );	
	    hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DPL_EnumLocalPrograms;
	}

	dwEnumCount = 0;

	DWORD dwIndex;
	for( dwIndex = 0; dwIndex < 2; dwIndex++ )
	{
		if( dwIndex == 0 )
		{
			hkCurrentBranch = HKEY_CURRENT_USER;
		}
		else
		{
			hkCurrentBranch = HKEY_LOCAL_MACHINE;
		}
		
		if (!RegistryEntry.Open(hkCurrentBranch,DPL_REG_LOCAL_APPL_SUBKEY,TRUE,FALSE,TRUE,DPL_REGISTRY_READ_ACCESS))
		{
			DPFX(DPFPREP,1,"On pass %i could not find app key", dwIndex);
			continue;
		}

		// Set up to enumerate
		if (!RegistryEntry.GetMaxKeyLen(&dwMaxKeyLen))
		{
			DPFERR("RegistryEntry.GetMaxKeyLen() failed");
			hResultCode = DPNERR_GENERIC;
			goto EXIT_DPL_EnumLocalPrograms;
		}
		dwMaxKeyLen++;	// Null terminator
		DPFX(DPFPREP, 7,"dwMaxKeyLen = %ld",dwMaxKeyLen);
		if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen*sizeof(WCHAR)))) == NULL)
		{
			DPFERR("DNMalloc() failed");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DPL_EnumLocalPrograms;
		}
		dwMaxApplicationNameLength = dwMaxKeyLen * sizeof(WCHAR);
		dwMaxExecutableFilenameLength = dwMaxApplicationNameLength;		

		if ((pwszApplicationName = static_cast<WCHAR*>(DNMalloc(dwMaxApplicationNameLength*sizeof(WCHAR)))) == NULL)	// Seed Application name size
		{
			DPFERR("DNMalloc() failed");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DPL_EnumLocalPrograms;
		}
		if ((pwszExecutableFilename = static_cast<WCHAR*>(DNMalloc(dwMaxExecutableFilenameLength*sizeof(WCHAR)))) == NULL)
		{
			DPFERR("DNMalloc() failed");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_DPL_EnumLocalPrograms;
		}
		dwEnumIndex = 0;
		dwKeyLen = dwMaxKeyLen;

		// Enumerate !
		while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
		{
			DPFX(DPFPREP, 7,"%ld - %ls (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);

			// Get Application name and GUID from each sub key
			if (!SubEntry.Open(RegistryEntry,pwszKeyName,TRUE,FALSE))
			{
				DPFX(DPFPREP, 7,"skipping %ls",pwszKeyName);
				goto LOOP_END;
			}

			//
			// Minara, double-check size vs. length for names
			//
			if (!SubEntry.GetValueLength(DPL_REG_KEYNAME_APPLICATIONNAME,&dwApplicationNameLength))
			{
				DPFX(DPFPREP, 7,"Could not get ApplicationName size.  Skipping [%ls]",pwszKeyName);
				goto LOOP_END;
			}

			// To include null terminator
			dwApplicationNameLength++;

			if (dwApplicationNameLength > dwMaxApplicationNameLength)
			{
				// grow buffer (taking into account that the reg functions always return WCHAR) and try again
				DPFX(DPFPREP, 7,"Need to grow pwszApplicationName from %ld to %ld",dwMaxApplicationNameLength,dwApplicationNameLength);
				if (pwszApplicationName != NULL)
				{
					DNFree(pwszApplicationName);
					pwszApplicationName = NULL;
				}
				if ((pwszApplicationName = static_cast<WCHAR*>(DNMalloc(dwApplicationNameLength*sizeof(WCHAR)))) == NULL)
				{
					DPFERR("DNMalloc() failed");
					hResultCode = DPNERR_OUTOFMEMORY;
					goto EXIT_DPL_EnumLocalPrograms;
				}
				dwMaxApplicationNameLength = dwApplicationNameLength;
			}

			if (!SubEntry.ReadString(DPL_REG_KEYNAME_APPLICATIONNAME,pwszApplicationName,&dwApplicationNameLength))
			{
				DPFX(DPFPREP, 7,"Could not read ApplicationName.  Skipping [%ls]",pwszKeyName);
				goto LOOP_END;
			}

			DPFX(DPFPREP, 7,"ApplicationName = %ls (%ld WCHARs)",pwszApplicationName,dwApplicationNameLength);

			if (!SubEntry.ReadGUID(DPL_REG_KEYNAME_GUID, &dplAppInfo.guidApplication))
			{
				DPFERR("SubEntry.ReadGUID failed - skipping entry");
				goto LOOP_END;
			}

			DWORD dwGuidSearchIndex;
			for( dwGuidSearchIndex = 0; dwGuidSearchIndex < dwLengthAppLoadedList; dwGuidSearchIndex++ )
			{
				if( pAppLoadedList[dwGuidSearchIndex] == dplAppInfo.guidApplication )
				{
					DPFX(DPFPREP, 1, "Ignoring local machine entry for current user version of entry [%ls]", pwszApplicationName );
					goto LOOP_END;
				}
			}

			if ((pGuidApplication == NULL) || (*pGuidApplication == dplAppInfo.guidApplication))
			{
				// Get process count - need executable filename
				
				//
				// Minara, check size vs. length
				//
				if (!SubEntry.GetValueLength(DPL_REG_KEYNAME_EXECUTABLEFILENAME,&dwExecutableFilenameLength))
				{
					DPFX(DPFPREP, 7,"Could not get ExecutableFilename size.  Skipping [%ls]",pwszKeyName);
					goto LOOP_END;
				}

				// So we include null terminator
				dwExecutableFilenameLength++;

				if (dwExecutableFilenameLength > dwMaxExecutableFilenameLength)
				{
					// grow buffer (noting that all strings from the registry are WCHAR) and try again
					DPFX(DPFPREP, 7,"Need to grow pwszExecutableFilename from %ld to %ld",dwMaxExecutableFilenameLength,dwExecutableFilenameLength);
					if (pwszExecutableFilename != NULL)
					{
						DNFree(pwszExecutableFilename);
						pwszExecutableFilename = NULL;
					}
					if ((pwszExecutableFilename = static_cast<WCHAR*>(DNMalloc(dwExecutableFilenameLength*sizeof(WCHAR)))) == NULL)
					{
						DPFERR("DNMalloc() failed");
						hResultCode = DPNERR_OUTOFMEMORY;
						goto EXIT_DPL_EnumLocalPrograms;
					}
					dwMaxExecutableFilenameLength = dwExecutableFilenameLength;
				}
				if (!SubEntry.ReadString(DPL_REG_KEYNAME_EXECUTABLEFILENAME,pwszExecutableFilename,&dwExecutableFilenameLength))
				{
					DPFX(DPFPREP, 7,"Could not read ExecutableFilename.  Skipping [%ls]",pwszKeyName);
					goto LOOP_END;
				}
				DPFX(DPFPREP, 7,"ExecutableFilename [%ls]",pwszExecutableFilename);

				// Count running apps
				dwNumPID = dwMaxPID;
				while ((hResultCode = DPLGetProcessList(pwszExecutableFilename,pdwPID,&dwNumPID)) == DPNERR_BUFFERTOOSMALL)
				{
					if (pdwPID)
					{
						DNFree(pdwPID);
						pdwPID = NULL;
					}
					dwMaxPID = dwNumPID;
					if ((pdwPID = static_cast<DWORD*>(DNMalloc(dwNumPID*sizeof(DWORD)))) == NULL)
					{
						DPFERR("DNMalloc() failed");
						hResultCode = DPNERR_OUTOFMEMORY;
						goto EXIT_DPL_EnumLocalPrograms;
					}
				}
				if (hResultCode != DPN_OK)
				{
					DPFERR("DPLGetProcessList() failed");
					DisplayDNError(0,hResultCode);
					hResultCode = DPNERR_GENERIC;
					goto EXIT_DPL_EnumLocalPrograms;
				}

				// Count waiting apps
				dplAppInfo.dwNumWaiting = 0;
				for (dw = 0 ; dw < dwNumPID ; dw++)
				{
					if ((hResultCode = MessageQueue.Open(	pdwPID[dw],
															DPL_MSGQ_OBJECT_SUFFIX_APPLICATION,
															DPL_MSGQ_SIZE,
															DPL_MSGQ_OPEN_FLAG_NO_CREATE, INFINITE)) == DPN_OK)
					{
						if (MessageQueue.IsAvailable())
						{
							dplAppInfo.dwNumWaiting++;
						}
						MessageQueue.Close();
					}
				}

				hResultCode = PackedBuffer.AddWCHARStringToBack(pwszApplicationName);
				dplAppInfo.pwszApplicationName = (PWSTR)(PackedBuffer.GetTailAddress());
				dplAppInfo.dwFlags = 0;
				dplAppInfo.dwNumRunning = dwNumPID;
				hResultCode = PackedBuffer.AddToFront(&dplAppInfo,sizeof(DPL_APPLICATION_INFO));

				if( dwLengthAppLoadedList+1 > dwSizeAppLoadedList )
				{
					GUID *pTmpArray = NULL;
					
					pTmpArray  = static_cast<GUID*>(DNMalloc(sizeof(GUID)*(dwSizeAppLoadedList+DPL_ENUM_APPGUID_BUFFER_GROWBY)));

					if( !pTmpArray )
					{
						DPFERR("DNMalloc() failed");
						hResultCode = DPNERR_OUTOFMEMORY;
						goto EXIT_DPL_EnumLocalPrograms;					
					}

					memcpy( pTmpArray, pAppLoadedList, sizeof(GUID)*dwLengthAppLoadedList);

					dwSizeAppLoadedList += DPL_ENUM_APPGUID_BUFFER_GROWBY;				
					
					DNFree(pAppLoadedList);
					pAppLoadedList = pTmpArray;
				}

				pAppLoadedList[dwLengthAppLoadedList] = dplAppInfo.guidApplication;
				dwLengthAppLoadedList++;

	    		dwEnumCount++;
			}

		LOOP_END:
			SubEntry.Close();
			dwEnumIndex++;
			dwKeyLen = dwMaxKeyLen;
		}

		RegistryEntry.Close();

		if( pwszKeyName )
		{
			DNFree(pwszKeyName);
			pwszKeyName= NULL;
		}

		if( pwszApplicationName )
		{
			DNFree(pwszApplicationName);
			pwszApplicationName = NULL;
		}

		if( pwszExecutableFilename )
		{
			DNFree(pwszExecutableFilename);
			pwszExecutableFilename = NULL;
		}
	}

	dwSizeRequired = PackedBuffer.GetSizeRequired();
	if (dwSizeRequired > *pdwEnumDataSize)
	{
		DPFX(DPFPREP, 7,"Buffer too small");
		*pdwEnumDataSize = dwSizeRequired;
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		*pdwEnumDataItems = dwEnumCount;
	}

	if( pGuidApplication != NULL && dwEnumCount == 0 )
	{
	    DPFX(DPFPREP,  0, "Specified application was not registered" );
        hResultCode = DPNERR_DOESNOTEXIST;
	}

EXIT_DPL_EnumLocalPrograms:

	if (pwszKeyName != NULL)
		DNFree(pwszKeyName);
	if (pwszApplicationName != NULL)
		DNFree(pwszApplicationName);
	if (pwszExecutableFilename != NULL)
		DNFree(pwszExecutableFilename);
	if (pdwPID != NULL)
		DNFree(pdwPID);
	if( pAppLoadedList )
		DNFree(pAppLoadedList);

	DPF_RETURN(hResultCode);
}



//	DPL_ConnectApplication
//
//	Try to connect to a lobbied application.  Based on DPL_CONNECT_INFO flags,
//	we may have to launch an application.
//
//	If we have to launch an application, we will need to handshake the PID of the
//	application (as it may be ripple launched).  We will pass the LobbyClient's PID on the
//	command line to the application launcher and expect it to be passed down to the
//	application.  The application will open a named shared memory block using the PID and
//	write its PID there, and then signal a named event (using the LobbyClient's PID again).
//	When the waiting LobbyClient is signaled by this event, it continues its connection
//	process as if this was an existing running and available application.

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ConnectApplication"

STDMETHODIMP DPL_ConnectApplication(IDirectPlay8LobbyClient *pInterface,
									DPL_CONNECT_INFO *const pdplConnectInfo,
									void *pvConnectionContext,
									DPNHANDLE *const hApplication,
									const DWORD dwTimeOut,
									const DWORD dwFlags)
{
	HRESULT			hResultCode = DPN_OK;
	DWORD			dwSize = 0;
	BYTE			*pBuffer = NULL;
	DPL_PROGRAM_DESC	*pdplProgramDesc;
	DWORD			*pdwProcessList = NULL;
	DWORD			dwNumProcesses = 0;
	DWORD			dwPID = 0;
	DWORD			dw = 0;
	DPNHANDLE		handle = NULL;
	DPL_CONNECTION	*pdplConnection = NULL;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject = NULL;

	DPFX(DPFPREP, 3,"Parameters: pdplConnectInfo [0x%p], pvConnectionContext [0x%p], hApplication [0x%lx], dwFlags [0x%lx]",
			pdplConnectInfo,pvConnectionContext,hApplication,dwFlags);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
#ifndef DPNBUILD_NOPARAMVAL
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateConnectApplication( pInterface, pdplConnectInfo, pvConnectionContext, hApplication, dwTimeOut, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating connect application params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}		
#endif // !DPNBUILD_NOPARAMVAL

	// Get program description
	dwSize = 0;
	pBuffer = NULL;
	hResultCode = DPLGetProgramDesc(&pdplConnectInfo->guidApplication,pBuffer,&dwSize);
	if (hResultCode != DPNERR_BUFFERTOOSMALL)
	{
		DPFERR("Could not get Program Description");
		goto EXIT_DPL_ConnectApplication;
	}
	if ((pBuffer = static_cast<BYTE*>(DNMalloc(dwSize))) == NULL)
	{
		DPFERR("Could not allocate space for buffer");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto EXIT_DPL_ConnectApplication;
	}
	if ((hResultCode = DPLGetProgramDesc(&pdplConnectInfo->guidApplication,pBuffer,&dwSize)) != DPN_OK)
	{
		DPFERR("Could not get Program Description");
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	pdplProgramDesc = reinterpret_cast<DPL_PROGRAM_DESC*>(pBuffer);
	dwPID = 0;
	dwNumProcesses = 0;
	pdwProcessList = NULL;

	if (!(pdplConnectInfo->dwFlags & DPLCONNECT_LAUNCHNEW))	// Only if not forcing launch
	{
		// Get process list
		hResultCode = DPLGetProcessList(pdplProgramDesc->pwszExecutableFilename,NULL,&dwNumProcesses);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_BUFFERTOOSMALL)
		{
			DPFERR("Could not retrieve process list");
			DisplayDNError(0,hResultCode);
			goto EXIT_DPL_ConnectApplication;			
		}
		if (hResultCode == DPNERR_BUFFERTOOSMALL)
		{
			if ((pdwProcessList = static_cast<DWORD*>(DNMalloc(dwNumProcesses*sizeof(DWORD)))) == NULL)
			{
				DPFERR("Could not create process list buffer");
				hResultCode = DPNERR_OUTOFMEMORY;
    			goto EXIT_DPL_ConnectApplication;				
			}
			if ((hResultCode = DPLGetProcessList(pdplProgramDesc->pwszExecutableFilename,pdwProcessList,
					&dwNumProcesses)) != DPN_OK)
			{
				DPFERR("Could not get process list");
				DisplayDNError(0,hResultCode);
    			goto EXIT_DPL_ConnectApplication;				
			}

		}

		// Try to connect to an already running application
		for (dw = 0 ; dw < dwNumProcesses ; dw++)
		{
			if ((hResultCode = DPLMakeApplicationUnavailable(pdwProcessList[dw])) == DPN_OK)
			{
				DPFX(DPFPREP, 1, "Found Existing Process=%d", pdwProcessList[dw] );				
				dwPID = pdwProcessList[dw];
				break;
			}
		}

		if (pdwProcessList)
		{
			DNFree(pdwProcessList);
			pdwProcessList = NULL;
		}
	}

	// Launch application if none are ready to connect
	if ((dwPID == 0) && (pdplConnectInfo->dwFlags & (DPLCONNECT_LAUNCHNEW | DPLCONNECT_LAUNCHNOTFOUND)))
	{
		if ((hResultCode = DPLLaunchApplication(pdpLobbyObject,pdplProgramDesc,&dwPID,dwTimeOut)) != DPN_OK)
		{
			DPFERR("Could not launch application");
			DisplayDNError(0,hResultCode);
			goto EXIT_DPL_ConnectApplication;
		}
		else
		{
			DPFX(DPFPREP, 1, "Launched process dwID=%d", dwPID );
		}
	}

	if (dwPID  == 0)	// Could not make any connection
	{
		DPFERR("Could not connect to an existing application or launch a new one");
		hResultCode = DPNERR_NOCONNECTION;
		DisplayDNError( 0, hResultCode );
		goto EXIT_DPL_ConnectApplication;
	}

	// Create connection
	handle = NULL;
	if ((hResultCode = DPLConnectionNew(pdpLobbyObject,&handle,&pdplConnection)) != DPN_OK)
	{
		DPFERR("Could not create connection entry");
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	pdplConnection->dwTargetProcessIdentity = dwPID;

		//get and store the process handle
	pdplConnection->hTargetProcess=DNOpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwPID);
	if (pdplConnection->hTargetProcess==NULL)
	{
		DPFX(DPFPREP, 0, "Could not open handle to process PID %u", dwPID);
		hResultCode = DPNERR_NOCONNECTION;
		DisplayDNError( 0, hResultCode );
		goto EXIT_DPL_ConnectApplication;
	}
	
	DPFX(DPFPREP,  0, "PID %u hProcess %u", dwPID,  HANDLE_FROM_DNHANDLE(pdplConnection->hTargetProcess));

	// Set the context for this connection
	if ((hResultCode = DPLConnectionSetContext( pdpLobbyObject, handle, pvConnectionContext )) != DPN_OK )
	{
		DPFERR( "Could not set contect for connection" );
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	// Connect to selected application instance
	if ((hResultCode = DPLConnectionConnect(pdpLobbyObject,handle,dwPID,TRUE)) != DPN_OK)
	{
		DPFERR("Could not connect to application");
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	DNResetEvent(pdplConnection->hConnectEvent);

	// Pass lobby client info to application

	if ((hResultCode = DPLConnectionSendREQ(pdpLobbyObject,handle,pdpLobbyObject->dwPID,
			pdplConnectInfo)) != DPN_OK)
	{
		DPFERR("Could not send connection request");
		DisplayDNError(0,hResultCode);
		goto EXIT_DPL_ConnectApplication;
	}

	if (DNWaitForSingleObject(pdplConnection->hConnectEvent,INFINITE) != WAIT_OBJECT_0)
	{
		DPFERR("Wait for connection terminated");
		hResultCode = DPNERR_GENERIC;
		goto EXIT_DPL_ConnectApplication;
	}

	*hApplication = handle;

	hResultCode = DPN_OK;	

EXIT_DPL_ConnectApplication:

	if( FAILED(hResultCode) && handle)
	{
		DPLConnectionDisconnect(pdpLobbyObject,handle);
		DPLConnectionRelease(pdpLobbyObject,handle);
	}

	if (pBuffer)
		DNFree(pBuffer);

	if (pdwProcessList)
		DNFree(pdwProcessList);	

	DPF_RETURN(hResultCode);
}



#undef DPF_MODNAME
#define DPF_MODNAME "DPL_ReleaseApplication"

STDMETHODIMP DPL_ReleaseApplication(IDirectPlay8LobbyClient *pInterface,
									const DPNHANDLE hApplication, 
									const DWORD dwFlags )
{
	HRESULT		hResultCode;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	DPNHANDLE				*hTargets = NULL;
	DWORD					dwNumTargets = 0;
	DWORD					dwTargetIndex = 0;

	DPFX(DPFPREP, 3,"Parameters: hApplication [0x%lx]",hApplication);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	    
#ifndef DPNBUILD_NOPARAMVAL
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateReleaseApplication( pInterface, hApplication, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating release application params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	
#endif // !DPNBUILD_NOPARAMVAL

	if( hApplication == DPLHANDLE_ALLCONNECTIONS )
	{
		dwNumTargets = 0;

		// We need loop so if someone adds a connection during our run
		// it gets added to our list
		//
		while( 1 )
		{
			hResultCode = DPLConnectionEnum( pdpLobbyObject, hTargets, &dwNumTargets );

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( hTargets )
				{
					delete [] hTargets;
				}

				hTargets = new DPNHANDLE[dwNumTargets];

				if( hTargets == NULL )
				{
					DPFERR("Error allocating memory" );
					hResultCode = DPNERR_OUTOFMEMORY;
					dwNumTargets = 0;
					goto EXIT_AND_CLEANUP;
				}

				memset( hTargets, 0x00, sizeof(DPNHANDLE)*dwNumTargets);

				continue;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error getting list of connections hr=0x%x", hResultCode );
				break;
			}
			else
			{
				break;
			}
		}

		// Failed getting connection information
		if( FAILED( hResultCode ) )
		{
			if( hTargets )
			{
				delete [] hTargets;
				hTargets = NULL;
			}
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

	}
	else
	{
		hTargets = new DPNHANDLE[1]; // We use array delete below so we need array new

		if( hTargets == NULL )
		{
			DPFERR("Error allocating memory" );
			hResultCode = DPNERR_OUTOFMEMORY;
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

		dwNumTargets = 1;
		hTargets[0] = hApplication;
	}
		
	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		hResultCode = DPLConnectionDisconnect(pdpLobbyObject,hTargets[dwTargetIndex]);

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error disconnecting connection 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
		}
	}

EXIT_AND_CLEANUP:

	if( hTargets )
		delete [] hTargets;

	DPF_RETURN(hResultCode);
}


//	DPLLaunchApplication
//
//	Launch the application with a command-line argument of:
//		DPLID=PIDn	PID=Lobby Client PID, n=launch counter (each launch increases it)
//	Wait for the application to signal the event (or die)

#undef DPF_MODNAME
#define DPF_MODNAME "DPLLaunchApplication"

HRESULT	DPLLaunchApplication(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 DPL_PROGRAM_DESC *const pdplProgramDesc,
							 DWORD *const pdwPID,
							 const DWORD dwTimeOut)
{
	HRESULT				hResultCode;
	DWORD				dwAppNameLen=0;		//Length of the application full name (path+exe)
	PWSTR				pwszAppName=NULL;	//Unicode version of application full name
	DWORD				dwCmdLineLen=0;		//Length of the command line string
	PWSTR				pwszCmdLine=NULL;	//Unicode version of command line to supply 	

#ifndef UNICODE
	CHAR *				pszAppName=NULL;	//Ascii version of application full name
	CHAR *				pszCmdLine=NULL;		//Acii version of command line string
	CHAR				*pszDefaultDir = NULL;
#endif // UNICODE

	LONG				lc;
#if !defined(WINCE) || defined(WINCE_ON_DESKTOP)
	STARTUPINFO			startupinfo;
#endif // !WINCE
	DNPROCESS_INFORMATION pi;
	DWORD				dwError;
	DNHANDLE			hSyncEvents[2] = { NULL, NULL };
	WCHAR				pwszObjectName[(sizeof(DWORD)*2)*2 + 1];
	TCHAR				pszObjectName[(sizeof(DWORD)*2)*2 + 1 + 1]; // PID + LaunchCount + IDCHAR + NULL
	DPL_SHARED_CONNECT_BLOCK	*pSharedBlock = NULL;
	DNHANDLE			hFileMap = NULL;
	DWORD			dwPID;
	WCHAR			*wszToLaunchPath = NULL;
	WCHAR			*wszToLaunchExecutable = NULL;
	DWORD			dwToLaunchPathLen;


	// Are we launching the launcher or the executable?
	if( !pdplProgramDesc->pwszLauncherFilename || wcslen(pdplProgramDesc->pwszLauncherFilename) == 0 )
	{
		wszToLaunchPath = pdplProgramDesc->pwszExecutablePath; 
		wszToLaunchExecutable = pdplProgramDesc->pwszExecutableFilename;
	}
	else
	{ 
		wszToLaunchPath = pdplProgramDesc->pwszLauncherPath; 
		wszToLaunchExecutable = pdplProgramDesc->pwszLauncherFilename;		
	}

	DPFX(DPFPREP, 3,"Parameters: pdplProgramDesc [0x%p]",pdplProgramDesc);

	DNASSERT(pdplProgramDesc != NULL);

	// Increment launch count
	lc = DNInterlockedIncrement(&pdpLobbyObject->lLaunchCount);

	// Synchronization event and shared memory names
	swprintf(pwszObjectName,L"%lx%lx",pdpLobbyObject->dwPID,lc);
	_stprintf(pszObjectName,_T("-%lx%lx"),pdpLobbyObject->dwPID,lc); // We will overwrite this '-' with the appropriate IDCHAR below

	// Compute the size of the full application name string (combination of path and exe name)
	if (wszToLaunchPath)
	{
		dwAppNameLen += (wcslen(wszToLaunchPath) + 1);
	}
	if (wszToLaunchExecutable)
	{
		dwAppNameLen += (wcslen(wszToLaunchExecutable) + 1);
	}

	// Compute the size of the command line string
	dwCmdLineLen = dwAppNameLen + 1; // Make room for the exe plus a space
	if (pdplProgramDesc->pwszCommandLine)
	{
		dwCmdLineLen += wcslen(pdplProgramDesc->pwszCommandLine); // Add whatever user command line exists
	}
	dwCmdLineLen += (1 + wcslen(DPL_ID_STR_W) + (sizeof(DWORD)*2*2) + 1); // Add a space plus DPLID= + PID + LaunchCount + NULL

	DPFX(DPFPREP, 5,"Application full name string length [%ld] WCHARs", dwAppNameLen);
	DPFX(DPFPREP, 5,"Command Line string length [%ld] WCHARs", dwCmdLineLen);

	// Allocate memory to hold the full app name and command line + check allocation was OK
	pwszAppName = static_cast<WCHAR *>(DNMalloc(dwAppNameLen * sizeof(WCHAR)));
	pwszCmdLine = static_cast<WCHAR *>(DNMalloc(dwCmdLineLen * sizeof(WCHAR)));
	if (pwszAppName == NULL || pwszCmdLine == NULL)
	{
		DPFERR("Could not allocate strings for app name and command line");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto CLEANUP_DPLLaunch;		
	}

	// Build the application full name by combining launch path with exe name
	*pwszAppName = L'\0';
	if (wszToLaunchPath)
	{
		dwToLaunchPathLen = wcslen(wszToLaunchPath);
		if (dwToLaunchPathLen > 0)
		{
			wcscat(pwszAppName,wszToLaunchPath);
			if (wszToLaunchPath[dwToLaunchPathLen - 1] != L'\\')
	 		{
				wcscat(pwszAppName,L"\\");
			}
		}
	}
	if (wszToLaunchExecutable)
	{
		wcscat(pwszAppName,wszToLaunchExecutable);
	}

	//
	// We are building: <exe> <user cmd line> DPLID=(PID and LaunchCount unique number)
	//

	//Build the command line from app name, program description and the lobby related parameters
	wcscpy(pwszCmdLine, pwszAppName); // Executable name and path
	wcscat(pwszCmdLine,L" ");
	if (pdplProgramDesc->pwszCommandLine)
	{
		wcscat(pwszCmdLine,pdplProgramDesc->pwszCommandLine);
		wcscat(pwszCmdLine,L" ");
	}
	wcscat(pwszCmdLine,DPL_ID_STR_W);
	wcscat(pwszCmdLine,pwszObjectName);

	DPFX(DPFPREP, 5,"Application full name string [%ls]",pwszAppName);
	DPFX(DPFPREP, 5,"Command Line string [%ls]",pwszCmdLine);


	// Create shared connect block to receive Application's PID
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_FILEMAP;
	hFileMap = DNCreateFileMapping(INVALID_HANDLE_VALUE,(LPSECURITY_ATTRIBUTES) NULL,
		PAGE_READWRITE,(DWORD)0,sizeof(DPL_SHARED_CONNECT_BLOCK),pszObjectName);
	if (hFileMap == NULL)
	{
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "CreateFileMapping() failed dwLastError [0x%lx]", dwError );
		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
		goto CLEANUP_DPLLaunch;		
	}

	// Map file
	pSharedBlock = reinterpret_cast<DPL_SHARED_CONNECT_BLOCK*>(MapViewOfFile(HANDLE_FROM_DNHANDLE(hFileMap),FILE_MAP_ALL_ACCESS,0,0,0));
	if (pSharedBlock == NULL)
	{
		dwError = GetLastError();	    
		DPFX(DPFPREP, 0,"MapViewOfFile() failed dwLastError [0x%lx]", dwError);
		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
		goto CLEANUP_DPLLaunch;
	}

	// Create synchronization event
	*pszObjectName = DPL_MSGQ_OBJECT_IDCHAR_EVENT;
	if ((hSyncEvents[0] = DNCreateEvent(NULL,TRUE,FALSE,pszObjectName)) == NULL)
	{
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Create Event Failed dwLastError [0x%lx]", dwError );
		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
        goto CLEANUP_DPLLaunch;
	}

#if !defined(WINCE) || defined(WINCE_ON_DESKTOP)
	// More setup
    startupinfo.cb = sizeof(STARTUPINFO);
    startupinfo.lpReserved = NULL;
    startupinfo.lpDesktop = NULL;
    startupinfo.lpTitle = NULL;
    startupinfo.dwFlags = 0;
    startupinfo.cbReserved2 = 0;
    startupinfo.lpReserved2 = NULL;	    
#endif // !WINCE

#ifdef UNICODE
#if !defined(WINCE) || defined(WINCE_ON_DESKTOP)
    // Launch !
    if (DNCreateProcess(pwszAppName, pwszCmdLine, NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
        	pdplProgramDesc->pwszCurrentDirectory,&startupinfo,&pi) == 0)
#else // WINCE
	// WinCE AV's on a NULL first param and requires that Environment and CurrentDirectory be NULL.  It also ignores STARTUPINFO.
    if (DNCreateProcess(pwszAppName, pwszCmdLine, NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
        	NULL,NULL,&pi) == 0)
#endif // !WINCE
    {
        dwError = GetLastError();
        DPFX(DPFPREP,  0, "CreateProcess Failed dwLastError [0x%lx]", dwError );
        hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
        goto CLEANUP_DPLLaunch;
    }
#else
	//Convert full app name, command line and default dir from unicode to ascii format
    if( FAILED( hResultCode = STR_AllocAndConvertToANSI( &pszAppName, pwszAppName ) ) )
    {
        dwError = GetLastError();
        DPFX(DPFPREP,  0, "String conversion failed dwError = [0x%lx]", dwError );
        hResultCode = DPNERR_CONVERSION;
        goto CLEANUP_DPLLaunch;
    }
	if( FAILED( hResultCode = STR_AllocAndConvertToANSI( &pszCmdLine, pwszCmdLine ) ) )
    {
        dwError = GetLastError();
        DPFX(DPFPREP,  0, "String conversion failed dwError = [0x%lx]", dwError );
        hResultCode = DPNERR_CONVERSION;
        goto CLEANUP_DPLLaunch;
    }
    if( FAILED( hResultCode = STR_AllocAndConvertToANSI( &pszDefaultDir, pdplProgramDesc->pwszCurrentDirectory ) ) )
    {
        dwError = GetLastError();
        DPFX(DPFPREP,  0, "String conversion failed dwError = [0x%lx]", dwError );
        hResultCode = DPNERR_CONVERSION;
        goto CLEANUP_DPLLaunch;
    }

    // Launch !
    if (DNCreateProcess(pszAppName,pszCmdLine,NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,
        	pszDefaultDir,&startupinfo,&pi) == 0)
    {
        dwError = GetLastError();
        DPFX(DPFPREP,  0, "CreateProcess Failed dwLastError [0x%lx]", dwError );
        hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
        goto CLEANUP_DPLLaunch;
    }	    
#endif // UNICODE
	
	hSyncEvents[1] = pi.hProcess;

	// Wait for connection or application termination
	dwError = DNWaitForMultipleObjects(2,hSyncEvents,FALSE,dwTimeOut);

	DNCloseHandle(pi.hProcess);
	DNCloseHandle(pi.hThread);

	// Immediately clean up
	dwPID = pSharedBlock->dwPID;

	// Ensure we can continue
	if (dwError - WAIT_OBJECT_0 > 1)
	{
		if (dwError == WAIT_TIMEOUT)
		{
			DPFERR("Wait for application connection timed out");
			hResultCode = DPNERR_TIMEDOUT;
            goto CLEANUP_DPLLaunch;			
		}
		else
		{
			DPFERR("Wait for application connection terminated mysteriously");
			hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
            goto CLEANUP_DPLLaunch;			
		}
	}

	// Check if application terminated
	if (dwError == 1)
	{
		DPFERR("Application was terminated");
		hResultCode = DPNERR_CANTLAUNCHAPPLICATION;
        goto CLEANUP_DPLLaunch;
	}

	*pdwPID = dwPID;

	hResultCode = DPN_OK;

CLEANUP_DPLLaunch:

    if( hSyncEvents[0] != NULL )
        DNCloseHandle( hSyncEvents[0] );

    if( pSharedBlock != NULL )
    	UnmapViewOfFile(pSharedBlock);

    if( hFileMap != NULL )
        DNCloseHandle( hFileMap );

    if( pwszAppName != NULL )
        DNFree( pwszAppName );

    if (pwszCmdLine!=NULL)
        DNFree( pwszCmdLine );

#ifndef UNICODE
    if( pszAppName != NULL )
        DNFree(pszAppName);

    if (pszCmdLine!=NULL)
        DNFree(pszCmdLine);

    if( pszDefaultDir != NULL )
        DNFree(pszDefaultDir);
#endif // UNICODE

    DPF_RETURN(hResultCode);
}

HRESULT DPLUpdateAppStatus(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
                           const DPNHANDLE hSender, 
						   BYTE *const pBuffer)
{
	HRESULT		hResultCode;
	DPL_INTERNAL_MESSAGE_UPDATE_STATUS	*pStatus;
	DPL_MESSAGE_SESSION_STATUS			MsgStatus;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p]",pBuffer);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(pBuffer != NULL);

	pStatus = reinterpret_cast<DPL_INTERNAL_MESSAGE_UPDATE_STATUS*>(pBuffer);

	MsgStatus.dwSize = sizeof(DPL_MESSAGE_SESSION_STATUS);
	MsgStatus.dwStatus = pStatus->dwStatus;
	MsgStatus.hSender = hSender;

	// Return code is irrelevant, at this point we're going to indicate regardless
	hResultCode = DPLConnectionGetContext( pdpLobbyObject, hSender, &MsgStatus.pvConnectionContext );

	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Error getting connection context for 0x%x hr=0x%x", hSender, hResultCode );
	}

	hResultCode = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
													  DPL_MSGID_SESSION_STATUS,
													  reinterpret_cast<BYTE*>(&MsgStatus));

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

// ----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplclient.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLClient.h
 *  Content:    DirectPlay Lobby Client Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   03/22/2000	jtk		Changed interface names
 *   04/25/2000 rmt     Bug #s 33138, 33145, 33150 
 *   05/03/00   rmt     Bug #33879 -- Status messsage missing from field 
 *   06/15/00   rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances  
 *   07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLCLIENT_H__
#define	__DPLCLIENT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CMessageQueue;

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for lobbied application interface
//
extern IDirectPlay8LobbyClientVtbl DPL_Lobby8ClientVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

STDMETHODIMP DPL_EnumLocalPrograms(IDirectPlay8LobbyClient *pInterface,
							  GUID *const pGuidApplication,
							  BYTE *const pEnumData,
							  DWORD *const pdwEnumDataSize,
							  DWORD *const pdwEnumDataItems,
							  const DWORD dwFlags );

STDMETHODIMP DPL_ConnectApplication(IDirectPlay8LobbyClient *pInterface,
							   DPL_CONNECT_INFO *const pdplConnectionInfo,
							   const PVOID pvUserApplicationContext,
							   DPNHANDLE *const hApplication,
							   const DWORD dwTimeOut,
							   const DWORD dwFlags);

STDMETHODIMP DPL_ReleaseApplication(IDirectPlay8LobbyClient *pInterface,
									const DPNHANDLE hApplication, 
									const DWORD dwFlags );

HRESULT DPLSendLobbyClientInfo(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							   CMessageQueue *const pMessageQueue);

HRESULT	DPLLaunchApplication(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 DPL_PROGRAM_DESC *const pdplProgramDesc,
							 DWORD *const pdwPID,
							 const DWORD dwTimeOut);

HRESULT DPLUpdateAppStatus(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
                           const DPNHANDLE hSender,
						   BYTE *const pBuffer);

HRESULT DPLUpdateConnectionSettings(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
                           const DPNHANDLE hSender,
						   BYTE *const pBuffer );

#endif	// __DNLCLIENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplcommon.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLCommon.h
 *  Content:    DirectPlay Lobby Common Functions Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DPLCOMMON_H__
#define	__DPLCOMMON_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DPLSendConnectionSettings( DIRECTPLAYLOBBYOBJECT * const pdpLobbyObject, 
								   DPNHANDLE hConnection ); 

STDMETHODIMP DPL_GetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags );
STDMETHODIMP DPL_SetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags );

STDMETHODIMP DPL_RegisterMessageHandler(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										DPNHANDLE * const pdpnhConnection, 
										const DWORD dwFlags);

STDMETHODIMP DPL_RegisterMessageHandlerClient(PVOID pv,
										void * const pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										const DWORD dwFlags);

STDMETHODIMP DPL_Close(PVOID pv, const DWORD dwFlags );

STDMETHODIMP DPL_Send(PVOID pv,
					  const DPNHANDLE hTarget,
					  BYTE *const pBuffer,
					  const DWORD pBufferSize,
					  const DWORD dwFlags);

HRESULT DPLReceiveUserMessage(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							  const DPNHANDLE hSender,
							  BYTE *const pBuffer,
							  const DWORD dwBufferSize);

HRESULT DPLMessageHandler(PVOID pvContext,
						  const DPNHANDLE hSender,
						  DWORD dwMessageFlags, 
						  BYTE *const pBuffer,
						  const DWORD dwBufferSize);


#endif	// __DPLCOMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplconnect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLConnect.cpp
 *  Content:    DirectPlay Lobby Connection Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/21/00	mjn		Created
 *   05/08/00   rmt     Bug #33616 -- Does not run on Win9X 
 *   05/30/00	rmt		Bug #35700 - ConnectApp(h), Release(h), Release(h) returns OK
 *                      Added an additional release, handles were never getting destroyed
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  06/28/00	rmt		Prefix Bug #38082
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/18/2000	rmt		Bug #42751 - DPLOBBY8: Prohibit more than one lobby client or lobby app per process 
 *  08/30/2000	rmt		Bug #171827 - Prefix Bug 
 *  01/04/2001	rodtoll	WinBug #94200 - Remove BUGBUGs from Code.   
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionNew"

HRESULT	DPLConnectionNew(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE *const phConnect,
						 DPL_CONNECTION **const ppdplConnection)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPNHANDLE		handle;

	DPFX(DPFPREP, 3,"Parameters: phConnect [0x%p], ppdplConnection [0x%p]",phConnect,ppdplConnection);

	if( ppdplConnection == NULL )
	{
		DPFERR( "ppdplConnection param is NULL -- this should not happen" );
		DNASSERT( FALSE );
		return DPNERR_GENERIC;
	}

	// Create connection entry
	if ((pdplConnection = static_cast<DPL_CONNECTION*>(DNMalloc(sizeof(DPL_CONNECTION)))) == NULL)
	{
		DPFERR("Could not allocate Connection entry");
		return(DPNERR_OUTOFMEMORY);
	}

	// Create connection handle
	if ((hResultCode = pdpLobbyObject->m_HandleTable.Create(pdplConnection, &handle)) != DPN_OK)
	{
		DPFERR("Could not create Connection handle");
		DisplayDNError(0,hResultCode);
		DNFree(pdplConnection);
		return(hResultCode);
	}

	// Create connect event
	pdplConnection->hConnectEvent = DNCreateEvent(NULL,TRUE,FALSE,NULL);
	if (pdplConnection->hConnectEvent == NULL)
	{
		DPFERR("Could not create connection connect event");
		pdpLobbyObject->m_HandleTable.Destroy(handle, NULL);
		DNFree(pdplConnection);
		return(DPNERR_OUTOFMEMORY);
	}

	// Initialize entry
	pdplConnection->hConnect = handle;
	pdplConnection->dwTargetProcessIdentity = 0;
	pdplConnection->hTargetProcess=NULL;
	pdplConnection->pSendQueue = NULL;
	pdplConnection->lRefCount = 1;
	pdplConnection->pConnectionSettings = NULL;
	pdplConnection->pvConnectContext = NULL;

    if (DNInitializeCriticalSection( &pdplConnection->csLock ) == FALSE)
	{
		DPFERR("Could not initialize connection CS");
		DNCloseHandle(pdplConnection->hConnectEvent);
		pdpLobbyObject->m_HandleTable.Destroy(handle, NULL);
		DNFree(pdplConnection);
		return(DPNERR_OUTOFMEMORY);
	}

	pdplConnection->m_blLobbyObjectLinkage.Initialize(); // TODO: MASONB: Pool these

	// TODO: MASONB: Set recursion count to 0 on m_cs and above
	DNEnterCriticalSection(&pdpLobbyObject->m_cs);
	pdplConnection->m_blLobbyObjectLinkage.InsertBefore(&pdpLobbyObject->m_blConnections);
	pdpLobbyObject->m_dwConnectionCount++;

	DNLeaveCriticalSection(&pdpLobbyObject->m_cs);

	*phConnect = handle;
	if (ppdplConnection != NULL)
		*ppdplConnection = pdplConnection;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionFind"

HRESULT DPLConnectionFind(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						  const DPNHANDLE hConnect,
						  DPL_CONNECTION **const ppdplConnection,
						  const BOOL fAddRef)
{
	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx], ppdplConnection [0x%p], fAddRef [%ld]",
			hConnect, ppdplConnection, fAddRef);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);
	DNASSERT(ppdplConnection != NULL);

	pdpLobbyObject->m_HandleTable.Lock();
	if (FAILED(pdpLobbyObject->m_HandleTable.Find(hConnect, (PVOID*)ppdplConnection)))
	{
		pdpLobbyObject->m_HandleTable.Unlock();
		DPFERR("Could not retrieve handle");
		return DPNERR_INVALIDHANDLE;
	}

	if (fAddRef)
	{
		DNInterlockedIncrement(&(*ppdplConnection)->lRefCount);
	}
	pdpLobbyObject->m_HandleTable.Unlock();

	return DPN_OK;
}

// DPLConnectionGetConnectSettings
//
// This function gets the connection settings attached to the specified connection.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionGetConnectSettings"
HRESULT DPLConnectionGetConnectSettings( DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						 DPNHANDLE const hConnect, 
						 DPL_CONNECTION_SETTINGS * const pdplConnectSettings,
						 DWORD * const pdwDataSize )	
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnect, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

    // Grab lock to keep people from interfering.
    DNEnterCriticalSection( &pdplConnection->csLock );

    if( !pdplConnection->pConnectionSettings )
    {
    	*pdwDataSize = 0;
    	hResultCode = DPNERR_DOESNOTEXIST;
    	goto GETCONNECTIONSETTINGS_EXIT;
    }

    hResultCode = pdplConnection->pConnectionSettings->CopyToBuffer( (BYTE *) pdplConnectSettings, pdwDataSize );

GETCONNECTIONSETTINGS_EXIT:
  
    DNLeaveCriticalSection( &pdplConnection->csLock );        

    // Release this function's reference
    DPLConnectionRelease( pdpLobbyObject, hConnect );            

    return hResultCode;
    
}


// DPLConnectionSetConnectSettings
//
// This function sets the connection settings attached to the specified connection.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionSetConnectSettings"
HRESULT DPLConnectionSetConnectSettings( 
                    DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
					const DPNHANDLE hConnect, 
					CConnectionSettings * pConnectionSettings )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnect, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

    // Grab lock to prevent other people from interfering
    DNEnterCriticalSection( &pdplConnection->csLock );

	// Free old one if there is one
	if( pdplConnection->pConnectionSettings )
	{
		delete pdplConnection->pConnectionSettings;
		pdplConnection->pConnectionSettings = NULL;
	}

	pdplConnection->pConnectionSettings = pConnectionSettings;

    hResultCode = DPN_OK;

    DNLeaveCriticalSection( &pdplConnection->csLock );

    DPLConnectionRelease( pdpLobbyObject, hConnect );

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionGetContext"
HRESULT DPLConnectionGetContext(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnection, 
								PVOID *ppvConnectContext )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnection, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
		*ppvConnectContext = NULL;
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

	// Set connection context for the found handle
	DNEnterCriticalSection( &pdplConnection->csLock );
	*ppvConnectContext = pdplConnection->pvConnectContext;
    DNLeaveCriticalSection( &pdplConnection->csLock );

	// Release our reference to the connection 
    DPLConnectionRelease( pdpLobbyObject, hConnection );

	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionSetContext"
HRESULT DPLConnectionSetContext(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnection, 
								PVOID pvConnectContext )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnection, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

	// Set connection context for the found handle
	DNEnterCriticalSection( &pdplConnection->csLock );
	pdplConnection->pvConnectContext = pvConnectContext;
    DNLeaveCriticalSection( &pdplConnection->csLock );

	// Release our reference to the connection 
    DPLConnectionRelease( pdpLobbyObject, hConnection );

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionRelease"

HRESULT DPLConnectionRelease(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect)
{
	DPL_CONNECTION	*pdplConnection;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx]", hConnect);

	// TODO: MASONB: Thread safety issues
	if (FAILED(pdpLobbyObject->m_HandleTable.Find(hConnect, (PVOID*)&pdplConnection)))
	{
		DPFERR("Could not retrieve connection");
    	return DPNERR_GENERIC;
	}

	if (DNInterlockedDecrement(&pdplConnection->lRefCount) == 0)
	{
		pdpLobbyObject->m_HandleTable.Destroy(hConnect, NULL);
		DNEnterCriticalSection(&pdpLobbyObject->m_cs);

		// This may already have been done by the timeout code
		if (!pdplConnection->m_blLobbyObjectLinkage.IsEmpty())
		{
			pdplConnection->m_blLobbyObjectLinkage.RemoveFromList();
			pdpLobbyObject->m_dwConnectionCount--;
		}

		DNLeaveCriticalSection(&pdpLobbyObject->m_cs);
		
		DPFX(DPFPREP, 5,"Freeing object");
		if (pdplConnection->pSendQueue)
		{
			pdplConnection->pSendQueue->Close();
			delete pdplConnection->pSendQueue;
			pdplConnection->pSendQueue = NULL;

            delete pdplConnection->pConnectionSettings;
			pdplConnection->pConnectionSettings = NULL;

			DNDeleteCriticalSection( &pdplConnection->csLock );
		}

		DNCloseHandle(pdplConnection->hConnectEvent);
		if (pdplConnection->hTargetProcess)
			DNCloseHandle(pdplConnection->hTargetProcess);

    	DNFree(pdplConnection);
	}
	
	DPFX(DPFPREP, 3,"Returning: DPN_OK");
	return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionConnect"

HRESULT DPLConnectionConnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect,
							 const DWORD dwProcessId, 
							 const BOOL fApplication )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx], dwProcessId [0x%lx]",
			hConnect,dwProcessId);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);
	DNASSERT(dwProcessId != 0);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hConnect,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	pdplConnection->pSendQueue = new CMessageQueue;

	if( !pdplConnection->pSendQueue )
	{
		DPFERR("Could not allocate queue out of memory");
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		hResultCode = DPNERR_OUTOFMEMORY;
		return(hResultCode);
	}

	hResultCode = pdplConnection->pSendQueue->Open(dwProcessId,
												   (fApplication) ? DPL_MSGQ_OBJECT_SUFFIX_APPLICATION : DPL_MSGQ_OBJECT_SUFFIX_CLIENT,
												   DPL_MSGQ_SIZE,
												   0, INFINITE);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not open message queue");
		DisplayDNError(0,hResultCode);
		delete pdplConnection->pSendQueue;
		pdplConnection->pSendQueue = NULL;
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		return(hResultCode);
	}

	// Ensure other side is still connected to MsgQ
	if (!pdplConnection->pSendQueue->IsReceiving())
	{
		DPFERR("Application is not receiving");
		pdplConnection->pSendQueue->Close();
		delete pdplConnection->pSendQueue;
		pdplConnection->pSendQueue = NULL;
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		return(DPNERR_DOESNOTEXIST);
	}

	DPLConnectionRelease(pdpLobbyObject,hConnect);

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionDisconnect"

HRESULT DPLConnectionDisconnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hConnect )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_DISCONNECT	Msg;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx]",hConnect);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hConnect,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	Msg.dwMsgId = DPL_MSGID_INTERNAL_DISCONNECT;
	Msg.dwPID = pdpLobbyObject->dwPID;

	hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(&Msg),
			sizeof(DPL_INTERNAL_MESSAGE_DISCONNECT),INFINITE,DPL_MSGQ_MSGFLAGS_USER1,0);

	// Release the reference for the Find above
	DPLConnectionRelease(pdpLobbyObject,hConnect);

	// Release the interface's reference
	DPLConnectionRelease(pdpLobbyObject,hConnect);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DPLConnectionEnum
//
//	Enumerate outstanding connections

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionEnum"

HRESULT DPLConnectionEnum(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
						  DPNHANDLE *const prghConnect,
						  DWORD *const pdwNum)
{
	DPL_CONNECTION* pConnection;
	CBilink* pblTemp;
	DWORD dwCount;

	DPFX(DPFPREP, 3,"Parameters: prghConnect [0x%p], pdwNum [0x%p]",prghConnect,pdwNum);

	DNEnterCriticalSection(&pdpLobbyObject->m_cs);
	if (prghConnect == NULL || *pdwNum < pdpLobbyObject->m_dwConnectionCount)
	{
		*pdwNum = pdpLobbyObject->m_dwConnectionCount;
		DNLeaveCriticalSection(&pdpLobbyObject->m_cs);
		return DPNERR_BUFFERTOOSMALL;
	}

	*pdwNum = pdpLobbyObject->m_dwConnectionCount;

	pblTemp = pdpLobbyObject->m_blConnections.GetNext();
	for (dwCount = 0; dwCount < pdpLobbyObject->m_dwConnectionCount; dwCount++)
	{
		DNASSERT(pblTemp != &pdpLobbyObject->m_blConnections);

		pConnection = CONTAINING_OBJECT(pblTemp, DPL_CONNECTION, m_blLobbyObjectLinkage);

		prghConnect[dwCount] = pConnection->hConnect;

		pblTemp = pblTemp->GetNext();
	}
	DNASSERT(pblTemp == &pdpLobbyObject->m_blConnections);

	DNLeaveCriticalSection(&pdpLobbyObject->m_cs);

	DPFX(DPFPREP, 3,"Returning: DPN_OK");
	return DPN_OK;
}


//	DPLConnectionSendREQ
//
//	Send a request to connect to another process.
//	We will provide the handle of the current Connection to the other side
//		to send back as the SenderContext with messages to the local process
//		so that we can easily lookup info.
//	We will also provide the local PID so the other side can connect to us

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionSendREQ"

HRESULT DPLConnectionSendREQ(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect,
							 const DWORD dwPID,
							 DPL_CONNECT_INFO *const pInfo)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_CONNECT_REQ	*pMsg = NULL;
	CPackedBuffer	PackedBuffer;
	CConnectionSettings *pConnectSettings = NULL;
	PBYTE			pbTmpBuffer = NULL;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx]",hConnect);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hConnect,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	if (!pdplConnection->pSendQueue->IsReceiving())
	{
		DPFERR("Other side is not receiving");
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		return(DPNERR_DOESNOTEXIST);
	}

	DNEnterCriticalSection( &pdplConnection->csLock );

	if( pInfo->pdplConnectionSettings )
	{
		pConnectSettings = new CConnectionSettings();

		if( !pConnectSettings )
		{
			DPFERR("Error allocating memory");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto CONNECTREQ_EXIT;
		}

		hResultCode = pConnectSettings->InitializeAndCopy( pInfo->pdplConnectionSettings );

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP, 0, "Error copying settings hr [0x%x]", hResultCode );
			goto CONNECTREQ_EXIT;
		}
	}

	PackedBuffer.Initialize( NULL, 0 );	

	// Determine size of message to send.
	PackedBuffer.AddToFront(NULL,sizeof(DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER));

	// Add connect settings if they exist
	if( pInfo->pdplConnectionSettings )
		pConnectSettings->BuildWireStruct(&PackedBuffer);

	// Add lobby connect data
	PackedBuffer.AddToBack(NULL,pInfo->dwLobbyConnectDataSize);

	pbTmpBuffer = new BYTE[PackedBuffer.GetSizeRequired()];

	if( !pbTmpBuffer )
	{
		DPFERR("Error allocating memory" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto CONNECTREQ_EXIT;
	}

	pMsg = (DPL_INTERNAL_MESSAGE_CONNECT_REQ *) pbTmpBuffer;

	PackedBuffer.Initialize( pMsg, PackedBuffer.GetSizeRequired() );

	hResultCode = PackedBuffer.AddToFront( pMsg, sizeof( DPL_INTERNAL_MESSAGE_CONNECT_REQ_HEADER ) );

	if( FAILED( hResultCode ) )
	{
		DPFX( DPFPREP, 0, "Internal error! hr [0x%x]", hResultCode );
		goto CONNECTREQ_EXIT;
	}

	pMsg->dwMsgId = DPL_MSGID_INTERNAL_CONNECT_REQ;
	pMsg->hSender = hConnect;
	pMsg->dwSenderPID = dwPID;	

	if( pInfo->pdplConnectionSettings )
	{
		hResultCode = pConnectSettings->BuildWireStruct(&PackedBuffer);

		if( FAILED( hResultCode ) )
		{
			DPFX( DPFPREP, 0, "Error building wire struct for settings hr [0x%x]", hResultCode );
			goto CONNECTREQ_EXIT;
		}
		
		pMsg->dwConnectionSettingsSize = 1;		
	}
	else
	{
		pMsg->dwConnectionSettingsSize = 0;
	}

	hResultCode = PackedBuffer.AddToBack(pInfo->pvLobbyConnectData, pInfo->dwLobbyConnectDataSize, FALSE);

	if( FAILED( hResultCode ) )
	{
		DPFX( DPFPREP, 0, "Error adding connect data hr [0x%x]", hResultCode );
		goto CONNECTREQ_EXIT;
	}

	pMsg->dwLobbyConnectDataOffset = PackedBuffer.GetTailOffset();
	pMsg->dwLobbyConnectDataSize = pInfo->dwLobbyConnectDataSize;

	hResultCode = DPLConnectionSetConnectSettings( pdpLobbyObject, hConnect,pConnectSettings );

	if( FAILED( hResultCode ) )
	{
	    DPFERR( "Could not set local copy of connection settings" );
	    goto CONNECTREQ_EXIT;
	}

	hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(pMsg),
												   PackedBuffer.GetSizeRequired(),
												   INFINITE,
												   DPL_MSGQ_MSGFLAGS_USER1,
												   0);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not send connect info");
		goto CONNECTREQ_EXIT;
	}

CONNECTREQ_EXIT:	

	DNLeaveCriticalSection( &pdplConnection->csLock );	

    if( pbTmpBuffer )
    	delete [] pbTmpBuffer;

	DPLConnectionRelease(pdpLobbyObject,hConnect);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);

	if( FAILED( hResultCode ) )
	{
		if( pConnectSettings )
			delete pConnectSettings;
	}
	
	return(hResultCode);
}


//	DPLConnectionReceiveREQ
//
//	Receive a request to connect.
//	Attempt to connect to the requesting process using the PID supplied.
//	Keep the supplied SenderContext for future sends directed at that process.
//	Send a connect acknowledge

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionReceiveREQ"

HRESULT DPLConnectionReceiveREQ(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								BYTE *const pBuffer)
{
	HRESULT			hResultCode;
	DPNHANDLE		handle;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_CONNECT_REQ	*pMsg;
	DPL_MESSAGE_CONNECT		MsgConnect;
	DWORD                   dwSettingsBufferSize = 0;
	BOOL			fLobbyLaunching = FALSE;
	CConnectionSettings *pConnectSettings = NULL;
	BYTE *pbTmpBuffer = NULL; 


	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p]",pBuffer);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(pBuffer != NULL);

	pMsg = reinterpret_cast<DPL_INTERNAL_MESSAGE_CONNECT_REQ*>(pBuffer);

	if ((hResultCode = DPLConnectionNew(pdpLobbyObject,&handle,&pdplConnection)) != DPN_OK)
	{
		DPFERR("Could not create new connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	if ((hResultCode = DPLConnectionConnect(pdpLobbyObject,handle,pMsg->dwSenderPID,FALSE)) != DPN_OK)
	{
		DPFERR("Could not perform requested connection");
		goto CONNECTRECVREQ_ERROR;
	}

	pdplConnection->pSendQueue->SetSenderHandle(pMsg->hSender);
	pdplConnection->dwTargetProcessIdentity = pMsg->dwSenderPID;
	pdplConnection->hTargetProcess=DNOpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pMsg->dwSenderPID);
	if (pdplConnection->hTargetProcess==NULL)
	{
		DPFX(DPFPREP, 0, "Could not get open process PID %u", pMsg->dwSenderPID);
		DisplayDNError(0,GetLastError());
		hResultCode=DPNERR_DOESNOTEXIST;
		goto CONNECTRECVREQ_ERROR;
	}	
	DPFX(DPFPREP,  0, "PID %u hProcess %u", pMsg->dwSenderPID, 
										HANDLE_FROM_DNHANDLE(pdplConnection->hTargetProcess));

	if ((hResultCode = DPLConnectionSendACK(pdpLobbyObject,handle)) != DPN_OK)
	{
		DPFERR("Could not send connection acknowledge");
		goto CONNECTRECVREQ_ERROR;
	}

    if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_MULTICONNECT)
    {
        DPFX(DPFPREP,  1, "Multiconnect flag specified, returning app to available status" );
        pdpLobbyObject->pReceiveQueue->MakeAvailable();
    }

    if( pMsg->dwConnectionSettingsSize )
    {
	 	pConnectSettings = new CConnectionSettings();

	 	if( !pConnectSettings )
	 	{
			DPFERR("Error allocating structure");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto CONNECTRECVREQ_ERROR;
	 	}

	 	hResultCode = pConnectSettings->Initialize( &pMsg->dplConnectionSettings, (UNALIGNED BYTE *) pMsg );

	 	if( FAILED( hResultCode ) )
	 	{
	 		DPFX( DPFPREP, 0, "Error copying connection settings from wire hr=[0x%x]", hResultCode );
			goto CONNECTRECVREQ_ERROR;
	 	}
    }

    // Update the local connection settings
    hResultCode = DPLConnectionSetConnectSettings( pdpLobbyObject, handle, pConnectSettings );

 	if( FAILED( hResultCode ) )
 	{
 		DPFX( DPFPREP, 0, "Error setting connection settings from wire hr=[0x%x]", hResultCode );
		goto CONNECTRECVREQ_ERROR;
	}	

	// Indicate connection to application
	MsgConnect.dwSize = sizeof(DPL_MESSAGE_CONNECT);
	MsgConnect.hConnectId = handle;

 	if( pMsg->dwLobbyConnectDataSize )
 	{
		// Got to copy the connect data locally to an aligned buffer to ensure alignment -- ack
	 	pbTmpBuffer = new BYTE[pMsg->dwLobbyConnectDataSize];

		if( !pbTmpBuffer )
	 	{
			DPFERR("Error allocating structure");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto CONNECTRECVREQ_ERROR;
	 	}

		memcpy( pbTmpBuffer, pBuffer + pMsg->dwLobbyConnectDataOffset, pMsg->dwLobbyConnectDataSize );
		MsgConnect.pvLobbyConnectData = pbTmpBuffer;
		MsgConnect.dwLobbyConnectDataSize = pMsg->dwLobbyConnectDataSize;
 	}
 	else
 	{
 		MsgConnect.pvLobbyConnectData = NULL;
 		MsgConnect.dwLobbyConnectDataSize = 0;
 	}

	MsgConnect.pvConnectionContext = NULL;

	if( pConnectSettings )
	{
		MsgConnect.pdplConnectionSettings = pConnectSettings->GetConnectionSettings();
	}
	else
	{
		MsgConnect.pdplConnectionSettings = NULL;		
	}

	// If we're lobby launching set the connect event before calling the message handler
	// otherwise we may encounter deadlock then timeout if user blocks in callback
	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOOKINGFORLOBBYLAUNCH ) 
	{
		fLobbyLaunching = TRUE;
		pdpLobbyObject->dpnhLaunchedConnection = handle;
	}

	hResultCode = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
													  DPL_MSGID_CONNECT,
													  reinterpret_cast<BYTE*>(&MsgConnect));

	if( FAILED( hResultCode ) )
	{
		DPFX( DPFPREP, 0, "Error returned from user's callback -- ignoring hr [0x%x]", hResultCode );
	}

	// Set the context for this connection
	DPLConnectionSetContext( pdpLobbyObject, handle, MsgConnect.pvConnectionContext );

	if( pbTmpBuffer )
		delete [] pbTmpBuffer;

	// If we're looking for a lobby launch, set the dpnhLaunchedConnection to cache the connection handle
	DNSetEvent(pdpLobbyObject->hConnectEvent);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",DPN_OK);
	return(DPN_OK);

CONNECTRECVREQ_ERROR:

	if( pbTmpBuffer )
		delete [] pbTmpBuffer;

	if( pConnectSettings )
 		delete pConnectSettings;
	
	DPLConnectionDisconnect(pdpLobbyObject,handle);
	DPLConnectionRelease(pdpLobbyObject,handle);

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);	
	
	return(hResultCode); 		
	
}

//	DPLConnectionSendACK
//
//	Send a connect acknowledge.
//	Provide the local handle for the connection to the other side for future
//		sends to the local process

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionSendACK"

HRESULT DPLConnectionSendACK(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							 const DPNHANDLE hConnect)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_CONNECT_ACK	Msg;

	DPFX(DPFPREP, 3,"Parameters: hConnect [0x%lx]",hConnect);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(hConnect != NULL);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hConnect,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	Msg.dwMsgId = DPL_MSGID_INTERNAL_CONNECT_ACK;
	Msg.hSender = hConnect;

	hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(&Msg),
												   sizeof(DPL_INTERNAL_MESSAGE_CONNECT_ACK),
												   INFINITE,
												   DPL_MSGQ_MSGFLAGS_USER1, 
												   0);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not send connection acknowledge");
		DisplayDNError(0,hResultCode);
		DPLConnectionRelease(pdpLobbyObject,hConnect);
		return(hResultCode);
	}

	DPLConnectionRelease(pdpLobbyObject,hConnect);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DPLConnectionReceiveACK
//
//	Receive a connect acknowledge
//	Keep the supplied SenderContext for future sends directed at that process.

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionReceiveACK"

HRESULT DPLConnectionReceiveACK(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
								const DPNHANDLE hSender,
								BYTE *const pBuffer)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_INTERNAL_MESSAGE_CONNECT_ACK	*pMsg;

	DPFX(DPFPREP, 3,"Parameters: hSender [0x%lx], pBuffer [0x%p]",hSender,pBuffer);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(pBuffer != NULL);

	pMsg = reinterpret_cast<DPL_INTERNAL_MESSAGE_CONNECT_ACK*>(pBuffer);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hSender,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find sender's connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	pdplConnection->pSendQueue->SetSenderHandle(pMsg->hSender);

	DNSetEvent(pdplConnection->hConnectEvent);

	DPLConnectionRelease(pdpLobbyObject,hSender);

	// Indicate that a connection was made by setting event
	DNSetEvent(pdpLobbyObject->hConnectEvent);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//	DPLConnectionReceiveDisconnect
//
//	Receive a disconnect
//	Terminate the connection

#undef DPF_MODNAME
#define DPF_MODNAME "DPLConnectionReceiveDisconnect"

HRESULT DPLConnectionReceiveDisconnect(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
									   const DPNHANDLE hSender,
									   BYTE *const pBuffer,
									   const HRESULT hrDisconnectReason )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DPL_MESSAGE_DISCONNECT	MsgDisconnect;

	DPFX(DPFPREP, 3,"Parameters: hSender [0x%lx]",hSender);

	DNASSERT(pdpLobbyObject != NULL);

	if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hSender,&pdplConnection,TRUE)) != DPN_OK)
	{
		DPFERR("Could not find sender's connection");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}

	// Indicate disconnect to user
	MsgDisconnect.dwSize = sizeof(DPL_MESSAGE_DISCONNECT);
	MsgDisconnect.hDisconnectId = hSender;
	MsgDisconnect.hrReason = hrDisconnectReason;

	// Return code is irrelevant, at this point we're going to indicate regardless
	hResultCode = DPLConnectionGetContext( pdpLobbyObject, hSender, &MsgDisconnect.pvConnectionContext );

	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Error getting connection context for 0x%x hr=0x%x", hSender, hResultCode );
	}
	 
	hResultCode = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
													  DPL_MSGID_DISCONNECT,
													  reinterpret_cast<BYTE*>(&MsgDisconnect));

//  Fixed memory leak, DPLConnectionRelease will free the send queue
//	pdplConnection->pSendQueue->Close();
//	pdplConnection->pSendQueue = NULL;

	DPLConnectionRelease(pdpLobbyObject,hSender);

	DPLConnectionRelease(pdpLobbyObject,hSender);

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplcommon.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLCommon.cpp
 *  Content:    DirectPlay Lobby Common Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/21/00	mjn		Created
 *  04/13/00	rmt     First pass param validation
 *	04/26/00	mjn		Removed dwTimeOut from Send() API call
 *  05/01/00    rmt     Bug #33108 -- Initialize returns DPNERR_NORESPONSE when not lobbied
 *  05/03/00    rmt     Updated initialize so if lobby launched automatically establishes a 
 *                      connection and makes self unavailable.  (Also waits for connection).
 *  05/16/00	rmt		Bug #34734 -- Init Client, Init App, Close App hangs -- 
 *						both client and app were using 'C' prefix, should have been 'C' for 
 *						client and 'A' for app.
 *  06/14/00	rmt		Fixed build break with new compiler (added ')''s).
 *  06/15/00    rmt     Bug #33617 - Must provide method for providing automatic launch of DirectPlay instances   
 *  06/28/00	rmt		Prefix Bug #38082
 *  07/06/00	rmt		Bug #38717 ASSERTION when sending data
 *  07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *  07/13/2000	rmt		Fixed memory leak
 *  07/14/2000	rmt		Bug #39257 - LobbyClient::ReleaseApp returns E_OUTOFMEMORY when called when no one connected
 *  07/21/2000	rmt		Removed assert which wasn't needed
 *  08/03/2000	rmt		Removed assert which wasn't needed
 *  08/05/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/18/2000	rmt		Bug #42751 - DPLOBBY8: Prohibit more than one lobby client or lobby app per process 
 *  08/24/2000	rmt		Bug #43317 - DP8LOBBY: Occasionally when closing Lobby App right after releasing handles, causes assertion.
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

LONG volatile g_lLobbyAppCount = 0;
LONG volatile g_lLobbyClientCount = 0;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

// DPL_GetConnectionSettings
//
// Retrieves the pdplSessionInfo (if any) associated with the specified connection.  This method
// is shared between the client and app interfaces.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_GetConnectionSettings"
STDMETHODIMP DPL_GetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, DPL_CONNECTION_SETTINGS * const pdplSessionInfo, DWORD *pdwInfoSize, const DWORD dwFlags )
{
	HRESULT			hResultCode;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;

	DPFX(DPFPREP, 3,"Parameters: hTarget [0x%lx], pdplSessionInfo [0x%p], pdwInfoSize [%p], dwFlags [0x%lx]",
			hLobbyClient,pdplSessionInfo,pdwInfoSize,dwFlags);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
	    
#ifndef DPNBUILD_NOPARAMVAL
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateGetConnectionSettings( lpv, hLobbyClient, pdplSessionInfo, pdwInfoSize, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating getconnectsettings params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	
#endif // !DPNBUILD_NOPARAMVAL

    // Attempt to retrieve connection settings.
	hResultCode = DPLConnectionGetConnectSettings( pdpLobbyObject, hLobbyClient, pdplSessionInfo, pdwInfoSize );

    DPF_RETURN( hResultCode );
}

// DPL_SetConnectionSettings
//
// Sets the pdplSessionInfo structure associated with the specified connection.  This method 
// is shared between the client and app interfaces.
//
// This function will generate a DPL_MSGID_CONNECTION_SETTINGS message to be sent to the specified
// connection.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPL_SetConnectionSettings"
STDMETHODIMP DPL_SetConnectionSettings(LPVOID lpv,const DPNHANDLE hLobbyClient, const DPL_CONNECTION_SETTINGS * const pdplSessionInfo, const DWORD dwFlags )
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	DPNHANDLE		*hTargets = NULL;
	DWORD			dwNumTargets = 0;
	DWORD			dwTargetIndex = 0;
	CConnectionSettings *pConnectionSettings = NULL;

	DPFX(DPFPREP, 3,"Parameters: hLobbyClient [0x%lx], pBuffer [0x%p], dwFlags [0x%lx]",
			hLobbyClient,pdplSessionInfo,dwFlags);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(lpv));
	    
#ifndef DPNBUILD_NOPARAMVAL
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateSetConnectionSettings( lpv, hLobbyClient, pdplSessionInfo, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating setconnectsettings params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	
#endif // !DPNBUILD_NOPARAMVAL

	if( hLobbyClient == DPLHANDLE_ALLCONNECTIONS )
	{
		dwNumTargets = 0;

		// We need loop so if someone adds a connection during our run
		// it gets added to our list
		//
		while( 1 )
		{
			hResultCode = DPLConnectionEnum( pdpLobbyObject, hTargets, &dwNumTargets );

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( hTargets )
				{
					delete [] hTargets;
				}

				hTargets = new DPNHANDLE[dwNumTargets];

				if( hTargets == NULL )
				{
					DPFERR("Error allocating memory" );
					dwNumTargets = 0;
					hResultCode = DPNERR_OUTOFMEMORY;
					goto SETCONNECT_EXIT;
				}


				continue;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error getting list of connections hr=0x%x", hResultCode );
				break;
			}
			else
			{
				break;
			}
		}

		// Failed getting connection information
		if( FAILED( hResultCode ) )
		{
			if( hTargets )
			{
				delete [] hTargets;
				hTargets = NULL;
			}
			dwNumTargets = 0;
			goto SETCONNECT_EXIT;
		}

	}
	else
	{
		hTargets = new DPNHANDLE[1]; // We use array delete below so we need array new

		if( hTargets == NULL )
		{
			DPFERR("Error allocating memory" );
			dwNumTargets = 0;
			hResultCode = DPNERR_OUTOFMEMORY;
			goto SETCONNECT_EXIT;
		}

		dwNumTargets = 1;
		hTargets[0] = hLobbyClient;
	}
		
	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hTargets[dwTargetIndex],&pdplConnection,TRUE)) != DPN_OK)
		{
			DPFERR("Invalid send target");
			DisplayDNError(0,hResultCode);
			continue;
		}

		if( pdplSessionInfo )
		{
			pConnectionSettings = new CConnectionSettings();

			if( !pConnectionSettings )
			{
				DPFERR("Error allocating memory" );
				hResultCode = DPNERR_OUTOFMEMORY;
				goto SETCONNECT_EXIT;
			}

			hResultCode = pConnectionSettings->InitializeAndCopy( pdplSessionInfo );

			if( FAILED( hResultCode ) )
			{
				DPFX( DPFPREP, 0, "Error setting up connection settings hr [0x%x]", hResultCode );
				goto SETCONNECT_EXIT;
			}
		}

		// Attempt to set connection settings.
		hResultCode = DPLConnectionSetConnectSettings( pdpLobbyObject, hTargets[dwTargetIndex], pConnectionSettings );

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error setting connct settings for 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
			delete pConnectionSettings;
		}

		hResultCode = DPLSendConnectionSettings( pdpLobbyObject, hTargets[dwTargetIndex] );

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error sending connection settings to client 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
		}

		pConnectionSettings = NULL;
	}

SETCONNECT_EXIT:

	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if( hTargets[dwTargetIndex] )
			DPLConnectionRelease(pdpLobbyObject,hTargets[dwTargetIndex]);
	}

	if( hTargets )
		delete [] hTargets;

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME 
#define DPF_MODNAME "DPL_RegisterMessageHandlerClient"
STDMETHODIMP DPL_RegisterMessageHandlerClient(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										const DWORD dwFlags)
{
	return DPL_RegisterMessageHandler( pv, pvUserContext, pfn, NULL, dwFlags );
}

//	HRESULT	DPL_RegisterMessageHandler
//		PVOID					pv				Interface pointer
//		PVOID					pvUserContext	User context
//		PFNDPNMESSAGEHANDLER	pfn				User supplied message handler
//		DWORD					dwFlags			Not Used
//
//	Returns
//		DPN_OK					If the message handler was registered without incident
//		DPNERR_INVALIDPARAM		If there was an invalid parameter
//		DPNERR_GENERIC			If there were any problems
//
//	Notes
//		This function registers a user supplied message handler function.  This function should
//		only be called once, even in cases where a game is being re-connected (i.e. after ending)
//
//		This will set up the required message queues, handshake the lobby client's PID (if supplied on the
//		command line) and spawn the application's receive message queue thread.

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_RegisterMessageHandler"

STDMETHODIMP DPL_RegisterMessageHandler(PVOID pv,
										const PVOID pvUserContext,
										const PFNDPNMESSAGEHANDLER pfn,
										DPNHANDLE * const pdpnhConnection, 
										const DWORD dwFlags)
{
	HRESULT					hResultCode = DPN_OK;
	DWORD					dwCurrentPid;
	DWORD					dwThreadId;
	PDIRECTPLAYLOBBYOBJECT	pdpLobbyObject;
	char					cSuffix;

	DPFX(DPFPREP, 3,"Parameters: pv [0x%p], pfn [0x%p], dwFlags [%lx]",pv,pfn,dwFlags);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
	    
#ifndef DPNBUILD_NOPARAMVAL
		// TODO: MASONB: Why no paramval flag wrapping this?
		if( FAILED( hResultCode = DPL_ValidateRegisterMessageHandler( pv, pvUserContext, pfn, pdpnhConnection, dwFlags ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating register message handler params hr=[0x%lx]", hResultCode );
    	    DPF_RETURN( hResultCode );
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue != NULL)
    	{
    		DPFERR("Already initialized");
    		DPF_RETURN(DPNERR_ALREADYINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	
#endif // !DPNBUILD_NOPARAMVAL

	if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION )
	{
		// If we weren't at zero complain, otherwise put us at 1
		if( DNInterlockedCompareExchange((LONG*)&g_lLobbyAppCount, 1, 0) != 0 )
		{
			DPFERR( "You can only start one lobbied application per process!" );
			DPF_RETURN( DPNERR_NOTALLOWED );
		}
	}
	else
	{
		DNASSERT(pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBYCLIENT);
		// If we weren't at zero complain, otherwise put us at 1
		if( DNInterlockedCompareExchange((LONG*)&g_lLobbyClientCount, 1, 0) != 0 )
		{
			DPFERR( "You can only start one lobby client per process!" );
			DPF_RETURN( DPNERR_NOTALLOWED );
		}
	}

#ifndef DPNBUILD_NOPARAMVAL
	// Disable parameter validation flag if DPNINITIALIZE_DISABLEPARAMVAL 
	// is specified 
	if( dwFlags & DPLINITIALIZE_DISABLEPARAMVAL )
	{
		pdpLobbyObject->dwFlags &= ~(DPL_OBJECT_FLAG_PARAMVALIDATION);
   	}
#endif // !DPNBUILD_NOPARAMVAL

	pdpLobbyObject->pfnMessageHandler = pfn;
	pdpLobbyObject->pvUserContext = pvUserContext;

	pdpLobbyObject->pReceiveQueue = new CMessageQueue;


	if( pdpLobbyObject->pReceiveQueue == NULL )
	{
		DPFX(DPFPREP,  0, "Error allocating receive queue" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto ERROR_DPL_RegisterMessageHandler;		
	}

	pdpLobbyObject->pReceiveQueue->SetMessageHandler(static_cast<PVOID>(pdpLobbyObject),DPLMessageHandler);

	if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION)
	{
		cSuffix = DPL_MSGQ_OBJECT_SUFFIX_APPLICATION;
	}
	else
	{
		cSuffix = DPL_MSGQ_OBJECT_SUFFIX_CLIENT;
	}

	// Open application receive message queue
	dwCurrentPid = GetCurrentProcessId();
	if ((hResultCode = pdpLobbyObject->pReceiveQueue->Open(dwCurrentPid,
			cSuffix,DPL_MSGQ_SIZE,DPL_MSGQ_TIMEOUT_IDLE,0)) != DPN_OK)
	{
		DPFERR("Could not open App Rec Q");
		goto ERROR_DPL_RegisterMessageHandler;
	}

	if ((pdpLobbyObject->hReceiveThread =
			DNCreateThread(NULL,(DWORD)NULL,(LPTHREAD_START_ROUTINE)DPLProcessMessageQueue,
				static_cast<void*>(pdpLobbyObject->pReceiveQueue),(DWORD)NULL,&dwThreadId)) == NULL)
	{
		DPFERR("CreateThread() failed");
		hResultCode = DPNERR_GENERIC;
		pdpLobbyObject->pReceiveQueue->Close();
		goto ERROR_DPL_RegisterMessageHandler;
	}

	pdpLobbyObject->pReceiveQueue->WaitForReceiveThread(INFINITE);

	if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION)
	{
		DPFX(DPFPREP, 5,"Attempt lobby connection");

		hResultCode = DPLAttemptLobbyConnection(pdpLobbyObject);

		if ( hResultCode == DPN_OK)
		{
			if( pdpnhConnection )
				*pdpnhConnection = pdpLobbyObject->dpnhLaunchedConnection;

			DPFX(DPFPREP, 5,"Application was lobby launched");
			DPFX(DPFPREP, 5,"Waiting for true connect notification" );

			DWORD dwReturnValue = DNWaitForSingleObject( pdpLobbyObject->hConnectEvent, DPL_LOBBYLAUNCHED_CONNECT_TIMEOUT );

			DNASSERT( dwReturnValue == WAIT_OBJECT_0 );
		}
		else if( hResultCode != DPNERR_TIMEDOUT )
		{
			DPFX(DPFPREP, 5,"Application was not lobby launched");

			if( pdpnhConnection )
				*pdpnhConnection = NULL;

			// Need to reset return code to OK.. this is not an error
			hResultCode = DPN_OK;
		}
		else
		{
			DPFERR( "App was lobby launched but timed out establishing a connection" );
			if( pdpnhConnection )
				*pdpnhConnection = NULL;
		}
	}

EXIT_DPL_RegisterMessageHandler:

	DPF_RETURN(hResultCode);

ERROR_DPL_RegisterMessageHandler:

	if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION )
	{
		DNInterlockedExchange((LONG*)&g_lLobbyAppCount, 0);
	}
	else
	{
		DNASSERT(pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBYCLIENT);
		DNInterlockedExchange((LONG*)&g_lLobbyClientCount, 0);
	}

	goto EXIT_DPL_RegisterMessageHandler;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Close"

STDMETHODIMP DPL_Close(PVOID pv, const DWORD dwFlags )
{
	HRESULT					hResultCode;
	DWORD					dwNumHandles;
	DPNHANDLE				*prgHandles;
	DWORD					dw;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	DPL_CONNECTION			*pConnection;

	DPFX(DPFPREP, 3,"Parameters: (none)");

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
	    
#ifndef DPNBUILD_NOPARAMVAL
		// TODO: MASONB: Why no paramval flag wrapping this?
    	if( FAILED( hResultCode = DPL_ValidateClose( pv, dwFlags  ) ) )
    	{
    	    DPFX(DPFPREP,  0, "Error validating close params hr=[0x%lx]", hResultCode );
    	    return hResultCode;
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Already closed");
    	    return DPNERR_UNINITIALIZED;
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
    	return DPNERR_INVALIDOBJECT;
	}	
#endif // !DPNBUILD_NOPARAMVAL

	// Shutdown the queue first to ensure that we don't end up shutting down a connection
	// twice!  (E.g. disconnect comes in as we are disconnecting it).
	if (pdpLobbyObject->pReceiveQueue)
	{
		if (pdpLobbyObject->pReceiveQueue->IsOpen())
		{

			// Ask receive thread to terminate
			DPFX(DPFPREP, 5,"Terminate Receive Msg Thread");
			pdpLobbyObject->pReceiveQueue->Terminate();

			// Wait for termination to occur
			if (DNWaitForSingleObject(pdpLobbyObject->hReceiveThread,INFINITE) != WAIT_OBJECT_0)
			{
				hResultCode = DPNERR_GENERIC;
				DPFERR("WaitForSingleObject failed");
			}
			pdpLobbyObject->pReceiveQueue->Close();

    		if (pdpLobbyObject->pReceiveQueue)
    		{
    			delete pdpLobbyObject->pReceiveQueue;			
    			pdpLobbyObject->pReceiveQueue = NULL;
    		}

			if (pdpLobbyObject->hReceiveThread)
			{
				DNCloseHandle(pdpLobbyObject->hReceiveThread);
				pdpLobbyObject->hReceiveThread = NULL;
			}
			
			if (pdpLobbyObject->hConnectEvent)
			{
				DNCloseHandle(pdpLobbyObject->hConnectEvent);
				pdpLobbyObject->hConnectEvent = NULL;
			}

			if (pdpLobbyObject->hLobbyLaunchConnectEvent)
			{
				DNCloseHandle(pdpLobbyObject->hLobbyLaunchConnectEvent);
				pdpLobbyObject->hLobbyLaunchConnectEvent = NULL;
			}
		}
	}

	// Enumerate handles outstanding 
	dwNumHandles = 0;		
	prgHandles = NULL;
	hResultCode = DPLConnectionEnum(pdpLobbyObject,prgHandles,&dwNumHandles);
	while (hResultCode == DPNERR_BUFFERTOOSMALL)
	{
		if (prgHandles)
			DNFree(prgHandles);

		if ((prgHandles = static_cast<DPNHANDLE*>(DNMalloc(dwNumHandles*sizeof(DPNHANDLE)))) != NULL)
		{
			hResultCode = DPLConnectionEnum(pdpLobbyObject,prgHandles,&dwNumHandles);
		}
		else
		{
			DPFERR("Could not allocate space for handle array");
			hResultCode = DPNERR_OUTOFMEMORY;
			break;
		}
	}

	// Send DISCONNECTs to all attached msg queues, for which there are handles
	if (hResultCode == DPN_OK)
	{
		for (dw = 0 ; dw < dwNumHandles ; dw++)
		{
			hResultCode = DPLConnectionFind(pdpLobbyObject,prgHandles[dw],&pConnection,TRUE );

			if( SUCCEEDED( hResultCode ) )
			{

				hResultCode = DPLConnectionDisconnect(pdpLobbyObject,prgHandles[dw]);

				if( FAILED( hResultCode ) )
				{
					DPFX(DPFPREP,  0, "Error disconnecting connection 0x%x", hResultCode );
				}

				DPLConnectionRelease( pdpLobbyObject,prgHandles[dw]);
			}
		}

		// Errors above are irrelevant, it's quite possible after building the list of outstanding 
		// connections that before we attempt to close the list one has gone away.
		// 
		hResultCode = DPN_OK;			
	}	

	if (prgHandles)
	{
		DNFree(prgHandles);
        prgHandles = NULL;
	}

	if (pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBIEDAPPLICATION )
	{
		DNInterlockedExchange((LONG*)&g_lLobbyAppCount, 0);
	}
	else
	{
		DNASSERT(pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_LOBBYCLIENT);
		DNInterlockedExchange((LONG*)&g_lLobbyClientCount, 0);
	}

	DPF_RETURN( hResultCode );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPL_Send"

STDMETHODIMP DPL_Send(PVOID pv,
					  const DPNHANDLE hTarget,
					  BYTE *const pBuffer,
					  const DWORD dwBufferSize,
					  const DWORD dwFlags)
{
	HRESULT			hResultCode;
	DPL_CONNECTION	*pdplConnection;
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	DPNHANDLE		*hTargets = NULL;
	DWORD			dwNumTargets = 0;
	DWORD			dwTargetIndex = 0;

	DPFX(DPFPREP, 3,"Parameters: hTarget [0x%lx], pBuffer [0x%p], dwBufferSize [%ld], dwFlags [0x%lx]",
			hTarget,pBuffer,dwBufferSize,dwFlags);

#ifndef DPNBUILD_NOPARAMVAL
	TRY
	{
#endif // !DPNBUILD_NOPARAMVAL
    	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
	    
#ifndef DPNBUILD_NOPARAMVAL
    	if( pdpLobbyObject->dwFlags & DPL_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DPL_ValidateSend( pv, hTarget, pBuffer, dwBufferSize, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating send params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

    	// Ensure we've been initialized
    	if (pdpLobbyObject->pReceiveQueue == NULL)
    	{
    		DPFERR("Not initialized");
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}
#endif // !DPNBUILD_NOPARAMVAL
	
	if( hTarget == DPLHANDLE_ALLCONNECTIONS )
	{
		dwNumTargets = 0;

		// We need loop so if someone adds a connection during our run
		// it gets added to our list
		//
		while( 1 )
		{
			hResultCode = DPLConnectionEnum( pdpLobbyObject, hTargets, &dwNumTargets );

			if( hResultCode == DPNERR_BUFFERTOOSMALL )
			{
				if( hTargets )
				{
					delete [] hTargets;
				}

				hTargets = new DPNHANDLE[dwNumTargets];

				if( hTargets == NULL )
				{
					DPFERR("Error allocating memory" );
					dwNumTargets = 0;
					hResultCode = DPNERR_OUTOFMEMORY;
					goto EXIT_AND_CLEANUP;
				}

				memset( hTargets, 0x00, sizeof(DPNHANDLE)*dwNumTargets);

				continue;
			}
			else if( FAILED( hResultCode ) )
			{
				DPFX(DPFPREP,  0, "Error getting list of connections hr=0x%x", hResultCode );
				break;
			}
			else
			{
				break;
			}
		}

		// Failed getting connection information
		if( FAILED( hResultCode ) )
		{
			if( hTargets )
			{
				delete [] hTargets;
				hTargets = NULL;
			}
			dwNumTargets = 0;
			goto EXIT_AND_CLEANUP;
		}

	}
	else
	{
		hTargets = new DPNHANDLE[1]; // We use array delete below so we need array new

		if( hTargets == NULL )
		{
			DPFERR("Error allocating memory" );
			dwNumTargets = 0;
			hResultCode = DPNERR_OUTOFMEMORY;
			goto EXIT_AND_CLEANUP;
		}

		dwNumTargets = 1;
		hTargets[0] = hTarget;
	}
		
	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if ((hResultCode = DPLConnectionFind(pdpLobbyObject,hTargets[dwTargetIndex],&pdplConnection,TRUE)) != DPN_OK)
		{
			DPFERR("Invalid send target");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDHANDLE;
			goto EXIT_AND_CLEANUP;
		}

		DNASSERT(pdplConnection->pSendQueue != NULL);

		if (!pdplConnection->pSendQueue->IsReceiving())
		{
			DPFERR("Other side is not listening");
			DPLConnectionRelease(pdpLobbyObject,hTarget);
			hResultCode = DPNERR_INVALIDHANDLE;
			goto EXIT_AND_CLEANUP;
		}

		hResultCode = pdplConnection->pSendQueue->Send(pBuffer,dwBufferSize,INFINITE,DPL_MSGQ_MSGFLAGS_USER2,0);

		if( FAILED( hResultCode ) )
		{
			DPFX(DPFPREP,  0, "Error sending to connection 0x%x hr=0x%x", hTargets[dwTargetIndex], hResultCode );
		}
	}

EXIT_AND_CLEANUP:

	for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
	{
		if( hTargets[dwTargetIndex] )
			DPLConnectionRelease(pdpLobbyObject,hTargets[dwTargetIndex]);
	}

	if( hTargets )
		delete [] hTargets;

	DPF_RETURN(hResultCode);

}

#undef DPF_MODNAME
#define DPF_MODNAME "DPLReceiveIdleTimeout"
HRESULT DPLReceiveIdleTimeout(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							  const DPNHANDLE hSender)
{
    DPL_CONNECTION *pConnection;
	CBilink* pblTemp;
	CBilink blRemove;

	blRemove.Initialize();

    DPFX(DPFPREP,  6, "(%p) Enumerating processes, checking for exit", pdpLobbyObject );

	DNEnterCriticalSection(&pdpLobbyObject->m_cs);

	// Go through the list of all connections and build up a list of the ones that 
	// need to be removed.
	pblTemp = pdpLobbyObject->m_blConnections.GetNext();
	while (pblTemp != &pdpLobbyObject->m_blConnections)
	{
		pConnection = CONTAINING_OBJECT(pblTemp, DPL_CONNECTION, m_blLobbyObjectLinkage);

		pblTemp = pblTemp->GetNext();

		DWORD dwExitCode=0;
		if (DNGetExitCodeProcess(pConnection->hTargetProcess, &dwExitCode)==FALSE || dwExitCode!=STILL_ACTIVE)
		{
			DPFX(DPFPREP,  5, "(%p) Process exit detected hTargetProcess %u dwExitCode %u GetLastError %u", 
				pdpLobbyObject, HANDLE_FROM_DNHANDLE(pConnection->hTargetProcess), dwExitCode, GetLastError());
				// Take the connection off of the Lobby Object's list and on a temporary list
			pConnection->m_blLobbyObjectLinkage.RemoveFromList();
			pdpLobbyObject->m_dwConnectionCount--;
			pConnection->m_blLobbyObjectLinkage.InsertBefore(&blRemove);
		}
	}

	DNLeaveCriticalSection(&pdpLobbyObject->m_cs);

	// Go through the list of removed connections and signal the user
	pblTemp = blRemove.GetNext();
	while (pblTemp != &blRemove)
	{
		pConnection = CONTAINING_OBJECT(pblTemp, DPL_CONNECTION, m_blLobbyObjectLinkage);

		pblTemp = pblTemp->GetNext();

		pConnection->m_blLobbyObjectLinkage.RemoveFromList();

			// Process has exited..
		DPFX(DPFPREP,  6, "(%p) Process has exited PID %u hProcess", pdpLobbyObject, 
			pConnection->dwTargetProcessIdentity, HANDLE_FROM_DNHANDLE(pConnection->hTargetProcess ));
		DPLConnectionReceiveDisconnect( pdpLobbyObject, pConnection->hConnect, NULL, DPNERR_CONNECTIONLOST );
	}
   
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPLReceiveUserMessage"

HRESULT DPLReceiveUserMessage(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
							  const DPNHANDLE hSender,
							  BYTE *const pBuffer,
							  const DWORD dwBufferSize)
{
	HRESULT			hResultCode;
	DPL_MESSAGE_RECEIVE	Msg;

	Msg.dwSize = sizeof(DPL_MESSAGE_RECEIVE);
	Msg.pBuffer = pBuffer;
	Msg.dwBufferSize = dwBufferSize;
	Msg.hSender = hSender;

	hResultCode = DPLConnectionGetContext( pdpLobbyObject, hSender, &Msg.pvConnectionContext );

	// Failed to get the connection's context -- strange, but we're going to indicate anyhow.  
	//
	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Failed getting connection context hResultCode = 0x%x", hResultCode );
	}

	hResultCode = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
													  DPL_MSGID_RECEIVE,
													  reinterpret_cast<BYTE*>(&Msg));

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DPLMessageHandler"

HRESULT DPLMessageHandler(PVOID pvContext,
						  const DPNHANDLE hSender,
						  DWORD dwMessageFlags, 
						  BYTE *const pBuffer,
						  const DWORD dwBufferSize)
{
	DIRECTPLAYLOBBYOBJECT	*pdpLobbyObject;
	HRESULT		hResultCode;
	DWORD		*pdwMsgId;

	DPFX(DPFPREP, 3,"Parameters: hSender [0x%x], pBuffer [0x%p], dwBufferSize [%ld]",
			hSender,pBuffer,dwBufferSize);

	DNASSERT(pBuffer != NULL);

	/*if (dwBufferSize < sizeof(DWORD))
	{
		DPFERR("Invalid message");
		return(DPNERR_GENERIC);
	}*/

	pdpLobbyObject = static_cast<DIRECTPLAYLOBBYOBJECT*>(pvContext);
	pdwMsgId = reinterpret_cast<DWORD*>(pBuffer);

	if( dwMessageFlags & DPL_MSGQ_MSGFLAGS_USER1 )
	{
		DPFX(DPFPREP, 5,"Received INTERNAL message");
		switch(*pdwMsgId)
		{
		case DPL_MSGID_INTERNAL_IDLE_TIMEOUT:
		    {
		        DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_IDLE_TIMEOUT" );
		        DPLReceiveIdleTimeout(pdpLobbyObject,hSender);
		        break;
		    }
		case DPL_MSGID_INTERNAL_DISCONNECT:
			{
				DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_DISCONNECT");
				DPLConnectionReceiveDisconnect(pdpLobbyObject,hSender,pBuffer,DPN_OK);
				break;
			}

		case DPL_MSGID_INTERNAL_CONNECT_REQ:
			{
				DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_CONNECT_REQ");
				DPLConnectionReceiveREQ(pdpLobbyObject,pBuffer);
				break;
			}

		case DPL_MSGID_INTERNAL_CONNECT_ACK:
			{
				DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_CONNECT_ACK");
				DPLConnectionReceiveACK(pdpLobbyObject,hSender,pBuffer);
				break;
			}

		case DPL_MSGID_INTERNAL_UPDATE_STATUS:
			{
				DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_UPDATE_STATUS");
				DPLUpdateAppStatus(pdpLobbyObject,hSender,pBuffer);
				break;
			}

		case DPL_MSGID_INTERNAL_CONNECTION_SETTINGS:
		    {
		        DPFX(DPFPREP, 5,"Received: DPL_MSGID_INTERNAL_CONNECTION_SETTINGS");
		        DPLUpdateConnectionSettings(pdpLobbyObject,hSender,pBuffer);
		        break;
		    }

		default:
			{
				DPFX(DPFPREP, 5,"Received: Unknown message [0x%lx]",*pdwMsgId);
				DNASSERT(FALSE);
				break;
			}
		}
	}
	else if( dwMessageFlags & DPL_MSGQ_MSGFLAGS_USER2 )
	{
		DNASSERT( !(dwMessageFlags & DPL_MSGQ_MSGFLAGS_QUEUESYSTEM) );
		DPFX(DPFPREP, 5,"Received USER message");
		DPLReceiveUserMessage(pdpLobbyObject,hSender,pBuffer,dwBufferSize);
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

// DPLSendConnectionSettings
//
// This function is used to send a connection settings update message
#undef DPF_MODNAME
#define DPF_MODNAME "DPLSendConnectionSettings"
HRESULT DPLSendConnectionSettings( DIRECTPLAYLOBBYOBJECT * const pdpLobbyObject, 
								   const DPNHANDLE hConnection )
{
	BYTE *pbTransmitBuffer = NULL;
	DWORD dwTransmitBufferSize = 0;
	DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE *pdplMsgSettings = NULL;
	DPL_CONNECTION *pdplConnection = NULL;
	CPackedBuffer PackBuffer;

	HRESULT			hResultCode = DPN_OK;

    hResultCode = DPLConnectionFind(pdpLobbyObject, hConnection, &pdplConnection, TRUE );

    if( FAILED( hResultCode ) )
    {
        DPFERR( "Unable to find specified connection" );
        return hResultCode;
    }

    // Grab lock to prevent other people from interfering
    DNEnterCriticalSection( &pdplConnection->csLock );

    PackBuffer.Initialize( NULL, 0 );

    PackBuffer.AddToFront( NULL, sizeof( DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER ) );

    if( pdplConnection->pConnectionSettings )
    {
    	pdplConnection->pConnectionSettings->BuildWireStruct( &PackBuffer );
    }

    dwTransmitBufferSize = PackBuffer.GetSizeRequired();

    pbTransmitBuffer = new BYTE[ dwTransmitBufferSize ];

    if( !pbTransmitBuffer )
    {
    	DPFX( DPFPREP, 0, "Error allocating memory" );
    	hResultCode = DPNERR_OUTOFMEMORY;
    	goto DPLSENDCONNECTSETTINGS_DONE;
    }

    pdplMsgSettings = (DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE *) pbTransmitBuffer;

    PackBuffer.Initialize( pbTransmitBuffer, dwTransmitBufferSize );

    DNASSERT( pdplMsgSettings );

    hResultCode = PackBuffer.AddToFront( NULL, sizeof( DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE_HEADER ) );

	if( FAILED( hResultCode ) ) 
	{
		DPFX( DPFPREP, 0, "Error adding main struct hr [0x%x]", hResultCode );
		goto DPLSENDCONNECTSETTINGS_DONE;
	}

	if( pdplConnection->pConnectionSettings )
	{
		hResultCode = pdplConnection->pConnectionSettings->BuildWireStruct( &PackBuffer );

		if( FAILED( hResultCode ) )
		{
			DPFX( DPFPREP, 0, "Error adding connect struct hr [0x%x]", hResultCode );
			goto DPLSENDCONNECTSETTINGS_DONE;			
		}
		
    	pdplMsgSettings->dwConnectionSettingsSize = 1;		
	}
	else
	{
    	pdplMsgSettings->dwConnectionSettingsSize = 0;		
	}

   	pdplMsgSettings->dwMsgId = DPL_MSGID_INTERNAL_CONNECTION_SETTINGS;

	if (!pdplConnection->pSendQueue->IsReceiving())
	{
		DPFERR("Other side is not receiving");
		goto DPLSENDCONNECTSETTINGS_DONE;
	}

	hResultCode = pdplConnection->pSendQueue->Send(reinterpret_cast<BYTE*>(pdplMsgSettings),
												   PackBuffer.GetSizeRequired(),
												   INFINITE,
												   DPL_MSGQ_MSGFLAGS_USER1, 
												   0);
	if ( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP, 0, "Could not send connect settings hr [0x%x]", hResultCode );
		goto DPLSENDCONNECTSETTINGS_DONE;
	}

    hResultCode = DPN_OK;

DPLSENDCONNECTSETTINGS_DONE:

	if( pbTransmitBuffer )
		delete [] pbTransmitBuffer;

    DNLeaveCriticalSection( &pdplConnection->csLock );	

    DPLConnectionRelease(pdpLobbyObject,hConnection);

    return hResultCode;

}


	

// DPLUpdateConnectionSettings
//
// This function is called when a connection settings update message has been received.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DPLUpdateConnectionSettings"
HRESULT DPLUpdateConnectionSettings(DIRECTPLAYLOBBYOBJECT *const pdpLobbyObject,
                           const DPNHANDLE hSender,
						   BYTE *const pBuffer )
{
	HRESULT		hr;
	DPL_MESSAGE_CONNECTION_SETTINGS 			MsgConnectionSettings;
	DWORD                                       dwSettingsBufferSize = 0;
	BOOL										fAddressReferences = FALSE;
	CConnectionSettings							*pConnectionSettings = NULL;
	DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE		*pConnectionSettingsMsg = NULL;

	DPFX(DPFPREP, 3,"Parameters: pBuffer [0x%p]",pBuffer);

	DNASSERT(pdpLobbyObject != NULL);
	DNASSERT(pBuffer != NULL);

	pConnectionSettingsMsg = (DPL_INTERNAL_CONNECTION_SETTINGS_UPDATE *) pBuffer;

	if( pConnectionSettingsMsg->dwConnectionSettingsSize )
	{
		pConnectionSettings = new CConnectionSettings();

		if( !pConnectionSettings )
		{
			DPFX( DPFPREP, 0, "Error allocating connection settings" );
			hr = DPNERR_OUTOFMEMORY;
			goto UPDATESETTINGS_FAILURE;
		}

		hr = pConnectionSettings->Initialize( &pConnectionSettingsMsg->dplConnectionSettings, (UNALIGNED BYTE *) pConnectionSettingsMsg ); 

		if( FAILED( hr ) )
		{
			DPFX( DPFPREP, 0, "Error building structure from wire struct hr [0x%x]", hr );
			goto UPDATESETTINGS_FAILURE;  
		}
	}

	// Set the connection settings on the object
	hr = DPLConnectionSetConnectSettings( pdpLobbyObject, hSender, pConnectionSettings );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error setting connection settings hr = 0x%x", hr );
		goto UPDATESETTINGS_FAILURE;
	}	

	// Setup message to indicate to user
	MsgConnectionSettings.dwSize = sizeof(DPL_MESSAGE_CONNECTION_SETTINGS);
	MsgConnectionSettings.hSender = hSender;

	if( pConnectionSettings )
		MsgConnectionSettings.pdplConnectionSettings = pConnectionSettings->GetConnectionSettings();
	else
		MsgConnectionSettings.pdplConnectionSettings = NULL;

	hr = DPLConnectionGetContext( pdpLobbyObject, hSender, &MsgConnectionSettings.pvConnectionContext );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting connection's context value" );
		goto UPDATESETTINGS_FAILURE;
	}	

	hr = (pdpLobbyObject->pfnMessageHandler)(pdpLobbyObject->pvUserContext,
										     DPL_MSGID_CONNECTION_SETTINGS,
											 reinterpret_cast<BYTE*>(&MsgConnectionSettings));	

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP, 1, "Error returned from user callback -- ignored hr [0x%x]", hr );
	}


	return DPN_OK;

UPDATESETTINGS_FAILURE:	

	if( pConnectionSettings )
		delete pConnectionSettings;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\lobby\dplconset.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DPLConset.cpp
 *  Content:    DirectPlay Lobby Connection Settings Utility Functions
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/13/00   rmt		Created
 *   07/07/00	rmt		Bug #38755 - No way to specify player name in connection settings
 *   07/08/2000	rmt		Bug #38725 - Need to provide method to detect if app was lobby launched
 *				rmt		Bug #38757 - Callback messages for connections may return AFTER WaitForConnection returns
 *				rmt		Bug #38755 - No way to specify player name in Connection Settings
 *				rmt		Bug #38758 - DPLOBBY8.H has incorrect comments
 *				rmt		Bug #38783 - pvUserApplicationContext is only partially implemented
 *				rmt		Added DPLHANDLE_ALLCONNECTIONS and dwFlags (reserved field to couple of funcs).
 *	 07/12/2000	rmt		Removed improper assert
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dnlobbyi.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::CConnectionSettings"
CConnectionSettings::CConnectionSettings(): m_dwSignature(DPLSIGNATURE_LOBBYCONSET), m_fManaged(FALSE), m_pdplConnectionSettings(NULL), m_fCritSecInited(FALSE)
{
}

CConnectionSettings::~CConnectionSettings()
{
	if( !m_fManaged && m_pdplConnectionSettings )
	{
		FreeConnectionSettings( m_pdplConnectionSettings );
		m_pdplConnectionSettings = NULL;
	}
	
	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection( &m_csLock );
	}
	m_dwSignature = DPLSIGNATURE_LOBBYCONSET_FREE;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::FreeConnectionSettings"
// CConnectionSettings::FreeConnectionSettings
//
// This function frees the memory associated with the specified connection
void CConnectionSettings::FreeConnectionSettings( DPL_CONNECTION_SETTINGS *pConnectionSettings )
{
	if( pConnectionSettings ) 
	{
		if( pConnectionSettings->pwszPlayerName )
		{
			delete [] pConnectionSettings->pwszPlayerName;
			pConnectionSettings->pwszPlayerName = NULL;
		}

		if( pConnectionSettings->dpnAppDesc.pwszSessionName )
		{
			delete [] pConnectionSettings->dpnAppDesc.pwszSessionName;
			pConnectionSettings->dpnAppDesc.pwszSessionName = NULL;
		}

		if( pConnectionSettings->dpnAppDesc.pwszPassword )
		{
			delete [] pConnectionSettings->dpnAppDesc.pwszPassword;
			pConnectionSettings->dpnAppDesc.pwszPassword = NULL;
		}

		if( pConnectionSettings->dpnAppDesc.pvReservedData )
		{
			delete [] pConnectionSettings->dpnAppDesc.pvReservedData;
			pConnectionSettings->dpnAppDesc.pvReservedData = NULL;
		}

		if( pConnectionSettings->dpnAppDesc.pvApplicationReservedData )
		{
			delete [] pConnectionSettings->dpnAppDesc.pvApplicationReservedData;
			pConnectionSettings->dpnAppDesc.pvApplicationReservedData = NULL;
		}

		if( pConnectionSettings->pdp8HostAddress )
		{
			IDirectPlay8Address_Release( pConnectionSettings->pdp8HostAddress );
			pConnectionSettings->pdp8HostAddress = NULL;
		}

		if( pConnectionSettings->ppdp8DeviceAddresses )
		{
			for( DWORD dwIndex = 0; dwIndex < pConnectionSettings->cNumDeviceAddresses; dwIndex++ )
			{
				IDirectPlay8Address_Release( pConnectionSettings->ppdp8DeviceAddresses[dwIndex] );
			}

			delete [] pConnectionSettings->ppdp8DeviceAddresses;
			pConnectionSettings->ppdp8DeviceAddresses = NULL;
			
		}
	
		delete pConnectionSettings;
	}	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::Initialize"
// Initialize (DPL_CONNECTION_SETTINGS version)
//
// This function tells this class to take the specified connection settings and 
// work with it.  
//
HRESULT CConnectionSettings::Initialize( DPL_CONNECTION_SETTINGS * pdplSettings )
{
	if (!DNInitializeCriticalSection( &m_csLock ) )
	{
		DPFX(DPFPREP, 0, "Failed to create critical section");
		return DPNERR_OUTOFMEMORY;
	}
	m_fCritSecInited = TRUE;

	m_pdplConnectionSettings = pdplSettings;
	m_fManaged = FALSE;

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::Initialize"
// Initialize (Wire Version)
//
// THis function initializes this object to contain a connection settings structure
// that mirrors the values of the wire message.  
HRESULT CConnectionSettings::Initialize( UNALIGNED DPL_INTERNAL_CONNECTION_SETTINGS *pdplSettingsMsg,  UNALIGNED BYTE * pbBufferStart )
{
	DNASSERT( pdplSettingsMsg );
	
	HRESULT hr = DPN_OK;
	DPL_CONNECTION_SETTINGS *pdplConnectionSettings = NULL;
	UNALIGNED BYTE *pBasePointer = pbBufferStart;
	PDIRECTPLAY8ADDRESS pdp8Address = NULL; 
	WCHAR *wszTmpAlignedBuffer = NULL;  
	DWORD dwTmpOffset = 0;
	DWORD dwTmpLength = 0;
	UNALIGNED DWORD *pdwOffsets = NULL;
	UNALIGNED DWORD *pdwLengths = NULL;

	if (!DNInitializeCriticalSection( &m_csLock ) )
	{
		DPFX(DPFPREP, 0, "Failed to create critical section");
		return DPNERR_OUTOFMEMORY;
	}
	m_fCritSecInited = TRUE;

	pdplConnectionSettings = new DPL_CONNECTION_SETTINGS;

	if( !pdplConnectionSettings )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto INITIALIZE_FAILED;
	}

	// Zero out the memory
	ZeroMemory( pdplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ) );

	pdplConnectionSettings->dwSize = sizeof( DPL_CONNECTION_SETTINGS );
	pdplConnectionSettings->dwFlags = pdplSettingsMsg->dwFlags;

	//
	// PLAYER NAME COPY
	//
	if( pdplSettingsMsg->dwPlayerNameLength )
	{
		pdplConnectionSettings->pwszPlayerName = new WCHAR[pdplSettingsMsg->dwPlayerNameLength >> 1];

		if( !pdplConnectionSettings->pwszPlayerName )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		memcpy( pdplConnectionSettings->pwszPlayerName, pBasePointer + pdplSettingsMsg->dwPlayerNameOffset, 
		        pdplSettingsMsg->dwPlayerNameLength );
	}

	//
	// HOST ADDRESS COPY
	//
	if( pdplSettingsMsg->dwHostAddressLength )
	{
		// We need to create a buffer for string that we know is aligned.   - Ick - 
		wszTmpAlignedBuffer = new WCHAR[pdplSettingsMsg->dwHostAddressLength >> 1];

		if( !wszTmpAlignedBuffer )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto INITIALIZE_FAILED;
		}

		// Copy the potentially unaligned data to the aligned data string.
		memcpy( wszTmpAlignedBuffer, pBasePointer + pdplSettingsMsg->dwHostAddressOffset,pdplSettingsMsg->dwHostAddressLength );
		
        hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, (void **) &pdp8Address, FALSE );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error creating address hr=0x%x", hr );
			goto INITIALIZE_FAILED;
        }

        // Convert the host address (if there is one)
        hr = IDirectPlay8Address_BuildFromURLW( pdp8Address, wszTmpAlignedBuffer );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Error building URL from address hr=0x%x", hr );
			goto INITIALIZE_FAILED;
        }

        pdplConnectionSettings->pdp8HostAddress = pdp8Address;

        pdp8Address = NULL;

		if( wszTmpAlignedBuffer )
		{
			delete [] wszTmpAlignedBuffer;
			wszTmpAlignedBuffer = NULL;
		}
    }

	if( pdplSettingsMsg->dwNumDeviceAddresses )
	{
		pdplConnectionSettings->cNumDeviceAddresses = pdplSettingsMsg->dwNumDeviceAddresses;
    	//
    	// DEVICE ADDRESS COPY
    	//

    	pdplConnectionSettings->ppdp8DeviceAddresses = new PDIRECTPLAY8ADDRESS[pdplSettingsMsg->dwNumDeviceAddresses];

    	if( !pdplConnectionSettings->ppdp8DeviceAddresses )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}
    	
    	// Give us an unaligned dword pointer to the device addresses offset
    	pdwOffsets = (UNALIGNED DWORD *) (pBasePointer + pdplSettingsMsg->dwDeviceAddressOffset);	
    	pdwLengths = (UNALIGNED DWORD *) (pBasePointer + pdplSettingsMsg->dwDeviceAddressLengthOffset);

        for( DWORD dwIndex = 0; dwIndex < pdplSettingsMsg->dwNumDeviceAddresses; dwIndex++ )
        {
        	dwTmpOffset = pdwOffsets[dwIndex];
        	dwTmpLength = pdwLengths[dwIndex];
        	    		
    		// We need to create a buffer for string that we know is aligned.   - Ick - 
    		wszTmpAlignedBuffer = new WCHAR[dwTmpLength >> 1];

    		if( !wszTmpAlignedBuffer )
    		{
    			hr = DPNERR_OUTOFMEMORY;
    			goto INITIALIZE_FAILED;
    		}

    		memcpy( wszTmpAlignedBuffer, pBasePointer + dwTmpOffset, dwTmpLength );
    		
            hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, (void **) &pdp8Address, FALSE );

            if( FAILED( hr ) )
            {
                DPFX(DPFPREP,  0, "Error creating address hr=0x%x", hr );
                return hr;
            }

            // Convert the host address (if there is one)
            hr = IDirectPlay8Address_BuildFromURLW( pdp8Address, wszTmpAlignedBuffer );

            if( FAILED( hr ) )
            {
                DPFX(DPFPREP,  0, "Error building URL from address hr=0x%x", hr );
                DNASSERT( FALSE );
                return hr;
            }

            pdplConnectionSettings->ppdp8DeviceAddresses[dwIndex] = pdp8Address;

            pdp8Address = NULL;

			if( wszTmpAlignedBuffer )
			{
				delete [] wszTmpAlignedBuffer;
				wszTmpAlignedBuffer = NULL;
			}

        }	
	}
	else
	{
	    pdplConnectionSettings->ppdp8DeviceAddresses = NULL;
	}

    // 
	// APPLICATION DESCRIPTION COPY
	//

	pdplConnectionSettings->dpnAppDesc.dwSize = sizeof( DPN_APPLICATION_DESC );
    pdplConnectionSettings->dpnAppDesc.dwFlags = pdplSettingsMsg->dpnApplicationDesc.dwFlags;
    pdplConnectionSettings->dpnAppDesc.guidInstance = pdplSettingsMsg->dpnApplicationDesc.guidInstance;
    pdplConnectionSettings->dpnAppDesc.guidApplication = pdplSettingsMsg->dpnApplicationDesc.guidApplication;
    pdplConnectionSettings->dpnAppDesc.dwMaxPlayers = pdplSettingsMsg->dpnApplicationDesc.dwMaxPlayers;
    pdplConnectionSettings->dpnAppDesc.dwCurrentPlayers = pdplSettingsMsg->dpnApplicationDesc.dwCurrentPlayers;

    if( pdplSettingsMsg->dpnApplicationDesc.dwSessionNameSize )
    {
    	pdplConnectionSettings->dpnAppDesc.pwszSessionName = new WCHAR[pdplSettingsMsg->dpnApplicationDesc.dwSessionNameSize >> 1];

    	if( !pdplConnectionSettings->dpnAppDesc.pwszSessionName )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}

    	memcpy( pdplConnectionSettings->dpnAppDesc.pwszSessionName, 
    		    pBasePointer + pdplSettingsMsg->dpnApplicationDesc.dwSessionNameOffset, 
    		    pdplSettingsMsg->dpnApplicationDesc.dwSessionNameSize );
    }

    if( pdplSettingsMsg->dpnApplicationDesc.dwPasswordSize )
    {
    	pdplConnectionSettings->dpnAppDesc.pwszPassword = new WCHAR[pdplSettingsMsg->dpnApplicationDesc.dwPasswordSize >> 1];

    	if( !pdplConnectionSettings->dpnAppDesc.pwszPassword )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}

    	memcpy( pdplConnectionSettings->dpnAppDesc.pwszPassword, 
    		    pBasePointer + pdplSettingsMsg->dpnApplicationDesc.dwPasswordOffset, 
    		    pdplSettingsMsg->dpnApplicationDesc.dwPasswordSize );
    }    

    if( pdplSettingsMsg->dpnApplicationDesc.dwReservedDataSize )
    {
    	pdplConnectionSettings->dpnAppDesc.pvReservedData = new BYTE[pdplSettingsMsg->dpnApplicationDesc.dwReservedDataSize];

    	if( !pdplConnectionSettings->dpnAppDesc.pvReservedData )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}

    	memcpy( pdplConnectionSettings->dpnAppDesc.pvReservedData, 
    		    pBasePointer + pdplSettingsMsg->dpnApplicationDesc.dwReservedDataOffset, 
    		    pdplSettingsMsg->dpnApplicationDesc.dwReservedDataSize );

		pdplConnectionSettings->dpnAppDesc.dwReservedDataSize = pdplSettingsMsg->dpnApplicationDesc.dwReservedDataSize;
    } 

    if( pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataSize )
    {
    	pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData = new BYTE[pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataSize];

    	if( !pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData )
    	{
    		hr = DPNERR_OUTOFMEMORY;
    		goto INITIALIZE_FAILED;
    	}

    	memcpy( pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData, 
    		    pBasePointer + pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataOffset, 
    		    pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataSize );

		pdplConnectionSettings->dpnAppDesc.dwApplicationReservedDataSize = pdplSettingsMsg->dpnApplicationDesc.dwApplicationReservedDataSize;
    }     

		
	// Free the old structure if one exists.  
	if( m_fManaged )
	{
		m_fManaged = FALSE;		
	} 
	else if( m_pdplConnectionSettings )
	{
		FreeConnectionSettings( m_pdplConnectionSettings );		
	}

    m_pdplConnectionSettings = pdplConnectionSettings;

	if( wszTmpAlignedBuffer ) 
		delete [] wszTmpAlignedBuffer;   

    return DPN_OK;
    
INITIALIZE_FAILED:

	FreeConnectionSettings( pdplConnectionSettings );

	if( wszTmpAlignedBuffer ) 
		delete [] wszTmpAlignedBuffer;

	if( pdp8Address )
		IDirectPlay8Address_Release( pdp8Address );

	return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CConnectionSettings::InitializeAndCopy"
// InitializeAndCopy
//
// This function initializes this class to contain a copy of the specified 
// connection settings structure.
//
HRESULT CConnectionSettings::InitializeAndCopy( const DPL_CONNECTION_SETTINGS * const pdplSettings )
{
	DNASSERT( pdplSettings );
	
	HRESULT hr = DPN_OK;
	DPL_CONNECTION_SETTINGS *pdplConnectionSettings = NULL;

	if (!DNInitializeCriticalSection( &m_csLock ) )
	{
		DPFX(DPFPREP, 0, "Failed to create critical section");
		return DPNERR_OUTOFMEMORY;
	}
	m_fCritSecInited = TRUE;

	pdplConnectionSettings = new DPL_CONNECTION_SETTINGS;

	if( !pdplConnectionSettings )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto INITIALIZE_FAILED;
	}

	// Copy over.  This is a little dangerous as we copy pointer values.  Pointers 
	// should be set in our local structure to NULL so that proper cleanup can occur
	// on error.  (Otherwise we'll free other structure's memory!!)
	memcpy( pdplConnectionSettings, pdplSettings, sizeof( DPL_CONNECTION_SETTINGS ) );

	// Reset pointers as mentioned above.  
	pdplConnectionSettings->pdp8HostAddress = NULL;
	pdplConnectionSettings->ppdp8DeviceAddresses = NULL;	
	pdplConnectionSettings->pwszPlayerName = NULL;
	pdplConnectionSettings->dpnAppDesc.pwszSessionName = NULL;	
	pdplConnectionSettings->dpnAppDesc.pwszPassword = NULL;	
	pdplConnectionSettings->dpnAppDesc.pvReservedData = NULL;		
	pdplConnectionSettings->dpnAppDesc.pvApplicationReservedData = NULL;	

	if( pdplSettings->pdp8HostAddress )
	{
		hr = IDirectPlay8Address_Duplicate( pdplSettings->pdp8HostAddress, &pdplConnectionSettings->pdp8HostAddress );

		if( FAILED( hr ) )
		{
            DPFX(DPFPREP,  0, "Error duplicating host address hr [0x%x]", hr );
            goto INITIALIZE_FAILED;
		}
	}

	if( pdplSettings->ppdp8