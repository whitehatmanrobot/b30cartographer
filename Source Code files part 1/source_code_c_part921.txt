 GetAt(cp / RSIZE) & (1<<(cp % RSIZE));
	return FALSE;
}

// Set break at cp, so it's breakable between char[cp-1] and [cp]
void CBreakArray::SetBreak (LONG cp, BOOL fOn)
{
	if (cp >= _cbBreak)
		return;

	CheckArray();

	cp += cp < _ibGap ? 0 : _cbGap;

	ITEM	*pel = Elem(cp / RSIZE);
	*pel = fOn ? *pel | (1<<(cp % RSIZE)) : *pel & ~(1<<(cp % RSIZE));
}

// Clear break in range <cch> start at position <cp>
void CBreakArray::ClearBreak (
	LONG	cp, 
	LONG	cch)
{
	if (!cch)
		return;

	Assert (cch > 0 && cp < _cbBreak);
	CheckArray();

	cp += cp < _ibGap ? 0 : _cbGap;
	cch += cp < _ibGap && cp + cch > _ibGap ? _cbGap : 0;

	LONG 	i = cp / RSIZE;
	LONG	j = (cp+cch) / RSIZE;
	ITEM	uMaskl, uMaskh;
	ITEM	*pel;

	uMaskl = MASK_LOW(-1, cp % RSIZE);
	uMaskh = ~MASK_LOW(-1, (cp+cch) % RSIZE);

	if (i==j)
	{
		uMaskl |= uMaskh;
		uMaskh = uMaskl;
	}

	// clear first item
	pel = Elem(i);
	*pel &= uMaskl;
	
	if (uMaskh != (ITEM)-1)
	{
		// clear last item
		pel = Elem(j);
		*pel &= uMaskh;
	}

	// clear items in between
	i++;
	while (i < j)
	{
		pel = Elem(i);
		*pel = 0;
		i++;
	}
}

// Collapse the gap down to 0 using bit shifting
// (using the 'bits remove with shifting' algorithm)
//
LONG CBreakArray::CollapseGap ()
{
#ifdef BITVIEW
	_cCollapse++;
#endif
	if (_cbGap == 0)
		return 0;		// No gap

	PUSH_STATE(0, 0, COLLAPSER);

	LONG	cit = _cbGap / RSIZE;
	LONG	i = _ibGap / RSIZE;
	LONG	j = (_ibGap+_cbGap) / RSIZE;
	LONG	cDel = 0;			// number of break deleted
	ITEM	uh, ul;				// H: high-mask after cp, L: low-mask before cp
	ITEM	*peli, *pelj;

	Assert (IsValid());

	// Get the [i] and [j]
	peli = Elem(i);
	pelj = Elem(j);

	// Create the high/low mask & keep the masked values
	ul = MASK_LOW (-1, _ibGap % RSIZE);
	uh = ~MASK_LOW (-1, (_ibGap+_cbGap) % RSIZE);
	ul &= *peli;
	uh &= pelj ? *pelj : 0;

	// Remove items
	if (cit)
	{
		Remove(i, cit);
		cDel += (cit * RSIZE);
		_cbSize -= cDel;
		if (!_cbSize)
			return VALIDATE(cDel);
	}

	// Zero [i]
	peli = Elem(i);
	*peli = 0;

	// Reference the (new) [j]
	j -= cit;

	cit = Count() - 1;

	// Move H to [j]
	pelj = Elem(j);
	if (pelj)
		*pelj = uh;

	// Shifting bits down <cit-i> items starting@[i]
	ShDn(i, cit-i, _cbGap % RSIZE);
	cDel += (_cbGap % RSIZE);

	// Or L to [i]
	*peli |= ul;

	Assert (cit > 0 && cDel == _cbGap);

	_cbGap = 0;

	if (_cbSize - _cbBreak > RSIZE)
	{
		// The last item was shifted til empty.
		// No need to keep it around.
		Remove(cit-1, 1);
		_cbSize -= RSIZE;
	}

	return VALIDATE(0);
}

// Shifting <cel> dword n bits UPWARD
void CBreakArray::ShUp (LONG iel, LONG cel, LONG n)
{
	if (n < RSIZE)
	{
		ITEM	*pel;
		ITEM	uo;				// shifting overflow
		ITEM	ua = 0;			// shifting addendum
		ITEM	uMask = MASK_HIGH(-1, n);
	
		while (cel > 0)
		{
			pel = Elem(iel);
			Assert (pel);
			uo = (*pel & uMask) >> (RSIZE-n);
			*pel = (*pel << n) | ua;
			ua = uo;
			iel++;
			cel--;
		}
	}
}

// Shifting <cel> dword n bits DOWNWARD
void CBreakArray::ShDn (LONG iel, LONG cel, LONG n)
{
	if (n < RSIZE)
	{
		ITEM	*pel;
		ITEM	uo;				// shifting overflow
		ITEM	ua = 0;			// shifting addendum
		ITEM	uMask = MASK_LOW(-1, n);
	
		iel += cel-1;
		while (cel > 0)
		{
			pel = Elem(iel);
			Assert (pel);
			uo = (*pel & uMask) << (RSIZE-n);
			*pel = (*pel >> n) | ua;
			ua = uo;
			iel--;
			cel--;
		}
	}
}

#ifdef BVDEBUG
LONG CBreakArray::Validate (LONG cchRet)
{										
	Assert(_cbSize >= 0 && (Count() - 1)*RSIZE == _cbSize);
	Assert(_cbBreak - _s.cbBreak == cchRet);
	return cchRet;
}										

void CBreakArray::PushState (LONG cp, LONG cch, LONG who)
{
	_s.who = who;
	_s.ibGap = _ibGap;
	_s.cbGap = _cbGap;
	_s.cbSize = _cbSize;
	_s.cbBreak = _cbBreak;
	_s.cp = cp;
	_s.cch = cch;
}
#endif

#ifdef BITVIEW
LONG CBreakArray::SetCollapseCount ()
{
	LONG cc = _cCollapse;
	_cCollapse = 0;
	return cc;
}
#endif


#ifndef BITVIEW

/////// CTxtBreaker class implementation
//		
//
CTxtBreaker::CTxtBreaker(
	CTxtEdit*	ped)
{
	// Register ourself in the notification list
	// so we get notified when backing store changed.

	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);

	_ped = ped;
}

CTxtBreaker::~CTxtBreaker()
{
	CNotifyMgr *pnm = _ped->GetNotifyMgr();

	if(pnm)
		pnm->Remove((ITxNotify *)this);

	// Clear break arrays
	if (_pbrkWord)
	{
		_pbrkWord->Clear(AF_DELETEMEM);
		delete _pbrkWord;
	}
	if (_pbrkChar)
	{
		_pbrkChar->Clear(AF_DELETEMEM);
		delete _pbrkChar;
	}
}

// Adding the breaker
// return TRUE means we plug something in.
BOOL CTxtBreaker::AddBreaker(
	UINT		brkUnit)
{
	BOOL		fr = FALSE;
	CUniscribe* pusp = _ped->Getusp();

	if (pusp && pusp->IsValid())
	{
		// Initialize proper bit mask used to test breaking bits
		if (!_pbrkWord && (brkUnit & BRK_WORD))
		{
			_pbrkWord = new CBreakArray();
			Assert(_pbrkWord);
			if (_pbrkWord)
				fr = TRUE;
		}
		if (!_pbrkChar && (brkUnit & BRK_CLUSTER))
		{
			_pbrkChar = new CBreakArray();
			Assert(_pbrkChar);
			if (_pbrkChar)
				fr = TRUE;
		}
	}
	return fr;
}

// <devnote:> The "cluster" break array actually contains invert logic.
// This is for speed since it's likely to be a sparse array.
CTxtBreaker::CanBreakCp(
	BREAK_UNIT	brk, 	// kind of break
	LONG		cp)		// given cp
{
	Assert (brk != BRK_BOTH);
	if (brk == BRK_WORD && _pbrkWord)
		return _pbrkWord->GetBreak(cp);
	if (brk == BRK_CLUSTER && _pbrkChar)
		return !_pbrkChar->GetBreak(cp);
	return FALSE;
}

void CTxtBreaker::OnPreReplaceRange (
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
/***  Not good idea to check anything in PreReplaceRange before the action is complete.
#ifdef DEBUG

	if (_pbrkWord)
		Assert (_pbrkWord->GetCchBreak() == _ped->GetTextLength());
	if (_pbrkChar)
		Assert (_pbrkChar->GetCchBreak() == _ped->GetTextLength());

#endif
***/
}


// Sync up the breaking result of each available breaker.
void CTxtBreaker::Refresh()
{
	CBreakArray*	pbrk = _pbrkWord;
	LONG			len = _ped->GetTextLength();

	for (int i=0; i<2; i++)
	{
		if (pbrk && pbrk->GetCchBreak())
		{
			// (temporarily) collapse the breaking result
			pbrk->RemoveBreak(0, len);
		}
		pbrk = _pbrkChar;
	}
	// Now announce the new coming text of the whole document.
	// (we recalculate both results at once here since the ScriptBreak returns
	// both kind of information in one call. No need to slow thing down by making 2 calls.)
	OnPostReplaceRange(0, 0, len, 0, 0, NULL);
}

	
// This method gets called once backing store changed.
// Produce correct breaking positions for the text range effected by the change.
//
void CTxtBreaker::OnPostReplaceRange (
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	if (!cchDel && !cchNew)
		return;

#ifdef DEBUG
	LONG	cchbrkw = _pbrkWord ? _pbrkWord->GetCchBreak() : 0;
	LONG	cchbrkc = _pbrkChar ? _pbrkChar->GetCchBreak() : 0;
#endif

	CTxtPtr			tp(_ped, cp);
	LONG			cpBreak = cp > 0 ? cp - 1 : 0;
	CBreakArray*	pSyncObj = NULL;		// Break object to retrieve sync point
	LONG			cBrks = 1, cBrksSave;
	BOOL			fStop = TRUE;			// default: looking for stop
	LONG			cpStart, cpEnd;

	
	// Figure a boundary limited by whitespaces
	tp.FindWhiteSpaceBound(cchNew, cpStart, cpEnd);


	Assert (_pbrkWord || _pbrkChar);

	// Use wordbreak array (if available) to figure sync point, 
	// otherwise use cluster break array
	if (_pbrkWord)
	{
		pSyncObj = _pbrkWord;
		cBrks = CWORD_TILLSYNC;
	}
	else if (_pbrkChar)
	{
		pSyncObj = _pbrkChar;
		cBrks = CCLUSTER_TILLSYNC;
		
		// for perf reason, we kept cluster breaks in invert logic.
		// Logic TRUE in the array means "NOT A CLUSTER BREAK". The array is
		// like a sparse metric full of 0.
		fStop = FALSE;
	}

	// Figure sync point so we can go from there.
	cBrksSave = cBrks;
	while (pSyncObj && cpBreak > cpStart)
	{
		if (pSyncObj->GetBreak(cpBreak) == fStop)
			if (!cBrks--)
				break;
		cpBreak--;
	}

	cpStart = cpBreak;
	tp.SetCp(cpStart);

	cBrks = cBrksSave;

	// adjust the end boundary to the state of break array.
	cpEnd -= cchNew - cchDel;
	cpBreak = cp + cchDel;
	while (pSyncObj && cpBreak < cpEnd)
	{
		if (pSyncObj->GetBreak(cpBreak) == fStop)
			if (!cBrks--)
				break;
		cpBreak++;
	}
	cpEnd = cpBreak;

	// adjust the end boundary back to the state of the backing store.
	cpEnd -= cchDel - cchNew;

	Assert (cpStart >= 0 && cpEnd >= 0 && cpStart <= cpEnd);

	if (cpStart == cpEnd)
	{
		// This is deletion process
		if (_pbrkWord)
			_pbrkWord->ReplaceBreak(cp, cchDel, 0);
		if (_pbrkChar)
			_pbrkChar->ReplaceBreak(cp, cchDel, 0);
	}
	else
	{
		CUniscribe*					pusp;
		const SCRIPT_PROPERTIES*	psp;
		SCRIPT_ITEM*				pi;
		SCRIPT_LOGATTR*				pl;
		PUSP_CLIENT					pc = NULL;
		BYTE						pbBufIn[MAX_CLIENT_BUF];
		WCHAR*						pwchString;
		LONG						cchString = cpEnd - cpStart;
		int							cItems;

		// Now with the minimum range, we begin itemize and break the word/clusters.
		// :The process is per item basis.
	
		// prepare Uniscribe
		pusp = _ped->Getusp();
		if (!pusp)
		{
			// No Uniscribe instance allowed to be created.
			// We failed badly!
			Assert (FALSE);
			return;
		}
	
		// allocate temp buffer for itemization
		pusp->CreateClientStruc(pbBufIn, MAX_CLIENT_BUF, &pc, cchString, cli_Itemize | cli_Break);
		if (!pc)
			// nom!
			return;
	
		Assert (tp.GetCp() == cpStart);
	
		tp.GetText(cchString, pc->si->pwchString);

		if (pusp->ItemizeString (pc, 0, &cItems, pc->si->pwchString, cchString, 0) > 0)
		{
			// Prepare room in the break array(s) to put the break results
			if (_pbrkWord)
				_pbrkWord->ReplaceBreak (cp, cchDel, cchNew);
			if (_pbrkChar)
				_pbrkChar->ReplaceBreak (cp, cchDel, cchNew);
	
			// Initial working pointers
			pi = pc->si->psi;
			pwchString = pc->si->pwchString;
			pl = pc->sb->psla;
	
			for (int i=0; i < cItems; i++)
			{
				psp = pusp->GeteProp(pi[i].a.eScript);
				if (psp->fComplex && 
					(psp->fNeedsWordBreaking || psp->fNeedsCaretInfo))
				{
					// Break only the item needing text break
					if ( ScriptBreak(&pwchString[pi[i].iCharPos], pi[i+1].iCharPos - pi[i].iCharPos, 
									&pi[i].a, pl) != S_OK )
					{
						TRACEWARNSZ ("Calling ScriptBreak FAILED!");
						break;
					}
					// Fill in the breaking result
					cp = cpStart + pi[i].iCharPos;
					for (int j = pi[i+1].iCharPos - pi[i].iCharPos - 1; j >= 0; j--)
					{
						if (_pbrkWord)
							_pbrkWord->SetBreak(cp+j, pl[j].fWordStop);
						if (_pbrkChar)
							_pbrkChar->SetBreak(cp+j, !pl[j].fCharStop);
					}
				}
				else
				{
					// Note: ClearBreak is faster than ZeroMemory the CArray::ArInsert()
					if (_pbrkWord)
						_pbrkWord->ClearBreak(cpStart + pi[i].iCharPos, pi[i+1].iCharPos - pi[i].iCharPos);
					if (_pbrkChar)
						_pbrkChar->ClearBreak(cpStart + pi[i].iCharPos, pi[i+1].iCharPos - pi[i].iCharPos);
				}
			}
		}
	
		if (pc && pbBufIn != (BYTE*)pc)
			delete pc;
	}

#ifdef DEBUG
	if (_pbrkWord)
		Assert (_pbrkWord->GetCchBreak() - cchbrkw == cchNew - cchDel);
	if (_pbrkChar)
		Assert (_pbrkChar->GetCchBreak() - cchbrkc == cchNew - cchDel);
#endif
}

#endif	// !BITVIEW

#endif // NOCOMPLEXSCRIPTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\tomsel.cpp ===
/*
 *	@doc TOM
 *
 *	@module	tomsel.cpp - Implement the CTxtSelection Class |
 *	
 *		This module contains the TOM ITextSelection implementation for
 *		the selection object
 *
 *	History: <nl>
 *		5/24/95 - Alex Gounares: stubs <nl>
 *		8/95	- Murray Sargent: core implementation
 *
 *	@comm
 *		The "cursor-pad" functions (Left, Right, Up, Down, Home, End)
 *		are simple generalizations of the corresponding keystrokes and have
 *		to express the same UI.  Consequently they are typically not as
 *		efficient for moving the cursor around as ITextRange methods, which
 *		are designed for particular purposes.  This is especially true for
 *		counts larger than one.
 *
 *	@devnote
 *		All ITextSelection methods inherited from ITextRange are handled by
 *		the ITextRange methods, since they either don't affect the display of
 *		the selection (e.g., Get methods), or virtual methods are used that
 *		perform the appropriate updating of the selection on screen.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_select.h"
#include "_disp.h"
#include "_edit.h"

#define DEBUG_CLASSNAME CTxtSelection
#include "_invar.h"


//---------------------- CTxtSelection methods	------------------------------------

/*
 *	CTxtSelection::EndKey (Unit, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI End key, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = start of line/document for
 *		Ctrl key not being/being depressed.  Returns *<p pDelta> = count of
 *		characters active end is moved forward, i.e., a number >= 0.
 *
 *	@rdesc
 *		HRESULT =  (invalid Unit) ? E_INVALIDARG :
 *				   (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::EndKey (
	long  	Unit,			//@parm Unit to use
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive count of chars moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::EndKey");

	return Homer(Unit, Extend, pDelta, End);
}

/*
 *	CTxtSelection::GetFlags (pFlags)
 *
 *	@mfunc
 *		Set <p pFlags> = this text selection's flags
 *
 *	@rdesc
 *		HRESULT = (<p pFlags>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtSelection::GetFlags(
	long * pFlags) 		//@parm Out parm to receive selection flags
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::GetFlags");

	if(!pFlags)
		return E_INVALIDARG;

	if(IsZombie())	
	{
		*pFlags = tomSelStartActive | tomSelReplace;
		return CO_E_RELEASED;
	}

	DWORD	dwFlags = _cch <= 0;			// Store tomSelStartActive value

	if(_fCaretNotAtBOL)
		dwFlags |= tomSelAtEOL;

	if(GetPed()->_fOverstrike)
		dwFlags |= tomSelOvertype;

	if(GetPed()->_fFocus)
		dwFlags |= tomSelActive;

	*pFlags = dwFlags | tomSelReplace;		// tomSelReplace isn't optional

	return NOERROR;
}

/*
 *	CTxtSelection::GetSelectionType (pType)
 *
 *	@mfunc
 *		Set *pType = type of this text selection
 *
 *	@rdesc
 *		HRESULT = <p pType> ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtSelection::GetType(
	long * pType) 		//@parm Out parm to receive selection type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::GetSelectionType");

	if(!pType)
		return E_INVALIDARG;

	*pType = !_cch ? tomSelectionIP
		   : (_cch == -1 && _rpTX.GetChar() == WCH_EMBEDDING ||
			  _cch ==  1 && GetPrevChar()   == WCH_EMBEDDING)
		   ? tomSelectionInlineShape : tomSelectionNormal;

	return IsZombie() ? CO_E_RELEASED : NOERROR;
}

/*
 *	CTxtSelection::HomeKey (Unit, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI Home key, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = start of line/document for
 *		Ctrl key not being/being depressed.  Returns *<p pDelta> = count of
 *		characters active end is moved forward, i.e., a number <= 0.
 *
 *	@rdesc
 *		HRESULT =  (invalid Unit) ? E_INVALIDARG :
 *				   (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::HomeKey (
	long  	Unit,			//@parm Unit to use
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive count of chars moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::HomeKey");
	
	return Homer(Unit, Extend, pDelta, Home);
}

/*
 *	CTxtSelection::MoveDown (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI Down arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomLine/tomParagraph for
 *		Ctrl key not being/being depressed. In addition, <p Unit> can equal
 *		tomWindow/tomWindowEnd for the Ctrl key not being/being depressed.
 *		This second pair emulates PgDn behavior.  The method returns
 *		*<p pDelta> = actual count of units moved.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveDown (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveDown");
 	return GeoMover(Unit, Count, Extend, pDelta, 3);
}

/*
 *	CTxtSelection::MoveLeft (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI left arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomChar/tomWord for Ctrl key
 *		not	being/being	depressed.  Returns *<p pDelta> = actual count of
 *		units moved
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveLeft (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveLeft");

	return GeoMover(Unit, Count, Extend, pDelta, 0);
}

/*
 *	CTxtSelection::MoveRight (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI right arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomChar/tomWord for Ctrl key
 *		not	being/being	depressed.  Returns *<p pDelta> = actual count of
 *		units moved
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveRight (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveRight");
	return GeoMover(Unit, Count, Extend, pDelta, 1);
}

/*
 *	CTxtSelection::MoveUp (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI Up arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomLine/tomParagraph for
 *		Ctrl key not being/being depressed. In addition, <p Unit> can equal
 *		tomWindow/tomWindowEnd for the Ctrl key not being/being depressed.
 *		This second pair emulates PgUp behavior.  The method returns
 *		*<p pDelta> = actual count of units moved.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveUp (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveUp");

	return GeoMover(Unit, Count, Extend, pDelta, 2);
}

/*
 *	CTxtSelection::SetFlags (Flags)
 *
 *	@mfunc
 *		Set this text selection's flags = Flags
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		RichEdit ignores tomSelReplace since it's always on
 */
STDMETHODIMP CTxtSelection::SetFlags(
	long Flags) 			//@parm New flag values
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::SetFlags");

	if(IsZombie())	
		return CO_E_RELEASED;

	_fCaretNotAtBOL			= (Flags & tomSelAtEOL) != 0;
	GetPed()->_fOverstrike	= (Flags & tomSelOvertype) != 0;

	if(!(Flags & tomSelStartActive) ^ (_cch > 0))
		FlipRange();

	if((Flags & tomSelActive) && !GetPed()->_fFocus)
		GetPed()->TxSetFocus();

	return NOERROR;
}

/*
 *	CTxtRange::SetPoint (x, y, Extend)
 *
 *	@mfunc
 *		Select text at or up through (depending on <p Extend>) the point
 *		(<p x>, <p y>).
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtSelection::SetPoint (
	long	x,			//@parm Horizontal coord of point to select
	long	y,			//@parm	Vertical   coord of point to select
	long 	Extend) 	//@parm Whether to extend selection to point
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::SelectPoint");

	if(IsZombie())	
		return CO_E_RELEASED;

	CCallMgr	callmgr(GetPed());
	POINT		ptxy = {x, y};
	POINTUV		pt;

	_pdp->PointuvFromPoint(pt, ptxy);

	if(Extend)
		ExtendSelection (pt);
	else
		SetCaret(pt, FALSE);		

	return NOERROR;
}

/*
 *	CTxtSelection::TypeText (bstr)
 *
 *	@mfunc
 *		Type the string given by bstr at this selection as if someone typed it.
 *		This is similar to the underlying ITextRange::SetText() method, but is
 *		sensitive to the Ins/Ovr key state.
 *
 *	@rdesc
 *		HRESULT = !<p bstr> ? E_INVALIDARG :
 *				  (whole string typed) ? NOERROR : S_FALSE
 *	@comm
 *		This is faster than sending chars via SendMessage(), but it's slower
 *		than using ITextRange::SetText()
 */
STDMETHODIMP CTxtSelection::TypeText (
	BSTR bstr)				//@parm String to type into this selection
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::TypeText");

	if(!bstr)
		return E_INVALIDARG;

	if(IsZombie())	
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());

	if(!GetPed()->IsntProtectedOrReadOnly(WM_CHAR, 0, 0))
		return E_ACCESSDENIED;

	CFreezeDisplay	fd(_pdp);
	DWORD			dwFlags = GetPed()->_fOverstrike;
	DWORD			dwFlagsPutChar;
	OLECHAR *		pch	  = bstr;
	IUndoBuilder *	publdr;
	CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);

	if(GetPed()->_fIMEInProgress)					// Suppress autocorrect until last
		dwFlags |= KBD_NOAUTOCORRECT | KBD_CHAR;	//  character during IME

	dwFlagsPutChar = dwFlags;
	for(LONG cch = SysStringLen(bstr); cch > 0; dwFlags = dwFlagsPutChar)
	{
		unsigned ch = *pch++;
		cch--;

		if(IN_RANGE(0xD800, ch, 0xDBFF) && cch && IN_RANGE(0xDC00, *pch, 0xDFFF))
		{
			ch = (*pch++ & 0x3FF) + ((ch & 0x3FF) << 10) + 0x10000;
			cch--;
			dwFlags &= ~KBD_CHAR;		// Need font binding
		}
		else if ((IN_RANGE(0x03400, ch, 0x04DFF) || IN_RANGE(0xE000, ch, 0x0F8FF)))
			dwFlags &= ~KBD_CHAR;		// Need font binding

		if(!cch)						// ch is last character: allow autocorrect
			dwFlags &= ~KBD_NOAUTOCORRECT;
		if(!PutChar(ch, dwFlags, publdr))
			break;
		undobldr.Done();				// Simulate one char input at a time
	}
	return cch ? S_FALSE : NOERROR;
}


//--------------------- ITextSelection PRIVATE helper methods -----------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtSelection::GeoMover (Unit, Count, Extend, pDelta, iDir)
 *
 *	@mfunc
 *		Helper function to move active end <p Count> <p Unit>s geometrically
 *
 *		Extends range if <p Extend> is TRUE; else collapses range to Start if
 *		<p Count> <lt> 0 and to End if <p Count> <gt> 0.
 *
 *		Sets *<p pDelta> = count of Units moved
 *
 *		Used by ITextSelection::Left(), Right(), Up(), and Down()
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : (if Unit supported) ? S_FALSE
 *			: E_NOTIMPL
 */
HRESULT CTxtSelection::GeoMover (
	long  		Unit,		//@parm Unit to use
	long  		Count,		//@parm Number of Units to move
	long 	 	Extend,		//@parm Extend selection or go to IP
	long *	  	pDelta,		//@parm Out parm to receive count of Units moved
	LONG	  	iDir)		//@parm Direction to move in if Count > 0
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtSelection::GeoMover");

	if(pDelta)							// Default no movement
		*pDelta = 0;

	if(IsZombie())	
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());
	LONG	 CountSave = Count;
	LONG	 cp;
	LONG	 cUnit;
	LONG	 iDefUnit = (iDir & 0xfe) == 2 ? tomLine : tomCharacter;
	BOOL	 fCollapse = !Extend && _cch;
	BOOL	 fCtrl	 = Unit != iDefUnit;
	BOOL	 fExtend = Extend != 0;

	if(Count < 0)
	{
		Count = -Count;
		iDir ^= 1;
	}
	
	if(iDefUnit == tomLine)				// Up or Down
	{
		if(Unit == tomPage && GetPed()->IsInPageView())
			Unit = tomScreen;

		if(Unit == tomScreen)
		{
			iDir ^= 6;					// Convert Up/Down to PgUp/PgDn
			fCtrl = FALSE;
		}
		else if(Unit == tomWindow)		// Go to top/bottom of window
		{
			iDir ^= 6;					// Convert Up/Down to PgUp/PgDn
			Count = 1;					// Be sure Count = 1
		}								// Leave fCtrl = 1
		else if(fCtrl && Unit != tomParagraph)
			return E_INVALIDARG;
	}
	else if(fCtrl && Unit != tomWord)
		return E_INVALIDARG;

	for (cUnit = Count; Count; Count--)
	{
		cp = GetCp();					// Save cp for comparison
		switch(iDir)					// iDir bit 0 inc/dec for 1/0
		{								// iDir values are chosen contiguously
		case 0:							//  to encourage compiler to use a
			Left(fCtrl, fExtend);		//  jump table
			break;

		case 1:							// tomCharacter/tomWord OK here
			Right(fCtrl, fExtend);
			break;

		case 2:							// tomLine/tomParagraph OK here
			Up(fCtrl, fExtend);
			break;

		case 3:							// tomLine/tomParagraph OK here
			Down(fCtrl, fExtend);
			break;

		case 4:							// tomWindow/tomScreen OK here
			PageUp(fCtrl, fExtend);
			break;

		case 5:							// tomWindow/tomScreen OK here
			PageDown(fCtrl, fExtend);
		}
		if(cp == GetCp() && !fCollapse)	// Didn't move or collapse
			break;						//  so we're done
		fCollapse = FALSE;				// Collapse counts as a Unit
	}

	cUnit -= Count;						// Count of Units moved
	if(CountSave < 0)
		cUnit = -cUnit;					// Negative Counts get negative results

	if(pDelta)
		*pDelta = cUnit;

	return cUnit ? NOERROR : S_FALSE;
}

/*
 *	CTxtSelection::Homer (Unit, Extend, pDelta, pfn)
 *
 *	@mfunc
 *		Helper function to move active end Home or End depending on pfn
 *
 *		Extends range if <p Extend> is TRUE; else collapses range to Start if
 *		<p Count> <lt> 0 and to End if <p Count> <gt> 0.
 *
 *		Sets *<p pDelta> = count of chars moved	forward
 *
 *		Used by ITextSelection::Home(), End()
 *
 *	@rdesc
 *		HRESULT =  (invalid Unit) ? E_INVALIDARG :
 *				   (if change) ? NOERROR : S_FALSE
 */
HRESULT CTxtSelection::Homer (
	long  	Unit,			//@parm Unit to use
	long 	Extend,			//@parm Extend selection or go to IP
	long *	pDelta,			//@parm Out parm to receive count of Units moved
	BOOL	(CTxtSelection::*pfn)(BOOL, BOOL))	//@parm Direction to move in
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtSelection::Homer");

	if(pDelta)							// Default no movement
		*pDelta = 0;

	if(IsZombie())	
		return CO_E_RELEASED;

	if(Unit != tomLine && Unit != tomStory)
		return E_INVALIDARG;

	CCallMgr callmgr(GetPed());
	LONG	 cch = GetCp();

	(this->*pfn)(Unit != tomLine, Extend != 0);
	cch = GetCp() - cch;
	if(pDelta)
		*pDelta = cch;

	return cch ? NOERROR : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\utilmem.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	utilmem.cpp - Debug memory tracking/allocation routines
 *	
 *	History: <nl>
 *		8/17/99 KeithCu Move to a separate module to prevent errors.
 *
 *	Copyright (c) 1995-1999 Microsoft Corporation. All rights reserved.
 */

#define W32SYS_CPP

#include "_common.h"

#undef PvAlloc
#undef PvReAlloc
#undef FreePv
#undef new


#if defined(DEBUG)

#undef PvSet
#undef ZeroMemory
#undef strcmp

MST vrgmst[100];

typedef struct tagPVH //PV Header
{
	char	*szFile;
	int		line;
	tagPVH	*ppvhNext;
	int		cbAlloc;	//On Win'95, the size returned is not the size allocated.
	int		magicPvh;	//Should be last
} PVH;
#define cbPvh (sizeof(PVH))

typedef struct //PV Tail
{
	int		magicPvt; //Must be first
} PVT;

#define cbPvt (sizeof(PVT))
#define cbPvDebug (cbPvh + cbPvt)

void *vpHead = 0;

/*
 *	UpdateMst(void)
 *
 *	@func Fills up the vrgmst structure with summary information about our memory
 *	usage.
 *
 *	@rdesc
 *		void
 */
void UpdateMst(void)
{
	W32->ZeroMemory(vrgmst, sizeof(vrgmst));

	PVH		*ppvh;
	MST		*pmst;

	ppvh = (PVH*) vpHead;

	while (ppvh != 0)
	{
		pmst = vrgmst;

		//Look for entry in list...
		while (pmst->szFile)
		{
			if (W32->strcmp(pmst->szFile, ppvh->szFile) == 0)
			{
				pmst->cbAlloc += ppvh->cbAlloc;
				break;
			}
			pmst++;
		}

		if (pmst->szFile == 0)
		{
			pmst->szFile = ppvh->szFile;
			pmst->cbAlloc = ppvh->cbAlloc;
		}

		ppvh = ppvh->ppvhNext;
	}
}

/*
 *	PvDebugValidate(void)
 *
 *	@func Verifies the the node is proper.  Pass in a pointer to the users data
 *	(after the header node.)
 *
 *	@rdesc
 *		void
 */
void PvDebugValidate(void *pv)
{
	PVH	*ppvh;
	UNALIGNED PVT *ppvt;

	ppvh = (PVH*) ((char*) pv - cbPvh);
	ppvt = (PVT*) ((char*) pv + ppvh->cbAlloc);

	AssertSz(ppvh->magicPvh == 0x12345678, "PvDebugValidate: header bytes are corrupt");
	AssertSz(ppvt->magicPvt == 0xfedcba98, "PvDebugValidate: tail bytes are corrupt");
}

/*
 *	CW32System::PvSet(pv, szFile, line)
 *
 *	@mfunc Sets a different module and line number for
 *
 *	@rdesc
 *		void
 */
void CW32System::PvSet(void *pv, char *szFile, int line)
{
	if (pv == 0)
		return;

	PvDebugValidate(pv);
	PVH *ppvh = (PVH*) ((char*) pv - cbPvh);

	ppvh->szFile = szFile;
	ppvh->line = line;
}
/*
 *	CW32System::PvAllocDebug(cb, uiMemFlags, szFile, line)
 *
 *	@mfunc Allocates a generic (void*) pointer. This is a debug only routine which
 *	tracks the allocation.
 *
 *	@rdesc
 *		void
 */
void* CW32System::PvAllocDebug(ULONG cb, UINT uiMemFlags, char *szFile, int line)
{
	void	*pv;

	pv = PvAlloc(cb + cbPvDebug, uiMemFlags);
	if (!pv)
		return 0;

	PVH	*ppvh;
	UNALIGNED PVT *ppvt;

	ppvt = (PVT*) ((char*) pv + cb + cbPvh);
	ppvh = (PVH*) pv;

	ZeroMemory(ppvh, sizeof(PVH));
	ppvh->magicPvh = 0x12345678;
	ppvt->magicPvt = 0xfedcba98;
	ppvh->szFile = szFile;
	ppvh->line = line;
	ppvh->cbAlloc = cb;

	ppvh->ppvhNext = (PVH*) vpHead;
	vpHead = pv;

	return (char*) pv + cbPvh;
}

/*
 *	CW32System::PvReAllocDebug(pv, cb, szFile, line)
 *
 *	@mfunc ReAllocates a generic (void*) pointer. This is a debug only routine which
 *	tracks the allocation.
 *
 *	@rdesc
 *		void
 */
void* CW32System::PvReAllocDebug(void *pv, ULONG cb, char *szFile, int line)
{
	void	*pvNew;
	PVH	*ppvh, *ppvhHead, *ppvhTail;
	UNALIGNED PVT *ppvt;
	ppvh = (PVH*) ((char*) pv - cbPvh);

	if (!pv)
		return PvAllocDebug(cb, 0, szFile, line);

	PvDebugValidate(pv);

	pvNew = PvReAlloc((char*) pv - cbPvh, cb + cbPvDebug);

	if (!pvNew)
		return 0;

	ppvt = (PVT*) ((char*) pvNew + cb + cbPvh);
	ppvh = (PVH*) pvNew;
	ppvh->cbAlloc = cb;

	//Put the new trailer bytes in.
	ppvt->magicPvt = 0xfedcba98;

	//Make the pointer list up to date again
	if (pv != pvNew)
	{
		ppvhTail = 0;
		ppvhHead = (PVH*) vpHead;

		while ((char*)ppvhHead != (char*)pv - cbPvh)
		{
			AssertSz(ppvhHead, "entry not found in list.");
			ppvhTail = ppvhHead;
			ppvhHead = (PVH*) ppvhHead->ppvhNext;
		}

		if (ppvhTail == 0)
			vpHead = pvNew;
		else
			ppvhTail->ppvhNext = (PVH*) pvNew;
	}

	return (char*) pvNew + cbPvh;
}

/*
 *	CW32System::FreePvDebug(pv)
 *
 *	@mfunc Returns a pointer when you are done with it.
 *
 *	@rdesc
 *		void
 */
void CW32System::FreePvDebug(void *pv)
{
	if (!pv)
		return;

	PvDebugValidate(pv);

	PVH	*ppvhHead, *ppvhTail, *ppvh;

	AssertSz(vpHead, "Deleting from empty free list.");

	ppvh = (PVH*) ((char*) pv - cbPvh);
	
	//Search and remove the entry from the list
	ppvhTail = 0;
	ppvhHead = (PVH*) vpHead;

	while ((char*) ppvhHead != ((char*) pv - cbPvh))
	{
		AssertSz(ppvhHead, "entry not found in list.");
		ppvhTail = ppvhHead;
		ppvhHead = (PVH*) ppvhHead->ppvhNext;
	}

	if (ppvhTail == 0)
		vpHead = ppvhHead->ppvhNext;
	else
		ppvhTail->ppvhNext = ppvhHead->ppvhNext;

	FreePv((char*) pv - cbPvh);
}

/*
 *	CatchLeaks(void)
 *
 *	@func Displays any memory leaks in a dialog box.
 *
 *	@rdesc
 *		void
 */
void CatchLeaks(void)
{
	PVH		*ppvh;
	char szLeak[512];

	ppvh = (PVH*) vpHead;
	while (ppvh != 0)
	{
#ifndef NOFULLDEBUG
		wsprintfA(szLeak, "Memory Leak of %d bytes: -- File: %s, Line: %d", ppvh->cbAlloc, ppvh->szFile, ppvh->line);
#endif
	    if (NULL != pfnAssert) 
		{
			// if we have an assert hook, give the user a chance to process the leak message
			if (pfnAssert(szLeak, ppvh->szFile, &ppvh->line))
			{
#ifdef NOFULLDEBUG
				DebugBreak();
#else
				// hook returned true, show the message box
				MessageBoxA(NULL, szLeak, "", MB_OK);
#endif
			}
		}
		else
		{
#ifdef NOFULLDEBUG
				DebugBreak();
#else
			MessageBoxA(NULL, szLeak, "", MB_OK);
#endif
		}
		ppvh = ppvh->ppvhNext;
	}
}

void* _cdecl operator new (size_t size, char *szFile, int line)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "new");

	return W32->PvAllocDebug(size, GMEM_ZEROINIT, szFile, line);
}

void _cdecl operator delete (void* pv)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "delete");

	W32->FreePvDebug(pv);
}

#else //DEBUG

void* _cdecl operator new (size_t size)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "new");

	return W32->PvAlloc(size, GMEM_ZEROINIT);
}

void _cdecl operator delete (void* pv)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "delete");

	W32->FreePv(pv);
}


#endif //DEBUG

HANDLE g_hHeap;

/*
 *	PvAlloc (cbBuf, uiMemFlags)
 *
 *	@mfunc	memory allocation.  Similar to GlobalAlloc.
 *
 *	@comm	The only flag of interest is GMEM_ZEROINIT, which
 *			specifies that memory should be zeroed after allocation.
 */
PVOID CW32System::PvAlloc(
	ULONG	cbBuf, 			//@parm	Count of bytes to allocate
	UINT	uiMemFlags)		//@parm Flags controlling allocation
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "PvAlloc");
	if (g_hHeap == 0)
	{
		CLock lock;
		g_hHeap = HeapCreate(0, 0, 0);
	}

	void *pv = HeapAlloc(g_hHeap, (uiMemFlags & GMEM_ZEROINIT) ? HEAP_ZERO_MEMORY : 0, cbBuf);
	
	return pv;
}

/*
 *	PvReAlloc	(pv, cbBuf)
 *
 *	@mfunc	memory reallocation.
 *
 */
PVOID CW32System::PvReAlloc(
	PVOID	pv, 		//@parm Buffer to reallocate
	DWORD	cbBuf)		//@parm New size of buffer
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "PvReAlloc");

	if(pv)
		return HeapReAlloc(g_hHeap, 0, pv, cbBuf);

	return PvAlloc(cbBuf, 0);
}

/*
 *	FreePv (pv)
 *
 *	@mfunc	frees memory
 *
 *	@rdesc	void
 */
void CW32System::FreePv(
	PVOID pv)		//@parm Buffer to free
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "FreePv");

	if(pv)
		HeapFree(g_hHeap, 0, pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\uuid.cpp ===
/*	
 *	UUID.C
 *
 *	Purpose:
 *		provide definitions for locally used GUID's
 *
 *	Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

//set these two GUIDs up for export in our file

#undef IID_RichEditOle
#undef IID_IRichEditOleCallback
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#undef DEFINE_GUID
#undef DEFINE_OLEGUID

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const IID name \
        = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


DEFINE_OLEGUID(IID_IDispatch,				0x00020400, 0, 0);
DEFINE_OLEGUID(IID_IUnknown,				0x00000000, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);
DEFINE_OLEGUID(IID_IViewObject,	 			0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IViewObject2,			0x00000127, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,				0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IOleClientSite, 			0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,				0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,			0x00000119, 0, 0);
DEFINE_OLEGUID(IID_IOleLink,	 			0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,	 			0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleObject, 				0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,			0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,	   	0x00000113, 0, 0);
DEFINE_GUID(IID_IRichEditOle,				0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback,		0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

DEFINE_OLEGUID(CLSID_Picture_EnhMetafile,	0x00000319, 0, 0);
DEFINE_OLEGUID(CLSID_StaticMetafile,		0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_StaticDib,				0x00000316, 0, 0); 			

// REMARK: presumably TOM should have official MS GUIDs
// To make pre-compiled headers work better, we just copy the
// guid definitions here.  Make sure they don't change!

DEFINE_GUID(LIBID_tom,			0x8CC497C9,	0xA1DF,0x11ce,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextDocument,	0x8CC497C0,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextSelection,	0x8CC497C1,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextRange,		0x8CC497C2,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextFont,		0x8CC497C3,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextPara,		0x8CC497C4,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextMsgFilter,	0xA3787420, 0x4267,0x11D1,0x88,0x3A,0x3C,0x8B,
											0x00,0xC1,0x00,0x00);
DEFINE_GUID(IID_ITextDocument2,	0x01C25500,	0x4268,0x11D1,0x88,0x3A,0x3C,0x8B,
											0x00,0xC1,0x00,0x00);

// Accessibility stuff
// We need to define this as EXTERN_C since the DEFINE_GUID macro removes the EXTERN_C
//
EXTERN_C DEFINE_GUID(IID_IAccessible,		0x618736e0, 0x3c3d, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
EXTERN_C DEFINE_GUID(LIBID_Accessibility,	0x1ea4dbf0, 0x3c3b, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);											
EXTERN_C DEFINE_OLEGUID(IID_IEnumVARIANT,	0x00020404, 0x0000, 0x0000);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\usp10.h ===
/*++

   Copyright (c) 1998-1999 Microsoft Corporation.

*/

#ifndef __usp10__
#define __usp10__
#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#ifdef __cplusplus
extern "C" {
#endif


///// Uniscribe build number

#define USPBUILD 0231



/////   USP - Unicode Complex Script processor
//
//      Copyright (c) 1996-9, Microsoft Corporation. All rights reserved.




/////   SCRIPT
//
//      The SCRIPT enum is an opaque type used internally to identify
//      which shaping engine functions are used to process a given run.
//
//
#define SCRIPT_UNDEFINED  0
//
//p     SCRIPT_UNDEFINED: This is the only public script ordinal. May be
//      forced into the eScript field of a SCRIPT_ANALYSIS to disable shaping.
//      SCRIPT_UNDEFINED is supported by all fonts - ScriptShape will display
//      whatever glyph is defined in the font CMAP table, or, if none, the
//      missing glyph.







/////   USP Status Codes
//
#define USP_E_SCRIPT_NOT_IN_FONT   \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x200)    // Script doesn't exist in font






/////   SCRIPT_CACHE
//
//      Many script APIs take a combination of HDC and SCRIPT_CACHE parameter.
//
//      A SCRIPT_CACHE is an opaque pointer to a Uniscribe font metric cache
//      structure.


typedef void *SCRIPT_CACHE;


//      The client must allocate and retain one SCRIPT_CACHE variable for each
//      character style used. It must be initialised by the client to NULL.
//
//      APIs are passed an HDC and the address of a SCRIPT_CACHE variable.
//      Uniscribe will first attempt to access font data via the SCRIPT_CACHE
//      and will only inspect the HDC if the required data is not already
//      cached.
//
//      The HDC may be passed as NULL. If data required by Uniscribe is
//      already cached, the HDC won't be accessed and operation continues
//      normally.
//
//      If the HDC is passed as NULL, and Uniscribe needs to access it for
//      any reason, Uniscribe will return E_PENDING.
//
//      E_PENDING is returned quickly, allowing the client to avoid time
//      consuming SelectObject calls. The following example applies to all
//      APIs that take a SCRIPT_CACHE and an optional HDC.
//
//c     hr = ScriptShape(NULL, &sc, ..);
//c     if (hr == E_PENDING) {
//c         ... select font into hdc ...
//c         hr = ScriptShape(hdc, &sc, ...);
//c     }






/////   ScriptFreeCache
//
//      The client may free a SCRIPT_CACHE at any time. Uniscribe maintains
//      reference counts in it's font and shaper caches, and frees font data
//      only when all sizes of the font are free, and shaper data only when
//      all fonts it supports are freed.
//
//      The client should free the SCRIPT_CACHE for a style when it discards
//      that style.
//
//      ScriptFreeCache always sets it's parameter to NULL to help avoid
//      mis-referencing.


HRESULT WINAPI ScriptFreeCache(
    SCRIPT_CACHE   *psc);       //InOut  Cache handle






/////   SCRIPT_CONTROL
//
//      The SCRIPT_CONTROL structure provides itemization control flags to the
//      ScriptItemize function.
//
//
typedef struct tag_SCRIPT_CONTROL {
    DWORD   uDefaultLanguage    :16; // For NADS, also default for context
    DWORD   fContextDigits      :1;  // Means use previous script instead of uDefaultLanguage

    // The following flags provide legacy support for GetCharacterPlacement features
    DWORD   fInvertPreBoundDir  :1;  // Reading order of virtual item immediately prior to string
    DWORD   fInvertPostBoundDir :1;  // Reading order of virtual item immediately following string
    DWORD   fLinkStringBefore   :1;  // Equivalent to presence of ZWJ before string
    DWORD   fLinkStringAfter    :1;  // Equivalent to presence of ZWJ after string
    DWORD   fNeutralOverride    :1;  // Causes all neutrals to be strong in the current embedding direction
    DWORD   fNumericOverride    :1;  // Causes all numerals to be strong in the current embedding direction
    DWORD   fLegacyBidiClass    :1;  // Causes plus and minus to be reated as neutrals, slash as a common separator
    DWORD   fReserved           :8;
} SCRIPT_CONTROL;
//
//
//p     uDefaultLanguage: Language to use when Unicode values are ambiguous.
//              Used by numeric processing to select digit shape when
//              fDigitSubstitute (see SCRIPT_STATE) is in force.
//
//p     fContextDigits: Specifies that national digits are chosen according to
//              the nearest previous strong text, rather than using
//              uDefaultLanguage.
//
//p     fInvertPreBoundDir: By default text at the start of the string is
//              laid out as if it follows strong text of the same direction
//              as the base embedding level. Set fInvertPreBoundDir to change
//              the initial context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fInvertPostBoundDir: By default text at the end of the string is
//              laid out as if it preceeds strong text of the same direction
//              as the base embedding level. Set fInvertPostBoundDir to change
//              the final context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fLinkStringBefore: Causes the first character of the string to be
//              shaped as if were joined to a previous character.
//
//p     fLinkStringAfter: Causes the last character of the string to be
//              shaped as if were joined to a following character.
//
//p     fNeutralOverride: Causes all neutral characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks neutrals in place,
//              reordering occuring only between neutrals.
//
//p     fNumericOverride: Causes all numeric characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks numerics in place,
//              reordering occuring only between numerics.
//
//p     fReserved: Reserved. Always initialise to 0.






/////   SCRIPT_STATE
//
//      The SCRIPT_STATE structure is used both to initialise the unicode
//      algorithm state as an input parameter to ScriptItemize, and is also
//      a component of each item analysis returned by ScriptItemize.
//
//
typedef struct tag_SCRIPT_STATE {
    WORD    uBidiLevel         :5;  // Unicode Bidi algorithm embedding level (0-16)
    WORD    fOverrideDirection :1;  // Set when in LRO/RLO embedding
    WORD    fInhibitSymSwap    :1;  // Set by U+206A (ISS), cleared by U+206B (ASS)
    WORD    fCharShape         :1;  // Set by U+206D (AAFS), cleared by U+206C (IAFS)
    WORD    fDigitSubstitute   :1;  // Set by U+206E (NADS), cleared by U+206F (NODS)
    WORD    fInhibitLigate     :1;  // Equiv !GCP_Ligate, no Unicode control chars yet
    WORD    fDisplayZWG        :1;  // Equiv GCP_DisplayZWG, no Unicode control characters yet
    WORD    fArabicNumContext  :1;  // For EN->AN Unicode rule
    WORD    fGcpClusters       :1;  // For Generating Backward Compatible GCP Clusters (legacy Apps)
    WORD    fReserved          :1;
    WORD    fEngineReserved    :2;  // For use by shaping engine
} SCRIPT_STATE;
//
//
//p     uBidiLevel: The embedding level associated with all characters in this
//              run according to the Unicode bidi algorithm. When passed to
//              ScriptItemize, should be initialised to 0 for an LTR base
//              embedding level, or 1 for RTL.
//
//p     fOverrideDirection: TRUE if this level is an override level (LRO/RLO).
//              In an override level, characters are layed out purely
//              left to right, or purely right to left. No reordering of digits
//              or strong characters of opposing direction takes place.
//              Note that this initial value is reset by LRE, RLE, LRO or
//              RLO codes in the string.
//
//p     fInhibitSymSwap: TRUE if the shaping engine is to bypass mirroring of
//              Unicode Mirrored glyphs such as brackets. Set by Unicode
//              character ISS, cleared by ASS.
//
//p     fCharShape: TRUE if character codes in the Arabic Presentation Forms
//              areas of Unicode should be shaped. (Not implemented).
//
//p     fDigitSubstitute: TRUE if character codes U+0030 through U+0039
//              (European digits) are to be substituted by national digits.
//              Set by Unicode NADS, Cleared by NODS.
//
//p     fInhibitLigate: TRUE if ligatures are not to be used in the shaping
//              of Arabic or Hebrew characters.
//
//p     fDisplayZWG: TRUE if control characters are to be shaped as
//              representational glyphs. (Normally, control characters are
//              shaped to the blank glyph and given a width of zero).
//
//p     fArabicNumContext: TRUE indicates prior strong characters were Arabic
//              for the purposes of rule P0 on page 3-19 of 'The Unicode
//              Standard, version 2.0'. Should normally be set TRUE before
//              itemizing an RTL paragraph in an Arabic language, FALSE
//              otherwise.
//
//p     fGcpClusters: For GetCharaterPlacement legacy support only.
//              Initialise to TRUE to request ScriptShape to generate
//              the LogClust array the same way as GetCharacterPlacement
//              does in Arabic and Hebrew Windows95. Affects only Arabic
//              and Hebrew items.
//
//p     fReserved: Reserved. Always initialise to 0.
//
//p     fEngineReserved: Reserved. Always initialise to 0.






/////   SCRIPT_ANALYSIS
//
//      Each analysed item is described by a SCRIPT_ANALYSIS structure.
//      It also includes a copy of the Unicode algorithm state (SCRIPT_STATE).
//
//
typedef struct tag_SCRIPT_ANALYSIS {
    WORD    eScript         :10;    // Shaping engine
    WORD    fRTL            :1;     // Rendering direction
    WORD    fLayoutRTL      :1;     // Set for GCP classes ARABIC/HEBREW and LOCALNUMBER
    WORD    fLinkBefore     :1;     // Implies there was a ZWJ before this item
    WORD    fLinkAfter      :1;     // Implies there is a ZWJ following this item.
    WORD    fLogicalOrder   :1;     // Set by client as input to ScriptShape/Place
    WORD    fNoGlyphIndex   :1;     // Generated by ScriptShape/Place - this item does not use glyph indices
    SCRIPT_STATE s;
} SCRIPT_ANALYSIS;
//
//
//p     eScript: Opaque value identifying which engine Uniscribe will use to
//              Shape, Place and TextOut this item. The value of eScript is
//              undefined, and will change in future releases, but attributes
//              of eScript may be obtained by calling ScriptGetProperties.
//
//p     fRTL: Rendering direction. Normally identical to the parity of the
//              Unicode embedding level, but may differ if overridden by
//              GetCharacterPlacement legacy support.
//
//p     fLayoutRTL: Logical direction - whether conceptually part of a
//              left-to-right sequenece or a right-to-left sequence. Although
//              this is usually the same as fRTL, for a number in a
//              right-to-left run, fRTL is False (because digits are always
//              displayed LTR), but fLayoutRTL is True (because the number is
//              read as part of the right-to-left sequence).
//
//p     fLinkBefore: If set, the shaping engine will shape the first character
//              of this item as if it were joining with a previous character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLinkAfter: If set, the shaping engine will shape the last character
//              of this item as if it were joining with a subsequient character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLogicalOrder: If set, the shaping engine will generate all glyph
//              related arrays in logical order. By default glyph related
//              arrays are in visual order, the first array entry corresponding
//              to the leftmost glyph.
//              Set to FALSE by ScriptItemize, may be overriden before calling
//              ScriptShape.
//
//p     fNoGlyphIndex: May be set TRUE on input to ScriptShape to disable use
//              of glyphs for this item. Additionally, ScriptShape will set it
//              TRUE for hdcs containing symbolic, unrecognised and device fonts.
//              Disabling glyphing disables complex script shaping. When set,
//              shaping and placing for this item is implemented directly by
//              calls to GetTextExtentExPoint and ExtTextOut.
/////   SCRIPT_ITEM
//
//      The SCRIPT_ITEM structure includes a SCRIPT_ANALYSIS with the string
//      ofset of the first character of the item.
//
//
typedef struct tag_SCRIPT_ITEM {
    int              iCharPos;      // Logical offset to first character in this item
    SCRIPT_ANALYSIS  a;
} SCRIPT_ITEM;
//
//
//p     iCharPos: Offset from beginning of itemised string to first character
//              of this item, counted in Unicode codepoints (i.e. words).
//
//p     a: Script analysis structure containing analysis specific to this
//              item, to be passed to ScriptShape, ScriptPlace etc.






/////   ScriptItemize - break text into items
//
//      Breaks a run of unicode into individually shapeable items.
//      Items are delimited by
//
//      o Change of shaping engine
//      o Change of direction
//
//      The client may create multiple runs from each item returned by
//      ScriptItemize, but should not combine multiple items into a single run.
//
//      Later the client will call ScriptShape for each run (when measuring or
//      rendering), and must pass the SCRIPT_ANALYSIS that ScriptItemize
//      returned.


HRESULT WINAPI ScriptItemize(
    const WCHAR           *pwcInChars,  // In   Unicode string to be itemized
    int                    cInChars,    // In   Codepoint count to itemize
    int                    cMaxItems,   // In   Max length of itemization array
    const SCRIPT_CONTROL  *psControl,   // In   Analysis control (optional)
    const SCRIPT_STATE    *psState,     // In   Initial bidi algorithm state (optional)
    SCRIPT_ITEM           *pItems,      // Out  Array to receive itemization
    int                   *pcItems);    // Out  Count of items processed (optional)






/////
//
//
//      Returns E_INVALIDARG if pwcInChars == NULL or cInChars == 0
//          or pItems == NULL or cMaxItems < 2.
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxItems) is
//          insufficient. Note that in this case, as in all error cases, no
//          items have been fully processed so no part of the output array
//          contains defined values.
//
//      If psControl and psState are NULL on entry, ScriptItemize
//      breaks the unicode string purely by character code.  If they are all
//      non-null, it performs a full Unicode bidi analysis.
//
//      ScriptItemize always adds a terminal item to the item analysis array
//      (pItems) such that the length of an item at pItem is always available as:
//
//c     pItem[1].iCharPos - pItem[0].iCharPos
//
//      For this reason, it is invalid to call ScriptItemize with a buffer
//      of less than two SCRIPT_ANALYSIS items.
//
//      To perform a correct Unicode Bidi analysis, the SCRIPT_STATE should
//      be initialised according to the paragraph reading order at paragraph
//      start, and ScriptItemize should be passed the whole paragraph.
//
//      fRTL and fNumeric together provide the same classification as
//      the lpClass output from GetCharacterPlacement.
//
//      European digits U+0030 through U+0039 may be rendered as national
//      digits as follows:
//
//t     fDigitSubstitute | FContextDigits | Digit shapes displayed for Unicode U+0030 through U+0039
//t     ---------------- | -------------- | ------------------------------------
//t     False            | Any            | Western (European / American) digits
//t     True             | False          | As specified in SCRIPT_CONTROL.uDefaultLanguage
//t     True             | True           | As prior strong text, defaulting to SCRIPT_CONTROL.uDefaultLanguage
//
//
//      For fContextDigits, any Western digits (U+0030 - U+0039) encountered
//      before the first strongly directed character are substituted by the
//      traditional digits of the SCRIPT_CONTROL.uDefaultLanguage when that
//      language is written in the same direction as SCRIPT_STATE.uBidiLevel.
//
//      Thus, in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage is
//      1 (LANG_ARABIC), then leading Western digits will be substituted by
//      traditional Arabic digits.
//
//      However, also in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage
//      is 0x1e (LANG_THAI), then no substitution occurs on leading Western
//      digits because the Thai language is written left-to-right.
//
//      Following strongly directed characters, digits are substituted
//      by the traditional digits associated with the closest prior strongly
//      directed character.
//
//      The left-to-right mark (LRM) and right-to-left mark (RLM) are strong
//      characters whose language depends on the SCRIPT_CONTROL.uDefaultLangauge.
//
//      If SCRIPT_CONTROL.uDefaultLangauge is a left-to-right langauge, then
//      LRM causes subsequent Western digits to be substituted by the
//      traditional digits associated with that language, while Western
//      digits following RLM are not substituted.
//
//      Conversly, if SCRIPT_CONTROL.uDefaultLangauge is a right-to-left
//      langauge, then Western digits following LRM are not substituted, while
//      Western digits following RLM are substituted by the traditional digits
//      associated with that language.
//
//
//
//      Effect of Unicode control characters on SCRIPT_STATE:
//
//t     SCRIPT_STATE flag | Set by | Cleared by
//t     ----------------- | ------   ----------
//t     fDigitSubstitute  |  NADS  |   NODS
//t     fInhibitSymSwap   |  ISS   |   ASS
//t     fCharShape        |  AAFS  |   IAFS
//
//      SCRIPT_STATE.fArabicNumContext controls the Unicode EN->AN rule.
//      It should normally be initialised to TRUE
//      before itemizing an RTL paragraph in an Arabic language, FALSE
//      otherwise.
/////   ScriptLayout
//
//      The ScriptLayout function converts an array of run embedding levels to
//      a map of visual to logical position, and/or logical to visual position.
//
//      pbLevel must contain the embedding levels for all runs on the line,
//      ordered logically.
//
//      On output, piVisualToLogical[0] is the logical index of the run to
//      display at the far left. Subsequent entries should be displayed
//      progressing from left to right.
//
//      piLogicalToVisual[0] is the relative visual position where the first
//      logical run should be displayed - the leftmost display position being zero.
//
//      The caller may request either piLogicalToVisual or piVisualToLogical
//      or both.
//
//      Note: No other input is required since the embedding levels give all
//      necessary information for layout.


HRESULT WINAPI ScriptLayout(
    int           cRuns,              // In   Number of runs to process
    const BYTE   *pbLevel,            // In   Array of run embedding levels
    int          *piVisualToLogical,  // Out  List of run indices in visual order
    int          *piLogicalToVisual); // Out  List of visual run positions






/////   SCRIPT_JUSTIFY
//
//      The script justification enumeration provides the client with the
//      glyph characteristic information it needs to implement justification.


typedef enum tag_SCRIPT_JUSTIFY {
    SCRIPT_JUSTIFY_NONE           = 0,   // Justification can't be applied at this glyph
    SCRIPT_JUSTIFY_ARABIC_BLANK   = 1,   // This glyph represents a blank in an Arabic run
    SCRIPT_JUSTIFY_CHARACTER      = 2,   // Inter-character justification point follows this glyph
    SCRIPT_JUSTIFY_RESERVED1      = 3,   // Reserved #1
    SCRIPT_JUSTIFY_BLANK          = 4,   // This glyph represents a blank outside an Arabic run
    SCRIPT_JUSTIFY_RESERVED2      = 5,   // Reserved #2
    SCRIPT_JUSTIFY_RESERVED3      = 6,   // Reserved #3
    SCRIPT_JUSTIFY_ARABIC_NORMAL  = 7,   // Normal Middle-Of-Word glyph that connects to the right (begin)
    SCRIPT_JUSTIFY_ARABIC_KASHIDA = 8,   // Kashida(U+640) in middle of word
    SCRIPT_JUSTIFY_ARABIC_ALEF    = 9,   // Final form of Alef-like (U+627, U+625, U+623, U+632)
    SCRIPT_JUSTIFY_ARABIC_HA      = 10,  // Final form of Ha (U+647)
    SCRIPT_JUSTIFY_ARABIC_RA      = 11,  // Final form of Ra (U+631)
    SCRIPT_JUSTIFY_ARABIC_BA      = 12,  // Final form of Ba (U+628)
    SCRIPT_JUSTIFY_ARABIC_BARA    = 13,  // Ligature of alike (U+628,U+631)
    SCRIPT_JUSTIFY_ARABIC_SEEN    = 14,  // Highest priority: Initial shape of Seen(U+633) (end)
    SCRIPT_JUSTIFY_RESERVED4      = 15,  // Reserved #4
} SCRIPT_JUSTIFY;



/////   SCRIPT_VISATTR
//
//      The visual (glyph) attribute buffer generated by ScriptShape
//      identifies clusters and justification points:


typedef struct tag_SCRIPT_VISATTR {
    WORD           uJustification   :4;  // Justification class
    WORD           fClusterStart    :1;  // First glyph of representation of cluster
    WORD           fDiacritic       :1;  // Diacritic
    WORD           fZeroWidth       :1;  // Blank, ZWJ, ZWNJ etc, with no width
    WORD           fReserved        :1;  // General reserved
    WORD           fShapeReserved   :8;  // Reserved for use by shaping engines
} SCRIPT_VISATTR;
//
//
//p     uJustification: Justification class for this glyph. See SCRIPT_JUSTIFY.
//
//p     fClusterStart: Set for the logically first glyph in every cluster,
//          even for clusters containing just one glyph.
//
//p     fDiacritic: Set for glyphs that combine with base characters.
//
//p     fZeroWidth: Set by the shaping engine for some, but not all, zero
//          width characters.


/////   ScriptShape
//
//      The ScriptShape function takes a Unicode run and generates glyphs and
//      visual attributes.
//
//      The number of glyphs generated varies according to the script and the
//      font. Only for simple scripts and fonts does each Unicode code point
//      generates a single glyph.
//
//      There is no limit on the number of glyphs generated by a codepoint.
//      For example, a sophisticated complex script font might choose to
//      constuct characters from components, and so generate many times as
//      many glyphs as characters.
//
//      There are also special cases like invalid character representations,
//      where extra glyphs are added to represent the invalid sequence.
//
//      A reasonable guess might be to provide a glyph buffer 1.5 times the
//      length of the character buffer, plus a 16 glyph fixed addition for
//      rare cases like invalid sequenece representation.
//
//      If ScriptShape returns E_OUTOFMEMORY it will be necessary to recall
//      it, possibly more than once, until a large enough buffer is found.


HRESULT WINAPI ScriptShape(
    HDC                 hdc,            // In    Optional (see under caching)
    SCRIPT_CACHE       *psc,            // InOut Cache handle
    const WCHAR        *pwcChars,       // In    Logical unicode run
    int                 cChars,         // In    Length of unicode run
    int                 cMaxGlyphs,     // In    Max glyphs to generate
    SCRIPT_ANALYSIS    *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    WORD               *pwOutGlyphs,    // Out   Output glyph buffer
    WORD               *pwLogClust,     // Out   Logical clusters
    SCRIPT_VISATTR     *psva,           // Out   Visual glyph attributes
    int                *pcGlyphs);      // Out   Count of glyphs generated






/////
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxGlyphs) is
//          insufficient. Note that in this case, as in all error cases, the
//          content of the output array is undefined.
//
//      Clusters are sequenced uniformly within the run, as are glyphs within
//      the cluster - the fRTL item flag (from ScriptItemize) identifies
//      whether left to right, or right to left.
//
//      ScriptShape may set the fNoGlyphIndex flag in psa if the font or
//      OS cannot support glyph indices.
//
//      If fLogicalOrder is requested in psa, glyphs will be always be
//      generated in the same order as the original Unicode characters.
//
//      If fLogicalOrder is not set, right to left items are generated in
//      reverse order, so ScriptTextOut does not need to reverse them before
//      calling ExtTextOut.
/////   ScriptPlace
//
//      The ScriptPlace function takes the output of a ScriptShape call and
//      generates glyph advance width and 2D offset information.
//
//      The composite ABC width for the whole item identifies how much the
//      glyphs overhang to the left of the start position and to the right of
//      the length implied by the sum of the advance widths.
//
//      The total advance width of the line is exactly abcA + abcB + abcC.
//
//      abcA and abcC are maintained internally by Uniscribe as proportions
//      of the cell height represented in 8 bits and are thus roughly +/- 1%.
//      The total width returned (as the sum of piAdvance, and as the sum of
//      abcA+abcB+abcC) is accurate to the resolution of the TrueType shaping
//      engine.
//
//      All glyph related arrays are in visual order unless the fLogicalOrder
//      flag is set in psa.


#ifndef LSDEFS_DEFINED
typedef struct tagGOFFSET {
    LONG  du;
    LONG  dv;
} GOFFSET;
#endif


HRESULT WINAPI ScriptPlace(
    HDC                     hdc,        // In    Optional (see under caching)
    SCRIPT_CACHE           *psc,        // InOut Cache handle
    const WORD             *pwGlyphs,   // In    Glyph buffer from prior ScriptShape call
    int                     cGlyphs,    // In    Number of glyphs
    const SCRIPT_VISATTR   *psva,       // In    Visual glyph attributes
    SCRIPT_ANALYSIS        *psa,        // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    int                    *piAdvance,  // Out   Advance wdiths
    GOFFSET                *pGoffset,   // Out   x,y offset for combining glyph
    ABC                    *pABC);      // Out   Composite ABC for the whole run (Optional)






/////   ScriptTextOut
//
//      The ScriptTextOut function takes the output of both ScriptShape and
//      ScriptPlace calls and calls the operating system ExtTextOut function
//      appropriately.
//
//      All arrays are in visual order unless the fLogicalOrder flag is set in
//      psa.


HRESULT WINAPI ScriptTextOut(
    const HDC               hdc,        // In     OS handle to device context (required)
    SCRIPT_CACHE           *psc,        // InOut  Cache handle
    int                     x,          // In     x,y position for first glyph
    int                     y,          // In
    UINT                    fuOptions,  // In     ExtTextOut options
    const RECT             *lprc,       // In     optional clipping/opaquing rectangle
    const SCRIPT_ANALYSIS  *psa,        // In     Result of ScriptItemize
    const WCHAR            *pwcReserved,// In     Reserved (requires NULL)
    int                     iReserved,  // In     Reserved (requires 0)
    const WORD             *pwGlyphs,   // In     Glyph buffer from prior ScriptShape call
    int                     cGlyphs,    // In     Number of glyphs
    const int              *piAdvance,  // In     Advance widths from ScriptPlace
    const int              *piJustify,  // In     Justified advance widths (optional)
    const GOFFSET          *pGoffset);  // In     x,y offset for combining glyph






/////
//
//      The caller should normally use SetTextAlign(hdc, TA_RIGHT) before
//      calling ScriptTextOut with an RTL item inlogical order.
//
//      The piJustify array provides requested cell widths for each glyph.
//      When the piJustify width of a glyph differs from the unjustified
//      width (in PiAdvance), space is added to or removed from the glyph
//      cell at it's trailing edge. The glyph is always aligned with the
//      leading edge of it's cell. (This rule applies even in visual order.)
//
//      When a glyph cell is extended the extra space is uaually made up by
//      the addition of white space, however for Arabic scripts, the extra
//      space is made up by one or more kashida glyphs, unless the extra space
//      is insufficient for the shortest kashida glyph in the font. (The
//      width of the shortest kashida is available by calling
//      ScriptGetFontProperties.)
//
//      piJustify should only be passed if re-justification of the string is
//      required. Normally pass NULL to this parameter.
//
//      fuOptions may contain ETO_CLIPPED or ETO_OPAQUE (or neither or both).
//
//      Do not use ScriptTextOut to write to a metafile unless you are sure
//      that the metafile will eventually be played back without any font
//      substitution. ScriptTextOut record glyph numbers in the metafile.
//      Since glyph numbers vary considerably from one font to another
//      such a metafile is unlikely to play back correctly when differant
//      fonts are substituted.
//
//      For example when a metafile is played back at a different scale
//      CreateFont requests recorded in the metafile may resolve to bitmap
//      instead of truetype fonts, or if the metafile is played back on
//      a different machine requested fonts may not be installed.//
//
//      To write complex scripts in a metafile in a font independant manner,
//      use ExtTextOut to write the logical characters directly, so that
//      glyph generation and placement does not occur until the text is
//      played back.
/////   ScriptJustify
//
//      ScriptJustify provides a simple minded implementation of multilingual
//      justification.
//
//      Sophisticated text formatters may prefer to generate their own delta
//      dx array by combining their own features with the information returned
//      by ScriptShape in the SCRIPT_VISATTR array.
//
//      ScriptJustify establishes how much adjustment to make at each glyph
//      position on the line. It interprets the SCRIPT_VISATTR array generated
//      by a call to ScriptShape, and gives top priority to kashida, then uses
//      inter word spacing if there's no kashida points, then uses
//      intercharacter spacing if there are no inter-word points.
//
//      The justified advance widths generated in ScriptJustify should be
//      passed to ScriptTextOut in the piJustify paramter.
//
//      ScriptJustify creates a justify array containing updated advance
//      widths for each glyph. Where a glyphs advance width is increased, it
//      is expected that the extra width will be rendered to the right of the
//      glyph, with as white space or, for Arabic text, as kashida.
/////
HRESULT WINAPI ScriptJustify(
    const SCRIPT_VISATTR  *psva,        // In   Collected visual attributes for entire line
    const int             *piAdvance,   // In   Advance widths from ScriptPlace
    int                    cGlyphs,     // In   Size of all arrays
    int                    iDx,         // In   Desired width change, either increase or descrease
    int                    iMinKashida, // In   Minimum length of continuous kashida glyph to generate
    int                   *piJustify);  // Out  Updated advance widths to pass to ScriptTextOut






/////   SCRIPT_LOGATTR
//
//      The SCRIPT_LOGATTR structure describes attributes of logical
//      characters useful when editing and formatting text.
//
//
typedef struct tag_SCRIPT_LOGATTR {
    BYTE    fSoftBreak      :1;     // Potential linebreak point
    BYTE    fWhiteSpace     :1;     // A unicode whitespace character, except NBSP, ZWNBSP
    BYTE    fCharStop       :1;     // Valid cursor position (for left/right arrow)
    BYTE    fWordStop       :1;     // Valid cursor position (for ctrl + left/right arrow)
    BYTE    fInvalid        :1;     // Invalid character sequence
    BYTE    fReserved       :3;
} SCRIPT_LOGATTR;
//
//
//p     fSoftBreak: It would be valid to break the line in front of this
//              character. This flag is set on the first character of
//              South-East Asian words.
//
//p     fWhiteSpace: This character is one of the many Unicode character
//              that are classified as breakable whitespace.
//
//p     fCharStop: Valid cursor position. Set on most characters, but not
//              on codepoints inside Indian and South East Asian character
//              clusters. May be used to implement left and right arrow
//              operation in editors.
//
//p     fWordStop: Valid position following word advance/retire commonly
//              implemented at ctrl/left-arrow and ctrl/right-arrow.
//              May be used to implement ctrl+left and ctrl+right arrow
//              operation in editors.
//
//p     fInvalid: Marks characters which form an invalid or undisplayable
//              combination. Scripts which can set this flag have the flag
//              fInvalidLogAttr set in their SCRIPT_PROPERTIES.






/////   ScriptBreak
//
//      The ScriptBreak function returns cursor movement and formatting break
//      positions for an item as an array of SCRIPT_LOGATTRs. To support
//      mixed formatting within a single word correctly, ScriptBreak should
//      be passed whole items as returned by ScriptItemize.
//
//      ScriptBreak does not require an hdc and does not execute glyph shaping.
//
//      The fCharStop flag marks cluster boundaries for those scripts where
//      it is conventional to restrict from moving inside clusters. The same
//      boundaries could also be inferred by inspecting the pLogCLust array
//      returned by ScriptShape, however ScriptBreak is considerably faster in
//      implementation and does not require an hdc to be prepared.
//
//      The fWordStop, fSoftBreak and fWhiteSpace flags are only available
//      through ScriptBreak.
//
//      Most shaping engines that identify invalid sequences do so by setting
//      the fInvalid flag in ScriptBreak. The fInvalidLogAttr flag in
//      ScriptProperties identifies which scripts do this.


HRESULT WINAPI ScriptBreak(
    const WCHAR            *pwcChars,  // In   Logical unicode item
    int                     cChars,    // In   Length of unicode item
    const SCRIPT_ANALYSIS  *psa,       // In   Result of earlier ScriptItemize call
    SCRIPT_LOGATTR         *psla);     // Out  Logical character attributes






/////   ScriptCPtoX
//
//      The ScriptCPtoX function returns the x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to either the leading
//      or the trailing edge of a logical character cluster.
//
//      iCP is the offset of any logical character in the cluster.
//
//      For scripts where the caret may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned X may be
//      an interpolated position for any codepoint in the line.
//
//      For scripts where the caret is conventionally snapped to the boundaries
//      of clusters, (e.g. Thai, Indian), the resulting X position will be
//      snapped to the requested edge of the cluster containing CP.


HRESULT WINAPI ScriptCPtoX(
    int                     iCP,        // In   Logical character position in run
    BOOL                    fTrailing,  // In   Which edge (default - leading)
    int                     cChars,     // In   Count of logical codepoints in run
    int                     cGlyphs,    // In   Count of glyphs in run
    const WORD             *pwLogClust, // In   Logical clusters
    const SCRIPT_VISATTR   *psva,       // In   Visual glyph attributes array
    const int              *piAdvance,  // In   Advance widths
    const SCRIPT_ANALYSIS  *psa,        // In   Script analysis from item attributes
    int                    *piX);       // Out  Resulting X position






/////   ScriptXtoCP
//
//      The ScriptXtoCP function converts an x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to a logical
//      character position and a flag that indicates whether the X position
//      fell in the leading or the trailing half of the character.
//
//      For scripts where the cursor may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned CP may be
//      for any codepoint in the line, and fTrailing will be either zero
//      or one.
//
//      For scripts where the cursor is conventionally snapped to the
//      boundaries of a cluster, the returned CP is always the position of
//      the logically first codepoint in a cluster, and fTrailing is either
//      zero, or the number of codepoints in the cluster.
//
//      Thus the appropriate cursor position for a mouse hit is always the
//      returned CP plus the value of fTrailing.
//
//      If the X positition passed is not in the item at all, the resulting
//      position will be the trailing edge of character -1 (for X positions
//      before the item), or the leading edge of character 'cChars' (for
//      X positions following the item).


HRESULT WINAPI ScriptXtoCP(
    int                     iX,             // In   X offset from left of run
    int                     cChars,         // In   Count of logical codepoints in run
    int                     cGlyphs,        // In   Count of glyphs in run
    const WORD             *pwLogClust,     // In   Logical clusters
    const SCRIPT_VISATTR   *psva,           // In   Visual glyph attributes
    const int              *piAdvance,      // In   Advance widths
    const SCRIPT_ANALYSIS  *psa,            // In   Script analysis from item attributes
    int                    *piCP,           // Out  Resulting character position
    int                    *piTrailing);    // Out  Leading or trailing half flag






/////   Relationship between caret positions, justifications points and clusters
//
//
//t     Job                              | Uniscribe support
//t     -------------------------------- | --------------------------------------------------------
//t     Caret move by character cluster  | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Line breaking between characters | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Caret move by word               | LOGATTR.fWordStop
//t     Line breaking between words      | LOGATTR.fWordStop
//t     Justification                    | VISATTR.uJustification
//
//
//
/////   Character clusters
//
//      Character clusters are glyph sequences that cannot be split between
//      lines.
//
//      Some languages (e.g. Thai, Indic) restrict caret placement to points
//      betwen clusters. This applies both to keyboard initiated caret
//      movement (e.g. cursor keys) and pointing and clicking with the mouse
//      (hit testing).
//
//      Uniscribe provides cluster information in both the visual and logical
//      attributes. If you've called ScriptShape you'll find the cluster
//      information represented both by sequences of the same value in the
//      pwLogClust array, and by the fClusterStart flag in the psva
//      SCRIPT_VISATTR array.
//
//      ScriptBreak also returns the fCharStop flag in the SCRIPT_LOGATTR
//      array to identify cluster positions.
//
//
//
/////   Word break points
//
//      Valid positions for moving the caret when moving in whole words are
//      marked by the fWordStop flag returned by ScriptBreak.
//
//      Valid positions for breaking lines between words are marked by the
//      fSoftBreak flag returned by ScriptBreak.
//
//
//
/////   Justification
//
//      Justification space or kashida should be inserted where identified by
//      the uJustificaion field of the SCRIPT_VISATTR.
//
//      When performing inter-character justification, insert extra space
//      only after glyphs marked with uJustify == SCRIPT_JUSTIFY_CHARACTER.
//
//
//
/////   Script specific processing
//
//      Uniscribe provides information about special processing for each
//      script in the SCRIPT_PROPERTIES array.
//
//      Use the following code during initialisation to get a pointer to
//      the SCRIPT_PROPERTIES array:
//
//c     const SCRIPT_PROPERTIES **g_ppScriptProperties; // Array of pointers to properties
//c     int iMaxScript;
//c     HRESULT hr;
//
//c     hr = ScriptGetProperties(&g_ppScriptProperties, &g_iMaxScript);
//
//      Then inspect the properties of the script of an item 'iItem' as follows:
//
//c     hr = ScriptItemize( ... , pItems, ... );
//c     ...
//c     if (g_ppScriptProperties[pItems[iItem].a.eScript]->fNeedsCaretInfo) {
//c         // Use ScriptBreak to restrict the caret from entering clusters (for example).
//c     }
//
//
//      SCRIPT_PROPERTIES.fNeedsCaretInfo
//
//      Caret placement should be restricted to cluster
//      edges for scripts such as Thai and Indian. The fNeedsCaretInfo flag
//      in SCRIPT_PROPERTIES identifies such languages.
//
//      Note that ScriptXtoCP and ScriptCPtoX automatically apply caret
//      placement restictions.
//
//
//      SCRIPT_PROPERTIES.fNeedsWordBreaking
//
//      For most scripts, word break placement  may be
//      identified by scanning for characters marked as fWhiteSpace in
//      SCRIPT_LOGATTR, or for glyphs marked as uJustify ==
//      SCRIPT_JUSTIFY_BLANK or SCRIPT_JUSTIFY_ARABIC_BLANK in SCRIPT_VISATTR.
//
//      For languages such as Thai, it is also necessary to call ScriptBreak,
//      and include character positions marked as fWordStop in SCRIPT_LOGATTR.
//      Such scripts are marked as fNeedsWordbreaking in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fNeedsCharacterJustify
//
//      Languages such as Thai also require inter-character spacing when
//      justifying (where uJustify == SCRIPT_JUSTIFY_CHARACTER in the
//      SCRIPT_VISATTR). Such languages are marked as fNeedsCharacterJustify
//      in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fAmbiguousCharSet
//
//      Many Uniscribe scripts do not correspond directly to 8 bit character
//      sets. For example Unicode characters in the range U+100 through U+024F
//      represent extended latin shapes used for many languages, including
//      those supported by EASTEUROPE_CHARSET, TURKISH_CHARSET and
//      VIETNAMESE_CHARSET. However many of these characters are supported by
//      more han one of thsese charsets.
//      fAmbiguousCharset is set for any script token which could contain
//      characters from a number of these charsets. In these cases the bCharSet
//      field may contain ANSI_CHARSET or DEFAULT_CHARSET. The Uniscribe client
//      will generally need to apply futher processing to determine which charset
//      to use when requesting a font suitable for this run. For example it
//      determine that the run consists of multiple languages and split it up
//      to use a different font for each language.






/////   Notes on ScriptXtoCP and ScriptCPtoX
//
//      Both functions work only within runs and require the results of a
//      previous ScriptShape call.
//
//      The client must establish which run a given cursor offset or x
//      position is within before passing it to ScriptCPtoX or ScriptXtoCP.
//
//      Cluster information in the logical cluster array is used to share
//      the width of a cluster of glyphs equally among the logical characters
//      they represent.
//
//      For example, the lam alif glyph is divided into four areas: the
//      leading half of the lam, the trailing half of the lam, the leading
//      half of the alif and the trailing half of the alif.
//
//      ScriptXtoCP Understands the caret position conventions of each script.
//      For Indian and Thai, caret positions are snapped to cluster boundaries,
//      for Arabic and Hebrew, caret positions are interpolated within clusters.
//
//
/////   Translating mouse hit 'x' offset to caret position
//
//      Conventionally, caret position 'cp' may be selected by clicking either
//      on the trailing half of character 'cp-1' or on the leading half of
//      character 'cp'. This may easily be implemented as follows:
//
//c     int iCharPos;
//c     int iCaretPos
//c     int fTrailing;
//
//c     ScriptXtoCP(iMouseX, ..., &iCharPos, &fTrailing);
//c     iCaretPos = iCharPos + fTrailing;
//
//      For scripts that snap the caret to cluster boundaries, ScriptXtoCP
//      returns ftrailing set to either 0, or the width of the cluster in
//      codepoints. Thus the above code correctly returns only valid
//      caret positions.
//
//
/////   Displaying the caret in bidi strings
//
//      In unidirectional text, the leading edge of a character is at the same
//      place as the trailing edge of the previous character, so there is no
//      ambiguity in placing the caret between characters.
//
//      In bidirectional text, the caret position between runs of opposing
//      direction may be ambiguous.
//
//      For example in the left to right paragraph 'helloMAALAS', the last
//      letter of 'hello' immediately preceeds the first letter of 'salaam'.
//      The best position to display the caret depends on whether it is
//      considered to follow the 'o' of 'hello', or to preceed the 's' of
//      'salaam'.
//
/////   Commonly used caret positioning conventions
//
//t     Situation       | Visual caret placement
//t     ---------       | -------------------------------------------
//t     Typing          | Trailing edge of last character typed
//t     Pasting         | Trailing edge of last character pasted
//t     Caret advancing | Trailing edge of last character passed over
//t     Caret retiring  | Leading edge of last character passed over
//t     Home            | Leading edge of line
//t     End             | Trailing edge of line
//
//      The caret may be positioned as follows:
//
//c     if (advancing) {
//c         ScriptCPtoX(iCharPos-1, TRUE, ..., &iCaretX);
//c     } else {
//c         ScriptCPtoX(iCharPos, FALSE, ..., &iCaretX);
//c     }
//
//      Or, more simply, given an fAdvancing BOOL restricted to TRUE or FALSE:
//
//c     ScriptCPtoX(iCharPos-fAdvancing, fAdvancing, ..., &iCaretX);
//
//      ScriptCPtoX handles out of range positions logically: it returns the
//      leading edge of the run for iCharPos <0, and the trailing edge of the
//      run for iCharPos >=length.
/////   ScriptGetLogicalWidths
//
//      Converts visual withs in piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Ligature glyphs widths are divided evenly amongst the characters
//      they represent.


HRESULT WINAPI ScriptGetLogicalWidths(
    const SCRIPT_ANALYSIS  *psa,            // In   Script analysis from item attributes
    int                     cChars,         // In   Count of logical codepoints in run
    int                     cGlyphs,        // In   Count of glyphs in run
    const int              *piGlyphWidth,   // In   Advance widths
    const WORD             *pwLogClust,     // In   Logical clusters
    const SCRIPT_VISATTR   *psva,           // In   Visual glyph attributes
    int                    *piDx);          // Out  Logical widths






/////
//      ScriptGetLogicalWidths is useful for recording widths in a
//      font independant manner. By passing the recorded logical widths
//      to ScriptApplyLogicalWidths, a block of text can be replayed in the
//      same boundaries with acceptable loss of quality even when the original
//      font is not available.
/////   ScriptApplyLogicalWidth
//
//      Accepts an array of advance widths in logical order, corresponding
//      one to one with codepoints, and generates an array of glyph widths
//      suitable for passing to the piJustify parameter of ScriptTextOut.
//
//      ScriptApplyLogicalWidth may be used to reapply logical widths
//      obtained with ScriptGetLogicalWidths. It may be useful in situations
//      such as metafiling, where it is necessary to record and reapply
//      advance width information in a font independant manner.



HRESULT WINAPI ScriptApplyLogicalWidth(
    const int              *piDx,        // In     Logical dx array to apply
    int                     cChars,      // In     Count of logical codepoints in run
    int                     cGlyphs,     // In     Glyph count
    const WORD             *pwLogClust,  // In     Logical clusters
    const SCRIPT_VISATTR   *psva,        // In     Visual attributes from ScriptShape/Place
    const int              *piAdvance,   // In     Glyph advance widths from ScriptPlace
    const SCRIPT_ANALYSIS  *psa,         // In     Script analysis from item attributes
    ABC                    *pABC,        // InOut  Updated item ABC width (optional)
    int                    *piJustify);  // Out    Resulting glyph advance widths for ScriptTextOut






/////
//p     piDx: Pointer to an array of dx widths in logical order, one per codepoint.
//
//p     cChars: Count of the logical codepoints in the run.
//
//p     cGlyphs: Glyph count.
//
//p     pwLogClust: Pointer to an array of logical clusters from ScriptShape
//
//p     psva: Pointer to an array of visual attributes from ScriptShape and
//          updated by ScriptPlace.
//
//p     piAdvance: Pointer to an array of glyph advance widths from ScriptPlace.
//
//p     psa: Pointer to a SCRIPT_ANALYSIS structure from ScriptItemize and
//          updated by ScriptShape and SriptPlace..
//
//p     pABC: Pointer to the run overall ABC width (optional). If present,
//          when the function is called, it should contain the run ABC width
//          returned by ScriptPlace; when the function returns, the ABC width
//          has been updated to match the new widths.
//
//p     piJustify:Pointer to an array of the resulting glyph advance widths.
//          This is suitable for passing to the piJustify parameter of ScriptTextOut.
/////   ScriptGetCMap
//
//      ScriptGetCMap may be used to determine which characters in a run
//      are supported by the selected font.
//
//      It returns glyph indices of Unicode characters according to Truetype
//      Cmap table, or standard Cmap implemented for old style fonts. The
//      glyph indices are returned in the same order as the input string.
//
//      The caller may scan the returned glyph buffer looking for the default
//      glyph to determine which characters are not available. (The default
//      glyph index for the selected font should be determined by calling
//      ScriptGetFontProperties).
//
//      The return value indicates the presence of any missing glyphs.


#define SGCM_RTL  0x00000001      // Return mirrored glyph for mirrorable Unicode codepoints


HRESULT WINAPI ScriptGetCMap(
    HDC             hdc,            // In    Optional (see notes on caching)
    SCRIPT_CACHE   *psc,            // InOut Address of Cache handle
    const WCHAR    *pwcInChars,     // In    Unicode codepoint(s) to look up
    int             cChars,         // In    Number of characters
    DWORD           dwFlags,        // In    Flags such as SGCM_RTL
    WORD           *pwOutGlyphs);   // Out   Array of glyphs, one per input character






/////
//  returns S_OK     - All unicode codepoints were present in the font
//          S_FALSE  - Some of the Unicode codepoints were mapped to the default glyph
//          E_HANDLE - font or system does not support glyph indices
/////   ScriptGetGlyphABCWidth
//
//      Returns ABC width of a given glyph.
//      May be useful for drawing glyph charts. Should not be used for
//      run of the mill complex script text formatting.


HRESULT WINAPI ScriptGetGlyphABCWidth(
    HDC             hdc,            // In    Optional (see notes on caching)
    SCRIPT_CACHE   *psc,            // InOut Address of Cache handle
    WORD            wGlyph,         // In    Glyph
    ABC            *pABC);          // Out   ABC width






/////
//  returns S_OK     - Glyph width returned
//          E_HANDLE - font or system does not support glyph indices
/////   SCRIPT_PROPERTIES
//
typedef struct {
    DWORD   langid                 :16; // Primary and sublanguage associated with script
    DWORD   fNumeric               :1;
    DWORD   fComplex               :1;  // Script requires special shaping or layout
    DWORD   fNeedsWordBreaking     :1;  // Requires ScriptBreak for word breaking information
    DWORD   fNeedsCaretInfo        :1;  // Requires caret restriction to cluster boundaries
    DWORD   bCharSet               :8;  // Charset to use when creating font
    DWORD   fControl               :1;  // Contains only control characters
    DWORD   fPrivateUseArea        :1;  // This item is from the Unicode range U+E000 through U+F8FF
    DWORD   fNeedsCharacterJustify :1;  // Requires inter-character justification
    DWORD   fInvalidGlyph          :1;  // Invalid combinations generate glyph wgInvalid in the glyph buffer
    DWORD   fInvalidLogAttr        :1;  // Invalid combinations are marked by fInvalid in the logical attributes
    DWORD   fCDM                   :1;  // Contains Combining Diacritical Marks
    DWORD   fAmbiguousCharSet      :1;  // Script does not correspond 1:1 with a charset
    DWORD   fClusterSizeVaries     :1;  // Measured cluster width depends on adjacent clusters
    DWORD   fRejectInvalid         :1;  // Invalid combinations should be rejected
} SCRIPT_PROPERTIES;
//
//p     langid: Language associated with this script. When a script is used for many languages,
//          langid id represents a default language. For example, Western script is represented
//          by LANG_ENGLISH although it is also used for French, German, Spanish etc.
//
//p     fNumeric: Script contains numerics and characters used in conjunction with numerics
//          by the rules of the Unicode bidirectional algorithm. For example
//          dollar sign and period are classified as numeric when adjacent to or in between
//          digits.
//
//p     fComplex: Indicates a script that requires complex script handling. If fComplex is false
//          the script contains no combining characters and requires no contextual shaping or reordering.
//
//p     fNeedsWordBreaking: A script, such as Thai, which requires algorithmic wordbreaking.
//          Use ScriptBreak to obtain a wordbreak points using the standard system wordbreaker.
//
//p     fNeedsCaretInfo: A script, such as Thai and Indian, where the caret may not be placed
//          inside a cluster. To determine valid caret positions inspect the fCharStop flag in the
//          logical attributes returned by ScriptBreak, or compare adjacent values in the pwLogClust
//          array returned by ScriptShape.
//
//p     bCharSet: Nominal charset associated with script. May be used in a logfont when creating
//          a font suitable for displaying this script. Note that for new scripts where there
//          is no charset defined, bCharSet may be innapropriate and DEFAULT_CHARSET should
//          be used instead - see the description of fAmbiguousCharSet below.
//
//p     fControl: contains control characters.
//
//p     fPrivateUseArea: The Unicode range U+E000 through U+F8FF.
//
//p     fNeedsCharacterJustify: A script, such as Thai, where justification is conventionally
//          achieved by increasing the space between all letters, not just between words.
//
//p     fInvalidGlyph: A script for which ScriptShape generates an invalid glyph
//          to represent invalid sequences. The glyph index of the invalid glyph for
//          a particular font may be obtained by calling ScriptGetFontProperties.
//
//p     fInvalidLogAttr: A script for which ScriptBreak sets the fInvalid flag
//          in the logical attributes to mark invalid sequences.
//
//p     fCDM: Implies that an item analysed by ScriptItemize included combining
//          diacritical marks (U+0300 through U+36F).
//
//p     fAmbiguousCharSet: No single legacy charset supports this script.
//          For example the extended Latin Extended-A Unicode range includes
//          characters from the EASTUROPE_CHARSET, the TURKISH_CHARSET and the
//          BALTIC_CHARSET. It also contains characters that are not available
//          in any legacy charset. Use DEFAULT_CHARSET when creating fonts to
//          display parts of this run.
//
//p     fClusterSizeVaries: A script, such as Arabic, where contextual shaping
//          may cause a string to increase in size when removing characters.
//
//p     fRejectInvalid: A script, such as Thai, where invalid sequences conventionally
//          cause an editor such as notepad to beep, and ignore keypresses.


/////   ScriptGetProperties
//
//      ScriptGetProperties returns the address of a table that maps a
//      script in a SCRIPT_ANALYSIS uScript field to properties including
//      the primary language associated with that script, whether it's
//      numeric and whether it's complex.


HRESULT WINAPI ScriptGetProperties(
    const SCRIPT_PROPERTIES ***ppSp,             // Out  Receives pointer to table of pointers to properties indexed by script
    int                       *piNumScripts);    // Out  Receives number of scripts (valid values are 0 through NumScripts-1)






/////   SCRIPT_FONTPROPERTIES
//
typedef struct {
    int     cBytes;         // Structure length
    WORD    wgBlank;        // Blank glyph
    WORD    wgDefault;      // Glyph used for Unicode values not present in the font
    WORD    wgInvalid;      // Glyph used for invalid character combinations (especially in Thai)
    WORD    wgKashida;      // Shortest continuous kashida glyph in the font, -1 if doesn't exist
    int     iKashidaWidth;  // Widths of shortest continuous kashida glyph in the font
} SCRIPT_FONTPROPERTIES;


/////   ScriptGetFontProperties
//
//      Returns information from the font cache


HRESULT WINAPI ScriptGetFontProperties(
    HDC                     hdc,    // In    Optional (see notes on caching)
    SCRIPT_CACHE           *psc,    // InOut Address of Cache handle
    SCRIPT_FONTPROPERTIES  *sfp);   // Out   Receives properties for this font






/////   ScriptCacheGetHeight
//
//


HRESULT WINAPI ScriptCacheGetHeight(
    HDC            hdc,         // In    Optional (see notes on caching)
    SCRIPT_CACHE  *psc,         // InOut Address of Cache handle
    long          *tmHeight);   // Out   Receives font height in pixels






/////   ScriptStringAnalyse
//
//
#define SSA_PASSWORD         0x00000001  // Input string contains a single character to be duplicated iLength times
#define SSA_TAB              0x00000002  // Expand tabs
#define SSA_CLIP             0x00000004  // Clip string at iReqWidth
#define SSA_FIT              0x00000008  // Justify string to iReqWidth
#define SSA_DZWG             0x00000010  // Provide representation glyphs for control characters
#define SSA_FALLBACK         0x00000020  // Use fallback fonts
#define SSA_BREAK            0x00000040  // Return break flags (character and word stops)
#define SSA_GLYPHS           0x00000080  // Generate glyphs, positions and attributes
#define SSA_RTL              0x00000100  // Base embedding level 1
#define SSA_GCP              0x00000200  // Return missing glyphs and LogCLust with GetCharacterPlacement conventions
#define SSA_HOTKEY           0x00000400  // Replace '&' with underline on subsequent codepoint
#define SSA_METAFILE         0x00000800  // Write items with ExtTextOutW Unicode calls, not glyphs
#define SSA_LINK             0x00001000  // Apply FE font linking/association to non-complex text
#define SSA_HIDEHOTKEY       0x00002000  // Remove first '&' from displayed string
#define SSA_HOTKEYONLY       0x00002400  // Display underline only.

#define SSA_LPKANSIFALLBACK  0x08000000  // Internal - enable FallBack for all LPK Ansi calls Except BiDi hDC calls
#define SSA_PIDX             0x10000000  // Internal
#define SSA_LAYOUTRTL        0x20000000  // Internal - Used when DC is mirrored
#define SSA_DONTGLYPH        0x40000000  // Internal - Used only by GDI during metafiling - Use ExtTextOutA for positioning
#define SSA_NOKASHIDA        0x80000000  // Internal - Used by GCP to justify the non Arabic glyphs only.




/////   SCRIPT_TABDEF
//
//      Defines tabstop positions for ScriptStringAnalyse (ignored unless SSA_TAB passed)
//
typedef struct tag_SCRIPT_TABDEF {
    int   cTabStops;        // Number of entries in pTabStops array
    int   iScale;           // Scale factor for pTabStops (see below)
    int  *pTabStops;        // Pointer to array of one or more tab stops
    int   iTabOrigin;       // Initial offset for tab stops (logical units)
} SCRIPT_TABDEF;
//
//
//p     cTabStops: Number of entries in the pTabStops array. If zero, tabstops
//          are every 8 average character widths. If one, all tabstops are
//          the length of the first entry in pTabStops. If more than one,
//          the first cTabStops are as specified in the pTabStops array,
//          subsequent tabstops are every 8 average characters from the last
//          tabstop in the array.
//
//p     iScale: Scale factor for iTabOrigin and pTabStops entries. Values are
//          converted to device coordinates by multiplying by iScale then
//          dividing by 4. If values are already in device units, set iScale to
//          4. If values are in dialog units, set iScale to the average char
//          width of the dialog font. If values are multiples of the average
//          character width for the selected font, set iScale to 0.
//
//p     pTabStops: Array of cTabStops entries. Each entry specifies a
//          tabstop position. Positive values give nearedge alignment,
//          negative values give faredge alignment.
//
//p     iTabOrigin: Tabs are considered to start iTabOrigin before the
//          beginning of the string. Helps with multiple tabbed
//          outputs on the same line.






/////   ScriptStringAnalyse
//
//      cString - Input string must contain at least one character
//
//      hdc - required if SSA_GLYPH requested. Optional for SSA_BREAK.
//      If present the current font in the hdc is inspected and if a symbolic
//      font the character string is treated as a single neutral SCRIPT_UNDEFINED item.
//
//      Note that the uBidiLevel field in the initial SCRIPT_STATE value
//      is ignored - the uBidiLevel used is derived from the SSA_RTL
//      flag in combination with the layout of the hdc.


typedef void* SCRIPT_STRING_ANALYSIS;


HRESULT WINAPI ScriptStringAnalyse(
    HDC                      hdc,       //In  Device context (required)
    const void              *pString,   //In  String in 8 or 16 bit characters
    int                      cString,   //In  Length in characters (Must be at least 1)
    int                      cGlyphs,   //In  Required glyph buffer size (default cString*1.5 + 16)
    int                      iCharset,  //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD                    dwFlags,   //In  Analysis required
    int                      iReqWidth, //In  Required width for fit and/or clip
    SCRIPT_CONTROL          *psControl, //In  Analysis control (optional)
    SCRIPT_STATE            *psState,   //In  Analysis initial state (optional)
    const int               *piDx,      //In  Requested logical dx array
    SCRIPT_TABDEF           *pTabdef,   //In  Tab positions (optional)
    const BYTE              *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)

    SCRIPT_STRING_ANALYSIS  *pssa);     //Out Analysis of string






/////   ScriptStringFree - free a string analysis
//
//


HRESULT WINAPI ScriptStringFree(
    SCRIPT_STRING_ANALYSIS *pssa);  //InOut Address of pointer to analysis






/////   ScriptStringSize
//
//      returns a pointer to the size (width and height) of an analysed string
//
//      Note that the SIZE pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const SIZE* WINAPI ScriptString_pSize(
    SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pcOutChars
//
//      returns pointer to length of string after clipping (requires SSA_CLIP set)
//
//      Note that the int pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const int* WINAPI ScriptString_pcOutChars(
    SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pLogAttr
//
//      returns pointer to logical attributes buffer in a SCRIPT_STRING_ANALYSIS
//
//      Note that the buffer pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.
//
//      The logical attribute array contains *ScriptString_pcOutChars(ssa)
//      entries.


const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttr(
    SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptStringGetOrder
//
//      Creates an array mapping original character position to glyph position.
//
//      Treats clusters as they were in legacy systems - Unless a cluster
//      contains more glyphs than codepoints, each glyph is referenced at
//      least once from the puOrder array.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The puOrder parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


HRESULT WINAPI ScriptStringGetOrder(
    SCRIPT_STRING_ANALYSIS  ssa,
    UINT                    *puOrder); 






/////   ScriptStringCPtoX
//
//      Return x coordinate for leading or trailing edge of character icp.


HRESULT WINAPI ScriptStringCPtoX(
    SCRIPT_STRING_ANALYSIS  ssa,        //In  String analysis
    int                     icp,        //In  Caret character position
    BOOL                    fTrailing,  //In  Which edge of icp
    int                    *pX);        //Out Corresponding x offset






/////   ScriptStringXtoCP
//
//


HRESULT WINAPI ScriptStringXtoCP(
    SCRIPT_STRING_ANALYSIS  ssa,            // In
    int                     iX,             // In
    int                    *piCh,           // Out
    int                    *piTrailing);    // Out






/////   ScriptStringGetLogicalWidths
//
//      Converts visual withs in psa->piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The piDx parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


HRESULT WINAPI ScriptStringGetLogicalWidths(
    SCRIPT_STRING_ANALYSIS  ssa,
    int                    *piDx); 






/////   ScriptStringValidate
//
//      Scans the string analysis for invalid glyphs.
//
//      Only glyphs generated by scripts that can generate invalid glyphs
//      are scanned.
//
//      returns S_OK    - no invalid glyphs are present
//              S_FALSE - one or more invalid glyphs are present


HRESULT WINAPI ScriptStringValidate(
    SCRIPT_STRING_ANALYSIS ssa); 






/////   ScriptStringOut
//
//      Displays the string generated by a prior ScriptStringAnalyze call,
//      then optionally adds highlighting corresponding to a logical selection.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.


HRESULT WINAPI ScriptStringOut(
    SCRIPT_STRING_ANALYSIS ssa,         //In  Analysis with glyphs
    int              iX,                //In
    int              iY,                //In
    UINT             uOptions,          //In  ExtTextOut options
    const RECT      *prc,               //In  Clipping rectangle (iff ETO_CLIPPED)
    int              iMinSel,           //In  Logical selection. Set iMinSel>=iMaxSel for no selection
    int              iMaxSel,           //In
    BOOL             fDisabled);        //In  If disabled, only the background is highlighted.






/////
//      uOptions may nclude only ETO_CLIPPED or ETO_OPAQUE.
/////   ScriptIsComplex
//
//      Determines whether a Unicode string requires complex script processing
//
//      The dwFlags parameter may include the following requests
//
#define SIC_COMPLEX     1   // Treat complex script letters as complex
#define SIC_ASCIIDIGIT  2   // Treat digits U+0030 through U+0039 as complex
#define SIC_NEUTRAL     4   // Treat neutrals as complex
//
//      SIC_COMPLEX: Should normally set. Causes complex script letters to
//      be treated as complex.
//
//      SIC_ASCIIDIGIT: Set this flag if the string would be displayed with
//      digit substitution enabled. If you are following the users NLS
//      settings using the ScriptRecordDigitSubstitution API, you can pass
//      scriptDigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE.
//
//      SIC_NEUTRAL: Set this flag if you may be displaying the string with
//      right-to-left reading order. When this flag is set, neutral characters
//      are considered as complex.
//
//
//      Returns S_OK     if string requires complex script processing,
//              S_FALSE  if string contains only characters laid out side by
//                       side from left to right.


HRESULT WINAPI ScriptIsComplex(
    const WCHAR     *pwcInChars,        //In  String to be tested
    int              cInChars,          //In  Length in characters
    DWORD            dwFlags);          //In  Flags (see above)






/////   ScriptRecordDigitSubstitution
//
//      Reads NLS native digit and digit substitution settings and records
//      them in the SCRIPT_DIGITSUBSTITUTE structure.
//
//
typedef struct tag_SCRIPT_DIGITSUBSTITUTE {
    DWORD  NationalDigitLanguage    :16;   // Language for native substitution
    DWORD  TraditionalDigitLanguage :16;   // Language for traditional substitution
    DWORD  DigitSubstitute          :8;    // Substitution type
    DWORD  dwReserved;                     // Reserved
} SCRIPT_DIGITSUBSTITUTE;
//
//
//p     NationalDigitLanguage: Standard digits for the selected locale as
//          defined by the countries/regions standard setting authority.
//
//p     TraditionalDigitLangauge: Digits originally used with the locales
//          script.
//
//p     DigitSubstitute: Selects between None, Context, National and
//          Traditional. See ScriptApplyDigitSubstitution below for
//          constant definitions.
//
//      Although most complex scripts have their own associated digits, many
//      countries/regions using those scripts use western (so called
//      'Arabic') digits as their standard. NationalDigitLanguage reflects the
//      digits used as standard, and is set from
//      the NLS data for the locale.
//      On Windows 2000 the national digit langauge can be
//      adjusted to any digit script with the control panel/regional
//      options/numbers/Standard digits listbox.
//
//      The TraditionalDigitLanguage for a locale is derived directly from the
//      script used by that locale.


HRESULT WINAPI ScriptRecordDigitSubstitution(
    LCID                     Locale,    // In   LOCALE_USER_DEFAULT or desired locale
    SCRIPT_DIGITSUBSTITUTE  *psds);     // Out  Digit substitution settings






/////
//p     Locale: NLS locale to be queried. Should usually be set to
//          LOCALE_USER_DEFAULT. Alternatively may be passed as a locale
//          combined with LOCALE_NOUSEROVERRIDE to obtain default settings
//          for a given locale. Note that context digit substitution is
//          supported only in ARABIC and FARSI locales. In other locales,
//          context digit is mapped to no substitution.
//
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE. This structure may be passed
//          later to ScriptApplyDigitSubstitution.
//
//p     returns: E_INVALIDARG if Locale is invalid or not installed. E_POINTER
//          if psds is NULL. Otherwise S_OK.
//
//      For performance reasons, you should not call
//      ScriptRecordDigitSubstitution frequently. In particular it would be a
//      considerable overhead to call it every time you call ScriptItemize
//      or ScriptStringAnalyse.
//
//      Instead, you may choose to save the SCRIPT_DIGITSUBSTITUTE
//      structure, and update it only when you receive a
//      WM_SETTINGCHANGE message or when a RegNotifyChangeKeyValue
//      call in a dedicated thread indicates a change in the registry
//      under HKCU\Control Panel\\International.
//
//      The normal way to call this function is simply
//
//c     SCRIPT_DIGITSUBSTITUTE sds;
//c     ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &sds);
//
//      Then every time you itemize, you'd use the results like this:
//
//c     SCRIPT_CONTROL  sc = {0};
//c     SCRIPT_STATE    ss = {0};
//
//c     ScriptApplyDigitSubstitution(&sds, &sc, &ss);
//
//
/////   ScriptApplyDigitSubstitution
//
//      Aplies the digit substitution settings recorded in a
//      SCRIPT_DIGIT_SUBSTITUTE structure to the SCRIPT_CONTROL and
//      SCRIPT_STATE structures.
//
//      The DigitSubstitute field of the SCRIPT_DIGITSUBSTITUTE structure
//      is normally set by ScriptRecordDigitSubstitution, however it may
//      be replaced by any one of the following values:
//
//
#define SCRIPT_DIGITSUBSTITUTE_CONTEXT      0  // Substitute to match preceeding letters
#define SCRIPT_DIGITSUBSTITUTE_NONE         1  // No substitution
#define SCRIPT_DIGITSUBSTITUTE_NATIONAL     2  // Substitute with official national digits
#define SCRIPT_DIGITSUBSTITUTE_TRADITIONAL  3  // Substitute with traditional digits of the locale
//
//
//p     SCRIPT_DIGITSUBSTITUTE_CONTEXT: Digits U+0030 - U+0039 will be
//          substituted according to the language of prior letters. Before
//          any letters, digits will be substituted according to the
//          TraditionalDigitLangauge field of the SCRIPT_DIGIT_SUBSTITUTE
//          structure. This field is normally set to the primary language of
//          the Locale passed to ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_NONE: Digits will not be substituted. Unicode
//          values U+0030 to U+0039 will be displayed with Arabic (i.e.
//          Western) numerals.
//
//p     SCRIPT_DIGITSUBSTITUTE_NATIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the NationalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the national digits returned for the NLS LCTYPE
//          LOCALE_SNATIVEDIGITS by ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_TRADITIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the TraditionalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the primary language of the Locale passed to
//          ScriptRecordDigitSubstitution.


HRESULT WINAPI ScriptApplyDigitSubstitution(
    const SCRIPT_DIGITSUBSTITUTE  *psds,   // In   Digit substitution settings
    SCRIPT_CONTROL                *psc,    // Out  Script control structure
    SCRIPT_STATE                  *pss);   // Out  Script state structure






/////
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE structure recorded earlier.
//          If NULL, ScriptApplyDigitSubstitution calls
//          ScriptRecordDigitSubstitution with LOCALE_USER_DEFAULT.
//
//p     psc: SCRIPT_CONTROL structure. The fContextDigits and uDefaultLanguage
//          fields will be updated.
//
//p     pss: SCRIPT_CONTROL structure. The fDigitSubstitute field will be
//          updated.
//
//p     returns: E_INVALIDARG if the DigitSubstitute field of the
//          SCRIPT_DIGITSUBSTITUTE structure is unrecognised, else S_OK;
#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\uspi.cpp ===
/*
 *		Uniscribe interface (& related classes) class implementation
 *		
 *		File:    uspi.cpp
 * 		Create:  Jan 10, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

#ifndef NOCOMPLEXSCRIPTS

#include "_font.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_select.h"
#include "_measure.h"
#include "_uspi.h"

CUniscribe* 	g_pusp = NULL;
int				g_cMaxScript = 0x100;


// initial dummy script properties (= SCRIPT_UNDEFINED)
static const SCRIPT_PROPERTIES 	g_propUndef 	= { LANG_NEUTRAL, FALSE, FALSE, FALSE, FALSE, 0 };
static const SCRIPT_PROPERTIES*	g_pPropUndef[1]	= { &g_propUndef };

CUniscribe::CUniscribe ()
{
	// Initialize digit substitution info
	ApplyDigitSubstitution(W32->GetDigitSubstitutionMode());

	// Get maximum number of scripts supported
	ScriptGetProperties(NULL, &g_cMaxScript);
}

// Test the OS if it does any complex script.
// REVIEW (keithcu) What if it only supports indic, but not the other ones?
BOOL IsSupportedOS()
{
	BOOL	fSupport = !OnWin95FE();
	int		rguCodePage[] = {1255, 1256, 874};
	BYTE	rgbch[] = {0xe0, 0xd3, 0xa1};
	WCHAR	rgwch[] = {0x05d0, 0x0633, 0x0e01};
	WCHAR	wch;
	int	   	i = 0;

	if (fSupport)
	{
		for (;i < 3; i++)
		{
			if (MBTWC(rguCodePage[i], 0, (LPCSTR)&rgbch[i], 1, (LPWSTR)&wch, 1, NULL) > 0 &&
				wch == rgwch[i])
				break;			// support either Arabic, Hebrew or Thai
		}
	}
	return fSupport && i < 3;
}

// Prepare information for digit substitution
// return: Native digit script (shapine engine) ID.
//
WORD CUniscribe::ApplyDigitSubstitution(BYTE bDigitSubstMode)
{
	_wesNationalDigit = 0;

	// Remember national digits script ID if substitution mode is not None
	if (bDigitSubstMode != DIGITS_NOTIMPL && bDigitSubstMode != DIGITS_NONE)
	{
		WCHAR			chZero = 0x0030;
		int				cItems;
		SCRIPT_ITEM		si[2];
		SCRIPT_CONTROL	sc = {0};
		SCRIPT_STATE	ss = {0};

		// force national digit mode
		sc.uDefaultLanguage   = GetNationalDigitLanguage(GetThreadLocale());
		ss.fDigitSubstitute   = TRUE;
		sc.fContextDigits     = FALSE;

		if (SUCCEEDED(ScriptItemize(&chZero, 1, 2, &sc, &ss, (SCRIPT_ITEM*)&si, (int*)&cItems)))
			_wesNationalDigit = si[0].a.eScript;
	}
	return _wesNationalDigit;
}


// Some locales may have its own traditional (native) digit and national standard digit
// recognised by a standard body and adopted by NLSAPI. The example is that Nepali(India)
// has its own digit but the India standard uses Hindi digit as the national digit.
//
DWORD CUniscribe::GetNationalDigitLanguage(LCID lcid)
{
	DWORD	dwDigitLang = PRIMARYLANGID(LANGIDFROMLCID(lcid));

	if (W32->OnWinNT5())
	{
		WCHAR	rgwstrDigit[20];

		if (GetLocaleInfoW(lcid, LOCALE_SNATIVEDIGITS, rgwstrDigit, ARRAY_SIZE(rgwstrDigit)))
		{
			// Steal this from Uniscribe (build 0231)

			switch (rgwstrDigit[1])
			{
				case 0x0661: dwDigitLang = LANG_ARABIC;    break;
				case 0x06F1: dwDigitLang = LANG_FARSI;     break;
				case 0x0e51: dwDigitLang = LANG_THAI;      break;
				case 0x0967: dwDigitLang = LANG_HINDI;     break;
				case 0x09e7: dwDigitLang = LANG_BENGALI;   break;
				case 0x0a67: dwDigitLang = LANG_PUNJABI;   break;
				case 0x0ae7: dwDigitLang = LANG_GUJARATI;  break;
				case 0x0b67: dwDigitLang = LANG_ORIYA;     break;
				case 0x0be7: dwDigitLang = LANG_TAMIL;     break;
				case 0x0c67: dwDigitLang = LANG_TELUGU;    break;
				case 0x0ce7: dwDigitLang = LANG_KANNADA;   break;
				case 0x0d67: dwDigitLang = LANG_MALAYALAM; break;
				case 0x0f21: dwDigitLang = LANG_TIBETAN;   break;
				case 0x0ed1: dwDigitLang = LANG_LAO;       break;
			}
		}
	}

	return dwDigitLang;
}


CUniscribe::~CUniscribe ()
{
	if (_pFSM)
	{
		delete _pFSM;
	}
}


/***** High level services *****/


// Tokenize string and run Unicode Bidi algorithm if requested.
// return : =<0 - error
//			>0  - number of complex script tokens
//
int CUniscribe::ItemizeString (
	USP_CLIENT* pc,					// in: Working structure
	WORD		uInitLevel,			// in: Initial Bidi level
	int*        pcItems,			// out: Count of items generated
	WCHAR*		pwchString,			// in: Input string
	int			cch,				// in: Number of character to itemize
	BOOL        fUnicodeBiDi,		// in: TRUE - Use UnicodeBidi
	WORD		wLangId)			// in: (optional) Dominant language preference
{
	Assert (pc && pc->si && pcItems && pwchString && cch > 0 && cch <= pc->si->cchString);

	USP_CLIENT_SI*  pc_si = pc->si;
	SCRIPT_ITEM*    psi = pc_si->psi;
	SCRIPT_CONTROL	sc = {0};
	SCRIPT_STATE	ss = {0};
	SCRIPT_CONTROL*	psc;
	SCRIPT_STATE*	pss;
	HRESULT         hr;
	int             cItems = 0;

	if (fUnicodeBiDi)
	{
		psc = &sc;
		pss = &ss;

		if (wLangId == LANG_NEUTRAL)
			wLangId = PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale()));

		// (preitemize:) set up initial state
		psc->uDefaultLanguage = wLangId;
		// Classify + - and / in Win9x legacy manner
		psc->fLegacyBidiClass = TRUE;

		// For Arabic Office's compatibility.
		// We enable fArabicNumContext if the dominant language is Arabic.
		//
		if (psc->uDefaultLanguage == LANG_ARABIC)
			pss->fArabicNumContext = uInitLevel & 1;

		pss->uBidiLevel         = uInitLevel;
		// Leave digit substitution to None since we do it ourself.
		// pss->fDigitSubstitute   = FALSE;
		// psc->fContextDigits     = FALSE;
	}
	else
	{
		psc = NULL;
		pss = NULL;
	}

	// begin real work
	hr = ScriptItemize(pwchString, cch, cch+1, psc, pss, psi, (int*)&cItems);

	return SUCCEEDED(hr) ? *pcItems = cItems : 0;
}


// Produce a shaped string (glyph array), taking care of font association and measurer's CF update
//
// Success can require 3 calls to Shape():
// 1. Returns E_PENDING (script cache doesn't contain the glyphing information)
// 2. Return USP_E_SCRIPT_NOT_IN_FONT --the HFONT doesn't contain the script needed to do the glyphing
// 3. Hopefully success, but may return again if the fallback font doesn't exist, but we quit anyway.
int CUniscribe::ShapeString (
	PLSRUN					plsrun,		// in: The first run to be shaped
	SCRIPT_ANALYSIS*        psa, 		// in: Analysis of the run to be shaped
	CMeasurer*              pme, 		// in: Measurer points to start cp of the run
	const WCHAR*            pwch, 		// in: String to be shaped
	int                     cch,		// in: Count of chars
	WORD*&                  pwgi, 		// out: Reference to glyph indices array
	WORD*                   pwlc, 		// out: Logical cluster array
	SCRIPT_VISATTR*&        psva)		// out: Reference to glyph's attribute array
{
	AssertSz (plsrun && psa && pme && pwch, "ShapeString failed: Invalid params");

	HRESULT     hr = S_OK;
	HRESULT		hrLastError = S_OK;
	HDC         hdc = NULL;
	HFONT		hOrgFont = NULL;
	int         cGlyphs;
	int			cchAdd = 0;
	CCcs	    *pccsSave = pme->Check_pccs();
	int			nAttempt = 8;	// Maximum attempt to realloc glyph buffer to shape a string

	// make sure that we have proper font cache ready to use
	if (!pme->_pccs)
		return 0;
	
	if (psa->fNoGlyphIndex)
		// If no glyph processing, hdc must be around.
        hdc = PrepareShapeDC(plsrun, pme, E_PENDING, hOrgFont);

	// prepare glyph buffer
	if (!CacheAllocGlyphBuffers(cch, cGlyphs, pwgi, psva))
		return 0;

	do
	{
		hr = ScriptShape(hdc, &pme->_pccs->_sc, pwch, cch, cGlyphs, psa, pwgi, pwlc, psva, &cGlyphs);

		if (SUCCEEDED(hr))
			break;

		// Error handling...

		switch (hr)
		{
			case E_PENDING:
			case USP_E_SCRIPT_NOT_IN_FONT:

				if (hr == hrLastError)
					nAttempt = 0;		// We encounter the same error twice.
				else
				{
					hdc = PrepareShapeDC(plsrun, pme, hr, hOrgFont);
					hrLastError = hr;
				}
				break;

			case E_OUTOFMEMORY:

				// (#6773)Indic shaping engine could produce glyphs more than we could hold.
				//
				cchAdd += 16;
				if (CacheAllocGlyphBuffers(cch + cchAdd, cGlyphs, pwgi, psva))
				{
					nAttempt--;
					break;
				}
				
			default:
				nAttempt = 0;
				//AssertSz(FALSE, "Shaping fails with invalid error or we run out of memory.");
				break;
		}

	} while (nAttempt > 0);


	// restore hdc's original font
	if (hdc && hOrgFont)
		SelectObject(hdc, hOrgFont);

	if (pme->_pccs != pccsSave)
		plsrun->SetFallback(SUCCEEDED(hr));

	return SUCCEEDED(hr) ? cGlyphs : 0;
}

// Place a string and take care of font association and measurer's CF update
//
// This is called right after ShapeString.
int CUniscribe::PlaceString(
	PLSRUN					plsrun,		// in: The first run to be shaped
	SCRIPT_ANALYSIS*        psa, 		// in: Analysis of the run to be shaped
	CMeasurer*              pme,        // in: Measurer points to start cp of the run
	const WORD*             pcwgi,      // in: Glyph indices array
	int                     cgi,		// in: Count of input glyphs
	const SCRIPT_VISATTR*   psva, 		// in: Glyph's attribute array
	int*                    pgdx,		// out: Glyph's advanced width array
	GOFFSET*                pgduv,		// out: Glyph's offset array
	ABC*                    pABC)       // out: Run's dimension
{
	AssertSz (plsrun && psa && pme && pcwgi, "PlaceString failed: Invalid params");

	HRESULT     hr = S_OK;
	HRESULT		hrLastError = S_OK;
	HDC         hdc = NULL;
	HFONT		hOrgFont = NULL;
	int			nAttempt = 1;

	pme->Check_pccs();
	pme->ApplyFontCache(plsrun->IsFallback(), plsrun->_a.eScript);

	// make sure that we have proper font cache ready to use
	if (!pme->_pccs)
		return 0;

	if (psa->fNoGlyphIndex)
		// If no glyph processing, hdc must be around.
        hdc = PrepareShapeDC(plsrun, pme, E_PENDING, hOrgFont);

	do
	{
		hr = ScriptPlace(hdc, &pme->_pccs->_sc, pcwgi, cgi, psva, psa, pgdx, pgduv, pABC);

		if (SUCCEEDED(hr))
			break;

		// Error handling...

		switch (hr)
		{
			case E_PENDING:

				if (hr == hrLastError)
					nAttempt = 0;		// We encounter the same error twice.
				else
				{
					hdc = PrepareShapeDC(plsrun, pme, hr, hOrgFont);
					hrLastError = hr;
				}
				break;

			default:
				nAttempt = 0;
				//AssertSz(FALSE, "Placing fails with invalid error.");
				break;
		}

	} while (nAttempt > 0);


	// restore hdc's original font
	if (hdc && hOrgFont)
		SelectObject(hdc, hOrgFont);

	return SUCCEEDED(hr) ? cgi : 0;
}

// Placing given string results in logical width array,
// the result array would be used to record WMF metafile.
//
int CUniscribe::PlaceMetafileString (
	PLSRUN					plsrun,		// in: The first run to be shaped
	CMeasurer*              pme,        // in: Measurer points to start cp of the run
	const WCHAR*			pwch,		// in: Input codepoint string
	int						cch,		// in: Character count
	PINT*					ppiDx)		// out: Pointer to logical widths array
{
	AssertSz (pme && pwch && ppiDx, "PlaceMetafileString failed: Invalid params");

	if (W32->OnWinNT4() || W32->OnWin9xThai())
	{
		// MET NT40 has bug in lpdx justification so i doesnt playback the lpdx very nicely.
		// Thai Win9x simply cannot handle fancy lpdx values generated by Uniscribe.
		// We workaround both cases here by metafiling no lpdx and let the system reconstructs
		// it from scratch during playback time.

		// =FUTURE= If we do line justification. We need more sophisticated work here
		// basically to reconstruct the OS preferred type of lpdx.
		//
		*ppiDx = NULL;
		return cch;
	}

	HRESULT     	hr = E_FAIL;
	PUSP_CLIENT		pc = NULL;
	int*			piLogDx;		// logical width array
	int*			piVisDx;		// visual width array
	GOFFSET*		pGoffset;		// glyph offset array
	WORD*			pwgi;			// glyph array
	SCRIPT_VISATTR*	psva;			// glyph properties array
	int				cgi = 0;
	BYTE			pbBufIn[MAX_CLIENT_BUF];
	SCRIPT_ANALYSIS	sa = plsrun->_a;
	BOOL			fVisualGlyphDx = sa.fRTL && W32->OnWin9x() && W32->OnBiDiOS();


	CreateClientStruc(pbBufIn, MAX_CLIENT_BUF, &pc, cch, cli_pcluster);
	if (!pc)
		return 0;

	PUSP_CLIENT_SSP	pcssp = pc->ssp;
		
	if (fVisualGlyphDx)
		sa.fLogicalOrder = FALSE;	// shaping result in visual order

	// Shape string
	if (cgi = ShapeString(plsrun, &sa, pme, pwch, (int)cch, pwgi, pcssp->pcluster, psva))
	{
		// Get static buffer for logical and visual width arrays
		//
		if ( (piLogDx = GetWidthBuffer(cgi + cch)) &&
			 (pGoffset = GetGoffsetBuffer(cgi)) )
		{
			piVisDx		= &piLogDx[cch];
	
			// then place it...
			if (cgi == PlaceString(plsrun, &sa, pme, pwgi, cgi, psva, piVisDx, pGoffset, NULL))
			{
				if (fVisualGlyphDx)
				{
					// Workaround BiDi Win9x's lpdx handling
					// It assumes ExtTextOut's dx array is glyph width in visual order
	
					Assert (cgi <= cch); // glyph count never exceeds character count in BiDi
					CopyMemory (piLogDx, piVisDx, min(cgi, cch)*sizeof(int));
				}
				else
				{
					// Map visual glyph widths to logical widths
					hr = ScriptGetLogicalWidths(&sa, cch, cgi, piVisDx, pcssp->pcluster, psva, piLogDx);
				}
			}

			// result
			*ppiDx = piLogDx;
		}
	}

	if (pc && pbBufIn != (BYTE*)pc)
		FreePv(pc);

	return SUCCEEDED(hr) ? cgi : 0;
}



/***** Helper functions *****/


// Retrieve the BidiLevel FSM
const CBiDiFSM* CUniscribe::GetFSM ()
{
	if (!_pFSM)
	{
		_pFSM = new CBiDiFSM(this);
		if (_pFSM && !_pFSM->Init())
		{
			delete _pFSM;
		}
	}
	return _pFSM;
}


// Prepare the shapeable font ready to dc for a given script
//
// USP_E_SCRIPT_NOT_IN_FONT - complex scripts font association
// E_PENDING 				- prepare dc with current font selected
//
HDC CUniscribe::PrepareShapeDC (
	PLSRUN			plsrun,		// in: The first run to be shaped
    CMeasurer*		pme,        // in: Measurer points to start cp of the run
    HRESULT			hrReq,      // in: Error code to react
	HFONT&			hOrgFont)	// in/out: Original font of the shape DC
{
    Assert (pme);
	
	HDC		hdc = NULL;
	HFONT	hOldFont;

	switch (hrReq)
	{
		case USP_E_SCRIPT_NOT_IN_FONT:
			{
				pme->ApplyFontCache(fTrue, plsrun->_a.eScript);
#ifdef DEBUG
				if (pme->_pccs)
					Tracef(TRCSEVWARN, "USP_E_SCRIPT_NOT_IN_FONT: charset %d applied", pme->_pccs->_bCharSet);
#endif
			}
			
		default:
			if (pme->_pccs)
			{
				hdc = pme->_pccs->_hdc;
				hOldFont = (HFONT)SelectObject(hdc, pme->_pccs->_hfont);

				if (!hOrgFont)
					hOrgFont = hOldFont;
			}
	}

    return hdc;
}

const SCRIPT_PROPERTIES* CUniscribe::GeteProp (WORD eScript)
{
	if (!_ppProp)
	{
		if (!SUCCEEDED(ScriptGetProperties(&_ppProp, NULL)) || !_ppProp)
			_ppProp = g_pPropUndef;
	}
	if (_ppProp == g_pPropUndef || eScript >= (WORD)g_cMaxScript)
		eScript = 0;

	return _ppProp[eScript];
}

// Figure proper charset to use for complex script.
// The resulted charset can be either actual or virtual (internal) GDI charset used by given script
BOOL CUniscribe::GetComplexCharRep(
	const SCRIPT_PROPERTIES* 	psp,				// Uniscribe script's properties 			
	BYTE						iCharRepDefault,	// -1 format's charset
	BYTE&						iCharRepOut)		// out: Charset to use
{
	Assert(psp);

	BYTE	iCharRep = !psp->fCDM
					 ? CharRepFromCharSet(psp->bCharSet)
					 : GetCDMCharRep(iCharRepDefault);
	BOOL 	fr = psp->fComplex && !psp->fControl;

	if (fr)
	{
		if (iCharRep == ANSI_INDEX || iCharRep == DEFAULT_INDEX)
			iCharRep = CharRepFromLID(psp->langid);

		if (IsBiDiCharRep(iCharRep))
			_iCharRepRtl = iCharRep;	// Cache the last found BiDi charset

		iCharRepOut = iCharRep;
	}
	return fr;
}

// Figure out the charset to use for CDM run
//
BYTE CUniscribe::GetCDMCharRep(
	BYTE iCharRepDefault)
{
	if (!_iCharRepCDM)
	{
		_iCharRepCDM = (iCharRepDefault == VIET_INDEX ||
						W32->GetPreferredKbd(VIET_INDEX) ||
						GetLocaleCharRep() == VIET_INDEX || GetACP() == 1258)
					 ? VIET_INDEX : DEFAULT_INDEX;
	}
	return _iCharRepCDM;
}

BYTE CUniscribe::GetRtlCharRep(
    CTxtEdit*       ped,
	CRchTxtPtr*		prtp)		// ptr to the numeric run
{
	CFormatRunPtr	rp(prtp->_rpCF);

	rp.AdjustBackward();

	BYTE	iCharRep = ped->GetCharFormat(rp.GetFormat())->_iCharRep;

	if (!IsBiDiCharRep(iCharRep))
	{
		iCharRep = _iCharRepRtl;	// Use the last found BiDi charset

		if (!IsBiDiCharRep(iCharRep))
		{
			// try default charset
			DWORD	dwCharFlags;
	
			iCharRep = ped->GetCharFormat(-1)->_iCharRep;
	
			if (!IsBiDiCharRep(iCharRep))
			{
				// Then the system charset
				iCharRep = CharRepFromCodePage(GetACP());
				if (!IsBiDiCharRep(iCharRep))
				{
					// Then the content
					dwCharFlags = ped->GetCharFlags() & (FARABIC | FHEBREW);
	
					if (dwCharFlags == FARABIC)
						iCharRep = ARABIC_INDEX;

					else if(dwCharFlags == FHEBREW)
						iCharRep = HEBREW_INDEX;

					else
					{
						// And last chance with the first found loaded BiDi kbd
						if (W32->GetPreferredKbd(HEBREW_INDEX))
							iCharRep = HEBREW_INDEX;
						else
							// Even if we can't find Arabic, we have to assume it here.
							iCharRep = ARABIC_INDEX;
					}
				}
			}
		}
	}
	Assert(IsBiDiCharRep(iCharRep));
	return iCharRep;
}


// Substitute digit shaper in plsrun if needed
//
void CUniscribe::SubstituteDigitShaper (
	PLSRUN		plsrun,
	CMeasurer*	pme)
{
	Assert(plsrun && pme);

	CTxtEdit*	ped = pme->GetPed();
	WORD		wScript;

	if (GeteProp(plsrun->_a.eScript)->fNumeric)
	{
		wScript = plsrun->_pCF->_wScript;		// reset it before

		switch (W32->GetDigitSubstitutionMode())
		{
		case DIGITS_CTX:
			{
				if (ped->IsRich())
				{
					// Context mode simply means the charset of the kbd for richtext.
					if (!IsBiDiCharRep(ped->GetCharFormat(pme->_rpCF.GetFormat())->_iCharRep))
						break;
				}
				else
				{
					// Digit follows directionality of preceding run for plain text
					CFormatRunPtr	rp(pme->_rpCF);
					Assert(rp.IsValid());

					if (rp.PrevRun())
					{
						if (!IsBiDiCharRep(ped->GetCharFormat(rp.GetFormat())->_iCharRep))
							break;
					}
					else
					{
						// No preceding run, looking for the paragraph direction
						if (!pme->Get_pPF()->IsRtl())
							break;
					}
				}
				// otherwise, fall thru...
			}
		case DIGITS_NATIONAL:
			wScript = _wesNationalDigit;
		default:
			break;
		}

		// Update all linked runs
		while (plsrun)
		{
			plsrun->_a.eScript = wScript;		// assign proper shaping engine to digits
			plsrun = plsrun->_pNext;
		}
	}
}
	

/***** Uniscribe entry point *****/


// memory allocator
//
BOOL CUniscribe::CreateClientStruc (
	BYTE*           pbBufIn,
	LONG            cbBufIn,
	PUSP_CLIENT*    ppc,
	LONG            cchString,
	DWORD           dwMask)
{
	Assert(ppc && pbBufIn);

	if (!ppc)
		return FALSE;

	*ppc = NULL;

	if (cchString == 0)
		cchString = 1;		// simplify caller's logic

	LONG        i;
	LONG        cbSize;
	PBYTE       pbBlock;

	// ScriptItemize's
	//
	PVOID       pvString;
	PVOID       pvsi;

	// ScriptBreak's
	//
	PVOID       pvsla;

	// ScriptShape & Place's
	//
	PVOID       pvwgi;
	PVOID		pvsva;
	PVOID		pvcluster;
	PVOID		pvidx;
	PVOID		pvgoffset;

	// subtable ptrs
	//
	PUSP_CLIENT_SI      pc_si;
	PUSP_CLIENT_SB      pc_sb;
	PUSP_CLIENT_SSP		pc_ssp;


#define RQ_COUNT    	12

	BUF_REQ     brq[RQ_COUNT] =
	{
		// table and subtable blocks
		//
		{ sizeof(USP_CLIENT),                                                             1, (void**)ppc},
		{ sizeof(USP_CLIENT_SI),    dwMask & cli_Itemize    ? 1                         : 0, (void**)&pc_si},
		{ sizeof(USP_CLIENT_SB),    dwMask & cli_Break      ? 1                         : 0, (void**)&pc_sb},
		{ sizeof(USP_CLIENT_SSP),   dwMask & cli_ShapePlace ? 1                         : 0, (void**)&pc_ssp},

		// data blocks
		//
		{ sizeof(WCHAR),            dwMask & cli_string     ? cchString + 1             : 0, &pvString},
		{ sizeof(SCRIPT_ITEM),      dwMask & cli_psi        ? cchString + 1             : 0, &pvsi},
		{ sizeof(SCRIPT_LOGATTR),   dwMask & cli_psla       ? cchString + 1             : 0, &pvsla},
		{ sizeof(WORD),				dwMask & cli_pwgi       ? GLYPH_COUNT(cchString+1)	: 0, &pvwgi},
		{ sizeof(SCRIPT_VISATTR),   dwMask & cli_psva       ? GLYPH_COUNT(cchString+1)	: 0, &pvsva},
		{ sizeof(WORD),				dwMask & cli_pcluster   ? cchString + 1				: 0, &pvcluster},
		{ sizeof(int),				dwMask & cli_pidx       ? GLYPH_COUNT(cchString+1)	: 0, &pvidx},
		{ sizeof(GOFFSET),			dwMask & cli_pgoffset   ? GLYPH_COUNT(cchString+1)	: 0, &pvgoffset},
	};

	// count total buffer size in byte (WORD aligned)
	//
	for (i=0, cbSize=0; i < RQ_COUNT; i++)
	{
		cbSize += ALIGN(brq[i].size * brq[i].c);
	}

	// allocate the whole buffer at once
	//
	if (cbSize > cbBufIn)
	{
		pbBlock = (PBYTE)PvAlloc(cbSize, 0);
	}
	else
	{
		pbBlock = pbBufIn;
	}

	if (!pbBlock)
	{
		//
		// memory management failed!
		//
		TRACEERRORSZ("Allocation failed in CreateClientStruc!\n");
		*ppc = NULL;
		return FALSE;
	}

	
	// clear the main table
	ZeroMemory (pbBlock, sizeof(USP_CLIENT));


	// assign ptrs in buffer request structure
	//
	for (i=0; i < RQ_COUNT; i++)
	{
		if (brq[i].c > 0)
		{
			*brq[i].ppv = pbBlock;
			pbBlock += ALIGN(brq[i].size * brq[i].c);
		}
		else
		{
			*brq[i].ppv = NULL;
		}
	}

	Assert(((PBYTE)(*ppc)+cbSize == pbBlock));

	// fill in data block ptrs in subtable
	//
	if (pc_si)
	{
		pc_si->pwchString   = (WCHAR*)          pvString;
		pc_si->cchString    =                   cchString;
		pc_si->psi          = (SCRIPT_ITEM*)    pvsi;
	}

	if (pc_sb)
	{
		pc_sb->psla         = (SCRIPT_LOGATTR*) pvsla;
	}

	if (pc_ssp)
	{
		pc_ssp->pwgi		= (WORD*) 			pvwgi;
		pc_ssp->psva		= (SCRIPT_VISATTR*)	pvsva;
		pc_ssp->pcluster	= (WORD*) 			pvcluster;
		pc_ssp->pidx		= (int*)			pvidx;
		pc_ssp->pgoffset	= (GOFFSET*)		pvgoffset;
	}

	// fill in subtable ptrs in header table
	//
	(*ppc)->si              = (PUSP_CLIENT_SI)  pc_si;
	(*ppc)->sb              = (PUSP_CLIENT_SB)  pc_sb;
	(*ppc)->ssp             = (PUSP_CLIENT_SSP) pc_ssp;

	return TRUE;
}


///////	CBidiFSM class implementation
//
//		Create: Worachai Chaoweeraprasit(wchao), Jan 29, 1998
//
CBiDiFSM::~CBiDiFSM ()
{
	FreePv(_pStart);
}

INPUT_CLASS CBiDiFSM::InputClass (
	const CCharFormat*	pCF,
	CTxtPtr*			ptp,
	LONG				cchRun) const
{
	if (!_pusp->IsValid() || !pCF || pCF->_wScript == SCRIPT_WHITE)
		return chGround;

	const SCRIPT_PROPERTIES* psp = _pusp->GeteProp(pCF->_wScript);
	BYTE 	iCharRep = pCF->_iCharRep;

	if (psp->fControl)
	{
		if (cchRun == 1)
			switch (ptp->GetChar())				// single-char run
			{
				case LTRMARK: return chLTR;		// \ltrmark
				case RTLMARK: return chRTL;		// \rtlmark
			}
		return chGround;
	}

	if(IsSymbolOrOEMCharRep(iCharRep) || IsFECharRep(iCharRep) || pCF->_dwEffects & CFE_RUNISDBCS)
		return chLTR;

	BOOL fBiDiCharSet = IsBiDiCharSet(psp->bCharSet);
	if (psp->fNumeric)
		// Numeric digits
		return (fBiDiCharSet || IsBiDiCharRep(iCharRep)) ? digitRTL : digitLTR;

	// RTL if it's RTL script or its format charset is RTL and NOT a simplified script
	return (fBiDiCharSet || pCF->_wScript && IsBiDiCharRep(iCharRep)) ? chRTL : chLTR;
}

// The FSM generates run's embedding level based on given base level and puts it
// in CFormatRun. LsFetchRun is the client using this result.
//
#ifdef DEBUG
//#define DEBUG_LEVEL
#endif

#ifdef DEBUG_LEVEL
void DebugLevel (CBiDiFSMCell* pCell)
{
	Tracef(TRCSEVNONE, "%d,", pCell->_level._value);
}
#else
#define DebugLevel(x)
#endif

HRESULT CBiDiFSM::RunFSM (
	CRchTxtPtr*			prtp,				// in: text pointer to start run
	LONG				cRuns,				// in: number of FSM run
	LONG				cRunsStart,			// in: number of start run
	BYTE				bBaseLevel) const	// in: base level
{
	Assert (prtp->_rpCF.IsValid() && cRuns > 0);

	CRchTxtPtr				rtp(*prtp);
	const CCharFormat*      pCF;
	LONG					cchRun;
	LONG					cRunsAll = cRuns + cRunsStart;
	CBiDiFSMCell*           pCell;
	USHORT                  ucState = bBaseLevel ? S_X * NUM_FSM_INPUTS : 0;
	BOOL					fNext = TRUE;


	// loop thru FSM
	for (; fNext && cRunsAll > 0; cRunsAll--, fNext = !!rtp.Move(cchRun))
	{
		cchRun = rtp.GetCchLeftRunCF();
	
		pCF = rtp.GetPed()->GetCharFormat(rtp._rpCF.GetFormat());
	
		ucState += InputClass(pCF, &rtp._rpTX, cchRun);

		pCell = &_pStart[ucState];

		// set level to FSM runs
		if (cRunsAll <= cRuns)
			rtp._rpCF.SetLevel (pCell->_level);

		DebugLevel(pCell);

		ucState = pCell->_uNext;	// next state
	}

	return S_OK;
}

// Construct the BiDi embedding level FSM (FSM details see bidifsm2.html)
// :FSM's size = NUM_FSM_INPUTS * NUM_FSM_STATES * sizeof(CBiDiFSMCell) = 6*5*4 = 120 bytes
//
BOOL CBiDiFSM::Init()
{
	CBiDiFSMCell*   pCell;
	int             i;

	// Build the Bidi FSM

	_nState = NUM_FSM_STATES;
	_nInput = NUM_FSM_INPUTS;

	pCell = (CBiDiFSMCell*)PvAlloc(NUM_FSM_STATES * NUM_FSM_INPUTS * sizeof(CBiDiFSMCell), 0);

	if (!pCell)
		return FALSE;	// unable to create FSM!

	_pStart = pCell;


	CBiDiLevel		lvlZero		= {0,0};
	CBiDiLevel		lvlOne  	= {1,0};
	CBiDiLevel		lvlTwo  	= {2,0};
	CBiDiLevel		lvlTwoStart	= {2,1};


	// State A(0): LTR char in LTR para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_B * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_C * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlZero, 0); break;
		}
	}
	// State B(1): RTL char in LTR para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_B * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_C * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlZero, 0); break;
		}
	}
	// State C(2): RTL number run in LTR para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_B * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_C * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlZero, 0); break;
		}
	}
	// State X(1): RTL char in RTL para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_Z * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
		}
	}
	// State Y(2): LTR char in RTL para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwoStart, S_Z * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
		}
	}
	// State Z(2): RTL number in RTL para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlTwoStart, S_Y * NUM_FSM_INPUTS); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlTwoStart, S_Y * NUM_FSM_INPUTS); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_Z * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
		}
	}

	AssertSz(&pCell[-(NUM_FSM_STATES * NUM_FSM_INPUTS)] == _pStart, "Bidi FSM incomplete constructed!");

	return TRUE;
}


///////	CCallbackBufferBase class implementation
//

void* CBufferBase::GetPtr(int cel)
{
	if (_cElem < cel)
	{
		cel += celAdvance;

		_p = PvReAlloc(_p, cel * _cbElem);
		if (!_p)
			return NULL;
		ZeroMemory(_p, cel * _cbElem);
		_cElem = cel;
	}
	return _p;
}

void CBufferBase::Release()
{
	if (_p)
		FreePv(_p);
}

#endif // NOCOMPLEXSCRIPTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\util.cpp ===
/*
 *	UTIL.C
 *
 *	Purpose:
 *		Implementation of various useful utility functions
 *
 *	Author:
 *		alexgo (4/25/95)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfconv.h"

ASSERTDATA

// Author revision color table
const COLORREF rgcrRevisions[] =
{
        RGB(0, 0, 255),
        RGB(0, 128, 0),
        RGB(255, 0, 0),
        RGB(0, 128, 128),
        RGB(128, 0, 128),
        RGB(0, 0, 128),
        RGB(128, 0, 0),
        RGB(255, 0, 255)
};

#if REVMASK != 7
#pragma message ("WARNING, Revision mask not equal to table!");
#endif 


/*
 *	DuplicateHGlobal
 *
 *	Purpose:
 *		duplicates the passed in hglobal
 */

HGLOBAL DuplicateHGlobal( HGLOBAL hglobal )
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "DuplicateHGlobal");

	UINT	flags;
	DWORD	size;
	HGLOBAL hNew;
	BYTE *	pSrc;
	BYTE *	pDest;

	if( hglobal == NULL )
	{
		return NULL;
	}

	flags = GlobalFlags(hglobal);
	size = GlobalSize(hglobal);
	hNew = GlobalAlloc(flags, size);

	if( hNew )
	{
		pDest = (BYTE *)GlobalLock(hNew);
		pSrc = (BYTE *)GlobalLock(hglobal);

		if( pDest == NULL || pSrc == NULL )
		{
			GlobalUnlock(hNew);
			GlobalUnlock(hglobal);
			GlobalFree(hNew);

			return NULL;
		}

		memcpy(pDest, pSrc, size);

		GlobalUnlock(hNew);
		GlobalUnlock(hglobal);
	}

	return hNew;
}

/*
 *	CountMatchingBits (*pA, *pB, n)
 *
 *	@mfunc
 *		Count matching bit fields
 *
 *	@comm
 *		This is used to help decide how good the match is between
 *		code page bit fields. Mainly for KB/font switching support.
 *
 *	Author:
 *		Jon Matousek
 */
INT CountMatchingBits(
	const DWORD *pA,	//@parm Array A to be matched
	const DWORD *pB,	//@parm Array B to be matched
	INT			 n)		//@parm # DWORDs to be matched
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CountMatchingBits");
							//0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
	static INT	bitCount[] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };
	INT			c = 0;				// Bit count to return
	DWORD		matchBits;			// Next DWORD match

	while(n--)
	{
		//matchBits = ~(*pA++ ^ *pB++);			// 1 and 0's
		matchBits = *pA++ & *pB++;				// 1 only
		for( ; matchBits; matchBits >>= 4)		// Early out
			c += bitCount[matchBits & 15];
	}
	return c;
}

/*
 *	mysqrt(num)
 *
 *	@func
 *	Pass in a number, and it will very simply calculate its integer
 *	square root. This isn't fast but it can be helpful.
 *
 */ 
int mysqrt(int num)
{
	for (int pow = 1;pow * pow < num; pow++)
	{
	}
	return pow - 1;
}

/*
 *	FindPrimeLessThan(num)
 *
 *	@func
 *	Pass in a number, and it will return the greatest prime number less
 *	than num using a simple Sieve of Eratosthenes.
 *
 *	This is suitable for hashing functions.
 *	If you are worried about space, make this use bits.
 *	Also, we shouldn't waste our time with even numbers.
 *
 *	@rdesc
 *		prime number, or 0 if couldn't alloc mem.
 */ 
int FindPrimeLessThan(int num)
{
	BYTE *pb = new BYTE[num];
	if (!pb)
		return 0;

	int squareroot = mysqrt(num);

	//Mark all non-prime numbers.
	for (int i = 2; i <= squareroot;)
	{
		for (int j = i * 2; j < num; j += i)
			pb[j] = 1;				//Mark as composite

		i++;
		while (pb[i] == 1)			//Find next prime factor
			i++;
	}

	//Find first prime walking backwards
	for (i = num - 1; i >= 0 ;i--)
	{
		if (pb[i] == 0)
			break;
	}
     
	delete[]pb;
	return i;
}


//
//	Object Stabilization classes
//

//+-------------------------------------------------------------------------
//
//  Member:		CSafeRefCount::CSafeRefCount
//
//  Synopsis: 	constructor for the safe ref count class
//
//  Effects:
//
//  Arguments:	none
//
//  Requires: 	
//
//  Returns: 	none
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CSafeRefCount::CSafeRefCount()
{
	m_cRefs = 0;
	m_cNest = 0;
	m_fInDelete = FALSE;
    m_fForceZombie = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::CSafeRefCount (virtual)
//
//  Synopsis:	
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CSafeRefCount::~CSafeRefCount()
{
	Assert(m_cRefs == 0 && m_cNest == 0 && m_fInDelete == TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::SafeAddRef
//
//  Synopsis:	increments the reference count on the object
//
//  Effects:
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns: 	ULONG -- the reference count after the increment
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	increments the reference count.
//
//  History:    dd-mmm-yy Author    Comment
//   			28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::SafeAddRef()
{
	m_cRefs++;

	//AssertSz(m_fInDelete == FALSE, "AddRef called on deleted object!");

	// this *could* be really bad.  If we are deleting the object,
	// it means that during the destructor, somebody made an outgoing
	// call eventually ended up with another addref to ourselves
	// (even though	all pointers to us had been 'Released').
	//
	// this is usually caused by code like the following:
	//	m_pFoo->Release();
	//	m_pFoo = NULL;
	//
	// If the the Release may cause Foo to be deleted, which may cause
	// the object to get re-entered during Foo's destructor.  However,
	// 'this' object has not yet set m_pFoo to NULL, so it may
	// try to continue to use m_pFoo.
	//
	// However, the May '94 aggregation rules REQUIRE this behaviour
	// In your destructor, you have to addref the outer unknown before
	// releasing cached interface pointers on your aggregatee.  We
	// can't put an assert here because we do this all the time now.
	//

	return m_cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::SafeRelease
//
//  Synopsis:	decrements the reference count on the object
//
//  Effects: 	May delete the object!
//
//  Arguments:
//
//  Requires:
//
//  Returns:	ULONG -- the reference count after decrement
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm: 	decrements the reference count.  If the reference count
//				is zero AND the nest count is zero AND we are not currently
//				trying to delete our object, then it is safe to delete.
//
//  History:    dd-mmm-yy Author    Comment
//				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::SafeRelease()
{
	ULONG	cRefs;

	if( m_cRefs > 0 )
	{
		cRefs = --m_cRefs;

		if( m_cRefs == 0 && m_cNest == 0 && m_fInDelete == FALSE )
		{
			m_fInDelete = TRUE;
			delete this;
		}
	}
	else
	{
 		// somebody is releasing a non-addrefed pointer!!
		AssertSz(0, "Release called on a non-addref'ed pointer!\n");

		cRefs = 0;
	}

	return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::IncrementNestCount
//
//  Synopsis: 	increments the nesting count of the object
//
//  Effects:
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns: 	ULONG; the nesting count after increment
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:	The nesting count is the count of how many times an
//		an object has been re-entered.  For example, suppose
//		somebody calls pFoo->Bar1(), which makes some calls that
//		eventually call pFoo->Bar2();.  On entrace to Bar2, the
//		nest count of the object should be 2 (since the invocation
//		of Bar1 is still on the stack above us).
//
//		It is important to keep track of the nest count so we do
//		not accidentally delete ourselves during a nested invocation.
//		If we did, then when the stack unwinds to the original
//		top level call, it could try to access a non-existent member
//		variable and crash.
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::IncrementNestCount()
{

#ifdef DEBUG
	if( m_fInDelete )
	{
		TRACEWARNSZ("WARNING: CSafeRefCount, object "
			"re-entered during delete!\n");
	}
#endif

	m_cNest++;

	return m_cNest;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::DecrementNestCount
//
//  Synopsis: 	decrements the nesting count and deletes the object
//				(if necessary)
//
//  Effects: 	may delete 'this' object!
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns:	ULONG, the nesting count after decrement
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	decrements the nesting count.  If the nesting count is zero
//				AND the reference count is zero AND we are not currently
//				trying to delete ourselves, then delete 'this' object
//
//  History:    dd-mmm-yy Author    Comment
//				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::DecrementNestCount()
{
	ULONG	cNest;

	if( m_cNest > 0 )
	{
		cNest = --m_cNest;

		if( m_cRefs == 0 && m_cNest == 0 && m_fInDelete == FALSE )
		{
			m_fInDelete = TRUE;
			delete this;
		}
	}
	else
	{
 		// somebody forget to increment the nest count!!
		AssertSz(0, "Unbalanced nest count!!");

		cNest = 0;
	}

	return cNest;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CSafeRefCount::IsZombie
//
//  Synopsis: 	determines whether or not the object is in a zombie state
//				(i.e. all references gone, but we are still on the stack
//				somewhere).
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns: 	TRUE if in a zombie state
//				FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  If we are in the middle of a delete, or if the ref count
//				is zero and the nest count is greater than zero, then we
//				are a zombie
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CSafeRefCount::IsZombie()
{
	BOOL	fIsZombie;

	if( (m_cRefs == 0 && m_cNest > 0) || m_fInDelete == TRUE
	    || m_fForceZombie == TRUE)
	{
		fIsZombie = TRUE;
	}
	else
	{
		fIsZombie = FALSE;
	}

	return fIsZombie;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CSafeRefCount::Zombie
//
//  Synopsis: 	Forces the object into a zombie state.  This is called
//              when the object is still around but shouldn't be. It
//              flags us so we behave safely while we are in this state.
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns:    none
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID CSafeRefCount::Zombie()
{
    m_fForceZombie = TRUE;
}

/* OleStdSwitchDisplayAspect
**
**	@mfunc
**    Switch the currently cached display aspect between DVASPECT_ICON
**    and DVASPECT_CONTENT.
**
**    NOTE: when setting up icon aspect, any currently cached content
**    cache is discarded and any advise connections for content aspect
**    are broken.
**
**	@rdesc
**      S_OK -- new display aspect setup successfully
**      E_INVALIDARG -- IOleCache interface is NOT supported (this is
**                  required).
**      <other SCODE> -- any SCODE that can be returned by
**                  IOleCache::Cache method.
**      NOTE: if an error occurs then the current display aspect and
**            cache contents unchanged.
*/
HRESULT OleStdSwitchDisplayAspect(
		LPOLEOBJECT             lpOleObj,
		LPDWORD                 lpdwCurAspect,
		DWORD                   dwNewAspect,
		HGLOBAL                 hMetaPict,
		BOOL                    fDeleteOldAspect,
		BOOL                    fSetupViewAdvise,
		LPADVISESINK            lpAdviseSink,
		BOOL FAR*               lpfMustUpdate)
{
   LPOLECACHE      lpOleCache = NULL;
   LPVIEWOBJECT    lpViewObj = NULL;
   LPENUMSTATDATA  lpEnumStatData = NULL;
   STATDATA        StatData;
   FORMATETC       FmtEtc;
   STGMEDIUM       Medium;
   DWORD           dwAdvf;
   DWORD           dwNewConnection;
   DWORD           dwOldAspect = *lpdwCurAspect;
   HRESULT         hrErr;

   if (lpfMustUpdate)
      *lpfMustUpdate = FALSE;

   if (hrErr =
	   lpOleObj->QueryInterface(IID_IOleCache, (void**)&lpOleCache))
   {
	   return hrErr;
   }

   // Setup new cache with the new aspect
   FmtEtc.cfFormat = 0;     // whatever is needed to draw
   FmtEtc.ptd      = NULL;
   FmtEtc.dwAspect = dwNewAspect;
   FmtEtc.lindex   = -1;
   FmtEtc.tymed    = TYMED_NULL;

   /* NOTE: if we are setting up Icon aspect with a custom icon
   **    then we do not want DataAdvise notifications to ever change
   **    the contents of the data cache. thus we set up a NODATA
   **    advise connection. otherwise we set up a standard DataAdvise
   **    connection.
   */
   if (dwNewAspect == DVASPECT_ICON && hMetaPict)
      dwAdvf = ADVF_NODATA;
   else
      dwAdvf = ADVF_PRIMEFIRST;

   hrErr = lpOleCache->Cache(
         (LPFORMATETC)&FmtEtc,
         dwAdvf,
         (LPDWORD)&dwNewConnection
   );

   if (! SUCCEEDED(hrErr)) {
      lpOleCache->Release();
      return hrErr;
   }

   *lpdwCurAspect = dwNewAspect;

   /* NOTE: if we are setting up Icon aspect with a custom icon,
   **    then stuff the icon into the cache. otherwise the cache must
   **    be forced to be updated. set the *lpfMustUpdate flag to tell
   **    caller to force the object to Run so that the cache will be
   **    updated.
   */
   if (dwNewAspect == DVASPECT_ICON && hMetaPict) {

      FmtEtc.cfFormat = CF_METAFILEPICT;
      FmtEtc.ptd      = NULL;
      FmtEtc.dwAspect = DVASPECT_ICON;
      FmtEtc.lindex   = -1;
      FmtEtc.tymed    = TYMED_MFPICT;

      Medium.tymed            = TYMED_MFPICT;
      Medium.hGlobal        = hMetaPict;
      Medium.pUnkForRelease   = NULL;

      hrErr = lpOleCache->SetData(
            (LPFORMATETC)&FmtEtc,
            (LPSTGMEDIUM)&Medium,
            FALSE   /* fRelease */
      );
   } else {
      if (lpfMustUpdate)
         *lpfMustUpdate = TRUE;
   }

   if (fSetupViewAdvise && lpAdviseSink) {
      /* NOTE: re-establish the ViewAdvise connection */
      lpOleObj->QueryInterface(IID_IViewObject, (void**)&lpViewObj);

      if (lpViewObj) {

         lpViewObj->SetAdvise(
               dwNewAspect,
               0,
               lpAdviseSink
         );

         lpViewObj->Release();
      }
   }

   /* NOTE: remove any existing caches that are set up for the old
   **    display aspect. It WOULD be possible to retain the caches set
   **    up for the old aspect, but this would increase the storage
   **    space required for the object and possibly require additional
   **    overhead to maintain the unused cachaes. For these reasons the
   **    strategy to delete the previous caches is prefered. if it is a
   **    requirement to quickly switch between Icon and Content
   **    display, then it would be better to keep both aspect caches.
   */

   if (fDeleteOldAspect) {
      hrErr = lpOleCache->EnumCache(
            (LPENUMSTATDATA FAR*)&lpEnumStatData
      );

      while(hrErr == NOERROR) {
         hrErr = lpEnumStatData->Next(
               1,
               (LPSTATDATA)&StatData,
               NULL
         );
         if (hrErr != NOERROR)
            break;              // DONE! no more caches.

         if (StatData.formatetc.dwAspect == dwOldAspect) {

            // Remove previous cache with old aspect
            lpOleCache->Uncache(StatData.dwConnection);
         }
      }

      if (lpEnumStatData)
         lpEnumStatData->Release();
   }

   if (lpOleCache)
      lpOleCache->Release();

   return NOERROR;
}

/*
 *	ObjectReadSiteFlags
 *
 *	@mfunc
 *		Read the dwFlags, dwUser, & dvaspect bytes from a container
 *		specific stream.
 *
 *	Arguments:
 *		preobj			The REOBJ in which to copy the flags.
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT ObjectReadSiteFlags(REOBJECT * preobj)
{
	HRESULT hr = NOERROR;
	LPSTREAM pstm = NULL;
	OLECHAR StreamName[] = OLESTR("RichEditFlags");


	// Make sure we have a storage to read from
	if (!preobj->pstg)
		return E_INVALIDARG;

	// Open the stream
	if (hr = preobj->pstg->OpenStream(StreamName, 0, STGM_READ |
										STGM_SHARE_EXCLUSIVE, 0, &pstm))
	{
		goto Cleanup;
	}

	if ((hr = pstm->Read(&preobj->dwFlags,
							sizeof(preobj->dwFlags), NULL)) ||
		(hr = pstm->Read(&preobj->dwUser,
							 sizeof(preobj->dwUser), NULL)) ||
		(hr = pstm->Read(&preobj->dvaspect,
								 sizeof(preobj->dvaspect), NULL)))
	{
		goto Cleanup;
	}

Cleanup:
	if (pstm)
		pstm->Release();
	return hr;
}

//Used for EnumMetafileCheckIcon & FIsIconMetafilePict
typedef	struct _walkmetafile
{
	BOOL	fAND;
	BOOL	fPastIcon;
	BOOL 	fHasIcon;
} WALKMETAFILE;

static CHAR szIconOnly[] = "IconOnly";

/*
 * EnumMetafileCheckIcon
 *
 * @mfunc
 *	Stripped down version of EnumMetafileExtractIcon and
 *	EnumMetafileExtractIconSource from the OLE2UI library.
 *
 *  EnumMetaFile callback function that walks a metafile looking for
 *  StretchBlt (3.1) and BitBlt (3.0) records.  We expect to see two
 *  of them, the first being the AND mask and the second being the XOR
 *  data. 
 *
 *	Once we find the icon, we confirm this find by looking for the "IconOnly"
 *	comment block found in standard OLE iconic metafiles.
 *
 *  Arguments:
 *		hDC             HDC into which the metafile should be played.
 *		phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *		pMFR            METARECORD FAR * giving the enumerated record.
 *		pIE             LPICONEXTRACT providing the destination buffer and length.
 *
 * @rdesc
 *  int             0 to stop enumeration, 1 to continue.
 */

#ifndef NOMETAFILES
int CALLBACK EnumMetafileCheckIcon(HDC hdc, HANDLETABLE *phTable,
											METARECORD *pMFR, int cObj,
											LPARAM lparam)
{
	WALKMETAFILE *		pwmf = (WALKMETAFILE *) lparam;

	switch (pMFR->rdFunction)
	{
	case META_DIBBITBLT:			// Win30
	case META_DIBSTRETCHBLT:		// Win31
		// If this is the first pass (pIE->fAND==TRUE) then save the memory
		// of the AND bits for the next pass.

		if (pwmf->fAND)
			pwmf->fAND = FALSE;
		else
			pwmf->fPastIcon = TRUE;
		break;

	case META_ESCAPE:
		if (pwmf->fPastIcon &&
			pMFR->rdParm[0] == MFCOMMENT &&
			!lstrcmpiA(szIconOnly, (LPSTR)&pMFR->rdParm[2]))
		{
			pwmf->fHasIcon = TRUE;
			return 0;
		}
		break;
	}
	return 1;
}
#endif

/*
 *	FIsIconMetafilePict(hmfp)
 *
 *	@mfunc
 *		Detect whether the metafile contains an iconic presentation. We do this
 *		by getting a screen DC and walking the metafile records until we find
 *		the landmarks denoting an icon.
 *
 *		Arguments:
 *			hmfp			The metafile to test
 *
 *	@rdesc
 *		BOOL			TRUE if the metafile contains an iconic view
 */
BOOL FIsIconMetafilePict(HGLOBAL hmfp)
{
#ifndef NOMETAFILES
	LPMETAFILEPICT	pmfp;
	WALKMETAFILE	wmf = { 0 };
	HDC				hdc;

	wmf.fAND = TRUE;
	if (!hmfp || !(pmfp = (LPMETAFILEPICT)GlobalLock(hmfp)))
		goto CleanUp;

	// We get information back in the ICONEXTRACT structure.
	hdc = GetDC(NULL);
	EnumMetaFile(hdc, pmfp->hMF, EnumMetafileCheckIcon, (LPARAM) &wmf);
	ReleaseDC(NULL, hdc);
	GlobalUnlock(hmfp);

CleanUp:
	return wmf.fHasIcon;
#else
	return TRUE;
#endif
}

/*
 *	AllocObjectDescriptor (clsID, dwAspect, szl, ptl, dwMisc, pszName, pszSrc)
 *
 *	@func
 *		Allocate and fill an OBJECTDESCRIPTOR structure
 *
 *	@rdesc
 *		HBGLOBAL         Handle to OBJECTDESCRIPTOR structure.
 */
static HGLOBAL AllocObjectDescriptor(
	CLSID clsID,	// CLSID to store
	DWORD dwAspect,	// Display aspect
	SIZEL szl,		// Optional extents container uses to display object
	POINTL ptl,		// Upper-left corner of obj where mouse went down for D&D
	DWORD dwMisc,	// MiscStatus flags
	LPTSTR pszName,	// Name of object to copy
	LPTSTR pszSrc)	// Source of object
{
    HGLOBAL              hMem=NULL;
    LPOBJECTDESCRIPTOR   pOD;
    DWORD                cb, cbStruct;
    DWORD                cchName, cchSrc;

	cchName=wcslen(pszName)+1;

    if (NULL!=pszSrc)
        cchSrc=wcslen(pszSrc)+1;
    else
        {
        cchSrc=cchName;
        pszSrc=pszName;
        }

    /*
     * Note:  CFSTR_OBJECTDESCRIPTOR is an ANSI structure.
     * That means strings in it must be ANSI.  OLE will do
     * internal conversions back to Unicode as necessary,
     * but we have to put ANSI strings in it ourselves.
     */
    cbStruct=sizeof(OBJECTDESCRIPTOR);
    cb=cbStruct+(sizeof(WCHAR)*(cchName+cchSrc));   //HACK

    hMem=GlobalAlloc(GHND, cb);

    if (NULL==hMem)
        return NULL;

    pOD=(LPOBJECTDESCRIPTOR)GlobalLock(hMem);

    pOD->cbSize=cb;
    pOD->clsid=clsID;
    pOD->dwDrawAspect=dwAspect;
    pOD->sizel=szl;
    pOD->pointl=ptl;
    pOD->dwStatus=dwMisc;

    if (pszName)
        {
        pOD->dwFullUserTypeName=cbStruct;
       wcscpy((LPTSTR)((LPBYTE)pOD+pOD->dwFullUserTypeName)
            , pszName);
        }
    else
        pOD->dwFullUserTypeName=0;  //No string

    if (pszSrc)
        {
        pOD->dwSrcOfCopy=cbStruct+(cchName*sizeof(WCHAR));

        wcscpy((LPTSTR)((LPBYTE)pOD+pOD->dwSrcOfCopy), pszSrc);
        }
    else
        pOD->dwSrcOfCopy=0;  //No string

    GlobalUnlock(hMem);
    return hMem;
}

HGLOBAL OleGetObjectDescriptorDataFromOleObject(
	LPOLEOBJECT pObj,
	DWORD       dwAspect,
	POINTL      ptl,
	LPSIZEL     pszl
)
{
    CLSID           clsID;
    LPTSTR          pszName=NULL;
    LPTSTR          pszSrc=NULL;
   BOOL            fLink=FALSE;
    IOleLink       *pLink;
    TCHAR           szName[512];
    DWORD           dwMisc=0;
    SIZEL           szl = {0,0};
    HGLOBAL         hMem;
    HRESULT         hr;

    if (SUCCEEDED(pObj->QueryInterface(IID_IOleLink
        , (void **)&pLink)))
        fLink=TRUE;

    if (FAILED(pObj->GetUserClassID(&clsID)))
		ZeroMemory(&clsID, sizeof(CLSID));

    //Get user string, expand to "Linked %s" if this is link
    pObj->GetUserType(USERCLASSTYPE_FULL, &pszName);
    if (fLink && NULL!=pszName)
	{
		// NB!! we do these two lines of code below instead
		// wcscat because we don't use wcscat anywhere else
		// in the product at the moment.  The string "Linked "
		// should never change either.
		wcscpy(szName, TEXT("Linked "));
		wcscpy(&(szName[7]), pszName);
	}
    else if (pszName)
       wcscpy(szName, pszName);
	else
		szName[0] = 0;
 
	CoTaskMemFree(pszName);

   /*
     * Get the source name of this object using either the
     * link display name (for link) or a moniker display
     * name.
     */

    if (fLink)
		{
        hr=pLink->GetSourceDisplayName(&pszSrc);
		}
    else
        {
        IMoniker   *pmk;

        hr=pObj->GetMoniker(OLEGETMONIKER_TEMPFORUSER
            , OLEWHICHMK_OBJFULL, &pmk);

        if (SUCCEEDED(hr))
            {
            IBindCtx  *pbc;
            CreateBindCtx(0, &pbc);

            pmk->GetDisplayName(pbc, NULL, &pszSrc);
            pbc->Release();
            pmk->Release();
            }
        }

    if (fLink)
        pLink->Release();

    //Get MiscStatus bits
    hr=pObj->GetMiscStatus(dwAspect, &dwMisc);

    if (pszl)
    {
        szl.cx = pszl->cx;
        szl.cy = pszl->cy;
    }
    //Get OBJECTDESCRIPTOR
    hMem=AllocObjectDescriptor(clsID, dwAspect, szl, ptl, dwMisc, szName, pszSrc);

    CoTaskMemFree(pszSrc);

    return hMem;
}

/*
 * OleStdGetMetafilePictFromOleObject()
 *
 * @mfunc:
 *  Generate a MetafilePict from the OLE object.
 *  Parameters:
 *		lpOleObj        LPOLEOBJECT pointer to OLE Object 
 *		dwDrawAspect    DWORD   Display Aspect of object
 *		lpSizelHim      SIZEL   (optional) If the object is being scaled in its
 *                  container, then the container should pass the extents 
 *                  that it is using to display the object. 
 *                  May be NULL if the object is NOT being scaled. in this
 *                  case, IViewObject2::GetExtent will be called to get the
 *                  extents from the object.
 *  ptd             TARGETDEVICE FAR*   (optional) target device to render
 *                  metafile for. May be NULL.
 *
 * @rdesc
 *    HANDLE    -- handle of allocated METAFILEPICT
 */
HANDLE OleStdGetMetafilePictFromOleObject(
        LPOLEOBJECT         lpOleObj,
        DWORD               dwDrawAspect,
        LPSIZEL             lpSizelHim,
        DVTARGETDEVICE FAR* ptd
)
{
#ifndef NOMETAFILES
    LPVIEWOBJECT2 lpViewObj2 = NULL;
    HDC hDC;
    HMETAFILE hmf;
    HANDLE hMetaPict;
    LPMETAFILEPICT lpPict;
    RECT rcHim;
    RECTL rclHim;
    SIZEL sizelHim;
    HRESULT hrErr;
    SIZE size;
    POINT point;
	LPOLECACHE polecache = NULL;
	LPDATAOBJECT pdataobj = NULL;
	FORMATETC fetc;
	STGMEDIUM med;

	// First try the easy way,
	// pull out the cache's version of things.
	ZeroMemory(&fetc, sizeof(FORMATETC));
	fetc.dwAspect = dwDrawAspect;
	fetc.cfFormat = CF_METAFILEPICT;
	fetc.lindex = -1;
	fetc.tymed = TYMED_MFPICT;
	ZeroMemory(&med, sizeof(STGMEDIUM));
	hMetaPict = NULL;

	if (!lpOleObj->QueryInterface(IID_IOleCache, (void **)&polecache) &&
		!polecache->QueryInterface(IID_IDataObject, (void **)&pdataobj) &&
		!pdataobj->GetData(&fetc, &med))
	{
		hMetaPict = OleDuplicateData(med.hGlobal, CF_METAFILEPICT, 0);
		ReleaseStgMedium(&med);
	}

	if (pdataobj)
	{
		pdataobj->Release();
	}

	if (polecache)
	{
		polecache->Release();
	}

	// If all this failed, fall back to the hard way and draw the object
	// into a metafile.
	if (hMetaPict)
		return hMetaPict;

    if (lpOleObj->QueryInterface(IID_IViewObject2, (void **)&lpViewObj2))
        return NULL;

    // Get SIZEL
    if (lpSizelHim) {
        // Use extents passed by the caller
        sizelHim = *lpSizelHim;
    } else {
        // Get the current extents from the object
        hrErr = lpViewObj2->GetExtent(
					dwDrawAspect,
					-1,     /*lindex*/
					ptd,    /*ptd*/
					(LPSIZEL)&sizelHim);
        if (hrErr != NOERROR)
            sizelHim.cx = sizelHim.cy = 0;
    }

    hDC = CreateMetaFileA(NULL);

    rclHim.left     = 0;
    rclHim.top      = 0;
    rclHim.right    = sizelHim.cx;
    rclHim.bottom   = sizelHim.cy;

    rcHim.left      = (int)rclHim.left;
    rcHim.top       = (int)rclHim.top;
    rcHim.right     = (int)rclHim.right;
    rcHim.bottom    = (int)rclHim.bottom;

    SetWindowOrgEx(hDC, rcHim.left, rcHim.top, &point);
    SetWindowExtEx(hDC, rcHim.right-rcHim.left, rcHim.bottom-rcHim.top,&size);

    hrErr = lpViewObj2->Draw(
            dwDrawAspect,
            -1,
            NULL,
            ptd,
            NULL,
            hDC,
            (LPRECTL)&rclHim,
            (LPRECTL)&rclHim,
            NULL,
            0
    );

    lpViewObj2->Release();

    hmf = CloseMetaFile(hDC);

    if (hrErr != NOERROR) {
		TRACEERRORHR(hrErr);
		hMetaPict = NULL;
    }
	else
	{
    	hMetaPict = GlobalAlloc(GHND|GMEM_SHARE, sizeof(METAFILEPICT));

    	if (hMetaPict && (lpPict = (LPMETAFILEPICT)GlobalLock(hMetaPict))){
        	lpPict->hMF  = hmf;
        	lpPict->xExt = (int)sizelHim.cx ;
        	lpPict->yExt = (int)sizelHim.cy ;
        	lpPict->mm   = MM_ANISOTROPIC;
        	GlobalUnlock(hMetaPict);
    	}
	}

	if (!hMetaPict)
		DeleteMetaFile(hmf);

    return hMetaPict;
#else
	return NULL;
#endif
}

/*
 * OleUIDrawShading
 *
 * Purpose:
 *  Shade the object when it is in in-place editing. Borders are drawn
 *  on the Object rectangle. The right and bottom edge of the rectangle
 *  are excluded in the drawing.
 *
 * Parameters:
 *  lpRect      Dimensions of Container Object
 *  hdc         HDC for drawing
 *
 * Return Value: null
 *
 */
void OleUIDrawShading(LPRECT prc, HDC hdc)
{
    HBITMAP hbmp;
    WORD	 wHatchBmp[] = {0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88};
    COLORREF crTextOld;
    COLORREF crBkOld;

    hbmp = CreateBitmap(8, 8, 1, 1, wHatchBmp);
	if (hbmp)
	{
	    HBRUSH  hbr;
		hbr = CreatePatternBrush(hbmp);
		if (hbr)
		{
		    HBRUSH  hbrOld;

			hbrOld = (HBRUSH)SelectObject(hdc, hbr);

			crTextOld = SetTextColor(hdc, RGB(255, 255, 255));
			crBkOld = SetBkColor(hdc, RGB(0, 0, 0));

			PatBlt(hdc, prc->left, prc->top, prc->right - prc->left, prc->bottom - prc->top, 0x00A000C9L /* DPa */ );

			SetTextColor(hdc, crTextOld);
			SetBkColor(hdc, crBkOld);

			SelectObject(hdc, hbrOld);
			DeleteObject(hbr);
		}
		DeleteObject(hbmp);
	}
}

/*
 *	OleSaveSiteFlags
 *
 *	Purpose:
 *		Save the dwFlags and dwUser bytes into a container specific stream
 *
 *	Arguments:
 *		pstg			The storage to save to
 *		pobsite			The site from where to copy the flags
 *
 *	Returns:
 *		None.
 */
VOID OleSaveSiteFlags(LPSTORAGE pstg, DWORD dwFlags, DWORD dwUser, DWORD dvAspect)
{
#ifndef PEGASUS
	HRESULT hr;
	LPSTREAM pstm = NULL;
	static const OLECHAR szSiteFlagsStm[] = OLESTR("RichEditFlags");

	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "OleSaveSiteFlags");

	// Create/overwrite the stream
	AssertSz(pstg, "Invalid storage");
	if (hr = pstg->CreateStream(szSiteFlagsStm, STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
							    0, 0, &pstm))
	{
		TraceError("OleSaveSiteFlags", GetScode(hr));
		goto Cleanup;
	}

	//$ FUTURE: Put a version stamp

	// Write out the values
	//$ BUG: byte order
	if ((hr = pstm->Write(&dwFlags, sizeof(dwFlags), NULL)) ||
		(hr = pstm->Write(&dwUser, sizeof(dwUser), NULL)) ||
		(hr = pstm->Write(&dvAspect, sizeof(dvAspect), NULL)))
	{
		TraceError("OleSaveSiteFlags", GetScode(hr));
		//$ FUTURE: Wipe the data to make this operation all or nothing
		goto Cleanup;
	}

Cleanup:
    if (pstm)
        pstm->Release();
#endif	
}

/*
 *	AppendString ( szInput, szAppendStr, dBuffSize, dByteUsed )
 *
 *	Purpose:
 *		Append new string to original string. Check for size of buffer
 *	and re-allocate a large buffer is necessary
 *
 *	Arguments:
 *		szInput			Original String 
 *		szAppendStr		String to be appended to szInput 
 *		dBuffSize		Byte size of the buffer for szInput
 *		dByteUsed		Byte used in the buffer for szInput
 *
 *	Returns:
 *		INT		The error code
 */
INT AppendString( 
	BYTE ** szInput, 
	BYTE * szAppendStr,
	int	* dBuffSize,
	int * dByteUsed)
{
	BYTE	*pch;
	int		cchAppendStr;

	pch = *szInput;

	// check if we have enough space to append the new string
	cchAppendStr = strlen( (char *)szAppendStr );
	
	if ( cchAppendStr + *dByteUsed >= *dBuffSize )
	{
		// re-alloc a bigger buffer
		int cchNewSize = *dBuffSize + cchAppendStr + 32;
		
		pch = (BYTE *)PvReAlloc( *szInput, cchNewSize );
	
		if ( !pch )
		{
			return ( ecNoMemory );
		}

		*dBuffSize = cchNewSize;
		*szInput = pch;
	}

	pch += *dByteUsed;
	*dByteUsed += cchAppendStr;

	while (*pch++ = *szAppendStr++);	
	
	return ecNoError;
}

/*
 *	CTempBuf::Init
 *
 *	@mfunc	Set object to its initial state using the stack buffer
 *
 */
void CTempBuf::Init()
{
	_pv = (void *) &_chBuf[0];
	_cb = MAX_STACK_BUF;
}

/*
 *	CTempBuf::FreeBuf
 *
 *	@mfunc	Free an allocated buffer if there is one
 *
 */
void CTempBuf::FreeBuf()
{
	if (_pv != &_chBuf[0])
	{
		delete _pv;
	}
}

/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer for temporary use
 *
 *	@rdesc	Pointer to buffer if one could be allocated otherwise NULL.
 *
 *
 */
void *CTempBuf::GetBuf(
	LONG cb)				//@parm Size of buffer needed in bytes
{
	if (_cb >= cb)
	{
		// Currently allocated buffer is big enough so use it
		return _pv;
	}

	// Free our current buffer
	FreeBuf();

	// Allocate a new buffer if we can
	_pv = new BYTE[cb];

	if (NULL == _pv)
	{
		// Could not allocate a buffer so reset to our initial state and
		// return NULL.
		Init();
		return NULL;
	}

	// Store the size of our new buffer.
	_cb = cb;

	// Returnt he pointer to the buffer.
	return _pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\urlsup.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	URLSUP.CPP	URL detection support |
 *
 *	Author:	alexgo 4/3/96
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_urlsup.h"
#include "_m_undo.h"
#include "_select.h"
#include "_clasfyc.h"

ASSERTDATA

// Arrays for URL detection.  The first array is the protocols
// we support, followed by the "size" of the array.
// NB!! Do _not_ modify these arrays without first making sure
// that the code in ::IsURL is updated appropriately.


/*
FUTURE (keithcu)
We should generalize our support to recognize URLs of the following type:

Maybe we should do autocorrect so that:
keithcu@microsoft.com converts to mailto:keithcu@microsoft.com
Should we put this code in PutChar rather than here?

What about URLs of the form "seattle.sidewalk.com"? Word doesn't support this yet.
It is hard because do you look for the .com? What happens when .com, .edu, .gov,
etc. aren't the only suffixes anymore?

What about the interaction with notifications?
We should add support for purple text. CFE_LINKVISITED
*/

//Includes both types of URLs
const int MAXURLHDRSIZE	= 9;

//Most of these can just be passed right to the client--but some need a prefix.
//Can we automatically add that tag when it needs it?
const LPCWSTR rgszURL[] = {
	L"http:",
	L"file:",
	L"mailto:",
	L"ftp:",
	L"https:",
	L"gopher:",
	L"nntp:",
	L"prospero:",
	L"telnet:",
	L"news:",
	L"wais:",
	L"outlook:",
	L"callto:"
};
const char rgcchURL[] = {
	5,
	5,
	7,
	4,
	6,
	7,
	5,
	9,
	7,
	5,
	5,
	8,
	7
};

#define NUMURLHDR		sizeof(rgcchURL)

//
//The XXX. URLs
//
const LPCWSTR rgszDOTURL[] = {
	L"www.",
	L"ftp.",
};

const char rgcchDOTURL[] = {
	4,
	4,
};

#define NUMDOTURLHDR		sizeof(rgcchDOTURL)


inline BOOL IsURLWhiteSpace(WCHAR ch)
{
	if (IsWhiteSpace(ch))
		return TRUE;

	// See RAID 6304.  MSKK doesn't want CJK in URLs.  We do what we did in 2.0
	if ( ch >= 0x03000 && !IsKorean(ch) )
		return TRUE;

	// GetKinsokuClass() takes an lcid for Win95, but for this case it doesn't
	// seem to be worth the perf loss since different code pages shouldn't
	// result in different results.
	INT iset = GetKinsokuClass(ch);
	return iset == 10 || (iset == 14 && ch != WCH_EMBEDDING);
}

/*
 *	CDetectURL::CDetectURL (ped)
 *
 *	@mfunc	constructor; registers this class in the notification manager.
 *
 *	@rdesc	void
 */
CDetectURL::CDetectURL(
	CTxtEdit *ped)		//@parm edit context to use
{
	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);

	_ped = ped;
}

/*
 *	CDetectURL::~CDetectURL
 *
 *	@mfunc	destructor; removes ths class from the notification manager
 */
CDetectURL::~CDetectURL()
{
	CNotifyMgr *pnm = _ped->GetNotifyMgr();

	if(pnm)
		pnm->Remove((ITxNotify *)this);
}

//
//	ITxNotify	methods
//

/*
 *	CDetectURL::OnPreRelaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc	called before a change is made
 */
void CDetectURL::OnPreReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	; // don't need to do anything here
}

/*
 *	CDetectURL::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc	called after a change has been made to the backing store.  We
 *			simply need to accumulate all such changes
 */
void CDetectURL::OnPostReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	// We don't need to worry about format changes; just data changes
	// to the backing store

	if(cp != CP_INFINITE)
	{
		Assert(cp != CONVERT_TO_PLAIN);
		_adc.UpdateRecalcRegion(cp, cchDel, cchNew);
	}
}

/*
 *	CDetectURL::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDetectURL::Zombie ()
{
}

/*
 *	CDetectURL::ScanAndUpdate(publdr)
 *
 *	@mfunc	scans the affect text, detecting new URL's and removing old ones.
 *
 *	@comm	The algorithm we use is straightforward: <nl>
 *
 *			1. find the update region and expand out to whitespace in either
 *			direction. <nl>
 *
 *			2. Scan through region word by word (where word is contiguous
 *			non-whitespace). 
 *			
 *			3. Strip these words off punctuation marks. This may be a bit 
 *			tricky as some of the punctuation may be part of the URL itself.
 *			We assume that generally it's not, and if it is, one has to enclose
 *			the URL in quotes, brackets or such. We stop stripping the 
 *			punctuation off the end as soon as we find the matching bracket.
 *			
 *			4. If it's a URL, enable the effects, if it's
 *			incorrectly labelled as a URL, disabled the effects.
 *
 *			Note that this algorithm will only remove
 */
void CDetectURL::ScanAndUpdate(
	IUndoBuilder *publdr)	//@parm undo context to use
{
	LONG		cpStart, cpEnd, cp;
	CTxtSelection *psel = _ped->GetSel();
	CTxtRange	rg(*psel);
	BOOL		fCleanedThisURL;
	BOOL		fCleanedSomeURL = FALSE;

	// Clear away some unnecessary features of the range that will
	// just slow us down.
	rg.SetIgnoreFormatUpdate(TRUE);
	rg._rpPF.SetToNull();
		
	if(!GetScanRegion(cpStart, cpEnd))
		return;

	rg.Set(cpStart, 0);

	while((cp = rg.GetCp()) < cpEnd)
	{
		Assert(rg.GetCch() == 0);
		if(rg.GetCF()->_dwEffects & CFE_LINKPROTECTED)
		{
			rg.Move(rg._rpCF.GetCchLeft(), FALSE);	// Bypass run
			continue;
		}

		LONG cchAdvance; 

		ExpandToURL(rg, cchAdvance);

		if(rg.GetCch() && IsURL(rg._rpTX, -rg.GetCch(), NULL))
		{
			SetURLEffects(rg, publdr);

			LONG cpNew = rg.GetCp() - rg.GetCch();

			// Anything before detected URL did not really belong to it
			if (rg.GetCp() > cp)
			{
				rg.Set(cp, cp - rg.GetCp());
				CheckAndCleanBogusURL(rg, fCleanedThisURL, publdr);
				fCleanedSomeURL |= fCleanedThisURL;
			}

			// Collapse to end of URL range so that ExpandToURL will
			// find next candidate.
			rg.Set(cpNew, 0);

			// skip to the end of word; this can't be another URL!
			cp = cpNew;
			cchAdvance = -MoveByDelimiters(rg._rpTX, 1, URL_STOPATWHITESPACE, 0);
		}

		if(cchAdvance)
		{
			rg.Set(cp, cchAdvance);
			CheckAndCleanBogusURL(rg, fCleanedThisURL, publdr);
			fCleanedSomeURL |= fCleanedThisURL;

			// Collapse to end of scanned range so that ExpandToURL will
			// find next candidate.
			rg.Set(cp - cchAdvance, 0);
		}
	}

	// If we cleaned some URL, we might need to reset the default format
	if(fCleanedSomeURL && !psel->GetCch())
		psel->Update_iFormat(-1);
}

//
//	PRIVATE methods
//

/*
 *	CDetectURL::GetScanRegion (&rcpStart, &rcpEnd)
 *
 *	@mfunc	Gets the region of text to scan for new URLs by expanding the
 *			changed region to be bounded by whitespace
 *
 *	@rdesc	BOOL
 */
BOOL CDetectURL::GetScanRegion(
	LONG&	rcpStart,		//@parm where to put start of range
	LONG&	rcpEnd)			//@parm where to put end of range
{
	LONG		cp, cch;
	LONG		cchExpand;
	WCHAR		chBracket;
	CRchTxtPtr	rtp(_ped, 0);

	_adc.GetUpdateRegion(&cp, NULL, &cch);

	if(cp == CP_INFINITE)
		return FALSE;

	// First find start of region
	rtp.SetCp(cp);
	rcpStart = cp;
	rcpEnd = cp + cch;
	
	// Now let's see if we need to expand to the nearest quotation mark
	// we do if we have quotes in our region or we have the LINK bit set
	// on either side of the region that we might need or not need to clear
	BOOL fExpandToBrackets = (rcpEnd - rcpStart ? 
						      GetAngleBracket(rtp._rpTX, rcpEnd - rcpStart) : 0);

	BOOL fKeepGoing = TRUE;	
	while(fKeepGoing)
	{
		fKeepGoing = FALSE;

		// Expand left to the entire word
		rtp.SetCp(rcpStart);
		rcpStart += MoveByDelimiters(rtp._rpTX, -1, URL_STOPATWHITESPACE, 0);

		// Now the other end
		rtp.SetCp(rcpEnd);
		rcpEnd += MoveByDelimiters(rtp._rpTX, 1, URL_STOPATWHITESPACE, 0);

		// If we have LINK formatting around, we'll need to expand to nearest quotes
		rtp.SetCp(rcpStart);
		rtp._rpCF.AdjustBackward();
		fExpandToBrackets = fExpandToBrackets ||
						(_ped->GetCharFormat(rtp._rpCF.GetFormat())->_dwEffects & CFE_LINK);

		rtp.SetCp(rcpEnd);
		rtp._rpCF.AdjustForward();
		fExpandToBrackets = fExpandToBrackets || 
						(_ped->GetCharFormat(rtp._rpCF.GetFormat())->_dwEffects & CFE_LINK);

		if (fExpandToBrackets)
		// We have to expand to nearest angle brackets in both directions
		{
			rtp.SetCp(rcpStart);
			chBracket = LEFTANGLEBRACKET;
			cchExpand = MoveByDelimiters(rtp._rpTX, -1, URL_STOPATCHAR, &chBracket);
		
			// Did we really hit a bracket?	
			if(chBracket == LEFTANGLEBRACKET)
			{
				rcpStart += cchExpand;
				fKeepGoing = TRUE;
			}

			// Same thing, different direction
			rtp.SetCp(rcpEnd);
			chBracket = RIGHTANGLEBRACKET;
			cchExpand =  MoveByDelimiters(rtp._rpTX, 1, URL_STOPATCHAR, &chBracket);

			if(chBracket == RIGHTANGLEBRACKET)
			{
				rcpEnd += cchExpand;
				fKeepGoing = TRUE;
			}
			fExpandToBrackets = FALSE;
		}
	}
		
	LONG cchAdj = _ped->GetAdjustedTextLength();
	if(rcpEnd > cchAdj)
		rcpEnd = cchAdj;

	return TRUE;
}

/*
 *	CDetectURL::ExpandToURL(&rg, &cchAdvance)
 *
 *	@mfunc	skips white space and sets the range to the very next
 *			block of non-white space text. Strips this block off
 *			punctuation marks
 */
void CDetectURL::ExpandToURL(
	CTxtRange&	rg,	//@parm range to move
	LONG &cchAdvance//@parm how much to advance to the next URL from the current cp		
							)	
{
	LONG cp;
	LONG cch;

	Assert(rg.GetCch() == 0);

	cp = rg.GetCp();

	// Skip white space first, record the advance
	cp  -= (cchAdvance = -MoveByDelimiters(rg._rpTX, 1, 
							URL_EATWHITESPACE|URL_STOPATNONWHITESPACE, 0));
	rg.Set(cp, 0);

	// Strip off punctuation marks
	WCHAR chStopChar = URL_INVALID_DELIMITER;

	// Skip all punctuation from the beginning of the word
	LONG cchHead = MoveByDelimiters(rg._rpTX, 1, 
							URL_STOPATWHITESPACE|URL_STOPATNONPUNCT, 
							&chStopChar);

	// Now skip up to white space (i.e. expand to the end of the word).
	cch = MoveByDelimiters(rg._rpTX, 1, URL_STOPATWHITESPACE|URL_EATNONWHITESPACE, 0);
	
	// This is how much we want to advance to start loking for the next URL
	// if this does not turn out to be one: one word
	// We increment/decrement  the advance so we can accumulate changes in there
	cchAdvance -= cch;
	WCHAR chLeftDelimiter = chStopChar;

	// Check if anything left; if not, it's not interesting -- just return
	Assert(cchHead <= cch);
	if(cch == cchHead)
	{
		rg.Set(cp, -cch);
		return;
	}

	// Set to the end of range
	rg.Set(cp + cch, 0);
		
	//  Get the space after so we always clear white space between words
	//	cchAdvance -= MoveByDelimiters(rg._rpTX, 1, 
	//						URL_EATWHITESPACE|URL_STOPATNONWHITESPACE, 0);

	// and go back while skipping punctuation marks and not finding a match
	// to the left-side encloser

	chStopChar = BraceMatch(chStopChar);
	LONG cchTail = MoveByDelimiters(rg._rpTX, -1, 
							URL_STOPATWHITESPACE|URL_STOPATNONPUNCT|URL_STOPATCHAR, 
							&chStopChar);

	// Something should be left of the word, assert that
	Assert(cch - cchHead + cchTail > 0);

	if(chLeftDelimiter == LEFTANGLEBRACKET)
	{ 
		//If we stopped at a quote: go forward looking for the enclosing
		//quote, even if there are spaces.

		// move to the beginning
		rg.Set(cp + cchHead, 0);
		chStopChar = RIGHTANGLEBRACKET;
		if(GetAngleBracket(rg._rpTX) < 0) // closing bracket
		{
			LONG cchExtend = MoveByDelimiters(rg._rpTX, 1, URL_STOPATCHAR, &chStopChar);
			Assert(cchExtend <= URL_MAX_SIZE);

			// did we really get the closing bracket?
			if(chStopChar == RIGHTANGLEBRACKET)
			{
				rg.Set(cp + cchHead, -(cchExtend - 1));
				return;
			}
		}
		// Otherwise the quotes did not work out; fall through to
		// the general case
	}
	rg.Set(cp + cchHead, -(cch - cchHead + cchTail));
	return;
}

/*
 *	CDetectURL::IsURL(&tp, cchrg, pfURLLeadin)
 *
 *	@mfunc
 *		If the cchrg chars starting at tp.GetCp() are a valid URL start,
 *		return TRUE.  We assume that these chars constitute a block of
 *		non-white space text.
 *			
 *	@rdesc
 *		TRUE iff tp points at a valid URL start of cchrg characters
 */
BOOL CDetectURL::IsURL(
	CTxtPtr & tp,			//@parm Start of text to check
	LONG	  cchrg,		//@parm cch to check
	BOOL *	  pfURLLeadin)	//@parm Returns whether valid URL leadin string
{
	LONG i, j;
	WCHAR szBuf[MAXURLHDRSIZE + 1];
	
	if(pfURLLeadin)
		*pfURLLeadin = FALSE;

	if(cchrg <= 0)
		return FALSE;

	LONG cch = tp.GetText(MAXURLHDRSIZE, szBuf);
	szBuf[cch] = L'\0';

	// First, see if the word contains '\\' because that is a UNC
	// convention and it's cheap to check.
	if (szBuf[0] == L'\\' && szBuf[1] == L'\\' && cchrg > 2)
		return TRUE;

	// Scan the buffer to see if we have one of ':.' since
	// all URLs must contain that.  wcsnicmp is a fairly expensive
	// call to be making frequently.
	for(i = 0; i < cch; i++)
	{
		switch (szBuf[i])
		{
		default:
			break;

		case '.':
			for(j = 0; j < NUMDOTURLHDR; j++)
			{
				// The strings must match 
				if(W32->wcsnicmp(szBuf, rgszDOTURL[j], rgcchDOTURL[j]) == 0)
				{
					if(cchrg >= rgcchDOTURL[j])
					{
						if(pfURLLeadin)
							*pfURLLeadin = TRUE;
						return TRUE;
					}
					break;
				}
			}
			return FALSE;

		case ':':
			for(j = 0; j < NUMURLHDR; j++)
			{
				if(W32->wcsnicmp(szBuf, rgszURL[j], rgcchURL[j]) == 0)
				{
					LONG cchURL = rgcchURL[j];
					if(cchrg >= cchURL)
					{
						if(pfURLLeadin)
							*pfURLLeadin = TRUE;
						return j || cchrg > cchURL && szBuf[cchURL] == '/';
					}
					break;
				}
			}
			return FALSE;
		}
	}
	return FALSE;
}

/*
 *	CDetectURL::SetURLEffects (&rg, publdr)
 *
 *	@mfunc	Sets URL effects for the given range.
 *
 *	@comm	The URL effects currently are blue text, underline, with 
 *			CFE_LINK.
 */
void CDetectURL::SetURLEffects(
	CTxtRange &	rg,			//@parm Range on which to set the effects
	IUndoBuilder *publdr)	//@parm Undo context to use
{
	CCharFormat CF;

	CF._dwEffects = CFE_LINK;

	// NB!  The undo system should have already figured out what should
	// happen with the selection by now.  We just want to modify the
	// formatting and not worry where the selection should go on undo/redo.

	rg.SetCharFormat(&CF, SCF_IGNORESELAE, publdr, CFM_LINK, CFM2_CHARFORMAT);
}

/*
 *	CDetectURL::CheckAndCleanBogusURL(rg, fDidClean, publdr)
 *
 *	@mfunc	checks the given range to see if it has CFE_LINK set,
 *			and if so, removes is.  We assume that the range is already
 *			_not_ a well-formed URL string.
 */
void CDetectURL::CheckAndCleanBogusURL(
	CTxtRange&	rg,			//@parm range to use
	BOOL	   &fDidClean,	//@parm return TRUE if we actually did some cleaning
	IUndoBuilder *publdr)	//@parm undo context to use
{
	LONG cch = -rg.GetCch();
	Assert(cch > 0);

	CCharFormat CF;
	CFormatRunPtr rp(rg._rpCF);

	fDidClean = FALSE;

	// If there are no format runs, nothing to do
	if(!rp.IsValid())
		return;

	rp.AdjustForward();
	// Run through the format runs in this range; if there is no
	// link bit set, then just return.
	while(cch > 0)
	{
		DWORD dwEffects = _ped->GetCharFormat(rp.GetFormat())->_dwEffects;
		if((dwEffects & CFE_LINK) && !(dwEffects & CFE_LINKPROTECTED))
			break;

		cch -= rp.GetCchLeft();
		rp.NextRun();
	}

	// If there is no link bit set on any part of the range, just return	
	if(cch <= 0)
		return;

	// Uh-oh, it's a bogus link.  Turn off the link bit.
	fDidClean = TRUE;

	CF._dwEffects = 0;

	// NB!  The undo system should have already figured out what should
	// happen with the selection by now.  We just want to modify the
	// formatting and not worry where the selection should go on undo/redo.
	rg.SetCharFormat(&CF, SCF_IGNORESELAE, publdr, CFM_LINK, CFM2_CHARFORMAT);
}

/*
 *	CDetectURL::MoveByDelimiters(&tpRef, iDir, grfDelimeters, pchStopChar)
 *
 *	@mfunc	returns the signed number of characters until the next delimiter 
 *			character in the given direction.
 *
 *	@rdesc	signed number of characters until next delimite
 */
LONG CDetectURL::MoveByDelimiters(
	const CTxtPtr&	tpRef,		//@parm cp/tp to start looking from
	LONG iDir,					//@parm Direction to look, must be 1 or -1
	DWORD grfDelimiters,		//@parm Eat or stop at different types of
								// characters. Use one of URL_EATWHITESPACE,
								// URL_EATNONWHITESPACE, URL_STOPATWHITESPACE
								// URL_STOPATNONWHITESPACE, URL_STOPATPUNCT,
								// URL_STOPATNONPUNCT ot URL_STOPATCHAR
	WCHAR *pchStopChar)			// @parm Out: delimiter we stopped at
								// In: additional char that stops us
								// when URL_STOPATCHAR is specified
{
	LONG	cch = 0;
	LONG	cchMax = (grfDelimiters & URL_EATWHITESPACE)	// Use huge # if
				   ? tomForward : URL_MAX_SIZE;				//  eating whitesp
	LONG	cchvalid = 0;
	WCHAR chScanned = URL_INVALID_DELIMITER;
	LONG	i;
	const WCHAR *pch;
	CTxtPtr	tp(tpRef);

	// Determine the scan mode: do we stop at white space, at punctuation, 
	// at a stop character? 
	BOOL fWhiteSpace	= (0 != (grfDelimiters & URL_STOPATWHITESPACE));
	BOOL fNonWhiteSpace = (0 != (grfDelimiters & URL_STOPATNONWHITESPACE));
	BOOL fPunct			= (0 != (grfDelimiters & URL_STOPATPUNCT));
	BOOL fNonPunct		= (0 != (grfDelimiters & URL_STOPATNONPUNCT));
	BOOL fStopChar		= (0 != (grfDelimiters & URL_STOPATCHAR));

	Assert(iDir == 1 || iDir == -1);
	Assert(fWhiteSpace || fNonWhiteSpace || (!fPunct && !fNonPunct));
	Assert(!fStopChar || NULL != pchStopChar);

	// Break anyway if we scanned more than URL_MAX_SIZE chars
	for (LONG cchScanned = 0; cchScanned < cchMax;)
	{
		// Get the text
		if(iDir == 1)
		{
			i = 0;
			pch = tp.GetPch(cchvalid);
		}
		else
		{
			i = -1;
			pch = tp.GetPchReverse(cchvalid);
			// This is a bit odd, but basically compensates for	the
			// backwards loop running one-off from the forwards loop
			cchvalid++;
		}

		if(!pch)
			goto exit;

		// Loop until we hit a character within criteria.  Note that for
		// our purposes, the embedding character counts as whitespace.

		while(abs(i) < cchvalid  && cchScanned < cchMax
			&& (IsURLWhiteSpace(pch[i]) ? !fWhiteSpace : !fNonWhiteSpace)
			&& (IsURLDelimiter(pch[i]) ? !fPunct : !fNonPunct)
			&& !(fStopChar && (*pchStopChar == chScanned) && (chScanned != URL_INVALID_DELIMITER))
			&& ((chScanned != CR && chScanned != LF) || fNonWhiteSpace))
		{	
			chScanned = pch[i];
			i += iDir;
			++cchScanned;
		}

		// If we're going backwards, i will be off by one; adjust
		if(iDir == -1)
		{
			Assert(i < 0 && cchvalid > 0);
			i++;
			cchvalid--;
		}

		cch += i;
		if(abs(i) < cchvalid)
			break;
		tp.Move(i);
	}

exit:	
	// Stop char parameter is present, fill it in
	// with the last character scanned and accepted
	if (pchStopChar)
		*pchStopChar = chScanned;

	return cch; 
}

/*
 *	CDetectURL::BraceMatch (chEnclosing)
 *
 *	@mfunc	returns the matching bracket to the one passed in.
 *			if the symbol passed in is not a bracket it returns 
 *			URL_INVALID_DELIMITER
 *
 *	@rdesc	returns bracket that matches chEnclosing
 */
WCHAR CDetectURL::BraceMatch(
	WCHAR chEnclosing)
{	
	// We're matching "standard" roman braces only. Thus only them may be used
	// to enclose URLs. This should be fine (after all, only Latin letters are allowed
	// inside URLs, right?).
	// I hope that the compiler converts this into some efficient code
	switch(chEnclosing)
	{
	case(TEXT('\"')): 
	case(TEXT('\'')): return chEnclosing;
	case(TEXT('(')): return TEXT(')');
	case(TEXT('<')): return TEXT('>');
	case(TEXT('[')): return TEXT(']');
	case(TEXT('{')): return TEXT('}');
	default: return URL_INVALID_DELIMITER;
	}
}

/*
 *	CDetectURL::GetAngleBracket	(&tpRef, cchMax)
 *
 *	@mfunc	Goes forward as long as the current paragraph 
 *			or URL_SCOPE_MAX not finding quotation marks and counts 
 *			those quotation marks
 *			returns their parity
 *
 *	@rdesc	LONG
 */
LONG CDetectURL::GetAngleBracket(
	CTxtPtr &tpRef,
	LONG	 cchMax)
{	
	CTxtPtr	tp(tpRef);
	LONG	cchvalid = 0;
	const WCHAR *pch;

	Assert (cchMax >= 0);

	if(!cchMax)
		cchMax = URL_MAX_SIZE;

	// Break anyway if we scanned more than cchLimit chars
	for (LONG cchScanned = 0; cchScanned < cchMax; NULL)
	{
		pch = tp.GetPch(cchvalid);

		if(!cchvalid)
			return 0;
		
		for (LONG i = 0; (i < cchvalid); ++i)
		{
			if(pch[i] == CR || pch[i] == LF || cchScanned >= cchMax)
				return 0;

			if(pch[i] == LEFTANGLEBRACKET)
				return 1;

			if(pch[i] == RIGHTANGLEBRACKET)
				return -1;
			++cchScanned;
		}
		tp.Move(i);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_callmgr.h ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	_CALLMGR.H	CCallMgr declaration |
 *
 *	Purpose:  The call manager controls various aspects of
 *		a client call chain, including re-entrancy management,
 *		undo contexts, and change notifications.
 *
 *	Author:	<nl>
 *		alexgo 2/8/96
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#ifndef _CALLMGR_H
#define _CALLMGR_H

class CTxtEdit;
class CCallMgr;

#include "textserv.h"

enum CompName
{
	COMP_UNDOBUILDER	= 1,	// currently, these two are only compatible
	COMP_REDOBUILDER	= 2,	// with CGenUndoBuilder undo contexts
	COMP_UNDOGUARD		= 3,
	COMP_SELPHASEADJUSTER = 4
};

/*
 *	IReEntrantComponent
 *
 *	@class	A base class/interface for objects that want to work with the call
 *			manager for special re-entrancy requirements.
 *
 *			This class is similar in spirit to ITxNotify, thus, it contains
 *			private data only accessible to CCallMgr
 */
class IReEntrantComponent
{
	friend class CCallMgr;

//@access	Public Data
public:
	virtual void OnEnterContext() = 0;		//@cmember Called when a 
											// context is entered
//@access	Private Data
private:
	CompName				_idName;		//@cmember Name for this component
	IReEntrantComponent *	_pnext;			//@cmember Next one in list
};
		
/*
 *
 *	CCallMgr
 *
 *	@class	A stack-based class to handle re-entrancy and notification
 *			management.  CCallMgr's are created on the stack on every
 *			important entry point.  If one already exists (i.e. the
 *			edit control has been re-entered), the Call Manager will 
 *			adjust appropriately.
 */

class CCallMgr
{
	friend class CGenUndoBuilder;

//@access	Public Methods
public:
	// Notification Methods
	void SetChangeEvent(CHANGETYPE fType);	//@cmember Something changed
	void ClearChangeEvent();				//@cmember Ignore change
											//@cmember Did something change?
	BOOL GetChangeEvent()	{return _pPrevcallmgr ? 
								_pPrevcallmgr->GetChangeEvent() : _fChange;}
	BOOL GetMaxText()		{return _pPrevcallmgr ? 
								_pPrevcallmgr->GetMaxText() : _fMaxText;}
	BOOL GetOutOfMemory()	{return _pPrevcallmgr ? 
								_pPrevcallmgr->GetOutOfMemory() : _fOutOfMemory;}
	void SetNewUndo();						//@cmember New undo action added
	void SetNewRedo();						//@cmember New redo action added
	void SetMaxText();						//@cmember Max text length reached
	void SetSelectionChanged();				//@cmember Selection changed
	void SetOutOfMemory();					//@cmember Out of memory hit
	void SetInProtected(BOOL f);			//@cmember Set if in protected
											//		 notification callback
	BOOL GetInProtected();					//@cmember Get InProtected flag

	// SubSystem Management methods
											//@cmember Register a component
											// for this call context
	void RegisterComponent(IReEntrantComponent *pcomp, CompName name);
											//@cmember Revoke a component from
											//		this call context
	void RevokeComponent(IReEntrantComponent *pcomp);
	
	IReEntrantComponent *GetComponent(CompName name);//@cmember Get registered
											//		component by name

	// General Methods
	BOOL IsReEntered() { return !!_pPrevcallmgr;} //@cmember Return TRUE if
											//		in a re-entrant state
	BOOL IsZombie() { return !_ped;}		//@cmember Zombie call

	// Constructor/Destructor
	CCallMgr(CTxtEdit *ped);				//@cmember constructor
	~CCallMgr();							//@cmember destructor


//@access	Private Methods and data
private:

	void SendAllNotifications();			//@cmember Flush any cached 
											// notifications 
	void NotifyEnterContext();				//@cmember Notify registered 
											// components of a new context.

	CTxtEdit *		_ped;					//@cmember Current edit context
	CCallMgr *		_pPrevcallmgr;			//@cmember Next highest call mgr
	IReEntrantComponent *_pcomplist;		//@cmember List of components
											// registered for this call context

	unsigned long	_fTextChanged	:1;		//@cmember Text changed
	unsigned long	_fChange		:1;		//@cmember Generic change
	unsigned long	_fNewUndo		:1;		//@cmember New undo action added
	unsigned long	_fNewRedo		:1;		//@cmember New redo action added
	unsigned long	_fMaxText		:1;		//@cmember Max text length reached
	unsigned long	_fSelChanged	:1;		//@cmember Selection changed
	unsigned long	_fOutOfMemory	:1;		//@cmember Out of memory

	unsigned long	_fInProtected	:1;		//@cmember if in EN_PROTECTED not.
};

#endif // _CALLMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\w32sys.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	w32sys.cpp - thin layer over Win32 services
 *	
 *	History: <nl>
 *		1/22/97 joseogl Created
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

// This prevents the "W32->" prefix from being prepended to our identifiers.

#define W32SYS_CPP

#include "_common.h"
#include "_host.h"
#include "_font.h"
#include "_edit.h"

//
//Cache of Type 1 data. See also clasifyc.cpp and rgbCharClass in
//rtflex.cpp.
// Used by GetStringTypeEx
//
const unsigned short rgctype1Ansi[256] = {
0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, //0x00
0x0020, 0x0068, 0x0028, 0x0028, 0x0028, 0x0028, 0x0020, 0x0020, //0x08
0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, //0x10
0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, //0x18
0x0048, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, //0x20
0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, //0x28
0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084, 0x0084, //0x30
0x0084, 0x0084, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, //0x38
0x0010, 0x0181, 0x0181, 0x0181, 0x0181, 0x0181, 0x0181, 0x0101, //0x40
0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, //0x48
0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, //0x50
0x0101, 0x0101, 0x0101, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, //0x58
0x0010, 0x0182, 0x0182, 0x0182, 0x0182, 0x0182, 0x0182, 0x0102, //0x60
0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, //0x68
0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, //0x70
0x0102, 0x0102, 0x0102, 0x0010, 0x0010, 0x0010, 0x0010, 0x0020, //0x78
0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, //0x80
0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, //0x88
0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, //0x90
0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, //0x98
0x0048, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, //0xA0
0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, //0xA8
0x0010, 0x0010, 0x0014, 0x0014, 0x0010, 0x0010, 0x0010, 0x0010, //0xB0
0x0010, 0x0014, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, //0xB8
0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, //0xC0
0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, //0xC8
0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0010, //0xD0
0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0102, //0xD8
0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, //0xE0
0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, //0xE8
0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, //0xF0
0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102, 0x0102};//0xF8

//
//Cache of Type 3 data. 
//
const unsigned short rgctype3Ansi[256] = {
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, //0x00
0x0000, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0000, 0x0000, //0x08
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, //0x10
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, //0x18
0x0048, 0x0048, 0x0448, 0x0048, 0x0448, 0x0048, 0x0048, 0x0440, //0x20
0x0048, 0x0048, 0x0048, 0x0048, 0x0048, 0x0440, 0x0048, 0x0448, //0x28
0x0040, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040, 0x0040, //0x30
0x0040, 0x0040, 0x0048, 0x0048, 0x0048, 0x0448, 0x0048, 0x0048, //0x38
0x0448, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, //0x40
0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, //0x48
0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, //0x50
0x8040, 0x8040, 0x8040, 0x0048, 0x0448, 0x0048, 0x0448, 0x0448, //0x58
0x0448, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, //0x60
0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, //0x68
0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, 0x8040, //0x70
0x8040, 0x8040, 0x8040, 0x0048, 0x0048, 0x0048, 0x0448, 0x0000, //0x78
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, //0x80
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, //0x88
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, //0x90
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, //0x98
0x0008, 0x0008, 0x0048, 0x0048, 0x0008, 0x0048, 0x0048, 0x0008, //0xA0
0x0408, 0x0008, 0x0400, 0x0008, 0x0048, 0x0408, 0x0008, 0x0448, //0xA8
0x0008, 0x0008, 0x0000, 0x0000, 0x0408, 0x0008, 0x0008, 0x0008, //0xB0
0x0408, 0x0000, 0x0400, 0x0008, 0x0000, 0x0000, 0x0000, 0x0008, //0xB8
0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8000, 0x8003, //0xC0
0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, //0xC8
0x8000, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x0008, //0xD0
0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8000, 0x8000, //0xD8
0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8000, 0x8003, //0xE0
0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, //0xE8
0x8000, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, //0xF0
0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8003, 0x8000, 0x8003};//0xF8

// Include the appropriate implementation.
#include W32INCLUDE
#if 0
// Could be one of.
// This list is here to allow the dependency generator to work.
#include "w32win32.cpp"
#include "w32wince.cpp"
#endif

ASSERTDATA

/*
 * rgCodePage, rgCharSet, rgFontSig
 *
 * Locally used arrays that contain CodePage, CharSet, and FontSig info
 * and indexed by iCharRep, the character repertoire index. When a char
 * repertoire has a CharSet and CodePage, it has an entry in rgCharSet 
 * and in rgCodePage.  Unicode-only repertoires follow the CharSet 
 * repertoires in the rgFontSig table.  It is essential to keep these
 * three tables in sync and they used to be combined into a single table.
 * They are separate here to save on RAM.
 */
static const WORD rgCodePage[] =
{
//	  0		1	  2		3	  4		5	  6		7	  8		9
	1252, 1250, 1251, 1253, 1254, 1255, 1256, 1257, 1258,   0,
	  42,  874,  932,  936,  949,  950,  437,  850, 10000
};

static const BYTE rgCharSet[] =
{
//			0					1					2				3
	ANSI_CHARSET,		EASTEUROPE_CHARSET,	RUSSIAN_CHARSET, GREEK_CHARSET,
	TURKISH_CHARSET,	HEBREW_CHARSET,		ARABIC_CHARSET,  BALTIC_CHARSET,
	VIETNAMESE_CHARSET,	DEFAULT_CHARSET,	SYMBOL_CHARSET,	 THAI_CHARSET,
	SHIFTJIS_CHARSET,	GB2312_CHARSET,		HANGUL_CHARSET,  CHINESEBIG5_CHARSET,
	PC437_CHARSET,		OEM_CHARSET,		MAC_CHARSET
};

#define CCHARSET	ARRAY_SIZE(rgCharSet)
#define CCODEPAGE	ARRAY_SIZE(rgCodePage)

#define	LANG_PRC		MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)
#define	LANG_SINGAPORE	MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE)

const BYTE rgCharRepfromLID[] = {
//  Char Repertoire		PLID	primary language
//  --------------------------------------------
	DEFAULT_INDEX,		// 00 - undefined
	ARABIC_INDEX,		// 01 - Arabic
	RUSSIAN_INDEX,		// 02 - Bulgarian
	ANSI_INDEX,			// 03 - Catalan
	GB2312_INDEX,		// 04 - PRC, Singapore (Taiwan, Hong Kong SAR, Macau SAR are 950)
	EASTEUROPE_INDEX,	// 05 - Czech
	ANSI_INDEX,			// 06 - Danish
	ANSI_INDEX,			// 07 - German
	GREEK_INDEX,		// 08 - Greek
	ANSI_INDEX,			// 09 - English
	ANSI_INDEX,			// 0A - Spanish
	ANSI_INDEX,			// 0B - Finnish
	ANSI_INDEX,			// 0C - French
	HEBREW_INDEX,		// 0D - Hebrew
	EASTEUROPE_INDEX,	// 0E - Hungarian
	ANSI_INDEX,			// 0F - Icelandic
	ANSI_INDEX,			// 10 - Italian
	SHIFTJIS_INDEX,		// 11 - Japan
	HANGUL_INDEX,		// 12 - Korea
	ANSI_INDEX,			// 13 - Dutch
	ANSI_INDEX,			// 14 - Norwegian
	EASTEUROPE_INDEX,	// 15 - Polish
	ANSI_INDEX,			// 16 - Portuguese
	DEFAULT_INDEX,		// 17 - Rhaeto-Romanic
	EASTEUROPE_INDEX,	// 18 - Romanian
	RUSSIAN_INDEX,		// 19 - Russian
	EASTEUROPE_INDEX,	// 1A - Croatian
	EASTEUROPE_INDEX,	// 1B - Slovak
	EASTEUROPE_INDEX,	// 1C - Albanian
	ANSI_INDEX,			// 1D - Swedish
	THAI_INDEX,			// 1E - Thai
	TURKISH_INDEX,		// 1F - Turkish
	ARABIC_INDEX,		// 20 - Urdu
	ANSI_INDEX,			// 21 - Indonesian
	RUSSIAN_INDEX,		// 22 - Ukranian
	RUSSIAN_INDEX,		// 23 - Byelorussian
	EASTEUROPE_INDEX,	// 24 - Slovenian
	BALTIC_INDEX,		// 25 - Estonia
	BALTIC_INDEX,		// 26 - Latvian
	BALTIC_INDEX,		// 27 - Lithuanian
	DEFAULT_INDEX,		// 28 - Tajik - Tajikistan (undefined)
	ARABIC_INDEX,		// 29 - Farsi
	VIET_INDEX,			// 2A - Vietnanese
	ARMENIAN_INDEX,		// 2B - Armenian (Unicode only)
	TURKISH_INDEX,		// 2C - Azeri (Latin, can be Cyrillic...)
	ANSI_INDEX,			// 2D - Basque
	DEFAULT_INDEX,		// 2E - Sorbian
	RUSSIAN_INDEX,		// 2F - fyro Macedonian
	ANSI_INDEX,			// 30 - Sutu
	ANSI_INDEX,			// 31 - Tsonga
	ANSI_INDEX,			// 32 - Tswana
	ANSI_INDEX,			// 33 - Venda
	ANSI_INDEX,			// 34 - Xhosa
	ANSI_INDEX,			// 35 - Zulu
	ANSI_INDEX,			// 36 - Africaans
	GEORGIAN_INDEX,		// 37 - Georgian (Unicode only)
	ANSI_INDEX,			// 38 - Faerose
	DEVANAGARI_INDEX,	// 39 - Hindi (Indic)
	ANSI_INDEX,			// 3A - Maltese
	ANSI_INDEX,			// 3B - Sami
	ANSI_INDEX,			// 3C - Gaelic
	HEBREW_INDEX,		// 3D - Yiddish
	ANSI_INDEX,			// 3E - Malaysian
	RUSSIAN_INDEX,		// 3F - Kazakh
	ANSI_INDEX,			// 40 - Kirghiz
	ANSI_INDEX,			// 41 - Swahili
	ANSI_INDEX,			// 42 - Turkmen
	TURKISH_INDEX,		// 43 - Uzbek (Latin, can be Cyrillic...)
	ANSI_INDEX,			// 44 - Tatar
	BENGALI_INDEX,		// 45 - Bengali (Indic)
	GURMUKHI_INDEX,		// 46 - Punjabi(Gurmukhi) (Indic)
	GUJARATI_INDEX,		// 47 - Gujarati (Indic)
	ORIYA_INDEX,		// 48 - Oriya (Indic)
	TAMIL_INDEX,		// 49 - Tamil (Indic)
	TELUGU_INDEX,		// 4A - Telugu (Indic)
	KANNADA_INDEX,		// 4B - Kannada (Indic)
	MALAYALAM_INDEX,	// 4C - Malayalam (Indic)
	BENGALI_INDEX,		// 4D - Assamese (Indic)
	DEVANAGARI_INDEX,	// 4E - Marathi (Indic)
	DEVANAGARI_INDEX,	// 4F - Sanskrit (Indic)
	MONGOLIAN_INDEX,	// 50 - Mongolian (Mongolia)
	TIBETAN_INDEX,		// 51 - Tibetan (Tibet)
	ANSI_INDEX,			// 52 - Welsh (Wales)
	KHMER_INDEX,		// 53 - Khmer (Cambodia)
	LAO_INDEX,			// 54 - Lao (Lao)
	MYANMAR_INDEX,		// 55 - Burmese (Myanmar)
	ANSI_INDEX,			// 56 - Gallego (Portugal)
	DEVANAGARI_INDEX,	// 57 - Konkani (Indic)
	BENGALI_INDEX,		// 58 - Manipuri (Indic)
	GURMUKHI_INDEX,		// 59 - Sindhi (Indic)
	SYRIAC_INDEX,		// 5A - Syriac (Syria)
	SINHALA_INDEX,		// 5B - Sinhalese (Sri Lanka)
	CHEROKEE_INDEX,		// 5C - Cherokee
	ABORIGINAL_INDEX,	// 5D - Inuktitut
	ETHIOPIC_INDEX,		// 5E - Amharic (Ethiopic)
	DEFAULT_INDEX,		// 5F - Tamazight (Berber/Arabic) also Latin
	DEFAULT_INDEX,		// 60 - Kashmiri
	DEVANAGARI_INDEX,	// 61 - Nepali (Nepal)
	ANSI_INDEX,			// 62 - Frisian (Netherlands)
	ARABIC_INDEX,		// 63 - Pashto (Afghanistan)
	ANSI_INDEX,			// 64 - Filipino 
	THAANA_INDEX		// 65 - Maldivian (Maldives (Thaana))
};

#define CLID	ARRAY_SIZE(rgCharRepfromLID)

#define lidAzeriCyrillic	0x82C
#define lidSerbianCyrillic	0xC1A
#define lidUzbekCyrillic	0x843

// Our interface pointer
CW32System *W32;

CW32System::CW32System( )
{
	if(GetVersion(&_dwPlatformId, &_dwMajorVersion, &_dwMinorVersion))
	{
		_fHaveAIMM = FALSE;
		_fHaveIMMEShare = FALSE;
		_fHaveIMMProcs = FALSE;
		_fLoadAIMM10 = FALSE;
		_pIMEShare = NULL;
		_icr3DDarkShadow = COLOR_WINDOWFRAME;
		if(_dwMajorVersion >= VERS4)
			_icr3DDarkShadow = COLOR_3DDKSHADOW;
	}

	_syslcid = GetSystemDefaultLCID();
	_ACP = ::GetACP();

#ifndef NOMAGELLAN
    // BUG FIX #6089
    // we need this for backward compatibility of mouse wheel
    _MSMouseRoller = RegisterWindowMessageA(MSH_MOUSEWHEEL);
#endif

#ifndef NOFEPROCESSING
	// Register IME messages
	_MSIMEMouseMsg = RegisterWindowMessageA("MSIMEMouseOperation");
	_MSIMEDocFeedMsg = RegisterWindowMessageA("MSIMEDocumentFeed");	
	_MSIMEQueryPositionMsg = RegisterWindowMessageA("MSIMEQueryPosition");	
	_MSIMEServiceMsg = RegisterWindowMessageA("MSIMEService");

	// Check Reconvert messages unless we are running in NT5
	if (_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ||
		(_dwPlatformId == VER_PLATFORM_WIN32_NT && _dwMajorVersion <= 4))
	{
		_MSIMEReconvertMsg = RegisterWindowMessageA("MSIMEReconvert");
		_MSIMEReconvertRequestMsg = RegisterWindowMessageA("MSIMEReconvertRequest");

	}
	else
	{
		_MSIMEReconvertMsg = 0;			// For reconversion
		_MSIMEReconvertRequestMsg = 0;	// For reconversion request
	}
#endif
}

CW32System::~CW32System()
{
	if (_arTmpDisplayAttrib)
	{
		delete _arTmpDisplayAttrib;
		_arTmpDisplayAttrib = NULL;
	}

	FreeOle();
	if (_hdcScreen)
		DeleteDC(_hdcScreen);
	if (_hDefaultFont)
		DeleteObject(_hDefaultFont);

}

///////////////////////////////  Memory  and CRT utility functions  /////////////////////////////////
extern "C" {

#ifdef NOCRTOBJS

// Havinf these functions defined here helps eliminate the dependency on the CRT
// Some function definitions copied from CRT sources.
// Typically, it is better to get the objs for these objects from the CRT
// without dragging in the whole thing.

/***
*int memcmp(buf1, buf2, count) - compare memory for lexical order
*
*Purpose:
*       Compares count bytes of memory starting at buf1 and buf2
*       and find if equal or which one is first in lexical order.
*
*Entry:
*       void *buf1, *buf2 - pointers to memory sections to compare
*       size_t count - length of sections to compare
*
*Exit:
*       returns < 0 if buf1 < buf2
*       returns  0  if buf1 == buf2
*       returns > 0 if buf1 > buf2
*
*Exceptions:
*
*******************************************************************************/

int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}

/***
*char *memset(dst, val, count) - sets "count" bytes at "dst" to "val"
*
*Purpose:
*       Sets the first "count" bytes of the memory starting
*       at "dst" to the character value "val".
*
*Entry:
*       void *dst - pointer to memory to fill with val
*       int val   - value to put in dst bytes
*       size_t count - number of bytes of dst to fill
*
*Exit:
*       returns dst, with filled bytes
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl memset (
        void *dst,
        int val,
        size_t count
        )
{
        void *start = dst;

        while (count--) {
                *(char *)dst = (char)val;
                dst = (char *)dst + 1;
        }

        return(start);
}

/***
*memcpy - Copy source buffer to destination buffer
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propogation.
*
*       For cases where propogation must be avoided, memmove() must be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }

        return(ret);
}

void * __cdecl memmove(void *dst, const void *src, size_t count)
{
	void * ret = dst;

	if (dst <= src || (char *)dst >= ((char *)src + count)) {
		/*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
         while (count--) {
			*(char *)dst = *(char *)src;
            dst = (char *)dst + 1;
            src = (char *)src + 1;
         }
	}
    else
	{
		/*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;

        while (count--) {
			*(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
	}

	return(ret);
}

/***
*strlen - return the length of a null-terminated string
*
*Purpose:
*       Finds the length in bytes of the given string, not including
*       the final null character.
*
*Entry:
*       const char * str - string whose length is to be computed
*
*Exit:
*       length of the string "str", exclusive of the final null byte
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl strlen (
        const char * str
        )
{
        const char *eos = str;

        while( *eos++ ) ;

        return( (int)(eos - str - 1) );
}

#endif

#ifdef DEBUG

// These functions are only used for RTF logging

/***
*strcmp - compare two strings, returning less than, equal to, or greater than
*
*Purpose:
*       STRCMP compares two strings and returns an integer
*       to indicate whether the first is less than the second, the two are
*       equal, or whether the first is greater than the second.
*
*       Comparison is done byte by byte on an UNSIGNED basis, which is to
*       say that Null (0) is less than any other character (1-255).
*
*Entry:
*       const char * src - string for left-hand side of comparison
*       const char * dst - string for right-hand side of comparison
*
*Exit:
*       returns -1 if src <  dst
*       returns  0 if src == dst
*       returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl CW32System::strcmp (
        const char * src,
        const char * dst
        )
{
        int ret = 0 ;

        while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)
                ++src, ++dst;

        if ( ret < 0 )
                ret = -1 ;
        else if ( ret > 0 )
                ret = 1 ;

        return( ret );
}

/***
*char *strcat(dst, src) - concatenate (append) one string to another
*
*Purpose:
*       Concatenates src onto the end of dest.  Assumes enough
*       space in dest.
*
*Entry:
*       char *dst - string to which "src" is to be appended
*       const char *src - string to be appended to the end of "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl CW32System::strcat (
        char * dst,
        const char * src
        )
{
        char * cp = dst;

        while( *cp )
                cp++;                   /* find end of dst */

        while( *cp++ = *src++ ) ;       /* Copy src to end of dst */

        return( dst );                  /* return dst */

}


char * __cdecl CW32System::strrchr (
        const char * string,
        int ch
        )
{
        char *start = (char *)string;

        while (*string++)                       /* find end of string */
                ;
                                                /* search towards front */
        while (--string != start && *string != (char)ch)
                ;

        if (*string == (char)ch)                /* char found ? */
                return( (char *)string );

        return(NULL);
}

#endif

// This function in the runtime traps virtual method calls
int __cdecl _purecall()
{
	AssertSz(FALSE, "Fatal Error : Virtual method called in RichEdit");
	return 0;
}

// To avoid brionging in floating point lib
extern int _fltused = 1;

} // end of extern "C" block

size_t CW32System::wcslen(const wchar_t *wcs)
{
        const wchar_t *eos = wcs;

        while( *eos++ ) ;

        return( (size_t)(eos - wcs - 1) );
}

wchar_t * CW32System::wcscpy(wchar_t * dst, const wchar_t * src)
{
        wchar_t * cp = dst;

        while( *cp++ = *src++ )
                ;               /* Copy src over dst */

        return( dst );
}

int CW32System::wcscmp(const wchar_t * src, const wchar_t * dst)
{
	int ret = 0;

	while( ! (ret = (int)(*src - *dst)) && *dst)
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}

int CW32System::wcsicmp(const wchar_t * src, const wchar_t * dst)
{
	int ret = 0;
	wchar_t s,d;
	
	do
	{
		s = ((*src <= L'Z') && (*dst >= L'A'))
			? *src - L'A' + L'a'
			: *src;
		d = ((*dst <= L'Z') && (*dst >= L'A'))
			? *dst - L'A' + L'a'
			: *dst;
		src++;
		dst++;
	} while (!(ret = (int)(s - d)) && d);

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}

wchar_t * CW32System::wcsncpy (wchar_t * dest, const wchar_t * source, size_t count)
{
	wchar_t *start = dest;
	
	while (count && (*dest++ = *source++))	  /* copy string */
		count--;
	
	if (count)								/* pad out with zeroes */
		while (--count)
			*dest++ = L'\0';
		
	return(start);
}

int CW32System::wcsnicmp (const wchar_t * first, const wchar_t * last, size_t count)
{
	wchar_t f,l;
	int result = 0;
	
	if ( count ) {
		do {
			f = ((*first <= L'Z') && (*first >= L'A'))
				? *first - L'A' + L'a'
				: *first;
			l = ((*last <= L'Z') && (*last >= L'A'))
				? *last - L'A' + L'a'
				: *last;
			first++;
			last++;
		} while ( (--count) && f && (f == l) );
		result = (int)(f - l);
	}
	return result;
}

unsigned long CW32System::strtoul(const char *nptr)
{
	const char *p;
	char c;
	unsigned long number;
	unsigned digval;
	unsigned long maxval;
	
	p = nptr;                       /* p is our scanning pointer */
	number = 0;                     /* start with zero */
	
	c = *p++;                       /* read char */
	while ( c == ' ' || c == '\t' )
		c = *p++;               /* skip whitespace */
	
	if (c == '-') {
		return 0;
	}
		
	/* if our number exceeds this, we will overflow on multiply */
	maxval = ULONG_MAX / 10;
	
	for (;;) {      /* exit in middle of loop */
		/* convert c to value */
		digval = (unsigned char) c;
		if ( digval >= '0' && digval <= '9' )
			digval = c - '0';
		else
			return number;
		
		/* we now need to compute number = number * base + digval,
		but we need to know if overflow occured.  This requires
		a tricky pre-check. */
		
		if (number < maxval || (number == maxval &&
			(unsigned long)digval <= ULONG_MAX % 10)) {
			/* we won't overflow, go ahead and multiply */
			number = number * 10 + digval;
		}
		else
			return 0;
		
		c = *p++;               /* read next digit */
	}
}


// CW32System static members
BYTE	CW32System::_fLRMorRLM;
BYTE	CW32System::_fHaveIMMProcs;
BYTE	CW32System::_fHaveIMMEShare;
BYTE	CW32System::_fHaveAIMM;
BYTE	CW32System::_fLoadAIMM10;
UINT	CW32System::_fRegisteredXBox;
DWORD	CW32System::_dwPlatformId;
LCID	CW32System::_syslcid;
DWORD	CW32System::_dwMajorVersion;
DWORD	CW32System::_dwMinorVersion;
INT		CW32System::_icr3DDarkShadow;
UINT	CW32System::_MSIMEMouseMsg;	
UINT	CW32System::_MSIMEReconvertMsg;
UINT	CW32System::_MSIMEReconvertRequestMsg;	
UINT	CW32System::_MSIMEDocFeedMsg;
UINT	CW32System::_MSIMEQueryPositionMsg;
UINT	CW32System::_MSIMEServiceMsg;
UINT	CW32System::_MSMouseRoller;
HDC		CW32System::_hdcScreen;
CIMEShare* CW32System::_pIMEShare;
CTmpDisplayAttrArray* CW32System::_arTmpDisplayAttrib;

// CW32System static system parameter members
BOOL	CW32System::_fSysParamsOk;
BOOL 	CW32System::_fUsePalette;
INT 	CW32System::_dupSystemFont;
INT 	CW32System::_dvpSystemFont;
INT		CW32System::_ySysFontLeading;
LONG 	CW32System::_xPerInchScreenDC;
LONG 	CW32System::_yPerInchScreenDC;
INT		CW32System::_cxBorder;
INT		CW32System::_cyBorder;
INT		CW32System::_cxVScroll;
INT		CW32System::_cyHScroll;
LONG 	CW32System::_dxSelBar;
INT		CW32System::_cxDoubleClk;
INT		CW32System::_cyDoubleClk;	
INT		CW32System::_DCT;
WORD	CW32System::_nScrollInset;
WORD	CW32System::_nScrollDelay;
WORD	CW32System::_nScrollInterval;
WORD	CW32System::_nScrollHAmount;
WORD	CW32System::_nScrollVAmount;
WORD	CW32System::_nDragDelay;
WORD	CW32System::_nDragMinDist;
WORD	CW32System::_wDeadKey;
WORD	CW32System::_wKeyboardFlags;
DWORD	CW32System::_dwNumKeyPad;
WORD	CW32System::_fFEFontInfo;
BYTE	CW32System::_bDigitSubstMode;
BYTE	CW32System::_bCharSetSys;
HCURSOR CW32System::_hcurSizeNS;
HCURSOR CW32System::_hcurSizeWE;
HCURSOR CW32System::_hcurSizeNWSE;
HCURSOR CW32System::_hcurSizeNESW;
LONG	CW32System::_cLineScroll;
HFONT	CW32System::_hSystemFont;
HFONT	CW32System::_hDefaultFont;
HKL		CW32System::_hklCurrent;
HKL		CW32System::_hkl[NCHARREPERTOIRES];
INT		CW32System::_sysiniflags;
UINT	CW32System::_ACP;

DWORD	CW32System::_cRefs;

#ifndef NODRAFTMODE
CW32System::DraftModeFontInfo CW32System::_draftModeFontInfo;
#endif

/*
 *  CW32System::MbcsFromUnicode(pstr, cch, pwstr, cwch, codepage, flags)
 *
 *  @mfunc
 *		Converts a string to MBCS from Unicode. If cwch equals -1, the string
 *		is assumed to be NULL terminated.  -1 is supplied as a default argument.
 *
 *	@rdesc
 *		If [pstr] is NULL or [cch] is 0, 0 is returned.  Otherwise, the number
 *		of characters converted, including the terminating NULL, is returned
 *		(note that converting the empty string will return 1).  If the
 *		conversion fails, 0 is returned.
 *
 *	@devnote
 *		Modifies pstr
 */
int CW32System::MbcsFromUnicode(
	LPSTR	pstr,		//@parm Buffer for MBCS string
	int		cch,		//@parm Size of MBCS buffer, incl space for NULL terminator
	LPCWSTR pwstr,		//@parm Unicode string to convert
	int		cwch,		//@parm # chars in Unicode string, incl NULL terminator
	UINT	codepage,	//@parm Code page to use (CP_ACP is default)
	UN_FLAGS flags)		//@parm Indicates if WCH_EMBEDDING should be handled specially
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CW32System::MbcsFromUnicode");

	LONG			i;
	LPWSTR			pwstrtemp;
	CTempWcharBuf	twcb;

    Assert(cch >= 0 && pwstr && (cwch == -1 || cwch > 0));

    if(!pstr || !cch)
        return 0;

	// If we have to convert WCH_EMBEDDINGs, scan through and turn
	// them into spaces.  This is necessary for RichEdit 1.0 compatibity,
	// as WideCharToMultiByte will turn WCH_EMBEDDING into a '?'
	if(flags == UN_CONVERT_WCH_EMBEDDING)
	{
		if(cwch == -1) 
			cwch = wcslen(pwstr) + 1;

		pwstrtemp = twcb.GetBuf(cwch);
		if(pwstrtemp)
		{
			for(i = 0; i < cwch; i++)
			{
				pwstrtemp[i] = pwstr[i];

				if(pwstr[i] == WCH_EMBEDDING)
					pwstrtemp[i] = L' ';
			}
			pwstr = pwstrtemp;
		}
	}
    return WCTMB(codepage, 0, pwstr, cwch, pstr, cch, NULL, NULL, NULL);
}

/*
 *  CW32System::UnicodeFromMbcs(pwstr, cwch, pstr, cch,	uiCodePage)
 *
 *	@mfunc
 *		Converts a string to Unicode from MBCS.  If cch equals -1, the string
 *		is assumed to be NULL terminated.  -1 is supplied as a default
 *		argument.
 *
 *	@rdesc
 *		If [pwstr] is NULL or [cwch] is 0, 0 is returned.  Otherwise,
 *		the number of characters converted, including the terminating
 *		NULL, is returned (note that converting the empty string will
 *		return 1).  If the conversion fails, 0 is returned.
 *
 *	@devnote
 *		Modifies:   [pwstr]
 */
int CW32System::UnicodeFromMbcs(
	LPWSTR	pwstr,		//@parm Buffer for Unicode string
	int		cwch,		//@parm Size of Unicode buffer, incl space for NULL terminator
	LPCSTR	pstr,		//@parm MBCS string to convert
	int		cch,		//@parm # chars in MBCS string, incl NULL terminator
	UINT	uiCodePage)	//@parm Code page to use (CP_ACP is default)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CW32System::UnicodeFromMbcs");

    Assert(pstr && cwch >= 0 && (cch == -1 || cch >= 0));

    if(!pwstr || !cwch)
        return 0;

	if(cch >= 3 && IsUTF8BOM((BYTE *)pstr))
	{
		uiCodePage = CP_UTF8;				// UTF-8 BOM file
		cch -= 3;							// Eat the BOM
		pstr += 3;
	}
    return MBTWC(uiCodePage, 0, pstr, cch, pwstr, cwch, NULL);
}

/*
 *	CW32System::TextHGlobalAtoW (hglobalA)
 *
 *	@func
 *		translates a unicode string contained in an hglobal and
 *		wraps the ansi version in another hglobal
 *
 *	@devnote 
 *		does *not* free the incoming hglobal
 */
HGLOBAL	CW32System::TextHGlobalAtoW(HGLOBAL hglobalA)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CW32System::TextHGlobalAtoW");

	if(!hglobalA)
		return NULL;

	HGLOBAL hnew;
	LPSTR	pstr = (LPSTR)GlobalLock(hglobalA);
	DWORD	dwSize = GlobalSize(hglobalA);
	LONG	cbSize = (dwSize + 1) * sizeof(WCHAR);
	
    hnew = GlobalAlloc(GMEM_FIXED, cbSize);
	if(hnew)
	{
		LPWSTR pwstr = (LPWSTR)GlobalLock(hnew);
		UnicodeFromMbcs(pwstr, dwSize + 1, pstr);
		GlobalUnlock(hnew);		
	}
	GlobalUnlock(hglobalA);
	return hnew;
}

/*
 *	CW32System::TextHGlobalWtoA(hglobalW)
 *
 *	@func
 *		converts a unicode text hglobal into a newly allocated
 *		allocated hglobal with ANSI data
 *
 *	@devnote
 *		does *NOT* free the incoming hglobal 
 */
HGLOBAL CW32System::TextHGlobalWtoA(
	HGLOBAL hglobalW )
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CW32System::TextHGlobalWtoA");

	if(!hglobalW)
		return NULL;

	HGLOBAL hnew = NULL;
	LPWSTR 	pwstr = (LPWSTR)GlobalLock(hglobalW);
	DWORD	dwSize = GlobalSize(hglobalW);
	LONG	cbSize = (dwSize * 2) * sizeof(CHAR);
	hnew = GlobalAlloc(GMEM_FIXED, cbSize);

	if( hnew )
	{
		LPSTR pstr = (LPSTR)GlobalLock(hnew);
		MbcsFromUnicode(pstr, cbSize, pwstr );
		GlobalUnlock(hnew);
	}
	GlobalUnlock(hglobalW);
	return hnew;
}	

/*
 *	CW32System::CharRepFromLID (lid, fPlane2)
 *
 *	@mfunc		Maps a language ID to a character repertoire
 *
 *	@rdesc		returns character repertoire (writing system) corresponding to LID
 *
 *	@devnote: 
 *		This routine takes advantage of the fact that except for Chinese,
 *		the code page is determined uniquely by the primary language ID,
 *		which is given by the low-order 10 bits of the lcid.
 */
UINT CW32System::CharRepFromLID(
	WORD lid,		//@parm Language ID to map to code page
	BOOL fPlane2)	//@parm TRUE if plane-2 CharRep needed
{
	UINT j = PRIMARYLANGID(lid);			// j = primary language (PLID)

	if(j >= LANG_CROATIAN)					// PLID = 0x1A
	{
		if (lid == lidSerbianCyrillic ||	// Special case for LID = 0xC1A
			lid == lidAzeriCyrillic	  ||
			lid == lidUzbekCyrillic)
		{
			return RUSSIAN_INDEX;
		}
		if(j >= CLID)						// Most languages above table 
			return ANSI_INDEX;
	}

	j = rgCharRepfromLID[j];				// Translate PLID to CharRep

	if(!IsFECharRep(j))
		return j;

	if(j == GB2312_INDEX && lid != LANG_PRC && lid != LANG_SINGAPORE)
		j = BIG5_INDEX;						// Taiwan, Hong Kong SAR, Macau SAR

	return fPlane2 ? j + JPN2_INDEX - SHIFTJIS_INDEX : j;
}

/*
 *	CW32System::GetLocaleCharRep ()
 *
 *	@mfunc		Maps an LCID for thread to a Char repertoire
 *
 *	@rdesc		returns Code Page
 */
UINT CW32System::GetLocaleCharRep()
{
#ifdef DEBUG
	UINT cpg = W32->DebugDefaultCpg();
	if (cpg)
		return CharRepFromCodePage(cpg);
#endif
	LCID lcid;
#ifdef UNDER_CE
	lcid = ::GetSystemDefaultLCID();
#else
	lcid = GetThreadLocale();
#endif
	return CharRepFromLID(LOWORD(lcid));
}

/*
 *	CW32System::GetKeyboardLCID ()
 *
 *	@mfunc		Gets LCID for keyboard active on current thread
 *
 *	@rdesc		returns Code Page
 */
LCID CW32System::GetKeyboardLCID(DWORD dwMakeAPICall)
{
	return (WORD)GetKeyboardLayout(dwMakeAPICall);
}

/*
 *	CW32System::GetKeyboardCharRep ()
 *
 *	@mfunc		Gets Code Page for keyboard active on current thread
 *
 *	@rdesc		returns Code Page
 */
UINT CW32System::GetKeyboardCharRep(DWORD dwMakeAPICall)
{
	return CharRepFromLID((WORD)GetKeyboardLayout(dwMakeAPICall));
}

/*
 *	CW32System::InitKeyboardFlags ()
 *
 *	@mfunc
 *		Initializes keyboard flags. Used when control gains focus. Note that
 *		Win95 doesn't support VK_RSHIFT, so if either shift key is pressed
 *		when focus is regained, it'll be assumed to be the left shift.
 */
void CW32System::InitKeyboardFlags()
{
	_wKeyboardFlags = 0;
	if(GetKeyState(VK_SHIFT) < 0)
		SetKeyboardFlag(GetKeyState(VK_RSHIFT) < 0 ? RSHIFT : LSHIFT);
}

/*
 *	CW32System::GetKeyboardFlag (dwKeyMask, wKey)
 *
 *	@mfunc
 *		Return whether wKey is depressed. Check with OS for agreement.
 *		If OS says it isn't depressed, reset our internal flags. In
 *		any event, return TRUE/FALSE in agreement with the system (bad
 *		client may have eaten keystrokes, thereby destabilizing our 
 *		internal keyboard state.
 *
 *	@rdesc
 *		TRUE iff wKey is depressed
 */
BOOL CW32System::GetKeyboardFlag (
	WORD dwKeyMask,	//@parm _wKeyboardFlags mask like ALT, CTRL, or SHIFT
	WORD wKey)		//@parm VK_xxx like VK_MENU, VK_CONTROL, or VK_SHIFT
{
	BOOL fFlag = (GetKeyboardFlags() & dwKeyMask) != 0;

	if(fFlag ^ ((GetKeyState(wKey) & 0x8000) != 0))
	{	
		// System doesn't agree with our internal state
		// (bad client ate a WM_KEYDOWN)
		if(fFlag)
		{
			ResetKeyboardFlag(dwKeyMask);
			return FALSE;					
		}
		// Don't set an internal _wKeyboardFlag since we check for it
		// anyhow and client might not send WM_KEYUP either
		return TRUE;
	}							
	return fFlag;
}

/*
 *	CW32System::IsAlef(ch)
 *
 *	@func
 *		Used to determine if base character is a Arabic-type Alef.
 *
 *	@rdesc
 *		TRUE iff the base character is an Arabic-type Alef.
 *
 *	@comm
 *		AlefWithMaddaAbove, AlefWithHamzaAbove, AlefWithHamzaBelow,
 *		and Alef are valid matches.
 */
BOOL CW32System::IsAlef(
	WCHAR ch)
{
	return IN_RANGE(0x622, ch, 0x627) && ch != 0x624 && ch != 0x626;
}

/*
 *	CW32System::IsBiDiLcid(lcid)
 *
 *	@func
 *		Return TRUE if lcid corresponds to an RTL language
 *
 *	@rdesc
 *		TRUE if lcid corresponds to an RTL language
 */
BOOL CW32System::IsBiDiLcid(
	LCID lcid)
{
	return
		PRIMARYLANGID(lcid) == LANG_ARABIC ||
		PRIMARYLANGID(lcid) == LANG_HEBREW ||
		PRIMARYLANGID(lcid) == LANG_URDU ||
		PRIMARYLANGID(lcid) == LANG_FARSI;
}

/*
 *	CW32System::IsIndicLcid(lcid)
 *
 *	@func
 *		Return TRUE if lcid corresponds to an Indic language
 *
 *	@rdesc
 *		TRUE if lcid corresponds to an Indic language
 */
BOOL CW32System::IsIndicLcid(
	LCID lcid)
{
	WORD	wLangId = PRIMARYLANGID(lcid);
	
	return
		wLangId == LANG_HINDI 	||
		wLangId == LANG_KONKANI ||
		wLangId == LANG_NEPALI 	||
		IN_RANGE(LANG_BENGALI, wLangId, LANG_SANSKRIT);
}

/*
 *	CW32System::IsIndicKbdInstalled()
 *
 *	@func
 *		Return TRUE if any Indic kbd installed
 */
bool CW32System::IsIndicKbdInstalled()
{
	for (int i = INDIC_FIRSTINDEX; i <= INDIC_LASTINDEX; i++)
		if (_hkl[i] != 0)
			return true;
	return false;
}

/*
 *	CW32System::IsComplexScriptLcid(lcid)
 *
 *	@func
 *		Return TRUE if lcid corresponds to any complex script locales
 *
 */
BOOL CW32System::IsComplexScriptLcid(
	LCID lcid)
{
	return	IsBiDiLcid(lcid) || 
			PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_THAI ||
			PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_VIETNAMESE ||
			IsIndicLcid(lcid);
}

/*
 *	CW32System::IsBiDiDiacritic(ch)
 *
 *	@func	Used to determine if character is a Arabic or Hebrew diacritic.
 *
 *  @rdesc  TRUE iff character is a diacritic
 */
BOOL CW32System::IsBiDiDiacritic(
	WCHAR ch)
{
	return IN_RANGE(0x64B, ch, 0x670) && (ch <= 0x652 || ch == 0x670) ||	// Arabic
		   IN_RANGE(0x591, ch, 0x5C4) && (ch != 0x5A2 && ch != 0x5BA &&		// Hebrew
				ch != 0x5BE && ch != 0x5C0 && ch != 0x5C3);					
}


/*
 *	CW32System::IsVietCdmSequenceValid(ch1, ch2)
 *
 *	@mfunc
 *		Check if ch2 can follow ch1 in case ch2 is a combining diacritic mark (CDM).
 *		Main use is for Vietnamese users (Chau Vu provides the logic below).
 *
 *	@rdesc
 *		TRUE if ch2 can follow ch1
 */
BOOL CW32System::IsVietCdmSequenceValid(
	WCHAR ch1,
	WCHAR ch2)
{
	if (!IN_RANGE(0x300, ch2, 0x323) ||		// Fast out
		!IN_RANGE(0x300, ch2, 0x301) && ch2 != 0x303 && ch2 != 0x309 && ch2 != 0x323)
	{
		return TRUE;						// Not Vietnamese tone mark
	}
	//									  		

	static const BYTE vowels[] = {0xF4, 0xEA, 0xE2, 'y', 'u', 'o', 'i', 'e', 'a'};

	for(int i = ARRAY_SIZE(vowels); i--; )
		if((ch1 | 0x20) == vowels[i])		// Vietnamese tone mark follows
			return TRUE;					//  vowel

	return IN_RANGE(0x102, ch1, 0x103) ||	// A-breve, a-breve
		   IN_RANGE(0x1A0, ch1, 0x1A1) ||	// O-horn,  o-horn
		   IN_RANGE(0x1AF, ch1, 0x1B0);		// U-horn,  u-horn
}

/*
 *  CW32System::IsFELCID(lcid)
 *
 *	@mfunc
 *		Returns TRUE iff lcid is for a East Asia country/region.
 *
 *	@rdesc
 *		TRUE iff lcid is for a East Asia country/region.
 */
bool CW32System::IsFELCID(
	LCID lcid)
{
	switch(PRIMARYLANGID(LANGIDFROMLCID(lcid)))
	{
		case LANG_CHINESE:
		case LANG_JAPANESE:
		case LANG_KOREAN:
			return true;
	}
	return false;
}

/*
 *  CW32System::IsFECharSet(bCharSet)
 *
 *	@mfunc
 *		Returns TRUE iff charset may be for a East Asia country/region.
 *
 *	@rdesc
 *		TRUE iff charset may be for a East Asia country/region.
 *
 */
BOOL CW32System::IsFECharSet(
	BYTE bCharSet)
{
	switch(bCharSet)
	{
		case CHINESEBIG5_CHARSET:
		case SHIFTJIS_CHARSET:
		case HANGEUL_CHARSET:
		case JOHAB_CHARSET:
		case GB2312_CHARSET:
			return TRUE;
	}

	return FALSE;
}

/*
 *  CW32System::Is8BitCodePage(CodePage)
 *
 *	@mfunc
 *		Returns TRUE iff the codepage is 8-bit
 */
BOOL CW32System::Is8BitCodePage(
	unsigned CodePage)
{
	if(!CodePage)
		CodePage = GetACP();

	return IN_RANGE(1250, CodePage, 1258) || CodePage == 874;
}

/*
 *  CW32System::IsFECodePageFont(dwFontCodePageSig)
 *
 *	@mfunc
 *		Returns TRUE iff the font codepage signature reveals only FE support
 */
BOOL CW32System::IsFECodePageFont(
	DWORD dwFontCodePageSig)
{
	DWORD	dwFE 	= 0x001e0000;	// Shift-JIS + PRC + Hangeul + Taiwan
	DWORD	dwOthers = 0x000101fc;	// The rest of the world except for Latin-1 and Latin-2

	return (dwFontCodePageSig & dwFE) && !(dwFontCodePageSig & dwOthers);
}

/*
 *  CW32System::IsRTLChar(ch)
 *
 *	@mfunc
 *		Returns TRUE iff ch Arabic or Hebrew
 *
 *	@rdesc
 *		TRUE iff ch is Arabic or Hebrew
 */
BOOL IsRTLChar(
	WCHAR	ch)
{
	// Remark: what about Arabic Presentation Forms?
	//  (0xFB50 - 0xFDFF, 0xFE70 - 0xFEFF)

	return IN_RANGE(0x590, ch, 0x6FF) || ch == RTLMARK;
}

/*
 *  CW32System::IsRTLCharSet(bCharSet)
 *
 *	@mfunc
 *		Returns TRUE iff charset is Arabic or Hebrew
 *
 *	@rdesc
 *		TRUE iff charset may be for Arabic or Hebrew
 */
BOOL CW32System::IsRTLCharSet(
	BYTE bCharSet)
{
	return IN_RANGE(HEBREW_CHARSET, bCharSet, ARABIC_CHARSET);
}

typedef struct {
	WCHAR codepoint;
	WORD  CharFlags;
	BYTE  runlength;
} Data_125X;

/*
 *  CW32System::GetCharFlags125x(ch)
 *
 *	@mfunc
 *		Returns char flags for ch as defined in FontSigFromCharRep() for 125x
 *		codepages. Bit 0: 1252, bit 1: 1250, bit 2: 1251, else bit x:
 *		125x (for 1253 - 1258).
 *
 *	@rdesc
 *		125x char flags for ch
 */
QWORD CW32System::GetCharFlags125x(
	WCHAR	ch)			//@parm Char to examine
{
	static const WORD rgCpgMask[] = {
		0x1FF,		// 0xA0
		0x131,		// 0xA1
		0x1F1,		// 0xA2
		0x1F9,		// 0xA3
		0x1DF,		// 0xA4
		0x179,		// 0xA5
		0x1FF,		// 0xA6
		0x1FF,		// 0xA7
		0x1FB,		// 0xA8
		0x1FF,		// 0xA9
		0x111,		// 0xAA
		0x1FF,		// 0xAB
		0x1FF,		// 0xAC
		0x1FF,		// 0xAD
		0x1FF,		// 0xAE
		0x1F1,		// 0xAF
		0x1FF,		// 0xB0
		0x1FF,		// 0xB1
		0x1F9,		// 0xB2
		0x1F9,		// 0xB3
		0x1F3,		// 0xB4
		0x1FF,		// 0xB5
		0x1FF,		// 0xB6
		0x1FF,		// 0xB7
		0x1F3,		// 0xB8
		0x1F1,		// 0xB9
		0x111,		// 0xBA
		0x1FF,		// 0xBB
		0x1F1,		// 0xBC
		0x1F9,		// 0xBD
		0x1F1,		// 0xBE
		0x131,		// 0xBF
		0x111,		// 0xC0
		0x113,		// 0xC1
		0x113,		// 0xC2
		0x011,		// 0xC3
		0x193,		// 0xC4
		0x191,		// 0xC5
		0x191,		// 0xC6
		0x113,		// 0xC7
		0x111,		// 0xC8
		0x193,		// 0xC9
		0x111,		// 0xCA
		0x113,		// 0xCB
		0x011,		// 0xCC
		0x113,		// 0xCD
		0x113,		// 0xCE
		0x111,		// 0xCF
		0x001,		// 0xD0
		0x111,		// 0xD1
		0x011,		// 0xD2
		0x193,		// 0xD3
		0x113,		// 0xD4
		0x091,		// 0xD5
		0x193,		// 0xD6
		0x1F3,		// 0xD7
		0x191,		// 0xD8
		0x111,		// 0xD9
		0x113,		// 0xDA
		0x111,		// 0xDB
		0x193,		// 0xDC
		0x003,		// 0xDD
		0x001,		// 0xDE
		0x193,		// 0xDF
		0x151,		// 0xE0
		0x113,		// 0xE1
		0x153,		// 0xE2
		0x011,		// 0xE3
		0x193,		// 0xE4
		0x191,		// 0xE5
		0x191,		// 0xE6
		0x153,		// 0xE7
		0x151,		// 0xE8
		0x1D3,		// 0xE9
		0x151,		// 0xEA
		0x153,		// 0xEB
		0x011,		// 0xEC
		0x113,		// 0xED
		0x153,		// 0xEE
		0x151,		// 0xEF
		0x001,		// 0xF0
		0x111,		// 0xF1
		0x011,		// 0xF2
		0x193,		// 0xF3
		0x153,		// 0xF4
		0x091,		// 0xF5
		0x193,		// 0xF6
		0x1F3,		// 0xF7
		0x191,		// 0xF8
		0x151,		// 0xF9
		0x113,		// 0xFA
		0x151,		// 0xFB
		0x1D3,		// 0xFC
		0x003,		// 0xFD
		0x001,		// 0xFE
		0x111		// 0xFF
	};
	static const Data_125X Table_125X[] = {
		{ 0x100, 0x080,  2},
		{ 0x102, 0x102,  2},
		{ 0x104, 0x082,  4},
		{ 0x10c, 0x082,  2},
		{ 0x10e, 0x002,  2},
		{ 0x110, 0x102,  2},
		{ 0x112, 0x080,  2},
		{ 0x116, 0x080,  2},
		{ 0x118, 0x082,  2},
		{ 0x11a, 0x002,  2},
		{ 0x11e, 0x010,  2},
		{ 0x122, 0x080,  2},
		{ 0x12a, 0x080,  2},
		{ 0x12e, 0x080,  2},
		{ 0x130, 0x010,  2},
		{ 0x136, 0x080,  2},
		{ 0x139, 0x002,  2},
		{ 0x13b, 0x080,  2},
		{ 0x13d, 0x002,  2},
		{ 0x141, 0x082,  4},
		{ 0x145, 0x080,  2},
		{ 0x147, 0x002,  2},
		{ 0x14c, 0x080,  2},
		{ 0x150, 0x002,  2},
		{ 0x152, 0x151,  2},
		{ 0x154, 0x002,  2},
		{ 0x156, 0x080,  2},
		{ 0x158, 0x002,  2},
		{ 0x15a, 0x082,  2},
		{ 0x15e, 0x012,  2},
		{ 0x160, 0x093,  2},
		{ 0x162, 0x002,  4},
		{ 0x16a, 0x080,  2},
		{ 0x16e, 0x002,  4},
		{ 0x172, 0x080,  2},
		{ 0x178, 0x111,  1},
		{ 0x179, 0x082,  4},
		{ 0x17d, 0x083,  2},
		{ 0x192, 0x179,  1},
		{ 0x1A0, 0x100,  2},
		{ 0x1AF, 0x100,  2},
		{ 0x2c6, 0x171,  1},
		{ 0x2c7, 0x082,  1},
		{ 0x2d8, 0x002,  1},
		{ 0x2d9, 0x082,  1},
		{ 0x2db, 0x082,  1},
		{ 0x2dc, 0x131,  1},
		{ 0x2dd, 0x002,  1},
		{ 0x300, 0x100,  2},
		{ 0x303, 0x100,  1},
		{ 0x309, 0x100,  1},
		{ 0x323, 0x100,  1},
		{ 0x384, 0x008,  3},
		{ 0x388, 0x008,  3},
		{ 0x38c, 0x008,  1},
		{ 0x38e, 0x008, 20},
		{ 0x3a3, 0x008, 44},
		{ 0x401, 0x004, 12},
		{ 0x40e, 0x004, 66},
		{ 0x451, 0x004, 12},
		{ 0x45e, 0x004,  2},
		{ 0x490, 0x004,  2},
		{ 0x5b0, 0x020, 20},
		{ 0x5d0, 0x020, 27},
		{ 0x5F0, 0x020,  5},
		{ 0x60c, 0x040,  1},
		{ 0x61b, 0x040,  1},
		{ 0x61f, 0x040,  1},
		{ 0x621, 0x040, 26},
		{ 0x640, 0x040, 19},
		{ 0x679, 0x040,  1},
		{ 0x67e, 0x040,  1},
		{ 0x686, 0x040,  1},
		{ 0x688, 0x040,  1},
		{ 0x691, 0x040,  1},
		{ 0x698, 0x040,  1},
		{ 0x6a9, 0x040,  1},
		{ 0x6af, 0x040,  1},
		{ 0x6ba, 0x040,  1},
		{ 0x6be, 0x040,  1},
		{ 0x6c1, 0x040,  1},
		{ 0x6d2, 0x040,  1},
		{0x200c, 0x040,  2},
		{0x200e, 0x060,  2},
		{0x2013, 0x1ff,  2},
		{0x2015, 0x008,  1},
		{0x2018, 0x1ff,  3},
		{0x201c, 0x1ff,  3},
		{0x2020, 0x1ff,  3},
		{0x2026, 0x1ff,  1},
		{0x2030, 0x1ff,  1},
		{0x2039, 0x1ff,  2},
		{0x20AA, 0x020,  1},
		{0x20AB, 0x100,  1},
		{0x20AC, 0x1ff,  1},
		{0x2116, 0x004,  1},
		{0x2122, 0x1ff,  1}
	};

	// Easy check for ASCII
	if(ch <= 0x7f)
		return FLATIN1 | FLATIN2 | FCYRILLIC | FGREEK | FTURKISH |
			   FHEBREW | FARABIC | FBALTIC | FVIETNAMESE;

	// Easy check for missing codes
	if(ch > 0x2122)
		return 0;

	if(IN_RANGE(0xA0, ch, 0xFF))
		return (QWORD)(DWORD)(rgCpgMask[ch - 0xA0] << 8);

	// Perform binary search to find entry in table
	int low = 0;
	int high = ARRAY_SIZE(Table_125X) - 1;
	int middle;
	int midval;
	int runlength;
	
	while(low <= high)
	{
		middle = (high + low) / 2;
		midval = Table_125X[middle].codepoint;
		if(midval > ch)
			high = middle - 1;
		else
			low = middle + 1;
	
		runlength = Table_125X[middle].runlength;
		if(ch >= midval && ch <= midval + runlength - 1)
			return (QWORD)(DWORD)(Table_125X[middle].CharFlags << 8);
	}
	return 0;
}

/*
 *	CW32System::IsUTF8BOM(pstr)
 *
 *	@mfunc
 *		Return TRUE if pstr points at a UTF-8 BOM
 *
 *	@rdesc
 *		TRUE iff pstr points at a UTF-8 BOM
 */
BOOL CW32System::IsUTF8BOM(
	BYTE *pstr)
{
	BYTE *pstrUtf8BOM = szUTF8BOM;

	for(LONG i = 3; i--; )
		if(*pstr++ != *pstrUtf8BOM++)
			return FALSE;
	return TRUE;
}

/*
 *	CW32System::GetTrailBytesCount(ach, cpg)
 *
 *	@mfunc
 *		Returns number of trail bytes iff the byte ach is a lead byte for the code page cpg.
 *
 *	@rdesc
 *		count of trail bytes if ach is lead byte for cpg
 *
 *	@comm
 *		This is needed to support CP_UTF8 as well as DBCS.
 *		This function potentially doesn't support as many code pages as the
 *		Win32 IsDBCSLeadByte() function (and it might not be as up-to-date).
 *		An AssertSz() is included to compare the results when the code page
 *		is supported by the system.
 *
 *		Reference: \\sparrow\sysnls\cptable\win9x. See code-page txt files
 *		in subdirectories windows\txt and others\txt.
 */
int CW32System::GetTrailBytesCount(
	BYTE ach,
	UINT cpg)
{
	if(ach < 0x81)									// Smallest known lead
		return 0;									//  byte = 0x81:
													//  early out
	BOOL	bDBLeadByte = FALSE;					// Variable to check
													//  result with system
													//  ifdef DEBUG
	if (cpg == CP_UTF8)
	{
		int	cTrailBytes = 0;						// Number of trail bytes for CP_UTF8(0 - 3)
		
		if (ach >= 0x0F0)							// Handle 4-byte form for 16 UTF-16 planes 
			cTrailBytes = 3;						// above the BMP) expect: 
													// 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
		else if (ach >= 0x0E0)						// Need at least 3 bytes of form
			cTrailBytes = 2;						// 1110bbbb 10bbbbbb 10bbbbbb
		else if (ach >= 0x0C0)						// Need at least 2 bytes of form 
			cTrailBytes = 1;						// 110bbbbb 10bbbbbb

		return cTrailBytes;
	}
	else if(cpg > 950)								
	{
		if(cpg < 1361)								// E.g., the 125x's are
			return 0;								//  SBCSs: early out

		else if(cpg == 1361)								// Korean Johab
			bDBLeadByte = IN_RANGE(0x84, ach, 0xd3) ||		// 0x84 <= ach <= 0xd3
				   IN_RANGE(0xd8, ach, 0xde) ||				// 0xd8 <= ach <= 0xde
				   IN_RANGE(0xe0, ach, 0xf9);				// 0xe0 <= ach <= 0xf9

		else if(cpg == 10001)						// Mac Japanese
			goto JIS;

		else if(cpg == 10002)						// Mac Trad Chinese (Big5)
			bDBLeadByte = ach <= 0xfe;

		else if(cpg == 10003)						// Mac Korean
			bDBLeadByte = IN_RANGE(0xa1, ach, 0xac) ||		// 0xa1 <= ach <= 0xac
				   IN_RANGE(0xb0, ach, 0xc8) ||		// 0xb0 <= ach <= 0xc8
				   IN_RANGE(0xca, ach, 0xfd);		// 0xca <= ach <= 0xfd

		else if(cpg == 10008)						// Mac Simplified Chinese
			bDBLeadByte = IN_RANGE(0xa1, ach, 0xa9) ||		// 0xa1 <= ach <= 0xa9
				   IN_RANGE(0xb0, ach, 0xf7);		// 0xb0 <= ach <= 0xf7
	}
	else if (cpg >= 932)							// cpg <= 950
	{
		if(cpg == 950 || cpg == 949 || cpg == 936)	// Chinese (Taiwan, HK),
			bDBLeadByte = ach <= 0xfe;						//  Korean Ext Wansung,
													//  PRC GBK: 0x81 - 0xfe  
		else if(cpg == 932)							// Japanese
JIS:		bDBLeadByte = ach <= 0x9f || IN_RANGE(0xe0, ach, 0xfc);
	}

	#ifdef DEBUG
	WCHAR	ch;
	static	BYTE asz[2] = {0xe0, 0xe0};				// All code pages above

	// if cpg == 0, fRet will FALSE but IsDBCSLeadByteEx may succeed. 
	if ( cpg && cpg != CP_SYMBOL && cpg != CP_UTF8)
	{
		// If system supports cpg, then fRet should agree with system result
		AssertSz(MultiByteToWideChar(cpg, 0, (char *)asz, 2, &ch, 1) <= 0 ||
			bDBLeadByte == IsDBCSLeadByteEx(cpg, ach),
			"bDBLeadByte differs from IsDBCSLeadByteEx()");
	}
	#endif

	return bDBLeadByte ? 1 : 0;
}

/*
 *	CW32System::CharSetFromCharRep(iCharRep)
 *
 *	@func
 *		Map character repertoire index to bCharSet for GDI
 */
BYTE CW32System::CharSetFromCharRep(
	LONG iCharRep)
{
	return (unsigned)iCharRep < CCHARSET ? rgCharSet[iCharRep] : DEFAULT_CHARSET;
}

/*
 *	CW32System::GetCharSet(nCP, piCharRep)
 *
 *	@func
 *		Get character set for code page <p nCP>. Also returns script index
 *		in *piCharRep
 *
 *	@rdesc
 *		CharSet for code page <p nCP>
 */
BYTE CW32System::GetCharSet(
	INT  nCP,				//@parm Code page or index
	int *piCharRep)		//@parm Out parm to receive index
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "GetCharSet");

	if(nCP < CCHARSET)					// nCP is already an index
	{
		nCP = max(nCP, 0);
		if(piCharRep)
			*piCharRep = nCP;
		return rgCharSet[nCP];
	}

	Assert(CCODEPAGE == CCHARSET && CCODEPAGE == NCHARSETS);
	for(int i = 0; i < CCODEPAGE && rgCodePage[i] != nCP; i++)
		;
	if(i == CCODEPAGE)					// Didn't find it
		i = -1;

	if (piCharRep)
		*piCharRep = i;

	return i >= 0 ? rgCharSet[i] : 0;
}

/*
 *	CW32System::MatchFECharRep(qwCharFlags, qwFontSig)
 *
 *	@func
 *		Get a FE character set for a FE char
 *
 *	@rdesc
 *		Char repertoire
 */
BYTE CW32System::MatchFECharRep(
	QWORD  qwCharFlags,		//@parm Char flags
	QWORD  qwFontSig)		//@parm Font Signature
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::MatchFECharSet");

	if (qwCharFlags & qwFontSig & FFE)		// Perfect match
		goto Exit;											

	if (!(qwFontSig & FFE))					// Not a FE font
		goto Exit;

	if (qwCharFlags & (FCHINESE | FBIG5))
	{
		if (qwFontSig & FBIG5)
			return BIG5_INDEX;

		if (qwFontSig & FHANGUL)
			return HANGUL_INDEX;

		if (qwFontSig & FKANA)
			return SHIFTJIS_INDEX;
	}

Exit:
	return CharRepFromFontSig(qwCharFlags);
}

/*
 *	CW32System::CodePageFromCharRep(iCharRep)
 *
 *	@func
 *		Get code page for character repertoire <p iCharRep>
 *
 *	@rdesc
 *		Code page for character repertoire <p iCharRep>
 */
INT CW32System::CodePageFromCharRep(
	LONG iCharRep)		//@parm CharSet
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "GetCodePage");

	return ((unsigned)iCharRep < CCODEPAGE) ? rgCodePage[iCharRep] : 0;
}

/*
 *	CW32System::FontSigFromCharRep(iCharRep)
 *
 *	@func
 *		Get font signature bits for character repertoire <p iCharRep>.
 *
 *	@rdesc
 *		Font signature mask for character repertoire <p bCharSet>
 */
QWORD CW32System::FontSigFromCharRep(
	LONG iCharRep)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::FontSigFromCharRep");

	if(iCharRep <= BIG5_INDEX)
	{
		if (iCharRep != ANSI_INDEX)
			return (DWORD)(FHILATIN1 << iCharRep);
		return FLATIN1;
	}

	union
	{
		QWORD qw;							// Endian-dependent way of
		DWORD dw[2];						//  avoiding 64-bit left shifts
	};
	qw = 0;
	if(IN_RANGE(ARMENIAN_INDEX, iCharRep, NCHARREPERTOIRES))
	{
		dw[1] = (DWORD)(FARMENIAN >> 32) << (iCharRep - ARMENIAN_INDEX);
		if(IN_RANGE(JPN2_INDEX, iCharRep, CHT2_INDEX))
			dw[0] |= FSURROGATE;
	}
	else if(IN_RANGE(PC437_INDEX, iCharRep, MAC_INDEX))
		dw[0] = FHILATIN1;

	return qw;
}

/*
 *	CW32System::CharRepFontSig(qwFontSig, fFirstAvailable)
 *
 *	@func
 *		Get char repertoire from font signature bit[s]. If fFirstAvailable
 *		= TRUE, then the CharRep corresponding to the lowest-order nonzero
 *		bit in qwFontSig is used.  If fFirstAvailable is FALSE, the CharRep
 *		is that corresponding to qwFontSig provided qwFontSig is a single bit.
 */
LONG CW32System::CharRepFontSig(
	QWORD qwFontSig,		//@parm Font signature to match
	BOOL  fFirstAvailable)	//@parm TRUE matches 1st available; else exact
{
	DWORD dw;
	INT	  i;
	union
	{
		QWORD qwFS;							// Endian-dependent way of
		DWORD dwFS[2];						//  avoiding 64-bit shifts
	};
	DWORD *pdw = &dwFS[0];
	qwFS = qwFontSig;

	if(*pdw & 0x00FFFF00)					// Check for everything less
	{										//  math
		dw = FHILATIN1;
		for(i = ANSI_INDEX; i <= BIG5_INDEX; i++, dw <<= 1)
		{
			if(dw & *pdw)
				return (fFirstAvailable || dw == *pdw) ? i : -1;
		}
	}
	pdw++;									// Endian dependent
	if(*pdw)								// High word of qw
	{
		dw = FARMENIAN >> 32;
		for(i = ARMENIAN_INDEX; i <= NCHARREPERTOIRES; i++, dw <<= 1)
		{
			if(dw & *pdw)
				return (fFirstAvailable || dw == *pdw) ? i : -1;
		}
	}
	return fFirstAvailable || (qwFontSig & FASCII) ? ANSI_INDEX : -1;
}

/*
 *	CW32System::CharRepFromCharSet(bCharSet)
 *
 *	@func
 *		Get character repertoire from bCharSet
 *
 *	@rdesc
 *		character repertoire corresponding to <p bCharSet>
 *
 *	@devnote
 *		Linear search
 */
LONG CW32System::CharRepFromCharSet(
	BYTE bCharSet)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::ScriptIndexFromCharSet");

	Assert(CCHARSET == CCODEPAGE);
	for (int i = 0; i < CCHARSET; i++)
	{
		if(rgCharSet[i] == bCharSet)
			return i;
	}
	return -1;								// Not found
}

/*
 *	CW32System::CharRepFromCodePage(CodePage)
 *
 *	@func
 *		Get character repertoire from bCharSet
 *
 *	@rdesc
 *		character repertoire corresponding to <p bCharSet>
 *
 *	@devnote
 *		Linear search
 */
INT CW32System::CharRepFromCodePage(
	LONG CodePage)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::ScriptIndexFromCharSet");

	for (int i = 0; i < CCODEPAGE; i++)
	{
		if(rgCodePage[i] == CodePage)
			return i;
	}
	return -1;								// Not found
}

/*
 *	CW32System::GetScreenDC()
 *
 *	@mfunc
 *		Returns you a default screen DC which richedit caches for its lifetime.
 *
 *		Note, you need to serialize access to DCs, so make sure its used in the
 *		renderer and measurer or otherwise protected by a CLock.
 *
 *	@rdesc
 *		Screen HDC if succeeded.
 */
HDC	CW32System::GetScreenDC()
{
	if (!_hdcScreen)
		_hdcScreen = CreateIC(L"DISPLAY", NULL, NULL, NULL);

	//Verify DC validity
	Assert(GetDeviceCaps(_hdcScreen, LOGPIXELSX));

	return _hdcScreen;
}

/*
 *	CW32System::GetTextMetrics(hdc, &lf, &tm)
 *
 *	@mfunc
 *		CreateFontIndirect(lf), select into hdc, and get TEXTMETRICS
 *
 *	@rdesc
 *		TRUE if succeeded and selected facename is same as lf.lfFaceName
 */
BOOL CW32System::GetTextMetrics(
	HDC			hdc,
	LOGFONT &	lf,
	TEXTMETRIC &tm)
{
	HFONT hfont = CreateFontIndirect(&lf);
	if(!hfont)
		return FALSE;

	HFONT hfontOld = SelectFont(hdc, hfont);
	WCHAR szFaceName[LF_FACESIZE + 1];

	BOOL  fRet = GetTextFace(hdc, LF_FACESIZE, szFaceName) &&
				 !wcsicmp(lf.lfFaceName, szFaceName) &&
				  W32->GetTextMetrics(hdc, &tm);

	SelectFont(hdc, hfontOld);
	DeleteObject(hfont);
	return fRet;
}

/*
 *	CW32System::ValidateStreamWparam(wparam)
 *
 *	@mfunc
 *		Examine lparam to see if hiword is a valid codepage. If not set it
 *		to 0 and turn off SF_USECODEPAGE flag
 *
 *	@rdesc
 *		Validated lparam
 */
WPARAM CW32System::ValidateStreamWparam(
	WPARAM wparam)		//@parm EM_STREAMIN/OUT wparam
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::ValidateStreamWparam");

	if ((wparam & SF_USECODEPAGE) && !IsValidCodePage(HIWORD(wparam)) &&
		HIWORD(wparam) != CP_UTF8 && HIWORD(wparam) != CP_UBE)
	{
		// Invalid codepage, so reset codepage parameters
		wparam &= 0xFFFF & ~SF_USECODEPAGE;
	}
	return wparam;
}

/*
 *	CW32System::MECharClass(ch)
 *
 *	@func
 *		return ME character type for purposes of CharSet stamping.  Values
 *		are:
 *
 *		0: Arabic (specific RTL)
 *		1: Hebrew (specific RTL)
 *		2: RTL (generic RTL, e.g., RTL mark)
 *		3: LTR
 *		4: EOP or start/end of text
 *		5: ASCII digit
 *		6: punctuation and neutrals
 *
 *	@rdesc
 *		ME character class
 */
CC CW32System::MECharClass(
	WCHAR	ch)
{
	AssertSz(CC_NEUTRAL > CC_ASCIIDIGIT && CC_ASCIIDIGIT > CC_EOP &&
			 CC_EOP > CC_LTR && CC_LTR > CC_RTL && CC_RTL > CC_ARABIC,
		"CW32System::MECharClass: invalid CC values");

	// Work down Unicode values from large to small. Use nested if
	// statements to reduce the number executed.

	// Remark: what about Arabic Presentation Forms?
	//  (0xFB50 - 0xFDFF, 0xFE70 - 0xFEFF)

	if(ch >= 0x700)
	{
		if(IN_RANGE(ENQUAD, ch, RTLMARK))
		{								// ENQUAD thru RTLMARK
			if(ch == RTLMARK)			// Maybe add more Unicode general
				return CC_RTL;			//  punctuation?

			if(IN_RANGE(ZWNJ, ch, ZWJ))	// ZWNJ & ZWJ are handled as Arabic,
				return CC_ARABIC;		//  even though they actually shouldn't
										//  affect layout.
			if(ch < ZWNJ)
				return CC_NEUTRAL;		// Various blanks are neutral
		}
		return CC_LTR;
	}

	if(ch >= 0x40)
	{
		if(ch >= 0x590)
			return (ch >= 0x600) ? CC_ARABIC : CC_HEBREW;

		if(IN_RANGE(0x7B, (ch | 0x20), 0x7F) || ch == 0x60 || ch == 0x40)
			return CC_NEUTRAL;			// [\]^_{|}~`@

		return CC_LTR;
	}

	if(ch >= 0x20)
	{
		if(IN_RANGE(0x30, ch, 0x39))
			return CC_ASCIIDIGIT;

		return CC_NEUTRAL;
	}

	Assert(ch < 0x20);
	if((1 << ch) & 0x00003201) /* IsASCIIEOP(ch) || ch == TAB || !ch */
		return CC_EOP;
		
	return CC_LTR;	 
}

/*
 *	CW32System::MBTWC (CodePage, dwFlags, pstrMB, cchMB, pstrWC, cchWC, pfNoCodePage)
 *
 *	@mfunc
 *		Convert MultiByte (MB) string pstrMB of length cchMB to WideChar (WC)
 *		string pstrWC of length cchWC according to the flags dwFlags and code
 *		page CodePage.  If CodePage = SYMBOL_CODEPAGE 
 *		(usually for SYMBOL_CHARSET strings),
 *		convert each byte in pstrMB to a wide char with a zero high byte
 *		and a low byte equal to the MultiByte string byte, i.e., no
 *		translation other than a zero extend into the high byte.  Else call
 *		the Win32 MultiByteToWideChar() function.
 *
 *	@rdesc
 *		Count of characters converted
 */
int CW32System::MBTWC(
	INT		CodePage,	//@parm Code page to use for conversion
	DWORD	dwFlags,	//@parm Flags to guide conversion
	LPCSTR	pstrMB,		//@parm MultiByte string to convert to WideChar
	int		cchMB,		//@parm Count of chars (bytes) in pstrMB or -1
	LPWSTR	pstrWC,		//@parm WideChar string to receive converted chars
	int		cchWC,		//@parm Max count for pstrWC or 0 to get cch needed
	LPBOOL 	pfNoCodePage) //@parm Out parm to receive whether code page is on system
{
	BOOL	fNoCodePage = FALSE;			// Default code page is on OS
	int		cch = -1;

	if(CodePage == CP_UTF8)
	{
		DWORD ch,ch1;

		for(cch = 0; cchMB--; )
		{
			ch = ch1 = *(BYTE *)pstrMB++;
			Assert(ch < 256);
			if(ch > 127 && cchMB && IN_RANGE(0x80, *(BYTE *)pstrMB, 0xBF))
			{
				// Need at least 2 bytes of form 110bbbbb 10bbbbbb
				ch1 = ((ch1 & 0x1F) << 6) + (*pstrMB++ & 0x3F);
				cchMB--;
				if(ch >= 0xE0 && cchMB && IN_RANGE(0x80, *(BYTE *)pstrMB, 0xBF))
				{
					// Need at least 3 bytes of form 1110bbbb 10bbbbbb 10bbbbbb
					ch1 = (ch1 << 6) + (*pstrMB++ & 0x3F);
					cchMB--;
					if (ch >= 0xF0 && cchMB && IN_RANGE(0x80, *(BYTE *)pstrMB, 0xBF))
					{
						// Handle 4-byte form for 16 UTF-16 planes above the
						// BMP) expect: 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
						ch1 = ((ch1 & 0x7FFF) << 6) + (*(BYTE *)pstrMB++ & 0x3F)
							- 0x10000;			// Subtract offset for BMP
						if(ch1 <= 0xFFFFF)		// Fits in 20 bits
						{
							cch++;				// Two 16-bit surrogate codes
							if(cch < cchWC)
								*pstrWC++ = UTF16_LEAD + (ch1 >> 10);
							ch1 = (ch1 & 0x3FF) + UTF16_TRAIL; 
							cchMB--;
						}
						else ch1 = '?';
					}
				}
			}
			cch++;
			if(cch < cchWC)
				*pstrWC++ = ch1;
			if(!ch)
				break;
		}
	}
	else if(CodePage != CP_SYMBOL)			// Not SYMBOL_CHARSET
	{
		fNoCodePage = TRUE;					// Default codepage isn't on OS
		if(CodePage >= 0)					// Might be..
		{
			cch = MultiByteToWideChar(
				CodePage, dwFlags, pstrMB, cchMB, pstrWC, cchWC);
			if(cch > 0)
				fNoCodePage = FALSE;		// Codepage is on OS
		}
	}
	if(pfNoCodePage)
		*pfNoCodePage = fNoCodePage;

	if(cch <= 0)
	{			
		// SYMBOL_CHARSET or conversion failed: bytes -> words with  
		//  high bytes of 0.  Return count for full conversion

		if(cchWC <= 0)					
			return cchMB >= 0 ? cchMB : (strlen(pstrMB) + 1);

		int cchMBMax = cchMB;

		if(cchMB < 0)					// If negative, use NULL termination
			cchMBMax = tomForward;			//  of pstrMB

		cchMBMax = min(cchMBMax, cchWC);

		for(cch = 0; (cchMB < 0 ? *pstrMB : 1) && cch < cchMBMax; cch++)
		{
			*pstrWC++ = (unsigned char)*pstrMB++;
		}
		
		// NULL-terminate the WC string if the MB string was NULL-terminated,
		// and if there is room in the WC buffer.
		if(cchMB < 0 && cch < cchWC)
		{
			*pstrWC = 0;
			cch++;
		}
	}
	return cch;
}

/*
 *	CW32System::WCTMB (CodePage, dwFlags, pstrWC, cchWC, pstrMB, cchMB,
 *					   pchDefault, pfUsedDef, pfNoCodePage, fTestCodePage)
 *
 *	@mfunc
 *		Convert WideChar (WC) string pstrWC of length cchWC to MultiByte (MB)
 *		string pstrMB of length cchMB according to the flags dwFlags and code
 *		page CodePage.  If CodePage = SYMBOL_CODEPAGE
 *		(usually for SYMBOL_CHARSET strings),
 *		convert each character in pstrWC to a byte, discarding the high byte.
 *		Else call the Win32 WideCharToMultiByte() function.
 *
 *	@rdesc
 *		Count of bytes stored in target string pstrMB
 */
int CW32System::WCTMB(
	INT		CodePage,	//@parm Code page to use for conversion
	DWORD	dwFlags,	//@parm Flags to guide conversion
	LPCWSTR	pstrWC,		//@parm WideChar string to convert
	int		cchWC,		//@parm Count for pstrWC or -1 to use NULL termination
	LPSTR	pstrMB,		//@parm MultiByte string to receive converted chars
	int		cchMB,		//@parm Count of chars (bytes) in pstrMB or 0
	LPCSTR	pchDefault,	//@parm Default char to use if conversion fails
	LPBOOL	pfUsedDef,	//@parm Out parm to receive whether default char used
	LPBOOL 	pfNoCodePage, //@parm Out parm to receive whether code page is on system
	BOOL	fTestCodePage)//@parm Test CodePage could handle the pstrWC
{
	int		cch = -1;						// No chars converted yet
	BOOL	fNoCodePage = FALSE;			// Default code page is on OS

	if(pfUsedDef)							// Default that all chars can be
		*pfUsedDef = FALSE;					//  converted

#ifndef WC_NO_BEST_FIT_CHARS
#define WC_NO_BEST_FIT_CHARS	0x400
#endif

	if (_dwPlatformId == VER_PLATFORM_WIN32_NT &&
		_dwMajorVersion > 4 && !dwFlags)
	{
		dwFlags = WC_NO_BEST_FIT_CHARS;
	}

	if(CodePage == CP_UTF8)					// Convert to UTF8 since OS
	{										// doesn't (pre NT 5.0)
		unsigned ch;
		cch = 0;							// No converted bytes yet
		while(cchWC--)
		{
			ch = *pstrWC++;					// Get Unicode char
			if(ch <= 127)					// It's ASCII
			{
				cch++;
				if(cch < cchMB)
					*pstrMB++ = ch;			// One more converted byte
				if(!ch)						// Quit on NULL termination
					break;
				continue;
			}
			if(ch <= 0x7FF)					// Need 2 bytes of form:
			{								//  110bbbbb 10bbbbbb
				cch += 2;
				if(cch < cchMB)				// Store lead byte
					*pstrMB++ = 0xC0 + (ch >> 6);
			}
			else if(IN_RANGE(UTF16_LEAD, ch, 0xDBFF))
			{								// Unicode surrogate pair
				cch += 4;					// Need 4 bytes of form:
				if(cch < cchMB)				//  11110bbb 10bbbbbb 10bbbbbb
				{							//  10bbbbbb
					AssertSz(IN_RANGE(UTF16_TRAIL, *pstrWC, 0xDFFF),
						"CW32System::WCTMB: illegal surrogate pair");
					cchWC--;
					ch = ((ch & 0x3FF) << 10) + (*pstrWC++ & 0x3FF) + 0x10000;
					*pstrMB++ = 0xF0 + (ch >> 18);
					*pstrMB++ = 0x80 + (ch >> 12 & 0x3F);
					*pstrMB++ = 0x80 + (ch >> 6  & 0x3F);
				}
			}
			else							// Need 3 bytes of form:
			{								//  1110bbbb 10bbbbbb
				cch += 3;					//  10bbbbbb
				if(cch < cchMB)				// Store lead byte followed by
				{							//  first trail byte
					*pstrMB++ = 0xE0 + (ch >> 12);
					*pstrMB++ = 0x80 + (ch >> 6 & 0x3F);
				}
			}
			if(cch < cchMB)					// Store final UTF-8 byte
				*pstrMB++ = 0x80 + (ch & 0x3F);
		}
	}
	else if(CodePage != CP_SYMBOL)
	{
		fNoCodePage = TRUE;					// Default codepage not on OS
		if(CodePage >= 0)					// Might be...
		{
			cch = WideCharToMultiByte(CodePage, dwFlags,
					pstrWC, cchWC, pstrMB, cchMB, pchDefault, pfUsedDef);
			if(cch > 0)
				fNoCodePage = FALSE;		// Found codepage on system
		}
	}
	if(pfNoCodePage)
		*pfNoCodePage = fNoCodePage;

	// Early exit if we are just testing for CodePage
	if (fTestCodePage)
		return cch;

	// SYMBOL_CHARSET, fIsDBCS or conversion failed: low bytes of words ->
	//  bytes
	if(cch <= 0)
	{									
		// Return multibyte count for full conversion. cchWC is correct for
		// single-byte charsets like the 125x's
		if(cchMB <= 0)
		{
			return cchWC >= 0 ? cchWC : wcslen(pstrWC);
		}

		char chDefault = 0;
		BOOL fUseDefaultChar = (pfUsedDef || pchDefault) && CodePage != CP_SYMBOL;

		if(fUseDefaultChar)
		{
			// determine a default char for our home-grown conversion
			if(pchDefault)
			{
				chDefault = *pchDefault;
			}
			else
			{
				static char chSysDef = 0;
				static BOOL fGotSysDef = FALSE;

				// 0x2022 is a math symbol with no conversion to ANSI
				const WCHAR szCantConvert[] = { 0x2022 };
				BOOL fUsedDef;

				if(!fGotSysDef)
				{
					fGotSysDef = TRUE;

					if(!(WideCharToMultiByte
							(CP_ACP, 0, szCantConvert, 1, &chSysDef, 1, NULL,
										&fUsedDef) == 1 && fUsedDef))
					{
						AssertSz(0, "WCTMB():  Unable to determine what the "
									"system uses as its default replacement "
									"character.");
						chSysDef = '?';
					}
				}
				chDefault = chSysDef;
			}
		}

		int cchWCMax = cchWC;

		// If negative, use NULL termination of pstrMB
		if(cchWC < 0)
		{
			cchWCMax = tomForward;
		}

		cchWCMax = min(cchWCMax, cchMB);

		for(cch = 0; (cchWC < 0 ? *pstrWC : 1) && cch < cchWCMax; cch++)
		{
			// TODO(BradO):  Should this be 0x7F in some conversion cases?
			if(fUseDefaultChar && *pstrWC > 0xFF)
			{
				if(pfUsedDef)
				{
					*pfUsedDef = TRUE;
				}
				*pstrMB = chDefault;
			}
			else
			{
				*pstrMB = (BYTE)*pstrWC;
			}
			pstrMB++;
			pstrWC++;
		}

		if(cchWC < 0 && cch < cchMB)
		{
			*pstrMB = 0;
			cch++;
		}
	}
	return cch;
}
/*
 *	CW32System::VerifyFEString(cpg, pstrWC, cchWC, fTestInputCpg)
 *
 *	@mfunc
 *		Verify if the input cpg can handle the pstrWC.
 *		If not, select another FE cpg.
 *
 *	@rdesc
 *		New CodePage for the pstrWC
 */
#define NUMBER_OF_CHARS	64
	
int CW32System::VerifyFEString(
	INT		cpg,			//@parm cpg to format the pstrWC
	LPCWSTR	pstrWC,			//@parm WideChar string to test
	int		cchWC,			//@parm Count for pstrWC
	BOOL	fTestInputCpg)	//@parm test the input cpg only
{
	if (cchWC <=0)
		return cpg;

	int				cpgNew = cpg;
	BOOL			fUsedDef;
	int				cchMB = cchWC * sizeof(WCHAR);
	CTempCharBuf	tcb;
	char			*pstrMB = tcb.GetBuf(cchMB);
	CTempWcharBuf	twcb;
	WCHAR			*pstrWchar = twcb.GetBuf(cchWC);						
	static			int	aiCpg[4] =
		{ CP_JAPAN, CP_KOREAN, CP_CHINESE_TRAD, CP_CHINESE_SIM };	

	if (pstrMB)
	{
		int	cchConverted = WCTMB(cpg, 0, pstrWC, cchWC, pstrMB, cchMB, NULL,
				&fUsedDef, NULL, TRUE);

		if (cchConverted > 0 && !fUsedDef && IsFEFontInSystem(cpg))	
		{
			cchConverted = MBTWC(cpg, 0, pstrMB, cchConverted, pstrWchar, cchWC, NULL);

			if (cchConverted == cchWC)
				goto Exit;					// Found it
		}		
		
		if (fTestInputCpg)				// Only need to test the input cpg			
			cpgNew = -1;				// Indicate cpg doesn't support the string
		else
		{
			// If no conversion or if the default character is used or
			// no such FE font in system,
			// it means that this cpg may not be the right choice.
			// Let's try other FE cpg.
			for (int i=0; i < 4; i++)
			{
				if (cpg != aiCpg[i])
				{
					cchConverted = WCTMB(aiCpg[i], 0, pstrWC, cchWC, pstrMB, cchMB, NULL,
						&fUsedDef, NULL, TRUE);

					if (cchConverted > 0 && !fUsedDef && IsFEFontInSystem(aiCpg[i]))
					{
						cchConverted = MBTWC(aiCpg[i], 0, pstrMB, cchConverted, pstrWchar, cchWC, NULL);

						if (cchConverted == cchWC)
						{
							cpgNew = aiCpg[i];	// Found it
							break;
						}
					}
				}
			}
		}
	}			

Exit:

	return cpgNew;
}

int __cdecl CW32System::sprintf(char * buff, char *fmt, ...)
{
	va_list	marker;

	va_start(marker, fmt);
	int cb = W32->WvsprintfA(0x07FFFFFFF, buff, fmt, marker);
	va_end(marker);

	return cb;
}

/*
 *	CW32System::GetSizeCursor(void)
 *
 *	@mfunc
 *		Get the sizing cursor (double arrow) specified by
 *		the resource id.  If the cursors are not loaded
 *		load them and cache them.
 *		parameters:
 *			idcur - cursor resource id.
 *
 *	@rdesc
 *		Handle to cursor or null if failure. Returns NULL if
 *		idcur is null.
 */
HCURSOR CW32System::GetSizeCursor(
	LPTSTR idcur)
{
	if(!idcur )
		return NULL;

	//If any cursor isn't loaded, try loading it.
	if(!_hcurSizeNS)
		_hcurSizeNS = LoadCursor(NULL, IDC_SIZENS);

	if(!_hcurSizeWE)
		_hcurSizeWE = LoadCursor(NULL, IDC_SIZEWE);

	if(!_hcurSizeNWSE)
		_hcurSizeNWSE = LoadCursor(NULL, IDC_SIZENWSE);

	if(!_hcurSizeNESW)
		_hcurSizeNESW = LoadCursor(NULL, IDC_SIZENESW);
	
	//Return cursor corresponding to id passed in.
	if(idcur == IDC_SIZENS && _hcurSizeNS)
		return _hcurSizeNS;

	if(idcur == IDC_SIZEWE && _hcurSizeWE)
		return _hcurSizeWE;

	if(idcur == IDC_SIZENWSE && _hcurSizeNWSE)
		return _hcurSizeNWSE;

	if(idcur == IDC_SIZENESW && _hcurSizeNESW)
		return _hcurSizeNESW;

	AssertSz(FALSE, "Failure loading sizing cursor.");

	return NULL;
}

/*
 *	Mirroring API (only in BiDi Win98 and NT5 upward)
 *
 *	@mfunc	Get/Set DC mirroring effect
 *
 */

DWORD WINAPI GetLayoutStub(HDC hdc)
{
	return 0;
}

DWORD WINAPI SetLayoutStub(HDC hdc, DWORD dwLayout)
{
	return 0;
}

DWORD WINAPI GetLayoutInit(HDC hdc)
{
#ifndef NOCOMPLEXSCRIPTS
	CLock		lock;
	HINSTANCE	hMod = ::GetModuleHandleA("GDI32.DLL");
	Assert(hMod);

	W32->_pfnGetLayout = (PFN_GETLAYOUT)GetProcAddress(hMod, "GetLayout");

	if (!W32->_pfnGetLayout)
		W32->_pfnGetLayout = &GetLayoutStub;
	return W32->_pfnGetLayout(hdc);
#else
	return 0;
#endif

}

DWORD WINAPI SetLayoutInit(HDC hdc, DWORD dwLayout)
{
#ifndef NOCOMPLEXSCRIPTS
	CLock		lock;
	HINSTANCE	hMod = ::GetModuleHandleA("GDI32.DLL");
	Assert(hMod);

	W32->_pfnSetLayout = (PFN_SETLAYOUT)GetProcAddress(hMod, "SetLayout");

	if (!W32->_pfnSetLayout)
		W32->_pfnSetLayout = &SetLayoutStub;
	return W32->_pfnSetLayout(hdc, dwLayout);
#else
	return 0;
#endif
}

PFN_GETLAYOUT	CW32System::_pfnGetLayout = &GetLayoutInit;
PFN_SETLAYOUT	CW32System::_pfnSetLayout = &SetLayoutInit;

ICustomTextOut *g_pcto;

STDAPI SetCustomTextOutHandlerEx(ICustomTextOut **ppcto, DWORD dwFlags)
{
	g_pcto = *ppcto;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\w32win32.cpp ===
/*
 *	Unicode <--> MultiByte conversions, OLE, and other system functions
 *
 *	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
 */
#include <objbase.h>	// CoCreateInstance define
#include "aimm.h"		// AIMM i/f
#include "aimmex.h"		// AIMMEX i/f
#include "aimm_i.c"		// AIMM CLSID etc

#include "_font.h"
#include "_uspi.h"

#include <wininet.h>

#define MAX_HKLS 256			// It will be a while before we have more KBs

static HINSTANCE g_hOleAut32 = NULL;
static HINSTANCE g_hOle32 = NULL;

#ifndef NOACCESSIBILITY 
static HINSTANCE g_hAcc = NULL;
static HINSTANCE g_hUser32 = NULL;
#endif

#define DXOFPRECT(prc)    ((prc)->right - (prc)->left)
#define DYOFPRECT(prc)    ((prc)->bottom - (prc)->top)

class CIMM32_PROC
{
public:
	void *ImmGetCompositionStringA;
	void *ImmGetCompositionStringW;
	void *ImmGetContext;
	void *ImmSetCompositionFontA;
	void *ImmSetCompositionWindow;
	void *ImmReleaseContext;
	void *ImmGetProperty;
	void *ImmGetCandidateWindow;
	void *ImmSetCandidateWindow;
	void *ImmNotifyIME;
	void *ImmAssociateContext;
	void *ImmGetVirtualKey;
	void *ImmEscapeA;
	void *ImmEscapeW;
	void *ImmGetOpenStatus;
	void *ImmSetOpenStatus;
	void *ImmGetConversionStatus;
	void *ImmSetConversionStatus;
	void *ImmGetDefaultIMEWnd;
	void *ImmSetCompositionStringW;
	void *ImmIsIME;
};
static CIMM32_PROC	g_IMM32Proc;

class CIMESHARE_PROC
{
public:
	void *FSupportSty;
	void *PIMEStyleFromAttr;
	void *PColorStyleTextFromIMEStyle;
	void *PColorStyleBackFromIMEStyle;
	void *FBoldIMEStyle;
	void *FItalicIMEStyle;
	void *FUlIMEStyle;
	void *IdUlIMEStyle;
	void *RGBFromIMEColorStyle;
};
static CIMESHARE_PROC	g_IMEShareProc;

class COLEAUT32_PROC
{
public:
	void *LoadRegTypeLib;
	void *LoadTypeLib;
	void *LoadTypeLibEx;
	void *SysAllocString;
	void *SysAllocStringLen;
	void *SysFreeString;
	void *SysStringLen;
	void *VariantInit;
	void *VariantClear;
};
static COLEAUT32_PROC	g_OleAut32Proc;

class COLE32_PROC
{
public:
	void *OleCreateFromData;
	void *CoTaskMemFree;
	void *CreateBindCtx;
	void *OleDuplicateData;
	void *CoTreatAsClass;
	void *ProgIDFromCLSID;
	void *OleConvertIStorageToOLESTREAM;
	void *OleConvertIStorageToOLESTREAMEx;
	void *OleSave;
	void *StgCreateDocfileOnILockBytes;
	void *CreateILockBytesOnHGlobal;
	void *OleCreateLinkToFile;
	void *CoTaskMemAlloc;
	void *CoTaskMemRealloc;
	void *OleInitialize;
	void *OleUninitialize;
	void *OleSetClipboard;
	void *OleFlushClipboard;
	void *OleIsCurrentClipboard;
	void *DoDragDrop;
	void *OleGetClipboard;
	void *RegisterDragDrop;
	void *OleCreateLinkFromData;
	void *OleCreateStaticFromData;
	void *OleDraw;
	void *OleSetContainedObject;
	void *CoDisconnectObject;
	void *WriteFmtUserTypeStg;
	void *WriteClassStg;
	void *SetConvertStg;
	void *ReadFmtUserTypeStg;
	void *ReadClassStg;
	void *OleRun;
	void *RevokeDragDrop;
	void *CreateStreamOnHGlobal;
	void *GetHGlobalFromStream;
	void *OleCreateDefaultHandler;
	void *CLSIDFromProgID;
	void *OleConvertOLESTREAMToIStorage;
	void *OleLoad;
	void *ReleaseStgMedium;
	void *CoCreateInstance;
	void *OleCreateFromFile;
};
static COLE32_PROC	g_Ole32Proc;

class CConvertStr
{
public:
    operator char *();

protected:
    CConvertStr();
    ~CConvertStr();
    void Free();

    LPSTR   _pstr;
    char    _ach[MAX_PATH * 2];
};

inline CConvertStr::operator char *()
{
    return _pstr;
}

inline CConvertStr::CConvertStr()
{
    _pstr = NULL;
}

inline CConvertStr::~CConvertStr()
{
    Free();
}

class CStrIn : public CConvertStr
{
public:
    CStrIn(LPCWSTR pwstr, UINT CodePage = CP_ACP);
    CStrIn(LPCWSTR pwstr, int cwch, UINT CodePage = CP_ACP);
    int strlen();

protected:
    CStrIn();
    void Init(LPCWSTR pwstr, int cwch, UINT CodePage = CP_ACP);

    int _cchLen;
};

inline CStrIn::CStrIn()
{
}

inline int CStrIn::strlen()
{
    return _cchLen;
}

class CStrOut : public CConvertStr
{
public:
    CStrOut(LPWSTR pwstr, int cwchBuf);
    ~CStrOut();

    int     BufSize();
    int     Convert();

private:
    LPWSTR  _pwstr;
    int     _cwchBuf;
};

inline int CStrOut::BufSize()
{
    return _cwchBuf * 2;
}

//
//	Multi-Byte ---> Unicode conversion
//

class CStrOutW : public CConvertStrW
{
public:
    CStrOutW(LPSTR pstr, int cchBuf, UINT uiCodePage);
    ~CStrOutW();

    int     BufSize();
    int     Convert();

private:

    LPSTR  	_pstr;
    int     _cchBuf;
	UINT	_uiCodePage;
};

inline int CStrOutW::BufSize()
{
    return _cchBuf;
}

DWORD CW32System::AddRef()
{
	return ++_cRefs;
}

DWORD CW32System::Release()
{
	DWORD culRefs =	--_cRefs;

	if(culRefs == 0)
	{
#ifndef NOFEPROCESSING
		FreeIME();
#endif
		if (g_hOle32)
		{
			EnterCriticalSection(&g_CriticalSection);
			OleUninitialize();
			FreeLibrary(g_hOle32);
			g_hOle32 = NULL;
			memset(&g_Ole32Proc, 0, sizeof(g_Ole32Proc));
 			LeaveCriticalSection(&g_CriticalSection);
		}
	}
	return culRefs;
}

ATOM WINAPI CW32System::RegisterREClass(
	const WNDCLASSW *lpWndClass)
{
	WNDCLASSA wc;
	ATOM atom;

	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "RegisterREClass");
	// First register the normal window class.
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
	{
		atom = ::RegisterClass(lpWndClass); 
		if (!atom && GetLastError() == ERROR_CLASS_ALREADY_EXISTS)
			atom = FindAtom(lpWndClass->lpszClassName);
	}
	else
	{
		// On WIndows 95 we need to convert the window class name.
		CStrIn strMenuName(lpWndClass->lpszMenuName);
		CStrIn strClassName(lpWndClass->lpszClassName);
		Assert(sizeof(wc) == sizeof(*lpWndClass));
		memcpy(&wc, lpWndClass, sizeof(wc));
		wc.lpszMenuName = strMenuName;
		wc.lpszClassName = strClassName;
		
		atom = ::RegisterClassA(&wc);		
		if (!atom && GetLastError() == ERROR_CLASS_ALREADY_EXISTS)
			atom = FindAtomA(wc.lpszClassName);
	}

	return atom;
}

LONG ValidateTextRange(TEXTRANGE *pstrg);

LRESULT CW32System::ANSIWndProc(
	HWND	hwnd,
	UINT	msg,
	WPARAM	wparam,
	LPARAM	lparam,
	BOOL	fIs10Mode)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditANSIWndProc");

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	LRESULT	lres;

	switch( msg )
	{

	case EM_REPLACESEL:
	case WM_SETTEXT:
	{	
		SETTEXTEX st = {ST_CHECKPROTECTION, 0};
				if(msg == EM_REPLACESEL)
		{
			st.flags = wparam ? ST_CHECKPROTECTION | ST_SELECTION | ST_KEEPUNDO | ST_10REPLACESEL
							  :	ST_CHECKPROTECTION | ST_SELECTION | ST_10REPLACESEL;
		}
		else if (fIs10Mode)
			st.flags |= ST_10WM_SETTEXT;		// 1.0 Mode WM_SETTEXT

		return RichEditWndProc(hwnd, EM_SETTEXTEX, (WPARAM)&st, lparam);
	}

	case EM_FINDTEXT:
	case EM_FINDTEXTEX:
		{
			// We cheat a little here because FINDTEXT and FINDTEXTEX overlap
			// with the exception of the extra out param chrgText in FINDTEXTEX
			FINDTEXTEXW ftexw;
			FINDTEXTA *pfta = (FINDTEXTA *)lparam;
			CStrInW strinw(pfta->lpstrText, W32->GetKeyboardCodePage());

			ftexw.chrg = pfta->chrg;
			ftexw.lpstrText = (WCHAR *)strinw;

			lres = RichEditWndProc(hwnd, msg, wparam, (LPARAM)&ftexw);
			
			if(msg == EM_FINDTEXTEX)
			{
				// In the FINDTEXTEX case, the extra field in the
				// FINDTEXTEX data structure is an out parameter indicating
				// the range where the text was found.  Update the 'real'
				// [in, out] parameter accordingly.	
				((FINDTEXTEXA *)lparam)->chrgText = ftexw.chrgText;
			}
			return lres;
		}
		break;				

	case EM_GETSELTEXT:
		{
			GETTEXTEX gt;
			const char chDefault = ' ';

			gt.cb = (unsigned)-1;			// Client claims to have enuf room		
			gt.flags = GT_SELECTION;		// Get selected text
			gt.codepage = (unsigned)-1;		// Use default CCharFormat codepage
			gt.lpDefaultChar = &chDefault;	// Translate other chars into blanks
			gt.lpUsedDefChar = NULL;

			return RichEditWndProc(hwnd, EM_GETTEXTEX, (WPARAM)&gt, lparam);
		}
		break;

	// case WM_GETTEXT:	Handled by Ansi filter

	// case WM_GETTEXTLENGTH: Handled by Ansi filter

	case EM_GETTEXTRANGE:
		{
			TEXTRANGEA *ptrg = (TEXTRANGEA *)lparam;

            LONG clInBuffer = ValidateTextRange((TEXTRANGEW *) ptrg);

            // If size is -1, this means that the size required is the total
            // size of the the text.
            if(-1 == clInBuffer)
            {
                // We can get this length either by digging the data out of the
                // various structures below us or we can take advantage of the
                // WM_GETTEXTLENGTH message. The first might be slightly 
                // faster but the second definitely save code size. So we
                // will go with the second.
                clInBuffer = SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);
            }

            if(0 == clInBuffer)
            {
                // The buffer was invalid for some reason or there was not data
                // to copy. In any case, we are done.
                return 0;
            }

            // Verify that the output buffer is big enough.
            if(IsBadWritePtr(ptrg->lpstrText, clInBuffer + 1))
            {
                // Not enough space so don't copy any
                return 0;
            }

			// For EM_GETTEXTRANGE case, we again don't know how big the
			// incoming buffer is, only that it should be *at least* as
			// great as cpMax - cpMin in the text range structure.  We also
			// know that anything *bigger* than (cpMax - cpMin)*2 bytes is
			// uncessary.  So we'll just assume that it's "big enough"
			// and let WideCharToMultiByte scribble as much as it needs.
			// Memory shortages are the caller's responsibility (courtesy
			// of the RichEdit 1.0 design).
			
			CStrOutW stroutw(ptrg->lpstrText, (clInBuffer + 1) * sizeof(WCHAR), 
							 RichEditWndProc(hwnd, EM_GETCODEPAGE, 0, 0));
			TEXTRANGEW trgw;
			trgw.chrg = ptrg->chrg;
			trgw.lpstrText = (WCHAR *)stroutw;

			RichEditWndProc(hwnd, EM_GETTEXTRANGE, wparam, (LPARAM)&trgw);
			
			return stroutw.Convert();	// Return count of BYTEs converted
		}

	case EM_GETLINE:
		{
			// The size is indicated by the first word of the memory pointed
			// to by lparam
			WORD size = *(WORD *)lparam;
			CStrOutW stroutw((char *)lparam, (DWORD)size,
							 RichEditWndProc(hwnd, EM_GETCODEPAGE, 0, 0));
			WCHAR *pwsz = (WCHAR *)stroutw;
			*(WORD *)pwsz = size;

			lres = RichEditWndProc(hwnd, msg, wparam, (LPARAM)pwsz);

			if (lres < size)
				*(pwsz+lres) = L'\0';		// EM_GETLINE does not return NULL-terminated string.
			LONG cach = stroutw.Convert();
			return fIs10Mode ? cach : lres;	// Return count of BYTEs converted
		}

#ifdef DEBUG
	case WM_NCCREATE:
	case WM_CREATE:
		// These messages should be handled higher up so let everyone
		// know we got to the wrong place!
		AssertSz(FALSE, "CW32System::ANSIWndProc got WM_CREATE or WM_NCCREATE");
		break;

#endif // DEBUG

	}
	return RichEditWndProc(hwnd, msg, wparam, lparam);
}

// Note that AnsiFilter could be refined so that we could get rid
// of the ANSI window proc.
void CW32System::AnsiFilter(
	UINT &	msg,
	WPARAM &wparam,
	LPARAM lparam,
	void *pvoid,
	BOOL f10Mode
)
{
	GETTEXTEX *pgt;
	GETTEXTLENGTHEX *pgtl;
	WM_CHAR_INFO *pwmci;
	bool fAltNumPad = (GetKeyboardFlags() & ALTNUMPAD) != 0;
	UINT cpg = GetKeyboardCodePage(0xFFFFFFFF);

	switch (msg)
	{
		case WM_CHAR:
			pwmci = (WM_CHAR_INFO *) pvoid;
			pwmci->_fTrailByte = false;
			pwmci->_fLeadByte = false;
			pwmci->_fIMEChar = false;
			if (pwmci->_fAccumulate) {
				// We could do some validation here.
				pwmci->_fTrailByte = true;
				return;
			}
			// WM_CHAR > 256 on Win95; assumed to be Unicode

			if(fAltNumPad)
			{
				DWORD Number = GetKeyPadNumber();
				if(Number >= 256 || GetKeyboardFlags() & ALT0)
				{
					wparam = Number;
					if(!IN_RANGE(1250, cpg, 1258))	// Use 1252 for DBCS
						cpg = 1252;					//  codepages
				}
			}

			if(IN_RANGE(128, wparam, 255))
			{							
				bool fShift = (GetKeyboardFlags() & SHIFT) != 0;
				bool fCtrl  = (GetKeyboardFlags() & CTRL)  != 0;

				// If fAltNumPad is set, wparam is HiAnsi
				// If Shift + Alt + Ctrl, it is repeat event from Win3.1 IME
				if ((!fAltNumPad || (fShift && fCtrl)) && GetTrailBytesCount((BYTE) wparam, cpg))
				{
					pwmci->_fLeadByte = true;
					return;
				}
				WPARAM	wparamNew = 0;
				switch ( cpg )
				{				
					case CP_JAPAN:
						// for Japanese codepage, need to translate SBC if KANA mode is on					 
						if ((GetKeyState(VK_KANA) & 1) || f10Mode)		
							break;
						// If not in KANA mode, then fall thru to use 1252 codepage...
					case CP_KOREAN:
					case CP_CHINESE_TRAD:
					case CP_CHINESE_SIM:
						// use English codepage since there is no HiAnsi conversion for
						// FE systems
						cpg = 1252;
						break;				
				}

				if (cpg == 1252 && !IN_RANGE(0x80, wparam, 0x9f))
					return;

				// Convert single byte WM_CHAR messages to Unicode
				if(UnicodeFromMbcs((LPWSTR)&wparamNew, 1, (char *)&wparam, 1,
					cpg) == 1 )
				{
					wparam = wparamNew;
					if (fAltNumPad)
						SetKeyPadNumber(wparam);
				}
			}
			else if(lparam == 1 && _dwPlatformId == VER_PLATFORM_WIN32_NT &&
				wparam > 256 && !fAltNumPad)
			{		
				// On WinNT s/w generated WM_CHAR, this should be WM_IME_CHAR message
				// for some Chinese Level 2 IME.
				if ( cpg == CP_CHINESE_SIM || cpg == CP_CHINESE_TRAD )
				{
					BYTE	bTrailByte = wparam >> 8;
					BYTE	bLeadByte = wparam;
					wparam =  (bLeadByte << 8) | bTrailByte;
					pwmci->_fIMEChar = true;
				}
			}
			return;

		case WM_GETTEXT:
			// EVIL HACK ALERT: on Win95, WM_GETTEXT should always be treated
			// as an ANSI message.
			pgt = (GETTEXTEX *) pvoid;
			pgt->cb = wparam;
			pgt->flags = GT_USECRLF;
			pgt->codepage = 0;
			pgt->lpDefaultChar = NULL;
			pgt->lpUsedDefChar = NULL;
			msg = EM_GETTEXTEX;
			wparam = (WPARAM) pgt;
			return;

		case WM_GETTEXTLENGTH:
			// EVIL HACK ALERT: on Win95, WM_GETEXTLENGTH should always
			// be treated an ANSI message because some old apps will send
			// this message to arbitrary windows (e.g., accessibility aps)
			pgtl = (GETTEXTLENGTHEX *) pvoid;
			pgtl->flags = GTL_NUMBYTES | GTL_PRECISE | GTL_USECRLF;
			pgtl->codepage = 0;
			msg = EM_GETTEXTLENGTHEX;
			wparam = (WPARAM) pgtl;
			return;
	}
}

/*
 *	CW32System::CheckChangeKeyboardLayout (iCharRep)
 *
 *	@mfunc
 *		Change keyboard for new character repertoire, or charrep at new
 *		character position.
 *
 *	@rdesc
 *		Keyboard hkl selected. 0 if failed to find keyboard
 *
 *	@comm
 *		Using only the currently loaded KBs, locate one that will support
 *		bCharSet. This is called anytime a character format	change occurs,
 *		or the caret position changes.
 *
 *	@devnote
 *		The current KB is preferred. If a previous association was made,
 *		see if the KB is still loaded in the system and if so use it.
 *		Otherwise, locate a suitable KB, preferring KB's that have
 *		the same charset ID as their default, preferred charset. If no
 *		match can be found, nothing changes.
 */
HKL CW32System::CheckChangeKeyboardLayout(
	BYTE iCharRep)
{
	return ActivateKeyboard(iCharRep);
}

HKL CW32System::GetKeyboardLayout (
	DWORD dwThreadID)
{
	if(dwThreadID == 0x0FFFFFFFF)
		RefreshKeyboardLayout();

	return _hklCurrent;
}

/*
 *	CW32System::RefreshKeyboardLayout ()
 *
 *	@mfunc
 *		Update _hklCurrent with current keyboard layout and update
 *		entry for corresponding script.
 */
void CW32System::RefreshKeyboardLayout ()
{
	_hklCurrent = ::GetKeyboardLayout(0);
	LONG iCharRep = CharRepFromLID(LOWORD(_hklCurrent));
	SetPreferredKbd(iCharRep, _hklCurrent);
}

/*
 *	CW32System::ActivateKeyboard (iCharRep)
 *
 *	@mfunc
 *		Change keyboard to that for iCharRep
 *
 *	@rdesc
 *		Keyboard hkl selected. 0 if no keyboard assigned to iCharRep
 */
HKL CW32System::ActivateKeyboard(
	LONG iCharRep)
{
	HKL hkl = 0;
	if((unsigned)iCharRep < NCHARREPERTOIRES)
	{
		hkl = GetPreferredKbd(iCharRep);
		if(hkl)
		{
			if(hkl != _hklCurrent && ActivateKeyboardLayout(hkl, 0))
				_hklCurrent = hkl;

			AssertSz(hkl == ::GetKeyboardLayout(0),
				"CW32System::ActivateKeyboard: incorrect _hklCurrent");
		}
	}
	return hkl;
}

#ifndef NOCOMPLEXSCRIPTS
/*
 *	CW32System::FindDirectionalKeyboard (fRTL)
 *
 *	@mfunc
 *		Find first keyboard with direction given by fRTL
 *
 *	@rdesc
 *		HKL of keyboard selected. 0 if no keyboard for direction given by fRTL
 */
HKL CW32System::FindDirectionalKeyboard(
	BOOL fRTL)
{
	Assert(ARABIC_INDEX == HEBREW_INDEX + 1);
	int iCharRep;

	if(fRTL)
	{
		iCharRep = CharRepFromCodePage(GetACP());
		if(!IN_RANGE(HEBREW_INDEX, iCharRep, ARABIC_INDEX))
			iCharRep = _hkl[HEBREW_INDEX] ? HEBREW_INDEX :
				  _hkl[ARABIC_INDEX] ? ARABIC_INDEX : -1;
	}
	else
		for(iCharRep = 0;
			iCharRep < NCHARREPERTOIRES && (!_hkl[iCharRep] || IN_RANGE(HEBREW_INDEX, iCharRep, ARABIC_INDEX));
			iCharRep++)
				;
	return ActivateKeyboard(iCharRep);
}
#endif


enum DLL_ENUM{
	DLL_OLEAUT32,
	DLL_OLE32,
	
#ifndef NOACCESSIBILITY 
	DLL_ACC,
	DLL_USER32
#endif
};

static void SetProcAddr(
	void * & pfunc,
	DLL_ENUM which,
	char *	 fname )
{
	HINSTANCE hdll = NULL;
	EnterCriticalSection(&g_CriticalSection);
	if (pfunc == NULL)
	{
		switch (which)
		{
		case DLL_OLEAUT32:
			if (g_hOleAut32 == NULL)
				g_hOleAut32 = W32->LoadLibrary(L"oleaut32.dll" );

			hdll = g_hOleAut32;
			break;

		case DLL_OLE32:
			if (g_hOle32 == NULL)
			{
				g_hOle32 = W32->LoadLibrary(L"ole32.dll");
				CW32System::OleInitialize(NULL);
			}
			hdll = g_hOle32;
			break;

#ifndef NOACCESSIBILITY 
		case DLL_ACC:
			if (g_hAcc == NULL)
				g_hAcc = W32->LoadLibrary(L"oleacc.dll");
			hdll = g_hAcc;
			break;

		case DLL_USER32:
			if (g_hUser32 == NULL)
				g_hUser32 = W32->LoadLibrary(L"user32.dll");
			hdll = g_hUser32;
			break;
#endif			
		}

		Assert(hdll != NULL || which == DLL_USER32);
		pfunc = GetProcAddress( hdll, fname );
	}
	AssertSz(pfunc != NULL || which == DLL_USER32, fname);
 	LeaveCriticalSection(&g_CriticalSection);
}

void CW32System::FreeOle()
{
	if (g_hOleAut32 || g_hOle32)
	{
		EnterCriticalSection(&g_CriticalSection);
		if (g_hOleAut32 != NULL)
		{
			FreeLibrary(g_hOleAut32);
			g_hOleAut32 = NULL;
			memset(&g_OleAut32Proc, 0, sizeof(g_OleAut32Proc));
		}
		if (g_hOle32 != NULL)
		{
			FreeLibrary(g_hOle32);
			g_hOle32 = NULL;
			memset(&g_Ole32Proc, 0, sizeof(g_Ole32Proc));
		}
 		LeaveCriticalSection(&g_CriticalSection);
	}
}

#ifndef NOFEPROCESSING
enum IME_DLL_ENUM{
	DLL_IMM32,
	DLL_IMESHARE
};

static HINSTANCE hIMM32 = NULL;
static HINSTANCE hIMEShare = NULL;

static void SetIMEProcAddr( void * &pfunc, IME_DLL_ENUM which, char * fname )
{
	HINSTANCE hdll = NULL;
	EnterCriticalSection(&g_CriticalSection);
	if (pfunc == NULL)
	{
		switch (which) {
		case DLL_IMM32 :
			if (hIMM32 == NULL)
				hIMM32 = W32->LoadLibrary(L"imm32.dll" );
			Assert( hIMM32 != NULL );
			hdll = hIMM32;
			break;
		case DLL_IMESHARE :
			if (hIMEShare == NULL)
				hIMEShare = W32->LoadLibrary(L"imeshare.dll" );
			else if (hIMEShare == (HINSTANCE)INVALID_HANDLE_VALUE)
				goto Exit;

			hdll = hIMEShare;

			// set to invalid handle if we have tried loading it.
			// this is to avoid loading it again and again in case
			// imeshare.dll is not in the system.
			if (hIMEShare == NULL)
				hIMEShare = (HINSTANCE)INVALID_HANDLE_VALUE;

			break;
		}
		if (hdll)
		{
			pfunc = GetProcAddress( hdll, fname );
			Assert(pfunc != NULL );
		}
	}
Exit:
 	LeaveCriticalSection(&g_CriticalSection);
}

static IActiveIMMApp *pAIMM = (IActiveIMMApp *) NULL;

typedef IMESHAREAPI void (IMECDECL*FEND_CAST)(void);
void CW32System::FreeIME()
{
	if (hIMM32 || hIMEShare || pAIMM) {
		EnterCriticalSection(&g_CriticalSection);
		if (hIMM32 != NULL && FreeLibrary(hIMM32)) {
			hIMM32 = NULL;
			memset(&g_IMM32Proc, 0, sizeof(g_IMM32Proc));
		}
		if (hIMEShare != NULL && hIMEShare != (HINSTANCE)INVALID_HANDLE_VALUE) {
			// clean up IMMShare before leaving
			if ( _pIMEShare )
			{
				_pIMEShare->FDeleteIMEShare();
				_pIMEShare = NULL;
			}
			else
			{
				// This is old IMEShare, end it the old way
				void *pEndIMEShareFunc;
				pEndIMEShareFunc = GetProcAddress( hIMEShare, "EndIMEShare" );
				if (pEndIMEShareFunc)
				{
					( (FEND_CAST)pEndIMEShareFunc)();
				}
			}
			FreeLibrary(hIMEShare);
			hIMEShare = NULL;
			memset(&g_IMEShareProc, 0, sizeof(g_IMEShareProc));
		}
		if (pAIMM != (IActiveIMMApp *)NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
		{
			pAIMM->Release();
			pAIMM = (IActiveIMMApp *)NULL;
		}
		_fHaveAIMM = FALSE;
		_fHaveIMMEShare = FALSE;
		_fHaveIMMProcs = FALSE;
		_fLoadAIMM10 = FALSE;
 		LeaveCriticalSection(&g_CriticalSection);
	}
}


// return TRUE if we load AIMM
BOOL CW32System::LoadAIMM(BOOL fUseAimm12)
{
	HRESULT	hResult = E_FAIL;
	BOOL	fLoadAimm10 = FALSE;

	// return if AIMM has been loaded in process
	if (_fHaveAIMM)
		return TRUE;

	if (pAIMM == (IActiveIMMApp *)INVALID_HANDLE_VALUE)
		return FALSE;

	EnterCriticalSection(&g_CriticalSection);

	if (fUseAimm12)
	{
		// load if it has not been loaded
		// Try with new W2K/COM+ CLSCTX_NO_CODE_DOWNLOAD flag
		hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM12,
			NULL, CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD, IID_IActiveIMMAppEx, (LPVOID *)&pAIMM);

		if (hResult == E_INVALIDARG)	// Try again if CLSCTX_NO_CODE_DOWNLOAD not support
			hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM12,
				NULL, CLSCTX_INPROC_SERVER, IID_IActiveIMMAppEx, (LPVOID *)&pAIMM);

		if (FAILED(hResult))
		{
			hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM12,
				NULL, CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD, IID_IActiveIMMApp, (LPVOID *)&pAIMM);

			if (hResult == E_INVALIDARG)	// Try again if CLSCTX_NO_CODE_DOWNLOAD not support
				hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM12,
					NULL, CLSCTX_INPROC_SERVER, IID_IActiveIMMApp, (LPVOID *)&pAIMM);
		}
	}

	if (FAILED(hResult))
	{
		// Try Aimm
		hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM,
			NULL, CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD, IID_IActiveIMMApp, (LPVOID *)&pAIMM);

		if (hResult == E_INVALIDARG)	// Try again if CLSCTX_NO_CODE_DOWNLOAD not support
			hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM,
				NULL, CLSCTX_INPROC_SERVER, IID_IActiveIMMApp, (LPVOID *)&pAIMM);
		fLoadAimm10 = TRUE;
	}

	if (FAILED(hResult))
	{	
		_fHaveAIMM = FALSE;
		pAIMM = (IActiveIMMApp *)INVALID_HANDLE_VALUE;	
	}
	else
	{
		_fHaveAIMM = TRUE;
		_fLoadAIMM10 = fLoadAimm10;
	}
	LeaveCriticalSection(&g_CriticalSection);

	return _fHaveAIMM ? TRUE : FALSE;
}

// Return the Aimm object and AddRef()
BOOL CW32System::GetAimmObject(IUnknown **ppAimm)
{

	*ppAimm = NULL;

	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		pAIMM->AddRef();
		*ppAimm = pAIMM;
		return TRUE;
	}

	return FALSE;
}

// Return the GUID for IME Display attributes
UINT CW32System::GetDisplayGUID(
	HIMC hIMC,
	UINT uAttribute)
{
	if (_fLoadAIMM10 || !pAIMM || uAttribute <= ATTR_FIXEDCONVERTED)
		return uAttribute;

	DWORD dwGuidatom;

	if (((IActiveIMMAppEx *)pAIMM)->GetGuidAtom(hIMC, (BYTE)uAttribute, &dwGuidatom) == S_OK)
		uAttribute = dwGuidatom;

   return uAttribute;
}

// return TRUE if we have IMEShare in system
// else return FALSE

typedef IMESHAREAPI BOOL (IMECDECL*FINIT_CAST)(void);
typedef IMESHAREAPI CIMEShare *  (IMECDECL*FPIME_CAST)(void);
BOOL CW32System::HaveIMEShare()
{
	// return if IMEShare has been loaded
	if (_fHaveIMMEShare)
		return TRUE;

	if (hIMEShare == (HINSTANCE)INVALID_HANDLE_VALUE)
		return FALSE;

	EnterCriticalSection(&g_CriticalSection);

	// load if it has not been loaded
	hIMEShare = W32->LoadLibrary(L"imeshare.dll");

	_fHaveIMMEShare = TRUE;
	// load fail, setup INVALID_HANDLE_VALUE
	if (hIMEShare == NULL)
	{
		hIMEShare = (HINSTANCE)INVALID_HANDLE_VALUE;
		_fHaveIMMEShare = FALSE;
	}
	else
	{
		// get the new IMEshare object and init the DLL
		void *pPIMEShareCreate;
		pPIMEShareCreate = GetProcAddress( hIMEShare, "PIMEShareCreate" );

		if (pPIMEShareCreate)
		{
			_pIMEShare = ( (FPIME_CAST)pPIMEShareCreate) ();
			
			if ( _pIMEShare == NULL )
				_fHaveIMMEShare = FALSE;
			else
			{
				// Setup underline styles that RE supports
				for (int i = IMESTY_UL_MIN; i <= IMESTY_UL_MAX; i++)
				{
					if (i == 2004 || i == 2007 || i == 2008 ||
						i == 2009 || i == 2010)			// Obsolete styles
						continue;
    
					_pIMEShare->FSupportSty(i, i);
				}
			}
		}
		else
		{
			// This is old IMEShare, init it the old way
			void *pInitFunc;
			pInitFunc = GetProcAddress( hIMEShare, "FInitIMEShare" );
			if (pInitFunc)
			{
				_fHaveIMMEShare = ( (FINIT_CAST)pInitFunc)();
			}
			else
				// init failed, forget it
				_fHaveIMMEShare = FALSE;
		}

		if (_fHaveIMMEShare == FALSE)
		{
			// Init failed, forget it
			FreeLibrary(hIMEShare);
			hIMEShare = (HINSTANCE)INVALID_HANDLE_VALUE;
		}
	}
	
	LeaveCriticalSection(&g_CriticalSection);

	return _fHaveIMMEShare;
}

BOOL CW32System::getIMEShareObject(CIMEShare **ppIMEShare)
{
	*ppIMEShare = _pIMEShare;

	return (_pIMEShare != NULL);
}

HRESULT CW32System::AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		LRESULT	localLRes;

		hResult = pAIMM->OnDefWindowProc(hWnd, msg, wparam, lparam, &localLRes);

		if (hResult == S_OK)
		{
			*plres = localLRes;
			return S_OK;
		}
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMGetCodePage(HKL hKL, UINT *uCodePage)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->GetCodePageA(hKL, uCodePage);

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMActivate(BOOL fRestoreLayout)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->Activate(fRestoreLayout);

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMDeactivate(void)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->Deactivate();

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize, HWND hWnd)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		IActiveIMMAppEx *pAIMMEx = (IActiveIMMAppEx *) NULL;
		hResult = pAIMM->QueryInterface(IID_IActiveIMMAppEx, (LPVOID *)&pAIMMEx);

		if (pAIMMEx)
		{
			hResult = pAIMMEx->FilterClientWindowsEx(hWnd, FALSE);
			pAIMMEx->Release();

			if (SUCCEEDED(hResult))
				return S_OK;

			Assert(FALSE);
		}

		hResult = pAIMM->FilterClientWindows(aaClassList, uSize);

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMUnfilterClientWindows(HWND hWnd)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		IActiveIMMAppEx *pAIMMEx = (IActiveIMMAppEx *) NULL;
		hResult = pAIMM->QueryInterface(IID_IActiveIMMAppEx, (LPVOID *)&pAIMMEx);

		if (pAIMMEx)
		{
			hResult = pAIMMEx->UnfilterClientWindowsEx(hWnd);
			pAIMMEx->Release();

			if (SUCCEEDED(hResult))
				return S_OK;
		}
	}
	return S_FALSE;
}

#define RE_OLEAUTAPI(name) 		DECLSPEC_IMPORT HRESULT (STDAPICALLTYPE *name)
#define RE_OLEAUTAPI_(type, name) 	DECLSPEC_IMPORT type (STDAPICALLTYPE *name)

typedef RE_OLEAUTAPI(LRTL_CAST)(REFGUID, WORD, WORD, LCID, ITypeLib **);
HRESULT CW32System::LoadRegTypeLib (
	REFGUID rguid,
	WORD wmajor,
	WORD wminor,
	LCID lcid,
	ITypeLib ** pptlib
)
{
	if (g_OleAut32Proc.LoadRegTypeLib == NULL)
		SetProcAddr( g_OleAut32Proc.LoadRegTypeLib, DLL_OLEAUT32, "LoadRegTypeLib" );
	return ((LRTL_CAST)g_OleAut32Proc.LoadRegTypeLib)(rguid, wmajor, wminor, lcid, pptlib);
}

typedef RE_OLEAUTAPI(LTL_CAST)(const OLECHAR *, ITypeLib **);
HRESULT CW32System::LoadTypeLib ( const OLECHAR *szfile, ITypeLib **pptlib )
{
	if (g_OleAut32Proc.LoadTypeLib == NULL)
		SetProcAddr( g_OleAut32Proc.LoadTypeLib, DLL_OLEAUT32, "LoadTypeLib" );
	return ((LTL_CAST)g_OleAut32Proc.LoadTypeLib)(szfile, pptlib);
}

typedef RE_OLEAUTAPI(LTLEX_CAST)(const OLECHAR *, REGKIND, ITypeLib **);
HRESULT CW32System::LoadTypeLibEx ( const OLECHAR *szfile, REGKIND regkind, ITypeLib **pptlib )
{
	if (g_OleAut32Proc.LoadTypeLibEx == NULL)
		SetProcAddr( g_OleAut32Proc.LoadTypeLibEx, DLL_OLEAUT32, "LoadTypeLibEx" );
	
	if (g_OleAut32Proc.LoadTypeLibEx == NULL)
		return E_FAIL;

	return ((LTLEX_CAST)g_OleAut32Proc.LoadTypeLibEx)(szfile, regkind, pptlib);
}

typedef RE_OLEAUTAPI_(BSTR, SAS_CAST)(const OLECHAR *);
BSTR CW32System::SysAllocString ( const OLECHAR * sz )
{
	if (g_OleAut32Proc.SysAllocString == NULL)
		SetProcAddr( g_OleAut32Proc.SysAllocString, DLL_OLEAUT32, "SysAllocString" );
	return ((SAS_CAST)g_OleAut32Proc.SysAllocString)(sz);
}

typedef RE_OLEAUTAPI_(BSTR, SASL_CAST)(const OLECHAR *, UINT);
BSTR CW32System::SysAllocStringLen ( const OLECHAR *pch, UINT cch )
{
	if (g_OleAut32Proc.SysAllocStringLen == NULL)
		SetProcAddr( g_OleAut32Proc.SysAllocStringLen, DLL_OLEAUT32, "SysAllocStringLen" );
	return ((SASL_CAST)g_OleAut32Proc.SysAllocStringLen)(pch, cch);
}

typedef RE_OLEAUTAPI_(void, SFS_CAST)(BSTR);
void CW32System::SysFreeString ( BSTR bstr )
{
	if (g_OleAut32Proc.SysFreeString == NULL)
		SetProcAddr( g_OleAut32Proc.SysFreeString, DLL_OLEAUT32, "SysFreeString" );
	((SFS_CAST)g_OleAut32Proc.SysFreeString)(bstr);
}

typedef RE_OLEAUTAPI_(UINT, SSL_CAST)(BSTR);
UINT CW32System::SysStringLen ( BSTR bstr )
{
	if (g_OleAut32Proc.SysStringLen == NULL)
		SetProcAddr( g_OleAut32Proc.SysStringLen, DLL_OLEAUT32, "SysStringLen" );
	return ((SSL_CAST)g_OleAut32Proc.SysStringLen)(bstr);
}

typedef RE_OLEAUTAPI_(void, VI_CAST)(VARIANTARG *);
void CW32System::VariantInit ( VARIANTARG * pvarg )
{
	if (g_OleAut32Proc.VariantInit == NULL)
		SetProcAddr( g_OleAut32Proc.VariantInit, DLL_OLEAUT32, "VariantInit" );
	((VI_CAST)g_OleAut32Proc.VariantInit)(pvarg);
}

typedef RE_OLEAUTAPI_(void, VC_CAST)(VARIANTARG *);
void CW32System::VariantClear ( VARIANTARG * pvarg )
{
	if (g_OleAut32Proc.VariantClear == NULL)
		SetProcAddr( g_OleAut32Proc.VariantClear, DLL_OLEAUT32, "VariantClear" );
	((VC_CAST)g_OleAut32Proc.VariantClear)(pvarg);
}

#define RE_OLE32API(name)		DECLSPEC_IMPORT	HRESULT (STDAPICALLTYPE *name)
#define RE_OLE32API_(type, name) DECLSPEC_IMPORT type (STDAPICALLTYPE *name)

typedef RE_OLE32API(OCFD_CAST)(LPDATAOBJECT, REFIID, DWORD, 
							   LPFORMATETC, LPOLECLIENTSITE,
							   LPSTORAGE, void **);
HRESULT CW32System::OleCreateFromData (
	LPDATAOBJECT pDataObj,
	REFIID riid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	LPOLECLIENTSITE pClientSite,
	LPSTORAGE pStg,
	void **ppvObj
)
{
	if (g_Ole32Proc.OleCreateFromData == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateFromData, DLL_OLE32, "OleCreateFromData" );
	return ((OCFD_CAST)g_Ole32Proc.OleCreateFromData)(pDataObj, riid, renderopt, pfetc, pClientSite, pStg, ppvObj);
}

typedef RE_OLE32API_(void, CTMF_CAST)(LPVOID);
void CW32System::CoTaskMemFree ( LPVOID pv )
{
	if (g_Ole32Proc.CoTaskMemFree == NULL)
		SetProcAddr( g_Ole32Proc.CoTaskMemFree, DLL_OLE32, "CoTaskMemFree" );
	((CTMF_CAST)g_Ole32Proc.CoTaskMemFree)(pv);
}

typedef RE_OLE32API(CBC_CAST)(DWORD, LPBC *);
HRESULT CW32System::CreateBindCtx ( DWORD reserved, LPBC * ppbc )
{
	if (g_Ole32Proc.CreateBindCtx == NULL)
		SetProcAddr( g_Ole32Proc.CreateBindCtx, DLL_OLE32, "CreateBindCtx" );
	return ((CBC_CAST)g_Ole32Proc.CreateBindCtx)(reserved, ppbc);
}

typedef RE_OLE32API_(HANDLE, ODD_CAST)(HANDLE, CLIPFORMAT, UINT);
HANDLE CW32System::OleDuplicateData ( HANDLE hSrc, CLIPFORMAT cfFormat, UINT uFlags )
{
	if (g_Ole32Proc.OleDuplicateData == NULL)
		SetProcAddr( g_Ole32Proc.OleDuplicateData, DLL_OLE32, "OleDuplicateData" );
	return ((ODD_CAST)g_Ole32Proc.OleDuplicateData)(hSrc, cfFormat, uFlags);
}

typedef RE_OLE32API(CTAC_CAST)(REFCLSID, REFCLSID);
HRESULT CW32System::CoTreatAsClass ( REFCLSID clsidold, REFCLSID clsidnew )
{
	if (g_Ole32Proc.CoTreatAsClass == NULL)
		SetProcAddr( g_Ole32Proc.CoTreatAsClass, DLL_OLE32, "CoTreatAsClass" );
	return ((CTAC_CAST)g_Ole32Proc.CoTreatAsClass)(clsidold, clsidnew);
}

typedef RE_OLE32API(PIFC_CAST)(REFCLSID, LPOLESTR *);
HRESULT CW32System::ProgIDFromCLSID ( REFCLSID clsid, LPOLESTR * lplpszProgId )
{
	if (g_Ole32Proc.ProgIDFromCLSID == NULL)
		SetProcAddr( g_Ole32Proc.ProgIDFromCLSID, DLL_OLE32, "ProgIDFromCLSID" );
	return ((PIFC_CAST)g_Ole32Proc.ProgIDFromCLSID)(clsid, lplpszProgId);
}

typedef RE_OLE32API(OCITO_CAST)(LPSTORAGE, LPOLESTREAM);
HRESULT CW32System::OleConvertIStorageToOLESTREAM ( LPSTORAGE pstg, LPOLESTREAM lpolestream)
{
	if (g_Ole32Proc.OleConvertIStorageToOLESTREAM == NULL)
		SetProcAddr( g_Ole32Proc.OleConvertIStorageToOLESTREAM, DLL_OLE32, "OleConvertIStorageToOLESTREAM" );
	return ((OCITO_CAST)g_Ole32Proc.OleConvertIStorageToOLESTREAM)(pstg, lpolestream);
}

typedef RE_OLE32API(OCITOX_CAST)(LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM);
HRESULT CW32System::OleConvertIStorageToOLESTREAMEx (
	LPSTORAGE pstg,
	CLIPFORMAT cf,
	LONG lwidth,
	LONG lheight,
	DWORD dwsize,
	LPSTGMEDIUM pmedium,
	LPOLESTREAM lpolestream
)
{
	if (g_Ole32Proc.OleConvertIStorageToOLESTREAMEx == NULL)
		SetProcAddr( g_Ole32Proc.OleConvertIStorageToOLESTREAMEx, DLL_OLE32, "OleConvertIStorageToOLESTREAMEx" );
	return ((OCITOX_CAST)g_Ole32Proc.OleConvertIStorageToOLESTREAMEx)
		(pstg,cf, lwidth, lheight, dwsize, pmedium, lpolestream);
}

typedef RE_OLE32API(OS_CAST)(LPPERSISTSTORAGE, LPSTORAGE, BOOL);
HRESULT CW32System::OleSave ( LPPERSISTSTORAGE pPS, LPSTORAGE pstg, BOOL fSameAsLoad )
{
	if (g_Ole32Proc.OleSave == NULL)
		SetProcAddr( g_Ole32Proc.OleSave, DLL_OLE32, "OleSave" );
	return ((OS_CAST)g_Ole32Proc.OleSave)(pPS, pstg, fSameAsLoad);
}

typedef RE_OLE32API(SCDOI_CAST)(ILockBytes *, DWORD, DWORD, IStorage **);
HRESULT CW32System::StgCreateDocfileOnILockBytes (
	ILockBytes *plkbyt,
	DWORD grfmode,
	DWORD res,
	IStorage **ppstg
)
{
	if (g_Ole32Proc.StgCreateDocfileOnILockBytes == NULL)
		SetProcAddr( g_Ole32Proc.StgCreateDocfileOnILockBytes, DLL_OLE32, "StgCreateDocfileOnILockBytes" );
	return ((SCDOI_CAST)g_Ole32Proc.StgCreateDocfileOnILockBytes)(plkbyt, grfmode, res, ppstg);
}

typedef RE_OLE32API(CIOH_CAST)(HGLOBAL, BOOL, ILockBytes **);
HRESULT CW32System::CreateILockBytesOnHGlobal ( HGLOBAL hGlobal, BOOL fDel, ILockBytes **pplkbyt )
{
	if (g_Ole32Proc.CreateILockBytesOnHGlobal == NULL)
		SetProcAddr( g_Ole32Proc.CreateILockBytesOnHGlobal, DLL_OLE32, "CreateILockBytesOnHGlobal" );
	return ((CIOH_CAST)g_Ole32Proc.CreateILockBytesOnHGlobal)(hGlobal, fDel, pplkbyt);
}

typedef RE_OLE32API(OCLTF_CAST)(LPCOLESTR, REFIID, DWORD, LPFORMATETC,
								LPOLECLIENTSITE, LPSTORAGE, void **);
HRESULT CW32System::OleCreateLinkToFile( 
	LPCOLESTR pstr,
	REFIID rid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	LPOLECLIENTSITE psite,
	LPSTORAGE pstg, 
	void **ppstg
)
{
	if (g_Ole32Proc.OleCreateLinkToFile == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateLinkToFile, DLL_OLE32, "OleCreateLinkToFile" );
	return ((OCLTF_CAST)g_Ole32Proc.OleCreateLinkToFile)(pstr, rid, renderopt, pfetc, psite, pstg, ppstg);
}

typedef RE_OLE32API_(LPVOID, CTMA_CAST)(ULONG);
LPVOID CW32System::CoTaskMemAlloc ( ULONG cb )
{
	if (g_Ole32Proc.CoTaskMemAlloc == NULL)
		SetProcAddr( g_Ole32Proc.CoTaskMemAlloc, DLL_OLE32, "CoTaskMemAlloc" );
	return ((CTMA_CAST)g_Ole32Proc.CoTaskMemAlloc)(cb);
}

typedef RE_OLE32API_(LPVOID, CTMR_CAST)(LPVOID, ULONG);
LPVOID CW32System::CoTaskMemRealloc ( LPVOID pv, ULONG cv)
{
	if (g_Ole32Proc.CoTaskMemRealloc == NULL)
		SetProcAddr( g_Ole32Proc.CoTaskMemRealloc, DLL_OLE32, "CoTaskMemRealloc" );
	return ((CTMR_CAST)g_Ole32Proc.CoTaskMemRealloc)(pv, cv);
}

typedef RE_OLE32API(OI_CAST)(LPVOID);
HRESULT CW32System::OleInitialize ( LPVOID pvres )
{
	if (g_Ole32Proc.OleInitialize == NULL)
		SetProcAddr( g_Ole32Proc.OleInitialize, DLL_OLE32, "OleInitialize" );
	return ((OI_CAST)g_Ole32Proc.OleInitialize)(pvres);
}

typedef RE_OLE32API_(void, OUI_CAST)( void );
void CW32System::OleUninitialize ( void )
{
	if (g_Ole32Proc.OleUninitialize == NULL)
		SetProcAddr( g_Ole32Proc.OleUninitialize, DLL_OLE32, "OleUninitialize" );
	((OUI_CAST)g_Ole32Proc.OleUninitialize)();
}

typedef RE_OLE32API(OSC_CAST)(IDataObject *);
HRESULT CW32System::OleSetClipboard ( IDataObject *pdo )
{
	if (g_Ole32Proc.OleSetClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleSetClipboard, DLL_OLE32, "OleSetClipboard" );
	return ((OSC_CAST)g_Ole32Proc.OleSetClipboard)(pdo);
}

typedef RE_OLE32API(OFC_CAST)(void);
HRESULT CW32System::OleFlushClipboard ( void )
{
	if (g_Ole32Proc.OleFlushClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleFlushClipboard, DLL_OLE32, "OleFlushClipboard" );
	return ((OFC_CAST)g_Ole32Proc.OleFlushClipboard)();
}

typedef RE_OLE32API(OICC_CAST)(IDataObject *);
HRESULT CW32System::OleIsCurrentClipboard ( IDataObject *pdo )
{
	if (g_Ole32Proc.OleIsCurrentClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleIsCurrentClipboard, DLL_OLE32, "OleIsCurrentClipboard" );
	return ((OICC_CAST)g_Ole32Proc.OleIsCurrentClipboard)(pdo);
}

typedef RE_OLE32API(DDD_CAST)(IDataObject *, IDropSource *,
			DWORD, DWORD *);
HRESULT CW32System::DoDragDrop ( IDataObject *pdo, IDropSource *pds, DWORD dweffect, DWORD *pdweffect )
{
	if (g_Ole32Proc.DoDragDrop == NULL)
		SetProcAddr( g_Ole32Proc.DoDragDrop, DLL_OLE32, "DoDragDrop" );
	return ((DDD_CAST)g_Ole32Proc.DoDragDrop)(pdo, pds, dweffect, pdweffect);
}

typedef RE_OLE32API(OGC_CAST)(IDataObject **);
HRESULT CW32System::OleGetClipboard ( IDataObject **ppdo )
{
	if (g_Ole32Proc.OleGetClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleGetClipboard, DLL_OLE32, "OleGetClipboard" );
	return ((OGC_CAST)g_Ole32Proc.OleGetClipboard)(ppdo);
}

typedef RE_OLE32API(RDD_CAST)(HWND, IDropTarget *);
HRESULT CW32System::RegisterDragDrop ( HWND hwnd, IDropTarget *pdt )
{
	if (g_Ole32Proc.RegisterDragDrop == NULL)
		SetProcAddr( g_Ole32Proc.RegisterDragDrop, DLL_OLE32, "RegisterDragDrop" );
	return ((RDD_CAST)g_Ole32Proc.RegisterDragDrop)(hwnd, pdt);
}

typedef RE_OLE32API(OCLFD_CAST)(IDataObject *, REFIID, DWORD,
								LPFORMATETC, IOleClientSite *,
								IStorage *, void **);
HRESULT CW32System::OleCreateLinkFromData (
	IDataObject *pdo,
	REFIID rid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	IOleClientSite *psite,
	IStorage *pstg,
	void **ppv
)
{
	if (g_Ole32Proc.OleCreateLinkFromData == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateLinkFromData, DLL_OLE32, "OleCreateLinkFromData" );
	return ((OCLFD_CAST)g_Ole32Proc.OleCreateLinkFromData)
		(pdo, rid, renderopt, pfetc, psite, pstg, ppv);
}

typedef RE_OLE32API(OCSFD_CAST)(IDataObject *, REFIID, DWORD,
								LPFORMATETC, IOleClientSite *,
								IStorage *, void **);
HRESULT CW32System::OleCreateStaticFromData (
	IDataObject *pdo,
	REFIID rid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	IOleClientSite *psite,
	IStorage *pstg,
	void **ppv
)
{
	if (g_Ole32Proc.OleCreateStaticFromData == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateStaticFromData, DLL_OLE32, "OleCreateStaticFromData" );
	return ((OCSFD_CAST)g_Ole32Proc.OleCreateStaticFromData)
		(pdo, rid, renderopt, pfetc, psite, pstg, ppv);
}

typedef RE_OLE32API(OD_CAST)(IUnknown *, DWORD, HDC, LPCRECT);
HRESULT CW32System::OleDraw ( IUnknown *punk, DWORD dwAspect, HDC hdc, LPCRECT prect )
{
	if (g_Ole32Proc.OleDraw == NULL)
		SetProcAddr( g_Ole32Proc.OleDraw, DLL_OLE32, "OleDraw" );
	return ((OD_CAST)g_Ole32Proc.OleDraw)(punk, dwAspect, hdc, prect);
}

typedef RE_OLE32API(OSCO_CAST)(IUnknown *, BOOL);
HRESULT CW32System::OleSetContainedObject ( IUnknown *punk, BOOL fContained )
{
	if (g_Ole32Proc.OleSetContainedObject == NULL)
		SetProcAddr( g_Ole32Proc.OleSetContainedObject, DLL_OLE32, "OleSetContainedObject" );
	return ((OSCO_CAST)g_Ole32Proc.OleSetContainedObject)(punk, fContained);
}

typedef RE_OLE32API(CDO_CAST)(IUnknown *, DWORD);
HRESULT CW32System::CoDisconnectObject ( IUnknown *punk, DWORD dwres )
{
	if (g_Ole32Proc.CoDisconnectObject == NULL)
		SetProcAddr( g_Ole32Proc.CoDisconnectObject, DLL_OLE32, "CoDisconnectObject" );
	return ((CDO_CAST)g_Ole32Proc.CoDisconnectObject)(punk, dwres);
}

typedef RE_OLE32API(WFUTS_CAST)(IStorage *, CLIPFORMAT, LPOLESTR);
HRESULT CW32System::WriteFmtUserTypeStg ( IStorage *pstg, CLIPFORMAT cf, LPOLESTR pstr)
{
	if (g_Ole32Proc.WriteFmtUserTypeStg == NULL)
		SetProcAddr( g_Ole32Proc.WriteFmtUserTypeStg, DLL_OLE32, "WriteFmtUserTypeStg" );
	return ((WFUTS_CAST)g_Ole32Proc.WriteFmtUserTypeStg)(pstg, cf, pstr);
}

typedef RE_OLE32API(WCS_CAST)(IStorage *, REFCLSID);
HRESULT CW32System::WriteClassStg ( IStorage *pstg, REFCLSID rid )
{
	if (g_Ole32Proc.WriteClassStg == NULL)
		SetProcAddr( g_Ole32Proc.WriteClassStg, DLL_OLE32, "WriteClassStg" );
	return ((WCS_CAST)g_Ole32Proc.WriteClassStg)(pstg, rid);
}

typedef RE_OLE32API(SCS_CAST)(IStorage *, BOOL);
HRESULT CW32System::SetConvertStg ( IStorage *pstg, BOOL fConv )
{
	if (g_Ole32Proc.SetConvertStg == NULL)
		SetProcAddr( g_Ole32Proc.SetConvertStg, DLL_OLE32, "SetConvertStg" );
	return ((SCS_CAST)g_Ole32Proc.SetConvertStg)(pstg, fConv);
}

typedef RE_OLE32API(RFUTS_CAST)(IStorage *, CLIPFORMAT *, LPOLESTR *);
HRESULT CW32System::ReadFmtUserTypeStg ( IStorage *pstg, CLIPFORMAT *pcf, LPOLESTR *pstr )
{
	if (g_Ole32Proc.ReadFmtUserTypeStg == NULL)
		SetProcAddr( g_Ole32Proc.ReadFmtUserTypeStg, DLL_OLE32, "ReadFmtUserTypeStg" );
	return ((RFUTS_CAST)g_Ole32Proc.ReadFmtUserTypeStg)(pstg, pcf, pstr);
}

typedef RE_OLE32API(RCS_CAST)(IStorage *, CLSID *);
HRESULT CW32System::ReadClassStg ( IStorage *pstg, CLSID *pclsid )
{
	if (g_Ole32Proc.ReadClassStg == NULL)
		SetProcAddr( g_Ole32Proc.ReadClassStg, DLL_OLE32, "ReadClassStg" );
	return ((RCS_CAST)g_Ole32Proc.ReadClassStg)(pstg, pclsid);
}

typedef RE_OLE32API(OR_CAST)(IUnknown *);
HRESULT CW32System::OleRun ( IUnknown *punk )
{
	if (g_Ole32Proc.OleRun == NULL)
		SetProcAddr( g_Ole32Proc.OleRun, DLL_OLE32, "OleRun" );
	return ((OR_CAST)g_Ole32Proc.OleRun)(punk);
}

typedef RE_OLE32API(RevDD_CAST)(HWND);
HRESULT CW32System::RevokeDragDrop ( HWND hwnd )
{
	if (g_Ole32Proc.RevokeDragDrop == NULL)
		SetProcAddr( g_Ole32Proc.RevokeDragDrop, DLL_OLE32, "RevokeDragDrop" );
	return ((RevDD_CAST)g_Ole32Proc.RevokeDragDrop)(hwnd);
}

typedef RE_OLE32API(CSOH_CAST)(HGLOBAL, BOOL, IStream **);
HRESULT CW32System::CreateStreamOnHGlobal ( HGLOBAL hglobal, BOOL fDel, IStream **ppstrm )
{
	if (g_Ole32Proc.CreateStreamOnHGlobal == NULL)
		SetProcAddr( g_Ole32Proc.CreateStreamOnHGlobal, DLL_OLE32, "CreateStreamOnHGlobal" );
	return ((CSOH_CAST)g_Ole32Proc.CreateStreamOnHGlobal)(hglobal, fDel, ppstrm);
}

typedef RE_OLE32API(GHFS_CAST)(IStream *, HGLOBAL *);
HRESULT CW32System::GetHGlobalFromStream ( IStream *pstrm, HGLOBAL *phglobal )
{
	if (g_Ole32Proc.GetHGlobalFromStream == NULL)
		SetProcAddr( g_Ole32Proc.GetHGlobalFromStream, DLL_OLE32, "GetHGlobalFromStream" );
	return ((GHFS_CAST)g_Ole32Proc.GetHGlobalFromStream)(pstrm, phglobal);
}

typedef RE_OLE32API(OCDH_CAST)(REFCLSID, IUnknown *, REFIID, void **);
HRESULT CW32System::OleCreateDefaultHandler (
	REFCLSID clsid,
	IUnknown *punk,
	REFIID riid,
	void **ppv
)
{
	if (g_Ole32Proc.OleCreateDefaultHandler == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateDefaultHandler, DLL_OLE32, "OleCreateDefaultHandler" );
	return ((OCDH_CAST)g_Ole32Proc.OleCreateDefaultHandler)(clsid, punk, riid, ppv);
}

typedef RE_OLE32API(CFPI_CAST)(LPCOLESTR, LPCLSID);
HRESULT CW32System::CLSIDFromProgID ( LPCOLESTR pstr, LPCLSID pclsid )
{
	if (g_Ole32Proc.CLSIDFromProgID == NULL)
		SetProcAddr( g_Ole32Proc.CLSIDFromProgID, DLL_OLE32, "CLSIDFromProgID" );
	return ((CFPI_CAST)g_Ole32Proc.CLSIDFromProgID)(pstr, pclsid);
}

typedef RE_OLE32API(OCOTI_CAST)(LPOLESTREAM, IStorage *, 
								const DVTARGETDEVICE *);
HRESULT CW32System::OleConvertOLESTREAMToIStorage (
	LPOLESTREAM pstrm,
	IStorage *pstg,
	const DVTARGETDEVICE *ptd
)
{
	if (g_Ole32Proc.OleConvertOLESTREAMToIStorage == NULL)
		SetProcAddr( g_Ole32Proc.OleConvertOLESTREAMToIStorage, DLL_OLE32, "OleConvertOLESTREAMToIStorage" );
	return ((OCOTI_CAST)g_Ole32Proc.OleConvertOLESTREAMToIStorage)(pstrm, pstg, ptd);
}

typedef RE_OLE32API(OL_CAST)(IStorage *, REFIID, IOleClientSite *, void **);
HRESULT CW32System::OleLoad ( 
	IStorage *pstg,
	REFIID riid,
	IOleClientSite *psite,
	void **ppv
)
{
	if (g_Ole32Proc.OleLoad == NULL)
		SetProcAddr( g_Ole32Proc.OleLoad, DLL_OLE32, "OleLoad" );
	return ((OL_CAST)g_Ole32Proc.OleLoad)(pstg, riid, psite, ppv);
}

typedef RE_OLE32API(RSM_CAST)(LPSTGMEDIUM);
HRESULT CW32System::ReleaseStgMedium ( LPSTGMEDIUM pmedium )
{
	if (g_Ole32Proc.ReleaseStgMedium == NULL)
		SetProcAddr( g_Ole32Proc.ReleaseStgMedium, DLL_OLE32, "ReleaseStgMedium" );
	return ((RSM_CAST)g_Ole32Proc.ReleaseStgMedium)(pmedium);
}

typedef RE_OLE32API(CCI_CAST)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID);
HRESULT CW32System::CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
		DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
	if (g_Ole32Proc.CoCreateInstance == NULL)
		SetProcAddr( g_Ole32Proc.CoCreateInstance, DLL_OLE32, "CoCreateInstance" );
	return ((CCI_CAST)g_Ole32Proc.CoCreateInstance)(rclsid, pUnknown, dwClsContext, riid, ppv);
}

typedef RE_OLE32API(CFF_CAST)(REFCLSID, LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, LPVOID *);
HRESULT CW32System::OleCreateFromFile (
	REFCLSID		rclsid, 
	LPCOLESTR		lpszFileName,
	REFIID			riid, 
	DWORD			renderopt,
	LPFORMATETC		pFormatEtc, 
	LPOLECLIENTSITE pClientSite,
	LPSTORAGE		pStg, 
	LPVOID *		ppvObj)
{
	if (g_Ole32Proc.OleCreateFromFile == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateFromFile, DLL_OLE32, "OleCreateFromFile" );
	return ((CFF_CAST)g_Ole32Proc.OleCreateFromFile)(rclsid, lpszFileName, riid, renderopt,
								pFormatEtc, pClientSite, pStg, ppvObj);
}

BOOL CW32System::ImmInitialize( void )
{
	// MAC Only function.
	return FALSE;
}

void CW32System::ImmTerminate( void )
{
	// MAC only function.
	return;
}
#endif	// NOFEPROCESSING

#ifndef NOACCESSIBILITY

typedef HRESULT (WINAPI *ACC_VC_CAST)(VARIANTARG FAR*, VARIANTARG FAR*);
HRESULT CW32System::VariantCopy(VARIANTARG FAR*  pvargDest, VARIANTARG FAR*  pvargSrc)
{
    static void *pVariantCopy = NULL;
	if (pVariantCopy == NULL)
		SetProcAddr( pVariantCopy, DLL_OLEAUT32, "VariantCopy" );
	if (pVariantCopy)
		return ((ACC_VC_CAST)pVariantCopy)(pvargDest, pvargSrc);

    return (E_NOINTERFACE);
}

typedef LRESULT (WINAPI *ACC_LFO_CAST)(REFIID, WPARAM, LPUNKNOWN);
LRESULT CW32System::LResultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk)
{
	static void *pLResultFromObject = NULL;
	if (pLResultFromObject == NULL)
		SetProcAddr( pLResultFromObject, DLL_ACC, "LresultFromObject" );
	if (pLResultFromObject)
		return ((ACC_LFO_CAST)pLResultFromObject)(riid, wParam, punk);
	return E_NOINTERFACE;
}

typedef HRESULT (WINAPI *ACC_CSAPW)(HWND, LPCWSTR, LONG, REFIID, void**);
HRESULT CW32System::CreateStdAccessibleProxyW(HWND hwnd, LPCWSTR pClassName, LONG idObject, REFIID riid, void** ppvObject)
{
	static void *pCreateStdAccessibleProxyW = NULL;
	if (pCreateStdAccessibleProxyW == NULL)
		SetProcAddr( pCreateStdAccessibleProxyW, DLL_ACC, "CreateStdAccessibleProxyW");
	if (pCreateStdAccessibleProxyW)
		return ((ACC_CSAPW)pCreateStdAccessibleProxyW)(hwnd, pClassName, idObject, riid, ppvObject);
	return E_NOINTERFACE;
}

typedef HRESULT (WINAPI *ACC_AOFW_CAST)(HWND, DWORD, REFIID, void **);
HRESULT CW32System::AccessibleObjectFromWindow (HWND hWnd, DWORD dwID, REFIID riidInterface, void ** ppvObject)
{
    static void *pAccessibleObjectFromWindow = NULL;
	if (pAccessibleObjectFromWindow == NULL)
		SetProcAddr( pAccessibleObjectFromWindow, DLL_ACC, "AccessibleObjectFromWindow" );
	if (pAccessibleObjectFromWindow)
		return ((ACC_AOFW_CAST)pAccessibleObjectFromWindow)(hWnd, dwID, riidInterface, ppvObject);
    return (E_NOINTERFACE);
}

typedef BOOL (WINAPI *ACC_BI_CAST)(BOOL);
BOOL CW32System::BlockInput (BOOL fBlock)
{
    static void *pBlockInput = NULL;
	if (pBlockInput == NULL)
		SetProcAddr( pBlockInput, DLL_USER32, "BlockInput" );
	if (pBlockInput)
		return ((ACC_BI_CAST)pBlockInput)(fBlock);

    return FALSE;
}

typedef UINT (WINAPI *ACC_SI_CAST)(UINT, LPINPUT, int);
UINT CW32System::SendInput (UINT nInputs, LPINPUT pInputs, int cbSize)
{
    static void *pSendInput = NULL;
	if (pSendInput == NULL)
		SetProcAddr( pSendInput, DLL_USER32, "SendInput" );
	if (pSendInput)
		return ((ACC_SI_CAST)pSendInput)(nInputs, pInputs, cbSize);

    return 0;
}

typedef VOID (WINAPI *ACC_NWE_CAST)(DWORD, HWND, LONG, LONG);
VOID CW32System::NotifyWinEvent(DWORD dwEvent, HWND hWnd, LONG lObjectType, LONG lObjectId)
{
	static void *pNotfiyWinEvent = NULL;
	if (pNotfiyWinEvent == INVALID_HANDLE_VALUE)
		return;

	if (pNotfiyWinEvent == NULL)
		SetProcAddr( pNotfiyWinEvent, DLL_USER32, "NotifyWinEvent" );
	if (pNotfiyWinEvent)
		((ACC_NWE_CAST)pNotfiyWinEvent)(dwEvent, hWnd, lObjectType, lObjectId);
	else 
		pNotfiyWinEvent = INVALID_HANDLE_VALUE;

}

#endif

#ifndef NOFEPROCESSING
typedef LONG (WINAPI*IGCSA_CAST)(HIMC, DWORD, LPVOID, DWORD);
LONG CW32System::ImmGetCompositionStringA ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPVOID lpBuf, 
	DWORD dwBufLen,
	BOOL fAimmActivated)
{	
	if (fAimmActivated)
	{
		HRESULT hResult;
		LONG	lCopied = 0;
	
		hResult = pAIMM->GetCompositionStringA(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);
				
		return (SUCCEEDED(hResult) ? lCopied : 0);
	}

	if (g_IMM32Proc.ImmGetCompositionStringA == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetCompositionStringA, DLL_IMM32, "ImmGetCompositionStringA" );
	return ((IGCSA_CAST)g_IMM32Proc.ImmGetCompositionStringA)(hIMC, dwIndex, lpBuf, dwBufLen);
}

typedef LONG (WINAPI*IGCSW_CAST)(HIMC, DWORD, LPVOID, DWORD);
LONG CW32System::ImmGetCompositionStringW ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPVOID lpBuf, 
	DWORD dwBufLen,
	BOOL fAimmActivated)
{	
	if (fAimmActivated)
	{
		HRESULT hResult;
		LONG	lCopied = 0;
	
		hResult = pAIMM->GetCompositionStringW(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);
				
		return (SUCCEEDED(hResult) ? lCopied : 0);
	}

	if (g_IMM32Proc.ImmGetCompositionStringW == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetCompositionStringW, DLL_IMM32, "ImmGetCompositionStringW" );
	return ((IGCSW_CAST)g_IMM32Proc.ImmGetCompositionStringW)(hIMC, dwIndex, lpBuf, dwBufLen);
}

typedef HIMC (WINAPI*IGC_CAST)(HWND);
HIMC CW32System::ImmGetContext (
	HWND hWnd,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
		HIMC	hIMC = 0;
	
		hResult = pAIMM->GetContext(hWnd, &hIMC);
		return (SUCCEEDED(hResult) ? hIMC : 0);
	}

	if (g_IMM32Proc.ImmGetContext == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetContext, DLL_IMM32, "ImmGetContext" );
	return ((IGC_CAST)g_IMM32Proc.ImmGetContext)(hWnd);
}

typedef BOOL (WINAPI*ISCFA_CAST)(HIMC, LPLOGFONTA);
BOOL CW32System::ImmSetCompositionFontA (
	HIMC hIMC, 
	LPLOGFONTA lpLogFontA,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->SetCompositionFontA(hIMC, lpLogFontA);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetCompositionFontA == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCompositionFontA, DLL_IMM32, "ImmSetCompositionFontA" );
	return ((ISCFA_CAST)g_IMM32Proc.ImmSetCompositionFontA)(hIMC, lpLogFontA);
}

typedef BOOL (WINAPI*ISCW_CAST)(HIMC, LPCOMPOSITIONFORM);
BOOL CW32System::ImmSetCompositionWindow ( 
	HIMC hIMC, 
	LPCOMPOSITIONFORM lpCompForm,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->SetCompositionWindow(hIMC, lpCompForm);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetCompositionWindow == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCompositionWindow, DLL_IMM32, "ImmSetCompositionWindow" );
	return ((ISCW_CAST)g_IMM32Proc.ImmSetCompositionWindow)(hIMC, lpCompForm);
}

typedef BOOL (WINAPI*IRC_CAST)(HWND, HIMC);
BOOL CW32System::ImmReleaseContext (
	HWND hWnd, 
	HIMC hIMC,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->ReleaseContext(hWnd, hIMC);
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmReleaseContext == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmReleaseContext, DLL_IMM32, "ImmReleaseContext" );
	return ((IRC_CAST)g_IMM32Proc.ImmReleaseContext)(hWnd, hIMC);
}

typedef DWORD (WINAPI*IGP_CAST)(HKL, DWORD);
DWORD CW32System::ImmGetProperty ( 
	HKL hKL, 
	DWORD dwIndex,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
		DWORD	dwProperties=0;
	
		hResult = pAIMM->GetProperty(hKL, dwIndex, &dwProperties);
				
		return (SUCCEEDED(hResult) ? dwProperties : 0);
	}

	if (g_IMM32Proc.ImmGetProperty == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetProperty, DLL_IMM32, "ImmGetProperty" );
	return ((IGP_CAST)g_IMM32Proc.ImmGetProperty)(hKL, dwIndex);
}

typedef BOOL (WINAPI*IGCW_CAST)(HIMC, DWORD, LPCANDIDATEFORM);
BOOL CW32System::ImmGetCandidateWindow ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPCANDIDATEFORM lpCandidate,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->GetCandidateWindow(hIMC, dwIndex, lpCandidate);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmGetCandidateWindow == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetCandidateWindow, DLL_IMM32, "ImmGetCandidateWindow" );
	return ((IGCW_CAST)g_IMM32Proc.ImmGetCandidateWindow)(hIMC, dwIndex, lpCandidate);
}

typedef BOOL (WINAPI*ISCAW_CAST)(HIMC, LPCANDIDATEFORM);
BOOL CW32System::ImmSetCandidateWindow ( 
	HIMC hIMC, 
	LPCANDIDATEFORM lpCandidate ,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->SetCandidateWindow(hIMC, lpCandidate);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetCandidateWindow == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCandidateWindow, DLL_IMM32, "ImmSetCandidateWindow" );
	return ((ISCAW_CAST)g_IMM32Proc.ImmSetCandidateWindow)(hIMC, lpCandidate);
}

typedef BOOL (WINAPI*INIME_CAST)(HIMC, DWORD, DWORD, DWORD);
BOOL CW32System::ImmNotifyIME ( 
	HIMC hIMC, 
	DWORD dwAction, 
	DWORD dwIndex, 
	DWORD dwValue,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->NotifyIME(hIMC, dwAction, dwIndex, dwValue);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmNotifyIME == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmNotifyIME, DLL_IMM32, "ImmNotifyIME" );
	return ((INIME_CAST)g_IMM32Proc.ImmNotifyIME)(hIMC, dwAction, dwIndex, dwValue);
}

typedef HIMC (WINAPI*IAC_CAST)(HWND, HIMC);
HIMC CW32System::ImmAssociateContext ( 
	HWND hWnd, 
	HIMC hIMC,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
		HIMC	hPreviousIMC=0;

		hResult = pAIMM->AssociateContext(hWnd, hIMC, &hPreviousIMC);
				
		return (SUCCEEDED(hResult) ? hPreviousIMC : 0);
	}

	if (g_IMM32Proc.ImmAssociateContext == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmAssociateContext, DLL_IMM32, "ImmAssociateContext" );
	return ((IAC_CAST)g_IMM32Proc.ImmAssociateContext)(hWnd, hIMC);
}

typedef UINT (WINAPI*IGVK_CAST)(HWND);
UINT CW32System::ImmGetVirtualKey ( 
	HWND hWnd,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
		UINT	uVirtualKey=0;

		hResult = pAIMM->GetVirtualKey(hWnd, &uVirtualKey);
				
		return (SUCCEEDED(hResult) ? uVirtualKey : 0);
	}

	if (g_IMM32Proc.ImmGetVirtualKey == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetVirtualKey, DLL_IMM32, "ImmGetVirtualKey" );
	return ((IGVK_CAST)g_IMM32Proc.ImmGetVirtualKey)(hWnd);
}

// NOTE: We only use ImmEscape for IME_ESC_HANJA_MODE.
// Need to fix up if other methods are used.
typedef HIMC (WINAPI*IES_CAST)(HKL, HIMC, UINT, LPVOID );
HIMC CW32System::ImmEscape ( 
	HKL hKL, 
	HIMC hIMC, 
	UINT uEscape, 
	LPVOID lpData,
	BOOL fAimmActivated)
{
	if (fAimmActivated && !_fLoadAIMM10)	// Aimm1.2
	{
		HRESULT hResult;
		LRESULT lResult=0;
		WCHAR	szHangul[2];

		szHangul[0] = *((WCHAR *)lpData);
		szHangul[1] = 0;
		hResult = pAIMM->EscapeW(hKL, hIMC, uEscape, (LPVOID)szHangul, &lResult);

		return (SUCCEEDED(hResult) ? (HRESULT)lResult : 0);
	}

	// Aimm1.0 only support A version..
	if (!OnWin9x() && !fAimmActivated)
		goto USE_W_VERSION;

	char	szaHangul[3];

	szaHangul[0] = szaHangul[1] = szaHangul[2] = 0;
	if (MbcsFromUnicode(szaHangul, sizeof(szaHangul),
		(LPCWSTR)lpData, 1, CP_KOREAN, UN_NOOBJECTS) <= 0)
		return FALSE;

	if (fAimmActivated)
	{
		HRESULT hResult;
		LRESULT lResult=0;

		hResult = pAIMM->EscapeA(hKL, hIMC, uEscape, (LPVOID)szaHangul, &lResult);
				
		return (SUCCEEDED(hResult) ? (HRESULT)lResult : 0);
	}

	if (g_IMM32Proc.ImmEscapeA == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmEscapeA, DLL_IMM32, "ImmEscapeA" );
	return ((IES_CAST)g_IMM32Proc.ImmEscapeA)(hKL, hIMC, uEscape, (LPVOID)szaHangul);

USE_W_VERSION:
	if (g_IMM32Proc.ImmEscapeW == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmEscapeW, DLL_IMM32, "ImmEscapeW" );
	return ((IES_CAST)g_IMM32Proc.ImmEscapeW)(hKL, hIMC, uEscape, lpData);
}

typedef BOOL (WINAPI*IGOS_CAST)(HIMC);
BOOL CW32System::ImmGetOpenStatus ( 
	HIMC hIMC,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
		
		// AIMM is returning S_OK for OpenStatus == TRUE.
		hResult = pAIMM->GetOpenStatus(hIMC);
				
		return (hResult == S_OK);
	}

	if (g_IMM32Proc.ImmGetOpenStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetOpenStatus, DLL_IMM32, "ImmGetOpenStatus" );
	return ((IGOS_CAST)g_IMM32Proc.ImmGetOpenStatus)(hIMC);
}

typedef BOOL (WINAPI*ISOS_CAST)(HIMC, BOOL);
BOOL CW32System::ImmSetOpenStatus ( 
	HIMC hIMC, 
	BOOL fOpen,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->SetOpenStatus(hIMC, fOpen);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetOpenStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetOpenStatus, DLL_IMM32, "ImmSetOpenStatus" );
	return ((ISOS_CAST)g_IMM32Proc.ImmSetOpenStatus)(hIMC, fOpen);
}

typedef BOOL (WINAPI*IGCS_CAST)(HIMC , LPDWORD , LPDWORD );
BOOL CW32System::ImmGetConversionStatus ( 
	HIMC hIMC, 
	LPDWORD pdwConversion, 
	LPDWORD pdwSentence,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->GetConversionStatus(hIMC, pdwConversion, pdwSentence);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmGetConversionStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetConversionStatus, DLL_IMM32, "ImmGetConversionStatus" );
	return ((IGCS_CAST)g_IMM32Proc.ImmGetConversionStatus)(hIMC, pdwConversion, pdwSentence);
}

typedef BOOL (WINAPI*ISCS_CAST)(HIMC , DWORD , DWORD );
BOOL CW32System::ImmSetConversionStatus ( 
	HIMC hIMC, 
	DWORD dwConversion, 
	DWORD dwSentence,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->SetConversionStatus(hIMC, dwConversion, dwSentence);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetConversionStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetConversionStatus, DLL_IMM32, "ImmSetConversionStatus" );
	return ((ISCS_CAST)g_IMM32Proc.ImmSetConversionStatus)(hIMC, dwConversion, dwSentence);
}

typedef HWND (WINAPI*IGDW_CAST)( HWND );
HWND CW32System::ImmGetDefaultIMEWnd (  
	HWND hWnd,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;
		HWND	hIMEWnd;

		hResult = pAIMM->GetDefaultIMEWnd(hWnd, &hIMEWnd);
				
		return SUCCEEDED(hResult) ? hIMEWnd : NULL;
	}

	if (g_IMM32Proc.ImmGetDefaultIMEWnd == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetDefaultIMEWnd, DLL_IMM32, "ImmGetDefaultIMEWnd" );
	return ((IGDW_CAST)g_IMM32Proc.ImmGetDefaultIMEWnd)(hWnd);
}

typedef BOOL (WINAPI*ISCSW_CAST)(HIMC, DWORD, LPVOID, DWORD, LPVOID, DWORD);
BOOL CW32System::ImmSetCompositionStringW ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPVOID lpBuf, 
	DWORD dwBufLen,
	LPVOID lpRead,
	DWORD dwReadLen,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->SetCompositionStringW(hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwReadLen);

		return SUCCEEDED(hResult) ? TRUE : FALSE;
	}

	if (g_IMM32Proc.ImmSetCompositionStringW == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCompositionStringW, DLL_IMM32, "ImmSetCompositionStringW" );
	return ((ISCSW_CAST)g_IMM32Proc.ImmSetCompositionStringW)(hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwReadLen);
}

typedef BOOL (WINAPI*III_CAST)(HKL);
BOOL CW32System::ImmIsIME (
	HKL hKL,
	BOOL fAimmActivated)
{
	if (fAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->IsIME(hKL);

		return SUCCEEDED(hResult) ? TRUE : FALSE;
	}

	if (g_IMM32Proc.ImmIsIME == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmIsIME, DLL_IMM32, "ImmIsIME" );
	return ((III_CAST)g_IMM32Proc.ImmIsIME)(hKL);
}

typedef IMESHAREAPI BOOL (*FSS_CAST)(UINT, UINT);
BOOL CW32System::FSupportSty ( UINT uSty, UINT uStyAltered)
{
	if (g_IMEShareProc.FSupportSty == NULL)
		SetIMEProcAddr( g_IMEShareProc.FSupportSty, DLL_IMESHARE, "FSupportSty" );
	return ((FSS_CAST)g_IMEShareProc.FSupportSty)(uSty, uStyAltered);
}

typedef IMESHAREAPI const IMESTYLE * (IMECDECL*PISFA_CAST)(const UINT);
const IMESTYLE * CW32System::PIMEStyleFromAttr ( const UINT uAttr)
{
	if (g_IMEShareProc.PIMEStyleFromAttr == NULL)
		SetIMEProcAddr( g_IMEShareProc.PIMEStyleFromAttr, DLL_IMESHARE, "PIMEStyleFromAttr" );
	return ((PISFA_CAST)g_IMEShareProc.PIMEStyleFromAttr)( uAttr );
}

typedef IMESHAREAPI const IMECOLORSTY * (IMECDECL*PCSTFIS_CAST)(const IMESTYLE *);
const IMECOLORSTY * CW32System::PColorStyleTextFromIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.PColorStyleTextFromIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.PColorStyleTextFromIMEStyle, DLL_IMESHARE, "PColorStyleTextFromIMEStyle" );
	return ((PCSTFIS_CAST)g_IMEShareProc.PColorStyleTextFromIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI const IMECOLORSTY * (IMECDECL*PCSBFIS_CAST)(const IMESTYLE *);
const IMECOLORSTY * CW32System::PColorStyleBackFromIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.PColorStyleBackFromIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.PColorStyleBackFromIMEStyle, DLL_IMESHARE, "PColorStyleBackFromIMEStyle" );
	return ((PCSBFIS_CAST)g_IMEShareProc.PColorStyleBackFromIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI BOOL (IMECDECL*FBIS_CAST)(const IMESTYLE *);
BOOL CW32System::FBoldIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.FBoldIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.FBoldIMEStyle, DLL_IMESHARE, "FBoldIMEStyle" );
	return ((FBIS_CAST)g_IMEShareProc.FBoldIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI BOOL (IMECDECL*FIIS_CAST)(const IMESTYLE * );
BOOL CW32System::FItalicIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.FItalicIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.FItalicIMEStyle, DLL_IMESHARE, "FItalicIMEStyle" );
	return ((FIIS_CAST)g_IMEShareProc.FItalicIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI BOOL (IMECDECL*FUIS_CAST)(const IMESTYLE *);
BOOL CW32System::FUlIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.FUlIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.FUlIMEStyle, DLL_IMESHARE, "FUlIMEStyle" );
	return ((FUIS_CAST)g_IMEShareProc.FUlIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI UINT (IMECDECL*IUIS_CAST)(const IMESTYLE *);
UINT CW32System::IdUlIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.IdUlIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.IdUlIMEStyle, DLL_IMESHARE, "IdUlIMEStyle" );
	return ((IUIS_CAST)g_IMEShareProc.IdUlIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI COLORREF (IMECDECL*RFICS_CAST)(const IMECOLORSTY *);
COLORREF CW32System::RGBFromIMEColorStyle ( const IMECOLORSTY * pColorStyle )
{
	if (g_IMEShareProc.RGBFromIMEColorStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.RGBFromIMEColorStyle, DLL_IMESHARE, "RGBFromIMEColorStyle" );
	return ((RFICS_CAST)g_IMEShareProc.RGBFromIMEColorStyle)( pColorStyle );
}
#endif	// NOFEPROCESSING

CONVERTMODE WINAPI CW32System::DetermineConvertMode( HDC hdc, BYTE tmCharSet )
{
	CONVERTMODE cm = CVT_NONE;

	// Some fonts have problems under Win95 with the GetCharWidthW call; this
	// is a simple heuristic to determine if this problem exists.
	if (OnWin9x())
	{
		INT		widthA, widthW;
		BOOL	fResA, fResW;

		// FE font on Non-FE Win95 cannot use
		// GetCharWidthW and ExtTextOutW
		if(IsFECharSet(tmCharSet) && OnWin95FE())
			// always use ANSI call for DBC fonts.
			cm = CVT_WCTMB;
		else
		{
			fResA = GetCharWidthA( hdc, ' ', ' ', &widthA );
			fResW = GetCharWidthW( hdc, L' ', L' ', &widthW );
			if ( fResA && fResW && widthA != widthW )
				cm = CVT_WCTMB;
			else
			{
				fResA = GetCharWidthA( hdc, 'a', 'a', &widthA );
				fResW = GetCharWidthW( hdc, L'a', L'a', &widthW );
				if ( fResA && fResW && widthA != widthW )
					cm = CVT_WCTMB;
			}
		}
	}
	return cm;
}

void WINAPI CW32System::CalcUnderlineInfo(HDC hdc, CCcs *pcccs, TEXTMETRIC *ptm )
{
	if (ptm->tmPitchAndFamily & TMPF_TRUETYPE)
	{
		OUTLINETEXTMETRICA otm;

		if (GetOutlineTextMetricsA(hdc, sizeof(otm), &otm))
		{
			pcccs->_dyULOffset = -otm.otmsUnderscorePosition;
			pcccs->_dyULWidth = otm.otmsUnderscoreSize;
			pcccs->_dySOOffset = -otm.otmsStrikeoutPosition;
			pcccs->_dySOWidth = otm.otmsStrikeoutSize;
			//Handle fonts like Mangal and Latha which very small underline width, but do
			//have a reasonable strikeout width.
			if (pcccs->_dyULWidth < pcccs->_dySOWidth || pcccs->_dyULWidth <= 0)
				pcccs->_dyULWidth = pcccs->_dySOWidth = max(pcccs->_dySOWidth, max(pcccs->_dyULWidth, 1));
			return;
		}
	}

	// Default calculation of size of underline
	SHORT dyDescent = pcccs->_yDescent;

	if (0 == dyDescent)
		dyDescent = pcccs->_yHeight >> 3;

	pcccs->_dyULWidth = (short) max(1, dyDescent / 4);
	pcccs->_dyULOffset = (dyDescent - 3 * pcccs->_dyULWidth + 1) / 2;

	if ((0 == pcccs->_dyULOffset) && (dyDescent > 1))
		pcccs->_dyULOffset = 1;

	pcccs->_dySOOffset = -ptm->tmAscent / 3;
	pcccs->_dySOWidth = pcccs->_dyULWidth;

	return;
}

BOOL WINAPI CW32System::ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG )
{
	return ::ShowScrollBar( hWnd, wBar, bShow );
}

BOOL WINAPI CW32System::EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows )
{
	return ::EnableScrollBar( hWnd, wSBflags, wArrows );
}

void AdvanceXpYp(int &xp, int &yp, UINT cch, const INT **ppdx, TFLOW tflow)
{
	LONG upAdjust = 0;
	while (cch--)
		upAdjust += *(*ppdx)++;

	switch(tflow)
	{
	case tflowES:
		xp += upAdjust;
		break;
	case tflowSW:
		yp += upAdjust;
		break;
	case tflowWN:
		xp -= upAdjust;
		break;
	case tflowNE:
		yp -= upAdjust;
		break;
	}
}

/*
 * 	ReExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx, uiCodePage, dwETOFlags)
 *
 *	@mfunc
 *		Patch around the Win95 FE bug and MetaFile problem.		
 *
 *	@rdesc
 *		Returns whatever ExtTextOut returns
 */
BOOL ReExtTextOutW(
    HDC			hdc,			//@parm handle to device context 
    int			xp,				//@parm x-coordinate of reference point 
    int			yp,				//@parm y-coordinate of reference point 
    UINT		fuOptions,		//@parm text-output options 
    CONST RECT *lprect,			//@parm optional clipping and/or opaquing rectangle 
    const WCHAR *lpwchString,	//@parm points to string 
    UINT		cchCount,		//@parm number of characters in string 
    CONST INT *	lpDx,			//@parm Ptr to array of intercharacter spacing values
	UINT		uiCodePage,		//@parm CodePage for converting to Ansi
	DWORD		dwETOFlags)		//@parm ExtTextOut flags
{
	// This is a portion of Word code adapted for our needs. 
	// This is a work around for Win95FE bugs that cause GPFs in GDI if multiple
	// characters above Unicode 0x7F are passed to ExtTextOutW.

	// Also, when uiCodePage is non-zero, we want to output all characters using
	// ExtTextOutA - each character at a time.

	Assert(lpDx);
	int		cch = cchCount;
	const	WCHAR *lpwchT = lpwchString;
	const	WCHAR *lpwchStart = lpwchT;

	CONST int *lpdxpCur;
	BOOL	fRet = 0;

	if (lpDx)
	{
		const	WCHAR *lpwchEnd = lpwchString + cchCount;
		while (lpwchT < lpwchEnd)
		{
			// Characters less than 0x007F do not need special treatment
			// we output then in contiguous runs
			if (*lpwchT > 0x007F || uiCodePage)
			{
				if ((cch = lpwchT - lpwchStart) > 0)
				{
					lpdxpCur = lpDx + (lpwchStart - lpwchString);

					// Output the run of chars less than 0x7F
					fRet = ExtTextOutW(hdc, xp, yp, fuOptions, lprect, lpwchStart, cch, lpdxpCur);
					if (!fRet)
						return fRet;

					fuOptions &= ~ETO_OPAQUE; // Don't erase multiple times!!!

					// Advance cch
					AdvanceXpYp(xp, yp, cch, &lpdxpCur, dwETOFlags & 3);

					lpwchStart = lpwchT;
				}

				// Output chars above 0x7F one at a time to prevent Win95 FE GPF
				lpdxpCur = lpDx + (lpwchStart - lpwchString);
				if (uiCodePage)
				{

					// Need to convert to Ansi and use ExtTextOutA
					char	chAnsi[2];

					int	cbConv = WideCharToMultiByte(uiCodePage, 0, lpwchStart, 1,
						chAnsi, 2, NULL, NULL);

					if (cbConv <= 0)
					{
						chAnsi[0] = '?';
						cbConv = 1;
					}

					fRet = ExtTextOutA(hdc, xp, yp, fuOptions, lprect, chAnsi, cbConv, lpdxpCur);
				}
				else
					fRet = ExtTextOutW(hdc, xp, yp, fuOptions, lprect, lpwchStart, 1, lpdxpCur);

				if (!fRet)
					return fRet;

				fuOptions &= ~ETO_OPAQUE; // Don't erase multiple times!!!

				// Advance 1 character
				AdvanceXpYp(xp, yp, 1, &lpdxpCur, dwETOFlags & 3);

				lpwchStart++;
			}

			lpwchT++;
		}
		cch = lpwchT - lpwchStart;		// Setup to output the final run;
	}

	// If we were called with cchCount == 0, make a call here to erase the rectangle
	if (cch > 0 || !cchCount)
		fRet = ExtTextOutW(hdc, xp, yp, fuOptions, lprect, lpwchStart, cch, lpDx ? lpDx + (lpwchStart - lpwchString) : NULL);
	
	return fRet;	
}

extern ICustomTextOut *g_pcto;

void WINAPI CW32System::REExtTextOut(
	CONVERTMODE cm,
	UINT		uiCodePage,
	HDC			hdc,
	int			x,
	int			y,
	UINT		fuOptions,
	CONST RECT *lprc,
	const WCHAR *lpString,
	UINT		cch,
	CONST INT *	lpDx,
	DWORD		dwETOFlags)
{
	bool	fConvert = false;
	BOOL	fForceGdiFont = FALSE;
	HFONT	hfont = NULL, hfontCur = NULL;

	if (dwETOFlags & fETOCustomTextOut)
	{
		// If custom ExtTextOutW fails, then call OS to handle it
		if (g_pcto->ExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx))
			return;
	}

	// In order to get the EURO character to print, we need to force the
	// printer to use the glyphs inside GDI
	if(lpString[0] == EURO && 
	   (GetDeviceCaps(hdc, TECHNOLOGY) != DT_RASDISPLAY || W32->IsEnhancedMetafileDC(hdc)))
	{
		fForceGdiFont = TRUE;
		hfontCur = SelectFont(hdc, GetStockObject(ANSI_VAR_FONT));
		LOGFONT lf;
		GetObject(hfontCur, sizeof(LOGFONT), &lf);
		lf.lfOutPrecision = OnWin9x() ? OUT_TT_ONLY_PRECIS : OUT_SCREEN_OUTLINE_PRECIS;
		hfont = CreateFontIndirect(&lf);
		SelectObject(hdc, hfont);
	}

	if(OnWin9x())
	{
		// To get around some Win95 printer device problems with ExtTextOutW,
		// use ExtTextOutA if string is ASCII or if it's 1252 and any
		// nonASCII chars are between 0xA0 and 0xFF.
		for(UINT i = 0;
			i < cch &&
			(lpString[i] <= 0x7F ||
			 IN_RANGE(0xA0, lpString[i], 0xFF) && uiCodePage == 1252);
			i++)
				;
		if(i == cch) 				// All ASCII or ANSI: setup to truncate
		{							//  to low byte and use ExtTextOutA
			cm = CVT_LOWBYTE;
			fConvert = true;
		}
	}

	if (fConvert || (!(dwETOFlags & fETOFEFontOnNonFEWin9x)) && cm != CVT_NONE)		
	{
		if (cm == CVT_WCTMB)
		{
			if (IsFECodePage(uiCodePage))
			{
				if (OnWinNTNonFE() || (OnWin9x() && !OnWin95()))
				{
					// On NonFE NT4 and Win98, we need to textout each char using
					// ExtTextOutA
					ReExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx, uiCodePage, dwETOFlags);
					goto LExit;
				}
			}			
		}

		// Need to convert and use ExtTextOutA
		CTempCharBuf tcb;
		CTempBuf	 tDx;
		
		// Double the buffer size 
		int cbString = (cm == CVT_LOWBYTE) ? cch : cch * 2;
			
		// String buffer for converted string - allocate on the stack 
		char *psz = tcb.GetBuf(cbString);
		INT	 *pTempDx = NULL;
		
		if (NULL == psz)
		{
			// Could not allocate buffer
			goto LExit;
		}
			
		int cbConv = 0;
			
		if(cm == CVT_WCTMB)
		{
			cbConv = WideCharToMultiByte(uiCodePage, 0, lpString, cch, 
				psz, cbString, NULL, NULL);
				
			if(!cbConv)
			{
				// The conversion failed for one reason or another.  We should
				// make every effort to use WCTMB before we fall back to
				// taking the low-byte of every wchar (below), otherwise we
				// risk dropping the high-bytes and displaying garbage.
					
				// Use the cpg from the font, since the uiCodePage passed is
				//	the requested codepage and the font-mapper may very well
				//	have mapped to a different one.
				TEXTMETRIC tm;
				if(GetTextMetrics(hdc, &tm) && tm.tmCharSet != DEFAULT_CHARSET)
				{
					UINT cpg = CodePageFromCharRep(CharRepFromCharSet(tm.tmCharSet));
					uiCodePage = (uiCodePage != cpg) ? cpg : 1252;
				}
				else
					uiCodePage = 1252;

				cbConv = WideCharToMultiByte(uiCodePage, 0, lpString, cch, 
					psz, cbString, NULL, NULL);
			}

			if (cbConv > 0 && lpDx)
			{
				pTempDx = (INT *)tDx.GetBuf(cbConv * sizeof(INT));
				
				if (pTempDx)
				{
					// Repack lpDx to handle DBC
					INT		*pDx = pTempDx;
					CONST INT*pInputDx = lpDx;
					char	*pTempChar = psz;
					INT		cNumBytes = cbConv;

					while (cNumBytes > 0)
					{
						cNumBytes--;

						if (GetTrailBytesCount(*pTempChar++, uiCodePage))
						{
							*pDx++ = *pInputDx++;						
							*pDx++ = 0;
							cNumBytes--;
							pTempChar++;
						}
						else
							*pDx++ = *pInputDx++;
					}
				}
			}
		}
		else
		{
			Assert(cm == CVT_LOWBYTE);
			// drop through and convert using only low-bytes of WCHAR's
		}
			
			// WCTMB failed OR cm == CVT_LOWBYTE
		if(!cbConv)							// Convert WCHARs to CHARs
		{									
			// FUTURE:  We come here for both SYMBOL_CHARSET fonts and for
			// DBCS bytes stuffed into wchar's (one byte per wchar) when
			// the requested code page is not installed on the machine and
			// the MBTWC fails. Instead, we could have another conversion
			// mode that collects each DBCS char as a single wchar and then
			// remaps to a DBCS string for ExtTextOutA. This would allow us
			// to display text if the system has the right font even tho it
			// doesn't have the right cpg.
				
			// If we are converting this WCHAR buffer in this manner
			// (by taking only the low-byte's of the WCHAR's), it is 
			// because:
			// 	1) cm == CVT_LOWBYTE
			//	2) WCTMB above failed for some reason or another.  It may
			// 		be the case that the string is entirely ASCII in which
			//		case dropping the high-bytes is not a big deal (otherwise
			//		we assert).
		
			cbConv = cch;
				
			while(cch--)
			{
#ifdef DEBUG
				if (uiCodePage != CP_SYMBOL && lpString[cch] > 0xFF)
					Tracef(TRCSEVWARN, "Non-zero high-byte WCHAR: %x", lpString[cch]);
#endif
				psz[cch] = lpString[cch];
			}
		}		
		::ExtTextOutA(hdc, x, y, fuOptions, lprc, psz, cbConv, pTempDx ? pTempDx : lpDx);
		goto LExit;
	}

	if (OnWin9xFE() || (dwETOFlags & fETOFEFontOnNonFEWin9x))
		ReExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx, 0, dwETOFlags);
	else
		::ExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx);	

LExit:
	if (fForceGdiFont)
	{
		SelectObject(hdc, hfontCur);
		SideAssert(DeleteObject(hfont));
	}
}

void WINAPI CW32System::REGetCharWidth(
	HDC		hdc,
	WCHAR	ch,
	INT		*pdxp,
	UINT	cpg,	
	BOOL	fCustomTextOut)
{
	BOOL	fForceGdiFont = FALSE;
	HFONT	hfont = NULL, hfontCur = NULL;
	*pdxp = 0;

	if (fCustomTextOut && g_pcto->GetCharWidthW(hdc, ch, ch, pdxp))
		return;

	if ((cpg == CP_SYMBOL || ch <= 127) && ::GetCharWidthA(hdc, ch, ch, pdxp))
		goto Done;

	if(ch == EURO && (GetDeviceCaps(hdc, TECHNOLOGY) != DT_RASDISPLAY || W32->IsEnhancedMetafileDC(hdc)))
	{
		fForceGdiFont = TRUE;
		hfontCur = SelectFont(hdc, GetStockObject(ANSI_VAR_FONT));
		LOGFONT lf;
		GetObject(hfontCur, sizeof(LOGFONT), &lf);
		lf.lfOutPrecision = OnWin9x() ? OUT_TT_ONLY_PRECIS : OUT_SCREEN_OUTLINE_PRECIS;
		hfont = CreateFontIndirect(&lf);
		SelectObject(hdc, hfont);
	}

	// For most workarounds, we will use the workarounds on all the OSs.
	// We only use specific workaround is MBTWC conversion is needed.

	// This is a workaround for Win95 FE bugs
	// FUTURE (keithcu) This logic could be simplified.
	if (OnWin95() && !IN_RANGE(0x80, ch, 0xFF) &&			// Not high ANSI?
		(cpg == CP_CHINESE_TRAD || cpg == CP_CHINESE_SIM))	// Chinese CodePage?
	{
		int numOfDBCS = 0;
		::GetCharWidthW(hdc, 0x4e00, 0x4e00, pdxp);
		if (IN_RANGE(0x3400, ch, 0x9FFF))
			goto Done;
			
		// Use WCTMB heuristic
		char	ansiChar[2];
		BOOL	bDefCharUsed = FALSE;
		numOfDBCS = ::WideCharToMultiByte(cpg, 0, &ch, 1, ansiChar, 2, NULL, &bDefCharUsed);

		WORD wDBCS = (BYTE)ansiChar[0];
		
		if (2 == numOfDBCS)
			wDBCS = (BYTE)ansiChar[0] << 8 | (BYTE)ansiChar[1];
		
		if (numOfDBCS > 0 && ::GetCharWidthA( hdc, wDBCS, wDBCS, pdxp))
			goto Done;
	}

	//Win '95 GPFs if you pass in 0xFFFF
	if (ch == 0xFFFF)
		ch = 0xFFFE;

	::GetCharWidthW(hdc, ch, ch, pdxp);

	if(fForceGdiFont)
	{
		SelectObject(hdc, hfontCur);
		SideAssert(DeleteObject(hfont));
	}

Done:
	return;
}

//For now, we only fetch the ANSI_CHARSET kerning pairs and convert them to unicode
DWORD WINAPI CW32System::GetKerningPairs(HDC hdc, DWORD ckp, KERNINGPAIR *pkp)
{
	ckp = GetKerningPairsA(hdc, ckp, pkp);

	if (pkp) //Can be called with pkp == NULL to find out number of pairs
	{
		for (DWORD ikp = 0; ikp < ckp; ikp++)
		{
			if (pkp[ikp].wFirst > 127 || pkp[ikp].wSecond > 127)
			{
				CHAR rgch[2];
				rgch[0] = pkp[ikp].wFirst;
				rgch[1] = pkp[ikp].wSecond;

				MBTWC(1252, 0, rgch, 2, &pkp[ikp].wFirst, 2, NULL);
			}
		}
	}
	return ckp;
}

BOOL WINAPI CW32System::IsEnhancedMetafileDC( HDC hDC )
{
	BOOL	fEMFDC = FALSE;
	DWORD	dwObjectType;
	
	dwObjectType = ::GetObjectType( hDC );

	if ( OBJ_ENHMETADC == dwObjectType || OBJ_ENHMETAFILE == dwObjectType )
		fEMFDC = TRUE;
	else if ( OnWin95() && OBJ_DC == dwObjectType )
	{
		// HACK Alert,  Enhanced Metafile DC does not support any Escape function
		// and should return 0.
		int	iEscapeFuction = QUERYESCSUPPORT;

		if ( Escape( hDC, QUERYESCSUPPORT, sizeof(int), (LPCSTR)&iEscapeFuction, NULL) == 0 )
			fEMFDC = TRUE;
	}	

	return fEMFDC;
}


HPALETTE WINAPI CW32System::ManagePalette(
	HDC hdc,
	CONST LOGPALETTE *plogpal,
	HPALETTE &hpalOld,
	HPALETTE &hpalNew
)
{
	if (hpalNew == NULL)
	{
		hpalNew = ::CreatePalette(plogpal);
		if (hpalNew != NULL)
		{
			hpalOld = ::SelectPalette(hdc, hpalNew, TRUE);
			::RealizePalette(hdc);
		}
	}
	else
	{
		// A new palette was created previously and we are restoring the old one
		::SelectPalette(hdc, hpalOld, TRUE);
		::RealizePalette(hdc);
		DeleteObject(hpalNew);
		hpalNew = NULL;
	}
	return hpalNew;
}

BOOL WINAPI CW32System::WinLPtoDP(HDC hdc, LPPOINT lppoints, int nCount)
{
    return ::LPtoDP(hdc, lppoints, nCount);
}

BOOL WINAPI CW32System::WinDPtoLP(HDC hdc, LPPOINT lppoints, int nCount)
{
    return ::DPtoLP(hdc, lppoints, nCount);
}

long WINAPI CW32System::WvsprintfA( LONG cbBuf, LPSTR szBuf, LPCSTR szFmt, va_list arglist )
{
	LONG cb;
	cb = ::wvsprintfA( szBuf, szFmt, arglist );
	Assert(cb < cbBuf);
	return cb;
}

int WINAPI CW32System::MulDivFunc(int nNumber, int nNumerator, int nDenominator)
{
	if ((nNumerator && nNumerator == nDenominator) || (nDenominator && !nNumber))
		return nNumber;
	return ::MulDiv(nNumber, nNumerator, nDenominator);
}

/*
 *	GetFacePriorityCharSet(WCHAR* szFaceName)
 *
 *	@func
 *		return charset *really* supported by given facename
 */
int CALLBACK GetFacePriCharSetProc (
	ENUMLOGFONTEX	*lpelfe,
	NEWTEXTMETRIC	*lpntm,
	int				iFontType,
	LPARAM			lParam)
{
	Assert (lParam);
	*(BYTE*)lParam = lpntm->tmCharSet;
	return 0;
}

void CW32System::GetFacePriCharSet(HDC hdc, LOGFONT* plf)
{
	::EnumFontFamiliesEx(hdc, plf, (FONTENUMPROC)GetFacePriCharSetProc, (LPARAM)&plf->lfCharSet, 0);
}


/*
 *	CW32System::ReadRegDigitSubstitionMode(void)
 *
 *	@mfunc
 *		Get the digit substitution mode (available on BiDi/Thai platforms)
 *
 *	@rdesc
 *		0 - Context (digit shape follows preceding run or CHARFORMAT's charset
 *		1 - None (digits always show as European digit shape)
 *		2 - National (digits always show as user locale's native shape)
 */
BYTE CW32System::ReadRegDigitSubstitutionMode()
{
	BYTE	bDigitMode = 1;
#ifndef NOCOMPLEXSCRIPTS
	HKEY	hk;
	DWORD	keyDataType;
	DWORD	dwDataSize;
	BYTE	rgbValue[2];

	bDigitMode = DIGITS_NOTIMPL;			// assume "Not Implemented"

	// Perform platform check before reading registry
	if (!OnWin9xFE() && !OnWinNTFE() && 
		 IsComplexScriptLcid(GetThreadLocale()))
	{
		if(RegOpenKeyExA(HKEY_CURRENT_USER,
						"Control Panel\\International",
						0,		// reserved
						KEY_QUERY_VALUE,
						&hk) == ERROR_SUCCESS)
		{
			dwDataSize = 2;
			if (RegQueryValueExA(hk,
								"NumShape",
								NULL,		// reserved
								&keyDataType,
								(LPBYTE) &rgbValue,
								&dwDataSize) == ERROR_SUCCESS)
			{
				if (rgbValue[0] > 0x2f)
					bDigitMode = rgbValue[0] - 0x30 + 1;
				if (bDigitMode > DIGITS_NATIONAL)
					bDigitMode = DIGITS_NONE;
			}
			RegCloseKey(hk);
		}
	}
#endif
	return bDigitMode;
}

#ifdef DEBUG
/*
 *	TestGetCharFlags125x(iFirst, iLast)
 *
 *	@func
 *		Unit test function for GetCharFlags125x(). Assert if GetCharFlags125x()
 *		claims that any char in	Unicode range iFirst thru iLast 1) should
 *		roundtrip multibyte conversion using a codepage in the range 1250-1258
 *		when it	doesn't, or 2) shouldn't roundtrip when it does.
 */
BOOL TestGetCharFlags125x(
	int iFirst, 
	int iLast) 
{
	LONG	cch  = iLast - iFirst + 1;
	LONG	i;
	Assert(cch <= 0x700 - 0xA0);

	char 	rgach[0x700 - 0xA0];
	WCHAR	rgch [0x700 - 0xA0];
	WCHAR *	pch;

	for(i = iFirst, pch = rgch; i <= iLast;  pch++, i++)
		*pch = (WCHAR)i;

	for(int CodePage = 1250; CodePage <= 1258; CodePage++)
	{
		if(cch != WideCharToMultiByte(CodePage, 0, rgch, cch, rgach, cch, "\0", NULL) ||
		   cch != MultiByteToWideChar(CodePage, 0, rgach, cch, rgch, cch))
		{
			continue;				// Missing code page
		}
		//							 1250 1251 1252 1253  1254  1255  1256  1257   1258
		const static WORD rgMask[] = {0x2, 0x4, 0x1, 0x8, 0x10, 0x20, 0x40, 0x80, 0x100};

		DWORD dwMask = rgMask[CodePage - 1250] << 8;

		for(i = iFirst, pch = rgch; i <= iLast; pch++, i++)
		{
			AssertSz(!((*pch != (WCHAR)i) ^ !(W32->GetCharFlags125x(i) & dwMask)),
				"GetCharFlags125x() failure");
			*pch = (WCHAR)i;	// Restore value
		}
	}
	return TRUE;				// Above AssertSz() reports any errors
}
#endif

#ifndef NODRAFTMODE
bool CW32System::GetDraftModeFontInfo(
	SHORT &iFont,
	SHORT &yHeight,
	QWORD &qwFontSig,
	COLORREF &crColor
)
{
	// Update information if necessary
	if (_draftModeFontInfo._iFont == 0)
	{
		NONCLIENTMETRICSA ncm;
		ncm.cbSize = sizeof(NONCLIENTMETRICSA);
		// Using A version for Win9x compatibility
		if (SystemParametersInfoA(SPI_GETNONCLIENTMETRICS,sizeof(NONCLIENTMETRICS), &ncm, 0))
		{
			CStrInW strinwFontName(ncm.lfMessageFont.lfFaceName, CP_ACP);
			_draftModeFontInfo._iFont = GetFontNameIndex((WCHAR *)strinwFontName);
			_draftModeFontInfo._yHeight = (ncm.lfMessageFont.lfHeight * LY_PER_INCH) / W32->GetYPerInchScreenDC();
			if(_draftModeFontInfo._yHeight <= 0)
				_draftModeFontInfo._yHeight = -_draftModeFontInfo._yHeight;
			if (GetFontSignatureFromFace(_draftModeFontInfo._iFont, &_draftModeFontInfo._qwFontSig) == 0)
				_draftModeFontInfo._qwFontSig = 0;		// Trouble
		}
		_draftModeFontInfo._crTextColor = ::GetSysColor(COLOR_WINDOWTEXT);
	}

	// Handle bad draft mode font
	if (_draftModeFontInfo._qwFontSig == 0)
		return false;

	// Normal return
	iFont = _draftModeFontInfo._iFont;
	yHeight = _draftModeFontInfo._yHeight;
	qwFontSig = _draftModeFontInfo._qwFontSig;
	crColor = _draftModeFontInfo._crTextColor;

	return true;
}
#endif


/*
 *	CW32System::InitSysParams(fUpdate)
 *
 *	@mfunc
 *		This method is used to initialize certain system wide parameters that
 *      that are used in richedit.  This can also be used as an update method
 *      if we ever handle system parameter change notifications.  The update
 *		parameter id provided for this purpose.	Also note that if we ever support
 *		SysParam updating, we may have to protect access with locks.
 */
void CW32System::InitSysParams(BOOL fUpdate)
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CW32System::InitSysParams");
	CLock lock;

	if (!_fSysParamsOk || fUpdate)
	{
		_fSysParamsOk = TRUE;
		
		const LONG dxSelBarDefaultSize = 8;
		HDC hdc = GetScreenDC();
		HFONT hfontOld;
		TEXTMETRIC tm;

		_xPerInchScreenDC = GetDeviceCaps(hdc, LOGPIXELSX); 
		if (_xPerInchScreenDC == 0)
			_xPerInchScreenDC = 0x60;
		_yPerInchScreenDC = GetDeviceCaps(hdc, LOGPIXELSY);
		if (_yPerInchScreenDC == 0)
			_yPerInchScreenDC = 0x60;
		int cPalette = GetDeviceCaps(hdc, SIZEPALETTE);

		// 256 colors is where we seem to need to use the palette.
		if (256 == cPalette)
		{
			_fUsePalette = TRUE;
		}

		// calculate a himetric selection bar for the window's host.
		_dxSelBar = W32->DeviceToHimetric(dxSelBarDefaultSize, _xPerInchScreenDC);

		RefreshKeyboardLayout();
		_hSystemFont = (HFONT)GetStockObject(SYSTEM_FONT);
		hfontOld = SelectFont(hdc, _hSystemFont);
		if(hfontOld)
		{
			W32->GetTextMetrics(hdc, &tm);
			_dupSystemFont = tm.tmAveCharWidth;
			_dvpSystemFont = tm.tmHeight;
			_ySysFontLeading = tm.tmInternalLeading;
			_bCharSetSys = tm.tmCharSet;

			SelectFont(hdc, hfontOld);
		}

		_nScrollInset = (WORD)GetProfileIntA("windows", "ScrollInset",
			DD_DEFSCROLLINSET);
		_nDragDelay = (WORD)GetProfileIntA("windows", "DragDelay",
			DD_DEFDRAGDELAY);
		_nDragMinDist = (WORD)GetProfileIntA("windows", "DragMinDist",
			DD_DEFDRAGMINDIST);
		_nScrollDelay = (WORD)GetProfileIntA("windows", "ScrollDelay",
			DD_DEFSCROLLDELAY);
		_nScrollInterval = (WORD)GetProfileIntA("windows", "ScrollInterval",
			DD_DEFSCROLLINTERVAL);
	    _nScrollVAmount = (WORD)(GetYPerInchScreenDC()*DEFSCROLLVAMOUNT)/100;
	    _nScrollHAmount = (GetXPerInchScreenDC()*DEFSCROLLHAMOUNT)/100;

		_cxBorder	= GetSystemMetrics(SM_CXBORDER);	// Unsizable window border
		_cyBorder	= GetSystemMetrics(SM_CYBORDER);	//  widths
		_cxVScroll	= GetSystemMetrics(SM_CXVSCROLL);	//  dimensions
		_cyHScroll	= GetSystemMetrics(SM_CYHSCROLL);	//

		_cxDoubleClk	= GetSystemMetrics(SM_CXDOUBLECLK);
		_cyDoubleClk	= GetSystemMetrics(SM_CYDOUBLECLK);
		_DCT			= GetDoubleClickTime();
		_sysiniflags	= ::GetProfileIntA("richedit30", "flags", 0);

#ifdef DEBUG
		if(OnWinNT5() && (_sysiniflags & SYSINI_DEBUGGCF125X))
		{
			TestGetCharFlags125x(0xA0, 0x6FF);
			TestGetCharFlags125x(0x2000, 0x2122);
		}
#endif

		_bDigitSubstMode = ReadRegDigitSubstitutionMode();
#ifndef NOCOMPLEXSCRIPTS
		if (g_pusp)
			g_pusp->ApplyDigitSubstitution(_bDigitSubstMode);
#endif

#ifndef NODRAFTMODE
		_draftModeFontInfo._iFont = 0;
#endif
	}
}

/*
 *	CW32System:GetRollerLineScrollCount()
 *
 *	@mfunc	returns the number of lines to scroll with a roller mouse wheel.
 *			-1 means scroll by pages
 *
 *	@devnote We have to do different things for different platforms; NT4.0 has
 *			built in support for this functionality.
 */

/* excerpt from new winuser.h for calls to SystemParametersInfo */
#ifndef SPI_GETWHEELSCROLLLINES
#define SPI_GETWHEELSCROLLLINES   104
#endif

LONG CW32System::GetRollerLineScrollCount()
{
	if( _cLineScroll == 0 )
	{
#ifndef _WIN64
		HKEY hdlKey;
		DWORD keyDataType;
		CHAR charData[128];
		DWORD  dwDataBufSize;

		 // Fall back Value
		_cLineScroll = 0;

		// Read registry directly for Windows 95; if WinNT 4.0 
		// and above then use SystemParametersInfo
		if((OnWin95()))
		{
			// Read registry directly
			if ( RegOpenKeyExA(HKEY_CURRENT_USER, 
						"Control Panel\\Desktop", 
						0,
						KEY_QUERY_VALUE,
						&hdlKey) == ERROR_SUCCESS )
			{
				dwDataBufSize = sizeof(charData);
				if ( RegQueryValueExA(hdlKey, 
							  "WheelScrollLines",
							  NULL,  // reserved
							  &keyDataType,
							  (LPBYTE) &charData,
							  &dwDataBufSize) == ERROR_SUCCESS )
				{
					_cLineScroll = W32->strtoul( charData );   //String representation
				}
			}			
			else
			{
			    // We didn't find line scroll count in the registery.  Check for a Mouse
			    // Wheel window and query the window how many lines to scroll
			    static UINT idWheelSupport = RegisterWindowMessageA(MSH_WHEELSUPPORT);
			    static UINT idScrollLine = RegisterWindowMessageA(MSH_SCROLL_LINES);
			    HWND hwndMsWheel = FindWindowA(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);
			    if (hwndMsWheel && SendMessageA(hwndMsWheel, idWheelSupport, 0, 0))
			        _cLineScroll = SendMessageA(hwndMsWheel, idScrollLine, 0, 0);
			}
			RegCloseKey(hdlKey);
		}
		else if ( (_dwPlatformId == VER_PLATFORM_WIN32_NT) &&
             (_dwMajorVersion >= 4) || OnWin9x())
#endif //_WIN64     
		{
			//call this function if on NT4 or Win98 (NOTE: it isn't sufficient to use
			//OnWin9x() to determine if we are on a win98 system but since the 
			//previous if stmt checks to see if we are in a win95 system OnWin9x
			//can be use)
			SystemParametersInfoA(SPI_GETWHEELSCROLLLINES, 0, &_cLineScroll, 0);
		}
	}

	return _cLineScroll;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline these functions or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr, UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrIn::CStrIn");

    Init(pwstr, -1, CodePage);
}

CStrIn::CStrIn(LPCWSTR pwstr, int cwch, UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrIn::CStrIn");

    Init(pwstr, cwch, CodePage);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrIn::Init(
	LPCWSTR pwstr,
	int		cwch,
	UINT	CodePage)	//@parm Code page to use (CP_ACP is default)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrIn::Init");

    int cchBufReq;

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD((DWORD_PTR)pwstr) == 0)
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    Assert(cwch == -1 || cwch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = W32->MbcsFromUnicode(_ach, ARRAY_SIZE(_ach), pwstr, cwch, CodePage);

    if (_cchLen > 0)
    {
        if(_ach[_cchLen-1] == 0)
            _cchLen--;                // account for terminator
        _pstr = _ach;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    TRACEINFOSZ("CStrIn: Allocating buffer for wrapped function argument.");

    cchBufReq = WideCharToMultiByte(
            CP_ACP, 0, pwstr, cwch, NULL, 0,  NULL, NULL);

    Assert(cchBufReq > 0);
    _pstr = new char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        TRACEINFOSZ("CStrIn: No heap space for wrapped function argument.");
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pstr));
    _cchLen = -1 + W32->MbcsFromUnicode(_pstr, cchBufReq, pwstr, cwch);

    Assert(_cchLen >= 0);
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrInMulti (CStrIn)
//
//  Purpose:    Converts multiple strings which are terminated by two NULLs,
//              e.g. "Foo\0Bar\0\0"
//
//----------------------------------------------------------------------------

class CStrInMulti : public CStrIn
{
public:
    CStrInMulti(LPCWSTR pwstr, UINT CodePage);
};



//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(
	LPCWSTR pwstr,
	UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInMulti::CStrInMulti");

    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    Assert(HIWORD((DWORD_PTR)pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, pwstrT - pwstr, CodePage);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOut::CStrOut");

    Assert(cwchBuf >= 0);

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        Assert(cwchBuf == 0);
        _pstr = NULL;
        return;
    }

    Assert(HIWORD((DWORD_PTR)pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAY_SIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    TRACEINFOSZ("CStrOut: Allocating buffer for wrapped function argument.");
    _pstr = new char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        TRACEINFOSZ("CStrOut: No heap space for wrapped function argument.");
        Assert(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pstr));
    _pstr[0] = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::Convert
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//----------------------------------------------------------------------------

int
CStrOut::Convert()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOut::Convert");

    int cch;

    if (!_pstr)
        return 0;

    cch = MultiByteToWideChar(CP_ACP, 0, _pstr, -1, _pwstr, _cwchBuf);
    Assert(cch > 0 || _cwchBuf == 0);

    Free();

	if (cch > 0 && cch <= _cwchBuf && _pwstr[cch-1] == L'\0')
		cch--;

    return cch;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both Convert() and CConvertStr::~CConvertStr will be called
//              inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOut::~CStrOut");

    Convert();
}


//
//	MultiByte --> UNICODE routins
//

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStr::Free()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CConvertStr::Free");

    if (_pstr != _ach && HIWORD((DWORD_PTR)_pstr) != 0)
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStrW::Free()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CConvertStrW::Free");

    if (_pwstr != _awch && HIWORD((DWORD_PTR)_pwstr) != 0 )
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::CStrInW
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline these functions or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrInW::CStrInW(LPCSTR pstr)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::CStrInW");

    Init(pstr, -1, CP_ACP);
}

CStrInW::CStrInW(LPCSTR pstr, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::CStrInW");

    Init(pstr, -1, uiCodePage);
}

CStrInW::CStrInW(LPCSTR pstr, int cch, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::CStrInW");

    Init(pstr, cch, uiCodePage);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrInW::Init(LPCSTR pstr, int cch, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::Init");

    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD((DWORD_PTR)pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    Assert(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cwchLen = MultiByteToWideChar(
            uiCodePage, 0, pstr, cch, _awch, ARRAY_SIZE(_awch));

    if (_cwchLen > 0)
    {
        if(_awch[_cwchLen-1] == 0)
            _cwchLen--;                // account for terminator
        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    TRACEINFOSZ("CStrInW: Allocating buffer for wrapped function argument.");

    cchBufReq = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, NULL, 0);

    Assert(cchBufReq > 0);
    _pwstr = new WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        TRACEINFOSZ("CStrInW: No heap space for wrapped function argument.");
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pwstr));
    _cwchLen = -1 + MultiByteToWideChar(
            uiCodePage, 0, pstr, cch, _pwstr, cchBufReq);
    Assert(_cwchLen >= 0);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::CStrOutW
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pstr]   -- The ansi buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOutW::CStrOutW(LPSTR pstr, int cchBuf, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOutW::CStrOutW");

    Assert(cchBuf >= 0);

    _pstr = pstr;
    _cchBuf = cchBuf;
	_uiCodePage = uiCodePage;

    if (!pstr)
    {
        Assert(cchBuf == 0);
        _pwstr = NULL;
        return;
    }

    Assert(HIWORD((DWORD_PTR)pstr));

    // Initialize buffer in case Windows API returns an error.
    _awch[0] = 0;

    // Use preallocated buffer if big enough.
    if (cchBuf <= ARRAY_SIZE(_awch))
    {
        _pwstr = _awch;
        return;
    }

    // Allocate buffer.
    TRACEINFOSZ("CStrOutW: Allocating buffer for wrapped function argument.");
    _pwstr = new WCHAR[cchBuf * 2];
    if (!_pwstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        TRACEINFOSZ("CStrOutW: No heap space for wrapped function argument.");
        Assert(cchBuf > 0);
        _pstr[0] = 0;
        _cchBuf = 0;
        _pwstr = _awch;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pwstr));
    _pwstr[0] = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::Convert
//
//  Synopsis:   Converts the buffer from Unicode to MBCS
//
//----------------------------------------------------------------------------

int
CStrOutW::Convert()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOutW::Convert");

    int cch;

    if (!_pwstr)
        return 0;

	int cchBuf = _cchBuf;

	cch = W32->MbcsFromUnicode(_pstr, cchBuf, _pwstr, -1, _uiCodePage);

    Free();

	if (cch > 0 && cch <= _cchBuf && _pstr[cch-1] == '\0')
		cch--;

    return cch;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::~CStrOutW
//
//  Synopsis:   Converts the buffer from Unicode to MBCS.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both Convert() and CConvertStr::~CConvertStr will be called
//              inline.
//
//----------------------------------------------------------------------------

CStrOutW::~CStrOutW()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOutW::~CStrOutW");

    Convert();
}

BOOL CW32System::GetVersion(
	DWORD *pdwPlatformId,
	DWORD *pdwMajorVersion,
	DWORD *pdwMinorVersion
)
{
	OSVERSIONINFOA osv;
	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	*pdwPlatformId = 0;
	*pdwMajorVersion = 0;
	if (::GetVersionExA(&osv))
	{
		*pdwPlatformId = osv.dwPlatformId;
		*pdwMajorVersion = osv.dwMajorVersion;
		*pdwMinorVersion = osv.dwMinorVersion;
		return TRUE;
	}
	return FALSE;
}

BOOL CW32System::GetStringTypes(
	LCID	lcid,
	LPCTSTR rgch,
	int		cch,
	LPWORD	lpCharType1,
	LPWORD	lpCharType3)
{
	for (int ich = 0; ich < cch; ich++)
	{
		if (rgch[ich] <= 0xFF)
		{
			lpCharType1[ich] = rgctype1Ansi[rgch[ich]];
			lpCharType3[ich] = rgctype3Ansi[rgch[ich]];
		}
		else
			break;
	}
	if (ich == cch)
		return TRUE;

	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
	{
		if(::GetStringTypeExW(lcid, CT_CTYPE1, rgch, cch, lpCharType1))
			return ::GetStringTypeExW(lcid, CT_CTYPE3, rgch, cch, lpCharType3);
		return FALSE;
	}

    CStrIn  str(rgch, cch, CodePageFromCharRep(CharRepFromLID(lcid)));
	LONG	cchT = str.strlen();

	if(::GetStringTypeExA(lcid, CT_CTYPE1, str, cchT, lpCharType1))
		return ::GetStringTypeExA(lcid, CT_CTYPE3, str, cchT, lpCharType3);
	return FALSE;
}

BOOL WINAPI CW32System::GetStringTypeEx(
	LCID	lcid,
	DWORD	dwInfoType,
	LPCTSTR rgch,
	int		cch,
	LPWORD	lpCharType
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetStringTypeEx");

	const unsigned short * prgcTypeAnsi = NULL;
	if (dwInfoType == CT_CTYPE1)
		prgcTypeAnsi = rgctype1Ansi;
	else if (dwInfoType == CT_CTYPE3)
		prgcTypeAnsi = rgctype3Ansi;

	if (prgcTypeAnsi)
	{
		for (int ich = 0; ich < cch; ich++)
		{
			if (rgch[ich] <= 0xFF)
				lpCharType[ich] = prgcTypeAnsi[rgch[ich]];
			else
				break;
		}
		if (ich == cch)
			return TRUE;
	}
	
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetStringTypeExW(lcid, dwInfoType, rgch, cch, lpCharType);   

    CStrIn  str(rgch, cch, CodePageFromCharRep(CharRepFromLID(lcid)));
    return GetStringTypeExA(lcid, dwInfoType, str, str.strlen(), lpCharType);   
}

typedef LPSTR (CALLBACK *FnCharChangeCase)(LPSTR);

static LPWSTR CharChangeCase(LPWSTR pwstr, FnCharChangeCase pfn)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharChangeCaseWrap");

    if (HIWORD((DWORD_PTR)pwstr) == 0)
    {
        LPSTR   pstr=0;
		int		retCode;
		char	DBChar[3];

        retCode = W32->MbcsFromUnicode((LPSTR) &pstr, sizeof(pstr), (LPWSTR) &pwstr, 1);
        Assert(HIWORD((DWORD_PTR)pstr) == 0);
		if (retCode == 2)
		{
			// This is a DBC, use string
			DWORD	iTemp = (DWORD)((DWORD_PTR)pstr);
			DBChar[0] = char(iTemp & 0x0ff);
			DBChar[1] = char(iTemp >> 8);
			DBChar[2] = 0;
			pstr = (*pfn)(DBChar);
			W32->UnicodeFromMbcs((LPWSTR) &pwstr, sizeof(pwstr) / sizeof(WCHAR), (LPSTR)DBChar, 2);
		}
		else
		{
			pstr = (*pfn)(pstr);
			W32->UnicodeFromMbcs((LPWSTR) &pwstr, sizeof(pwstr) / sizeof(WCHAR), (LPSTR) &pstr);
		}
		Assert(HIWORD((DWORD_PTR)pwstr) == 0);
	}
    else
    {
        CStrOut strOut(pwstr, W32->wcslen(pwstr));
        W32->MbcsFromUnicode(strOut, strOut.BufSize(), pwstr);
        (*pfn)(strOut);
    }
    return pwstr;
}

LPWSTR WINAPI CW32System::CharLower(LPWSTR pwstr)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLower");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CharLowerW(pwstr);
    return CharChangeCase(pwstr, CharLowerA);
}

DWORD WINAPI CW32System::CharLowerBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLowerBuff");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CharLowerBuffW(pwstr, cchLength);
	LPWSTR lpBuffer = pwstr;
	for (DWORD pos = 0; pos < cchLength; pos++, lpBuffer++)
		*lpBuffer =  (WCHAR)CharChangeCase((LPWSTR)*lpBuffer, CharLowerA);
	return pos;
}

DWORD WINAPI CW32System::CharUpperBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharUpperBuff");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CharUpperBuffW(pwstr, cchLength);
	LPWSTR lpBuffer = pwstr;
	for (DWORD pos = 0; pos < cchLength; pos++, lpBuffer++)
		*lpBuffer =  (WCHAR)CharChangeCase((LPWSTR)*lpBuffer, CharUpperA);
	return pos;
}

typedef HDC (CALLBACK *FnCreateHDCA)(LPCSTR, LPCSTR, LPCSTR, CONST DEVMODEA *);

static HDC WINAPI CreateHDCAux(
	LPCWSTR             lpszDriver,
	LPCWSTR             lpszDevice,
	LPCWSTR             lpszOutput,
	CONST DEVMODEW *    lpInitData,
	FnCreateHDCA        pfn
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateHDCWrap");

    DEVMODEA    devmode;
    CStrIn      strDriver(lpszDriver);
    CStrIn      strDevice(lpszDevice);
    CStrIn      strOutput(lpszOutput);

	if ( lpInitData )
	{
		// converting DEVMODEW to DEVMODEA

		int byteCount;

		// copying the data between the two strings members
		byteCount = (char *)&(devmode.dmFormName) 
			- (char *)&(devmode.dmSpecVersion);
	    memcpy(&(devmode.dmSpecVersion), 
			&(lpInitData->dmSpecVersion), 
			byteCount);

		// copying the data after the second string member
 		byteCount = (char *)((char *)&devmode + sizeof(DEVMODEA)) 
			- (char *)&(devmode.dmLogPixels);
	    memcpy(&(devmode.dmLogPixels), 
			&(lpInitData->dmLogPixels), 
			byteCount);

		// converting the two strings members
		W32->MbcsFromUnicode((CHAR *)devmode.dmDeviceName, CCHDEVICENAME, lpInitData->dmDeviceName);
		W32->MbcsFromUnicode((CHAR *)devmode.dmFormName, CCHFORMNAME, lpInitData->dmFormName);
	}

    return (*pfn)(strDriver, strDevice, strOutput, 
		lpInitData ? &devmode : NULL);
}

HDC WINAPI CW32System::CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateIC");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CreateICW( lpszDriver, lpszDevice, lpszOutput, lpInitData );
    return CreateHDCAux(lpszDriver, lpszDevice, lpszOutput, lpInitData, CreateICA);
}

HANDLE WINAPI CW32System::CreateFile(
	LPCWSTR                 lpFileName,
	DWORD                   dwDesiredAccess,
	DWORD                   dwShareMode,
	LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
	DWORD                   dwCreationDisposition,
	DWORD                   dwFlagsAndAttributes,
	HANDLE                  hTemplateFile
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFile");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CreateFileW(lpFileName,
							dwDesiredAccess,
							dwShareMode,
							lpSecurityAttributes,
							dwCreationDisposition,
							dwFlagsAndAttributes,
							hTemplateFile);

    CStrIn  str(lpFileName);
    return ::CreateFileA(
            str,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
}

HFONT WINAPI CW32System::CreateFontIndirect(CONST LOGFONTW * plfw)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFontIndirect");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CreateFontIndirectW(plfw);
    LOGFONTA  lfa;
    HFONT     hFont;

    memcpy(&lfa, plfw, offsetof(LOGFONTA, lfFaceName));
    MbcsFromUnicode(lfa.lfFaceName, ARRAY_SIZE(lfa.lfFaceName), plfw->lfFaceName,
		-1, CP_ACP, UN_NOOBJECTS);
    hFont = ::CreateFontIndirectA(&lfa);
    return hFont;
}

int WINAPI CW32System::CompareString ( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cch1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cch2 			// size, in bytes or characters, of second string  
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CompareString");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CompareStringW(Locale, dwCmpFlags, lpString1, cch1, lpString2, cch2);

    CStrIn      str1(lpString1, cch1);
    CStrIn      str2(lpString2, cch2);

	return CompareStringA(
		Locale,
		dwCmpFlags,
		str1,
		str1.strlen(),
		str2,
		str2.strlen()
		);
}

LRESULT WINAPI CW32System::DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "DefWindowProcWrap");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::DefWindowProcW(hWnd, msg, wParam, lParam);
	return ::DefWindowProcA(hWnd, msg, wParam, lParam);
}

int WINAPI CW32System::GetObject(HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetObject");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetObjectW( hgdiObj, cbBuffer, lpvObj);

    int nRet;

    if(cbBuffer != sizeof(LOGFONTW) || !lpvObj)
    {
        nRet = ::GetObjectA(hgdiObj, cbBuffer, lpvObj);
        if(nRet == sizeof(LOGFONTA))
        {
            nRet = sizeof(LOGFONTW);
        }
    }
    else
    {
        LOGFONTA lfa;

        nRet = ::GetObjectA(hgdiObj, sizeof(lfa), &lfa);

        if(nRet > 0)
        {
            memcpy(lpvObj, &lfa, offsetof(LOGFONTW, lfFaceName));
            UnicodeFromMbcs(((LOGFONTW*)lpvObj)->lfFaceName, ARRAY_SIZE(((LOGFONTW*)lpvObj)->lfFaceName),
                            lfa.lfFaceName, -1);
            nRet = sizeof(LOGFONTW);
        }
    }

    return nRet;
}

DWORD APIENTRY CW32System::GetProfileSection(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetProfileSection");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetProfileSectionW( lpAppName, lpReturnedString, nSize );

	CStrIn 	strAppName(lpAppName);

	// we can't use CStrOut here, since the returned string contains a set of
	// strings delimited by single-NULL's and terminated by a double-NULL
	char *pszReturnedString;

	pszReturnedString = new char[nSize];
	Assert(pszReturnedString);

	DWORD cch = ::GetProfileSectionA(strAppName, pszReturnedString, nSize);

	if(cch)
	{
		cch = MultiByteToWideChar(CP_ACP, 0, pszReturnedString, cch, 
								lpReturnedString, nSize);
	}

	delete pszReturnedString;
	return cch;
}

int WINAPI CW32System::GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextFace");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetTextFaceW( hdc, cch, lpFaceName );
    CStrOut str(lpFaceName, cch);
    ::GetTextFaceA(hdc, str.BufSize(), str);
    return str.Convert();
}

BOOL WINAPI CW32System::GetTextMetrics(HDC hdc, LPTEXTMETRICW lptm)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextMetrics");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetTextMetricsW( hdc, lptm);

   BOOL         ret;
   TEXTMETRICA  tm;

   ret = ::GetTextMetricsA(hdc, &tm);

    if (ret)
    {
        lptm->tmHeight              = tm.tmHeight;
        lptm->tmAscent              = tm.tmAscent;
        lptm->tmDescent             = tm.tmDescent;
        lptm->tmInternalLeading     = tm.tmInternalLeading;
        lptm->tmExternalLeading     = tm.tmExternalLeading;
        lptm->tmAveCharWidth        = tm.tmAveCharWidth;
        lptm->tmMaxCharWidth        = tm.tmMaxCharWidth;
        lptm->tmWeight              = tm.tmWeight;
        lptm->tmOverhang            = tm.tmOverhang;
        lptm->tmDigitizedAspectX    = tm.tmDigitizedAspectX;
        lptm->tmDigitizedAspectY    = tm.tmDigitizedAspectY;
        lptm->tmItalic              = tm.tmItalic;
        lptm->tmUnderlined          = tm.tmUnderlined;
        lptm->tmStruckOut           = tm.tmStruckOut;
        lptm->tmPitchAndFamily      = tm.tmPitchAndFamily;
        lptm->tmCharSet             = tm.tmCharSet;

        UnicodeFromMbcs(&lptm->tmFirstChar, 1, (LPSTR) &tm.tmFirstChar, 1);
        UnicodeFromMbcs(&lptm->tmLastChar, 1, (LPSTR) &tm.tmLastChar, 1);
        UnicodeFromMbcs(&lptm->tmDefaultChar, 1, (LPSTR) &tm.tmDefaultChar, 1);
        UnicodeFromMbcs(&lptm->tmBreakChar, 1, (LPSTR) &tm.tmBreakChar, 1);
    }

    return ret;
}

LONG WINAPI CW32System::GetWindowLong(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLong");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetWindowLongW(hWnd, nIndex);
	return ::GetWindowLongA(hWnd, nIndex);
}

LONG_PTR WINAPI CW32System::GetWindowLongPtr(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLongPtr");
#ifdef _WIN64
	return GetWindowLongPtrW(hWnd, nIndex);
#else
	return GetWindowLong(hWnd, nIndex);
#endif
}

DWORD WINAPI CW32System::GetClassLong(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetClassLong");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetClassLongW(hWnd, nIndex);
	return ::GetClassLongA(hWnd, nIndex);
}

HBITMAP WINAPI CW32System::LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadBitmap");
    Assert(HIWORD((DWORD_PTR)lpBitmapName) == 0);
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::LoadBitmapW(hInstance, lpBitmapName);
    return ::LoadBitmapA(hInstance, (LPCSTR) lpBitmapName);
}

HCURSOR WINAPI CW32System::LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadCursor");
    Assert(HIWORD((DWORD_PTR)lpCursorName) == 0);
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::LoadCursorW(hInstance, lpCursorName);
    return ::LoadCursorA(hInstance, (LPCSTR) lpCursorName);
}

HINSTANCE WINAPI CW32System::LoadLibrary(LPCWSTR lpLibFileName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadLibrary");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::LoadLibraryW(lpLibFileName);
    CStrIn  str(lpLibFileName);
    return ::LoadLibraryA(str);
}

LRESULT WINAPI CW32System::SendMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SendMessage");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId && ::IsWindowUnicode(hWnd))
		return ::SendMessageW(hWnd, Msg, wParam, lParam);

	// We never need Ansi to Unicode translation in our use of SendMessage
	// Our list boxes always use Unicode.
    switch (Msg)
    {
	// We don't want to translate these!
	// case LB_ADDSTRING:
    // case LB_INSERTSTRING:
    // case CB_ADDSTRING:
    // case CB_SELECTSTRING:
    // case CB_INSERTSTRING:
    // case LB_GETTEXT:
    // case CB_GETLBTEXT:

    case WM_GETTEXT:
		{
		   CStrOut str((LPWSTR)lParam, (int)wParam);
			::SendMessageA(hWnd, Msg, str.BufSize(), (LPARAM)(LPSTR)str);
			return str.Convert();
		}
		break;

    case WM_SETTEXT:
    case EM_REPLACESEL:
        Assert(FALSE);		// We never send these.  Dead code?
		break;

    case EM_SETPASSWORDCHAR:
        Assert(FALSE);		// We never send these.  Dead code?
		break;
    }
	return ::SendMessageA(hWnd, Msg, wParam, lParam);
}

LONG WINAPI CW32System::SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLong");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::SetWindowLongW(hWnd, nIndex, dwNewLong);
    return ::SetWindowLongA(hWnd, nIndex, dwNewLong);
}

LONG WINAPI CW32System::SetWindowLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLongPtr");
#ifdef _WIN64
	return ::SetWindowLongPtrW(hWnd, nIndex, dwNewLong);
#else
	return SetWindowLong(hWnd, nIndex, dwNewLong);
#endif
}

BOOL WINAPI CW32System::PostMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PostMessage");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::PostMessageW(hWnd, Msg, wParam, lParam);
    return ::PostMessageA(hWnd, Msg, wParam, lParam);
}

BOOL WINAPI CW32System::UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "UnregisterClass");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::UnregisterClassW( lpClassName, hInstance);
    CStrIn  str(lpClassName);
    return ::UnregisterClassA(str, hInstance);
}

int WINAPI CW32System::lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmpi");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::lstrcmpiW(lpString1, lpString2);

	// Fall back on the simple minded CRT algortihm
	// The CRT actually has two paths.  This is the simple one
	const wchar_t * dst = lpString1;
    const wchar_t * src = lpString2;
	wchar_t f,l;
	
	do	{
		f = ((*dst <= L'Z') && (*dst >= L'A'))
			? *dst + L'a' - L'A'
			: *dst;
		l = ((*src <= L'Z') && (*src >= L'A'))
			? *src + L'a' - L'A'
			: *src;
		dst++;
		src++;
	} while ( (f) && (f == l) );
	
	return (int)(f - l);
}

BOOL WINAPI CW32System::PeekMessage(
	LPMSG   lpMsg,
    HWND    hWnd,
    UINT    wMsgFilterMin,
    UINT    wMsgFilterMax,
    UINT    wRemoveMsg
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PeekMessage");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
    return ::PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

DWORD WINAPI CW32System::GetModuleFileName(
	HMODULE hModule,
	LPWSTR lpFilename,
	DWORD nSize
)
{
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetModuleFileNameW(hModule, lpFilename, nSize);
    CStrOut  strout(lpFilename, nSize);
    DWORD res = ::GetModuleFileNameA(hModule, strout, nSize);
	strout.Convert();
	return res; 
}


// The high bits of _yHeightUI & _yHeightOther are being used to check if
// font is installed in the system
#define NEED_TO_CHECK_FONT 0x080
struct PreferredFontInfo
{
	BYTE _bPitchAndFamilyUI;
	BYTE _yHeightUI;
	SHORT _iFontUI;
	BYTE _bPitchAndFamilyOther;
	BYTE _yHeightOther;
	SHORT _iFontOther;
};

PreferredFontInfo g_pfinfo[NCHARREPERTOIRES];

void CW32System::InitPreferredFontInfo()
{
	// For UI case, we will use Word9 UI fonts
	// For Non-UI case, we will use Word9 default email fonts
	
	short iFont;
	short iFontPlane2;

	UINT  uSysDefCodePage = GetSystemDefaultCodePage();
	CLock lock;

	// Japanese Init
	static const WCHAR lpUIJapanFontName[] = L"MS UI Gothic";
	static const WCHAR lpOthJapanFontName[]
		= {0xFF2D,0xFF33,0x0020,0xFF30,0x30B4,0x30B7,0x30C3,0x30AF, 0};
	static const WCHAR lpOthJapanFontNameEUC[] = L"MS PGothic";

	iFont = GetFontNameIndex( lpUIJapanFontName );
	SetPreferredFontInfo( SHIFTJIS_INDEX, true, iFont, 9 | NEED_TO_CHECK_FONT, 17 );
	if (uSysDefCodePage == CP_JAPAN)
		iFont = GetFontNameIndex( lpOthJapanFontName );
	else
		iFont = GetFontNameIndex( lpOthJapanFontNameEUC );
	SetPreferredFontInfo( SHIFTJIS_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, 17 );

	// Korean Init
	static const WCHAR lpUIKoreanFontName[] = {0xAD74, 0xB9BC, 0};
	static const WCHAR lpUIKoreanFontNameEUC[] = L"Gulim";
	
	if (uSysDefCodePage == CP_KOREAN)
		iFont = GetFontNameIndex( lpUIKoreanFontName );		
	else
		iFont = GetFontNameIndex( lpUIKoreanFontNameEUC );

	SetPreferredFontInfo( HANGUL_INDEX, true, iFont, 9 | NEED_TO_CHECK_FONT, 49 );
	SetPreferredFontInfo( HANGUL_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, 49 );

	// Traditional Chinese Init
	static const WCHAR lpUITChineseFontName[]	= {0x65B0, 0x7D30, 0x660E, 0x9AD4, 0};
	static const WCHAR lpUITChineseFontNameEUC[] = L"PMingLiU";
	iFont = GetFontNameIndex(uSysDefCodePage == CP_CHINESE_TRAD
							 ? lpUITChineseFontName : lpUITChineseFontNameEUC);
	iFontPlane2 = iFont;

	SetPreferredFontInfo( BIG5_INDEX, true, iFont, 9 | NEED_TO_CHECK_FONT, 54 );
	SetPreferredFontInfo( BIG5_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, 54 );

	// Simplified Chinese Init
	static const WCHAR lpUISChineseFontName[] = {0x5B8B, 0x4F53, 0};
	static const WCHAR lpUISChineseFontNameEUC[] = L"SimSun";
	iFont = GetFontNameIndex(uSysDefCodePage == CP_CHINESE_SIM
							 ? lpUISChineseFontName : lpUISChineseFontNameEUC);
	SetPreferredFontInfo( GB2312_INDEX, true,  iFont,  9 | NEED_TO_CHECK_FONT, 54 );
	SetPreferredFontInfo( GB2312_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, 54 );

	// English, EastEurope, and Viet Init
	iFont = GetFontNameIndex( szTahoma );
	SetPreferredFontInfo(ANSI_INDEX, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(VIET_INDEX, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	iFont = GetFontNameIndex( szArial );
	SetPreferredFontInfo(ANSI_INDEX, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(EASTEUROPE_INDEX, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(EASTEUROPE_INDEX, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(VIET_INDEX, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );

	// SYMBOL_CHARSET
	iFont = GetFontNameIndex( szWingdings );
	SetPreferredFontInfo(SYMBOL_INDEX, true,  iFont, 8,  DEFAULT_PITCH | FF_DONTCARE);
	SetPreferredFontInfo(SYMBOL_INDEX, false, iFont, 10, DEFAULT_PITCH | FF_DONTCARE);

	// Thai Init
	if (OnWinNT5())
		iFont = GetFontNameIndex( szMicrosSansSerif );
	else 
		iFont = GetFontNameIndex( szTahoma );

	SetPreferredFontInfo(THAI_INDEX, true,  iFont,  8, DEFAULT_PITCH | FF_SWISS );
	iFont = GetFontNameIndex( szCordiaNew );
	SetPreferredFontInfo(THAI_INDEX, false, iFont, 14, DEFAULT_PITCH | FF_SWISS );

	if(OnWinNT5())
	{
		// Georgian and Armenian Init
		iFont = GetFontNameIndex(szSylfaen);
		SetPreferredFontInfo(GEORGIAN_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(GEORGIAN_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(ARMENIAN_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(ARMENIAN_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS);

		iFont = GetFontNameIndex(szArialUnicode);
		for(LONG i = BENGALI_INDEX; i <= MALAYALAM_INDEX; i++)
		{
			SetPreferredFontInfo(i, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS);
			SetPreferredFontInfo(i, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS);
		}
	}
	iFont = GetFontNameIndex( szShruti );
	SetPreferredFontInfo(GUJARATI_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(GUJARATI_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );

	iFont = GetFontNameIndex( szTunga );
	SetPreferredFontInfo(KANNADA_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(KANNADA_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );

	iFont = GetFontNameIndex( szGautami );
	SetPreferredFontInfo(TELUGU_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(TELUGU_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );

	// Devanagari Init
	iFont = GetFontNameIndex( szMangal );
	SetPreferredFontInfo(DEVANAGARI_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(DEVANAGARI_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );

	// Tamil Init
	iFont = GetFontNameIndex( szLatha );
	SetPreferredFontInfo(TAMIL_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(TAMIL_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );

	// Gurmukhi Init
	iFont = GetFontNameIndex( szRaavi );
	SetPreferredFontInfo(GURMUKHI_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(GURMUKHI_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );

	_fFEFontInfo = FEDATA_NOT_INIT;

	// Syriac Init
	iFont = GetFontNameIndex( szSyriac );
	SetPreferredFontInfo(SYRIAC_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(SYRIAC_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );

	// Thaana init
	iFont = GetFontNameIndex( szThaana );
	SetPreferredFontInfo(THAANA_INDEX, true,  iFont,  8 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(THAANA_INDEX, false, iFont, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS );

	// Plane-2 fonts
	BOOL	fRegistryKey = FALSE;

	if (_dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		HKEY	hKey = NULL;

		// Check if any plane2 is specified from Registry.
		if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
						L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\LanguagePack\\SurrogateFallback",
						0,
						KEY_QUERY_VALUE,
						&hKey) == ERROR_SUCCESS)
		{
			LONG	retCode;
			DWORD	keyDataType = 0;
			WCHAR	szPlane2Font[LF_FACESIZE];
			DWORD	dwDataSize = sizeof(szPlane2Font);

			retCode = RegQueryValueEx(hKey,
								L"Plane2",
								NULL,
								&keyDataType,
								(LPBYTE)szPlane2Font,
								&dwDataSize);

			if (retCode == ERROR_SUCCESS && keyDataType == REG_SZ)	// Found the plane2 font from Registry.
			{
				iFont = GetFontNameIndex(szPlane2Font);
				iFontPlane2 = iFont;
				fRegistryKey = TRUE ;
			}

			if (hKey)
				RegCloseKey(hKey);
		}
	}

	if (!fRegistryKey)
	{
		static const WCHAR lpCHSPlane2FontNameEUC[] = L"Simsun (Founder Extended)";
		static const WCHAR lpCHSPlane2FontName[] =
			{0x5B8B, 0x4F53, 0x2D, 0x65B9, 0x6B63, 0x8D85, 0x5927, 0x5B57, 0x7B26, 0x96C6, 0};

		iFont = GetFontNameIndex(uSysDefCodePage == CP_CHINESE_SIM
					 ? lpCHSPlane2FontName : lpCHSPlane2FontNameEUC);
	}

	for(LONG i = JPN2_INDEX; i < JPN2_INDEX + 4; i++)
	{
		SetPreferredFontInfo(i, true, i == CHS2_INDEX ? iFont : iFontPlane2,  9 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(i, false, i == CHS2_INDEX ? iFont : iFontPlane2, 10 | NEED_TO_CHECK_FONT, DEFAULT_PITCH | FF_SWISS);
	}
	CheckInstalledKeyboards();				// Check installed keyboard layouts
}

bool CW32System::IsDefaultFontDefined(
	LONG iCharRep,
	bool fUIFont,
	SHORT &iFont)
{
	if((unsigned)iCharRep >= NCHARREPERTOIRES)
		return false;

	if (!fUIFont && g_pfinfo[iCharRep]._yHeightOther)
	{
		iFont = g_pfinfo[iCharRep]._iFontOther;
		return true;
	}
	if (fUIFont && g_pfinfo[iCharRep]._yHeightUI)
	{
		iFont = g_pfinfo[iCharRep]._iFontUI;
		return true;
	}
	return false;
}

void CW32System::CheckInstalledKeyboards()
{
	HKL	 rghkl[MAX_HKLS];
    INT	 cLayouts = ::GetKeyboardLayoutList(MAX_HKLS, rghkl);		 	
	INT  iCharRep;

	for(INT i = 0; i < cLayouts; i++)
  	{
		iCharRep = CharRepFromLID(LOWORD(rghkl[i]));
 		if(iCharRep >= 0)
			SetPreferredKbd(iCharRep, rghkl[i]);
   	}
}

/*
 *	CW32System::SetPreferredFontInfo(iCharRep, fUIFont,	iFont, yHeight, bPitchAndFamily)
 *
 *	@mfunc
 *		Store font info preferred for iCharRep.
 *
 *	@rdesc
 *		true if success
 */
bool CW32System::SetPreferredFontInfo(
	int		iCharRep,
	bool	fUIFont,
	SHORT	iFont,
	BYTE	yHeight,
	BYTE	bPitchAndFamily)
{
	if((unsigned)iCharRep >= NCHARREPERTOIRES)
		return false;

	if (fUIFont)
	{
		g_pfinfo[iCharRep]._bPitchAndFamilyUI = bPitchAndFamily;

		if (yHeight)
			g_pfinfo[iCharRep]._yHeightUI = yHeight;
		else if (!g_pfinfo[iCharRep]._yHeightUI)
			g_pfinfo[iCharRep]._yHeightUI = 10;

		g_pfinfo[iCharRep]._iFontUI = iFont;
	}
	else
	{
		g_pfinfo[iCharRep]._bPitchAndFamilyOther = bPitchAndFamily;

		if (yHeight)
			g_pfinfo[iCharRep]._yHeightOther = yHeight;
		else if (!g_pfinfo[iCharRep]._yHeightOther)
			g_pfinfo[iCharRep]._yHeightOther = 10;

		g_pfinfo[iCharRep]._iFontOther = iFont;
	}
	SetFontLegitimateSize(iFont, fUIFont, yHeight & ~NEED_TO_CHECK_FONT,
						  IsFECharRep(iCharRep));
	SetFontSignature(iFont, FontSigFromCharRep(iCharRep));
	return true;
}

/*
 *	CW32System::GetPreferredFontInfo(iCharRep, fUIFont,	&iFont, &yHeight, &bPitchAndFamily)
 *
 *	@mfunc
 *		Return font info preferred for iCharRep.
 *
 *	@rdesc
 *		Preferred font info corresponding to iCharRep for doc/UI choice
 *		specified by fUIfont.
 */
bool CW32System::GetPreferredFontInfo(
	int		iCharRep,			//@parm Character Repertoire
	bool	fUIFont,			//@parm TRUE iff UI fonts should be used
	SHORT &	iFont,				//@parm Outparm for preferred font index
	BYTE &	yHeight,			//@parm Outparm for preferred font height
	BYTE &	bPitchAndFamily)	//@parm Outparm for preferred font pitch&family
{
	// Set reasonable values for failure case
	iFont = -1;
	yHeight = 0;
	bPitchAndFamily = 0;

	if((unsigned)iCharRep >= NCHARREPERTOIRES)
		return false;

	if (fUIFont)
	{
 		if(!g_pfinfo[iCharRep]._yHeightUI)
			iCharRep = 0;					// No entry.  Try default
		bPitchAndFamily = g_pfinfo[iCharRep]._bPitchAndFamilyUI;
		yHeight = g_pfinfo[iCharRep]._yHeightUI;
		iFont = g_pfinfo[iCharRep]._iFontUI;
	}
	else
	{
		if(!g_pfinfo[iCharRep]._yHeightOther)
			iCharRep = 0;					// No entry.  Try default
		bPitchAndFamily = g_pfinfo[iCharRep]._bPitchAndFamilyOther;
		yHeight = g_pfinfo[iCharRep]._yHeightOther;
		iFont = g_pfinfo[iCharRep]._iFontOther;
	}
	
	if (yHeight & NEED_TO_CHECK_FONT)
	{
		// Check if the preferred font is installed in the system.
		CLock lock;

		HDC hDC = GetScreenDC();

		// Turn off the checkfont bit
		yHeight &= ~NEED_TO_CHECK_FONT;

		if (fUIFont)
			g_pfinfo[iCharRep]._yHeightUI &= ~NEED_TO_CHECK_FONT;
		else
			g_pfinfo[iCharRep]._yHeightOther &= ~NEED_TO_CHECK_FONT;
		
		if (hDC)
		{
			const short *pFontIndex = fUIFont ? &g_pfinfo[iCharRep]._iFontUI : &g_pfinfo[iCharRep]._iFontOther;
			if (IsFontAvail( hDC, iCharRep, fUIFont, (short *)pFontIndex))
				iFont = *pFontIndex;
		}
	}
	return true;
}

/*
 *	CW32System::GetPreferredFontHeight(fUIFont,	iCharRepOrg, iCharRepNew, yHeightOrg)
 *
 *	@mfunc
 *		called when we need the default font size when changing from one charset to another.
 *
 *	@rdesc
 *		The preferred default font size in TWIP if the Original height is same as the
 *		original charset default font size.  Otherwise, it will return the Original height.
 */
SHORT CW32System::GetPreferredFontHeight(
	bool	fUIFont,
	BYTE	iCharRepOrg, 
	BYTE	iCharRepNew, 
	SHORT	yHeightOrg)
{
	// No entry, forget it
	if (iCharRepOrg == DEFAULT_INDEX || iCharRepNew == DEFAULT_INDEX)
		return yHeightOrg;

	BYTE yHeightOrgPreferred = fUIFont ? 
		g_pfinfo[iCharRepOrg]._yHeightUI : g_pfinfo[iCharRepOrg]._yHeightOther;

	yHeightOrgPreferred &= ~NEED_TO_CHECK_FONT;

	// Get New Preferred Height
	if(yHeightOrgPreferred && yHeightOrgPreferred == yHeightOrg/TWIPS_PER_POINT)
	{
		BYTE yHeightNew = (fUIFont ? 
			g_pfinfo[iCharRepNew]._yHeightUI : g_pfinfo[iCharRepNew]._yHeightOther);

		if (yHeightNew)
		{
			yHeightNew &= ~NEED_TO_CHECK_FONT;
			return yHeightNew * TWIPS_PER_POINT;
		}
	}
	return yHeightOrg;
}

/*
 *	CW32System::CheckInstalledFEFonts()
 *
 *	@mfunc
 *		called when building FE fonts installed and User default LCID info
 *
 *	@devnote
 *		This information is necessary when we want to classify Chinese characters
 *		and Full-width characters.
 */
void CW32System::CheckInstalledFEFonts()
{
	CLock	cLock;
	HDC		hDC = GetScreenDC();

	_fFEFontInfo = 0;
	
	LONG iCharRep = CharRepFromLID(::GetUserDefaultLCID());
	if(IsFECharRep(iCharRep))
	{
		switch (iCharRep)
		{
			case SHIFTJIS_INDEX:
				_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_JPN | JPN_FONT_AVAILABLE);
				break;

			case HANGUL_INDEX:
				_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_KOR | KOR_FONT_AVAILABLE);
				break;

			case BIG5_INDEX:
				_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_BIG5 | BIG5_FONT_AVAILABLE);
				break;

			case GB2312_INDEX:
				_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_GB | GB_FONT_AVAILABLE);
				break;
		}
	}
	if (hDC)
	{
		if (!(_fFEFontInfo & JPN_FONT_AVAILABLE) && IsFontAvail(hDC, SHIFTJIS_INDEX))
			_fFEFontInfo |= JPN_FONT_AVAILABLE;

		if (!(_fFEFontInfo & KOR_FONT_AVAILABLE) && IsFontAvail(hDC, HANGUL_INDEX))
			_fFEFontInfo |= KOR_FONT_AVAILABLE;

		if (!(_fFEFontInfo & BIG5_FONT_AVAILABLE) && IsFontAvail(hDC, BIG5_INDEX))
			_fFEFontInfo |= BIG5_FONT_AVAILABLE;

		if (!(_fFEFontInfo & GB_FONT_AVAILABLE) && IsFontAvail(hDC, GB2312_INDEX))
			_fFEFontInfo |= GB_FONT_AVAILABLE;
	}
}

/*
 *	CW32System::IsFEFontInSystem( cpg )
 *
 *	@mfunc
 *		check if there is any FE font installed for the given codepage
 *
 *	@devnote
 *		This information is necessary when we want to classify Chinese characters
 *		and Full-width characters.
 */
bool CW32System::IsFEFontInSystem(int cpg)
{
	int fFontExist = 0;

	if (_fFEFontInfo == FEDATA_NOT_INIT)
		CheckInstalledFEFonts();		// Look for FE fonts in system

	// Check if font for the codepage is in the system	
	switch (cpg)
	{
	case CP_JAPAN:
		fFontExist = _fFEFontInfo & JPN_FONT_AVAILABLE;
		break;
		
	case CP_KOREAN:
		fFontExist = _fFEFontInfo & KOR_FONT_AVAILABLE;
		break;

	case CP_CHINESE_TRAD:
		fFontExist = _fFEFontInfo & BIG5_FONT_AVAILABLE;
		break;

	case CP_CHINESE_SIM:
		fFontExist = _fFEFontInfo & GB_FONT_AVAILABLE;
		break;
	}
	
	return (fFontExist != 0);
}

/*
 *	CW32System::IsFontAvail(hDC, iCharRep, fUIFont, piFontIndex, pFontName )
 *
 *	@mfunc
 *		called when checking if a font (UI or non-UI) is installed for a given codepage
 *
 *	@devnote
 *		We will try to create the font and verify the charset of the font
 *		actually created.  If the fontname index is supplied, we will check
 *		if the requested font is installed. If the name from GDI is different,
 *		the GDI font index will be returned in piFontIndex.
 *
 *	@rdesc
 *		true if a font that supports the given codepage is available.
 *		If pFontName is given, only return true if this font is available
 */
bool CW32System::IsFontAvail(
	HDC		hDC,				//@parm	Screen hDC
	int		iCharRep,			//@parm Character repertoire	
	bool	fUIFont,			//@parm UI font?
	short	*piFontIndex,		//@parm Font Name Index (default = NULL)
	WCHAR	*pFontName)			//@parm Font Name (default = NULL)
{
	LOGFONTW	lf;
	HFONT		hfont;
	bool		retCode = false;
	BYTE		bCharSet = CharSetFromCharRep(iCharRep);

	ZeroMemory(&lf, sizeof(lf));
    
	// We want GDI to find a font that will support this charset 
	// Unspecified entries in LOGFONT will be either default or don't care.
	lf.lfCharSet = bCharSet; 
	
	if (pFontName)
	{
		lf.lfCharSet = DEFAULT_CHARSET;
		wcscpy(lf.lfFaceName, pFontName);
	}
	else if (fUIFont)
	{
		lf.lfHeight			= g_pfinfo[iCharRep]._yHeightUI;
		lf.lfPitchAndFamily = g_pfinfo[iCharRep]._bPitchAndFamilyUI;
		wcscpy(lf.lfFaceName, GetFontName((LONG)(g_pfinfo[iCharRep]._iFontUI)));
	}
	else
	{
		lf.lfHeight			= g_pfinfo[iCharRep]._yHeightOther;
		lf.lfPitchAndFamily = g_pfinfo[iCharRep]._bPitchAndFamilyOther;
		wcscpy(lf.lfFaceName, GetFontName((LONG)(g_pfinfo[iCharRep]._iFontOther)));
	}

	lf.lfHeight &= ~NEED_TO_CHECK_FONT;
	hfont = CreateFontIndirect(&lf);
	if(hfont)
    {
		HFONT	   hfontOld = SelectFont(hDC, hfont);
		TEXTMETRIC tm;
					
		if (GetTextMetrics(hDC, &tm) && (tm.tmCharSet == bCharSet || pFontName))
		{
			if (!pFontName)
				retCode = true;

			if (piFontIndex || pFontName)
			{
				const WCHAR	*pszFontName = pFontName ? pFontName : GetFontName(*piFontIndex);

				if (pszFontName)
				{ 
					WCHAR szNewFaceName[LF_FACESIZE];
					
					// Check if GDI gives us the same font name
					szNewFaceName[0] = L'\0';
					GetTextFace(hDC, LF_FACESIZE, szNewFaceName);
					if (szNewFaceName[0])
					{
						if (wcsicmp(pszFontName, szNewFaceName))
						{
							if (piFontIndex)
								*piFontIndex = GetFontNameIndex(szNewFaceName);	// Different name
						}
						else
							retCode = true;
					}
				}
			}
		}
		SelectFont(hDC, hfontOld);
		DeleteObject(hfont);
	}
	return retCode;
}

/*
 *	CW32System::GetFEFontInfo( void  )
 *
 *
 *	@mfunc
 *		called when classifying Chinese characters and Full-width characters
 *
 *	@devnote
 *		Chinese characters and Full-width characters can be in any
 *		of the four FE codepages.  We want to classfy them according to the 
 *		User default LCID and which FE fonts are installed in the system.
 *
 *	@rdesc
 *		CharRep for the character.
 */
UINT CW32System::GetFEFontInfo()
{
	int	iDefUserCodepage = -1;

	if (_fFEFontInfo == FEDATA_NOT_INIT)
	{
		CLock	Lock;

		// Check if FE fonts are available in the system
		CheckInstalledFEFonts();
	}

	if (_fFEFontInfo & FEUSER_LCID)
		iDefUserCodepage = (_fFEFontInfo & FEUSER_CODEPAGE);

	if (iDefUserCodepage == FEUSER_CP_BIG5)
		return BIG5_INDEX;

	if (iDefUserCodepage == FEUSER_CP_GB)
		return GB2312_INDEX;	
	
	if (iDefUserCodepage == FEUSER_CP_JPN)
		return SHIFTJIS_INDEX;

	if (iDefUserCodepage == FEUSER_CP_KOR)		
		return HANGUL_INDEX;

	// Check which font is available and return the corresponding codepage
	// We check for Simplified Chinese first since it contains more Chinese
	// characters than Traditional Chinese.
	if (_fFEFontInfo & GB_FONT_AVAILABLE)
		return GB2312_INDEX;

	if (_fFEFontInfo & BIG5_FONT_AVAILABLE)
		return BIG5_INDEX;

	if (_fFEFontInfo & JPN_FONT_AVAILABLE)
		return SHIFTJIS_INDEX;

	if (_fFEFontInfo & KOR_FONT_AVAILABLE)
		return HANGUL_INDEX;

	return GB2312_INDEX;				// Well, no FE font, tough luck.
}

#ifndef NOCOMPLEXSCRIPTS
/*
 *	CW32System::IsDiacriticOrKashida(ch, wC3Type)
 *
 *	@mfunc
 *		Return TRUE if ch or wC3Type reveals that ch is a nonspacing
 *		diacritic or a kashida. Because Win9x GetStringTypeExW isn't
 *		implemented, we use range checks for Win9x.
 *
 *	@rdesc
 *		True if ch or wC3Type reveals that ch is a nonspacing diacritic
 */
BOOL CW32System::IsDiacriticOrKashida(
	WCHAR ch,		//@parm On Win9x, check ranges for ch
	WORD  wC3Type)	//@parm On WinNT, use C3-type check
{
	if(VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId && wC3Type)
		return wC3Type & (C3_DIACRITIC | C3_NONSPACING | C3_VOWELMARK | C3_KASHIDA);

	if(!IN_RANGE(0x300, ch, 0xe50))		// Combining diacritics of interest
		return FALSE;					//  fall in this range

	return IN_RANGE(0x300, ch, 0x36F) || IsDiacritic(ch) || IsBiDiKashida(ch);
}
#endif

/*
 *	CW32System::IsDiacritic(ch)
 *
 *	@mfunc
 *		Return TRUE if ch falls in BiDi, Thai, Devanagari or Tamil diacritic range.
 */
BOOL CW32System::IsDiacritic(
	WCHAR ch)
{
	// BiDi
	if (IsBiDiDiacritic(ch))
		return TRUE;

	// Thai
	if (IN_RANGE(0xe31, ch, 0xe4e))
		return 	IN_RANGE(0x0e47, ch, 0x0e4e) || IN_RANGE(0x0e34, ch, 0x0e3a) || ch == 0x0e31;

	// Devanagari
	if (IN_RANGE(0x0902, ch, 0x0963))
		return 	IN_RANGE(0x0941, ch, 0x0948) || IN_RANGE(0x0951, ch, 0x0954) || ch == 0x094d ||		
				IN_RANGE(0x0962, ch, 0x0963) || IN_RANGE(0x0901, ch, 0x0902) || ch == 0x093c;

	// Tamil
	if (IN_RANGE(0x0b82, ch, 0x0bcd))
		return 	ch == 0x0bcd || ch == 0x0bc0 || ch == 0x0b82;

	return FALSE;
}

void CW32System::EraseTextOut(HDC hdc, const RECT *prc)
{
	::ExtTextOutA(hdc, 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);
}

int CW32System::GetTextCharsetInfo (
  HDC hdc,                // handle to device context
  LPFONTSIGNATURE lpSig,  // pointer to structure to receive data
  DWORD dwFlags           // reserved; must be zero
)
{
	return ::GetTextCharsetInfo( hdc, lpSig, dwFlags );
}

UINT WINAPI CW32System::SetTextAlign(HDC hdc, UINT uAlign)
{
	return ::SetTextAlign(hdc, uAlign);
}

BOOL WINAPI CW32System::InvertRect(HDC hdc, CONST RECT *prc)
{
    return ::InvertRect(hdc, prc);
}

HGLOBAL WINAPI CW32System::GlobalAlloc( UINT uFlags, DWORD dwBytes )
{
	return ::GlobalAlloc( uFlags, dwBytes );
}

HGLOBAL WINAPI CW32System::GlobalFree( HGLOBAL hMem )
{
	return hMem ? ::GlobalFree( hMem ) : NULL;
}

UINT WINAPI CW32System::GlobalFlags( HGLOBAL hMem )
{
	return ::GlobalFlags( hMem );
}

HGLOBAL WINAPI CW32System::GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags )
{
	return ::GlobalReAlloc( hMem, dwBytes, uFlags );
}

DWORD WINAPI CW32System::GlobalSize( HGLOBAL hMem )
{
	return ::GlobalSize( hMem );
}

LPVOID WINAPI CW32System::GlobalLock( HGLOBAL hMem )
{
	return ::GlobalLock( hMem );
}

HGLOBAL WINAPI CW32System::GlobalHandle( LPCVOID pMem )
{
	return ::GlobalHandle( pMem );
}

BOOL WINAPI CW32System::GlobalUnlock( HGLOBAL hMem )
{
	return ::GlobalUnlock( hMem );
}

// Return TRUE if
// hWnd is the same as GetForegroundWindow() or
// hWnd's parent is the parent of GetForegroundWindow()
BOOL CW32System::IsForegroundFrame(
	HWND	hWnd)
{

	if (hWnd == NULL)
		return FALSE;

	HWND	hForeGround = ::GetForegroundWindow();

	if (hForeGround == NULL)
		return FALSE;

	if (hForeGround == hWnd)
		return TRUE;

	// Get the Parent hwnd
	for(;;)
	{
		HWND hParent = ::GetParent( hWnd );
		if( hParent == NULL )
			break;
		hWnd = hParent;
	}

	// Get the Parent hwnd of hForeGround
	for(;;)
	{
		HWND hParent = ::GetParent( hForeGround );
		if( hParent == NULL )
			break;
		hForeGround = hParent;
	}

	return (hForeGround == hWnd);
}

VOID CALLBACK TrackMouseTimerProc(
	HWND hWnd,
	UINT uMsg,
	UINT idEvent,
	DWORD dwTime)
{
	RECT rect;
	POINT pt;

	::GetClientRect(hWnd,&rect);
	::MapWindowPoints(hWnd,NULL,(LPPOINT)&rect,2);
	::GetCursorPos(&pt);
	if (!::PtInRect(&rect,pt) || (::WindowFromPoint(pt) != hWnd) || !(CW32System::IsForegroundFrame(hWnd)))
	{
		if (!KillTimer(hWnd,RETID_VISEFFECTS))
		{
			// Error killing the timer!
		}

		CW32System::PostMessage(hWnd,WM_MOUSELEAVE,0,0);
	}
}

BOOL CW32System::TrackMouseLeave(HWND hWnd)
{
	// REVIEW JMO Should use TrackMouseEvent on NT 4, 5, and Win98
	if (::SetTimer(hWnd, RETID_VISEFFECTS, 50, (TIMERPROC)TrackMouseTimerProc))
		return TRUE;
	return FALSE;
}

// Helper function for color mixing
COLORREF CrBlend2Colors(COLORREF cr1, int nPart1, COLORREF cr2, int nPart2)
{
	int r, g, b;
	int sum = nPart1 + nPart2;

	// NOTE: there is no reason why this function would NOT work with
	// Part1 = 5 and Part2 = 23, but we expect to be doing percents.  This
	// assert can come out when this is not longer the case.
	Assert(sum == 10 || sum == 100 || sum == 1000);

	// By adding on sum/2 before dividing by sum, we properly round the value,
	// rather than truncating it, while doing integer math.

	r = (nPart1 * GetRValue(cr1) + nPart2 * GetRValue(cr2) + sum / 2) / sum;
	g = (nPart1 * GetGValue(cr1) + nPart2 * GetGValue(cr2) + sum / 2) / sum;
	b = (nPart1 * GetBValue(cr1) + nPart2 * GetBValue(cr2) + sum / 2) / sum;

	Assert(r >= 0);
	Assert(r <= 255);
	Assert(g >= 0);
	Assert(g <= 255);
	Assert(b >= 0);
	Assert(b <= 255);
	
	return RGB(r, g, b);
}

COLORREF CW32System::GetCtlBorderColor(BOOL fMousedown, BOOL fMouseover)
{
	if (fMousedown || fMouseover)
		return ::GetSysColor(COLOR_HIGHLIGHT);
	return ::GetSysColor(COLOR_BTNSHADOW);
}

COLORREF CW32System::GetCtlBkgColor(BOOL fMousedown, BOOL fMouseover)
{
	if (fMousedown)
		return CrBlend2Colors(::GetSysColor(COLOR_HIGHLIGHT), 50, ::GetSysColor(COLOR_WINDOW), 50);
	if (fMouseover)
		return CrBlend2Colors(::GetSysColor(COLOR_HIGHLIGHT), 30, ::GetSysColor(COLOR_WINDOW), 70);
	return ::GetSysColor(COLOR_BTNFACE);
}
 
COLORREF CW32System::GetCtlTxtColor(BOOL fMousedown, BOOL fMouseover, BOOL fDisabled)
{
	if (fMousedown)
		return ::GetSysColor(COLOR_HIGHLIGHTTEXT);
	if (fMouseover)
		return ::GetSysColor(COLOR_BTNTEXT);
	if (fDisabled)
		return ::GetSysColor(COLOR_GRAYTEXT);
	return ::GetSysColor(COLOR_WINDOWTEXT);
}

void CW32System::DrawBorderedRectangle(
	HDC hdc,
	RECT *prc,
	COLORREF crBorder,
	COLORREF crBackground
)
{
	if (hdc == NULL || prc == NULL)
	{
		Assert(FALSE);
		return;
	}

	HBRUSH hbrBorder = CreateSolidBrush(crBorder);
	::FrameRect(hdc, prc, hbrBorder);
	::DeleteObject(hbrBorder);

	// Draw background
	HBRUSH hbrBkg = CreateSolidBrush(crBackground);
	RECT rc = *prc;
	::InflateRect(&rc, -1, -1);
	::FillRect(hdc, &rc, hbrBkg);
	::DeleteObject(hbrBkg);
}

void CW32System::DrawArrow(
	HDC hdc,
	RECT *prc,
	COLORREF crArrow
)
{
	/* 
	dxArrow represents the width of the scrollbar.  It's value can be
	set through the Display Properties Dialog (8-100) and can change based on
	the color scheme the user chooses.
	*/
	int dxArrow = ((DXOFPRECT(prc) >> 1) << 1);	

	// Height of the scrollbar button.
	int dyArrow = DYOFPRECT(prc);

	/* 
	Value used in Windows Standard Color Scheme (dxArrow 16 or 18).  
	*/
	int dx = 7;	
	
	// For all scrollbars of 10 or less, make dx 3.
	if (dxArrow <= 10)
		dx = 3;	
	else if (dxArrow == 12 || dxArrow == 14)
		dx = 5;
	else if (dxArrow >= 20) 
		dx = 9;
	
	// Current x coord
	int x = prc->left + (dxArrow / 2) - (dx / 2); 
	// Current y coord
	int y = prc->top + (dyArrow / 2) - ((dx + 1) / 4); 
	
	// Change for the rectangle in the loop.
	LONG dTop = 1; 
	LONG dBottom = 1;
	LONG dLeft = 1;
	LONG dRight = -1;
	
	COLORREF crBackSav = SetBkColor(hdc, crArrow);
	// Draw
	RECT rc = {x, y, x + dx, y + 1};
	
	while(rc.right > rc.left)
	{
		ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
		rc.right += dRight;
		rc.top += dTop;
		rc.left += dLeft;
		rc.bottom += dBottom;
	}
	SetBkColor(hdc, crBackSav);
}

/*
 *	CW32System::GetTmpDisplayAttrIdx(tmpDisplayAttr)
 *
 *	@mfunc
 *		This routine returns the idx for the given temp display attr.
 *	If the item is not found, a new item will be added to the array.
 *
 *	@rdesc
 *		idx number if success.  Otherwise, returns -1
 */
short CW32System::GetTmpDisplayAttrIdx(
	TMPDISPLAYATTR &tmpDisplayAttr)
{
	if (tmpDisplayAttr.wMask == 0 && !tmpDisplayAttr.bUnderlineType)
		return -1;			// No tmp display attr.

	if (!_arTmpDisplayAttrib)
	{
		_arTmpDisplayAttrib = new CTmpDisplayAttrArray();

		if (!_arTmpDisplayAttrib)
			return -1;
	}

	LONG	idxMax = _arTmpDisplayAttrib->Count();
	LONG	idxItem;
	TMPDISPLAYATTR* pDisplayAttr;

	for (idxItem= 0; idxItem < idxMax; idxItem++)
	{
		pDisplayAttr = _arTmpDisplayAttrib->Elem(idxItem);
		if (pDisplayAttr && !memcmp(&tmpDisplayAttr, pDisplayAttr, sizeof(TMPDISPLAYATTR)))
			return idxItem;		// Find it!
	}

	// Not found, add it to the array
	pDisplayAttr = _arTmpDisplayAttrib->Add(1, &idxItem);

	if (pDisplayAttr)
	{
		*pDisplayAttr = tmpDisplayAttr;
		return idxItem;
	}
	return -1;
}

/*
 *	CW32System::GetTmpColor(idx, crTmpColor, iAction)
 *
 *	@mfunc
 *		Retrieve color from the temp. display attribute given by the idx.
 *
 *	@rdesc
 *		true if success and crTmpColor contains the requested color
 */
bool CW32System::GetTmpColor(
	SHORT idx,
	COLORREF &crTmpColor,
	INT iAction)
{
	crTmpColor = (COLORREF)tomAutoColor;

	if (!_arTmpDisplayAttrib || idx < 0)
		return false;

	Assert(idx < _arTmpDisplayAttrib->Count());

	if (idx < _arTmpDisplayAttrib->Count())
	{
		TMPDISPLAYATTR *pTmpDisplay = _arTmpDisplayAttrib->Elem(idx);

		if (pTmpDisplay)
		{
			switch (iAction)
			{
			case GET_TEMP_TEXT_COLOR:
				if (pTmpDisplay->wMask & APPLY_TMP_FORECOLOR)
				{
					crTmpColor = pTmpDisplay->crTextColor;
					return true;
				}
				break;

			case GET_TEMP_BACK_COLOR:
				if (pTmpDisplay->wMask & APPLY_TMP_BACKCOLOR)
				{
					crTmpColor = pTmpDisplay->crBackColor;
					return true;
				}
				break;

			case GET_TEMP_UL_COLOR:
				crTmpColor = pTmpDisplay->crUnderlineColor;
				return true;
			}
		}
	}
	return false;
}

/*
 *	CW32System::GetTmpUnderline(idx)
 *
 *	@mfunc
 *		Retrieve the underline style idx.
 *
 *	@rdesc
 *		Underline style idx number if success.  Otherwise, returns 0
 */
short CW32System::GetTmpUnderline(
	SHORT idx)
{
	if (!_arTmpDisplayAttrib || idx < 0)
		return 0;		// No temp. underline style

	Assert(idx < _arTmpDisplayAttrib->Count());

	if (idx < _arTmpDisplayAttrib->Count())
	{
		TMPDISPLAYATTR *pTmpDisplay = _arTmpDisplayAttrib->Elem(idx);
		if (pTmpDisplay)
			return pTmpDisplay->bUnderlineType;
	}
	return 0;
}

BOOL DisableBackgroundBitMap()
{
	return FALSE;
}

#undef new
#include "GDIPlus.h"

HBITMAP WINAPI CW32System::GetPictureBitmap(IStream *pstm)
{
	// Background bitmaps disabled for now.
	if (DisableBackgroundBitMap())
		return NULL;

	HBITMAP hbm = NULL;
#if 0
	Gdiplus::Status status;

	Gdiplus::Image image( pstm );
	unsigned int width = image.GetWidth();
	unsigned int height = image.GetHeight();

	Gdiplus::Graphics graphics( &image );
	Gdiplus::Bitmap bitmap(width, height, &graphics);
	Gdiplus::Graphics graphics2( &bitmap );
	status = graphics2.DrawImage(&image, Gdiplus::Point(0, 0));	
	if (status == Gdiplus::Ok)
	{
		Gdiplus::Color bkcolor;
		status = bitmap.GetHBITMAP( bkcolor, &hbm );
		if (status != Gdiplus::Ok)
			hbm = NULL;
	}
#endif
	return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\w32wince.cpp ===
// Windows CE implementations of W32 Interfaces.

#ifndef GUID_NULL
const GUID GUID_NULL = {
	0x00000000,
	0x0000,
	0x0000,
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	};
#endif

// The following function is needed only because a Windows CE dll must have at least one export
__declspec(dllexport) void Useless( void )
{
	return;
}

LONG ValidateTextRange(TEXTRANGE *pstrg);

ATOM WINAPI CW32System::RegisterREClass(
	const WNDCLASSW *lpWndClass)
{
	// On Windows CE we don't do anything with ANSI window class
	return ::RegisterClass(lpWndClass);
}

#ifndef NOANSIWINDOWS
LRESULT CW32System::ANSIWndProc(
	HWND	hwnd,
	UINT	msg,
	WPARAM	wparam,
	LPARAM	lparam,
	BOOL	fIs10Mode)
{
	// Should never be used in WinCE
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}
#endif

DWORD WINAPI CW32System::GetKerningPairs(HDC hdc, DWORD ckp, KERNINGPAIR *pkp)
{
	return 0;
//	return GetKerningPairsW(hdc, ckp, pkp);
}

extern ICustomTextOut *g_pcto;
void WINAPI CW32System::REGetCharWidth(
	HDC		hdc,
	WCHAR	ch,
	INT		*pdxp,
	UINT	cpg,	
	BOOL	fCustomTextOut)
{
	int junk;
	SIZE size;

	if (fCustomTextOut && g_pcto->GetCharWidthW(hdc, ch, ch, pdxp))
		return;

	GetTextExtentExPoint(hdc, &ch, 1, 0, NULL, &junk, &size);
	*pdxp = size.cx;
}

void WINAPI CW32System::REExtTextOut(
	CONVERTMODE cm,
	UINT uiCodePage,
	HDC hdc,
	int x,
	int y,
	UINT fuOptions,
	CONST RECT *prc,
	const WCHAR *lpString,
	UINT cch,
	CONST INT *lpDx,
	DWORD	dwETOFlags)
{
	if (dwETOFlags & fETOCustomTextOut)
	{
		g_pcto->ExtTextOutW(hdc, x, y, fuOptions, prc, lpString, cch, lpDx);
		return;
	}

    ExtTextOut(hdc, x, y, fuOptions, prc, lpString, cch, lpDx);
    return;
}

CONVERTMODE WINAPI CW32System::DetermineConvertMode( HDC hdc, BYTE tmCharSet )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return CVT_NONE;
}

void WINAPI CW32System::CalcUnderlineInfo(HDC hdc, CCcs *pcccs, TEXTMETRIC *ptm )
{
	// Default calculation of size of underline
	// Implements a heuristic in the absence of better font information.
	SHORT dyDescent = pcccs->_yDescent;

	if (0 == dyDescent)
	{
		dyDescent = pcccs->_yHeight >> 3;
	}

	pcccs->_dyULWidth = max(1, dyDescent / 4);
	pcccs->_dyULOffset = (dyDescent - 3 * pcccs->_dyULWidth + 1) / 2;

	if ((0 == pcccs->_dyULOffset) && (dyDescent > 1))
	{
		pcccs->_dyULOffset = 1;
	}

	pcccs->_dySOOffset = -ptm->tmAscent / 3;
	pcccs->_dySOWidth = pcccs->_dyULWidth;

	return;
}

BOOL WINAPI CW32System::ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG nMax )
{
	SCROLLINFO si;
	Assert(wBar == SB_VERT || wBar == SB_HORZ);
	W32->ZeroMemory(&si, sizeof(SCROLLINFO));
	
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_RANGE | SIF_DISABLENOSCROLL;
	if (bShow)
	{
		si.nMax = nMax;
	}
	::SetScrollInfo(hWnd, wBar, &si, TRUE);
	return TRUE;
}

BOOL WINAPI CW32System::EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows )
{
	BOOL fEnable = TRUE;
	BOOL fApi;
	SCROLLINFO si;

	Assert (wSBflags == SB_VERT || wSBflags == SB_HORZ);
	if (wArrows == ESB_DISABLE_BOTH)
	{
		fEnable = FALSE;
	}
	// Get the current scroll range
	W32->ZeroMemory(&si, sizeof(SCROLLINFO));
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_RANGE;
	fApi = ::GetScrollInfo(hWnd, wSBflags, &si);
	if (fApi && !fEnable)
	{
		si.fMask = SIF_RANGE | SIF_DISABLENOSCROLL;
		si.nMin = 0;
		si.nMax = 0;
	}
	if (fApi) ::SetScrollInfo(hWnd, wSBflags, &si, TRUE);
	return fApi ? TRUE : FALSE;
}

BOOL WINAPI CW32System::IsEnhancedMetafileDC( HDC )
{
	// No enhanced metafile
	return FALSE;
}

UINT WINAPI CW32System::SetTextAlign(HDC hdc, UINT uAlign)
{
	// Review :: SHould we set last error?
	return GDI_ERROR;
}

BOOL WINAPI CW32System::InvertRect(HDC hdc, CONST RECT *prc)
{
    HBITMAP hbm, hbmOld;
    HDC     hdcMem;
    int     nHeight, nWidth;

    nWidth = prc->right-prc->left;
    nHeight = prc->bottom-prc->top;

    hdcMem = CreateCompatibleDC(hdc);
    hbm = CreateCompatibleBitmap(hdc, nWidth, nHeight);
    hbmOld = (HBITMAP) SelectObject(hdcMem, hbm);

    BitBlt(hdcMem, 0, 0, nWidth, nHeight, hdc, prc->left, prc->top,
            SRCCOPY);

    FillRect(hdc, prc, (HBRUSH)GetStockObject(WHITE_BRUSH));

    BitBlt(hdc, prc->left, prc->top, nWidth,
                nHeight, hdcMem, 0, 0, SRCINVERT);

    SelectObject(hdcMem, hbmOld);
    DeleteDC(hdcMem);
    DeleteObject(hbm);
    return TRUE;
}

HPALETTE WINAPI CW32System::ManagePalette(
	HDC,
	CONST LOGPALETTE *,
	HPALETTE &,
	HPALETTE &
)
{
	// No op for Windows CE
	return NULL;
}

BOOL WINAPI CW32System::WinLPtoDP(HDC, LPPOINT, int)
{
    // This is not available on Win CE
    return 0;
}

BOOL WINAPI CW32System::WinDPtoLP(HDC, LPPOINT, int)
{
    // This is not available on Win CE
    return 0;
}

long WINAPI CW32System::WvsprintfA( LONG cbBuf, LPSTR pszBuf, LPCSTR pszFmt, va_list arglist )
{
	WCHAR wszBuf[64];
	WCHAR wszFmt[64];
	WCHAR *pwszBuf = wszBuf;
	WCHAR *pwszFmt = wszFmt;
	Assert(cbBuf < 64);
	while (*pszFmt)
	{
		*pwszFmt++ = *pszFmt++;
		if (*(pwszFmt - 1) == '%')
		{
			Assert(*pszFmt == 's' || *pszFmt == 'd' || *pszFmt == '0' || *pszFmt == 'c');
			if (*pszFmt == 's')
			{
				*pwszFmt++ = 'h';
			}
		}
	}
	*pwszFmt = 0;
	LONG cw = wvsprintf( wszBuf, wszFmt, arglist );
	while (*pszBuf++ = *pwszBuf++);
	Assert(cw < cbBuf);
	return cw;
}

int WINAPI CW32System::MulDivFunc(int nNumber, int nNumerator, int nDenominator)
{
#ifndef UNDER_CE
	if ((nNumerator && nNumerator == nDenominator) || (nDenominator && !nNumber))
		return nNumber;
	return ::MulDiv(nNumber, nNumerator, nDenominator);
#else
	// Special handling for Win CE
	// Must be careful to not cause divide by zero
	// Note that overflow on the multiplication is not handled
	// Hopefully that is not a problem for RichEdit use
	// Added Guy's fix up for rounding.

	// Conservative check to see if multiplication will overflow.
	if (IN_RANGE(_I16_MIN, nNumber, _I16_MAX) &&
		IN_RANGE(_I16_MIN, nNumerator, _I16_MAX))
	{
		return nDenominator ? ((nNumber * nNumerator) + (nDenominator / 2)) / nDenominator  : -1;
	}

	__int64 NNumber = nNumber;
	__int64 NNumerator = nNumerator;
	__int64 NDenominator = nDenominator;

	return NDenominator ? ((NNumber * NNumerator) + (NDenominator / 2)) / NDenominator  : -1;
#endif
}

void CW32System::GetFacePriCharSet(HDC hdc, LOGFONT* plf)
{
	plf->lfCharSet = 0;
}

HKL CW32System::CheckChangeKeyboardLayout(
	BYTE bCharSet)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

HKL CW32System::GetKeyboardLayout ( DWORD )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

HRESULT CW32System::LoadRegTypeLib ( REFGUID, WORD, WORD, LCID, ITypeLib ** )
{
	return E_NOTIMPL;
}

HRESULT CW32System::LoadTypeLib ( const OLECHAR *, ITypeLib ** )
{
	return E_NOTIMPL;
}

BSTR CW32System::SysAllocString(const OLECHAR *pch)
{
	return ::SysAllocString(pch);
}

BSTR CW32System::SysAllocStringLen(const OLECHAR *pch, UINT cch)
{
	return ::SysAllocStringLen(pch, cch);
}

void CW32System::SysFreeString(BSTR bstr)
{
	::SysFreeString(bstr);
}

UINT CW32System::SysStringLen(BSTR bstr)
{
	return ::SysStringLen(bstr);
}

void CW32System::VariantInit ( VARIANTARG * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return;
}

void CW32System::VariantClear ( VARIANTARG * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return;
}

HRESULT CW32System::OleCreateFromData ( LPDATAOBJECT, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleCreateFromFile (
	REFCLSID		rclsid, 
	LPCOLESTR		lpszFileName,
	REFIID			riid, 
	DWORD			renderopt,
	LPFORMATETC		pFormatEtc, 
	LPOLECLIENTSITE pClientSite,
	LPSTORAGE		pStg, 
	LPVOID *		ppvObj)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return S_FALSE;
}

void CW32System::CoTaskMemFree ( LPVOID )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return;
}

HRESULT CW32System::CreateBindCtx ( DWORD, LPBC * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HANDLE CW32System::OleDuplicateData ( HANDLE, CLIPFORMAT, UINT )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

HRESULT CW32System::CoTreatAsClass ( REFCLSID, REFCLSID )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::ProgIDFromCLSID ( REFCLSID, LPOLESTR * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleConvertIStorageToOLESTREAM ( LPSTORAGE, LPOLESTREAM )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleConvertIStorageToOLESTREAMEx ( LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleSave ( LPPERSISTSTORAGE, LPSTORAGE, BOOL )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::StgCreateDocfileOnILockBytes ( ILockBytes *, DWORD, DWORD, IStorage ** )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::CreateILockBytesOnHGlobal ( HGLOBAL, BOOL, ILockBytes ** )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleCreateLinkToFile ( LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

LPVOID CW32System::CoTaskMemAlloc ( ULONG )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

LPVOID CW32System::CoTaskMemRealloc ( LPVOID, ULONG )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

HRESULT CW32System::OleInitialize ( LPVOID )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

void CW32System::OleUninitialize ( )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return;
}

HRESULT CW32System::OleSetClipboard ( IDataObject * )
{
	return E_NOTIMPL;
}

HRESULT CW32System::OleFlushClipboard ( )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleIsCurrentClipboard ( IDataObject * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::DoDragDrop ( IDataObject *, IDropSource *, DWORD, DWORD * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleGetClipboard ( IDataObject ** )
{
	return E_NOTIMPL;
}

HRESULT CW32System::RegisterDragDrop ( HWND, IDropTarget * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleCreateLinkFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleCreateStaticFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleDraw ( IUnknown *, DWORD, HDC, LPCRECT )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleSetContainedObject ( IUnknown *, BOOL )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::CoDisconnectObject ( IUnknown *, DWORD )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::WriteFmtUserTypeStg ( IStorage *, CLIPFORMAT, LPOLESTR )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::WriteClassStg ( IStorage *, REFCLSID )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::SetConvertStg ( IStorage *, BOOL )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::ReadFmtUserTypeStg ( IStorage *, CLIPFORMAT *, LPOLESTR * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::ReadClassStg ( IStorage *pstg, CLSID * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleRun ( IUnknown * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::RevokeDragDrop ( HWND )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::CreateStreamOnHGlobal ( HGLOBAL, BOOL, IStream ** )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::GetHGlobalFromStream ( IStream *pstm, HGLOBAL * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleCreateDefaultHandler ( REFCLSID, IUnknown *, REFIID, void ** )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::CLSIDFromProgID ( LPCOLESTR, LPCLSID )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleConvertOLESTREAMToIStorage ( LPOLESTREAM, IStorage *, const DVTARGETDEVICE * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::OleLoad ( IStorage *, REFIID, IOleClientSite *, void ** )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HRESULT CW32System::ReleaseStgMedium ( LPSTGMEDIUM pstgmed)
{
	AssertSz(FALSE, "BUG: Should not be called");

	// we don't use anything other than TYMED_HGLOBAL currently.
	if (pstgmed && (pstgmed->tymed == TYMED_HGLOBAL)) {
		::LocalFree(pstgmed->hGlobal);
	}

	return 0;
}

HRESULT CW32System::CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
		DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return S_FALSE;
}

void CW32System::FreeOle()
{
	AssertSz(FALSE, "BUG: Should not be called");
}

#ifndef NOFEPROCESSING
void CW32System::FreeIME()
{
	AssertSz(FALSE, "BUG: Should not be called");
}

BOOL CW32System::HaveIMEShare()
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

BOOL CW32System::getIMEShareObject(CIMEShare **ppIMEShare)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

LRESULT CW32System::AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return S_FALSE;
}

LRESULT CW32System::AIMMGetCodePage(HKL hKL, UINT *uCodePage)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return S_FALSE;
}

LRESULT CW32System::AIMMActivate(BOOL fRestoreLayout)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return S_FALSE;
}

LRESULT CW32System::AIMMDeactivate(void)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return S_FALSE;
}

LRESULT CW32System::AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return S_FALSE;
}

BOOL CW32System::ImmInitialize( void )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

void CW32System::ImmTerminate( void )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return;
}

LONG CW32System::ImmGetCompositionStringA ( HIMC, DWORD, LPVOID, DWORD )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HIMC CW32System::ImmGetContext ( HWND )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

BOOL CW32System::ImmSetCompositionFontA ( HIMC, LPLOGFONTA )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

BOOL CW32System::ImmSetCompositionWindow ( HIMC, LPCOMPOSITIONFORM )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

BOOL CW32System::ImmReleaseContext ( HWND, HIMC )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

DWORD CW32System::ImmGetProperty ( HKL, DWORD )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

BOOL CW32System::ImmGetCandidateWindow ( HIMC, DWORD, LPCANDIDATEFORM )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

BOOL CW32System::ImmSetCandidateWindow ( HIMC, LPCANDIDATEFORM )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

BOOL CW32System::ImmNotifyIME ( HIMC, DWORD, DWORD, DWORD )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

HIMC CW32System::ImmAssociateContext ( HWND, HIMC )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

UINT CW32System::ImmGetVirtualKey ( HWND )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HIMC CW32System::ImmEscape ( HKL, HIMC, UINT, LPVOID )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

BOOL CW32System::ImmGetOpenStatus ( HIMC )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

BOOL CW32System::ImmGetConversionStatus ( HIMC, LPDWORD, LPDWORD )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

HWND CW32System::ImmGetDefaultIMEWnd ( HWND )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

BOOL CW32System::FSupportSty ( UINT, UINT )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

const IMESTYLE * CW32System::PIMEStyleFromAttr ( const UINT )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

const IMECOLORSTY * CW32System::PColorStyleTextFromIMEStyle ( const IMESTYLE * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

const IMECOLORSTY * CW32System::PColorStyleBackFromIMEStyle ( const IMESTYLE * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return NULL;
}

BOOL CW32System::FBoldIMEStyle ( const IMESTYLE * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

BOOL CW32System::FItalicIMEStyle ( const IMESTYLE * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

BOOL CW32System::FUlIMEStyle ( const IMESTYLE * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return FALSE;
}

UINT CW32System::IdUlIMEStyle ( const IMESTYLE * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

COLORREF CW32System::RGBFromIMEColorStyle ( const IMECOLORSTY * )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}
#endif	// #ifndef NOFEPROCESSING

BOOL CW32System::GetVersion(
	DWORD *pdwPlatformId,
	DWORD *pdwMajorVersion,
	DWORD *pdwMinorVersion
)
{
	OSVERSIONINFO osv;
	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	*pdwPlatformId = 0;
	*pdwMajorVersion = 0;
	if (GetVersionEx(&osv))
	{
		*pdwPlatformId = osv.dwPlatformId;
		*pdwMajorVersion = osv.dwMajorVersion;
		return TRUE;
	}
	return FALSE;
}

BOOL WINAPI CW32System::GetStringTypeEx(
	LCID lcid,
	DWORD dwInfoType,
	LPCTSTR lpSrcStr,
	int cchSrc,
	LPWORD lpCharType
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetStringTypeEx");
	return ::GetStringTypeExW(lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType);   
}

LPWSTR WINAPI CW32System::CharLower(LPWSTR pwstr)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLowerWrap");
    return ::CharLowerW(pwstr);
}

DWORD WINAPI CW32System::CharLowerBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLowerBuffWrap");
	return ::CharLowerBuffW(pwstr, cchLength);
}

DWORD WINAPI CW32System::CharUpperBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharUpperBuffWrap");
	return ::CharUpperBuffW(pwstr, cchLength);
}

HDC WINAPI CW32System::CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateIC");
	return ::CreateDCW( lpszDriver, lpszDevice, lpszOutput, lpInitData);
}

HANDLE WINAPI CW32System::CreateFile(
	LPCWSTR                 lpFileName,
	DWORD                   dwDesiredAccess,
	DWORD                   dwShareMode,
	LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
	DWORD                   dwCreationDisposition,
	DWORD                   dwFlagsAndAttributes,
	HANDLE                  hTemplateFile
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFile");
	return ::CreateFileW(lpFileName,
						dwDesiredAccess,
						dwShareMode,
						lpSecurityAttributes,
						dwCreationDisposition,
						dwFlagsAndAttributes,
						hTemplateFile);
}

HFONT WINAPI CW32System::CreateFontIndirect(CONST LOGFONTW * plf)
{
    TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFontIndirect");

	return ::CreateFontIndirectW(plf);
}

int WINAPI CW32System::CompareString ( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cchCount1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cchCount2 			// size, in bytes or characters, of second string  
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CompareString");
	return ::CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
}

LRESULT WINAPI CW32System::DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "DefWindowProc");
	return ::DefWindowProcW(hWnd, msg, wParam, lParam);
}

int WINAPI CW32System::GetObject(HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj)
{
    TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetObject");

	return ::GetObjectW( hgdiObj, cbBuffer, lpvObj );
}

DWORD APIENTRY CW32System::GetProfileSection(
	LPCWSTR ,
	LPWSTR ,
	DWORD
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetProfileSection");
	// Not available on Win CE
	return 0;
}

int WINAPI CW32System::GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
)
{
    TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextFaceWrap");

   	return ::GetTextFaceW( hdc, cch, lpFaceName );
}

BOOL WINAPI CW32System::GetTextMetrics(HDC hdc, LPTEXTMETRICW ptm)
{
    TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextMetrics");

	return ::GetTextMetricsW( hdc, ptm);
}

LONG WINAPI CW32System::GetWindowLong(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLong");
    return ::GetWindowLongW(hWnd, nIndex);
}

DWORD WINAPI CW32System::GetClassLong(HWND hWnd, int nIndex)
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HBITMAP WINAPI CW32System::LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadBitmap");
    Assert(HIWORD(lpBitmapName) == 0);
    return ::LoadBitmapW(hInstance, lpBitmapName);
}

HCURSOR WINAPI CW32System::LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadCursor");
    Assert(HIWORD(lpCursorName) == 0);
 	
	return (HCURSOR)lpCursorName;
}

HINSTANCE WINAPI CW32System::LoadLibrary(LPCWSTR lpLibFileName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadLibrary");
    return ::LoadLibraryW(lpLibFileName);
}

LRESULT WINAPI CW32System::SendMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SendMessage");
    return ::SendMessageW(hWnd, Msg, wParam, lParam);
}

LONG WINAPI CW32System::SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLongWrap");
    return ::SetWindowLongW(hWnd, nIndex, dwNewLong);
}

BOOL WINAPI CW32System::PostMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PostMessage");
	return ::PostMessageW(hWnd, Msg, wParam, lParam);
}

BOOL WINAPI CW32System::UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "UnregisterClass");
	return ::UnregisterClassW( lpClassName, hInstance);
}

int WINAPI CW32System::lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmpi");
	return ::lstrcmpiW(lpString1, lpString2);
}

BOOL WINAPI CW32System::PeekMessage(
	LPMSG   lpMsg,
    HWND    hWnd,
    UINT    wMsgFilterMin,
    UINT    wMsgFilterMax,
    UINT    wRemoveMsg
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PeekMessage");
    return ::PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

DWORD WINAPI CW32System::GetModuleFileName(
	HMODULE hModule,
	LPWSTR lpFilename,
	DWORD nSize
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetModuleFileName");
	// On Windows CE we will always be known as riched20.dll
	CopyMemory(lpFilename, TEXT("riched20.dll"), sizeof(TEXT("riched20.dll")));
	return sizeof(TEXT("riched20.dll"))/sizeof(WCHAR) - 1;
}

void CW32System::InitPreferredFontInfo()
{
}

bool CW32System::IsDefaultFontDefined(LONG iCharRep, bool fUIFont, SHORT &iFont)
{
	return TRUE;
}

bool CW32System::SetPreferredFontInfo(
	int idxScript,
	bool fUIFont,
	SHORT iFont,
	BYTE yHeight,
	BYTE bPitchAndFamily
)
{
	return FALSE;
}

bool CW32System::IsFontAvail(
	HDC		hDC,				//@parm	Screen hDC
	int		iCharRep,			//@parm Character repertoire	
	bool	fUIFont,			//@parm UI font?
	short	*piFontIndex,		//@parm Font Name Index (default = NULL)
	WCHAR	*pFontName)			//@parm Font Name (default = NULL)
{
	return FALSE;
}

bool CW32System::GetPreferredFontInfo(
	int idxScript,
	bool fUIFont,
	SHORT& iFont,
	BYTE& yHeight,
	BYTE& bPitchAndFamily
)
{
	// Set reasonable values for failure case
	iFont = -1;
	yHeight = 0;
	bPitchAndFamily = 0;

	return FALSE;
}

BOOL CW32System::GetStringTypes(
	LCID	lcid,
	LPCTSTR rgch,
	int		cch,
	LPWORD	lpCharType1,
	LPWORD	lpCharType3)
{
	for (int ich = 0; ich < cch; ich++)
	{
		if (rgch[ich] <= 0xFF)
		{
			lpCharType1[ich] = rgctype1Ansi[rgch[ich]];
			lpCharType3[ich] = rgctype3Ansi[rgch[ich]];
		}
		else
			break;
	}
	if (ich == cch)
		return TRUE;

	if(::GetStringTypeExW(lcid, CT_CTYPE1, rgch, cch, lpCharType1))
		return ::GetStringTypeExW(lcid, CT_CTYPE3, rgch, cch, lpCharType3);
	return FALSE;
}

void CW32System::InitSysParams(BOOL fUpdate)
{
	// FUTURE : JMO Review this carefully.  Not an issue for ebooks because they provide their own host.
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CW32System::InitSysParams");
	CLock lock;

	if (!_fSysParamsOk || fUpdate)
	{
		_fSysParamsOk = TRUE;
		
		const LONG dxSelBarDefaultSize = 8;
		HDC hdc = GetScreenDC();
		HFONT hfontOld;
		TEXTMETRIC tm;

		_xPerInchScreenDC = GetDeviceCaps(hdc, LOGPIXELSX); 
		_yPerInchScreenDC = GetDeviceCaps(hdc, LOGPIXELSY);
		int cPalette = GetDeviceCaps(hdc, SIZEPALETTE);

		// 256 colors is where we seem to need to use the palette.
		if (256 == cPalette)
		{
			_fUsePalette = TRUE;
		}

		// calculate a himetric selection bar for the window's host.
		_dxSelBar = W32->DeviceToHimetric(dxSelBarDefaultSize, _xPerInchScreenDC);

		RefreshKeyboardLayout();
		_hSystemFont = (HFONT)GetStockObject(SYSTEM_FONT);
		hfontOld = SelectFont(hdc, _hSystemFont);
		if(hfontOld)
		{
			W32->GetTextMetrics(hdc, &tm);
			_dupSystemFont = (INT) tm.tmAveCharWidth;
			_dvpSystemFont = (INT) tm.tmHeight;
			_ySysFontLeading = (INT) tm.tmInternalLeading;
			_bCharSetSys = tm.tmCharSet;

			SelectFont(hdc, hfontOld);
		}

		_nScrollInset = DD_DEFSCROLLINSET;
		_nDragDelay = DD_DEFDRAGDELAY;
		_nDragMinDist = DD_DEFDRAGMINDIST;
		_nScrollDelay = DD_DEFSCROLLDELAY;
		_nScrollInterval = DD_DEFSCROLLINTERVAL;
	    _nScrollVAmount = (WORD)(GetYPerInchScreenDC()*DEFSCROLLVAMOUNT)/100;
	    _nScrollHAmount = (GetXPerInchScreenDC()*DEFSCROLLHAMOUNT)/100;

		_cxBorder	= GetSystemMetrics(SM_CXBORDER);	// Unsizable window border
		_cyBorder	= GetSystemMetrics(SM_CYBORDER);	//  widths
		_cxVScroll	= GetSystemMetrics(SM_CXVSCROLL);	//  dimensions
		_cyHScroll	= GetSystemMetrics(SM_CYHSCROLL);	//

		_cxDoubleClk	= GetSystemMetrics(SM_CXDOUBLECLK);
		_cyDoubleClk	= GetSystemMetrics(SM_CYDOUBLECLK);
		_DCT			= GetDoubleClickTime();
		_sysiniflags	= 0;
	}
}

DWORD CW32System::AddRef()
{
	return ++_cRefs;
}

DWORD CW32System::Release()
{
	DWORD culRefs =	--_cRefs;

	return culRefs;
}

LONG WINAPI CW32System::SetWindowLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLongPtr");
	return SetWindowLong(hWnd, nIndex, dwNewLong);
}

LONG_PTR WINAPI CW32System::GetWindowLongPtr(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLongPtr");
	return GetWindowLong(hWnd, nIndex);
}

void CW32System::EraseTextOut(HDC hdc, const RECT *prc)
{
	::ExtTextOutW(hdc, 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);
}

SHORT  CW32System::GetPreferredFontHeight(	
	bool	fUIFont,
	BYTE	bOrgCharSet, 
	BYTE	bNewCharSet, 
	SHORT	yOrgHeight
)
{
	return yOrgHeight;
}

int CW32System::GetTextCharsetInfo(
  HDC hdc,                // handle to device context
  LPFONTSIGNATURE lpSig,  // pointer to structure to receive data
  DWORD dwFlags           // reserved; must be zero
)
{
	ZeroMemory(lpSig, sizeof(FONTSIGNATURE));
	// REMARK: this is a very weak approximation of what a font really
	// offers and needs to be changed when WinCE depends on font binding.
	// Perform inverse of code in GetFontSignatureFromFace():
	//		qwFontSig = ((fsCsb0 & 0x1FF) << 8)		// Shift left since we use
	//				  | ((fsCsb0 & 0x1F0000) << 3);	//  low byte for fBiDi, etc.
	DWORD dw = (DWORD)FontSigFromCharRep(GetLocaleCharRep());
	lpSig->fsCsb[0] = ((dw & 0x1FF00) >> 8) | ((dw & 0xF80000) >> 3);
	return DEFAULT_CHARSET;
}

void CW32System::RefreshKeyboardLayout ()
{
}

HGLOBAL WINAPI CW32System::GlobalAlloc( UINT uFlags, DWORD dwBytes )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HGLOBAL WINAPI CW32System::GlobalFree( HGLOBAL hMem )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

UINT WINAPI CW32System::GlobalFlags( HGLOBAL hMem )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HGLOBAL WINAPI CW32System::GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

DWORD WINAPI CW32System::GlobalSize( HGLOBAL hMem )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

LPVOID WINAPI CW32System::GlobalLock( HGLOBAL hMem )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

HGLOBAL WINAPI CW32System::GlobalHandle( LPCVOID pMem )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

BOOL WINAPI CW32System::GlobalUnlock( HGLOBAL hMem )
{
	AssertSz(FALSE, "BUG: Should not be called");
	return 0;
}

BOOL CW32System::IsForegroundFrame(
	HWND	hWnd)
{
	return FALSE;
}

BOOL CW32System::TrackMouseLeave(HWND hWnd)
{
	return FALSE;
}

// Helper function for color mixing
COLORREF CrBlend2Colors(COLORREF cr1, int nPart1, COLORREF cr2, int nPart2)
{
	return 0;
}

COLORREF CW32System::GetCtlBorderColor(BOOL fMousedown, BOOL fMouseover)
{
	return 0;
}

COLORREF CW32System::GetCtlBkgColor(BOOL fMousedown, BOOL fMouseover)
{
	return 0x0FFFFFFL;
}
 
COLORREF CW32System::GetCtlTxtColor(BOOL fMousedown, BOOL fMouseover, BOOL fDisabled)
{
	return 0;
}

void CW32System::DrawBorderedRectangle(
	HDC hdc,
	RECT *prc,
	COLORREF crBorder,
	COLORREF crBackground
)
{
}
			
void CW32System::DrawArrow(
	HDC hdc,
	RECT *prc,
	COLORREF crArrow
)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_antievt.h ===
/*
 *	@doc INTERNAL 
 *
 *	@module _ANTIEVT.H |
 *
 *
 *	Purpose:
 *		Class declarations for common anti-event objects
 *
 *	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef __ANTIEVT_H__
#define __ANTIEVT_H__

#include "_frunptr.h"

class CTxtEdit;
class CAntiEventDispenser;
class COleObject;


/*
 *	CBaseAE
 *
 *	@class
 *		Base anti-event that manages a linked list of anti-events
 *
 */
class CBaseAE : public IAntiEvent
{
//@access Public Methods
public:
	virtual void Destroy();						//@cmember Destroy
												//@cmember Undo			
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr );
	virtual HRESULT MergeData( DWORD dwDataType, void *pdata);	//@cmember 
												// Merges undo data into the
												// current context.
	virtual void OnCommit( CTxtEdit *ped );		//@cmember Called when AE is
												// committed to undo stack
	virtual	void SetNext( IAntiEvent *pNext );	//@cmember	Sets next AE
	virtual IAntiEvent *GetNext();				//@cmember	Gets next AE

//@access Protected Methods
protected:
	// CBaseAE should only exist as a parent class
	CBaseAE();									//@cmember Constructor
	~CBaseAE(){;}

//@access Private Methods and Data
private:
	IAntiEvent *	_pnext;						//@cmember Pointer to the next
												//AntiEvent
};

/*
 *	CReplaceRangeAE
 *
 *	@class
 *		an anti-event object than undoes a CTxtPtr::ReplaceRange
 *		operation
 *
 *	@base	public | CBaseAE
 */
class CReplaceRangeAE: public CBaseAE
{
//@access Public Methods
public:
	// IAntiEvent methods
	virtual void Destroy();						//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr);		
	virtual HRESULT MergeData( DWORD dwDataType, void *pdata);	//@cmember
												// Merges undo data into the
												// current context

//@access Private methods and data
private:
												//@cmember Constructor
	CReplaceRangeAE(LONG cpMin, LONG cpMax, LONG cchDel, TCHAR *pchDel,
			IAntiEvent *paeCF, IAntiEvent *paePF);
	~CReplaceRangeAE();							//@cmember Destructor

	LONG		_cpMin;							//@cmember cp delete start
	LONG		_cpMax;							//@cmember cp delete end
	LONG		_cchDel;						//@cmember #of chars to insert
	TCHAR *		_pchDel;						//@cmember chars to insert
	IAntiEvent *_paeCF;							//@cmember charformat AE
	IAntiEvent *_paePF;							//@cmember par format AE

	friend class CAntiEventDispenser;
};

/*
 *	CReplaceFormattingAE
 *
 *	@class
 *		an anti-event object than undoes replacing multiple char formats
 *
 *	@base	public |  CBaseAE
 */
class CReplaceFormattingAE: public CBaseAE
{
//@access	Public methods
public:
	//
	// IAntiEvent methods
	//
	virtual void Destroy();					//@cmember Destroy
											//@cmember Undo
	virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);

//@access	Private Methods and Data
private:
											//@cmember Constructor
	CReplaceFormattingAE(CTxtEdit* ped, LONG cp, CFormatRunPtr &rp, LONG cch,
						 IFormatCache *pf, BOOL fPara);

	~CReplaceFormattingAE();				//@cmember Destuctor

	LONG		_cp;						//@cmember cp at formatting start
	LONG		_cRuns;						//@cmember # of format runs
	CFormatRun  *_prgRuns;					//@cmember format runs
	BOOL		_fPara;						//@cmember TRUE if para format 

	friend class CAntiEventDispenser;
};

/*
 *	CReplaceObjectAE
 *
 *	@class
 *		an anti-event object that undoes the deletion of an object
 *
 *	@base public | CBaseAE
 */
class CReplaceObjectAE : public CBaseAE
{
//@access	Public methods
public:
	//
	//	IAntiEvent methods
	//
	virtual void Destroy(void);					//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);
	virtual void OnCommit(CTxtEdit *ped);		//@cmember called when
												// committed
private:
	CReplaceObjectAE(COleObject *pobj);			//@cmember Constructor
	~CReplaceObjectAE();						//@cmember Destructor

	COleObject *	_pobj;						//@cmember pointer to the
												// deleted object
	BOOL			_fUndoInvoked;				//@cmember undo was invoked
												// on this object.
	
	friend class CAntiEventDispenser;
};

/*
 *	CResizeObjectAE
 *
 *	@class
 *		an anti-event object that undoes the resizing of an object
 *
 *	@base public | CBaseAE
 */
class CResizeObjectAE : public CBaseAE
{
//@access	Public methods
public:
	//
	//	IAntiEvent methods
	//
	virtual void Destroy(void);					//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);
	virtual void OnCommit(CTxtEdit *ped);		//@cmember called when
												// committed
private:
	CResizeObjectAE(COleObject *pobj, SIZEUV size); //@cmember Constructor
	~CResizeObjectAE();							//@cmember Destructor

	COleObject *	_pobj;						//@cmember pointer to the
												// deleted object
	SIZEUV			_size;						//@cmember The old size
	BOOL			_fUndoInvoked;				//@cmember undo was invoked
												// on this object.
	
	friend class CAntiEventDispenser;
};

/*
 *  CSelectionAE
 *
 *  @class
 *      an anti-event object to restore a selection
 *
 *  @base public | CBaseAE
 */
class CSelectionAE : public CBaseAE
{
//@access   Public methods
public:
    //
    //  IAntiEvent methods
    //
    virtual void Destroy(void);                 //@cmember Destroy
                                                //@cmember Undo
    virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);
    virtual HRESULT MergeData( DWORD dwDataType, void *pdata);  //@cmember
                                                // Merges undo data into the
                                                // current context

private:
                                                //@cmember Constructor
    CSelectionAE(LONG cp, LONG cch, LONG cpNext, LONG cchNext);
    ~CSelectionAE();                            //@cmember Destructor

    LONG        _cp;                            //@cmember Active end
    LONG        _cch;                           //@cmember Signed extension
	LONG		_cpNext;						//@cmember Next active end
	LONG		_cchNext;						//@cmember Next extension

    friend class CAntiEventDispenser;
};

/*
 *	CAntiEventDispenser
 *
 *	@class
 *		creates anti events and caches them intelligently to provide
 *		for efficient multi-level undo
 */
class CAntiEventDispenser
{
//@access	Public methods
public:
	// no memory mgmt routines; the dispenser is global

												//@cmember text antievent
	IAntiEvent * CreateReplaceRangeAE( CTxtEdit *ped, LONG cpMin, 
					LONG cpMax, LONG cchDel, TCHAR *pchDel, 
					IAntiEvent *paeCF, IAntiEvent *paePF );
												//@cmember formatting AE
	IAntiEvent * CreateReplaceFormattingAE( CTxtEdit *ped, 
					LONG cp, CFormatRunPtr &rp, LONG cch,
					IFormatCache *pf, BOOL fPara );
												//@cmember Object AE
	IAntiEvent * CreateReplaceObjectAE(CTxtEdit *ped, COleObject *pobj);
												//@cmember Object AE
	IAntiEvent * CreateResizeObjectAE(CTxtEdit *ped, COleObject *pobj, SIZEUV size);
												//@cmember Selection AE
	IAntiEvent * CreateSelectionAE(CTxtEdit *ped, LONG cp, LONG cch, 
					LONG cpNext, LONG cchNext);

private:

	// FUTURE (alexgo): we'll want to maintain an allocation cache of 
	// anti-events
};

// NB!! Global variable.

extern class CAntiEventDispenser gAEDispenser;

#endif // !__ANTIEVNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_cbhost.h ===
/*	@doc INTERNAL
 *
 *	@module _CBHOST.H  Combobox Host for Window's Rich Edit Control |
 *	
 *
 *	Original Author: <nl>
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/30/98	v-jerrki	created
 */
#ifndef _CBHOST_H
#define _CBHOST_H

#ifndef NOWINDOWHOSTS

#include "_host.h"
#define CB_LISTBOXID	1000
#define CB_EDITBOXID	1001

enum ITEMMSG {
	ITEM_MSG_DRAWLIST = 1,
	ITEM_MSG_DRAWCOMBO,
	ITEM_MSG_DELETE,
	ITEM_MSG_MEASUREITEM,
};

extern "C" LRESULT CALLBACK RichComboBoxWndProc(HWND, UINT, WPARAM, LPARAM);
class CCmbBxWinHost : public CTxtWinHost
{
friend LRESULT CALLBACK RichComboBoxWndProc(HWND, UINT, WPARAM, LPARAM);

public:
	typedef enum {						// enumeration determining type of combo box
		kSimple = 1,
		kDropDown = 2,
		kDropDownList = 3
	} Combotype;

#ifndef NOACCESSIBILITY


//////////////////////// Combobox IAccessible Methods ////////////////////////////// 
// COMBOBOXES
#define INDEX_COMBOBOX                  0
#define INDEX_COMBOBOX_ITEM             1
#define INDEX_COMBOBOX_BUTTON           2
#define INDEX_COMBOBOX_LIST             3

#define CCHILDREN_COMBOBOX              3

public:
	// -----------------------------
	//	IUnknown interface
	// -----------------------------
    virtual HRESULT 		WINAPI QueryInterface(REFIID riid, void **ppvObject);
#endif
	
public:
	DWORD			_fRightAlign:1;		// Determines if the combo box should be right aligned
	DWORD			_fListVisible:1;	// Determines if list is visible
	DWORD			_fOwnerDraw:1;		// owner draw combo box
	DWORD			_fOwnerDrawVar:1;	// owner draw combo box with varibale height
	DWORD			_fFocus:1;			// do we have the focus?
	DWORD		 	_fMousedown:1;		// if the left button was down
	DWORD			_fVisible:1;		// window is visible
	DWORD			_fEnabled:1;		// window is enabled
	DWORD			_fNoIntegralHeight:1; // no integral height
	DWORD			_fCapture:1;		// determines if the combo box has mouse cursor captured or not
	DWORD			_fResizing:1;		// flag to indicate we are resizing the window
	DWORD			_fExtendedUI:1;		// flag indicating if extended ui is used
	DWORD			_fLBCBMessage:1;	// flag indicating the message is LBCB_TRACKING
	DWORD			_fIgnoreChange:1;	// flag indicating there was an internal change of text in
										// the edit control
	DWORD			_fIgnoreUpdate:1;	// flag indicating if we should ignore the update flag, we need
										// this flag because there will be cases where updateWindow is
										// needed but we don't want to fire the notification
	DWORD			_fButtonDown:1;		// true when button is pressed
	DWORD			_fDontWinNotify:1;	// true when we don't want to call WinNotify for changes
	DWORD			_fSendEditChange:1;	// true when we need to send CBN_EDITCHANGE after painting the change
										//	editbox
	DWORD			_fShutDown:1;		// true when we are shutting down

	HWND			_hwndList;			// window handle of listbox
	HCURSOR			_hcurOld;			// handle to the mouse cursor
	
protected:
	RECT			_rcWindow;			// rect of window which the combo box was created with
	RECT			_rcButton;			// rect of button
	RECT			_rcList;			// rect of listbox

										// we have to have a minimum inset for either the right or left
										// to account for the button for the combo box
	int				_dxRInset;			// minimum right inset
	int				_dxLInset;			// minimum left inset

	int				_dxROffset;			// indents for right and left these values should be used
	int 			_dxLOffset;			// with _dxRInset/_dxLInset to properly calculate the indents

	int				_dyFont;			// Height of the current font, may not necessarily be the system font
	int				_dyEdit;			// height of items

	int				_cyCombo;			// Height of the combo box
	int				_cxCombo;			// Width of the combo box
	int				_cyList;			// Height of the listbox
	int				_cxList;			// Width of the listbox set via CB_SETDROPWIDTH

	long			_nCursor;			// last selected cursor -2 by default
	BOOL			_bSelOk;			// used to help in determining what kind of notification to give

	UINT			_idCtrl;			// ID of control	
	Combotype		_cbType;			// current combo box style
	CLstBxWinHost*	_plbHost;			// pointer to listbox host

protected:

	// Draws the combo button
	void DrawButton(HDC hdc, BOOL bDown);

	// Sets the edit controls text to item of the list box
	void AutoUpdateEdit(int i);

	// Hilite the edit control
	void HiliteEdit(BOOL bSelect);

	// resizes the list box
	void SetDropSize(RECT* prc);

	// set the edit size
	void SetSizeEdit(int nLeft, int nTop, int nRight, int nBottom);

	// get the rect for the listbox
	void GetListBoxRect(RECT &rcList);

public:
	// Constructor / Destructor
	CCmbBxWinHost();
	virtual ~CCmbBxWinHost();

	// initialization function
	virtual BOOL Init(HWND,	const CREATESTRUCT *);

	// Window creation/destruction
	static 	LRESULT OnNCCreate(HWND hwnd, const CREATESTRUCT *pcs);
	static 	void OnNCDestroy(CCmbBxWinHost *ped);
	virtual LRESULT OnCreate(const CREATESTRUCT *pcs);

	// Edit control Text helper functions
	LRESULT GetEditText(LPTSTR szStr, int nSize);
	LRESULT GetTextLength();

	// Draws the focus rect for the edit control
	void DrawEditFocus(HDC);

	// Sets the text in the edit control to the text of the current item in the
	// list box
	void UpdateEditBox();

	// selects the item which has the same text string as the edit control
	int UpdateListBox(BOOL);

	// hides the listbox
	BOOL HideListBox(BOOL, BOOL);

	// shows the list box
	void ShowListBox(BOOL);

	// Used as a way for the listbox to communicate to the combo box about a selection
	void SetSelectionInfo(BOOL bOk, int nIdx);

	// Update the window but don't send the notification
	void UpdateCbWindow()
	{
		_fIgnoreUpdate = 1;
		TxViewChange(TRUE);
		_fIgnoreUpdate = 0;
	}
	
	BOOL DrawCustomFrame(WPARAM wParam, HDC hDCIn);

	/////////////////////////////// message handlers /////////////////////////////////

	// Richedit message
	LRESULT OnSetTextEx(WPARAM wparam, LPARAM lparam);
	 
	// Keyboard messages
	virtual LRESULT	OnKeyDown(WORD vKey, DWORD dwFlags);
	virtual LRESULT	OnChar(WORD vKey, DWORD dwFlags);
	virtual LRESULT OnSyskeyDown(WORD vKey, DWORD dwFlags);

	// mouse messages
	LRESULT OnLButtonUp(WPARAM wparam, LPARAM lparam);
	LRESULT OnMouseMove(WPARAM wparam, LPARAM lparam);
	LRESULT OnMouseWheel(WPARAM wparam, LPARAM lparam);
	LRESULT OnSetCursor(WPARAM wparam, LPARAM lparam);
	LRESULT OnLButtonDown(WPARAM wparam, LPARAM lparam);
	LRESULT OnMouseLeave(WPARAM wparam, LPARAM lparam);

	// focus messages
	LRESULT OnSetFocus(WPARAM wparam, LPARAM lparam);
	LRESULT OnKillFocus(WPARAM wparam, LPARAM lparam);
	LRESULT OnCaptureChanged(WPARAM wparam, LPARAM lparam);

	// window messages
	LRESULT OnPaint(WPARAM, LPARAM);
	HRESULT OnCommand(WPARAM wparam, LPARAM lparam);	
	LRESULT OnSize(WPARAM wparam, LPARAM lparam);
	LRESULT OnGetDlgCode(WPARAM wparam, LPARAM lparam);
	LRESULT OnEnable(WPARAM wparam, LPARAM lparam);

	// rich edit private message
	LRESULT OnSetEditStyle(WPARAM wparam, LPARAM lparam);

	//@cmember Notify host of events
	virtual HRESULT	TxNotify(DWORD iNotify, void *pv);

	//@cmember Scroll the content of the specified window's client area
	virtual void TxScrollWindowEx (INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip, 
		HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll);

	//@cmember Changes the mouse cursor
	virtual HCURSOR TxSetCursor2(HCURSOR hcur, BOOL bText) 
	{ return (hcur) ? ::SetCursor(hcur) : ::GetCursor();}

	//@cmember InvalidateRect
	virtual void TxInvalidateRect(LPCRECT prc, BOOL fMode);

	//@cmember Retrieves the coordinates of a window's client area
	virtual HRESULT	TxGetClientRect(LPRECT prc);

	///////////////////////// combo box message handlers ////////////////////////////
	// Calculates the rect's and height's of all the controls
	BOOL CbCalcControlRects(RECT* prc, BOOL bCalcChange);	

	// Retrieves the drop width of the list box
	LRESULT CbGetDropWidth();

	// sets the drop width of the list box
	void CbSetDropWidth(WPARAM wparam);

	// Retrieves the item height for either the edit or list box
	LRESULT CbGetItemHeight(WPARAM wparam, LPARAM lparam);

	// sets the item height for either the edit or list box
	LRESULT CbSetItemHeight(WPARAM wparam, LPARAM lparam);	

	// sets extendedUI mode
	LRESULT CbSetExtendedUI(BOOL bExtendedUI);

	// retrieves the current extendedUI mode
	LRESULT CbGetExtendedUI() const {return _fExtendedUI;}

	// forwards the WM_DRAWITEM, WM_DELETEITEM messages to the parent window
	LRESULT CbMessageItemHandler(HDC, int, WPARAM, LPARAM);

#ifndef NOACCESSIBILITY
	////////////////////////// IAccessible Methods /////////////////////////////////
	HRESULT	InitTypeInfo();
	
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);    
    STDMETHOD(get_accChildCount)(long *pcountChildren);    
    STDMETHOD(get_accChild)(VARIANT varChild, IDispatch **ppdispChild);    
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);    
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);    
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);     
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);    
    STDMETHOD(get_accFocus)(VARIANT *pvarChild);    
    STDMETHOD(get_accSelection)(VARIANT *pvarChildren);    
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);    
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);    
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);    
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);    
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChild);    
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
#endif // NOACCESSIBILITY

};

#endif // NOWINDOWHOSTS

#endif // _CBHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\winresrc.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) 1990-1996  Microsoft Corporation

Module Name:

    winresrc.h

Abstract:

    This module defines the 32-Bit Windows resource codes.

Revision History:

--*/

#ifndef _WINRESRC_
#define _WINRESRC_



/*
 * ShowWindow() Commands
 */
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10
#define SW_MAX              10

/*
 * Old ShowWindow() Commands
 */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

/*
 * Identifiers for the WM_SHOWWINDOW message
 */
#define SW_PARENTCLOSING    1
#define SW_OTHERZOOM        2
#define SW_PARENTOPENING    3
#define SW_OTHERUNZOOM      4


/*
 * Virtual Keys, Standard Set
 */
#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02
#define VK_CANCEL         0x03
#define VK_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VK_BACK           0x08
#define VK_TAB            0x09

#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D

#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14


#define VK_ESCAPE         0x1B

#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F

/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */

#define VK_LWIN           0x5B
#define VK_RWIN           0x5C
#define VK_APPS           0x5D

#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define VK_F1             0x70
#define VK_F2             0x71
#define VK_F3             0x72
#define VK_F4             0x73
#define VK_F5             0x74
#define VK_F6             0x75
#define VK_F7             0x76
#define VK_F8             0x77
#define VK_F9             0x78
#define VK_F10            0x79
#define VK_F11            0x7A
#define VK_F12            0x7B
#define VK_F13            0x7C
#define VK_F14            0x7D
#define VK_F15            0x7E
#define VK_F16            0x7F
#define VK_F17            0x80
#define VK_F18            0x81
#define VK_F19            0x82
#define VK_F20            0x83
#define VK_F21            0x84
#define VK_F22            0x85
#define VK_F23            0x86
#define VK_F24            0x87

#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91

/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5

#if(WINVER >= 0x0400)
#define VK_PROCESSKEY     0xE5
#endif /* WINVER >= 0x0400 */

#define VK_ATTN           0xF6
#define VK_CRSEL          0xF7
#define VK_EXSEL          0xF8
#define VK_EREOF          0xF9
#define VK_PLAY           0xFA
#define VK_ZOOM           0xFB
#define VK_NONAME         0xFC
#define VK_PA1            0xFD
#define VK_OEM_CLEAR      0xFE


/*
 * Window Messages
 */

#define WM_NULL                         0x0000
#define WM_CREATE                       0x0001
#define WM_DESTROY                      0x0002
#define WM_MOVE                         0x0003
#define WM_SIZE                         0x0005

#define WM_ACTIVATE                     0x0006
/*
 * WM_ACTIVATE state values
 */
#define     WA_INACTIVE     0
#define     WA_ACTIVE       1
#define     WA_CLICKACTIVE  2

#define WM_SETFOCUS                     0x0007
#define WM_KILLFOCUS                    0x0008
#define WM_ENABLE                       0x000A
#define WM_SETREDRAW                    0x000B
#define WM_SETTEXT                      0x000C
#define WM_GETTEXT                      0x000D
#define WM_GETTEXTLENGTH                0x000E
#define WM_PAINT                        0x000F
#define WM_CLOSE                        0x0010
#define WM_QUERYENDSESSION              0x0011
#define WM_QUIT                         0x0012
#define WM_QUERYOPEN                    0x0013
#define WM_ERASEBKGND                   0x0014
#define WM_SYSCOLORCHANGE               0x0015
#define WM_ENDSESSION                   0x0016
#define WM_SHOWWINDOW                   0x0018
#define WM_WININICHANGE                 0x001A
#if(WINVER >= 0x0400)
#define WM_SETTINGCHANGE                WM_WININICHANGE
#endif /* WINVER >= 0x0400 */


#define WM_DEVMODECHANGE                0x001B
#define WM_ACTIVATEAPP                  0x001C
#define WM_FONTCHANGE                   0x001D
#define WM_TIMECHANGE                   0x001E
#define WM_CANCELMODE                   0x001F
#define WM_SETCURSOR                    0x0020
#define WM_MOUSEACTIVATE                0x0021
#define WM_CHILDACTIVATE                0x0022
#define WM_QUEUESYNC                    0x0023

#define WM_GETMINMAXINFO                0x0024
#define WM_PAINTICON                    0x0026
#define WM_ICONERASEBKGND               0x0027
#define WM_NEXTDLGCTL                   0x0028
#define WM_SPOOLERSTATUS                0x002A
#define WM_DRAWITEM                     0x002B
#define WM_MEASUREITEM                  0x002C
#define WM_DELETEITEM                   0x002D
#define WM_VKEYTOITEM                   0x002E
#define WM_CHARTOITEM                   0x002F
#define WM_SETFONT                      0x0030
#define WM_GETFONT                      0x0031
#define WM_SETHOTKEY                    0x0032
#define WM_GETHOTKEY                    0x0033
#define WM_QUERYDRAGICON                0x0037
#define WM_COMPAREITEM                  0x0039

#define WM_COMPACTING                   0x0041
#define WM_COMMNOTIFY                   0x0044  /* no longer suported */
#define WM_WINDOWPOSCHANGING            0x0046
#define WM_WINDOWPOSCHANGED             0x0047

#define WM_POWER                        0x0048
/*
 * wParam for WM_POWER window message and DRV_POWER driver notification
 */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3

#define WM_COPYDATA                     0x004A
#define WM_CANCELJOURNAL                0x004B


#if(WINVER >= 0x0400)
#define WM_NOTIFY                       0x004E
#define WM_INPUTLANGCHANGEREQUEST       0x0050
#define WM_INPUTLANGCHANGE              0x0051
#define WM_TCARD                        0x0052
#define WM_HELP                         0x0053
#define WM_USERCHANGED                  0x0054
#define WM_NOTIFYFORMAT                 0x0055

#define NFR_ANSI                             1
#define NFR_UNICODE                          2
#define NF_QUERY                             3
#define NF_REQUERY                           4

#define WM_CONTEXTMENU                  0x007B
#define WM_STYLECHANGING                0x007C
#define WM_STYLECHANGED                 0x007D
#define WM_DISPLAYCHANGE                0x007E
#define WM_GETICON                      0x007F
#define WM_SETICON                      0x0080
#endif /* WINVER >= 0x0400 */


#define WM_NCCREATE                     0x0081
#define WM_NCDESTROY                    0x0082
#define WM_NCCALCSIZE                   0x0083
#define WM_NCHITTEST                    0x0084
#define WM_NCPAINT                      0x0085
#define WM_NCACTIVATE                   0x0086
#define WM_GETDLGCODE                   0x0087

#define WM_NCMOUSEMOVE                  0x00A0
#define WM_NCLBUTTONDOWN                0x00A1
#define WM_NCLBUTTONUP                  0x00A2
#define WM_NCLBUTTONDBLCLK              0x00A3
#define WM_NCRBUTTONDOWN                0x00A4
#define WM_NCRBUTTONUP                  0x00A5
#define WM_NCRBUTTONDBLCLK              0x00A6
#define WM_NCMBUTTONDOWN                0x00A7
#define WM_NCMBUTTONUP                  0x00A8
#define WM_NCMBUTTONDBLCLK              0x00A9

#define WM_KEYFIRST                     0x0100
#define WM_KEYDOWN                      0x0100
#define WM_KEYUP                        0x0101
#define WM_CHAR                         0x0102
#define WM_DEADCHAR                     0x0103
#define WM_SYSKEYDOWN                   0x0104
#define WM_SYSKEYUP                     0x0105
#define WM_SYSCHAR                      0x0106
#define WM_SYSDEADCHAR                  0x0107
#define WM_KEYLAST                      0x0108

#if(WINVER >= 0x0400)
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F
#endif /* WINVER >= 0x0400 */

#define WM_INITDIALOG                   0x0110
#define WM_COMMAND                      0x0111
#define WM_SYSCOMMAND                   0x0112
#define WM_TIMER                        0x0113
#define WM_HSCROLL                      0x0114
#define WM_VSCROLL                      0x0115
#define WM_INITMENU                     0x0116
#define WM_INITMENUPOPUP                0x0117
#define WM_MENUSELECT                   0x011F
#define WM_MENUCHAR                     0x0120
#define WM_ENTERIDLE                    0x0121

#define WM_CTLCOLORMSGBOX               0x0132
#define WM_CTLCOLOREDIT                 0x0133
#define WM_CTLCOLORLISTBOX              0x0134
#define WM_CTLCOLORBTN                  0x0135
#define WM_CTLCOLORDLG                  0x0136
#define WM_CTLCOLORSCROLLBAR            0x0137
#define WM_CTLCOLORSTATIC               0x0138



#define WM_MOUSEFIRST                   0x0200
#define WM_MOUSEMOVE                    0x0200
#define WM_LBUTTONDOWN                  0x0201
#define WM_LBUTTONUP                    0x0202
#define WM_LBUTTONDBLCLK                0x0203
#define WM_RBUTTONDOWN                  0x0204
#define WM_RBUTTONUP                    0x0205
#define WM_RBUTTONDBLCLK                0x0206
#define WM_MBUTTONDOWN                  0x0207
#define WM_MBUTTONUP                    0x0208
#define WM_MBUTTONDBLCLK                0x0209
#if(_WIN32_WINNT >= 0x0400)
#define WM_MOUSEWHEEL                   0x020A
#endif /* _WIN32_WINNT >= 0x0400 */
#if (_WIN32_WINNT < 0x0400)
#define WM_MOUSELAST                    0x0209
#else
#define WM_MOUSELAST                    0x020A
#endif /* if (_WIN32_WINNT < 0x0400) */

#if(_WIN32_WINNT >= 0x0400)
#define WHEEL_DELTA                     120     /* Value for rolling one detent */
#endif /* _WIN32_WINNT >= 0x0400 */
#if(_WIN32_WINNT >= 0x0400)
#define WHEEL_PAGESCROLL                (UINT_MAX) /* Scroll one page */
#endif /* _WIN32_WINNT >= 0x0400 */

#define WM_PARENTNOTIFY                 0x0210
#define MENULOOP_WINDOW                 0
#define MENULOOP_POPUP                  1
#define WM_ENTERMENULOOP                0x0211
#define WM_EXITMENULOOP                 0x0212

#if(WINVER >= 0x0400)
#define WM_NEXTMENU                     0x0213
#define WM_SIZING                       0x0214
#define WM_CAPTURECHANGED               0x0215
#define WM_MOVING                       0x0216
#define WM_POWERBROADCAST               0x0218
#define WM_DEVICECHANGE                 0x0219

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291
#endif /* WINVER >= 0x0400 */

#define WM_MDICREATE                    0x0220
#define WM_MDIDESTROY                   0x0221
#define WM_MDIACTIVATE                  0x0222
#define WM_MDIRESTORE                   0x0223
#define WM_MDINEXT                      0x0224
#define WM_MDIMAXIMIZE                  0x0225
#define WM_MDITILE                      0x0226
#define WM_MDICASCADE                   0x0227
#define WM_MDIICONARRANGE               0x0228
#define WM_MDIGETACTIVE                 0x0229



#define WM_MDISETMENU                   0x0230
#define WM_ENTERSIZEMOVE                0x0231
#define WM_EXITSIZEMOVE                 0x0232
#define WM_DROPFILES                    0x0233
#define WM_MDIREFRESHMENU               0x0234


#if(_WIN32_WINNT >= 0x0400)
#define WM_MOUSEHOVER                   0x02A1
#define WM_MOUSELEAVE                   0x02A3
#endif /* _WIN32_WINNT >= 0x0400 */

#define WM_CUT                          0x0300
#define WM_COPY                         0x0301
#define WM_PASTE                        0x0302
#define WM_CLEAR                        0x0303
#define WM_UNDO                         0x0304
#define WM_RENDERFORMAT                 0x0305
#define WM_RENDERALLFORMATS             0x0306
#define WM_DESTROYCLIPBOARD             0x0307
#define WM_DRAWCLIPBOARD                0x0308
#define WM_PAINTCLIPBOARD               0x0309
#define WM_VSCROLLCLIPBOARD             0x030A
#define WM_SIZECLIPBOARD                0x030B
#define WM_ASKCBFORMATNAME              0x030C
#define WM_CHANGECBCHAIN                0x030D
#define WM_HSCROLLCLIPBOARD             0x030E
#define WM_QUERYNEWPALETTE              0x030F
#define WM_PALETTEISCHANGING            0x0310
#define WM_PALETTECHANGED               0x0311
#define WM_HOTKEY                       0x0312

#if(WINVER >= 0x0400)
#define WM_PRINT                        0x0317
#define WM_PRINTCLIENT                  0x0318

#define WM_HANDHELDFIRST                0x0358
#define WM_HANDHELDLAST                 0x035F

#define WM_AFXFIRST                     0x0360
#define WM_AFXLAST                      0x037F
#endif /* WINVER >= 0x0400 */

#define WM_PENWINFIRST                  0x0380
#define WM_PENWINLAST                   0x038F




#if(WINVER >= 0x0400)
#define WM_APP                          0x8000
#endif /* WINVER >= 0x0400 */






/*
 * NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 */
#define WM_USER                         0x0400

#if(WINVER >= 0x0400)

/*  wParam for WM_SIZING message  */
#define WMSZ_LEFT           1
#define WMSZ_RIGHT          2
#define WMSZ_TOP            3
#define WMSZ_TOPLEFT        4
#define WMSZ_TOPRIGHT       5
#define WMSZ_BOTTOM         6
#define WMSZ_BOTTOMLEFT     7
#define WMSZ_BOTTOMRIGHT    8
#endif /* WINVER >= 0x0400 */

#ifndef NONCMESSAGES

/*
 * WM_SYNCTASK Commands
 */
#define ST_BEGINSWP         0
#define ST_ENDSWP           1

/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTGROWBOX           4
#define HTSIZE              HTGROWBOX
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT
#define HTSIZELAST          HTBOTTOMRIGHT
#if(WINVER >= 0x0400)
#define HTOBJECT            19
#define HTCLOSE             20
#define HTHELP              21
#endif /* WINVER >= 0x0400 */

/*
 * SendMessageTimeout values
 */
#define SMTO_NORMAL         0x0000
#define SMTO_BLOCK          0x0001
#define SMTO_ABORTIFHUNG    0x0002

#endif /* !NONCMESSAGES */

/*
 * WM_MOUSEACTIVATE Return Codes
 */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#define MA_NOACTIVATEANDEAT 4

/*
 * WM_SETICON / WM_GETICON Type Codes
 */
#define ICON_SMALL          0
#define ICON_BIG            1


/*
 * WM_SIZE message wParam values
 */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/*
 * Obsolete constant names
 */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/*
 * WM_NCCALCSIZE "window valid rect" return values
 */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW         (WVR_HREDRAW | \
                            WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400


#ifndef NOKEYSTATES

/*
 * Key State Masks for Mouse Messages
 */
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010

#endif /* !NOKEYSTATES */

#if(_WIN32_WINNT >= 0x0400)
#ifndef NOTRACKMOUSEEVENT

#define TME_HOVER       0x00000001
#define TME_LEAVE       0x00000002
#define TME_QUERY       0x40000000
#define TME_CANCEL      0x80000000


#define HOVER_DEFAULT   0xFFFFFFFF

#endif /* !NOTRACKMOUSEEVENT */
#endif /* _WIN32_WINNT >= 0x0400 */


/*
 * Window Styles
 */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L
#define WS_MINIMIZE         0x20000000L
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L
#define WS_MAXIMIZE         0x01000000L
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME
#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW

/*
 * Common Window Styles
 */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED     | \
                             WS_CAPTION        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)

#define WS_POPUPWINDOW      (WS_POPUP          | \
                             WS_BORDER         | \
                             WS_SYSMENU)

#define WS_CHILDWINDOW      (WS_CHILD)

/*
 * Extended Window Styles
 */
#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_NOPARENTNOTIFY    0x00000004L
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
#if(WINVER >= 0x0400)
#define WS_EX_MDICHILD          0x00000040L
#define WS_EX_TOOLWINDOW        0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L
#define WS_EX_CONTEXTHELP       0x00000400L

#define WS_EX_RIGHT             0x00001000L
#define WS_EX_LEFT              0x00000000L
#define WS_EX_RTLREADING        0x00002000L
#define WS_EX_LTRREADING        0x00000000L
#define WS_EX_LEFTSCROLLBAR     0x00004000L
#define WS_EX_RIGHTSCROLLBAR    0x00000000L

#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_STATICEDGE        0x00020000L
#define WS_EX_APPWINDOW         0x00040000L


#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)

#endif /* WINVER >= 0x0400 */



/*
 * Class styles
 */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080
#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800
#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000

#if(WINVER >= 0x0400)
#define CS_IME              0x00010000
#endif /* WINVER >= 0x0400 */



/*
 * Predefined Clipboard Formats
 */
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
#define CF_UNICODETEXT      13
#define CF_ENHMETAFILE      14
#if(WINVER >= 0x0400)
#define CF_HDROP            15
#define CF_LOCALE           16
#define CF_MAX              17
#endif /* WINVER >= 0x0400 */

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083
#define CF_DSPENHMETAFILE   0x008E

/*
 * "Private" formats don't get GlobalFree()'d
 */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/*
 * "GDIOBJ" formats do get DeleteObject()'d
 */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF


/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*
 * Menu flags for Add/Check/EnableMenuItem()
 */
#define MF_INSERT           0x00000000L
#define MF_CHANGE           0x00000080L
#define MF_APPEND           0x00000100L
#define MF_DELETE           0x00000200L
#define MF_REMOVE           0x00001000L

#define MF_BYCOMMAND        0x00000000L
#define MF_BYPOSITION       0x00000400L

#define MF_SEPARATOR        0x00000800L

#define MF_ENABLED          0x00000000L
#define MF_GRAYED           0x00000001L
#define MF_DISABLED         0x00000002L

#define MF_UNCHECKED        0x00000000L
#define MF_CHECKED          0x00000008L
#define MF_USECHECKBITMAPS  0x00000200L

#define MF_STRING           0x00000000L
#define MF_BITMAP           0x00000004L
#define MF_OWNERDRAW        0x00000100L

#define MF_POPUP            0x00000010L
#define MF_MENUBARBREAK     0x00000020L
#define MF_MENUBREAK        0x00000040L

#define MF_UNHILITE         0x00000000L
#define MF_HILITE           0x00000080L

#if(WINVER >= 0x0400)
#define MF_DEFAULT          0x00001000L
#endif /* WINVER >= 0x0400 */
#define MF_SYSMENU          0x00002000L
#define MF_HELP             0x00004000L
#if(WINVER >= 0x0400)
#define MF_RIGHTJUSTIFY     0x00004000L
#endif /* WINVER >= 0x0400 */

#define MF_MOUSESELECT      0x00008000L
#if(WINVER >= 0x0400)
#define MF_END              0x00000080L  /* Obsolete -- only used by old RES files */
#endif /* WINVER >= 0x0400 */


#if(WINVER >= 0x0400)
#define MFT_STRING          MF_STRING
#define MFT_BITMAP          MF_BITMAP
#define MFT_MENUBARBREAK    MF_MENUBARBREAK
#define MFT_MENUBREAK       MF_MENUBREAK
#define MFT_OWNERDRAW       MF_OWNERDRAW
#define MFT_RADIOCHECK      0x00000200L
#define MFT_SEPARATOR       MF_SEPARATOR
#define MFT_RIGHTORDER      0x00002000L
#define MFT_RIGHTJUSTIFY    MF_RIGHTJUSTIFY

/* Menu flags for Add/Check/EnableMenuItem() */
#define MFS_GRAYED          0x00000003L
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         MF_CHECKED
#define MFS_HILITE          MF_HILITE
#define MFS_ENABLED         MF_ENABLED
#define MFS_UNCHECKED       MF_UNCHECKED
#define MFS_UNHILITE        MF_UNHILITE
#define MFS_DEFAULT         MF_DEFAULT



#endif /* WINVER >= 0x0400 */

#define MF_END             0x00000080L          
/*
 * System Menu Command Values
 */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150
#if(WINVER >= 0x0400)
#define SC_DEFAULT      0xF160
#define SC_MONITORPOWER 0xF170
#define SC_CONTEXTHELP  0xF180
#define SC_SEPARATOR    0xF00F
#endif /* WINVER >= 0x0400 */
/*
 * Obsolete names
 */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE


/*
 * OEM Resource Ordinal Numbers
 */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640   /* OBSOLETE: use OCR_SIZEALL */
#define OCR_ICON            32641   /* OBSOLETE: use OCR_NORMAL */
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647   /* OBSOLETE: use OIC_WINLOGO */
#define OCR_NO              32648
#if(WINVER >= 0x0400)
#define OCR_APPSTARTING     32650
#endif /* WINVER >= 0x0400 */



#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516
#if(WINVER >= 0x0400)
#define OIC_WINLOGO         32517
#define OIC_WARNING         OIC_BANG
#define OIC_ERROR           OIC_HAND
#define OIC_INFORMATION     OIC_NOTE
#endif /* WINVER >= 0x0400 */


/*
 * Standard Icon IDs
 */
#ifdef RC_INVOKED
#define IDI_APPLICATION     32512
#define IDI_HAND            32513
#define IDI_QUESTION        32514
#define IDI_EXCLAMATION     32515
#define IDI_ASTERISK        32516
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         32517
#endif /* WINVER >= 0x0400 */
#else
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         MAKEINTRESOURCE(32517)
#endif /* WINVER >= 0x0400 */
#endif /* RC_INVOKED */

#if(WINVER >= 0x0400)
#define IDI_WARNING     IDI_EXCLAMATION
#define IDI_ERROR       IDI_HAND
#define IDI_INFORMATION IDI_ASTERISK
#endif /* WINVER >= 0x0400 */


/*
 * Dialog Box Command IDs
 */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7
#if(WINVER >= 0x0400)
#define IDCLOSE         8
#define IDHELP          9
#endif /* WINVER >= 0x0400 */


/*
 * Edit Control Styles
 */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L
#define ES_READONLY         0x0800L
#define ES_WANTRETURN       0x1000L
#if(WINVER >= 0x0400)
#define ES_NUMBER           0x2000L
#endif /* WINVER >= 0x0400 */


/*
 * Edit Control Messages
 */
#define EM_GETSEL               0x00B0
#define EM_SETSEL               0x00B1
#define EM_GETRECT              0x00B2
#define EM_SETRECT              0x00B3
#define EM_SETRECTNP            0x00B4
#define EM_SCROLL               0x00B5
#define EM_LINESCROLL           0x00B6
#define EM_SCROLLCARET          0x00B7
#define EM_GETMODIFY            0x00B8
#define EM_SETMODIFY            0x00B9
#define EM_GETLINECOUNT         0x00BA
#define EM_LINEINDEX            0x00BB
#define EM_SETHANDLE            0x00BC
#define EM_GETHANDLE            0x00BD
#define EM_GETTHUMB             0x00BE
#define EM_LINELENGTH           0x00C1
#define EM_REPLACESEL           0x00C2
#define EM_GETLINE              0x00C4
#define EM_LIMITTEXT            0x00C5
#define EM_CANUNDO              0x00C6
#define EM_UNDO                 0x00C7
#define EM_FMTLINES             0x00C8
#define EM_LINEFROMCHAR         0x00C9
#define EM_SETTABSTOPS          0x00CB
#define EM_SETPASSWORDCHAR      0x00CC
#define EM_EMPTYUNDOBUFFER      0x00CD
#define EM_GETFIRSTVISIBLELINE  0x00CE
#define EM_SETREADONLY          0x00CF
#define EM_SETWORDBREAKPROC     0x00D0
#define EM_GETWORDBREAKPROC     0x00D1
#define EM_GETPASSWORDCHAR      0x00D2
#if(WINVER >= 0x0400)
#define EM_SETMARGINS           0x00D3
#define EM_GETMARGINS           0x00D4
#define EM_SETLIMITTEXT         EM_LIMITTEXT   /* ;win40 Name change */
#define EM_GETLIMITTEXT         0x00D5
#define EM_POSFROMCHAR          0x00D6
#define EM_CHARFROMPOS          0x00D7
#endif /* WINVER >= 0x0400 */



/*
 * Button Control Styles
 */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT         0x00000020L
#if(WINVER >= 0x0400)
#define BS_TEXT             0x00000000L
#define BS_ICON             0x00000040L
#define BS_BITMAP           0x00000080L
#define BS_LEFT             0x00000100L
#define BS_RIGHT            0x00000200L
#define BS_CENTER           0x00000300L
#define BS_TOP              0x00000400L
#define BS_BOTTOM           0x00000800L
#define BS_VCENTER          0x00000C00L
#define BS_PUSHLIKE         0x00001000L
#define BS_MULTILINE        0x00002000L
#define BS_NOTIFY           0x00004000L
#define BS_FLAT             0x00008000L
#define BS_RIGHTBUTTON      BS_LEFTTEXT
#endif /* WINVER >= 0x0400 */


/*
 * User Button Notification Codes
 */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DOUBLECLICKED    5
#if(WINVER >= 0x0400)
#define BN_PUSHED           BN_HILITE
#define BN_UNPUSHED         BN_UNHILITE
#define BN_DBLCLK           BN_DOUBLECLICKED
#define BN_SETFOCUS         6
#define BN_KILLFOCUS        7
#endif /* WINVER >= 0x0400 */

/*
 * Button Control Messages
 */
#define BM_GETCHECK        0x00F0
#define BM_SETCHECK        0x00F1
#define BM_GETSTATE        0x00F2
#define BM_SETSTATE        0x00F3
#define BM_SETSTYLE        0x00F4
#if(WINVER >= 0x0400)
#define BM_CLICK           0x00F5
#define BM_GETIMAGE        0x00F6
#define BM_SETIMAGE        0x00F7

#define BST_UNCHECKED      0x0000
#define BST_CHECKED        0x0001
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008
#endif /* WINVER >= 0x0400 */

/*
 * Static Control Constants
 */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#if(WINVER >= 0x0400)
#define SS_OWNERDRAW        0x0000000DL
#define SS_BITMAP           0x0000000EL
#define SS_ENHMETAFILE      0x0000000FL
#define SS_ETCHEDHORZ       0x00000010L
#define SS_ETCHEDVERT       0x00000011L
#define SS_ETCHEDFRAME      0x00000012L
#define SS_TYPEMASK         0x0000001FL
#endif /* WINVER >= 0x0400 */
#define SS_NOPREFIX         0x00000080L /* Don't do "&" character translation */
#if(WINVER >= 0x0400)
#define SS_NOTIFY           0x00000100L
#define SS_CENTERIMAGE      0x00000200L
#define SS_RIGHTJUST        0x00000400L
#define SS_REALSIZEIMAGE    0x00000800L
#define SS_SUNKEN           0x00001000L
#define SS_ENDELLIPSIS      0x00004000L
#define SS_PATHELLIPSIS     0x00008000L
#define SS_WORDELLIPSIS     0x0000C000L
#define SS_ELLIPSISMASK     0x0000C000L
#endif /* WINVER >= 0x0400 */


/*
 * Dialog Styles
 */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L   /* Edit items get Local storage. */
#define DS_SETFONT          0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME       0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG        0x100L  /* WM_ENTERIDLE message will not be sent */
#define DS_SETFOREGROUND    0x200L  /* not in win3.1 */



#if(WINVER >= 0x0400)
#define DS_3DLOOK           0x0004L
#define DS_FIXEDSYS         0x0008L
#define DS_NOFAILCREATE     0x0010L
#define DS_CONTROL          0x0400L
#define DS_CENTER           0x0800L
#define DS_CENTERMOUSE      0x1000L
#define DS_CONTEXTHELP      0x2000L


#endif /* WINVER >= 0x0400 */


/*
 * Listbox Styles
 */
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#define LBS_DISABLENOSCROLL   0x1000L
#define LBS_NODATA            0x2000L
#if(WINVER >= 0x0400)
#define LBS_NOSEL             0x4000L
#endif /* WINVER >= 0x0400 */
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)


/*
 * Combo Box styles
 */
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#define CBS_DISABLENOSCROLL   0x0800L
#if(WINVER >= 0x0400)
#define CBS_UPPERCASE           0x2000L
#define CBS_LOWERCASE           0x4000L
#endif /* WINVER >= 0x0400 */


/*
 * Scroll Bar Styles
 */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L
#if(WINVER >= 0x0400)
#define SBS_SIZEGRIP                0x0010L
#endif /* WINVER >= 0x0400 */


/*
 * Commands to pass to WinHelp()
 */
#define HELP_CONTEXT      0x0001L  /* Display topic in ulTopic */
#define HELP_QUIT         0x0002L  /* Terminate help */
#define HELP_INDEX        0x0003L  /* Display index */
#define HELP_CONTENTS     0x0003L
#define HELP_HELPONHELP   0x0004L  /* Display help on using help */
#define HELP_SETINDEX     0x0005L  /* Set current Index for multi index help */
#define HELP_SETCONTENTS  0x0005L
#define HELP_CONTEXTPOPUP 0x0008L
#define HELP_FORCEFILE    0x0009L
#define HELP_KEY          0x0101L  /* Display topic for keyword in offabData */
#define HELP_COMMAND      0x0102L
#define HELP_PARTIALKEY   0x0105L
#define HELP_MULTIKEY     0x0201L
#define HELP_SETWINPOS    0x0203L
#if(WINVER >= 0x0400)
#define HELP_CONTEXTMENU  0x000a
#define HELP_FINDER       0x000b
#define HELP_WM_HELP      0x000c
#define HELP_SETPOPUP_POS 0x000d

#define HELP_TCARD              0x8000
#define HELP_TCARD_DATA         0x0010
#define HELP_TCARD_OTHER_CALLER 0x0011

// These are in winhelp.h in Win95.
#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445

#endif /* WINVER >= 0x0400 */







#define HDS_HORZ                0x00000000
#define HDS_BUTTONS             0x00000002
#define HDS_HIDDEN              0x00000008


#define TTS_ALWAYSTIP           0x01
#define TTS_NOPREFIX            0x02


#define SBARS_SIZEGRIP          0x0100


#define TBS_AUTOTICKS           0x0001
#define TBS_VERT                0x0002
#define TBS_HORZ                0x0000
#define TBS_TOP                 0x0004
#define TBS_BOTTOM              0x0000
#define TBS_LEFT                0x0004
#define TBS_RIGHT               0x0000
#define TBS_BOTH                0x0008
#define TBS_NOTICKS             0x0010
#define TBS_ENABLESELRANGE      0x0020
#define TBS_FIXEDLENGTH         0x0040
#define TBS_NOTHUMB             0x0080


#define UDS_WRAP                0x0001
#define UDS_SETBUDDYINT         0x0002
#define UDS_ALIGNRIGHT          0x0004
#define UDS_ALIGNLEFT           0x0008
#define UDS_AUTOBUDDY           0x0010
#define UDS_ARROWKEYS           0x0020
#define UDS_HORZ                0x0040
#define UDS_NOTHOUSANDS         0x0080


//====== COMMON CONTROL STYLES ================================================

#define CCS_TOP                 0x00000001L
#define CCS_NOMOVEY             0x00000002L
#define CCS_BOTTOM              0x00000003L
#define CCS_NORESIZE            0x00000004L
#define CCS_NOPARENTALIGN       0x00000008L
#define CCS_ADJUSTABLE          0x00000020L
#define CCS_NODIVIDER           0x00000040L


#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVS_TYPEMASK            0x0003
#define LVS_SINGLESEL           0x0004
#define LVS_SHOWSELALWAYS       0x0008
#define LVS_SORTASCENDING       0x0010
#define LVS_SORTDESCENDING      0x0020
#define LVS_SHAREIMAGELISTS     0x0040
#define LVS_NOLABELWRAP         0x0080
#define LVS_AUTOARRANGE         0x0100
#define LVS_EDITLABELS          0x0200
#define LVS_OWNERDATA           0x1000
#define LVS_NOSCROLL            0x2000

#define LVS_TYPESTYLEMASK       0xfc00

#define LVS_ALIGNTOP            0x0000
#define LVS_ALIGNLEFT           0x0800
#define LVS_ALIGNMASK           0x0c00

#define LVS_OWNERDRAWFIXED      0x0400
#define LVS_NOCOLUMNHEADER      0x4000
#define LVS_NOSORTHEADER        0x8000


#define TVS_HASBUTTONS          0x0001
#define TVS_HASLINES            0x0002
#define TVS_LINESATROOT         0x0004
#define TVS_EDITLABELS          0x0008
#define TVS_DISABLEDRAGDROP     0x0010
#define TVS_SHOWSELALWAYS       0x0020


#define TCS_FORCEICONLEFT       0x0010
#define TCS_FORCELABELLEFT      0x0020
#define TCS_TABS                0x0000
#define TCS_BUTTONS             0x0100
#define TCS_SINGLELINE          0x0000
#define TCS_MULTILINE           0x0200
#define TCS_RIGHTJUSTIFY        0x0000
#define TCS_FIXEDWIDTH          0x0400
#define TCS_RAGGEDRIGHT         0x0800
#define TCS_FOCUSONBUTTONDOWN   0x1000
#define TCS_OWNERDRAWFIXED      0x2000
#define TCS_TOOLTIPS            0x4000
#define TCS_FOCUSNEVER          0x8000


#define ACS_CENTER              0x0001
#define ACS_TRANSPARENT         0x0002
#define ACS_AUTOPLAY            0x0004









#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	        (WM_DDE_FIRST+4)
#define WM_DDE_DATA	        (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	        (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	        (WM_DDE_FIRST+8)





#ifdef  UNICODE                     
#define __TEXT(quote) L##quote      
#else   /* UNICODE */               
#define __TEXT(quote) quote         
#endif /* UNICODE */                
#define TEXT(quote) __TEXT(quote)   

//
//  Language IDs.
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//

//
//  Primary language IDs.
//

#define LANG_NEUTRAL                     0x00

#define LANG_AFRIKAANS                   0x36
#define LANG_ALBANIAN                    0x1c
#define LANG_ARABIC                      0x01
#define LANG_BASQUE                      0x2d
#define LANG_BELARUSIAN                  0x23
#define LANG_BULGARIAN                   0x02
#define LANG_CATALAN                     0x03
#define LANG_CHINESE                     0x04
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_ESTONIAN                    0x25
#define LANG_FAEROESE                    0x38
#define LANG_FARSI                       0x29
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HEBREW                      0x0d
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_INDONESIAN                  0x21
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_LATVIAN                     0x26
#define LANG_LITHUANIAN                  0x27
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SERBIAN                     0x1a
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_THAI                        0x1e
#define LANG_TURKISH                     0x1f
#define LANG_UKRAINIAN                   0x22
#define LANG_VIETNAMESE                  0x2a

//
//  Sublanguage IDs.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//

#define SUBLANG_NEUTRAL                  0x00    // language neutral
#define SUBLANG_DEFAULT                  0x01    // user default
#define SUBLANG_SYS_DEFAULT              0x02    // system default

#define SUBLANG_ARABIC_SAUDI_ARABIA      0x01    // Arabic (Saudi Arabia)
#define SUBLANG_ARABIC_IRAQ              0x02    // Arabic (Iraq)
#define SUBLANG_ARABIC_EGYPT             0x03    // Arabic (Egypt)
#define SUBLANG_ARABIC_LIBYA             0x04    // Arabic (Libya)
#define SUBLANG_ARABIC_ALGERIA           0x05    // Arabic (Algeria)
#define SUBLANG_ARABIC_MOROCCO           0x06    // Arabic (Morocco)
#define SUBLANG_ARABIC_TUNISIA           0x07    // Arabic (Tunisia)
#define SUBLANG_ARABIC_OMAN              0x08    // Arabic (Oman)
#define SUBLANG_ARABIC_YEMEN             0x09    // Arabic (Yemen)
#define SUBLANG_ARABIC_SYRIA             0x0a    // Arabic (Syria)
#define SUBLANG_ARABIC_JORDAN            0x0b    // Arabic (Jordan)
#define SUBLANG_ARABIC_LEBANON           0x0c    // Arabic (Lebanon)
#define SUBLANG_ARABIC_KUWAIT            0x0d    // Arabic (Kuwait)
#define SUBLANG_ARABIC_UAE               0x0e    // Arabic (U.A.E)
#define SUBLANG_ARABIC_BAHRAIN           0x0f    // Arabic (Bahrain)
#define SUBLANG_ARABIC_QATAR             0x10    // Arabic (Qatar)
#define SUBLANG_CHINESE_TRADITIONAL      0x01    // Chinese (Taiwan)
#define SUBLANG_CHINESE_SIMPLIFIED       0x02    // Chinese (PR China)
#define SUBLANG_CHINESE_HONGKONG         0x03    // Chinese (Hong Kong SAR)
#define SUBLANG_CHINESE_SINGAPORE        0x04    // Chinese (Singapore)
#define SUBLANG_DUTCH                    0x01    // Dutch
#define SUBLANG_DUTCH_BELGIAN            0x02    // Dutch (Belgian)
#define SUBLANG_ENGLISH_US               0x01    // English (USA)
#define SUBLANG_ENGLISH_UK               0x02    // English (UK)
#define SUBLANG_ENGLISH_AUS              0x03    // English (Australian)
#define SUBLANG_ENGLISH_CAN              0x04    // English (Canadian)
#define SUBLANG_ENGLISH_NZ               0x05    // English (New Zealand)
#define SUBLANG_ENGLISH_EIRE             0x06    // English (Irish)
#define SUBLANG_ENGLISH_SOUTH_AFRICA     0x07    // English (South Africa)
#define SUBLANG_ENGLISH_JAMAICA          0x08    // English (Jamaica)
#define SUBLANG_ENGLISH_CARIBBEAN        0x09    // English (Caribbean)
#define SUBLANG_ENGLISH_BELIZE           0x0a    // English (Belize)
#define SUBLANG_ENGLISH_TRINIDAD         0x0b    // English (Trinidad)
#define SUBLANG_FRENCH                   0x01    // French
#define SUBLANG_FRENCH_BELGIAN           0x02    // French (Belgian)
#define SUBLANG_FRENCH_CANADIAN          0x03    // French (Canadian)
#define SUBLANG_FRENCH_SWISS             0x04    // French (Swiss)
#define SUBLANG_FRENCH_LUXEMBOURG        0x05    // French (Luxembourg)
#define SUBLANG_GERMAN                   0x01    // German
#define SUBLANG_GERMAN_SWISS             0x02    // German (Swiss)
#define SUBLANG_GERMAN_AUSTRIAN          0x03    // German (Austrian)
#define SUBLANG_GERMAN_LUXEMBOURG        0x04    // German (Luxembourg)
#define SUBLANG_GERMAN_LIECHTENSTEIN     0x05    // German (Liechtenstein)
#define SUBLANG_ITALIAN                  0x01    // Italian
#define SUBLANG_ITALIAN_SWISS            0x02    // Italian (Swiss)
#define SUBLANG_KOREAN                   0x01    // Korean (Extended Wansung)
#define SUBLANG_KOREAN_JOHAB             0x02    // Korean (Johab)
#define SUBLANG_NORWEGIAN_BOKMAL         0x01    // Norwegian (Bokmal)
#define SUBLANG_NORWEGIAN_NYNORSK        0x02    // Norwegian (Nynorsk)
#define SUBLANG_PORTUGUESE               0x02    // Portuguese
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01    // Portuguese (Brazilian)
#define SUBLANG_SERBIAN_LATIN            0x02    // Serbian (Latin)
#define SUBLANG_SERBIAN_CYRILLIC         0x03    // Serbian (Cyrillic)
#define SUBLANG_SPANISH                  0x01    // Spanish (Castilian)
#define SUBLANG_SPANISH_MEXICAN          0x02    // Spanish (Mexican)
#define SUBLANG_SPANISH_MODERN           0x03    // Spanish (Modern)
#define SUBLANG_SPANISH_GUATEMALA        0x04    // Spanish (Guatemala)
#define SUBLANG_SPANISH_COSTA_RICA       0x05    // Spanish (Costa Rica)
#define SUBLANG_SPANISH_PANAMA           0x06    // Spanish (Panama)
#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC 0x07  // Spanish (Dominican Republic)
#define SUBLANG_SPANISH_VENEZUELA        0x08    // Spanish (Venezuela)
#define SUBLANG_SPANISH_COLOMBIA         0x09    // Spanish (Colombia)
#define SUBLANG_SPANISH_PERU             0x0a    // Spanish (Peru)
#define SUBLANG_SPANISH_ARGENTINA        0x0b    // Spanish (Argentina)
#define SUBLANG_SPANISH_ECUADOR          0x0c    // Spanish (Ecuador)
#define SUBLANG_SPANISH_CHILE            0x0d    // Spanish (Chile)
#define SUBLANG_SPANISH_URUGUAY          0x0e    // Spanish (Uruguay)
#define SUBLANG_SPANISH_PARAGUAY         0x0f    // Spanish (Paraguay)
#define SUBLANG_SPANISH_BOLIVIA          0x10    // Spanish (Bolivia)
#define SUBLANG_SPANISH_EL_SALVADOR      0x11    // Spanish (El Salvador)
#define SUBLANG_SPANISH_HONDURAS         0x12    // Spanish (Honduras)
#define SUBLANG_SPANISH_NICARAGUA        0x13    // Spanish (Nicaragua)
#define SUBLANG_SPANISH_PUERTO_RICO      0x14    // Spanish (Puerto Rico)
#define SUBLANG_SWEDISH                  0x01    // Swedish
#define SUBLANG_SWEDISH_FINLAND          0x02    // Swedish (Finland)

//
//  Sorting IDs.
//

#define SORT_DEFAULT                     0x0     // sorting default

#define SORT_JAPANESE_XJIS               0x0     // Japanese XJIS order
#define SORT_JAPANESE_UNICODE            0x1     // Japanese Unicode order

#define SORT_CHINESE_BIG5                0x0     // Chinese BIG5 order
#define SORT_CHINESE_PRCP                0x0     // PRC Chinese Phonetic order
#define SORT_CHINESE_UNICODE             0x1     // Chinese Unicode order
#define SORT_CHINESE_PRC                 0x2     // PRC Chinese Stroke Count order

#define SORT_KOREAN_KSC                  0x0     // Korean KSC order
#define SORT_KOREAN_UNICODE              0x1     // Korean Unicode order

#define SORT_GERMAN_PHONE_BOOK           0x1     // German Phone Book order

#ifndef UNDER_CE
#include <dlgs.h>
#include <winver.h>
#endif

#endif /* _WINRESRC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_cfpf.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _CFPF.H	-- RichEdit CCharFormat and CParaFormat Classes |
 *
 *	These classes are derived from the RichEdit 1.0 CHARFORMAT and PARAFORMAT
 *	structures and are the RichEdit 2.0 internal versions of these structures.
 *	Member functions (like Copy()) that use external (API) CHARFORMATs and
 *	PARAFORMATs need to check the <p cbSize> value to see what members are
 *	defined.  Default values that yield RichEdit 1.0 behavior should be stored
 *	for RichEdit 1.0 format structures, e.g., so that the renderer doesn't do
 *	anomalous things with random RichEdit 2.0 format values.  Generally the
 *	appropriate default value is 0.
 *
 *	All character and paragraph format measurements are in twips.  Undefined
 *	mask and effect bits are reserved and must be 0 to be compatible with
 *	future versions.
 *
 *	Effects that appear with an asterisk (*) are stored, but won't be
 *	displayed by RichEdit 2.0.  They are place holders for TOM and/or Word
 *	compatibility.
 *
 *	Note: these structures are much bigger than they need to be for internal
 *	use especially if we use SHORTs instead of LONGs for dimensions and
 *	the tab and font info are accessed via ptrs.  Nevertheless, in view of our
 *	tight delivery schedule, RichEdit 2.0 uses the classes below.
 *
 *	History:
 *		9/1995	-- MurrayS: Created
 *		11/1995 -- MurrayS: Extended to full Word97 FormatFont/Format/Para
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _CFPF_H
#define _CFPF_H

#define	TABS

SHORT	Get16BitTwips(LONG dy);
LONG	GetUsableFontHeight(LONG ySrcHeight, LONG lPointChange);
BOOL	IsValidCharFormatW(const CHARFORMATW *	pCF);
BOOL	IsValidCharFormatA(const CHARFORMATA *	pCFA);
BOOL	IsValidParaFormat (const PARAFORMAT *	pPF);

// CParaFormat Style enums and defines (maybe move to richedit.h?)
enum STYLES
{
	STYLE_NORMAL	= -1,
	STYLE_HEADING_1	= -2,
	STYLE_HEADING_9	= -10
};

#define	NHSTYLES				9			// # of heading styles
#define	STYLE_COMMAND			0x8000
#define TWIPS_PER_POINT			20

#define IsHeadingStyle(Style)	(Style <= STYLE_HEADING_1 && \
								 Style >= STYLE_HEADING_9)
#define IsKnownStyle(Style)		(IsHeadingStyle(Style) || Style == STYLE_NORMAL)
#define IsStyleCommand(Style)	((Style & 0xFF00) == STYLE_COMMAND)

#define CCHMAXNUMTOSTR			20			// Enuf for billions + parens + null term

typedef struct _styleformat
{
	BYTE	bEffects;
	BYTE	bHeight;
} STYLEFORMAT;

/*
 *	Tab Structure Template
 *
 *	To help keep the size of the tab array small, we use the two high nibbles
 *	of the tab LONG entries in rgxTabs[] to give the tab type and tab leader
 *	(style) values.  The measurer and renderer need to ignore (or implement)
 *	these nibbles.  We also need to be sure that the compiler does something
 *	rational with this idea...
 */

typedef struct tagTab
{
	DWORD	tbPos		: 24;	// 24-bit unsigned tab displacement
	DWORD	tbAlign		: 4;	// 4-bit tab type  (see enum PFTABTYPE)
	DWORD	tbLeader	: 4;	// 4-bit tab style (see enum PFTABSTYLE)
} TABTEMPLATE;

enum PFTABTYPE					// Same as tomAlignLeft, tomAlignCenter,
{								//  tomAlignRight, tomAlignDecimal, tomAlignBar
	PFT_LEFT = 0,				// ordinary tab
	PFT_CENTER,					// center tab
	PFT_RIGHT,					// right-justified tab
	PFT_DECIMAL,				// decimal tab
	PFT_BAR						// Word bar tab (vertical bar)
};

enum PFTABSTYLE					// Same as tomSpaces, tomDots, tomDashes,
{								//  tomLines
	PFTL_NONE = 0,				// no leader
	PFTL_DOTS,					// dotted
	PFTL_DASH,					// dashed
	PFTL_UNDERLINE,				// underlined
	PFTL_THICK,					// thick line
	PFTL_EQUAL					// double line
};

#define PFT_DEFAULT		0xff000000

typedef struct _cellparms
{
	LONG	uCell;				// Low 24 bits; high byte has flags
	DWORD	dxBrdrWidths;		// Widths of borders (left, top, right, bottom)
	DWORD	dwColors;			// Borders and background color
	BYTE	bShading;			// Shading in .5 per cent

	// Border widths and colors are packed in same low-to-high order as in
	// RECT, that is, left, top, right, bottom.
	LONG	GetBrdrWidthLeft() const	{return (dxBrdrWidths >> 0*8) & 0xFF;}
	LONG	GetBrdrWidthTop() const		{return (dxBrdrWidths >> 1*8) & 0xFF;}
	LONG	GetBrdrWidthRight() const	{return (dxBrdrWidths >> 2*8) & 0xFF;}
	LONG	GetBrdrWidthBottom() const	{return (dxBrdrWidths >> 3*8) & 0xFF;}
	void	SetBrdrWidthBottom(BYTE bBrdrWidth)
				{dxBrdrWidths = (dxBrdrWidths & 0x00FFFFFF) | (bBrdrWidth << 24);}

	LONG	GetColorIndexLeft() const		{return (dwColors >> 0*5) & 0x1F;}
	LONG	GetColorIndexTop() const		{return (dwColors >> 1*5) & 0x1F;}
	LONG	GetColorIndexRight() const		{return (dwColors >> 2*5) & 0x1F;}
	LONG	GetColorIndexBottom() const		{return (dwColors >> 3*5) & 0x1F;}
	LONG	GetColorIndexBackgound() const	{return (dwColors >> 4*5) & 0x1F;}
	LONG	GetColorIndexForegound() const	{return (dwColors >> 5*5) & 0x1F;}
	LONG	ICellFromUCell(LONG dul, LONG cCell) const;
} CELLPARMS;


// Effect flags beyond CHARFORMAT2. Go in high word of CCharFormat::_dwEffects
// which aren't used in CHARFORMAT2 (except for CFE_AUTOCOLOR: 0x40000000,
// CFE_AUTOBACKCOLOR: 0x04000000, CFE_SUBSCRIPT: 0x00010000, and
// CFE_SUPERSCRIPT: 0x00020000), since they overlap	with noneffect parms.
// Use corresponding high-word bits in dwMask2 to access.  Be careful not
// to define new effects that conflict with CFE_AUTOCOLOR, CFE_AUTOBACKCOLOR,
// CFE_SUBSCRIPT, or CFE_SUPERSCRIPT.

//		CFE_SUBSCRIPT		0x00010000			// Defined in richedit.h
//		CFE_SUPERSCRIPT		0x00020000			// Defined in richedit.h
#define CFM2_RUNISDBCS		0x00040000			// Says run is DBCS put 
#define CFE_RUNISDBCS		CFM2_RUNISDBCS		//  into Unicode buffer

#define CFM2_FACENAMEISDBCS	0x00080000			// Says szFaceName is DBCS 
#define CFE_FACENAMEISDBCS	CFM2_FACENAMEISDBCS	//  put into Unicode buffer

#define CFE_AVAILABLE		0x00100000			// Use me!!!

#define	CFM2_DELETED		0x00200000			// Says text was deleted
#define	CFE_DELETED			CFM2_DELETED		//  (roundtrips \deleted)

#define	CFM2_CUSTOMTEXTOUT	0x00400000			// Font has custom textout
#define	CFE_CUSTOMTEXTOUT	CFM2_CUSTOMTEXTOUT	// handling

#define	CFM2_LINKPROTECTED	0x00800000			// Word hyperlink field
#define	CFE_LINKPROTECTED	CFM2_LINKPROTECTED	// Don't let urlsup.cpp touch!

//		CFE_AUTOBACKCOLOR	0x04000000			// Defined in richedit.h
//		CFE_AUTOCOLOR		0x40000000			// Defined in richedit.h

#define CFM2_CHARFORMAT		0x00008000			// Noneffect mask flags
#define CFM2_USABLEFONT 	0x00004000			// EM_SETFONTSIZE functionality
#define CFM2_SCRIPT			0x00002000			// Uniscribe's script ID
#define	CFM2_NOCHARSETCHECK	0x00001000			// Suppress CharSet check
#define CFM2_HOLDITEMIZE	0x00000800			// Hold off Itemization
#define CFM2_ADJUSTFONTSIZE	0x00000400			// Font size adjustment (SAMECHARSET case only)
#define CFM2_UIFONT			0x00000200			// UI Font (SAMECHARSET case only)
#define CFM2_MATCHFONT		0x00000100			// Match font to charset
#define CFM2_USETMPDISPATTR	0x00000080			// Use Temp display attribute

/*
 *	CCharFormat
 *
 *	@class
 *		Collects character format methods along with data members
 *		corresponding to CHARFORMAT2.  Only 10 DWORDs are used, whereas
 *		CHARFORMAT2 has 30.  Some bits in the high word of _dwEffects
 *		are used for additional effects, since only CFE_AUTOCOLOR,
 *		CFE_AUTOBACKCOLOR, CFE_SUBSCRIPT, and CFE_SUPERSCRIPT are used
 *		by CHARFORMAT2 (the associated mask bits for the others are used
 *		for noneffect parameters, such as yHeight).
 *
 *	@devnote
 *		Could add extra data for round tripping more RTF info. This data
 *		wouldn't be exposed at the API level (other than via RTF).
 *		The order below is optimized for transfer to CHARFORMAT and for
 *		early out on font lookup, i.e., the most common 2 DWORDs are the
 *		first 2.
 */

class CCharFormat
{
public:

#ifdef DEBUG
	const WCHAR *_pchFaceName;		// Facename given by _iFont
#endif

	DWORD		_dwEffects;			// CFE_xxx effects
	BYTE		_iCharRep;			// Character Repertoire
	BYTE		_bPitchAndFamily;	// Pitch and Family
	SHORT		_iFont;				// Index into FONTNAME table
	SHORT		_yHeight;			// Font height
	SHORT		_yOffset;			// Vertical offset from baseline
	COLORREF	_crTextColor;		// Foreground color

	WORD		_wWeight;			// Font weight (LOGFONT value)
	SHORT		_sSpacing;			// Amount to space between letters
	COLORREF	_crBackColor;		// Background color
	LCID		_lcid;				// Locale ID
	SHORT		_sStyle;			// Style handle
	WORD		_wKerning;			// Twip size above which to kern char pair
	BYTE		_bUnderlineType;	// Underline type
	BYTE		_bAnimation;		// Animated text like marching ants 
	BYTE		_bRevAuthor;		// Revision author index
	BYTE		_bUnderlineColor;	// Used only by IME/UIM
	WORD		_wScript;			// Uniscribe's script ID
	BYTE		_iCharRepSave;		// Previous char repertoire for SYMBOL_CHARSET
	BYTE		_bQuality;			// Font quality (ClearType or whatever)

	SHORT		_sTmpDisplayAttrIdx; // Index to the temp. display attrib array

	CCharFormat() { _sTmpDisplayAttrIdx = -1; }
													//@cmember Apply *<p pCF>
	HRESULT	Apply (const CCharFormat *pCF,			//  to this CCharFormat
				   DWORD dwMask, DWORD dwMask2);
	void	ApplyDefaultStyle (LONG Style);

	BOOL	CanKern() const {return _wKerning && _yHeight >= _wKerning;}
	BOOL	CanKernWith(const CCharFormat *pCF) const;

	BOOL	Compare	(const CCharFormat *pCF) const;	//@cmember Compare this CF
													//  to *<p pCF>
	DWORD	Delta (CCharFormat *pCF,				//@cmember Get difference
				   BOOL fCHARFORMAT) const;			//  mask between this and
													//  *<p pCF>
	BOOL	fSetStyle(DWORD dwMask, DWORD dwMask2) const;
	void	Get (CHARFORMAT2 *pCF, UINT CodePage) const;//@cmember Copies this to
													//	CHARFORMAT pCF
	HRESULT	InitDefault (HFONT hfont);				//@cmember Initialize using
													//  font info from <p hfont>
	void	Set(const CHARFORMAT2 *pCF, UINT CodePage);//@cmember Copy *<p pCF> 
													//  to this CF
};

// dwMask2 bits
#define PFM2_PARAFORMAT			0x80000000			// Only PARAFORMAT parms used
#define PFM2_ALLOWTRDCHANGE		0x40000000			// Allow TRD changes
#define PFM2_TABLEROWSHIFTED	0x00008000			// Allow only TRD changes

#define PFE_TABLEROWSHIFTED		PFM2_TABLEROWSHIFTED

/*
 *	CParaFormat
 *
 *	@class
 *		Collects related paragraph formatting methods and data
 *
 *	@devnote
 *		Could add extra data for round tripping more RTF and TOM info
 */
class CParaFormat
{
public:
	WORD	_wNumbering;
	WORD	_wEffects;
	LONG	_dxStartIndent;
	LONG	_dxRightIndent;
	LONG	_dxOffset;
	BYTE	_bAlignment;
	BYTE	_bTabCount;
	SHORT	_iTabs;					// Tabs index in CTabs cache
 	LONG	_dySpaceBefore;			// Vertical spacing before para
	LONG	_dySpaceAfter;			// Vertical spacing after para
	LONG	_dyLineSpacing;			// Line spacing depending on Rule	
	SHORT	_sStyle;				// Style handle						
	BYTE	_bLineSpacingRule;		// Rule for line spacing (see tom.doc)
	BYTE	_bOutlineLevel;			// Outline Level
	union
	{
	  struct
	  {
		WORD	_wShadingWeight;	// Shading in hundredths of a per cent
		WORD	_wShadingStyle;		// Byte 0: style, nib 2: cfpat, 3: cbpat
		WORD	_wNumberingStart;	// Starting value for numbering		
		WORD	_wNumberingStyle;	// Alignment, Roman/Arabic, (), ), ., etc.
	  };
	  struct
	  {
		COLORREF _crCustom1;		// In table-row delimiters, this area has
		COLORREF _crCustom2;		//  custom colors instead of shading and
	  };							//  numbering
	};
	WORD	_wNumberingTab;			// Space bet 1st indent and 1st-line text
	WORD	_wBorderSpace;			// Border-text spaces (nbl/bdr in pts)
	WORD	_wBorderWidth;			// Pen widths (nbl/bdr in half twips)	
	WORD	_wBorders;				// Border styles (nibble/border)	
	DWORD	_dwBorderColor;			// Colors/attribs
	char	_bTableLevel;			// Table nesting level

	CParaFormat() {}
													//@cmember Add tab at
	HRESULT	AddTab (LONG tabPos, LONG tabType,		// position <p tabPos>
					LONG tabStyle, LONG *prgxTabs);
													//@cmember Apply *<p pPF> to
	HRESULT	Apply(const CParaFormat *pPF, DWORD dwMask, DWORD dwMask2);//  this PF
													
	void	ApplyDefaultStyle (LONG Style);
	HRESULT	DeleteTab(LONG tabPos, LONG *prgxTabs);	//@cmember Delete tab at
													//  <p tabPos>
	DWORD	Delta (CParaFormat *pPF,				//@cmember Set difference
				   BOOL fPARAFORMAT) const;			//  mask between this and
													//  *<p pPF>
	BOOL	fSetStyle(DWORD dwMask, DWORD dwMask2) const;
	void	Get (PARAFORMAT2 *pPF2) const;			//@cmember Copy this PF to
													//  *<p pPF>
	char	GetOutlineLevel(){return _bOutlineLevel;}
	LONG	GetRTLRowLength() const;				//@cmember Get RTL row length
													//@cmember Get tab position
	HRESULT	GetTab (long iTab, long *pdxptab,		// type, and style
					long *ptbt, long *pstyle,
					const LONG *prgxTabs) const;
	
	const LONG *GetTabs () const;					//@cmember Get ptr to tab array
	const CELLPARMS *GetCellParms () const			//@cmember Get ptr to cell array
			{return (const CELLPARMS *)GetTabs();}
	BOOL	HandleStyle(LONG Mode);					//@cmember Handle sStyle
													//@cmember Initialize this
	HRESULT	InitDefault (WORD wDefEffects);			//  PF to default values

	BOOL	IsRtlPara() const
				{return (_wEffects & (PFE_RTLPARA | PFE_TABLEROWDELIMITER)) == PFE_RTLPARA;}
	BOOL	IsRtl() const			{return _wEffects & PFE_RTLPARA;}
	BOOL	InTable() const			{return (_wEffects & PFE_TABLE) != 0;}
	BOOL	IsTableRowDelimiter() const	{return (_wEffects & PFE_TABLEROWDELIMITER) != 0;}
	BOOL	IsListNumbered() const	{return IN_RANGE(tomListNumberAsArabic,
												 _wNumbering,
												 tomListNumberAsSequence);}
	BOOL	IsNumberSuppressed() const
					{return (_wNumberingStyle & 0xF00) == PFNS_NONUMBER;}

	LONG	NumToStr(TCHAR *pch, LONG n, DWORD grf = 0) const;
													//@cmember Copy *<p pPF>
	void	Set (const PARAFORMAT2 *pPF2);			//  to this PF
	LONG	UpdateNumber (LONG n, const CParaFormat *pPF) const;

#ifdef DEBUG

	void	ValidateTabs();

#endif // DEBUG
};													 

#define fRtfWrite	 0x1
#define fIndicDigits 0x2

#define	GetTabPos(tab)		((tab) & 0xFFFFFF)
#define	GetTabAlign(tab)	(((tab) >> 24) & 0xF)
#define	GetTabLdr(tab)		((tab) >> 28)

#define fTopCell		0x04000000
#define fLowCell		0x08000000
#define fVerticalCell	0x10000000

#define	GetCellWidth(x)	((x) & 0xFFFFFF)
#define IsTopCell(x)	(((x) & fTopCell) != 0)
#define IsLowCell(x)	((x) & fLowCell)
#define IsVertMergedCell(x)	((x) & (fTopCell | fLowCell))
#define IsVerticalCell(x)	((x) & fVerticalCell)
#define GetCellVertAlign(x)	((x) & 0x03000000)
#define IsCellVertAlignCenter(x) ((x) & 0x01000000)

#define CELL_EXTRA	(sizeof(CELLPARMS)/sizeof(LONG) - 1)

/*
 *	CTabs
 *
 *	@class
 *		CFixArray element for tab and cell arrays
 */
class CTabs
{
public:
	LONG  _cTab;				// Count of tabs (or total LONGs in cells)
	LONG *_prgxTabs;			// Ptr to tab array
};

#endif

/*	Table Storage Layout:
 *
 *	Tables are stored using paragraphs with special characteristics. 
 *	Each table row starts with a two-character paragraph consisting of
 *	a STARTFIELD character followed by a CR.  The associated CParaFormat
 *	has the PFE_TABLEROWDELIMITER bit of _wEffects set to 1.  The CParaFormat
 *	properties identify the row properties: alignment, StartIndent, line
 *	spacing, line spacing rule, PFE_KEEP and PFE_RTLPARA bits, and border
 *	info, which all work the same way for the row that they work for an
 *	ordinary paragraph.  The offset	field gives the half-gap space between
 *	cells in the row. The CTabArray for the paragraph gives the cell widths
 *	and other info, such as vertical cell merge.
 *
 *	Cells in the row are delimited by CELL, which can have a CParaFormat like
 *	a CR, so that properties like alignment can be attached to a cell without
 *	having an explicit CR.  CRs are allowed in cells and the text may wrap
 *	in the cell.
 *
 *	The table row ends with a two-character paragraph consisting of
 *	a ENDFIELD character followed by a CR.  The associated CParaFormat is
 *	the same as the corresponding table row start paragraph.
 *
 *	Tables can be nested.  The _bTableLevel gives the nesting level: 1 for
 *	the outermost table, 2 for the next to outermost table, etc.
 */


BOOL IsValidTwip(LONG dl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_clasfyc.h ===
/*
 *	@doc
 *
 *	@module _clasfyc.H -- character classification |
 *	
 *	Authors: <nl>
 *		Jon Matousek 
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#ifndef _CLASFYC_H
#define _CLASFYC_H

extern const INT g_cKinsokuCategories;

void BatchClassify(const WCHAR *ch, INT cch, LCID lcid, WORD *pcType3,
				   INT *kinsokuClassifications, WORD *pwRes);
BOOL CanBreak(INT class1, INT class2);
WORD ClassifyChar(WCHAR ch, LCID lcid);
INT	 GetKinsokuClass(WCHAR ch, WORD cType3 = 0xFFFF, LCID lcid = 0);
BOOL InitKinsokuClassify();
BOOL IsSameClass(WORD currType1, WORD startType1,
				 WORD currType3, WORD startType3);
BOOL IsURLDelimiter(WCHAR ch);
void UninitKinsokuClassify();

#define MAX_CLASSIFY_CHARS (256L)

#define	brkclsQuote			0
#define	brkclsOpen			1
#define	brkclsClose			2
#define	brkclsGlueA			3
#define	brkclsExclaInterr	4
#define	brkclsSlash			6
#define	brkclsInseparable	7
#define	brkclsPrefix		8
#define	brkclsPostfix		9
#define	brkclsNoStartIdeo	10
#define	brkclsIdeographic	11
#define	brkclsNumeral		12
#define	brkclsSpaceN		14
#define	brkclsAlpha			15

// Korean Unicode ranges
#define IsKoreanJamo(ch)	IN_RANGE(0x1100, ch, 0x11FF)
#define IsKorean(ch)		IN_RANGE(0xAC00, ch, 0xD7FF)

// Thai Unicode range
#define IsThai(ch)			IN_RANGE(0x0E00, ch, 0x0E7F)

// -FUTURE- This should be moved to richedit.h
#define WBF_KOREAN			0x0080
#define WBF_WORDBREAKAFTER	0x0400		// Break word after this character (for language such as Thai)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_array.h ===
/*	@doc INTERNAL
 *
 *	@module _ARRAY.H  Generic Array Class |
 *	
 *	This module declares a generic array class for constant sized
 *	elements (although the elements themselves may be of any size).
 *
 *	Original Author: <nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95	alexgo	Cleanup and Commenting
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _ARRAY_H
#define _ARRAY_H

class CFormatRunPtr;

/*
 *	ArrayFlag
 *
 *	@enum	Defines flags used with the array class
 */
enum tagArrayFlag
{
	AF_KEEPMEM		= 1,	//@emem Don't delete any memory 
	AF_DELETEMEM	= 2,	//@emem Delete as much memory as possible
};

//@type ArrayFlag | flags controlling the usage of generic arrays 
//(and specifically how memory is handled)
typedef enum tagArrayFlag ArrayFlag;


/*
 *	CArrayBase
 *	
 * 	@class	The CArrayBase class implements a generic array class.  It should
 *	never be used directly; use the type-safe template, <c CArray>, instead.
 *
 *	@devnote There are exactly two legal states for an array: empty or not.
 *	If an array is empty, the following must be true:
 *
 *		<md CArrayBase::_prgel> == NULL; <nl>
 *		<md CArrayBase::_cel> == 0; <nl>
 *		<md CArrayBase::_celMax> == 0;
 *
 *	Otherwise, the following must be true:
 *
 *		<md CArrayBase::_prgel> != NULL; <nl>
 *		<md CArrayBase::_cel> <lt>= <md CArrayBase::_celMax>; <nl>
 *		<md CArrayBase::_celMax> <gt> 0;
 *
 *	
 *	An array starts empty, transitions to not-empty as elements are inserted
 *  and will transistion back to empty if all of the array elements are 
 *	removed.
 *
 */
class CArrayBase
{
//@access Public Methods
public:

#ifdef DEBUG
	BOOL	Invariant() const;		//@cmember Validates state consistentency
	void*	Elem(LONG iel) const;	//@cmember Get ptr to <p iel>'th run
#else
	void*	Elem(LONG iel) const {return _prgel + iel*_cbElem;}
#endif
	
	CArrayBase (LONG cbElem);		//@cmember Constructor
	~CArrayBase () {Clear(AF_DELETEMEM);}

	//@cmember Copy array into passed in array and initialize this array
	void	TransferTo(CArrayBase &ar);
	void 	Clear (ArrayFlag flag);	//@cmember Delete all runs in array
	LONG 	Count() const {return _cel;}//@cmember Get count of runs in array
									//@cmember Remove <p celFree> runs from
									// array, starting at run <p ielFirst>
	void 	Remove(LONG ielFirst, LONG celFree);
									//@cmember Replace runs <p iel> through
									// <p iel+cel-1> with runs from <p par>
	BOOL	Replace (LONG iel, LONG cel, CArrayBase *par);
	
	LONG 	Size() const {return _cbElem;}//@cmember Get size of a run			

//@access Protected Methods
protected:
	void* 	ArAdd (LONG cel, LONG *pielIns);	//@cmember Add <p cel> runs
	void* 	ArInsert(LONG iel, LONG celIns);	//@cmember Insert <p celIns>
												// runs

//@access Protected Data
protected:
	char*	_prgel;		//@cmember Pointer to actual array data
	LONG 	_cel;	  	//@cmember Count of used entries in array
	LONG	_celMax;	//@cmember Count of allocated entries in array
	LONG	_cbElem;	//@cmember Byte count of an individual array element
};

/*
 *	CArray
 *
 *	@class
 *		An inline template class providing type-safe access to CArrayBase
 *
 *	@tcarg class | ELEM | the class or struct to be used as array elements
 */

template <class ELEM> 
class CArray : public CArrayBase
{
//@access Public Methods
public:
	
	CArray ()								//@cmember Constructor
		: CArrayBase(sizeof(ELEM))
	{}
	
	ELEM *	Elem(LONG iel) const			//@cmember Get ptr to <p iel>'th
	{										// element
		return (ELEM *)CArrayBase::Elem(iel);
	}
	
	ELEM& 	GetAt(LONG iel) const			//@cmember Get <p iel>'th element
	{
		return *(ELEM *)CArrayBase::Elem(iel);
	}
	
	ELEM* 	Add (LONG cel, LONG *pielIns)	//@cmember Adds <p cel> elements						
	{										// to end of array
		return (ELEM*)ArAdd(cel, pielIns);
	}

	ELEM* 	Insert (LONG iel, LONG celIns)	//@cmember Insert <p celIns>
	{										// elements at index <p iel>
		return (ELEM*)ArInsert(iel, celIns);
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_devstk.h ===
/*
 *	_DEVSTK.H
 *	
 *	Purpose:
 *		CDevState - handle access to device descriptor
 *	
 *	Authors:
 *		Rick Sailor
 */

#ifndef _DEVSTK_H_
#define _DEVSTK_H_


class CTxtEdit;
class CDrawInfo;

// device descriptor
class CDevState
{
public:
						CDevState(CTxtEdit * ped);

						~CDevState();

    					BOOL    IsValid() const;

						BOOL 	IsMetafile() const;

						BOOL	SetDrawInfo(
									DWORD dwDrawAspect,
									LONG lindex,
									const DVTARGETDEVICE *_ptd,
									HDC hdcDraw,
									HDC hicTargetDev);

						BOOL	SetDC(HDC hdc);

	void 				ResetDrawInfo();

	HDC					GetTargetDD();

	HDC	 				GetRenderDD();

	void				ReleaseDC();

	BOOL				SameDrawAndTargetDevice();

	LONG				ConvertXToTarget(LONG xPixels);

	LONG				ConvertXToDraw(LONG xPixels);

	LONG				ConvertYToDraw(LONG yPixels);

protected:

	CTxtEdit * 			_ped;        // used to GetDC and ReleaseDC

	CDrawInfo *			_pdd;

	HDC					_hicMainTarget;
	
};

#ifndef DEBUG
#include	<_devstki.h>
#endif // DEBUG


#endif // _DEVSTK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_cmsgflt.h ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	_CMSGFLT.H	CTextMsgFilter declaration |
 *
 *	Purpose:  CTextMsgFilter is used in handling IME as well as Cicero Input.
 *
 *	Author:	<nl>
 *		2/6/98  v-honwch
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

// Forward declarations

#ifndef NOPRIVATEMESSAGE
#include "_MSREMSG.H"
#endif

class CIme;			
class CUIM;
class CTextMsgFilter;
class CLangProfileSink;

// CheckIMEType dwFlags
#define CHECK_IME_SERVICE	0x0001

#ifndef __ITfThreadMgr_INTERFACE_DEFINED__	
class ITfThreadMgr;
#endif

class CLangProfileSink : public ITfLanguageProfileNotifySink
{
public:
	CLangProfileSink();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	//
	// ITfLanguageProfilesNotifySink
	//
	STDMETHODIMP OnLanguageChange(LANGID langid, BOOL *pfAccept);
	STDMETHODIMP OnLanguageChanged();

	HRESULT _Advise(CTextMsgFilter *, ITfInputProcessorProfiles *pipp);
	HRESULT _Unadvise();

private:

	long _cRef;
	CTextMsgFilter *_pTextMsgFilter;
	ITfInputProcessorProfiles *_pITFIPP;
	DWORD _dwCookie;
};

class CTextMsgFilter : public ITextMsgFilter
{
public :
	
	friend class CUIM;
	friend class CLangProfileSink;

	HRESULT STDMETHODCALLTYPE QueryInterface( 
		REFIID riid,
		void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE AttachDocument( HWND hwnd, ITextDocument2 *pTextDoc, IUnknown *punk);
	HRESULT STDMETHODCALLTYPE HandleMessage( 
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres);
	HRESULT STDMETHODCALLTYPE AttachMsgFilter( ITextMsgFilter *pMsgFilter);

	COMPCOLOR* GetIMECompAttributes();
	
	void	OnSetUIMMode(WORD wUIMModeBias); 
	LRESULT	OnGetUIMMode() { return _wUIMModeBias; };

	~CTextMsgFilter();

	BOOL	IsIMEComposition()	{ return (_ime != NULL);};
	BOOL	GetTxSelection();
	BOOL	NoIMEProcess();
	BOOL	MouseOperation(UINT msg, long ichStart, long cchComp, WPARAM wParam, WPARAM *pwParamBefore, 
		BOOL *pfTerminateIME, HWND hwndIME, long *pCpCursor=NULL, ITfMouseSink *pMouseSink=NULL);

	CIme	*_ime;					// non-NULL when IME composition active
	HWND	_hwnd;	
	UINT	_uKeyBoardCodePage;		// current keyboard codepage
	UINT	_uSystemCodePage;		// system codepage

	DWORD	_fIMECancelComplete		:1;		// If aborting IME, cancel comp string, else complete
	DWORD	_fUnicodeIME			:1;		// TRUE if Unicode IME
	DWORD	_fIMEAlwaysNotify		:1;		// Send Notification during IME undetermined string
	DWORD	_fHangulToHanja			:1;		// TRUE during Hangul to Hanja conversion
	DWORD	_fOvertypeMode			:1;		// TRUE if overtype mode is on. 
	DWORD	_fMSIME					:1;		// TRUE if MSIME98 or later
	DWORD	_fUsingAIMM				:1;		// TRUE if AIMM is activated
	DWORD	_fUnicodeWindow			:1;		// TRUE if Unicode Window
	DWORD	_fForceEnable			:1;		// TRUE if Force Enable on Focus
	DWORD	_fForceActivate			:1;		// TRUE if Force Activate on Focus
	DWORD	_fForceRemember			:1;		// TRUE if Force Remember
	DWORD	_fIMEEnable				:1;		// TRUE if IME was enable before
	DWORD	_fRE10Mode				:1;		// TRUE if running in RE1.0 Mode
	DWORD	_fUsingUIM				:1;		// TRUE if Cicero is activated
	DWORD	_fTurnOffUIM			:1;		// TRUE if Client doesn't want UIM
	DWORD	_fTurnOffAIMM			:1;		// TRUE if Client doesn't want AIIM
	DWORD	_nIMEMode				:2;		// 1 = IME_SMODE_PLAURALCLAUSE
											// 2 = IME_SMODE_NONE
	DWORD	_fNoIme					:1;		// TRUE if Client has turn off IME processing
	DWORD	_fRestoreOLDIME			:1;		// TRUE if _wOldIMESentence is setup before
	DWORD	_fSendTransaction		:1;		// TRUE if we need to send EndEditTransaction
	DWORD	_fReceivedKeyDown		:1;		// TRUE if we have received key down message
	DWORD	_fAllowEmbedded			:1;		// TRUE if we allow Cicero insert embedded
	DWORD	_fAllowSmartTag			:1;		// TRUE if we allow Cicero SmartTag tips
	DWORD	_fAllowProofing			:1;		// TRUE if we allow Cicero Proofing tips

	WORD	_wOldIMESentence;				// for IME_SMODE_PHRASEPREDICT use
	WORD	_wUIMModeBias;					// for UIM Mode bias

	// Support for SETIMEOPTIONS:
	DWORD	_fIMEConversion;				// for Force Remember use
	DWORD	_fIMESentence;					// for Force Remember use
	HKL		_fIMEHKL;						// for Force Remember use

	long	_cpReconvertStart;				// use during reconversion
	long	_cpReconvertEnd;				// use during reconversion
	long	_lFEFlags;						// For FE setting (ES_NOIME, ES_SELFIME)	

	COMPCOLOR*			_pcrComp;			// Support 1.0 mode composition color
	ITextDocument2		*_pTextDoc;	
	ITextServices		*_pTextService;
	ITextSelection		*_pTextSel;	
	ITfThreadMgr		*_pTim;
	CUIM				*_pCUIM;
	TfClientId			_tid;
#ifndef NOPRIVATEMESSAGE
	CMsgCallBack		*_pMsgCallBack;
#endif

	ITfInputProcessorProfiles	*_pITfIPP;
	CLangProfileSink	*_pCLangProfileSink;

private:
	ULONG				_crefs;

	ITextMsgFilter *	_pFilter;

	HIMC				_hIMCContext;

	// private methods 
	HRESULT	OnWMChar(
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres);

	HRESULT	OnWMIMEChar(
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres);

	HRESULT	OnIMEReconvert( 
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres,
		BOOL	fUnicode);

	BOOL CheckIMEChange(
		LPRECONVERTSTRING	lpRCS,
		long				cpParaStart, 
		long				cpParaEnd,
		long				cpMin,
		long				cpMax,
		BOOL				fUnicode);

	HRESULT	OnIMEQueryPos( 
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres,
		BOOL	fUnicode);

	BOOL CheckIMEType( HKL hKL, DWORD dwFlags = CHECK_IME_SERVICE);

	HRESULT InputFEChar( WCHAR wchFEChar );

	void	OnSetFocus();
	void	OnKillFocus();

	LRESULT	OnSetIMEOptions(WPARAM wparam, LPARAM lparam);
	LRESULT	OnGetIMEOptions();
	void	SetupIMEOptions();
	void	SetupCallback();
	void	SetupLangSink();
	void	ReleaseLangSink();
	void	CompleteUIMTyping(LONG mode, BOOL fTransaction = TRUE);
	void	StartUIM();
	void	StartAimm(BOOL fUseAimm12);
	void	TurnOffUIM(BOOL fSafeToSendMessage);
	void	TurnOffAimm(BOOL fSafeToSendMessage);

	int		OnGetIMECompText(WPARAM wparam, LPARAM lparam);
	void OnSetIMEMode(WPARAM wparam, LPARAM lparam);
	LRESULT	OnGetIMEMode()
	{
		if (!_nIMEMode) 
			return 0;
		return _nIMEMode == 1 ? IMF_SMODE_PLAURALCLAUSE : IMF_SMODE_NONE;
	};
	void	SetIMESentenseMode(BOOL fSetup, HKL hKL = NULL);

	void	HandleCTFService(WPARAM wparam, LPARAM lparam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_devstki.h ===
INLINE	CDevDesc::CDevDesc(CTxtEdit * ped) : _ped(ped), _pdd(NULL)
{
	// Header does the work
}

INLINE BOOL CDevDesc::IsValid() const         
{
	return _pdd != NULL;
}

INLINE HDC CDevDesc::GetRenderDC()
{
	HDC hdc = NULL;

	if (NULL == _pdd)
	{
		// We don't already have on so try to get one. This is only valid when
		// we are inplace active.
		SetDrawInfo(
			DVA_ASPECT
			-1,
			NULL,
			NULL,
			hicTarget);
	}

	if (_pdd != NULL)
	{
		hdc = _pdd->GetDC();
	}

	return hdc;
}

INLINE HDC CDevDesc::GetTargetDC()
{
	if (_pdd != NULL)
	{
		return _pdd->GetTargetDC();
	}

	if (NULL != _hicMainTarget)
	{
		return _hicMainTarget;
	}

	return GetRenderDC();
}

INLINE void	CDevDesc::ResetDrawInfo()
{
	// We shouldn't reset 
	Assert
	CDrawInfo *pdd = _pdd;
	_pdd = _pdd->Pop();
	delete pdd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_dfreeze.h ===
/*	@doc INTERNAL
 *
 *	@module _DFREEZE.H  Classes handle freezing the display |
 *	
 *	This module declares class used by logic to handle freezing the display
 *
 *	History: <nl>
 *		2/8/96	ricksa	Created
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _DFREEZE_H
#define _DFREEZE_H

/*
 *	CAccumDisplayChanges
 *	
 * 	@class	This class is used to accumulate of all update to the display so
 *			so that at a later time the display can ask to be updated to 
 *			reflect all the previous updates.
 */
class CAccumDisplayChanges
{
//@access Public Methods
public:
				CAccumDisplayChanges();		//@cmember Constructor

				~CAccumDisplayChanges();	//@cmember Destructor

	void		AddRef();					//@cmember Add a reference

	LONG		Release();					//@cmember Release a reference

	void		UpdateRecalcRegion(			//@cmember Update the region 
					LONG cp,				// for recalc
					LONG cchDel,
					LONG cchNew);

	void		GetUpdateRegion(			//@cmember Get the update 
					LONG *pcpStart,			// region
					LONG *pcchNew,
					LONG *pcchDel,
					BOOL *pfUpdateCaret = NULL,
					BOOL *pfScrollIntoView = NULL,
					BOOL *pfRedisplayOnThaw = NULL);

	void		SaveUpdateCaret(			//@cmember Save update
					BOOL fScrollIntoView);	// caret state

	void		SetNeedRedisplayOnThaw(BOOL fNeedRedisplay)
	{
		_fNeedRedisplay = fNeedRedisplay;
	}
//@access Private Data
private:

	LONG		_cRefs;						//@cmember Reference count

	LONG		_cpMin;						//@cmember Min cp of change w.r.t.
											// original text array

	LONG		_cpMax;						//@cmember Max cp of change w.r.t.
											// original text array

	LONG		_delta;						//@cmember net # of chars changed

	BOOL		_fUpdateCaret:1;			//@cmember Whether update
											// caret required

	BOOL		_fScrollIntoView:1;			//@cmember first parm to 

	BOOL		_fNeedRedisplay:1;			//@cmember redisplay entire control on thaw
};

/*
 *	CAccumDisplayChanges::CAccumDisplayChanges()
 *
 *	@mfunc
 *		Initialize object for accumulating display changes
 */
inline CAccumDisplayChanges::CAccumDisplayChanges() 
	: _cRefs(1), _cpMin(CP_INFINITE), _fUpdateCaret(FALSE)
{
	// Header does all the work
}

/*
 *	CAccumDisplayChanges::~CAccumDisplayChanges()
 *
 *	@mfunc
 *		Free object
 *
 *	@devnote:
 *		This only serves a purpose in debug mode
 *
 */
inline CAccumDisplayChanges::~CAccumDisplayChanges()
{
	// Nothing to clean up
}

/*
 *	CAccumDisplayChanges::~CAccumDisplayChanges()
 *
 *	@mfunc
 *		Add another reference to this object
 */
inline void CAccumDisplayChanges::AddRef()
{
	++_cRefs;
}

/*
 *	CAccumDisplayChanges::Release()
 *
 *	@mfunc
 *		Release a reference to this object
 *
 *	@rdesc
 *		0 - no more references
 *		~0 - there are still outstanding references
 *
 *	@devnote:
 *		If 0 is returned the information should be retrieved from
 *		this object and passed on to the display so that it can
 *		update itself.
 *
 */
inline LONG CAccumDisplayChanges::Release()
{
	// When the reference count is 0, it is time to update the display.
	return --_cRefs;	
}

/*
 *	CAccumDisplayChanges::SaveUpdateCaret()
 *
 *	@mfunc
 *		Save parameters for update caret
 */
inline void CAccumDisplayChanges::SaveUpdateCaret(
	BOOL fScrollIntoView)		//@parm First parm for UpdateCaret
{
	_fUpdateCaret = TRUE;

	if (!_fScrollIntoView)
		_fScrollIntoView = fScrollIntoView;
}

#endif // _DFREEZE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_common.h ===
/*
 *	_COMMON.H
 *	
 *	Purpose:
 *		MSFTEDIT private common definitions
 *
 *	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
 */

#ifndef _COMMON_H
#define _COMMON_H

// REVIEW macro.
//
#define __LINE(l)   #l
#define __LINE_(l)  __LINE(l)
#define _LINE_      __LINE_(__LINE__)
#define REVIEW  __FILE__ "("  __LINE_(__LINE__) ") : "

#pragma message ("Compiling Common.H")

#ifdef NT
	#ifndef WINNT
	#define WINNT
	#endif
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#ifndef STRICT
#define STRICT
#endif

#define NOSHELLDEBUG			//disables asserts in shell.h

// Build dependent conditional definitions
#if defined(EBOOK_CE)

#define NOACCESSIBILITY
#define NOMAGELLAN
#define NODROPFILES
#define NOMETAFILES
#define NOFONTSUBINFO
#define NOFEPROCESSING
#define NOPRIVATEMESSAGE
#define NOCOMPLEXSCRIPTS
#define NODELAYLOAD
#define NOANSIWINDOWS
//#define NOWINDOWHOSTS - need hosted window for text boxes
#define NORIGHTTOLEFT
#define NOAUTOFONT
#define NOPLAINTEXT
#define NOPALETTE
#define NOLISTCOMBOBOXES
#define NOFULLDEBUG
#define THICKCARET
#define LIMITEDMEMORY
#define SLOWCPU
#define NOREGISTERTYPELIB
#define NODRAGDROP
#define NOWORDBREAKPROC
#define NORBUTTON
#define NODRAFTMODE
#define NOVERSIONINFO
#define NOINKOBJECT
#define W32INCLUDE "w32wince.cpp"
#pragma warning (disable : 4702)
#else // Normal build

#define W32INCLUDE "w32win32.cpp"

#endif

#define WINVER 0x0500

// 4201 : nameless struct/union
// 4514 : unreferenced inline function has been removed
// 4505 : unreferenced local function has been removed
#pragma warning (disable : 4201 4514 4505)

#ifdef NOFULLDEBUG
// 4800 : forcing value to bool 'true' or 'false' (performance warning)
#pragma warning (disable : 4800)
#endif

#include <limits.h>
#if defined(DEBUG) && !defined(NOFULLDEBUG)
#include <stdio.h>
#endif

#include <windows.h>
#include <windowsx.h>
#ifndef NOACCESSIBILITY 
#include <winable.h>
#endif

#include "imm.h"

/*
 *	Types
 */
#include <ourtypes.h>
#define QWORD	UINT64		// 64 flags used for CharFlags

// for the benefit of the outside world, richedit.h uses cpMax instead
// of cpMost. I highly prefer cpMost
#ifdef cpMax
#error "cpMax hack won't work"
#endif

//Everyone should call the W32->GetObject define and this makes calls to
//Win32 GetObject fail.
#undef GetObject

#define cpMax cpMost
#include <richedit.h>
#include <richole.h>
#undef cpMax

#include "_debug.h"

// Return TRUE if LF <= ch <= CR. NB: ch must be unsigned;
// WCHAR and unsigned short give wrong results!
#define IN_RANGE(n1, b, n2)		((unsigned)((b) - (n1)) <= unsigned((n2) - (n1)))

#define IsASCIIDigit(b)		IN_RANGE('0', b, '9')
#define IsASCIIEOP(ch)		IN_RANGE(LF, ch, CR)
#define IsZerowidthCharacter(ch) IN_RANGE(ZWSP, ch, RTLMARK)

// disable 
//         4710 : function not inlined
//         4512 : assignment operator not generated
//         4201 : nameless struct union
//         4100 : unreferenced formal;
//		   4706 : assignment within conditional expression (oould be bad, but common)
//		   4127 : conditional expression is constant (if (1))
//		   4242 : truncation warning
//         4244 : truncation warning
//         4267 : conversion from 'size_t' to 'int'


#pragma warning (disable : 4710 4512 4201 4100 4127 4706 4242 4244 4267)

#pragma warning(3:4121)   // structure is sensitive to alignment
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(3:4509)   // use of SEH with destructor

#include "resource.h"

// Use explicit ASCII values for LF and CR, since MAC compilers
// interchange values of '\r' and '\n'
#define CELL		7
#define TAB			TEXT('\t')
#define	LF			10
#define VT			TEXT('\v')
#define FF			12
#define	CR			13

#define BOM			0xFEFF
#define BULLET		0x2022
#define EMDASH		0x2014
#define EMSPACE		0x2003
#define ENDASH		0x2013
#define	ENQUAD		0x2000
#define ENSPACE		0x2002
#define EURO		0x20AC
#define KASHIDA		0x640
#define LDBLQUOTE	0x201c
#define LQUOTE		0x2018
#define LTRMARK		0x200E
#define NBSPACE		0xA0
#define NBHYPHEN	0x2011
#define NOTACHAR	0xFFFF
#define	PS			0x2029
#define RBOM		0xFFFE
#define RDBLQUOTE	0x201D
#define RQUOTE		0x2019
#define RTLMARK		0x200F
#define SOFTHYPHEN	0xAD
#define	TRD							// Table Row Delimiter (START/ENDFIELD CR)
#define	UTF16		0xDC00
#define	UTF16_LEAD	0xD800
#define	UTF16_TRAIL	0xDC00
#define ZWJ			0x200D
#define ZWNJ		0x200C
#define ZWSP		0x200B

#define STARTFIELD	0xFFF9
#define SEPARATOR	0xFFFA
#define ENDFIELD	0xFFFB

/*
 *	IsEOP(ch)
 *
 *	@func
 *		Used to determine if ch is an EOP char, i.e., CR, LF, VT, FF, CELL,
 *		PS, or LS (Unicode paragraph/line separator). For speed, this
 *		function is	inlined.
 *
 *	@rdesc
 *		TRUE if ch is an end-of-paragraph char
 */
__inline BOOL IsEOP(unsigned ch)
{
	return IN_RANGE(CELL, ch, CR) && ch != TAB || (ch | 1) == PS;
}

BOOL IsRTF(char *pstr, LONG cb);

#include <tom.h>
#define CP_INFINITE tomForward

#include "zmouse.h"
#include "_util.h"

#ifdef DEBUG
#define EM_DBGPED (WM_USER + 150)
#endif

#define EM_GETCODEPAGE	(WM_USER + 151)

// MIN

#ifdef min
#undef min
#endif
#define __min(a,b)    (((a) < (b)) ? (a) : (b))

inline int     min(int     v1, int     v2)	{return __min(v1, v2);}
inline UINT    min(UINT    v1, UINT    v2)	{return __min(v1, v2);}
inline float   min(float   v1, float   v2)	{return __min(v1, v2);}
inline double  min(double  v1, double  v2)	{return __min(v1, v2);}
inline __int64 min(__int64 v1, __int64 v2)	{return __min(v1, v2);}

// MAX

#ifdef max
#undef max
#endif
#define __max(a,b)    (((a) > (b)) ? (a) : (b))

inline int     max(int     v1, int     v2)	{return __max(v1, v2);}
inline UINT    max(UINT    v1, UINT    v2)	{return __max(v1, v2);}
inline float   max(float   v1, float   v2)	{return __max(v1, v2);}
inline double  max(double  v1, double  v2)	{return __max(v1, v2);}
inline __int64 max(__int64 v1, __int64 v2)	{return __max(v1, v2);}

// ABS

#ifdef abs
#undef abs
#endif
#define __abs(a)    (((a) < 0) ? 0 - (a) : (a))

#pragma function(abs)
inline int __cdecl abs(int	   v)	{return __abs(v);}
inline float   abs(float   v)	{return __abs(v);}
inline double  abs(double  v)   {return __abs(v);}
inline __int64 abs(__int64 v)	{return __abs(v);}

#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

#include "_cfpf.h"

// Interesting OS versions
#define VERS4		4

// conversions between byte and character counts
#define CbOfCch(_x) ((_x) * 2)
#define CchOfCb(_x) ((_x) / 2)

#define cKinsokuCategories	16

#define OLEstrcmp	wcscmp
#define OLEstrcpy	wcscpy
#define OLEsprintf	wsprintf
#define OLEstrlen	wcslen

// index (window long) of the PED
#define ibPed 0

// Timer ids
#define RETID_BGND_RECALC	0x01af
#define RETID_AUTOSCROLL	0x01b0
#define RETID_SMOOTHSCROLL	0x01b1
#define RETID_DRAGDROP		0x01b2
#define RETID_MAGELLANTRACK	0x01b3
#define RETID_VISEFFECTS	0x01b4

// Timer id when mouse is captured
#define ID_LB_CAPTURE	28988
#define ID_LB_CAPTURE_DEFAULT 250	// duration

// Timer id when type search is required
#define ID_LB_SEARCH	28989
#define ID_LB_SEARCH_DEFAULT 1250	// duration 1.25 second

// Count of characters in CRLF marker
#define cchCRLF 2
#define cchCR	1

// RichEdit 1.0 uses a CRLF for an EOD marker
#define	CCH_EOD_10			2
// RichEdit 2.0 uses a simple CR for the EOD marker
#define CCH_EOD_20			1

extern const WCHAR szCRLF[];
extern const WCHAR szCR[];

extern HINSTANCE hinstRE;		// DLL instance

#include <shellapi.h>

#ifdef DUAL_FORMATETC
#undef DUAL_FORMATETC
#endif
#define DUAL_FORMATETC FORMATETC

extern "C"
{
	LRESULT CALLBACK RichEditWndProc(HWND, UINT, WPARAM, LPARAM);
	LRESULT CALLBACK RichEditANSIWndProc(HWND, UINT, WPARAM, LPARAM);
}

// Multi-Threading support
extern CRITICAL_SECTION g_CriticalSection;

// a class to simplify critical section management
class CLock 
{
public:
	CLock()
	{
		EnterCriticalSection(&g_CriticalSection);
	}
	~CLock()
	{
		LeaveCriticalSection(&g_CriticalSection);
	}
};

enum HITTEST
{
	HT_Undefined = 0,	// Hit hasn't been determined
	HT_Nothing,
	HT_OutlineSymbol,
	HT_LeftOfText,
	HT_BulletArea,
	HT_RightOfText,
	HT_BelowText,
	HT_AboveScreen,

	HT_Text,			// All hits are in text from HT_Text on so
	HT_Link,			//  if(hit >= HT_Text) identifies text of some kind
	HT_Italic,
	HT_Object
};

typedef BYTE TFLOW;

#define tflowES		0  //Latin
#define tflowSW		1  //Vertical
#define tflowWN		2  //Upside down
#define tflowNE		3

const inline BOOL IsUVerticalTflow(TFLOW tflow)
{
	return tflow & 0x00000001L;
}

//This has the same names as RECT, but is of a different
//type so that the compiler can assist us in writing proper code.
struct RECTUV
{
    long    left;
    long    top;
    long    right;
    long    bottom;
};

struct SIZEUV
{
	LONG	du;
	LONG	dv;
};

#ifdef NOLINESERVICES
typedef struct tagPOINTUV
{
    LONG  u;
    LONG  v;
} POINTUV;
#endif //NOLINESERVICES

#define ST_CHECKPROTECTION		0x8000
#define ST_10REPLACESEL			0x10000000
#define ST_10WM_SETTEXT			0x20000000

/* REListbox1.0 Window Class. */
// For Windows CE to avaoid possible conflicts on WIn95.
#define CELISTBOX_CLASSA	"REListBoxCEA"
#define CELISTBOX_CLASSW	L"REListBoxCEW"

#define LISTBOX_CLASSW		L"REListBox50W"
#define COMBOBOX_CLASSW		L"REComboBox50W"

#ifdef DEBUG
//Debug api for dumping CTxtStory arrays.
extern "C" {
extern void DumpDoc(void *);
}
#endif

#ifndef NOLINESERVICES
#include "_ls.h"
#endif

// Our Win32 wrapper class
#include "_w32sys.h"


typedef BOOL (WINAPI *AutoCorrectProc)(LANGID langid, const WCHAR *pszBefore, WCHAR *pszAfter, LONG cchAfter, LONG *pcchReplaced);

#define EM_GETAUTOCORRECTPROC	(WM_USER + 233)
#define EM_SETAUTOCORRECTPROC	(WM_USER + 234)

#define EM_INSERTTABLE			(WM_USER + 232)
typedef struct _tableRowParms
{							// EM_INSERTTABLE wparam is a (TABLEROWPARMS *)
	BYTE	cbRow;			// Count of bytes in this structure
	BYTE	cbCell;			// Count of bytes in TABLECELLPARMS
	BYTE	cCell;			// Count of cells
	BYTE	cRow;			// Count of rows
	LONG	dxCellMargin;	// Cell left/right margin (\trgaph)
	LONG	dxIndent;		// Row left (right if fRTL indent (similar to \trleft)
	LONG	dyHeight;		// Row height (\trrh)
	DWORD	nAlignment:3;	// Row alignment (like PARAFORMAT::bAlignment, \trql, trqr, \trqc)
	DWORD	fRTL:1;			// Display cells in RTL order (\rtlrow)
	DWORD	fKeep:1;		// Keep row together (\trkeep}
	DWORD	fKeepFollow:1;	// Keep row on same page as following row (\trkeepfollow)
	DWORD	fWrap:1;		// Wrap text to right/left (depending on bAlignment)
							// (see \tdfrmtxtLeftN, \tdfrmtxtRightN)
	DWORD	fIdentCells:1;	// lparam points at single struct valid for all cells
} TABLEROWPARMS;

typedef struct _tableCellParms
{							// EM_INSERTTABLE lparam is a (TABLECELLPARMS *)
	LONG	dxWidth;		// Cell width (\cellx)
	WORD	nVertAlign:2;	// Vertical alignment (0/1/2 = top/center/bottom
							//  \clvertalt (def), \clvertalc, \clvertalb)
	WORD	fMergeTop:1;	// Top cell for vertical merge (\clvmgf)
	WORD	fMergePrev:1;	// Merge with cell above (\clvmrg)
	WORD	fVertical:1;	// Display text top to bottom, right to left (\cltxtbrlv)
	WORD	wShading;		// Shading in .01%		(\clshdng) e.g., 10000 flips fore/back

	SHORT	dxBrdrLeft;		// Left border width	(\clbrdrl\brdrwN) (in twips)
	SHORT	dyBrdrTop;		// Top border width		(\clbrdrt\brdrwN)
	SHORT	dxBrdrRight;	// Right border width	(\clbrdrr\brdrwN)
	SHORT	dyBrdrBottom;	// Bottom border width	(\clbrdrb\brdrwN)
	COLORREF crBrdrLeft;	// Left border color	(\clbrdrl\brdrcf)
	COLORREF crBrdrTop;		// Top border color		(\clbrdrt\brdrcf)
	COLORREF crBrdrRight;	// Right border color	(\clbrdrr\brdrcf)
	COLORREF crBrdrBottom;	// Bottom border color	(\clbrdrb\brdrcf)
	COLORREF crBackPat;		// Background color		(\clcbpat)
	COLORREF crForePat;		// Foreground color		(\clcfpat)
} TABLECELLPARMS;

// This interface enables clients to do custom rendering. Return FALSE for
// GetCharWidthW and RichEdit will call the OS to fetch character widths.
interface ICustomTextOut
{
	virtual BOOL WINAPI ExtTextOutW(HDC, int, int, UINT, CONST RECT *, LPCWSTR, UINT, CONST INT *) = 0;
	virtual BOOL WINAPI GetCharWidthW(HDC, UINT, UINT, LPINT) = 0;
	virtual BOOL WINAPI NotifyCreateFont(HDC) = 0;
	virtual void WINAPI NotifyDestroyFont(HFONT) = 0;
};

STDAPI SetCustomTextOutHandlerEx(ICustomTextOut **ppcto, DWORD dwFlags);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_coleobj.h ===
/*
 *	@doc	INTERNAL
 *
 *	@module	_COLEOBJ.H		The OLE Object management class | 
 *
 *	Author:	alexgo 10/24/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef __COLEOBJ_H__
#define __COLEOBJ_H__

#ifndef NOINKOBJECT
#include "HWXInk.h"
#endif

#include "_notmgr.h"

#ifndef NOLINESERVICES
extern "C" {
#include "plsdnode.h"
}
#endif

class CDisplay;
class CDevDesc;
class CTxtEdit;
class IUndoBuilder;

/* 
 *	COleObject
 *
 *	@class	This class manages an individual OLE object embedding.
 *
 */

class COleObject :  public IOleClientSite, public IOleInPlaceSite, 
					public IAdviseSink, public CSafeRefCount, public ITxNotify
{
//@access Public methods
public:
	//
	// IUnknown methods
	//

	STDMETHOD(QueryInterface)(REFIID riid, void **pv);
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);
	
	//
	// IOleClientSite methods
	//
	
	STDMETHOD(SaveObject)(void);
	STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker,
							IMoniker **ppmk);
	STDMETHOD(GetContainer)(IOleContainer **ppContainer);
	STDMETHOD(ShowObject)(void);
	STDMETHOD(OnShowWindow)(BOOL fShow);
	STDMETHOD(RequestNewObjectLayout)(void);

	//
	//	IOleInPlaceSite methods
	//
	STDMETHOD(GetWindow)(HWND *phwnd);
	STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);
	STDMETHOD(CanInPlaceActivate)(void);
	STDMETHOD(OnInPlaceActivate)(void);
	STDMETHOD(OnUIActivate)(void);
	STDMETHOD(GetWindowContext)(IOleInPlaceFrame **ppFrame,
							IOleInPlaceUIWindow **ppDoc, LPRECT lprcPosRect,
							LPRECT lprcClipRect, 
							LPOLEINPLACEFRAMEINFO lpFrameInfo);
	STDMETHOD(Scroll)(SIZE scrollExtant);
	STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
	STDMETHOD(OnInPlaceDeactivate)(void);
	STDMETHOD(DiscardUndoState)(void);
	STDMETHOD(DeactivateAndUndo)(void);
	STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);

	//
	// IAdviseSink methods
	//

	STDMETHOD_(void, OnDataChange)(FORMATETC *pfetc, STGMEDIUM *pmedium);
	STDMETHOD_(void, OnViewChange)(DWORD dwAspect, LONG lindex);
	STDMETHOD_(void, OnRename)(IMoniker *pmk);
	STDMETHOD_(void, OnSave)(void);
	STDMETHOD_(void, OnClose)(void);

	//
	//	ITxNotify methods
	//
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
    virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
	virtual void	Zombie();

	//
	//	internal public methods
	//

			COleObject(CTxtEdit *ped);	//@cmember Constructor
	LONG	GetCp()		{return _cp;}	//@cmember Get cp for this object
	CTxtEdit *GetPed()	{return _ped;}	//@cmember Get ped for this object
										//@cmember Fill out the REOBJECT struct
	HRESULT	GetObjectData(REOBJECT *preobj, DWORD dwFlags);
	BOOL	IsLink();					//@cmember returns TRUE if the object
										// is a link object.
										//@cmember Initialize from the given
										// object data
	HRESULT InitFromREOBJECT(LONG cp, REOBJECT *preobj);
										//@cmember Measures the object (no outgoing calls)
	void MeasureObj(long dvpInch, long dupInch, LONG & dup, LONG & dvpAscent,
					LONG & dvpDescent, SHORT dvpDescentFont, TFLOW tflow);
										//@cmember Draws the object
	void	DrawObj(const CDisplay *pdp, long dypInch, long dxpInch, HDC hdc, const RECTUV *prcClip,
					BOOL fMetafile, POINTUV *ppt, LONG yBaselineLine, LONG yDescentMaxCur, TFLOW tflow);
										//@cmember Handle the object being
										// deleted from the backing store
	void	Delete(IUndoBuilder *publdr);
	void	Restore();					//@cmember restore an object into
										// the backing store
										//@cmember Force a close on the
										// object
	void	Close(DWORD dwSaveOption);
										//@cmember Zombie the object.
    void    MakeZombie(void);
										//@cmember Activate the object
	BOOL	ActivateObj(UINT uiMsg,	WPARAM wParam, LPARAM lParam);
	HRESULT	DeActivateObj(void);		//@cmember Aeactivate the object
										//@cmember Set individual selection
										//state of object

	void GetRectuv(RECTUV &rc);

	void FetchObjectExtents(void);//@cmember Gets the size of the object
									//@cmember return REO_SELECTED state
	BOOL	FWrapTextAround(void) const {return (_pi.dwFlags & REO_WRAPTEXTAROUND) != 0;}
	BOOL	FAlignToRight(void) const {return (_pi.dwFlags & REO_ALIGNTORIGHT) != 0;}

	BOOL	GetREOSELECTED(void) {return (_pi.dwFlags & REO_SELECTED);}
										//@cmember set REO_SELECTED state
	void	SetREOSELECTED(BOOL fSelect);
								//@cmember checks for hits on frame handles
	WCHAR*  CheckForHandleHit(const POINTUV &pt, BOOL fLogical = FALSE);
								//@cmember handle object resize
	BOOL    HandleResize(const POINT &pt);
								//@cmember sets object size
	void    Resize(const SIZEUV &size, BOOL fCreateAntiEvent);
								//@cmember update _size
	void	ResetSize(const SIZEUV &size)
						{_size = size;}
								//@cmember called when object position changes
	void    OnReposition();
								//@cmember gets objects IUnknown
	IUnknown *	GetIUnknown(void) {return _punkobj;}
								//@cmember converts to the specified class
	HRESULT	Convert(REFCLSID rclsidNew, LPCSTR lpstrUserTypeNew);
								//@cmember activate as the specified class
	HRESULT	ActivateAs(REFCLSID rclsid, REFCLSID rclsidAs);
								//@cmember set aspect to use
	void	SetDvaspect(DWORD dvaspect);
								//@cmember get current aspect
	DWORD	GetDvaspect()
				{ return _pi.dvaspect; }
								//@cmember see IPersistStore::HandsOffStorage
	void	HandsOffStorage(void);
								//@cmember see IPersistStore::SaveCompleted
	void	SaveCompleted(LPSTORAGE lpstg);
								//@cmember set REO_LINKAVAILABLE flag
	HRESULT SetLinkAvailable(BOOL fAvailable);
								//@cmember Used for textize support
	LONG	WriteTextInfoToEditStream(EDITSTREAM *pes, UINT CodePage);
	
	void    SetHdata(HGLOBAL hg)	{_hdata = hg;}	//@cmember get the _hdata member

	void	GetSize(SIZEUV &size)	{size = _size;}
								//&cmember gets the _size member
	DWORD	GetFlags()	{return  _pi.dwFlags;}
								//&cmember gets the _sizel member
	DWORD	GetUser()	{return  _pi.dwUser;}
								//&cmember gets the _sizel member
	DWORD	GetAspect()	{return  _pi.dvaspect;}
								//&cmember gets the _sizel member

	// For internal use without reentering undo system.
	STDMETHOD(SafeSaveObject)(void);

	HGLOBAL GetHdata()				{return _hdata;}
	struct ImageInfo
	{
		LONG	xScale, yScale;		// @field scaling percentage along axes
		SHORT	xExtGoal, yExtGoal;	// @field desired dimensions in twips for pictures
		SHORT	cBytesPerLine;		// @field # bytes per raster line, if bitmap
	};
								//@cmember set the _pimageinfo member
	void    SetImageInfo(struct ImageInfo *pim)	{_pimageinfo = pim;}
								//@cmember get the _pimageinfo member
	ImageInfo *GetImageInfo()				{return _pimageinfo;}

#ifdef DEBUG
	void    DbgDump(DWORD id);
#endif
	BOOL	GetViewChanged()	{return _fViewChange;}
	void	ResetViewChanged()	{_fViewChange = FALSE;}

//@access Private methods and data
private:
	virtual ~COleObject();		//@cmember Destructor

	void SavePrivateState(void);//@cmember Saves private information
	HRESULT ConnectObject(void);//@cmember setup advises, etc.
	void DisconnectObject(void);//@cmember tear down advises, etc.
	void CleanupState(void);	//@cmember cleans up our member data, etc.
								//@cmember draws frame around object
	void DrawFrame(const CDisplay *pdp, HDC hdc, RECT* prc);
								//@cmember helper to draw frame handles
	void DrawHandle(HDC hdc, int x, int y);
								//@cmember helper to check for hit on a handle
	void CreateDib(HDC hdc);
								//@cmember helper to create DIB for WinCE bitmaps
	void DrawDib(HDC hdc, RECT *prc);
								//@cmember helper to draw WinCE bitmaps
	BOOL InHandle(int up, int vp, const POINTUV &pt);
								//@cmember to restablish rectangle position
	enum { SE_NOTACTIVATING, SE_ACTIVATING };  // used by SetExtent to indicate
												// the context of the SetExtent call
								//@cmember Attempts to set object extents
	HRESULT SetExtent(int iActivating);

	CTxtEdit *		_ped;		//@cmember edit context for this object
	IUnknown *		_punkobj;	//@cmember pointer to the objects IUnknown.
	IStorage *		_pstg;		//@cmember storage for the object
	SIZEUV			_size;		//@cmember cached "real" size of the object
	LONG			_cp;		//@cmember position of this object
	DWORD			_dwConn;	//@cmember advise connection cookie
	HGLOBAL			_hdata;
	HBITMAP			_hdib;
	ImageInfo *		_pimageinfo;

	struct PersistedInfo
	{
		DWORD	dwFlags;		//@cmember see richole.h
		DWORD	dwUser;			//@cmember user defined
		DWORD	dvaspect;		//@cmember from the DVASPECT enumeration
	};

	PersistedInfo	_pi;

	SHORT	_dxyFrame;			//@cmember Object frame width
	WORD	_fInPlaceActive:1;	//@cmember inplace active?
	WORD	_fInUndo:1;			//@cmember in the undo stack?
	WORD	_fIsWordArt2:1;		//@cmember Is this object a WordArt 2.0
								// object? (need to do hacks for it)
	WORD 	_fIsPaintBrush:1;	//@cmember Is this object a PaintBrush
								// object? (need to do hacks for it)
	WORD	_fPBUseLocalSize:1;	
								//@cmember Signals that SetExtent
								// for a PaintBrush object failed and that
								// _size is an accurate indication of object size
	WORD	_fDraw:1;			//@cmember Should object be drawn?
	WORD	_fSetExtent:1;		//@cmember Does SetExtent need to be called
								// when activating.
	WORD	_fDeactivateCalled:1;//@cmember Whether deactivate has been called.
	WORD	_fAspectChanged:1;	//@cmember Forces FetchObjectExtents to call through when aspect changes
	WORD	_fViewChange:1;		//@cmember flag to indicate size of object changed

	WORD	_fActivateCalled:1;	//@member Are we in the middle of the activation sequence?
	WORD	_fIsInkObject:1;	//@member Is this object a Ink Object

#ifndef NOINKOBJECT
public:
	ILineInfo	*_pILineInfo;	//@member Ink object ILineInfo
	BOOL	IsInkObject() { return _fIsInkObject; };
#endif

#ifndef NOLINESERVICES
public:
	PLSDNODE _plsdnTop;			//@cmember Ptr to LS display node
#endif

//VikramM - hacks added for E-Book
private:
	BOOL _fIsEBookImage; //@flags this is a ebook image that needs special treatment
	LPARAM _EBookImageID;
	SIZE _sizeEBookImage;
public: //E-Book functions
	void IsEbookImage(BOOL fIs) { _fIsEBookImage = fIs; };
	void SetEBookImageID(LPARAM lParam) { _EBookImageID = lParam ; };
	void SetEBookImageSizeDP(SIZE size) {_sizeEBookImage = size; };
};

#endif // __COLEOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_cuim.h ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	_CUIM.H	CUIM declaration
 *
 *	Purpose:  
 *
 *	Author:	<nl>
 *		11/16/99 honwch
 *
 *	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
 */
#ifndef	_CUIM_H
#define	_CUIM_H

#include "_notmgr.h"

class CUlColorArray : public CArray<COLORREF>
{
public:
	CUlColorArray() {};
	~CUlColorArray() {};
};

class CITfEnumRange : public CArray<IEnumTfRanges *>
{
public:
	CITfEnumRange() {};
	~CITfEnumRange() {};
};

typedef struct tagCTFMOUSETRAP
{
	LONG			cpMouseStart;
	LONG			cchMosueComp;
	WPARAM			wParamBefore;
	DWORD			dwCookie;
	ITfMouseSink	*pMouseSink;
	tagCTFMOUSETRAP	*pNext;
} CTFMOUSETRAP;

typedef struct _EMBEDOBJECT
{
	LONG		cpOffset;
	IDataObject *pIDataObj;
} EMBEDOBJECT;

// Forward declarations
class CTextMsgFilter;				

typedef HRESULT (*PTESCALLBACK)(ITfEditRecord *pEditRecord, void *pv);

class CTextEditSink : public ITfTextEditSink
{
public:
    CTextEditSink(PTESCALLBACK pfnCallback, void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfTextEditSink
    //
    STDMETHODIMP OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    HRESULT _Advise(ITfContext *pic);
    HRESULT _Unadvise();

private:

    long			_cRef;
    ITfContext		*_pic;
    DWORD			_dwCookie;
    PTESCALLBACK	_pfnCallback;
    void			*_pv;
};

class CUIM	:	public ITextStoreACP, public ITfContextOwnerCompositionSink, 
				public ITfMouseTrackerACP, public ITxNotify,
				public ITfEnableService, public IServiceProvider
{
public :

	CUIM(CTextMsgFilter *pTextMsgFilter);
	~CUIM();

    //
    // IUnknown
    //
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
	STDMETHODIMP_(ULONG) STDMETHODCALLTYPE AddRef(void);
	STDMETHODIMP_(ULONG) STDMETHODCALLTYPE Release(void);

    //
    // ITextStoreACP
    //
    STDMETHODIMP	AdviseSink(REFIID riid, IUnknown *punk, DWORD dwMask);
    STDMETHODIMP	UnadviseSink(IUnknown *punk);
    STDMETHODIMP	RequestLock(DWORD dwLockFlags, HRESULT *phrSession);
    STDMETHODIMP	GetStatus(TS_STATUS *pdcs);
	STDMETHODIMP	QueryInsert(LONG acpInsertStart, LONG acpInsertEnd, ULONG cch, LONG *pacpResultStart, LONG *pacpResultEnd);
    STDMETHODIMP	GetSelection(ULONG ulIndex, ULONG ulCount, TS_SELECTION_ACP *pSelection, ULONG *pcFetched);
    STDMETHODIMP	SetSelection(ULONG ulCount, const TS_SELECTION_ACP *pSelection);
    STDMETHODIMP	GetText(LONG acpStart, LONG acpEnd, WCHAR *pchPlain, ULONG cchPlainReq, ULONG *pcchPlainOut, TS_RUNINFO *prgRunInfo,
		ULONG ulRunInfoReq, ULONG *pulRunInfoOut, LONG *pacpNext);
    STDMETHODIMP	SetText(DWORD dwFlags, LONG acpStart, LONG acpEnd, const WCHAR *pchText, ULONG cch, TS_TEXTCHANGE *pChange);
	STDMETHODIMP	GetFormattedText(LONG acpStart, LONG acpEnd, IDataObject **ppDataObject);
    STDMETHODIMP	GetEmbedded(LONG acpPos, REFGUID rguidService, REFIID riid, IUnknown **ppunk);
    STDMETHODIMP	InsertEmbedded(DWORD dwFlags, LONG acpStart, LONG acpEnd, IDataObject *pDataObject, TS_TEXTCHANGE *pChange);
    STDMETHODIMP	RequestSupportedAttrs(DWORD dwFlags, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs);
    STDMETHODIMP	RequestAttrsAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP	RequestAttrsTransitioningAtPosition(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, DWORD dwFlags);
    STDMETHODIMP	FindNextAttrTransition(LONG acpStart, LONG acpHalt, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs,
		DWORD dwFlags, LONG *pacpNext, BOOL *pfFound, LONG *plFoundOffset);
    STDMETHODIMP	RetrieveRequestedAttrs(ULONG ulCount, TS_ATTRVAL *paAttrVals, ULONG *pcFetched);
    STDMETHODIMP	GetEndACP(LONG *pacp);
    STDMETHODIMP	GetActiveView(TsViewCookie *pvcView);
    STDMETHODIMP	GetACPFromPoint(TsViewCookie vcView, const POINT *pt, DWORD dwFlags, LONG *pacp);
    STDMETHODIMP	GetTextExt(TsViewCookie vcView, LONG acpStart, LONG acpEnd, RECT *prc, BOOL *pfClipped);
    STDMETHODIMP	GetScreenExt(TsViewCookie vcView, RECT *prc);
	STDMETHODIMP	GetWnd(TsViewCookie vcView, HWND *phwnd);
	STDMETHODIMP	QueryInsertEmbedded(const GUID *pguidService, const FORMATETC *pFormatEtc, BOOL *pfInsertable);
	STDMETHODIMP	InsertTextAtSelection(DWORD dwFlags, const WCHAR *pchText, ULONG cch, LONG *pacpStart,
		LONG *pacpEnd, TS_TEXTCHANGE *pChange);
	STDMETHODIMP	InsertEmbeddedAtSelection(DWORD dwFlags, IDataObject *pDataObject, LONG *pacpStart, 
		LONG *pacpEnd, TS_TEXTCHANGE *pChange);

	//
	// ITxNotify
	//
	virtual void OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
		LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
	virtual void OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
		LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
	virtual void Zombie();

	//
	// ITfContextOwnerCompositionSink
	//
	STDMETHODIMP	OnStartComposition(ITfCompositionView *pComposition, BOOL *pfOk);
	STDMETHODIMP	OnUpdateComposition(ITfCompositionView *pComposition, ITfRange *pRangeNew);
	STDMETHODIMP	OnEndComposition(ITfCompositionView *pComposition);

	//
	// ITfMouseTrackerACP
	//
	STDMETHODIMP	AdviseMouseSink(ITfRangeACP *pRangeACP, ITfMouseSink *pSink, DWORD *pdwCookie);
	STDMETHODIMP	UnadviseMouseSink(DWORD dwCookie);

    //
    // ITfEnableService
    //
	STDMETHODIMP	IsEnabled(REFGUID rguidServiceCategory, CLSID clsidService, IUnknown *punkService, BOOL *pfOkToRun);
	STDMETHODIMP	GetId(GUID *pguidId);

    //
    // IServiceProvider
    //
	STDMETHODIMP	QueryService(REFGUID guidService, REFIID riid, void **ppv);

	// Public
	STDMETHODIMP			Init();
	void					Uninit();
	HRESULT					GetAltDispAttrib(long lValue, ALTDISPLAYATTRIBUTE *pAltDispAttribute);
	void					OnSetFocus(BOOL fEnable = TRUE);
	void					CompleteUIMText();	
	BOOL					IsUIMTyping() { return _fUIMTyping; };
	STDMETHODIMP			GetStoryLength(LONG *pacp);
	int						Reconverse();
	HRESULT					MouseCheck(UINT *pmsg, WPARAM *pwparam, LPARAM *plparam, LRESULT *plres);
	ITfContext				*GetITfContext() { return  _pic; };

	WORD					_fUIMTyping				: 1;
	WORD					_fReadLockOn			: 1;
	WORD					_fWriteLockOn			: 1;
	WORD					_fReadLockPending		: 1;
	WORD					_fWriteLockPending		: 1;
	WORD					_fAllowUIMLock			: 1;
	WORD					_fAnyWriteOperation		: 1;
	WORD					_fSelChangeEventPending	: 1;
	WORD					_fLayoutEventPending	: 1;
	WORD					_fModeBiasPending		: 1;
	WORD					_fHoldCTFSelChangeNotify: 1;
	WORD					_fEndTyping				: 1;
	WORD					_fInterimChar			: 1;
	WORD					_fInsertTextAtSel		: 1;
	WORD					_fShutDown				: 1;
	WORD					_fMosueSink				: 1;

	short					_cCallMgrLevels;
	short					_ase;
	LONG					_acpInterimStart;
	LONG					_acpInterimEnd;

	LONG					_cchComposition;
	BSTR					_bstrComposition;
	LONG					_acpBstrStart;
	long					_cObjects;
	EMBEDOBJECT				*_pObjects;
	LONG					_acpFocusRange;
	LONG					_cchFocusRange;
	LONG					_acpPreFocusRangeLast;
	LONG					_cchFocusRangeLast;
	LONG					_cpEnd;

	ITextStoreACPSink		*_ptss;

	BOOL					CTFOpenStatus(BOOL fGetStatus, BOOL fOpen);

	CTFMOUSETRAP			*_pSinkList;		// Support for mouse trap operation

	void					NotifyService();	// Notify Cicero about services changes

private:
	ULONG					_crefs;
	CTextMsgFilter			*_pTextMsgFilter;
    ITfDocumentMgr			*_pdim;
    ITfContext				*_pic;
	ITextFont				*_pTextFont;
	long					_cpMin;
	TfEditCookie			_editCookie;

	ITfDisplayAttributeMgr	*_pDAM;
	ITfCategoryMgr			*_pCategoryMgr;
	CTextEditSink			*_pTextEditSink;
	CUlColorArray			*_pacrUl;
	CITfEnumRange			*_parITfEnumRange;
	ITfContextRenderingMarkup *_pContextRenderingMarkup;

	USHORT					_uAttrsValCurrent;
	USHORT					_uAttrsValTotal;
	TS_ATTRVAL				*_parAttrsVal;
	
	void	InitAttrVarArray(BOOL fAllocData = TRUE);
	BOOL	GetExtentAcpPrange(ITfRange *ITfRangeIn, long &cpFirst, long &cpLim);
    static	HRESULT EndEditCallback(ITfEditRecord *pEditRecord, void *pv);
	long	GetUIMUnderline(TF_DISPLAYATTRIBUTE &da, long &idx, COLORREF &cr);
	BOOL	GetUIMAttributeColor(TF_DA_COLOR *pdac, COLORREF *pcr);
	HRESULT	HandlePropAttrib(IEnumTfRanges *pEnumRanges);
	HRESULT	HandleFocusRange(IEnumTfRanges *pEnumRanges);
	HRESULT	HandleLangID(IEnumTfRanges *pEnumRanges);
	void	OnUIMTypingDone();
	BOOL	GetGUIDATOMFromGUID(REFGUID rguid, TfGuidAtom *pguidatom);
	int		FindGUID(REFGUID guid);
	BOOL	PackAttrData(LONG idx, ITextFont *pITextFont, ITextPara *pITextPara, TS_ATTRVAL *pTSAttrVal);
	HRESULT GetAttrs(LONG acpPos, ULONG cFilterAttrs, const TS_ATTRID *paFilterAttrs, BOOL fGetDefault);
	void	BuildHiddenTxtBlks(long &cpMin, long &cpMax, long **ppHiddenTxtBlk, long &cHiddenTxtBlk);
	HRESULT	FindHiddenText(long cp, long cpEnd, long &cpRange);
	HRESULT	FindUnhiddenText(long cp, long cpEnd, long &cpRange);
	void	HandleFinalString(ITfRange *pPropRange, long cp=0, long cch=0, BOOL fEndComposition = FALSE);
	void	HandleDispAttr(ITfRange *pITfRangeProp, VARIANT &var, long cp=0, long cch=0);
	int		BuildObject(ITextRange	*pTextRange, BSTR bstr, EMBEDOBJECT **ppEmbeddObjects, int cSize);
	void	InsertTextandObject(ITextRange *pTextRange, BSTR bstr, EMBEDOBJECT *pEmbeddObjects, long cEmbeddedObjects);
	void	CleanUpObjects(long cObjects, EMBEDOBJECT *pObjects);
	void	HandleTempDispAttr(ITfEditRecord *pEditRecord);
	void	CleanUpComposition();
	STDMETHODIMP	InsertData(DWORD dwFlags, LONG acpStart, LONG acpEnd, const WCHAR *pchText, ULONG cch,
		IDataObject *pDataObject, TS_TEXTCHANGE *pChange);
};

BOOL	CreateUIM(CTextMsgFilter *pTextMsgFilter);

#endif	// _CUIM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_debug.h ===
/*
 *	_DEBUG.H
 *	
 *	Purpose:
 *		RICHEDIT debugging support--commented out in ship builds
 *
 *	History: <nl>
 *		7/29/98	KeithCu Wrote it stealing much from Rich Arneson's code
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _DEBUG_H
#define _DEBUG_H

#define DllExport __declspec(dllexport)

#if !defined(NOFULLDEBUG) && (defined(DEBUG) || defined(_RELEASE_ASSERTS_))
#define	ASSERTDATA		static char _szFile[] = __FILE__;
BOOL WINAPI DebugMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved);
#else	// DEBUG
#define	ASSERTDATA
#define DebugMain(hDll, dwReason, lpReserved)
#endif	// DEBUG, else

//This is the buffer length used for building messages
#define MAXDEBUGSTRLEN (MAX_PATH + MAX_PATH)

//The following constants are used to specify and interpret
//packed values in the DWORD flags parameter passed to TraceMsg.
//Each of these is held in a 4-bit field in the DWORD.

//Subsystem field values
#define TRCSUBSYSNONE   0x0
#define TRCSUBSYSDISP   0x1
#define TRCSUBSYSWRAP   0x2
#define TRCSUBSYSEDIT   0x3
#define TRCSUBSYSTS     0x4
#define TRCSUBSYSTOM    0x5
#define TRCSUBSYSOLE    0x6
#define TRCSUBSYSBACK   0x7
#define TRCSUBSYSSEL    0x8
#define TRCSUBSYSHOST   0x9
#define TRCSUBSYSDTE    0xa
#define TRCSUBSYSUNDO   0xb
#define TRCSUBSYSRANG   0xc
#define TRCSUBSYSUTIL   0xd
#define TRCSUBSYSNOTM   0xe
#define TRCSUBSYSRTFR   0xf
#define TRCSUBSYSRTFW   0x10
#define TRCSUBSYSPRT    0x11
#define TRCSUBSYSFE     0x12
#define TRCSUBSYSFONT	0x13

//Severity field values
#define TRCSEVNONE      0x0
#define TRCSEVWARN      0x1
#define TRCSEVERR       0x2
#define TRCSEVASSERT    0x3
#define TRCSEVINFO      0x4
#define TRCSEVMEM       0x5

//Scope field values
#define TRCSCOPENONE    0x0
#define TRCSCOPEEXTERN  0x1
#define TRCSCOPEINTERN  0x2

//Data field values
#define TRCDATANONE     0x0
#define TRCDATAHRESULT  0x1
#define TRCDATASTRING   0x2
#define TRCDATAPARAM    0x3
#define TRCDATADEFAULT  0x4

//Debug option flags.  See the macros in this header for setting and testing
//these option flags.
#define OPTUSEDEFAULTS  0x00000001  //Use defaults from win.ini 
                                    //(used only with InitDebugServices).
#define OPTLOGGINGON    0x00000008  //Logging of trace output
#define OPTVERBOSEON    0x00000010  //Subsys, Scope & PID/TID
#define OPTINFOON       0x00000020  //Informational messages
#define OPTTRACEON      0x00000040  //All function tracing on
#define OPTTRACEEXT     0x00000080  //Function tracing only for external functions
#define OPTMEMORYON     0x00000100  //Memory alloc/free tracing on

//The following options allow tracing to be enabled for one or more
//specific subsystems.  If OPTTRACEON is set, these will have no effect.
//if OPTTRACEEXT is set, they will enable tracing for all functions in
//the designated subsystem in addition to external functions.
//The SETOPT and ISOPTSET macros should be used for setting and checking
//these options.  INITDEBUGSERVICES can also be used.
#define OPTTRACEDISP    0x00001000  //Function tracing for Display subsystem
#define OPTTRACEWRAP    0x00002000  //Function tracing for Wrapper subsystem
#define OPTTRACEEDIT    0x00004000  //Function tracing for Edit subsystem
#define OPTTRACETS      0x00008000  //Function tracing for TextServices subsystem
#define OPTTRACETOM     0x00010000  //Function tracing for TOM subsystem
#define OPTTRACEOLE     0x00020000  //Function tracing for OLE support subsystem
#define OPTTRACEBACK    0x00040000  //Function tracing for Backing Store subsystem
#define OPTTRACESEL     0x00080000  //Function tracing for Selection subsystem
#define OPTTRACEHOST    0x00100000  //Function tracing for WinHost subsystem
#define OPTTRACEDTE     0x00200000  //Function tracing for DataXfer subsystem
#define OPTTRACEUNDO    0x00400000  //Function tracing for Muli-undo subsystem
#define OPTTRACERANG    0x00800000  //Function tracing for Range subsystem
#define OPTTRACEUTIL    0x01000000  //Function tracing for Utility subsystem
#define OPTTRACENOTM    0x02000000  //Function tracing for Notification Mgr subsystem
#define OPTTRACERTFR    0x04000000  //Function tracing for RTF reader subsystem
#define OPTTRACERTFW    0x08000000  //Function tracing for RTF writer subsystem
#define OPTTRACEPRT     0x10000000  //Function tracing for Printing subsystem
#define OPTTRACEFE      0x20000000  //Function tracing for East Asia subsystem
#define OPTTRACEFONT    0x40000000  //Function tracing for Font Cache

#if !defined(NOFULLDEBUG) && (defined(DEBUG) || defined(_RELEASE_ASSERTS_))

#ifndef _RELEASE_ASSERTS_

//Union for handling tracing flags
//This union is used to decode the
//packed DWORD passed to TraceMsg.
typedef union
{
    struct
    {
        unsigned uData2         :4;
        unsigned uData1         :4;
        unsigned uScope         :4;
        unsigned uSeverity      :4;
        unsigned uSubSystem     :8;
        unsigned uUnused1       :4;
        unsigned uUnused2       :4;
    }       fields;
    DWORD   dw;
} TrcFlags;


//Exported classes and functions.
//Generally, these should not be used directly by the user.
//They should be used via the macros defined in this header.
//This helps to ensure that the parameter lists are well
//formed and keeps references to them from showing up in
//in non-debug builds.

//This class is used to implement the function Entry/Exit
//tracing. By declaring it on the stack at the beginning
//of a function, Entry and Exit messages are automatically
//generated by the constructor and destructor.
class CTrace
{
    public:
        CTrace(DWORD, DWORD, DWORD, LPSTR);
        ~CTrace();

    private:
        TrcFlags trcf;
        char szFileName[MAXDEBUGSTRLEN];
        char szFuncName[80];
};

extern DWORD dwDebugOptions;
extern void SetLogging(BOOL);
void Tracef(DWORD, LPSTR szFmt, ...);
void TraceError(LPSTR sz, LONG sc);

#endif //!_RELEASE_ASSERTS_

typedef BOOL (CALLBACK * PFNASSERTHOOK)(LPSTR, LPSTR, int*);
typedef BOOL (CALLBACK * PFNTRACEHOOK)(DWORD*, DWORD*, DWORD*, LPSTR, int*);
extern PFNTRACEHOOK pfnTrace;
extern PFNASSERTHOOK pfnAssert;
void AssertSzFn(LPSTR, LPSTR, int);
void TraceMsg(DWORD, DWORD, DWORD, LPSTR, int);
DllExport void WINAPI InitDebugServices(DWORD, PFNASSERTHOOK, PFNTRACEHOOK);

//Assert based on boolean f.
#define Assert(f)           AssertSz((f), NULL)

//Assert based on boolean f in debug, resolve to f in non-debug.
#define SideAssert(f)       AssertSz((f), NULL)

//Assert based on boolean f and use string sz in assert message.
#define AssertSz(f, sz)     (!(f) ? AssertSzFn(sz, __FILE__, __LINE__) : 0)

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETASSERTFN(pfn)      (pfnAssert = (pfn))    

//The following macros provide access to the debug services in this dll.
//Assert macros pop a dialog.  Trace macros output to debug output and
//logfile if enabled.

//Macro for InitDebugServices
#define INITDEBUGSERVICES(f, pfnA, pfnT) InitDebugServices(f, pfnA, pfnT)

//This is a utility macro for internal use.  The user should not need this.
#define MAKEFLAGS(ss, sv, sc, d1, d2) ((ss << 16) + (sv << 12) + (sc << 8)\
            + (d1 << 4) + (d2))

#ifndef _RELEASE_ASSERTS_
//Assert only on debug builds, not on _RELEASE_ASSERTS_ builds
//This is for asserts that contain debug only code
#ifndef AssertNr
#define AssertNr(f)         AssertSz((f), NULL)
#endif

#ifndef AssertNrSz
#define AssertNrSz(f, sz)     (!(f) ? AssertSzFn(sz, __FILE__, __LINE__) : 0)
#endif


//Macro for TraceError
#define TRACEERRSZSC(sz, sc) TraceError(sz, sc)

//Warning based on GetLastError or default message if no last error.
#define TRACEWARN           TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)
//Error based on GetLastError or default message if no last error.
#define TRACEERROR          TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)

//Warning based on HRESULT hr
#define TRACEWARNHR(hr)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)

//Test for a failure HR && warn
#define TESTANDTRACEHR(hr)	if( hr < 0 ) { TRACEWARNHR(hr); }

//Error based on HRESULT hr
#define TRACEERRORHR(hr)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)

//Warning using string sz
#define TRACEWARNSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__, __LINE__)

//Trace based on Assert, user passes file name and line
#define TRACEASSERT(szFile, iLine)     TraceMsg (MAKEFLAGS(TRCSUBSYSNONE,\
												TRCSEVASSERT, TRCSCOPENONE,\
												TRCDATANONE, TRCDATANONE),\
												(DWORD)0, (DWORD)0, szFile, iLine)

//Trace based on Assert, user passes file name and line
#define TRACEASSERTSZ(sz, szFile, iLine)     TraceMsg (MAKEFLAGS(TRCSUBSYSNONE,\
												TRCSEVASSERT, TRCSCOPENONE,\
												TRCDATASTRING, TRCDATANONE),\
												(DWORD)(DWORD_PTR)sz, (DWORD)0, szFile, iLine)
//Error using string sz
#define TRACEERRORSZ(sz)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__, __LINE__)

//Error using string sz
#define TRACEINFOSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVINFO,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__, __LINE__)

//Initiate tracing.  This declares an instance of the CTtrace class
//on the stack.  Subsystem (ss), Scope (sc), and the function name
//(sz) must be specifed.  ss and sc are specified using the macros
//defined in this header (i.e. - TRCSUBSYSTOM, TRCSCOPEEXTERN, etc.).
//sz can be a static string.
#define TRACEBEGIN(ss, sc, sz)  CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATANONE),\
                                    (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__)

//Same as TRACEBEGIN but it takes the additional param which is interpreted
//by TraceMsg as a Text Message request.
#define TRACEBEGINPARAM(ss, sc, sz, param) \
                                CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATAPARAM),\
                                    (DWORD)(DWORD_PTR)(sz), (DWORD)(param), __FILE__)

//Set logging to on (f = TRUE) or off (f = FALSE)
#define SETLOGGING(f)       SetLogging(f)

//Set output of process & thread IDs to on (f = TRUE) or off (f = FALSE)
#define SETVERBOSE(f)       ((f) ? (dwDebugOptions |= OPTVERBOSEON) :\
                            (dwDebugOptions &= ~OPTVERBOSEON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETINFO(f)          ((f) ? (dwDebugOptions |= OPTINFOON) :\
                            (dwDebugOptions &= ~OPTINFOON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETMEMORY(f)          ((f) ? (dwDebugOptions |= OPTMEMORYON) :\
                            (dwDebugOptions &= ~OPTMEMORYON))

//Set tracing for all functions to on (f = TRUE) or off (f = FALSE).
//If this is set to "on", external and subsystem level tracing
//has no effect since all function traces are enabled. If it is off,
//external and subsystem level tracing remain in whatever state they
//have been set to.
#define SETTRACING(f)       ((f) ? (dwDebugOptions |= OPTTRACEON) :\
                            (dwDebugOptions &= ~OPTTRACEON))

//Set tracing for EXTERNAL scope calls only to on (f = TRUE)
//or off (f = FALSE).  This is only effective if OPTTRACEON has not
//been set.
#define SETTRACEEXT(f)      ((f) ? (dwDebugOptions |= OPTTRACEEXT) :\
                            (dwDebugOptions &= ~OPTTRACEEXT))

//This macro turns all function tracing off.
#define SETALLTRACEOFF      (dwDebugOptions &= ~(OPTTRACEEXT | OPTTRACEON | 0xfffff000))

//This macro sets a given option or options (if they are or'ed together)
//to on (f = TRUE), or off (f = FALSE).  It cannot be used to set logging.
#define SETOPT(opt, f)      ((f) ? (dwDebugOptions |= (opt)) :\
                            (dwDebugOptions &= (~(opt))))
                             
//This macro determines the state of a given option.
#define ISOPTSET(opt)       ((opt) & dwDebugOptions)

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETTRACEFN(pfn)      (pfnTrace = (pfn))    

//The following option tests are explicitly defined for convenience.
#define fLogging            (OPTLOGGINGON & dwDebugOptions)
#define fVerbose            (OPTVERBOSEON & dwDebugOptions)
#define fInfo               (OPTINFOON & dwDebugOptions)
#define fTrace              (OPTTRACEON & dwDebugOptions)
#define fTraceExt           (OPTTRACEEXT & dwDebugOptions)

#else //_RELEASE_ASSERTS_

//Functions not used by release build with asserts
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define Tracef	;/##/
#define TRACEERRSZSC(sz, sc)
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEASSERT(szFile, iLine)
#define TRACEASSERTSZ(sz, szFile, iLine)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETTRACEFN(pfn)

#define TraceError(_sz, _sc)

#endif //_RELEASE_ASSERTS_

#else // !(!defined(NOFULLDEBUG) && (defined(DEBUG) || defined(_RELEASE_ASSERTS_)))

#if defined(NOFULLDEBUG) && defined(DEBUG)
__inline void Tracef(DWORD, LPSTR, ...) {};
__inline void Assert(bool) {};
__inline void AssertSz(bool, char *) {};
typedef BOOL (CALLBACK * PFNASSERTHOOK)(LPSTR, LPSTR, int*);
extern PFNASSERTHOOK pfnAssert;
#else // !defined(NOFULLDEBUG)
#define Tracef	;/##/
#ifndef Assert
#define Assert(f)
#endif
#ifndef AssertSz
#define AssertSz(f, sz)
#endif
#endif
#define INITDEBUGSERVICES(f, pfnA, pfnT)
#define TRACEERRSZSC(sz, sc)
#ifndef SideAssert
#define SideAssert(f) (f)
#endif
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEASSERT(szFile, iLine)
#define TRACEASSERTSZ(sz, szFile, iLine)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETASSERTFN(pfn)
#define SETTRACEFN(pfn)

#define AssertSzFn(sz, __FILE__, __LINE__)
#define TraceError(_sz, _sc)

#endif

#endif //DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_drwinfo.h ===
/*	@doc INTERNAL
 *
 *	@module _DRWINFO.H  Class to hold draw parameters |
 *	
 *	This declares a class that is used to hold parameters passed from
 *	the host for drawing.
 *
 *	Original Author: <nl>
 *		Rick Sailor
 *
 *	History: <nl>
 *		11/01/95	ricksa	created
 */
#ifndef _DRWINFO_H_
#define _DRWINFO_H_

/*
 *	CArrayBase
 *	
 * 	@class	This class serves as a holder for all the parameters to a draw
 *	except currently the HDC. Access to these parameters will actually come
 *	through the display class.
 *
 *	@devnote Although each operation that takes the parameters for drawing
 *	will create one of these objects, the display keeps only one of these
 *	objects because it will only use the last set of drawing parameters to
 *	draw with. The depth count is used to tell draw whether it is appropriate
 *	to draw or not.
 *
 */
class CDrawInfo
{
//@access Public Methods
public:
						CDrawInfo(CTxtEdit *ped);	//@cmember Initialize object

	void				Init(						//@cmember Fills object 
													//with draw data.
							DWORD dwDrawAspect,	
							LONG  lindex,		
							void *pvAspect,		
							DVTARGETDEVICE *ptd,
							HDC hicTargetDev);	

	DWORD				Release();					//@cmember Dec's ref count

	const CDevDesc *	GetTargetDD();				//@cmember Gets target device

	DWORD				GetDrawDepth() const;		//@cmember Gets depth count

	DWORD 				GetDrawAspect() const;		//@cmember Gets Draw aspect

	LONG 				GetLindex() const;			//@cmember Gets lindex

	void *				GetAspect() const;			//@cmember Gets aspect

	DVTARGETDEVICE *	GetPtd() const;				//@cmember Gets target device
				   									// descriptor.
//@access Private Data
private:

	DWORD				_dwDepth;					//@cmember Max number of
													// users of this information

	DWORD				_cRefs;						//@cmember Number of current
													// users

	CDevDesc			_ddTarget;					//@cmember target device
													// (if any).

	DWORD 				_dwDrawAspect;				//@cmember draw aspect

	LONG  				_lindex;					//@cmember lindex

	void *				_pvAspect;					//@cmember aspect

	DVTARGETDEVICE *	_ptd;						//@cmember target device data
};

/*
 *	CDrawInfo::CDrawInfo
 *
 *	@mfunc	Initializes structure with base required information
 *
 *	@rdesc	Initialized object
 *
 *	@devnote This serves two purposes: (1) CDevDesc requires the ped to 
 *	initalize correctly and (2) We need to make sure that the ref counts
 *	are set to zero since this is created on the stack.
 *	
 */
inline CDrawInfo::CDrawInfo(
	CTxtEdit *ped) 		//@parm Edit object used by the target device
	: _ddTarget(ped), _dwDepth(0), _cRefs(0)							   
{
	// Header does the work
}

/*
 *	CDrawInfo::Init
 *
 *	@mfunc	Initializes object with drawing data
 *
 *	@rdesc	void
 *
 *	@devnote This is separated from the constructor because the display
 * 	only uses one copy of this object so the display may initialize
 *	a different object than the one constructed.
 */
inline void CDrawInfo::Init(
	DWORD dwDrawAspect,	//@parm draw aspect
	LONG  lindex,		//@parm currently unused
	void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,//@parm information on target device								
	HDC hicTargetDev)	//@parm	target information context
{
	_dwDepth++;
	_cRefs++;
	_dwDrawAspect = dwDrawAspect;
	_lindex = lindex;
	_pvAspect = pvAspect;
	_ptd = ptd;

	if (hicTargetDev != NULL)
	{
		_ddTarget.SetDC(hicTargetDev);	
	}
}


/*
 *	CDrawInfo::Release
 *
 *	@mfunc	Decrements the reference count
 *
 *	@rdesc	Number of outstanding references to this object
 *
 *	@devnote This is used by the display to tell the display when it can NULL
 * 	its pointer to the display object.
 */
inline DWORD CDrawInfo::Release()
{

	AssertSz((_cRefs != 0), "CDrawInfo::Release invalid");
	return --_cRefs;	
}


/*
 *	CDrawInfo::GetTargetDD
 *
 *	@mfunc	Get pointer to target device
 *
 *	@rdesc	Returns pointer to target device if there is one
 *
 */
inline const CDevDesc *CDrawInfo::GetTargetDD()
{
	return (_ddTarget.IsValid())
		? &_ddTarget 
		: NULL;
}

/*
 *	CDrawInfo::GetDrawDepth
 *
 *	@mfunc	Get number of uses of this object
 *
 *	@rdesc	Number of uses of this object
 *
 *	@devnote This allows the draw routine to determine if a recursive draw
 *	occurred.
 *
 */
inline DWORD CDrawInfo::GetDrawDepth() const
{
	return _dwDepth;
}

/*
 *	CDrawInfo::GetDrawAspect
 *
 *	@mfunc	Get the draw aspect passed in on draw
 *
 *	@rdesc	Returns draw aspect
 *
 */
inline DWORD CDrawInfo::GetDrawAspect() const
{
	return _dwDrawAspect; 
}

/*
 *	CDrawInfo::GetLindex
 *
 *	@mfunc	Gets lindex passed from host
 *
 *	@rdesc	lindex passed from host
 *
 */
inline LONG CDrawInfo::GetLindex() const
{
	return _lindex; 
}

/*
 *	CDrawInfo::GetAspect
 *
 *	@mfunc	Gets pointer to aspect passed from host
 *
 *	@rdesc	Returns pointer to aspect structure
 *
 *	@devnote this is data is currently not defined.
 *
 */
inline void *CDrawInfo::GetAspect() const
{
	return _pvAspect; 
}

/*
 *	CDrawInfo::GetPtd
 *
 *	@mfunc	Get device target data from host
 *
 *	@rdesc	Returns pointer to device target data
 *
 */
inline DVTARGETDEVICE *CDrawInfo::GetPtd() const
{
	return _ptd; 
}

#endif // _DRWINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_dte.h ===
/*
 *	_DTE.H
 *
 *	Purpose:
 *		Interface declaration for IDataTransferEngine
 *		there is typically one data transfer engine per
 *		CTxtEdit instance
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	NB!  THIS FILE IS NOW OBSOLETE
 */

#ifndef __DTE_H__
#define __DTE_H__

#include "_m_undo.h"

class CTxtRange;
class CTxtEdit;

/*
 *	DataObjectInfo
 *
 *	Purpose:
 *		enumeration of bit flags used to indicate what operations
 *		are possible from a given data object.
 */

typedef enum tagDataObjectInfo
{
	DOI_NONE			= 0,
	DOI_CANUSETOM		= 1,	// TOM<-->TOM optimized data transfers
	DOI_CANPASTEPLAIN	= 2,	// plain text pasting available
	DOI_CANPASTERICH	= 4, 	// rich text pasting available  
	DOI_CANPASTEOLE		= 8,	// object may be pasted as an OLE embedding
								// (note that this flag may be combined with
								// others). 
} DataObjectInfo;

/*
 *	IDataTransferEngine
 *
 *	Purpose:
 *		provides clipboard, drag drop, and data object data transfer
 *		capabilities.  Each implementation will provide a different 
 *		level of functionality (e.g. OLE vs no-OLE)
 */
class IDataTransferEngine
{
public:
	// memory mgmt

	virtual void Destroy() = 0;

	// clipboard operations

	virtual HRESULT CopyRangeToClipboard( CTxtRange *prg ) = 0;
	virtual HRESULT CutRangeToClipboard( CTxtRange *prg, 
						IUndoBuilder *publdr ) = 0;
	virtual HRESULT PasteClipboardToRange( CTxtRange *prg, 
						IUndoBuilder *publdr ) = 0;
	virtual BOOL 	CanPaste( CTxtRange *prg, CLIPFORMAT cf) = 0;

	// data object operations

	virtual HRESULT RangeToDataObject( CTxtRange *prg, LONG lStreamFormat,
									IDataObject **ppdo) = 0;
	virtual HRESULT PasteDataObjectToRange( IDataObject *pdo,
						CTxtRange *prg, IUndoBuilder *publdr) = 0;

	virtual HRESULT GetDataObjectInfo( IDataObject *pdo, DWORD *pDOIFlags ) = 0;
	
	// drag drop operations
	
	virtual HRESULT GetDropTarget( IDropTarget **ppDropTarget ) = 0;
	virtual HRESULT StartDrag( CTxtRange *prg, IUndoBuilder *publdr) = 0;

	// file i/o

	virtual LONG LoadFromEs( CTxtRange *prg, LONG lStreamFormat,
							 EDITSTREAM *pes, IUndoBuilder *publdr) = 0;
	virtual LONG SaveToEs(	 CTxtRange *prg, LONG lStreamFormat,
							 EDITSTREAM *pes ) = 0;

	// converstion routines

	virtual HGLOBAL AnsiPlainTextFromRange( CTxtRange *prg ) = 0;
	virtual HGLOBAL UnicodePlainTextFromRange( CTxtRange *prg ) = 0;

};

#endif // !__DTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_dispprt.h ===
/*
 *  _DISPPRT.H
 *  
 *  Purpose:
 *      CDisplayPrinter class. Multi-line display for printing.
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Jon Matousek
 */

#ifndef _DISPPRT_H
#define _DISPPRT_H

#include "_dispml.h"


class CDisplayPrinter : public CDisplayML
{
public:
					CDisplayPrinter (
						CTxtEdit* ped, 
						HDC hdc, 
						RECT *prc, 
						SPrintControl prtcon);

    virtual BOOL    IsMain() const { return FALSE; }

	inline RECT 	GetPrintView( void ) { return _rcPrintView; }
	inline void 	SetPrintView( const RECT & rc ) { _rcPrintView = rc; }

	inline RECT		GetPrintPage(void) { return _rcPrintPage;}
	inline void		SetPrintPage(const RECT &rc) {_rcPrintPage = rc;}

    // Format range support
    LONG    		FormatRange(LONG cpFirst, LONG cpMost, BOOL fWidowOrphanControl);

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight);

	virtual BOOL	IsPrinter() const;

	void			SetPrintDimensions(RECT *prc);


protected:

	RECT			_rcPrintView;	// for supporting client driven printer banding.
	RECT			_rcPrintPage;	// the entire page size

	SPrintControl	_prtcon;		// Control print behavior
	LONG			_cpForNumber;	// cp of cached number.
	WORD			_wNumber;		// Cached value of paragraph number
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_disp.h ===
/*
 *  _DISP.H
 *  
 *  Purpose:
 *		DISP class
 *  
 *  Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _DISP_H
#define _DISP_H

#include "_devdsc.h"
#include "_line.h"
#include "_edit.h"

class CDisplay;
class CLed;
class CLinePtr;
class CTxtStory;
class CTxtEdit;
class CRchTxtPtr;
class CTxtRange;
class CTxtSelection;

#define INVALID_ZOOM_DENOMINATOR 0

// Auto scroll timing
#define cmsecScrollDelay	500
#define cmsecScrollInterval	50


class CDrawInfo;

// ============================  CLed  ====================================
// Line Edit Descriptor - describes impact of an edit on line breaks

class CLed
{
public:
	LONG _cpFirst;			// cp of first affected line
	LONG _iliFirst;			// index of first affected line
	LONG _vpFirst;			// y offset of first affected line

	LONG _cpMatchOld;		// pre-edit cp of first matched line
	LONG _iliMatchOld;		// pre-edit index of first matched line
	LONG _vpMatchOld;		// pre-edit y offset of first matched line

	LONG _cpMatchNew;		// post-edit cp of first matched line
	LONG _iliMatchNew;		// post-edit index of first matched line
	LONG _vpMatchNew;		// post-edit y offset of bottom of first matched line
	LONG _vpMatchNewTop;	// post-edit y offset of top of first matched line

public:
	CLed();
	
	void	SetMax(const CDisplay * const pdp);
};

inline CLed::CLed()
{
#ifdef DEBUG
	// We set this invalid so that we can assert on it in debug builds.
	_vpMatchNewTop = -1;

#endif // DEBUG
}

// An enumeration describing the various display actions we can perform on the selection
enum SELDISPLAYACTION
{
	selSetHiLite,
	selSetNormal,
	selUpdateHiLite,
	selUpdateNormal
};

class CDispDim
{
public:
	CDispDim(){ZeroMemory(this, sizeof(*this));}
	LONG	dup;
	DWORD	lstflow;
};

// Forward declaration to prevent recursion of definitions
class CAccumDisplayChanges;

// ==========================  CDisplay  ====================================
// Display - keeps track of line breaks for a device.
// All measurements are in pixels on rendering device,

class CDisplay : public CDevDesc, public ITxNotify
{
	friend class CLinePtr;
	friend class CLed;

#ifdef DEBUG
public:
	BOOL Invariant ( void ) const;
private:
#endif

public:
	// Average char width of system font
	static INT GetDupSystemFont() { return W32->GetDupSystemFont(); }

	// Height of system font
	static INT GetDvpSystemFont() { return W32->GetDvpSystemFont(); }

private:
	static DWORD _dwTimeScrollNext; // time for next scroll step
	static DWORD _dwScrollLast;	// last scroll action
	
	CDrawInfo *	 _pdi;			// Draw info parameters

protected:
	CAccumDisplayChanges *_padc;	// Accumulated display changes if frozen

	DWORD	_fBgndRecalc		:1; // Background recalc is running
	DWORD	_fDeferUpdateScrollBar:1; // Currently deferring updating scroll bars
	DWORD	_fUScrollEnabled	:1; // Horizontal scrolling enabled
	DWORD	_fInBkgndRecalc		:1; // Avoid reentrant background recalc
	DWORD	_fLineRecalcErr		:1; // Error occured during background recalc
	DWORD	_fNoUpdateView		:1; // Don't update visible view
	DWORD	_fWordWrap			:1; // Word wrap text
	DWORD	_fNeedRecalc		:1; // Recalc line is needed
	DWORD	_fRecalcDone		:1; // Is line recalc done ?
	DWORD	_fViewChanged		:1; // Visible view rect has changed since last Draw
	DWORD	_fUpdateScrollBarDeferred:1;// scroll bars need to be updated
	DWORD	_fVScrollEnabled	:1; // vertical scrolling enabled
	DWORD	_fUpdateCaret		:1; // Whether Draw needs to update cursor
	DWORD	_fActive			:1; // Whether this display is active
	DWORD	_fRectInvalid		:1; // Entire client rectangle has been 
									// invalidated. Used only in SL. Put
									// here, as usual, to save space
	DWORD	_fSmoothVScroll		:1;	// Timer for smooth scrolling installed
	DWORD	_fFinishSmoothVScroll:1;// TRUE if we're winding down the current smooth scroll
	DWORD	_fMultiLine			:1;	// TRUE iff this CDisplay is multiline

	LONG	_dupView;	  			// View rect width
	LONG	_dvpView;	 			// View rect height
	LONG	_dvpClient;   			// Height of client rect unmodified by inset.

	LONG	_upScroll;		 		// Horizontal scroll position of visible view

	LONG	_lTempZoomDenominator;	// Zoom for GetNaturalSize
	LONG	_cpFirstVisible;		// cp at start of first visible line

 	// Smooth scroll support.
	int		_smoothVDelta;			// Current # pixels * 1000 to smooth scroll by
	int		_continuedsmoothVDelta;	// At end of 1 smooth scroll cycle, start new with this
	int		_nextSmoothVScroll;		// Fractional amount not yet smooth scrolled
	int		_totalSmoothVScroll;	// Remaining # of device units to smooth scroll
	int		_continuedSmoothVScroll;// At end of 1 smooth scroll cycle, start new with this

private:
	void 	UpdateViewRectState(const RECTUV *prcClient);	

protected:
	LONG	GetSelBarInPixels() const;
	
	friend class CLinePtr;

	LONG			SetClientHeight(LONG yNewClientHeight);
	virtual void	InitLinePtr ( CLinePtr & ) = 0;
	
	// Line break recalc.
	virtual BOOL	RecalcView(BOOL fUpdateScrollBars, RECTUV* prc = NULL) = 0;

	// Rendering
	virtual void	Render(const RECTUV &rcView, const RECTUV &rcRender) = 0;

	// Scrollbar
	virtual BOOL	UpdateScrollBar(INT nBar, BOOL fUpdateRange = FALSE) = 0;
	void			GetViewDim(LONG& dup, LONG& dvp);
	void			SetCpFirstVisible(LONG cp)		{_cpFirstVisible = cp;};
	LONG			ConvertScrollToUPos(LONG uPos);
	LONG			ConvertUPosToScrollPos(LONG uPos);
	virtual LONG	GetMaxUScroll() const = 0;

public:
	virtual	LONG	ConvertVPosToScrollPos(LONG vPos);

			CDisplay (CTxtEdit* ped);
	virtual CDisplay::~CDisplay();

	virtual BOOL	Init();
			void	InitFromDisplay(const CDisplay *pdp);

	// Device context management
	virtual BOOL	SetMainTargetDC(HDC hdc, LONG dulTarget);
	virtual BOOL	SetTargetDC( HDC hdc, LONG dxpInch = -1, LONG dypInch = -1);


	// Getting properties
			CTxtEdit*		GetPed() const			{ return _ped;}
			CTxtStory*		GetStory() const		{ return _ped->GetTxtStory();}
			const CDevDesc*	GetDdRender() const		{ return this;}
	virtual const CDevDesc*	GetDdTarget() const		{ return NULL; }
			const CDevDesc*	GetTargetDev() const;
	
	virtual BOOL	IsMain() const = 0;
	virtual BOOL	IsPrinter() const;
			BOOL	IsRecalcDone() const			{ return _fRecalcDone;}
			BOOL	IsMultiLine() const				{ return _fMultiLine;}
			BOOL	IsTransparent() const			{ return _ped->IsTransparent();}
	virtual BOOL	GetWordWrap() const;
			void	SetWordWrap(BOOL fNoWrap);

			void	PointFromPointuv(POINT &pt, const POINTUV &ptuv, BOOL fExtTextOut = FALSE) const;
			void	PointuvFromPoint(POINTUV &ptuv, const POINT &pt) const;
			void	RectFromRectuv(RECT &rc, const RECTUV &rcuv) const;
			void	RectuvFromRect(RECTUV &rcuv, const RECT &rc) const;

	// Pagination
	virtual HRESULT	GetPage(LONG *piPage, DWORD dwFlags, CHARRANGE *pcrg);
			BOOL	IsInPageView() const			{ return _ped->IsInPageView();}
	virtual	BOOL	Paginate(LONG ili, BOOL fRebindFirstVisible);
	virtual	HRESULT	SetPage(LONG iPage);
	virtual LONG	GetCurrentPageHeight() const	{return 0;};

			HRESULT	GetCachedSize(LONG *pdupClient, LONG *pdvpClient) const;

	virtual TFLOW	GetTflow() const {return tflowES;}
	virtual void	SetTflow(TFLOW tflow) {}
	// When wrapping to printer, return the width we are to wrap to (or 0
	// if we are not in WYSIWYG mode.)
	virtual LONG	GetDulForTargetWrap() const		{ return 0;}

	// Width of widest line
	virtual LONG	GetDupLineMax() const = 0;
	// Height and line count (all text)
	virtual LONG	GetHeight() const = 0;
	virtual LONG	GetResizeHeight() const = 0;
	virtual LONG	LineCount() const = 0;

	// View rectangle
			void	GetViewRect(RECTUV &rcView, const RECTUV *prcClient = NULL);
			LONG	GetDupView() const			{ return _dupView;}
			LONG	GetDvpView() const			{ return _dvpView;}

	// Visible view properties
	virtual LONG	GetCliVisible(
						LONG *pcpMostVisible = NULL,
						BOOL fLastCharOfLastVisible = FALSE) const = 0;

			LONG	GetFirstVisibleCp() const		{return _cpFirstVisible;};
	virtual LONG	GetFirstVisibleLine() const = 0;

	// Line info
	virtual LONG	GetLineText(LONG ili, TCHAR *pchBuff, LONG cchMost) = 0;
	virtual LONG	CpFromLine(LONG ili, LONG *pdvp = NULL) = 0;
	
	virtual LONG	LineFromCp(LONG cp, BOOL fAtEnd) = 0;

	// Point <-> cp conversion
	virtual LONG	CpFromPoint(POINTUV pt, 
						const RECTUV *prcClient,
						CRchTxtPtr * const ptp, 
						CLinePtr * const prp, 
						BOOL fAllowEOL,
						HITTEST *pHit = NULL,
						CDispDim *pdispdim = NULL,
						LONG *pcpActual = NULL,
						CLine *pliParent = NULL) = 0;

	virtual LONG	PointFromTp (
						const CRchTxtPtr &tp, 
						const RECTUV *prcClient,
						BOOL fAtEnd,	
						POINTUV &pt,
						CLinePtr * const prp, 
						UINT taMode,
						CDispDim *pdispdim = NULL) = 0;

	// View recalc and updating
			void	SetUpdateCaret()		{_fUpdateCaret = TRUE;}
			void	SetViewChanged()		{_fViewChanged = TRUE;}
			void	InvalidateRecalc()		{_fNeedRecalc = TRUE;}
	virtual	void	RecalcLine(LONG cp)	{}
			BOOL	RecalcView (const RECTUV &rcView, RECTUV* prcClient = NULL);
			BOOL	UpdateView();
	virtual BOOL	UpdateView(CRchTxtPtr &rtp, LONG cchOld, LONG cchNew) = 0;

	// Rendering
			HRESULT Draw(HDC hicTargetDev,
						 HDC hdcDraw,
						 LPCRECT prcClient,
						 LPCRECT prcWBounds,
						 LPCRECT prcUpdate,
						 BOOL (CALLBACK * pfnContinue) (DWORD),
						 DWORD dwContinue);

	// Background recalc
	virtual void	StepBackgroundRecalc();
	virtual BOOL	WaitForRecalc(LONG cpMax, LONG vpMax);
	virtual BOOL	WaitForRecalcIli(LONG ili);
	virtual BOOL	WaitForRecalcView();

	// Scrolling 
			LONG	GetUpScroll() const			  {return _upScroll;} 
	virtual LONG	GetVpScroll() const			  {return 0;}
			void	UScroll(WORD wCode, LONG uPos);
	virtual LRESULT VScroll(WORD wCode, LONG vPos);
	virtual void	LineScroll(LONG cli, LONG cch);
	virtual void	FractionalScrollView ( LONG vDelta );
	virtual void	ScrollToLineStart(LONG iDirection);
	virtual LONG	CalcVLineScrollDelta ( LONG cli, BOOL fFractionalFirst );
			BOOL	DragScroll(const POINT * ppt);	 // outside of client rect.
			BOOL	AutoScroll(POINTUV pt, const WORD upScrollInset, const WORD vpScrollInset);
	virtual BOOL	ScrollView(LONG upScroll, LONG vpScroll, BOOL fTracking, BOOL fFractionalScroll) = 0;
	virtual	LONG	AdjustToDisplayLastLine(LONG yBase,	LONG vpScroll);

     // Smooth Scrolling 
			void	SmoothVScroll ( int direction, WORD cLines, int speedNum, int speedDenom, BOOL fMouseRoller );
			void	SmoothVScrollUpdate();
			BOOL	CheckInstallSmoothVScroll();
			void	CheckRemoveSmoothVScroll();
			void	FinishSmoothVScroll();
			BOOL	IsSmoothVScolling() { return _fSmoothVScroll; }

	// Scrollbars
	virtual LONG	GetScrollRange(INT nBar) const;
			BOOL	IsUScrollEnabled();
			BOOL	IsVScrollEnabled() {return _fVScrollEnabled; }

	// Resizing
			void	OnClientRectChange(const RECT &rcClient);
			void	OnViewRectChange(const RECT &rcView);
			HRESULT RequestResize();

	// Selection 
	virtual BOOL	InvertRange(LONG cp,
		                        LONG cch,
								SELDISPLAYACTION selAction) = 0;

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight) = 0;

	LONG			GetZoomDenominator() const;
	LONG			GetZoomNumerator() const;
	LONG			Zoom(LONG x) const;
	LONG			UnZoom(LONG x) const;

	LONG		 	HimetricUtoDU(LONG u) const;
	LONG		 	HimetricVtoDV(LONG v) const;
	LONG			DUtoHimetricU(LONG du)  const;
	LONG			DVtoHimetricV(LONG dv) const;

	HRESULT 		TransparentHitTest(
						HDC hdc,
						LPCRECT prcClient,
						POINTUV pt,
						DWORD *pHitResult);

	HRESULT 		RoundToLine(HDC hdc, LONG width, LONG *pheight);
	void			SetTempZoomDenominator(LONG lZoomDenominator)
					{ 
						_lTempZoomDenominator = lZoomDenominator;
					}
	LONG			GetTempZoomDenominator()
					{ 
						return _lTempZoomDenominator;
					}
	void			ResetTempZoomDenominator() 
					{ 
						_lTempZoomDenominator = INVALID_ZOOM_DENOMINATOR;
					}
	void			SetDrawInfo(
						CDrawInfo *pdi, 
						DWORD dwDrawAspect,	//@parm draw aspect
						LONG  lindex,		//@parm currently unused
						void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
						DVTARGETDEVICE *ptd,//@parm information on target device								
						HDC hicTargetDev);	//@parm	target information context

	void			ReleaseDrawInfo();
	void 			ResetDrawInfo(const CDisplay *pdp);
	DWORD 			GetDrawAspect() const;
	LONG 			GetLindex() const;
	void *			GetAspect() const;
	DVTARGETDEVICE *GetPtd() const;
	void			SetActiveFlag(BOOL fActive) { _fActive = fActive; }
	BOOL			IsActive()	{ return _fActive; }
	virtual CDisplay *Clone() const = 0;

	// Support for freezing the display
	BOOL			IsFrozen();
	void			SaveUpdateCaret(BOOL fScrollIntoView);
	void			Freeze();
	void			SetNeedRedisplayOnThaw(BOOL fNeedRedisplay);
	void			Thaw();

	//
	// ITxNotify Interface
	//
	virtual void 	OnPreReplaceRange( 
						LONG cp, 
						LONG cchDel, 
						LONG cchNew,
						LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );

	virtual void 	OnPostReplaceRange( 
						LONG cp, 
						LONG cchDel, 
						LONG cchNew,
						LONG cpFormatMin, 
						LONG cpFormatMax, NOTIFY_DATA *pNotifyData );

	virtual void	Zombie();
};

// Defines the draw info class. It is included here to prevent loops
// in dependencies that would require no inlining for functions dealing
// with this
#include	"_drwinfo.h"

/*
 *	CDisplay::ResetDrawInfo
 *
 *	@mfunc	Sets draw info using different display
 *
 *	@rdesc	void
 *
 */
inline void CDisplay::ResetDrawInfo(
	const CDisplay *pdp)	//@parm Display to use for draw information
{
	_pdi = pdp->_pdi;
}

/*
 *	CDisplay::ResetDrawInfo
 *
 *	@mfunc	Gets lindex as passed most recently from the host.
 *
 *	@rdesc	draw aspect
 *
 */
inline DWORD CDisplay::GetDrawAspect() const
{
	return _pdi ? _pdi->GetDrawAspect() : DVASPECT_CONTENT; 
}

/*
 *	CDisplay::GetLindex
 *
 *	@mfunc	Gets lindex as passed most recently from the host.
 *
 *	@rdesc	lindex
 *
 */
inline LONG CDisplay::GetLindex() const
{
	return _pdi ? _pdi->GetLindex() : -1; 
}

/*
 *	CDisplay::GetAspect
 *
 *	@mfunc	Gets aspect as passed most recently from the host.
 *
 *	@rdesc	Aspect data
 *
 */
inline void *CDisplay::GetAspect() const
{
	return _pdi ? _pdi->GetAspect() : NULL; 
}

/*
 *	CDisplay::GetPtd
 *
 *	@mfunc	Gets device target as passed most recently from the host.
 *
 *	@rdesc	DVTARGETDEVICE or NULL
 *
 */
inline DVTARGETDEVICE *CDisplay::GetPtd() const
{
	return _pdi ? _pdi->GetPtd() : NULL; 
}

/*
 *	CDisplay::IsFrozen
 *
 *	@mfunc	Return whether display is currently frozen
 *
 *	@rdesc	
 *		TRUE - display is frozen <nl>
 *		FALSE - display is not frozen
 *
 */
inline BOOL CDisplay::IsFrozen()
{
	return _padc != NULL;
}

/*
 *	CFreezeDisplay
 *	
 * 	@class	This class is used to freeze and guranatee that the display
 *			unfreeze a display when it passes out of its context.
 *
 *
 */
class CFreezeDisplay
{
public:	
						CFreezeDisplay(CDisplay *pdp); //@cmember Constructor Freezes

						~CFreezeDisplay();			//@cmember Destructor - Thaws

private:

	CDisplay *			_pdp;						//@cmember Display to freeze
};

/*
 *	CFreezeDisplay::CFreezeDisplay()
 *
 *	@mfunc
 *		Initialize object and tell the input display to freeze
 */
inline CFreezeDisplay::CFreezeDisplay(CDisplay *pdp) : _pdp(pdp)
{
	pdp->Freeze();
}

/*
 *	CFreezeDisplay::CFreezeDisplay()
 *
 *	@mfunc
 *		Free object and tell display to thaw.
 */
inline CFreezeDisplay::~CFreezeDisplay()
{
	_pdp->Thaw();
}

void GetDupDvpFromRect(const RECT &rc, TFLOW tflow, LONG &dup, LONG &dvp);
void GetDxpDypFromDupDvp(LONG dup, LONG dvp, TFLOW tflow, LONG &dxp, LONG &dyp);
void GetDxpDypFromRectuv(const RECTUV &rc, TFLOW tflow, LONG &dxp, LONG &dyp);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_devdsc.h ===
/*
 *	_DEVDSC.H
 *	
 *	Purpose:
 *		CDevDesc (Device Descriptor) class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 */

#ifndef _DEVDSC_H
#define _DEVDSC_H


class CTxtEdit;

// device descriptor
class CDevDesc
{
	friend class CMeasurer;
protected:
	CTxtEdit * _ped;        // used to GetDC and ReleaseDC
	
	HDC 	_hdc;			// hdc for rendering device
	BOOL	_fMetafile;		// Is this device a metafile.

	SHORT	_dxpInch;		// device units per horizontal "inch"
	SHORT	_dypInch;		// device units per vertical "inch"

	HDC		GetScreenDC () const;
	void	ReleaseScreenDC (HDC hdc) const;

public:
	CDevDesc(CTxtEdit * ped)
	{
		_fMetafile = FALSE;
		_ped = ped;
		_hdc = NULL;
		_dxpInch = 0;
		_dypInch = 0;
	}

    // Test validity of device descriptor 
    // (whether SetDC has been properly called)
    BOOL    IsValid() const         {return _dxpInch != 0 && _dypInch != 0;}

	BOOL 	IsMetafile() const
	{
		if(!_hdc)
			return FALSE;

		return _fMetafile;
	}

	BOOL	SetDC(HDC hdc, LONG dxpInch = -1, LONG dypInch = -1);

	void	SetMetafileDC(
				HDC hdcMetafile, 
				LONG xMeasurePerInch,
				LONG yMeasurePerInch);

	void 	ResetDC() { SetDC(NULL); }

	//REVIEW (keithcu) GetScreenDC/ReleaseScreenDC needed?
	HDC	 	GetDC() const
	{
		if(_hdc)
			return _hdc;
		return GetScreenDC();
	}

	void	ReleaseDC(HDC hdc) const
	{
		if(!_hdc)
			ReleaseScreenDC(hdc);
	}

	// REVIEW (keithcu) Verify callers of these routines logic...Think of a way to make it hard for people
	// to screw up?
	// Methods for converting between pixels and himetric
	LONG 	HimetricXtoDX(LONG xHimetric) const { return W32->HimetricToDevice(xHimetric, _dxpInch); }
	LONG 	HimetricYtoDY(LONG yHimetric) const { return W32->HimetricToDevice(yHimetric, _dypInch); }
	LONG	DXtoHimetricX(LONG dx)  const { return W32->DeviceToHimetric(dx, _dxpInch); }
	LONG	DYtoHimetricY(LONG dy) const { return W32->DeviceToHimetric(dy, _dypInch); }

	void	LRtoDR(RECT &rcDest, const RECT &rcSrc, TFLOW tflow) const;
	LONG	DXtoLX(LONG x) const	
	{
		AssertSz(_dxpInch, "CDevDesc::DXtoLX() - hdc has not been set");
		return MulDiv(x, LX_PER_INCH, _dxpInch);
	}

	LONG	DYtoLY(LONG y) const	
	{
	    AssertSz(_dypInch, "CDevDesc::DYtoLY() - hdc has not been set");
		return MulDiv(y, LY_PER_INCH, _dypInch);
	}

	LONG	LXtoDX(LONG x) const
	{
	    AssertSz(_dxpInch, "CDevDesc::LXtoDX() - hdc has not been set");
		return MulDiv(x, _dxpInch, LX_PER_INCH);
	}
	LONG	LYtoDY(LONG y) const
	{
	    AssertSz(_dypInch, "CDevDesc::LYtoDY() - hdc has not been set");
		return MulDiv(y, _dypInch, LY_PER_INCH);
	}

	BOOL 	SameDevice(const CDevDesc *pdd) const
	{
		return (_dxpInch == pdd->_dxpInch) && (_dypInch == pdd->_dypInch) ? TRUE : FALSE;
	}

	// Assignment
	CDevDesc& 	operator = (const CDevDesc& dd)
	{
		_hdc = dd._hdc;
		_dxpInch = dd._dxpInch;
		_dypInch = dd._dypInch;
		return *this;
	}

	// Compares two device descriptors
	BOOL 	operator == (const CDevDesc& dd) const
	{
		return 	_hdc == dd._hdc;
	}

	BOOL 	operator != (const CDevDesc& dd) const
	{
		return !(*this == dd);
	}

	LONG	GetDxpInch() const
	{
		AssertSz(_dxpInch != 0, "CDevDesc::GetDxpInch _dxpInch is 0");
		return _dxpInch;
	}

	LONG	GetDypInch() const
	{
		AssertSz(_dypInch != 0, "CDevDesc::GetDypInch _dypInch is 0");
		return _dypInch;
	}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_doc.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _DOC.H	CTxtStory declaration |
 *	
 *	Purpose:
 *		Encapsulate the plain-text document data (text blocks, cchText)
 *	
 *	Original Authors: <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		6/25/95	alexgo	commented and cleaned up
 *
 */

#ifndef _DOC_H
#define _DOC_H

#include "_array.h"

#define cbBlockCombine 	CbOfCch(3072)
#define cbBlockMost 	CbOfCch(49152)
#define cbBlockInitial 	CbOfCch(4096)
#define cchGapInitial 	128
#define cchBlkCombmGapI	(CchOfCb(cbBlockCombine) - cchGapInitial)
#define cchBlkInitmGapI	(CchOfCb(cbBlockInitial) - cchGapInitial)

#define cchBlkInsertmGapI	(CchOfCb(cbBlockInitial)*5 - cchGapInitial)

class CDisplay;
class CTxtPtr;
class CTxtArray;

/*
 *	CTxtRun
 *
 *	@class	Formalizes a run of text. A range of text with same attribute, 
 * (see CFmtDesc) or within the same line (see CLine), etc. Runs are kept
 * in arrays (see CArray) and are pointed to by CRunPtr's of various kinds.
 * In general the character position of a run is computed by summing the
 * length of all preceding runs, altho it may be possible to start from
 * some other cp, e.g., for CLines, from CDisplay::_cpFirstVisible.
 */

class CTxtRun
{
//@access Public Methods and Data
public:
	CTxtRun()	{_cch = 0;}			//@cmember Constructor
	LONG _cch;						//@cmember Count of characters in run
};

/*
 *	CTxtBlk
 *
 *	@class	A text block; a chunk of UNICODE text with a buffer gap to allow 
 *	for easy insertions and deletions.
 *
 *	@base	protected | CTxtRun
 *
 *	@devnote	A text block may have four states: <nl>
 *		NULL:	No data allocated for the block <nl>
 *				<md CTxtBlk::_pch> == NULL 	<nl>
 *				<md CTxtRun::_cch> == 0		<nl>
 *				<md CTxtBlk::_ibGap> == 0	<nl>
 *				<md CTxtBlk::_cbBlock> == 0	<nl>
 *
 *		empty:	All of the available space is a buffer gap <nl>
 *				<md CTxtBlk::_pch> != NULL 	<nl>
 *				<md CTxtRun::_cch> == 0		<nl>
 *				<md CTxtBlk::_ibGap> == 0	<nl>
 *				<md CTxtBlk::_cbBlock> <gt>= 0	<nl>
 *
 *		normal:	There is both data and a buffer gap <nl>
 *				<md CTxtBlk::_pch> != NULL 	<nl>
 *				<md CTxtRun::_cch> != 0		<nl>
 *				<md CTxtBlk::_ibGap> != 0	<nl>
 *				<md CTxtBlk::_cbBlock> <gt>= 0	<nl>
 *		
 *		full:	The buffer gap is of zero size <nl>
 *				<md CTxtBlk::_pch> != NULL 	<nl>
 *				<md CTxtRun::_cch> <gt>= 0	<nl>
 *				<md CTxtBlk::_ibGap> <gt> 0	<nl>
 *				<md CTxtBlk::_cbBlock> == _cch * sizeof(WCHAR) <nl>
 *
 *	The position of the buffer gap is given by _ibGap.  With _cch and _cbBlock,
 *	it's possible to figure out the *size* of the gap by simply calculating:
 *	<nl>
 *		size = _cbBlock - (_cch * sizeof(character))
 *
 */

class CTxtBlk : public CTxtRun
{
	friend class CTxtPtr;
	friend class CTxtArray;

//@access Protected Methods
protected:
									//@cmember	Constructor
	CTxtBlk()	{InitBlock(0);}
									//@cmember	Destructor
	~CTxtBlk()	{FreeBlock();}

									//@cmember	Initializes the block to the 
									//# of bytes given by <p cb>	
	BOOL 	InitBlock(LONG cb);
									//@cmember	Sets a block to the NULL state
	VOID 	FreeBlock();
									//@cmember	Moves the buffer gap in a 
									//block	
	VOID 	MoveGap(LONG ichGap);
									//@cmember	Resizes a block to <p cbNew> 
									//bytes
	BOOL 	ResizeBlock(LONG cbNew);

//@access Private Data
private:
									//@cmember	Pointer to the text data
	WCHAR 	*_pch;			
									//@cmember	BYTE offset of the gap
	LONG 	_ibGap;			
									//@cmember	size of the block in bytes
	LONG 	_cbBlock;		
};


/* 
 *	CTxtArray
 *
 *	@class	A dynamic array of <c CTxtBlk> classes
 *
 *	@base public | CArray<lt>CTxtBlk<gt>
 */
class CTxtArray : public CArray<CTxtBlk>
{
	friend class CTxtPtr;
	friend class CTxtStory;

//@access 	Public methods
public:
#ifdef DEBUG
									//@cmember	Invariant support
	BOOL Invariant() const;
#endif	// DEBUG
									//@cmember	Constructor
	CTxtArray();
									//@cmember	Destructor
	~CTxtArray();
									//@cmember	Gets the total number of
									//characters in the array.
	LONG 	CalcTextLength() const;

	// Get access to cached CCharFormat and CParaFormat structures
	const CCharFormat* 	GetCharFormat(LONG iCF);
	const CParaFormat* 	GetParaFormat(LONG iPF);

	LONG	Get_iCF()			{return _iCF;}
	LONG	Get_iPF()			{return _iPF;}
	void	Set_iCF(LONG iCF)	{_iCF = (SHORT)iCF;}
	void	Set_iPF(LONG iPF)	{_iPF = (SHORT)iPF;}

//@access Private methods
private:
									//@cmember	Adds cb blocks
	BOOL 	AddBlock(LONG itbNew, LONG cb);
									//@cmember	Removes ctbDel blocks
	void 	RemoveBlocks(LONG itbFirst, LONG ctbDel);
									//@cmember	Combines blocks adjacent to itb
	void 	CombineBlocks(LONG itb);
									//@cmember	Splits a block
	BOOL 	SplitBlock(LONG itb, LONG ichSplit, LONG cchFirst, 
				LONG cchLast, BOOL fStreaming);
									//@cmember	Shrinks all blocks to minimal
									//			size
	void 	ShrinkBlocks();		
									//@cmember	Copies chunk of text into 
									//			location given 
	LONG	GetChunk(TCHAR **ppch, LONG cch, TCHAR *pchChunk, LONG cchCopy) const;

	LONG	_cchText;				//@cmember Total text character count
	SHORT	_iCF;					//@cmember Default CCharFormat index
	SHORT	_iPF;
};


class CBiDiLevel
{
public:
    BOOL operator == (const CBiDiLevel& level) const
    {
        return _value == level._value && _fStart == level._fStart;
    }
    BOOL operator != (const CBiDiLevel& level) const
    {
        return _value != level._value || _fStart != level._fStart;
    }

	BYTE	_value;				// embedding level (0..15)
	BYTE	_fStart :1;			// start a new level e.g. "{{abc}{123}}"
};

/*
 *	CFormatRun
 *
 *	@class	A run of like formatted text, where the format is indicated by an
 *	and index into a format table
 *
 *	@base	protected | CTxtRun
 */
class CFormatRun : public CTxtRun
{
//@access 	Public Methods
public:
	friend class CFormatRunPtr;
	friend class CTxtRange;
	friend class CRchTxtPtr;

	BOOL SameFormat(CFormatRun* pRun)
	{
		return 	_iFormat == pRun->_iFormat && 
				_level._value == pRun->_level._value && 
				_level._fStart == pRun->_level._fStart;
	}

	short	_iFormat;			//@cmember index of CHARFORMAT/PARAFORMAT struct
	CBiDiLevel _level;			//@cmember BiDi level
};

//@type	CFormatRuns | An array of CFormatRun classes
typedef CArray<CFormatRun> CFormatRuns;


/*
 *	CTxtStory
 *
 *	@class
 *		The text "Document".  Maintains the state information related to the
 *		actual data of a document (such as text, formatting information, etc.)
 */

class CTxtStory
{
	friend class CTxtPtr;
	friend class CRchTxtPtr;
	friend class CReplaceFormattingAE;

//@access Public Methods
public:
	CTxtStory();				//@cmember	Constructor
	~CTxtStory();				//@cmember	Destructor

								//@cmember	Get total text length  
    LONG GetTextLength() const
        {return _TxtArray._cchText;}

								//@cmember	Get Paragraph Formatting runs
	CFormatRuns *GetPFRuns()	{return _pPFRuns;}
								//@cmember	Get Character Formatting runs
	CFormatRuns *GetCFRuns()	{return _pCFRuns;}
								
	void DeleteFormatRuns();	//@cmember	Converts to plain text from rich

	const CCharFormat* 	GetCharFormat(LONG iCF)
							{return _TxtArray.GetCharFormat(iCF);}
	const CParaFormat* 	GetParaFormat(LONG iPF)
							{return _TxtArray.GetParaFormat(iPF);}

	LONG Get_iCF()			{return _TxtArray.Get_iCF();}
	LONG Get_iPF()			{return _TxtArray.Get_iPF();}
	void Set_iCF(LONG iCF)	{_TxtArray.Set_iCF(iCF);}
	void Set_iPF(LONG iPF)	{_TxtArray.Set_iPF(iPF);}

#ifdef DEBUG
	void DbgDumpStory(void);	// Debug story dump member
#endif

//@access	Private Data
private:
	CTxtArray 		_TxtArray;	//@cmember	Plain-text runs
	CFormatRuns *	_pCFRuns;	//@cmember	Ptr to Character-Formatting runs
	CFormatRuns *	_pPFRuns;	//@cmember	Ptr to Paragraph-Formatting runs
};

#endif		// ifndef _DOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_dispml.h ===
/*
 *  _DISPML.H
 *  
 *  Purpose:
 *      CDisplayML class. Multi-line display.
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 */

#ifndef _DISPML_H
#define _DISPML_H

#include "_disp.h"
#include "_layout.h"

class CDisplayML : public CDisplay, public CLayout
{
public: 

#ifdef DEBUG
	BOOL	Invariant(void) const;
#endif 

	friend class CLayout;
    friend class CLinePtr;
    friend class CLed;
	friend BOOL CTxtEdit::OnDisplayBand(const RECT *prc, BOOL fPrintFromDraw);
	friend class CDisplayPrinter;

private:
    LONG _cpCalcMax;		// last cp for which line breaks have been calc'd + 1
    LONG _vpCalcMax;		// height of calculated lines
    LONG _cpWait;			// cp WaitForRecalc() is waiting for (or < 0)
    LONG _vpWait;			// vp WaitForRecalc() is waiting for (or < 0)

    LONG _vpScroll;			// vertical scroll position of visible view
    LONG _dvpFirstVisible;	// offset from top of view to first visible line
    LONG _iliFirstVisible;	// index of first visible line

    LONG _dulTarget;		// max width of this display (in log unit)
    LONG _dvlTarget;		// max height of this display (-1 for infinite)
    LONG _dupLineMax;		// width of longest calculated line

    CDevDesc *_pddTarget;	// Target device (if any).

	LONG _sPage;			// Page # of _iliFirstVisible if PageView

	WORD _fInRecalcScrollBars:1; // Are trying to recalc scrollbars
    
private:
    // Helpers
            void    InitVars();
			void 	RecalcScrollBars();
			LONG	ConvertScrollToVPos(LONG vPos);
			LONG	GetMaxVpScroll() const;
			BOOL	CreateEmptyLine();
			LONG	CalcScrollHeight(LONG yHeight) const;
			void	RebindFirstVisible(BOOL fResetCp = FALSE);
			void	Set_yScroll(LONG cp);
			void	Sync_yScroll();

    // Line/page breaking
            BOOL    RecalcLines(CRchTxtPtr &rtp, BOOL fWait);
            BOOL    RecalcLines(CRchTxtPtr &rtp, LONG cchOld, LONG cchNew,
								BOOL fBackground, BOOL fWait, CLed *pled);
            BOOL    RecalcSingleLine(CLed *pled);
            LONG    CalcDisplayDup();
			LONG	CalculatePage(LONG iliFirst);

    // Rendering
    virtual void    Render(const RECTUV &rcView, const RECTUV &rcRender);
            void    DeferUpdateScrollBar();
            BOOL    DoDeferredUpdateScrollBar();
    virtual BOOL    UpdateScrollBar(INT nBar, BOOL fUpdateRange = FALSE );

protected:
	virtual LONG	GetMaxUScroll() const;

public:
	virtual	BOOL	Paginate(LONG iLineFirst, BOOL fRebindFirstVisible = FALSE);
	virtual	HRESULT	GetPage(LONG *piPage, DWORD dwFlags, CHARRANGE *pcrg);
	virtual	HRESULT	SetPage(LONG iPage);

 	virtual	LONG	ConvertVPosToScrollPos(LONG vPos);

           CDisplayML (CTxtEdit* ped);
    virtual CDisplayML::~CDisplayML();

    virtual BOOL    Init();
	virtual BOOL	IsNestedLayout() const {return FALSE;}
	virtual TFLOW	GetTflow() const {return CLayout::GetTflow();}
	virtual void	SetTflow(TFLOW tflow) {CLayout::SetTflow(tflow);}


    // Device context management
    virtual BOOL    SetMainTargetDC(HDC hdc, LONG dulTarget);
    virtual BOOL    SetTargetDC(HDC hdc, LONG dxpInch = -1, LONG dypInch = -1);


    // Getting properties
    virtual void    InitLinePtr ( CLinePtr & );
    virtual const	CDevDesc*     GetDdTarget() const       {return _pddTarget;}

    virtual BOOL    IsMain() const							{return TRUE;}
			BOOL	IsInOutlineView() const					{return _ped->IsInOutlineView();}
	
	// When wrapping to printer, return the width we are to wrap to (or 0)
    virtual LONG    GetDulForTargetWrap() const             {return _dulTarget;}

	// Get width of widest line
    virtual LONG    GetDupLineMax() const                   {return _dupLineMax;}
    // Height and line count (of all text)
    virtual LONG    GetHeight() const                       {return _dvp;}
	virtual LONG	GetResizeHeight() const;
    virtual LONG    LineCount() const;

    // Visible view properties
    virtual LONG    GetCliVisible(
						LONG *pcpMostVisible = NULL,
						BOOL fLastCharOfLastVisible = FALSE) const;

    virtual LONG    GetFirstVisibleLine() const             {return _iliFirstVisible;}
    
    // Line info
    virtual LONG    GetLineText(LONG ili, TCHAR *pchBuff, LONG cchMost);
    virtual LONG    CpFromLine(LONG ili, LONG *pdvp = NULL);
    virtual LONG    LineFromCp(LONG cp, BOOL fAtEnd) ;

    // Point <-> cp conversion

    virtual LONG    CpFromPoint(
    					POINTUV pt, 
						const RECTUV *prcClient,
    					CRchTxtPtr * const ptp, 
    					CLinePtr * const prp, 
    					BOOL fAllowEOL,
						HITTEST *pHit = NULL,
						CDispDim *pdispdim = NULL,
						LONG *pcpActual = NULL,
						CLine *pliParent = NULL);

    virtual LONG    PointFromTp (
						const CRchTxtPtr &tp, 
						const RECTUV *prcClient,
						BOOL fAtEnd,	
						POINTUV &pt,
						CLinePtr * const prp, 
						UINT taMode,
						CDispDim *pdispdim = NULL);

    // Line break recalc
			BOOL    StartBackgroundRecalc();
    virtual VOID    StepBackgroundRecalc();
    virtual BOOL    RecalcView(BOOL fUpdateScrollBars, RECTUV* prc = NULL);
    virtual BOOL    WaitForRecalc(LONG cpMax, LONG vpMax);
    virtual BOOL    WaitForRecalcIli(LONG ili);
    virtual BOOL    WaitForRecalcView();
	virtual	void	RecalcLine(LONG cp);

    // Complete updating (recalc + rendering)
    virtual BOOL    UpdateView(CRchTxtPtr &rtp, LONG cchOld, LONG cchNew);

    // Scrolling 
    virtual LRESULT VScroll(WORD wCode, LONG uPos);
    virtual VOID    LineScroll(LONG cli, LONG cch);
	virtual VOID	FractionalScrollView ( LONG vDelta );
	virtual VOID	ScrollToLineStart(LONG iDirection);
	virtual LONG	CalcVLineScrollDelta ( LONG cli, BOOL fFractionalFirst );
    virtual BOOL    ScrollView(LONG upScroll, LONG vpScroll, BOOL fTracking, BOOL fFractionalScroll);
    virtual LONG    GetVpScroll() const { return _vpScroll; }
    virtual LONG    GetScrollRange(INT nBar) const;
	virtual	LONG	AdjustToDisplayLastLine(LONG yBase,	LONG vpScroll);

    // Selection 
    virtual BOOL    InvertRange(LONG cp, LONG cch, SELDISPLAYACTION selAction);

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight);

    // Misc. methods
            void    FindParagraph(LONG cpMin, LONG cpMost, LONG *pcpMin, LONG *pcpMost);
	virtual	LONG	GetCurrentPageHeight() const;

	virtual CDisplay *Clone() const;

#ifdef DEBUG
            void    CheckLineArray() const;
            void    DumpLines(LONG iliFirst, LONG cli);
            void    CheckView();
			BOOL	VerifyFirstVisible(LONG *pHeight = NULL);
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_dispsl.h ===
/*
 *  _DISPML.H
 *  
 *  Purpose:
 *      CDisplaySL class. Single-line display.
 *  
 *  Authors:
 *      Eric Vasilik
 */

#ifndef _DISPSL_H
#define _DISPSL_H

#include "_disp.h"

// Forward declaration
class CTxtSelection;

class CDisplaySL : public CDisplay, private CLine
{
public:

    CDisplaySL ( CTxtEdit* ped );
    
protected:


    // The following are pure functions from the base

    // Helpers
    virtual BOOL Init();
    void InitVars();
    
    // Line breaking
    BOOL RecalcLine();

    // Rendering
    virtual VOID Render(const RECTUV &rcView, const RECTUV &rcRender);
    
    // Scrolling and scroller bars
    virtual BOOL UpdateScrollBar(INT nBar, BOOL fUpdateRange = FALSE);
    virtual LONG GetScrollRange(INT nBar) const;
    
    // Getting properties
    virtual void InitLinePtr ( CLinePtr & plp );
    virtual BOOL IsMain() const;
    
	//Get width of widest line
    virtual LONG GetDupLineMax() const;
    // Width, height and line count (of all text)
    virtual LONG GetHeight() const;
	virtual LONG GetResizeHeight() const;
    virtual LONG LineCount() const;

    // Visible view properties
    virtual LONG GetCliVisible(
					LONG *pcpMostVisible = NULL,
					BOOL fLastCharOfLastVisible = FALSE) const;

    virtual LONG GetFirstVisibleLine() const;

    // Line info
    virtual LONG GetLineText(LONG ili, TCHAR *pchBuff, LONG cchMost);
    virtual LONG CpFromLine(LONG ili, LONG *pdvpLine = NULL);
    virtual LONG LineFromCp(LONG cp, BOOL fAtEnd);
    
    // Point <-> cp conversion
    virtual LONG CpFromPoint(
    				POINTUV pt, 
					const RECTUV *prcClient,
    				CRchTxtPtr * const ptp, 
    				CLinePtr * const prp, 
    				BOOL fAllowEOL,
					HITTEST *pHit = NULL,
					CDispDim *pdispdim = 0,
					LONG *pcpActual = NULL,
					CLine *pliParent = NULL);

    virtual LONG PointFromTp (
					const CRchTxtPtr &tp, 
					const RECTUV *prcClient,
					BOOL fAtEnd, 
					POINTUV &pt,
					CLinePtr * const prp, 
					UINT taMode,
					CDispDim *pdispdim = 0);

    // Line break recalc
    virtual BOOL RecalcView(BOOL fUpdateScrollBars, RECTUV* prc = NULL);
    virtual BOOL WaitForRecalcIli(LONG ili);

    // Complete updating (recalc + rendering)
    virtual BOOL UpdateView(CRchTxtPtr &tpFirst, LONG cchOld, LONG cchNew);

    // Scrolling 
    virtual BOOL ScrollView(LONG upScroll, LONG vpScroll, BOOL fTracking, BOOL fFractionalScroll);
    
    // Selection 
    virtual BOOL InvertRange(LONG cp, LONG cch, SELDISPLAYACTION selAction);

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight);

    virtual BOOL    GetWordWrap() const;

	virtual CDisplay *Clone() const;

	virtual LONG	GetMaxUScroll() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_dragdrp.h ===
/*
 *	_DRAGDRP.H
 *
 *	Purpose:
 *		class declarations for Richedit's OLE drop target and drop source
 *		objects.
 *
 *	Author:
 *		alexgo (4/28/95)
 *
 */

#ifndef __DRAGDRP_H__
#define __DRAGDRP_H__

#include	"_osdc.h"

// DWORD packed flag values.  These are assigned values such that they can
// be or'd with DataObjectInfo flags and not conflict.  We are, in effect,
// overriding the DataObjectInfo flags.
#define DF_CLIENTCONTROL	0x80000000	// QueryAcceptData says the client
										// will handle this drop.
#define DF_CANDROP			0x40000000  // We can handle the drop
#define DF_OVERSOURCE       0x20000000  // Drop target is within source range.
#define DF_RIGHTMOUSEDRAG	0x10000000	// doing a right mouse drag drop


// forward declaration.
class CCallMgr;


#define	WIDTH_DROPCARET 2

/*
 *	CDropCaret
 *
 *	Purpose:
 *		provides a caret for the location that drop will occur
 */
class CDropCaret
{
public:

					CDropCaret(CTxtEdit *ped);

					~CDropCaret();

	BOOL			Init();

	void			DrawCaret(LONG cpCur);

	void			ShowCaret(BOOL fShow);

	void			CancelRestoreCaretArea() {_dvp = -1;}

	BOOL			NoCaret() const {return -1 == _dvp;}

private:
	CTxtEdit *		_ped;
	HDC				_hdcWindow;

	LONG			_dvp;

	POINTUV			_ptCaret;
	BOOL			_fCaretOn;
};


/*
 *	CDropSource
 *
 *	Purpose:
 *		provides drag drop feedback
 */

class CDropSource : public IDropSource
{
public:
	// IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropSource methods
    STDMETHOD(QueryContinueDrag)(BOOL fEscapePressed, DWORD grfKeyState);
    STDMETHOD(GiveFeedback)(DWORD dwEffect);

	CDropSource();

private:
	// NOTE: private destructor, may not be allocated on the stack as 
	// this would break OLE's current object liveness rules
	~CDropSource();

	ULONG		_crefs;
};

/*
 *	CDropTarget
 *
 *	Purpose:
 *		an OLE drop-target object; provides a place for text to be "dropped"
 *
 */

class CDropTarget : public IDropTarget
{
public:
	// IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropTarget methods
    STDMETHOD(DragEnter)(IDataObject *pdo, DWORD grfKeyState,
            POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject *pdo, DWORD grfKeyState, POINTL pt,
           	DWORD *pdwEffect);
	
	
	CDropTarget(CTxtEdit *ped);

	// this method is used during drag drop to cache important information
	void SetDragInfo( IUndoBuilder *publdr, LONG cpMin, LONG cpMax );
	void Zombie();		//@cmember Nulls out the state of this object
						
	BOOL fInDrag();		//@cmember Tells whether another app is dragging
						// over us.

private:
	// this class is used in CDropTarget::Drop to clean up at the end
	// of the call.
	class CDropCleanup
	{
	public:
		CDropCleanup( CDropTarget *pdt )
		{	
			_pdt = pdt;
		}

		~CDropCleanup()
		{
			delete _pdt->_pcallmgr;
			_pdt->_pcallmgr = NULL;
			delete _pdt->_pdrgcrt;
			_pdt->_pdrgcrt = NULL;
		}
	private:
		CDropTarget *	_pdt;
	};

	friend class CDropCleanup;

	// NOTE: private destructor, may not be allocated on the stack as 
	// this would break OLE's current object liveness rules

	~CDropTarget();

	void UpdateEffect(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
	void DrawFeedback(void);
	void ConvertScreenPtToClientPt( POINTL *pptScreen, POINT *pptClient );
	HRESULT HandleRightMouseDrop(IDataObject *pdo, POINTL ptl);

	ULONG		_crefs;
	DWORD		_dwFlags;	// DataObjectInfo cache (e.g. DOI_CANPASTEPLAIN)
							// and other flags.
	CTxtEdit *	_ped;
	CCallMgr *	_pcallmgr;	// The call manager used during a drag drop operation.

	// cached information for drag drop operations
	IUndoBuilder *_publdr;	// the undo builder for the drag operation
	LONG		_cpMin;		// the min and max cp's for the range that is
	LONG		_cpMost;	//   being dragged so we can disable drag-onto-yourself!
	LONG		_cpSel;		// active end and length for selection *before*
	LONG		_cchSel;	//	 drag drop op occured (so we can restore it)
	LONG		_cpCur;		// the cp that the mouse is currently over
	CDropCaret *_pdrgcrt;	// Object that implements the drop caret
};


/*
 *	CDropTarget::fInDrag ()
 *
 *	Purpose:
 *		Tells interested parties whether a drag operation is occurring
 *
 */
inline BOOL CDropTarget::fInDrag()
{
	return _pcallmgr != NULL;
}

#endif // !__DRAGDRP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_dxfrobj.h ===
/*
 *	_DXFROBJ.H
 *
 *	Purpose:
 *		Class declaration for an OLE data transfer object (for use in
 *		drag drop and clipboard operations)
 *
 *	Author:
 *		alexgo (4/25/95)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef __DXFEROBJ_H__
#define __DXFEROBJ_H__

class CTxtRange;

EXTERN_C const IID IID_IRichEditDO;

/*
 *	CDataTransferObj
 *
 *	Purpose:
 *		holds a "snapshot" of some rich-text data that can be used
 *		for drag drop or clipboard operations
 *
 *	Notes:
 *		FUTURE (alexgo): add in support for TOM<-->TOM optimized data
 *		transfers
 */

class CDataTransferObj : public IDataObject, public ITxNotify
{
public:

	// IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

	// IDataObject methods
    STDMETHOD(DAdvise)( FORMATETC * pFormatetc, DWORD advf,
    		IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHOD(DUnadvise)( DWORD dwConnection);
    STDMETHOD(EnumDAdvise)( IEnumSTATDATA ** ppenumAdvise);
    STDMETHOD(EnumFormatEtc)( DWORD dwDirection,
            IEnumFORMATETC **ppenumFormatEtc);
    STDMETHOD(GetCanonicalFormatEtc)( FORMATETC *pformatetc,
            FORMATETC *pformatetcOut);
    STDMETHOD(GetData)( FORMATETC *pformatetcIn, STGMEDIUM *pmedium );
    STDMETHOD(GetDataHere)( FORMATETC *pformatetc, STGMEDIUM *pmedium);
    STDMETHOD(QueryGetData)( FORMATETC *pformatetc );
    STDMETHOD(SetData)( FORMATETC *pformatetc, STGMEDIUM *pmedium,
            BOOL fRelease);

	// ITxNotify methods
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
    virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
	virtual void	Zombie();

	static	CDataTransferObj * Create(CTxtEdit *ped, CTxtRange *prg, LONG lStreamFormat);

private:
	// NOTE: private cons/destructor, may not be allocated on the stack as 
	// this would break OLE's current object liveness rules
	CDataTransferObj(CTxtEdit *ped);
	~CDataTransferObj();

	BOOL		IsZombie() {return !_ped;}

	ULONG		_crefs;
	ULONG		_cTotal;		// total number of formats supported
	FORMATETC *	_prgFormats;	// the array of supported formats
	LONG		_lStreamFormat; // Stream format to use in Rtf conversion
	
	// for 1.0 compatability
	DWORD	_dwFlags;
	DWORD	_dwUser;
	DWORD	_dvaspect;

	enum TEXTKIND
	{
		tPlain,
		tRtf,
		tRtfUtf8,
		tRtfNCRforNonASCII
	};

	HGLOBAL     TextToHglobal( HGLOBAL &hText, TEXTKIND tKind );
	LPSTORAGE	GetDataForEmbeddedObject( LPOLEOBJECT pOleObj, LPSTORAGE lpstgdest );
	HGLOBAL		GetDataForObjectDescriptor(	LPOLEOBJECT pOleObj, DWORD dwAspect, SIZEUV* psize );

public:
	CTxtEdit *		_ped;
	HGLOBAL			_hPlainText;	// handle to the plain UNICODE text
	HGLOBAL			_hRtfText;		// handle to the RTF UNICODE text
	HGLOBAL			_hRtfUtf8;		// Handle to UTF8 encoding of RTF
	HGLOBAL			_hRtfNCRforNonASCII;	// Handle to NCRforNonASCII encoding of RTF
	IOleObject *	_pOleObj;		// Embedded Object
	LPSTORAGE		_pObjStg;		// Embedded object data
	HGLOBAL			_hObjDesc;		// Embedded object descriptor
	HMETAFILE		_hMFPict;		// Embedded object metafile
	LONG			_cch;			// number of "characters" in the this
									// dxfer object
	LONG			_cpMin;			// Starting cp for this dxfer object
	LONG			_cObjs;			// number of objects in this dxfer object.
};

/*
 *	class CEnumFormatEtc
 *
 *	Purpose:
 *		implements a generic format enumerator for IDataObject
 */

class CEnumFormatEtc : public IEnumFORMATETC
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Next) (ULONG celt, FORMATETC *rgelt,
            ULONG *pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (IEnumFORMATETC **ppenum);

    static HRESULT Create(FORMATETC *prgFormats, DWORD cFormats, 
    			IEnumFORMATETC **ppenum);

private:

	CEnumFormatEtc();
	~CEnumFormatEtc();

	ULONG		_crefs;
    ULONG       _iCurrent; 	// current clipboard format
    ULONG       _cTotal;   	// total number of formats
    FORMATETC * _prgFormats; // array of available formats
};


//
//	Some globally useful FORMATETCs

extern FORMATETC g_rgFETC[];
extern const DWORD g_rgDOI[];
#define CFETC	17						// Dimension of g_rgFETC[]

enum FETCINDEX							// Keep in sync with g_rgFETC[]
{
	iRtfUtf8,							// RTF in UTF8 encoding
	iRtfFETC,							// RTF
	iRtfNCRforNonASCII,					// RTF with NCR for nonASCII
	iEmbObj,							// Embedded Object
	iEmbSrc,							// Embed Source
	iObtDesc,							// Object Descriptor
	iLnkSrc,							// Link Source
	iMfPict,							// Metafile
	iDIB,								// DIB
	iBitmap,							// Bitmap
	iRtfNoObjs,							// RTF with no objects
	iUnicodeFETC,						// Unicode plain text
	iAnsiFETC,							// ANSI plain text
	iFilename,							// Filename
	iRtfAsTextFETC,						// Pastes RTF as text
	iTxtObj,							// Richedit Text
	iRichEdit							// RichEdit Text w/formatting
};

#define cf_RICHEDIT			 g_rgFETC[iRichEdit].cfFormat
#define cf_EMBEDDEDOBJECT	 g_rgFETC[iEmbObj].cfFormat
#define cf_EMBEDSOURCE		 g_rgFETC[iEmbSrc].cfFormat
#define cf_OBJECTDESCRIPTOR	 g_rgFETC[iObtDesc].cfFormat
#define cf_LINKSOURCE		 g_rgFETC[iLnkSrc].cfFormat
#define cf_RTF				 g_rgFETC[iRtfFETC].cfFormat
#define cf_RTFUTF8			 g_rgFETC[iRtfUtf8].cfFormat
#define cf_RTFNCRFORNONASCII g_rgFETC[iRtfNCRforNonASCII].cfFormat
#define cf_RTFNOOBJS		 g_rgFETC[iRtfNoObjs].cfFormat
#define cf_TEXTOBJECT		 g_rgFETC[iTxtObj].cfFormat
#define cf_RTFASTEXT		 g_rgFETC[iRtfAsTextFETC].cfFormat
#define cf_FILENAME			 g_rgFETC[iFilename].cfFormat

#endif // !__DXFROBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_invar.h ===
/*
 *
 *
 *	_INVAR.H
 *	
 *	Purpose:
 *		Template class designed to call parameterized object's Invariant().
 *
 *	Overview (see also, usage):
 *		1)	declare and define a public const function BOOL Invariant( void ) in your class, with #ifdef DEBUG.
 *		2)	in the source: #define DEBUG_CLASSNAME to be the name of the class you're debugging.
 *		3)	followed by #include "_invar.h"
 *		4)	For every method you wish to check Invariants,
 *			insert the _TEST_INVARIANT_ macro once, usually at the beginning of a routine.
 *			OPTIONAL: You may optionally use the _TEST_INVARIANT_ON (x) to call x's Invariant directly.
 *
 *	Notes:
 *		Invariants are designed to be called at the beginning and upon exit of a routine, 
 *		testing the consistent properties of an object which remain invariant--always the same.
 *
 *		Functions may temporarily make an object inconsistent during their execution.
 *		A generalized invariant test should not be called during these inconsistent times;
 *		if there is a need for a function, which checks invariants, to be called during
 *		an inconsistent object state, a solution will need to be designed--the current design
 *		does not facilitate this.
 *
 *		Because it is entirely possible for an Invariant() function to recurse on itself
 *		causing a stack overflow, the template explicitly prevents this from happening.
 *		The template also prevents invariant-checking during the processing of Assert(),
 *		preventing another type of recursion.
 *
 *		Currently Invariant() returns a BOOL, as I think this allows for it to be called
 *		from the QuickWatch window under VC++2.0. TRUE indicates that the invariant executed
 *		normally.
 *
 *	Usage:
 *		-the _invariant.h header should only be included in source files. An error will occur
 *			if included in another header file. This is to prevent multiple #define DEBUG_CLASSNAME.
 *		-Typical #include into a source file looks like this:
			#define DEBUG_CLASSNAME ClassName
			#include "_invar.h"
 *		-Typical definition of a class' Invariant() method looks like this:
			#ifdef DEBUG
				public:
				BOOL Invariant( void ) const;
				protected:
			#endif	// DEBUG
 *		-Typical declaration of Invariant() looks like this:
			#ifdef DEBUG

			BOOL
			ClassName::Invariant( void ) const
			{
				static LONG	numTests = 0;
				numTests++;				// how many times we've been called.

				// do mega-assert checking here.

				return TRUE;
			}

			#endif	// DEBUG
 *
 *
 *		
 *	
 *	Author:
 *		Jon Matousek (jonmat) 5/04/1995
 *
 *		Any problems? Please let me know.
 */

#ifndef _INVARIANT_H

#define _INVARIANT_H

#ifndef DEBUG_CLASSNAME
prior to including _invariant.h file, you must define DEBUG_CLASSNAME
to be the name of the class for which you are making Invariant() calls.
#endif


#ifdef DEBUG

template < class T >
class InvariantDebug
{
	public:
	InvariantDebug	( const T & t) : _t(t)
 	{
		static volatile BOOL fRecurse = FALSE;

		if ( fRecurse )	return;		/* Don't allow recursion.*/
		
		fRecurse = TRUE;

		_t.Invariant();

		fRecurse = FALSE;
	}

	~InvariantDebug	()
	{
		static volatile BOOL fRecurse = FALSE;

		if ( fRecurse )	return;		/* Don't allow recursion.*/
		
		fRecurse = TRUE;

		_t.Invariant();

		fRecurse = FALSE;
	}

	private:
	 const T &_t;
};

typedef InvariantDebug<DEBUG_CLASSNAME> DoInvariant;

#define _TEST_INVARIANT_ DoInvariant __invariant_tester( *this );
#define _TEST_INVARIANT_ON(x) \
					{\
						static volatile BOOL fRecurse = FALSE;\
						if (FALSE == fRecurse )\
						{\
							fRecurse = TRUE;\
							(x).Invariant();\
							fRecurse = FALSE;\
						}\
					}

#else	// DEBUG

#define _TEST_INVARIANT_
#define _TEST_INVARIANT_ON(x)

#endif	// DEBUG


	// code that should be at the start and end of all Invariant() methods.

#else	// INVARIANT_H

	This file should only be included once per source file. jonmat

#endif	// INVARIANT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_edit.h ===
/*	_EDIT.H
 *	
 *	Purpose:
 *		Base classes for rich-text manipulation
 *	
 *	Authors:
 *		Christian Fortini
 *		Murray Sargent (and many others)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _EDIT_H
#define _EDIT_H

#include "textserv.h"
#include "textsrv2.h"
#include "_ldte.h"
#include "_m_undo.h"
#include "_notmgr.h"
#include "_doc.h"
#include "_objmgr.h"
#include "_cfpf.h"
#include "_callmgr.h"
#include "_magelln.h"

#ifndef NOPRIVATEMESSAGE
#include "_MSREMSG.H"
#include "_textnot.h"
#endif

#ifndef NOINKOBJECT
#include "HWXInk.h"
#endif

// Forward declarations
class CRchTxtPtr;
class CTxtSelection;
class CTxtStory;
class CTxtUndo;
class CMeasurer;
class CRenderer;
class CDisplay;
class CDisplayPrinter;
class CDrawInfo;
class CDetectURL;
class CUniscribe;
class CTxtBreaker;
class CHyphCache;


// Macro for finding parent "this" of embedded class. If this turns out to be
// globally useful we should move it to _common.h. 
#define GETPPARENT(pmemb, struc, membname) (\
				(struc FAR *)(((char FAR *)(pmemb))-offsetof(struc, membname)))

// These wonderful constants are for backward compatibility. They are the 
// sizes used for initialization and reset in RichEdit 1.0
const LONG cInitTextMax	 = (32 * 1024) - 1;
const LONG cResetTextMax = (64 * 1024);

extern DWORD CALLBACK ReadHGlobal (DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);
extern DWORD GetKbdFlags(WORD vkey, DWORD dwFlags);

extern BYTE szUTF8BOM[];
extern WORD g_wFlags;							// Toggled by Ctrl-"
#define	KF_SMARTQUOTES	0x0001					// Enable smart quotes
#define SmartQuotesEnabled()	(g_wFlags & KF_SMARTQUOTES)

struct SPrintControl
{
	union
	{
		DWORD		_dwAllFlags;				// Make it easy to set all flags at once.
		struct
		{
			ULONG	_fDoPrint:1;				// Whether actual print is required
			ULONG	_fPrintFromDraw:1;			// Whether draw is being used to print
		};
	};

	SPrintControl(void) { _dwAllFlags = 0; }
};

enum DOCUMENTTYPE
{
	DT_LTRDOC	= 1,			// DT_LTRDOC and DT_RTLDOC are mutually
	DT_RTLDOC	= 2,			//  exclusive
};

// Context rule settings.
// Optimally, these would be an enum, but we run into sign extension glitchs
// sticking an enum into a 2-bit field.
#define	CTX_NONE	0		// No context direction/alignment.
#define	CTX_NEUTRAL	1		// No strong characters in the control, direction/alignment follows keyboard.
#define	CTX_LTR		2		// LTR direction/alignment (first strong character is LTR)
#define	CTX_RTL		3		// RTL direction/alignment (first strong character is RTL)

#define IsStrongContext(x)	(x >= CTX_LTR)

class CDocInfo					// Contains ITextDocument info
{
public:
	BSTR	  _pName;				// Document filename
	HANDLE	  _hFile;				// Handle used unless full file sharing
	WORD	  _wFlags;				// Open, share, create, and save flags
	WORD	  _wCpg;				// Code page
	LONG	  _dwDefaultTabStop;	// TOM settable default tab stop
	LCID	  _lcid;				// Document lcid (for RTF \deflang)
	LCID	  _lcidfe;				// Document FE lcid (for RTF \deflangfe)
	LPSTR	  _lpstrLeadingPunct;	// Leading kinsoku characters
	LPSTR	  _lpstrFollowingPunct;	// Following kinsoku characters
	COLORREF *_prgColor;			// Special color array
	COLORREF  _crColor;				// Background color
	COLORREF  _crBackColor;			// Background color
	HGLOBAL	  _hdata;				// Background data
	HBITMAP	  _hBitmapBack;			// Background bitmap
	char	  _cColor;				// Allocated count of colors in pColor
	BYTE	  _bDocType;			// 0-1-2: export none-\ltrdoc-\rtldoc
									// If 0x80 or'd in, PWD instead of RTF
	BYTE	  _bCaretType;			// Caret type
	char	  _nFillType;			// Background fill type
	SHORT	  _sFillAngle;			// Fill angle
 	BYTE	  _bFillFocus;			// Background fill focus 
 	BYTE	  _bPicFormat;			// Background Picture format 
	BYTE	  _bPicFormatParm;		// Background Picture format parameter
	RECT	  _rcCrop;				// Background cropping RECT
	SHORT	  _xExt, _yExt;			// Dimensions in pixels for pictures, twips for
									//	for objects
	SHORT	  _xScale, _yScale;		// Scaling percentage along axes
	SHORT	  _xExtGoal, _yExtGoal;	// Desired dimensions in twips for pictures
	SHORT	  _xExtPict, _yExtPict;	// Metafile dimensions

	AutoCorrectProc _pfnAutoCorrect;

	CDocInfo() {Init();}			// Constructor
	~CDocInfo();					// Destructor

	void	Init();
	void	InitBackground();
};

const DWORD tomInvalidCpg = 0xFFFF;
const DWORD tomInvalidLCID = 0xFFFE;

// This depends on the number of property bits defined in textserv.h. However,
// this is for private use by the text services so it is defined here.
#define MAX_PROPERTY_BITS	21
#define SPF_SETDEFAULT		4

// IDispatch global declarations
extern ITypeInfo *	g_pTypeInfoDoc;
extern ITypeInfo *	g_pTypeInfoSel;
extern ITypeInfo *	g_pTypeInfoFont;
extern ITypeInfo *	g_pTypeInfoPara;
HRESULT GetTypeInfoPtrs();
HRESULT GetTypeInfo(UINT iTypeInfo, ITypeInfo *&pTypeInfo,
							ITypeInfo **ppTypeInfo);

BOOL IsSameVtables(IUnknown *punk1, IUnknown *punk2);

// Map from keyboard to font. (converse is handled in font.cpp)
typedef struct _kbdFont
{
	WORD	iKbd;
	SHORT	iCF;
} KBDFONT;

LONG	CheckTwips(LONG x);
QWORD	GetCharFlags(const WCHAR *pch, LONG cchPch = 1, BYTE iCharRepDefault = 0);
LONG	TwipsToHalfPoints(LONG x);
LONG	TwipsToQuarterPoints(LONG x);

// Convert between Twips and Himetric
// Ratio is 1440 twips/in, 2540 him/in, therefore 1440/2540 = 72/127 him/twips
// Use muldiv() to include rounding and 64-bit intermediate result
#define TwipsFromHimetric(hm)	MulDiv(hm, 72, 127)
#define HimetricFromTwips(tw)	MulDiv(tw, 127, 72)

CUniscribe* GetUniscribe(void);

#define FRTL		0x00000001
#define FDIGITSHAPE 0x00000002

#define FCOMBINING	0x00000008
#define FSURROGATE  0x00000010
#define FUNIC_CTRL  0x00000020
#define FBELOWX40	0x00000040			// ASCII 0x00-0x3F
#define FASCIIUPR	0x00000080			// ASCII 0x40-0x7F

/*	The font signature fsCsb[0] has the bit definitions
	
	0 1252 Latin 1
	1 1250 Latin 2: Eastern Europe
	2 1251 Cyrillic
	3 1253 Greek
	4 1254 Turkish
	5 1255 Hebrew
	6 1256 Arabic
	7 1257 Baltic
	8 1258 Vietnamese
	9 - 15 Reserved for ANSI
	16 874 Thai
	17 932 JIS/Japan
	18 936 Chinese: Simplified chars--PRC, Hong Kong SAR, Singapore
	19 949 Korean Unified Hangul Code (Hangul TongHabHyung Code)
	20 950 Chinese: Traditional chars--Taiwan 

	We define bit masks which are similar to the values above shifted over
	one byte (add 8) to make room for a low byte of special flags like FRTL
	in _qwCharFlags.  In addition, we define some Unicode-only repertoires
	using info in the Unicode subset fields fsUsb[].

	This approach uses a 64-bit _qwCharFlags and currently can add 6 more
	character repertoires (actually writing systems). If more are needed, an
	approach with an array of three (or more as needed) DWORDs could be used
	as in the Win32 FONTSIGNATURE.
*/
#define	FHILATIN1	0x00000100
#define	FLATIN2		0x00000200
#define FCYRILLIC	0x00000400
#define FGREEK		0x00000800
#define FTURKISH	0x00001000
#define FHEBREW		0x00002000
#define FARABIC		0x00004000
#define FBALTIC		0x00008000
#define FVIETNAMESE	0x00010000

#define FOTHER		0x00020000
#define FSYMBOL		0x00040000

#define FTHAI		0x00080000
#define FKANA		0x00100000
#define FCHINESE	0x00200000			// Simplified Chinese
#define FHANGUL		0x00400000
#define FBIG5		0x00800000			// Traditional Chinese

#define FMATHGENR	0x01000000			// Generic math
#define FMATHITAL	0x02000000			// Math alphanumerics
#define FMATHBOLD	0x04000000
#define FMATHSCRP	0x08000000
#define FMATHFRAK	0x10000000
#define FMATHOPEN	0x20000000
#define FMATHSANS	0x40000000
#define FMATHMONO	0x80000000

// Unicode-only character repertoires. If you add new repertoire flags, add
// corresponding xxx_INDEX values in _w32sys.h and change CW32System::
// CharRepFontSig() and CW32System::FontSigFromCharRep().
#define FARMENIAN	0x0000000100000000	// 0x0530 - 0x058F
#define	FSYRIAC		0x0000000200000000	// 0x0700 - 0x074F
#define FTHAANA		0x0000000400000000	// 0x0780 - 0x07BF
#define FDEVANAGARI	0x0000000800000000	// 0x0900 - 0x097F
#define FBENGALI	0x0000001000000000	// 0x0980 - 0x09FF
#define FGURMUKHI	0x0000002000000000	// 0x0A00 - 0x0A7F
#define FGUJARATI	0x0000004000000000	// 0x0A80 - 0x0AFF
#define FORYIA		0x0000008000000000	// 0x0B00 - 0x0B7F
#define FTAMIL		0x0000010000000000	// 0x0B80 - 0x0BFF
#define FTELEGU		0x0000020000000000	// 0x0C00 - 0x0C7F
#define FKANNADA	0x0000040000000000	// 0x0C80 - 0x0CFF
#define FMALAYALAM	0x0000080000000000	// 0x0D00 - 0x0D7F
#define FSINHALA	0x0000100000000000	// 0x0D80 - 0x0DFF
#define	FLAO		0x0000200000000000	// 0x0E80 - 0x0EFF
#define	FTIBETAN	0x0000400000000000	// 0x0F00 - 0x0FBF
#define	FMYANMAR	0x0000800000000000	// 0x1000 - 0x109F
#define FGEORGIAN	0x0001000000000000	// 0x10A0 - 0x10FF
#define FJAMO		0x0002000000000000	// 0x1100 - 0x11FF
#define FETHIOPIC	0x0004000000000000	// 0x1200 - 0x137F
#define FCHEROKEE	0x0008000000000000	// 0x13A0 - 0x13FF
#define FABORIGINAL	0x0010000000000000	// 0x1400 - 0x167F
#define FOGHAM		0x0020000000000000	// 0x1680 - 0x169F
#define FRUNIC		0x0040000000000000	// 0x16A0 - 0x16F0
#define	FKHMER		0x0080000000000000	// 0x1780 - 0x17FF
#define	FMONGOLIAN	0x0100000000000000	// 0x1800 - 0x18AF
#define	FBRAILLE	0x0200000000000000	// 0x2800 - 0x28FF
#define	FYI			0x0400000000000000	// 0xA000 - 0xA4CF
										// Keep next 4 in same order as FKANA - FBIG5
#define FJPN2		0x0800000000000000	// 0x20000 - 2FFFFF Japanese
#define FCHS2		0x1000000000000000	// 0x20000 - 2FFFFF Simplified Chinese
#define FKOR2		0x2000000000000000	// 0x20000 - 2FFFFF Korean
#define FCHT2		0x4000000000000000	// 0x20000 - 2FFFFF Traditional Chinese

#define FASCII		(FASCIIUPR | FBELOWX40)
#define FLATIN1		(FASCII | FHILATIN1)
#define FLATIN		(FHILATIN1 | FLATIN2 | FTURKISH | FBALTIC | FVIETNAMESE)
#define FBIDI		(FRTL | FARABIC | FHEBREW | FSYRIAC | FTHAANA | FDIGITSHAPE)
#define FFE			(FKANA | FCHINESE | FBIG5 | FHANGUL)
#define FFE2		(FJPN2 | FCHS2 | FCHT2 | FKOR2)
#define FMATH		(FMATHGENR | FMATHITAL | FMATHBOLD | FMATHSCRP | FMATHFRAK | \
					 FMATHOPEN | FMATHSANS | FMATHMONO)
#define FINDIC		(FDEVANAGARI | FBENGALI | FGURMUKHI | FGUJARATI | FORYIA | \
					 FTAMIL | FTELEGU | FKANNADA | FMALAYALAM | FSINHALA)
#define FABOVEX7FF	(FTHAI | FFE | FOTHER | FINDIC | FLAO | FTIBETAN | FMYANMAR	| \
					 FGEORGIAN | FJAMO | FETHIOPIC | FCHEROKEE | FABORIGINAL | \
					 FOGHAM | FRUNIC | FKHMER | FMONGOLIAN | FBRAILLE | FYI)

#define FNEEDWORDBREAK	FTHAI
#define FNEEDCHARBREAK	(FTHAI | FINDIC)
#define FCOMPLEX_SCRIPT	(FBIDI | FTHAI | FINDIC | FJAMO | FCOMBINING | FSURROGATE)

#define RB_DEFAULT			0x00000000	// Perform default behavior
#define RB_NOSELCHECK		0x00000001	// For OnTxRButtonUp, bypass pt in selection check
#define RB_FORCEINSEL		0x00000002	// Force point into selection (used by keyboard
										//  to get context menus)
// Flags for OnTxLButtonUp
#define LB_RELEASECAPTURE	0x00000001	// Force release mouse capture
#define	LB_FLUSHNOTIFY		0x00000002	// 1.0 mode force selection change notification
										//  if selChange is cached
enum AccentIndices
{
	ACCENT_GRAVE = 1,
	ACCENT_ACUTE,
	ACCENT_CARET,
	ACCENT_TILDE,
	ACCENT_UMLAUT,
	ACCENT_CEDILLA
};

#define KBD_CHAR			2		// Must be a bit value > 1
#define KBD_CTRL			4		// Must be a bit value > 2
#define KBD_NOAUTOCORRECT	8		// Must be a bit value > 4

// ==================================  CTxtEdit  ============================================
// Outer most class for a Text Control.
class CTxtEdit : public ITextServices, public IRichEditOle, public ITextDocument2
{
public:
	friend class CCallMgr;
	friend class CMagellanBMPStateWrap;

	CTxtEdit(ITextHost2 *phost, IUnknown *punkOuter);
	 ~CTxtEdit ();

	// Initialization 
	BOOL 		Init(const RECT *prcClient);

	// A helper function
	LONG GetTextLength() const	{return _story.GetTextLength();}
	LONG GetAdjustedTextLength();
   
	// Access to ActiveObject members

	IUnknown *		GetPrivateIUnknown() 	{ return &_unk; }
	CLightDTEngine *GetDTE() 				{ return &_ldte; }

	IUndoMgr *		GetUndoMgr() 			{ return _pundo; }
	IUndoMgr *		GetRedoMgr()			{ return _predo; }
	IUndoMgr *		CreateUndoMgr(LONG cUndoLim, USFlags flags);
	CCallMgr *		GetCallMgr()
						{Assert(_pcallmgr); return _pcallmgr;}

	static CHyphCache *	GetHyphCache(void);
	CObjectMgr *	GetObjectMgr();
					// the callback is provided by the client
					// to help with OLE support
	BOOL			HasObjects()			{return _pobjmgr && _pobjmgr->GetObjectCount();}
	IRichEditOleCallback *GetRECallback()
		{ return _pobjmgr ? _pobjmgr->GetRECallback() : NULL; }	
	LRESULT 		HandleSetUndoLimit(LONG Count);
	LRESULT			HandleSetTextMode(DWORD mode);
	LRESULT			HandleSetTextFlow(DWORD mode);

	CCcs*			GetCcs(const CCharFormat *const pCF, const LONG dvpInch, DWORD dwFlags = -1, HDC hdc = 0);
	CNotifyMgr *	GetNotifyMgr();

	CDetectURL *	GetDetectURL()			{return _pdetecturl;}

	CUniscribe *	Getusp() const			{return GetUniscribe();}

#ifndef NOMAGELLAN
	CMagellan		mouse;
	LRESULT			HandleMouseWheel(WPARAM wparam, LPARAM lparam);
#endif

	void			AutoCorrect(CTxtSelection *psel, WCHAR ch, IUndoBuilder *publdr);

	// Misc helpers
	LONG			GetAcpFromCp(LONG cp, BOOL fPrecise=0);
	LONG			GetCpFromAcp(LONG acp, BOOL fPrecise=0);
#ifndef NOANSIWINDOWS
	BOOL			Get10Mode() const			{return _f10Mode;}
	BOOL			fUseCRLF() const			{return _f10Mode;}
	BOOL			fCpMap() const				{return _f10Mode;}
#else
	BOOL			Get10Mode() const			{return FALSE;}
	BOOL			fUseCRLF() const			{return FALSE;}
	BOOL			fCpMap() const				{return FALSE;}
#endif
	LONG			GetCpAccelerator() const	{return _cpAccelerator;}
	short			GetFreezeCount() const 		{return _cFreeze;}
#ifndef NOWINDOWHOSTS
	BOOL			fInOurHost() const			{return _fInOurHost;}
#else
	BOOL			fInOurHost() const			{return FALSE;}
#endif
	BOOL			fInHost2() const			{return _fHost2;}
	BOOL			fInplaceActive() const		{return _fInPlaceActive;}
	BOOL			fHideGridlines() const		{return _fHideGridlines;}
	BOOL			fHideSelection() const		{return _fHideSelection;}
	BOOL			fXltCRCRLFtoCR() const		{return _fXltCRCRLFtoCR;}
	BOOL			fUsePassword() const		{return _fUsePassword;}

	BOOL			FUseCustomTextOut() const	{return !(_bTypography & TO_DISABLECUSTOMTEXTOUT);}
	BOOL			fUseLineServices() const	{return _bTypography & TO_ADVANCEDTYPOGRAPHY;}
	BOOL			fUseSimpleLineBreak() const	{return (_bTypography & TO_SIMPLELINEBREAK) != 0;}
	BOOL			fUseObjectWrapping() const	{return (_bTypography & TO_ADVANCEDLAYOUT) != 0;}
#ifndef NOAUTOFONT
	BOOL			IsAutoFont() const			{return _fAutoFont;};
	BOOL			IsAutoKeyboard() const		{return _fAutoKeyboard;};
	BOOL			IsAutoFontSizeAdjust() const{return _fAutoFontSizeAdjust;};
#else
	BOOL			IsAutoFont() const			{return FALSE;};
	BOOL			IsAutoKeyboard() const		{return FALSE;};   
	BOOL			IsAutoFontSizeAdjust() const{return FALSE;};
#endif
	BOOL			IsBiDi() const				{return (_qwCharFlags & FBIDI) != 0;}
	BOOL			IsComplexScript() const		{return (_qwCharFlags & FCOMPLEX_SCRIPT) != 0;}
#ifndef NOFEPROCESSING
	BOOL			IsFE() const				{return (_qwCharFlags & FFE) != 0;}
#else
	BOOL			IsFE() const				{return FALSE;}
#endif
	BOOL			IsInOutlineView() const		{return _fOutlineView;}
	BOOL			IsInPageView() const		{return _fPageView;}
	BOOL			IsMouseDown() const			{return _fMouseDown;}
#ifndef NOPLAINTEXT
	BOOL			IsRich() const				{return _fRich;}
#else
	BOOL			IsRich() const				{return TRUE;}
#endif
	BOOL			IsLeftScrollbar() const;
	BOOL			IsSelectionBarRight() const	{return IsLeftScrollbar(); }
	void			SetfSelChangeCharFormat()	{_fSelChangeCharFormat = TRUE; }
	BOOL			DelayChangeNotification()   {return _f10DeferChangeNotify;}
	BOOL			GetOOMNotified()			{return _fOOMNotified;}

	
	void	SetOOMNotified(BOOL ff)		
			{
				Assert(ff == 1 || ff == 0);
				_fOOMNotified = ff;
			}

	//plain-text controls always use the UIFont
	bool 			fUseUIFont() const			{return !_fRich || _fUIFont;} 
	BOOL			IsTransparent()				{return _fTransparent;}

	LONG			GetZoomNumerator() const	{return _wZoomNumerator;}
	LONG			GetZoomDenominator() const	{return _wZoomDenominator;}
	void			SetZoomNumerator(LONG x)	{_wZoomNumerator = (WORD)x;}
	void			SetZoomDenominator(LONG x)	{_wZoomDenominator = (WORD)x;}
	LONG			GetCpFirstStrong()			{return _cpFirstStrong;}
	void			SetReleaseHost();
	QWORD			GetCharFlags() const		{return _qwCharFlags;}
	BOOL			IsDocMoreThanLatin1Symbol()	{return (GetCharFlags() & ~(FLATIN1 | FSYMBOL)) != 0;}
    void            OrCharFlags(QWORD qwFlags, IUndoBuilder* publdr = NULL);
	void			Beep();
	void			HandleKbdContextMenu();
	void			Set10Mode();
	void			SetContextDirection(BOOL fUseKbd = FALSE);
	void			ItemizeDoc(IUndoBuilder* publdr = NULL, LONG cchRange = -1);
	HRESULT			UpdateAccelerator();
	HRESULT			UpdateOutline();
	HRESULT			MoveSelection(LPARAM lparam, IUndoBuilder *publdr);
	HRESULT			PopAndExecuteAntiEvent(IUndoMgr *pundomgr, void *pAE);
	BOOL			InsertEOP(DWORD dwFlags, BOOL fShift, IUndoBuilder* publdr);

	HRESULT			CutOrCopySelection(UINT msg, WPARAM wparam, LPARAM lparam,
									   IUndoBuilder *publdr);

	HRESULT			PasteDataObjectToRange( 
						IDataObject *pdo, 
						CTxtRange *prg, 
						CLIPFORMAT cf, 
						REPASTESPECIAL *rps,
						IUndoBuilder *publdr, 
						DWORD dwFlags );

	// Story access
	CTxtStory * GetTxtStory () {return &_story;}

	// Get access to cached CCharFormat and CParaFormat structures
	const CCharFormat* 	GetCharFormat(LONG iCF)
							{return _story.GetCharFormat(iCF);}
	const CParaFormat* 	GetParaFormat(LONG iPF)
							{return _story.GetParaFormat(iPF);}

	LONG		Get_iCF()			{return _story.Get_iCF();}
	LONG		Get_iPF()			{return _story.Get_iPF();}
	void		Set_iCF(LONG iCF)	{_story.Set_iCF(iCF);}
	void		Set_iPF(LONG iPF)	{_story.Set_iPF(iPF);}

	HRESULT		HandleStyle(CCharFormat *pCFTarget, const CCharFormat *pCF,
							DWORD dwMask, DWORD dwMask2);
	HRESULT		HandleStyle(CParaFormat *pPFTarget, const CParaFormat *pPF,
							DWORD dwMask, DWORD dwMask2);

	// Get host interface pointer
	ITextHost2 *GetHost() {return _phost;}

	// Helper for getting CDocInfo ptr and creating it if NULL 
	CDocInfo *	GetDocInfo();
	CDocInfo *	GetDocInfoNC()	{return _pDocInfo;}
	HRESULT		InitDocInfo();
	LONG		GetBackgroundType();

	LONG		GetDefaultTab()	
					{return _pDocInfo ? _pDocInfo->_dwDefaultTabStop : lDefaultTab;};
	HRESULT		SetDefaultLCID	 (LCID lcid);
	HRESULT		GetDefaultLCID	 (LCID *pLCID);
	HRESULT		SetDefaultLCIDFE (LCID lcid);
	HRESULT		GetDefaultLCIDFE (LCID *pLCID);
	HRESULT		SetDocumentType  (LONG DocType);
	HRESULT		GetDocumentType  (LONG *pDocType);
	HRESULT		GetFollowingPunct(LPSTR *plpstrFollowingPunct);
	HRESULT		SetFollowingPunct(LPSTR lpstrFollowingPunct);
	HRESULT		GetLeadingPunct	 (LPSTR *plpstrLeadingPunct);
	HRESULT		SetLeadingPunct	 (LPSTR lpstrLeadingPunct);
	HRESULT		GetViewKind		 (LRESULT *plres);
	HRESULT		SetViewKind		 (long Value);
	HRESULT		GetViewScale	 (long *pValue);
	HRESULT		SetViewScale	 (long Value);

	// Notification Management Methods.  In principle, these methods 
	// could form a separate class, but for space savings, they are part
	// of the CTxtEdit class

	HRESULT		TxNotify(DWORD iNotify, void *pv);	//@cmember General-purpose
													// notification
	void		SendScrollEvent(DWORD iNotify);		//@cmember Send scroll
													//  event
	void		SendUpdateEvent();					//@cmember Send EN_UPDATE
													//  event
													//@cmember Use EN_PROTECTED
	BOOL		QueryUseProtection( CTxtRange *prg, //  to query protection
					UINT msg,WPARAM wparam, LPARAM lparam);//  usage
													//@cmember Indicates whether
													// protection checking enabled
	BOOL		IsProtectionCheckingEnabled() 
					{return !!(_dwEventMask & ENM_PROTECTED);}

	// FUTURE (alexgo): maybe we can use just one method :-)
	BOOL	 	IsntProtectedOrReadOnly(UINT msg, WPARAM wparam, LPARAM lparam, BOOL fBeep = TRUE);

	BOOL 		IsProtected(UINT msg, WPARAM wparam, LPARAM lparam);
	BOOL 		IsProtectedRange(UINT msg, WPARAM wparam, LPARAM lparam, CTxtRange *prg);

	void		SetStreaming(BOOL flag)	{_fStreaming = flag;}
	BOOL		IsStreaming()			{return _fStreaming;}

	DWORD		GetEventMask(){return _dwEventMask;}//@cmember Get event mask
													//@cmember Handles EN_LINK
	BOOL		HandleLinkNotification(UINT msg, WPARAM wparam, LPARAM lparam,
					BOOL *pfInLink = NULL);
	BOOL		HandleLowFiRTF(char *szControl);	//@cmember Handles EN_LOWFIRTF

	HRESULT		CloseFile (BOOL bSave);

	// Helper for determine when to load message filter
	BOOL		LoadMsgFilter (UINT msg, WPARAM wparam, LPARAM lparam);

#ifndef NOINKOBJECT
	// Helper function to setup ink object properties
	HRESULT		SetInkProps( LONG cp, ILineInfo *pILineInfo, UINT *piInkWidth );
#endif

	LONG		GetCaretWidth();

	//--------------------------------------------------------------
	// Inline proxies to ITextHost methods
	//--------------------------------------------------------------

	// Persisted properties (persisted by the host)
	// Get methods: called by the Text Services component to get 
	// the value of a given persisted property

	// FUTURE (alexgo) !! some of these need to get cleaned up
	
	BOOL		TxGetAutoSize() const;
	BOOL 	 	TxGetAutoWordSel() const;				
	COLORREF 	TxGetBackColor() const;
	TXTBACKSTYLE TxGetBackStyle() const;					
	HRESULT 	TxGetDefaultCharFormat(CCharFormat *pCF, DWORD &dwMask);

	void		TxGetClientRect(RECTUV *prc) const;
	void		TxGetClientRect(LPRECT prc) const {_phost->TxGetClientRect(prc);}
	HRESULT		TxGetExtent(SIZEL *psizelExtents) 
					{return _phost->TxGetExtent(psizelExtents);}
	COLORREF 	TxGetForeColor() const			{return _phost->TxGetSysColor(COLOR_WINDOWTEXT);}
	DWORD		TxGetMaxLength() const;
	void		TxSetMaxToMaxText(LONG cExtra = 0);
	BOOL		TxGetModified() const			{return _fModified;}
	HRESULT		TxGetDefaultParaFormat(CParaFormat *pPF);
	TCHAR		TxGetPasswordChar() const;				
	BOOL		TxGetReadOnly() const			{return _fReadOnly;}
	BOOL		TxGetSaveSelection() const;
	DWORD		TxGetScrollBars() const	;				
	LONG		TxGetSelectionBarWidth() const;
	void		TxGetViewInset(RECTUV *prc, CDisplay const *pdp) const;
	BOOL		TxGetWordWrap() const;

	BOOL		TxClientToScreen (LPPOINT lppt)	{return _phost->TxClientToScreen(lppt); }
	BOOL		TxScreenToClient (LPPOINT lppt)	{return _phost->TxScreenToClient(lppt); }


	//	ITextHost 2 wrappers				
	BOOL		TxIsDoubleClickPending();
	HRESULT		TxGetWindow(HWND *phwnd);
	HRESULT		TxSetForegroundWindow();
	HPALETTE	TxGetPalette();
	HRESULT		TxGetFEFlags(LONG *pFEFlags);
	HCURSOR		TxSetCursor(HCURSOR hcur, BOOL fText = FALSE);

	// Allowed only when in in-place 
	// The host will fail if not in-place
	HDC 		TxGetDC()				{return _phost->TxGetDC();}
	INT			TxReleaseDC(HDC hdc)	{return _phost->TxReleaseDC(hdc);}
	
	// Helper functions for metafile support
	INT			TxReleaseMeasureDC( HDC hMeasureDC );

	void 		TxUpdateWindow()								
				{
					_phost->TxViewChange(_fInPlaceActive ? TRUE : FALSE);
				}
	void		TxScrollWindowEx (INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip);

	void		TxSetCapture(BOOL fCapture)
										{_phost->TxSetCapture(fCapture);}
	void		TxSetFocus()			
										{_phost->TxSetFocus();}

	// Allowed any-time
	
	BOOL 		TxShowScrollBar(INT fnBar, BOOL fShow);
	BOOL 		TxEnableScrollBar (INT fuSBFlags, INT fuArrowFlags);
	BOOL 		TxSetScrollRange(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw);
	BOOL 		TxSetScrollPos (INT fnBar, INT nPos, BOOL fRedraw);
	void		TxInvalidate()	{TxInvalidateRect((RECT*)NULL);}
	void		TxInvalidateRect(const RECT* prc);
	void		TxInvalidateRect(const RECTUV* prc);
	BOOL		TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight)
										{return _phost->TxCreateCaret(hbmp, xWidth, yHeight);}
	BOOL		TxShowCaret(BOOL fShow)
										{return _phost->TxShowCaret(fShow);}
	BOOL		TxSetCaretPos(INT u, INT v);
	BOOL 		TxSetTimer(UINT idTimer, UINT uTimeout)
										{return _phost->TxSetTimer(idTimer, uTimeout);}
	void 		TxKillTimer(UINT idTimer)
										{_phost->TxKillTimer(idTimer);}
	COLORREF	TxGetSysColor(int nIndex){ return _phost->TxGetSysColor(nIndex);}

	int			TxWordBreakProc(TCHAR* pch, INT ich, INT cb, INT action, LONG cpStart, LONG cp = -1);

	// IME
	HIMC		TxImmGetContext()		{return _phost->TxImmGetContext();}
	void		TxImmReleaseContext(HIMC himc)
										{_phost->TxImmReleaseContext( himc );}	

	// Selection access
	CTxtSelection *GetSel();
	CTxtSelection *GetSelNC() { return _psel; }
	LONG 	GetSelMin() const;
	LONG 	GetSelMost() const;
	void 	GetSelRangeForRender(LONG *pcpSelMin, LONG *pcpSelMost);
	void	DiscardSelection();


	// Property Change Helpers
	HRESULT OnRichEditChange(BOOL fFlag);
	HRESULT	OnTxMultiLineChange(BOOL fMultiLine);
	HRESULT	OnTxReadOnlyChange(BOOL fReadOnly);
	HRESULT	OnShowAccelerator(BOOL fPropertyFlag);
	HRESULT	OnUsePassword(BOOL fPropertyFlag);
	HRESULT	OnTxHideSelectionChange(BOOL fHideSelection);
	HRESULT	OnSaveSelection(BOOL fPropertyFlag);
	HRESULT	OnTxVerticalChange(BOOL fVertical);
	HRESULT	OnAutoWordSel(BOOL fPropertyFlag);
	HRESULT	NeedViewUpdate(BOOL fPropertyFlag);
	HRESULT	OnWordWrapChange(BOOL fPropertyFlag);
	HRESULT	OnAllowBeep(BOOL fPropertyFlag);
	HRESULT OnDisableDrag(BOOL fPropertyFlag);
	HRESULT	OnTxBackStyleChange(BOOL fPropertyFlag);
	HRESULT	OnMaxLengthChange(BOOL fPropertyFlag);
	HRESULT OnCharFormatChange(BOOL fPropertyFlag);
	HRESULT OnParaFormatChange(BOOL fPropertyFlag);
	HRESULT	OnClientRectChange(BOOL fPropertyFlag);
	HRESULT OnScrollChange(BOOL fProperyFlag);
	HRESULT OnSetTypographyOptions(WPARAM wparam, LPARAM lparam);
	HRESULT	OnHideSelectionChange(BOOL fHideSelection);
	
	// Helpers
	HRESULT	TxCharFromPos(LPPOINT ppt, LRESULT *pacp);
	HRESULT	OnTxUsePasswordChange(BOOL fUsePassword);
	HRESULT FormatAndPrint(
				HDC hdcDraw,		
				HDC hicTargetDev,	
				DVTARGETDEVICE *ptd,
				RECT *lprcBounds,
				RECT *lprcWBounds);

	//
	// PUBLIC INTERFACE METHODS
	//

	// -----------------------------
	//	IUnknown interface
	// -----------------------------

	virtual HRESULT 	WINAPI QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG 		WINAPI AddRef(void);
	virtual ULONG 		WINAPI Release(void);

	//--------------------------------------------------------------
	// ITextServices methods
	//--------------------------------------------------------------
	//@cmember Generic Send Message interface
	virtual HRESULT 	TxSendMessage(
							UINT msg, 
							WPARAM wparam, 
							LPARAM lparam,
							LRESULT *plresult);
	
	//@cmember Rendering
	virtual HRESULT		TxDraw(	
							DWORD dwDrawAspect,		// draw aspect
							LONG  lindex,			// currently unused
							void * pvAspect,		// info for drawing 
													// optimizations (OCX 96)
							DVTARGETDEVICE * ptd,	// information on target 
													// device								'
							HDC hdcDraw,			// rendering device context
							HDC hicTargetDev,		// target information 
													// context
							LPCRECTL lprcBounds,	// bounding (client) 
													// rectangle
							LPCRECTL lprcWBounds,	// clipping rect for 
													// metafiles
			   				LPRECT lprcUpdate,		// dirty rectange insde 
			   										// lprcBounds
							BOOL (CALLBACK * pfnContinue) (DWORD), // for 
													// interupting 
							DWORD dwContinue,		// long displays (currently 
													// unused) 
							LONG lViewID);			// Specifies view to redraw

	//@cmember Horizontal scrollbar support
	virtual HRESULT		TxGetHScroll(
							LONG *plMin, 
							LONG *plMax, 
							LONG *plPos, 
							LONG *plPage,
							BOOL * pfEnabled );

   	//@cmember Horizontal scrollbar support
	virtual HRESULT		TxGetVScroll(
							LONG *plMin, 
							LONG *plMax, 
							LONG *plPos, 
							LONG *plPage, 
							BOOL * pfEnabled );

	//@cmember Setcursor
	virtual HRESULT 	OnTxSetCursor(
							DWORD dwDrawAspect,		// draw aspect
							LONG  lindex,			// currently unused
							void * pvAspect,		// info for drawing 
													// optimizations (OCX 96)
							DVTARGETDEVICE * ptd,	// information on target 
													// device								'
							HDC hdcDraw,			// rendering device context
							HDC hicTargetDev,		// target information 
													// context
							LPCRECT lprcClient, 
							INT x, 
							INT y);

	//@cmember Hit-test
	virtual HRESULT 	TxQueryHitPoint(
							DWORD dwDrawAspect,		// draw aspect
							LONG  lindex,			// currently unused
							void * pvAspect,		// info for drawing 
													// optimizations (OCX 96)
							DVTARGETDEVICE * ptd,	// information on target 
													// device								'
							HDC hdcDraw,			// rendering device context
							HDC hicTargetDev,		// target information 
													// context
							LPCRECT lprcClient, 
							INT x, 
							INT y, 
							DWORD * pHitResult);

	//@member Inplace activate notification
	virtual HRESULT		OnTxInPlaceActivate(const RECT *prcClient);

	//@member Inplace deactivate notification
	virtual HRESULT		OnTxInPlaceDeactivate();

	//@member UI activate notification
	virtual HRESULT		OnTxUIActivate();

	//@member UI deactivate notification
	virtual HRESULT		OnTxUIDeactivate();

	//@member Get text in control
	virtual HRESULT		TxGetText(BSTR *pbstrText);

	//@member Set text in control
	virtual HRESULT		TxSetText(LPCTSTR pszText);
	
	//@member Get x position of 
	virtual HRESULT		TxGetCurTargetX(LONG *);
	//@member Get baseline position
	virtual HRESULT		TxGetBaseLinePos(LONG *);

	//@member Get Size to fit / Natural size
	virtual HRESULT		TxGetNaturalSize(
							DWORD dwAspect,
							HDC hdcDraw,
							HDC hicTargetDev,
							DVTARGETDEVICE *ptd,
							DWORD dwMode, 
							const SIZEL *psizelExtent,
							LONG *pwidth, 
							LONG *pheight);

	//@member Drag & drop
	virtual HRESULT		TxGetDropTarget( IDropTarget **ppDropTarget );

	//@member Bulk bit property change notifications
	virtual HRESULT		OnTxPropertyBitsChange(DWORD dwMask, DWORD dwBits);

	//@cmember Fetch the cached drawing size 
	virtual	HRESULT		TxGetCachedSize(DWORD *pdupClient, DWORD *pdvpClient);
	
	//	IDispatch methods

   	STDMETHOD(GetTypeInfoCount)( UINT * pctinfo);

	STDMETHOD(GetTypeInfo)(
	  
	  UINT itinfo,
	  LCID lcid,
	  ITypeInfo **pptinfo);

	STDMETHOD(GetIDsOfNames)(
	  
	  REFIID riid,
	  OLECHAR **rgszNames,
	  UINT cNames,
	  LCID lcid,
	  DISPID * rgdispid);

	STDMETHOD(Invoke)(
	  
	  DISPID dispidMember,
	  REFIID riid,
	  LCID lcid,
	  WORD wFlags,
	  DISPPARAMS * pdispparams,
	  VARIANT * pvarResult,
	  EXCEPINFO * pexcepinfo,
	  UINT * puArgErr);


	// ITextDocument2 methods
	STDMETHOD(GetName)(BSTR *pName);
	STDMETHOD(GetSelection)(ITextSelection **ppSel);
	STDMETHOD(GetStoryCount)(long *pCount);
	STDMETHOD(GetStoryRanges)(ITextStoryRanges **ppStories);
	STDMETHOD(GetSaved)(long *pValue);
	STDMETHOD(SetSaved)(long Value);
	STDMETHOD(GetDefaultTabStop)(float *pValue);
	STDMETHOD(SetDefaultTabStop)(float Value);
	STDMETHOD(New)();
	STDMETHOD(Open)(VARIANT *pVar, long Flags, long CodePage);
	STDMETHOD(Save)(VARIANT *pVar, long Flags, long CodePage);
	STDMETHOD(Freeze)(long *pCount);
	STDMETHOD(Unfreeze)(long *pCount);
	STDMETHOD(BeginEditCollection)();
	STDMETHOD(EndEditCollection)();
	STDMETHOD(Undo)(long Count, long *prop);
	STDMETHOD(Redo)(long Count, long *prop);
	STDMETHOD(Range)(long cpFirst, long cpLim, ITextRange ** ppRange);
	STDMETHOD(RangeFromPoint)(long x, long y, ITextRange **ppRange);
    STDMETHOD(AttachMsgFilter)(IUnknown *pFilter);
	STDMETHOD(GetEffectColor)( long Index, COLORREF *pcr);
	STDMETHOD(SetEffectColor)( long Index, COLORREF cr);
	STDMETHOD(GetCaretType)( long *pCaretType);     
	STDMETHOD(SetCaretType)( long CaretType);
	STDMETHOD(GetImmContext)( long *pContext);
	STDMETHOD(ReleaseImmContext)( long Context);
	STDMETHOD(GetPreferredFont)( long cp, long CodePage, long lOption, long curCodepage,
		long curFontSize, BSTR *pFontName, long *pPitchAndFamily, long *pNewFontSize);
	STDMETHOD(GetNotificationMode)( long *plMode);
	STDMETHOD(SetNotificationMode)( long lMode);
	STDMETHOD(GetClientRect)( long Type, long *pLeft, long *pTop, long *pRight, long *pBottom);
	STDMETHOD(GetSelectionEx)(ITextSelection **ppSel);
	STDMETHOD(GetWindow)( long *phWnd );
	STDMETHOD(GetFEFlags)( long *pFlags );
	STDMETHOD(UpdateWindow)( void );
	STDMETHOD(CheckTextLimit)( long cch, long *pcch );
	STDMETHOD(IMEInProgress)( long lMode );
	STDMETHOD(SysBeep)( void );
	STDMETHOD(Update)( long lMode );
    STDMETHOD(Notify)( long lNotify );
    STDMETHOD(GetDocumentFont)( ITextFont **ppITextFont );
    STDMETHOD(GetDocumentPara)( ITextPara **ppITextPara );
    STDMETHOD(GetCallManager)( IUnknown **ppVoid );
    STDMETHOD(ReleaseCallManager)( IUnknown *pVoid );

	// IRichEditOle methods
	STDMETHOD(GetClientSite) ( LPOLECLIENTSITE  *lplpolesite);
	STDMETHOD_(LONG,GetObjectCount) (THIS);
	STDMETHOD_(LONG,GetLinkCount) (THIS);
	STDMETHOD(GetObject) ( LONG iob, REOBJECT  *lpreobject,
						  DWORD dwFlags);
	STDMETHOD(InsertObject) ( REOBJECT  *lpreobject);
	STDMETHOD(ConvertObject) ( LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew);
	STDMETHOD(ActivateAs) ( REFCLSID rclsid, REFCLSID rclsidAs);
	STDMETHOD(SetHostNames) ( LPCSTR lpstrContainerApp, 
							 LPCSTR lpstrContainerObj);
	STDMETHOD(SetLinkAvailable) ( LONG iob, BOOL fAvailable);
	STDMETHOD(SetDvaspect) ( LONG iob, DWORD dvaspect);
	STDMETHOD(HandsOffStorage) ( LONG iob);
	STDMETHOD(SaveCompleted) ( LONG iob, LPSTORAGE lpstg);
	STDMETHOD(InPlaceDeactivate) (THIS);
	STDMETHOD(ContextSensitiveHelp) ( BOOL fEnterMode);
	STDMETHOD(GetClipboardData) ( CHARRANGE  *lpchrg, DWORD reco,
									LPDATAOBJECT  *lplpdataobj);
	STDMETHOD(ImportDataObject) ( LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict);


private:

	// Get/Set text helpers
	LONG	GetTextRange(LONG cpFirst, LONG cch, TCHAR *pch);
	LONG	GetTextEx(GETTEXTEX *pgt, TCHAR *pch);
	LONG	GetTextLengthEx(GETTEXTLENGTHEX *pgtl);

	//--------------------------------------------------------------
	// WinProc dispatch methods
	// Internally called by the WinProc
	//--------------------------------------------------------------

	// Keyboard
	HRESULT	OnTxKeyDown		  (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
	HRESULT	OnTxChar		  (DWORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
	HRESULT	OnTxSysChar		  (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
	HRESULT	OnTxSysKeyDown	  (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
	HRESULT	OnTxSpecialKeyDown(WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);

	// Mouse 
	HRESULT	OnTxLButtonDblClk(INT x, INT y, DWORD dwFlags);
	HRESULT	OnTxLButtonDown	 (INT x, INT y, DWORD dwFlags);
	HRESULT	OnTxLButtonUp	 (INT x, INT y, DWORD dwFlags, int ffOptions);
	HRESULT	OnTxRButtonDown	 (INT x, INT y, DWORD dwFlags);
	HRESULT	OnTxRButtonUp	 (INT x, INT y, DWORD dwFlags, int ffOptions);
	HRESULT	OnTxMouseMove	 (INT x, INT y, DWORD dwFlags, IUndoBuilder *publdr);
	HRESULT OnTxMButtonDown	 (INT x, INT y, DWORD dwFlags);
	HRESULT OnTxMButtonUp	 (INT x, INT y, DWORD dwFlags);
	
	// Timer
	HRESULT	OnTxTimer(UINT idTimer);
	void CheckInstallContinuousScroll ();
	void CheckRemoveContinuousScroll ();

	// Scrolling
	HRESULT	TxLineScroll(LONG cli, LONG cach);

	// Magellan mouse scrolling
	BOOL StopMagellanScroll();
	
	// Paint, size message
	LRESULT OnSize(HWND hwnd, WORD fwSizeType, int nWidth, int nHeight);

	// Selection commands
	LRESULT	OnGetSelText(TCHAR *psz);
	LRESULT OnGetSel(LONG *pacpMin, LONG *pacpMost);
	LRESULT	OnSetSel(LONG acpMin, LONG acpMost);
	void	OnExGetSel(CHARRANGE *pcr);

	// Editing commands
	void	OnClear(IUndoBuilder *publdr);
	
	// Format range related commands
	LRESULT	OnFormatRange(FORMATRANGE *pfr, SPrintControl prtcon, BOOL fSetupDC = FALSE);
	
	BOOL	OnDisplayBand(const RECT *prcView, BOOL fPrintFromDraw);

	// Scrolling commands
	void	OnScrollCaret();

	// Focus messages
	LRESULT OnSetFocus();
	LRESULT OnKillFocus();

	// System notifications
	HRESULT	OnContextMenu(LPARAM lparam);

	// Get/Set other properties commands
	LRESULT OnFindText(UINT msg, DWORD flags, FINDTEXTEX *pftex);
	LRESULT OnSetWordBreakProc();

	// Richedit stuff
		
	LRESULT	OnGetCharFormat(CHARFORMAT2 *pCF2, DWORD dwFlags);
	LRESULT	OnGetParaFormat(PARAFORMAT2 *pPF2, DWORD dwFlags);
	LRESULT	OnSetCharFormat(WPARAM wparam, CCharFormat *pCF, IUndoBuilder *publdr,
							DWORD dwMask, DWORD dwMask2);
	LRESULT	OnSetParaFormat(WPARAM wparam, CParaFormat *pPF, IUndoBuilder *publdr,
							DWORD dwMask, DWORD dwMask2);
	LRESULT	OnSetFont(HFONT hfont);
	LRESULT	OnSetFontSize(LONG yPoint, DWORD dwFlags, IUndoBuilder *publdr);

	LRESULT	OnDropFiles(HANDLE hDropFiles);

	LRESULT OnGetAssociateFont(CHARFORMAT2 *pCF, DWORD dwFlags);
	LRESULT OnSetAssociateFont(CHARFORMAT2 *pCF, DWORD dwFlags);

	// Other services
	HRESULT TxPosFromChar(LONG acp, LPPOINT ppt);
	HRESULT TxGetLineCount(LRESULT *plres);
	HRESULT	TxLineFromCp(LONG acp, LRESULT *plres);
	HRESULT	TxLineLength(LONG acp, LRESULT *plres);
	HRESULT	TxLineIndex (LONG ili, LRESULT *plres);
	HRESULT TxFindText(DWORD flags, LONG acpMin, LONG acpMost, const WCHAR *pch,
					   LONG *pacpMin, LONG *pacpMost);
	HRESULT TxFindWordBreak(INT nFunction, LONG acp, LRESULT *plres);

	HRESULT SetText(LPCWSTR pwszText, DWORD flags, LONG CodePage,
					IUndoBuilder *publdr = NULL, LRESULT *plres = NULL);
	LONG	GetDefaultCodePage(UINT msg);
	HRESULT OnInsertTable(TABLEROWPARMS *ptrp, TABLECELLPARMS *pclp, IUndoBuilder *publdr);


	// Other miscelleneous 
#if defined(DEBUG) && !defined(NOFULLDEBUG)
	void	OnDumpPed();
#endif

	COleObject * ObjectFromIOB(LONG iob);

	// Only when the selection is going away should this value be NULLed. We 
	// use SelectionNull function rather than CTxtSelection::~CTxtSelection 
	// to avoid circular dependencies.
	friend void SelectionNull(CTxtEdit *ped);
	void	SetSelectionToNull()
			{if(_fFocus)
				DestroyCaret();
				_psel = NULL;
			}

	// Helper for converting a rich text object to plain text.
	void HandleRichToPlainConversion();

	// Helper for clearing the undo buffers.
	void ClearUndo(IUndoBuilder *publdr);

	// Helper for setting the automatic EOP
	void SetRichDocEndEOP(LONG cchToReplace);

	LRESULT CTxtEdit::InsertFromFile ( LPCTSTR lpFile );
//
//	Data Members
//

public:	
	static DWORD 		_dwTickDblClick;	// time of last double-click
	static POINT 		_ptDblClick;		// position of last double-click

	static HCURSOR 		_hcurArrow;
//	static HCURSOR 		_hcurCross;			// OutlineSymbol drag not impl
	static HCURSOR 		_hcurHand;
	static HCURSOR 		_hcurIBeam;
	static HCURSOR 		_hcurItalic;
	static HCURSOR 		_hcurSelBar;
	static HCURSOR 		_hcurVIBeam;
	static HCURSOR 		_hcurVItalic;

	typedef HRESULT (CTxtEdit::*FNPPROPCHG)(BOOL fPropFlag);

	static FNPPROPCHG 	_fnpPropChg[MAX_PROPERTY_BITS];

	QWORD				_qwCharFlags;// Char flags for text in control

	// Only wrapper functions should use this member...
	ITextHost2*			_phost;		// host 

	// word break procedure
	EDITWORDBREAKPROC 	_pfnWB;		// word break procedure

	// display subsystem
	CDisplay *			_pdp;		// display
	CDisplayPrinter *	_pdpPrinter;// display for printer

	// undo
	IUndoMgr *			_pundo;		// the undo stack
	IUndoMgr *			_predo;		// the redo stack

	// data transfer
	CLightDTEngine 		_ldte;		// the data transfer engine

	CNotifyMgr 			_nm;		// the notification manager (for floating

	// OLE support
	CObjectMgr *		_pobjmgr;	// handles most high-level OLE stuff

	// Re-entrancy && Notification Management
	CCallMgr *			_pcallmgr;

	// URL detection
	CDetectURL *		_pdetecturl;// manages auto-detection of URL strings
	
	CDocInfo *			_pDocInfo;	// Document info (name, flags, code page)

	CTxtBreaker *		_pbrk;		// text-breaker object

 	DWORD				_dwEventMask;	// Event mask

	union
	{
	  DWORD _dwFlags;				// All together now
	  struct
	  {

#define TXTBITS (TXTBIT_RICHTEXT	  | \
				 TXTBIT_READONLY	  | \
				 TXTBIT_USEPASSWORD   | \
				 TXTBIT_HIDESELECTION | \
				 TXTBIT_VERTICAL	  | \
				 TXTBIT_ALLOWBEEP	 | \
				 TXTBIT_DISABLEDRAG   )

		//	State information. Flags in TXTBITS must appear in same bit
		//	positions as the following (saves code in Init())

		//	TXTBIT_RICHTEXT			0	_fRich
		//	TXTBIT_MULTILINE		1
		//	TXTBIT_READONLY			2	_fReadOnly
		//	TXTBIT_SHOWACCELERATOR	3
		//	TXTBIT_USEPASSWORD		4	_fUsePassword
		//	TXTBIT_HIDESELECTION	5	_fHideSelection
		//	TXTBIT_SAVESELECTION	6
		//	TXTBIT_AUTOWORDSEL		7		
		//	TXTBIT_VERTICAL			8	
		//	TXTBIT_SELECTIONBAR		9
		//	TXTBIT_WORDWRAP  		10
		//	TXTBIT_ALLOWBEEP		11	_fAllowBeep
		//  TXTBIT_DISABLEDRAG		12	_fDisableDrag
		//  TXTBIT_VIEWINSETCHANGE	13
		//  TXTBIT_BACKSTYLECHANGE	14
		//  TXTBIT_MAXLENGTHCHANGE	15
		//  TXTBIT_SCROLLBARCHANGE	16
		//  TXTBIT_CHARFORMATCHANGE 17
		//  TXTBIT_PARAFORMATCHANGE	18
		//  TXTBIT_EXTENTCHANGE		19
		//  TXTBIT_CLIENTRECTCHANGE	20

		DWORD	_fRich				:1;	// 0: Use rich-text formatting
		DWORD	_fCapture			:1;	// 1: Control has mouse capture
		DWORD	_fReadOnly			:1;	// 2: Control is read only
		DWORD 	_fInPlaceActive		:1;	// 3: Control is in place active
		DWORD	_fUsePassword		:1; // 4: Whether to use password char
		DWORD	_fHideSelection		:1; // 5: Hide selection when inactive
		DWORD	_fOverstrike		:1;	// 6: Overstrike mode vs insert mode
		DWORD	_fFocus				:1;	// 7: Control has keyboard focus
		DWORD	_fEatLeftDown		:1;	// 8: Eat the next left down?
		DWORD	_fMouseDown			:1;	// 9: One mouse button is current down
		DWORD	_fTransparent		:1;	// 10: Background transparency
		DWORD	_fAllowBeep			:1; // 11: Allow beep at doc boundaries
		DWORD   _fDisableDrag		:1;	// 12: Disable Drag

		DWORD	_fIconic			:1;	// 13: Control/parent window is iconized
		DWORD	_fModified			:1;	// 14: Control text has been modified
		DWORD	_fScrollCaretOnFocus:1;	// 15: Scroll caret into view on set focus
		DWORD	_fStreaming			:1;	// 16: Currently streaming text in or out
		DWORD	_fWantDrag			:1;	// 17: Want to initiate drag & drop
		DWORD	_fRichPrevAccel		:1; // 18: Rich state previous to accelerator
	
		// Miscellaneous bits
		DWORD	_f10Mode			:1;	// 19: Use Richedit10 behavior
		DWORD 	_fUseUndo			:1;	// 20: Only set to zero if undo limit is 0
	
		// Font binding (see also _fAutoFontSizeAdjust)
		DWORD	_fAutoFont			:1;	// 21: auto switching font
		DWORD	_fAutoKeyboard		:1;	// 22: auto switching keyboard

		DWORD	_fContinuousScroll	:1;	// 23: Timer runs to support scrolling
		DWORD	_fMButtonCapture	:1;	// 24: captured mButton down
		DWORD	_fHost2				:1;	// 25: TRUE iff _phost is a phost2
		DWORD	_fSaved				:1;	// 26: ITextDocument Saved property
		DWORD	_fInOurHost			:1; // 27: Whether we are in our host
		DWORD	_fCheckAIMM			:1;	// 28: if FALSE check if client has loaded AIMM
		DWORD	_fKoreanBlockCaret	:1;	// 29: Display Korean block caret during Kor IME

		// Drag/Drop UI refinement.
		DWORD	_fDragged			:1;	// 30: Was the selection actually dragged?
		DWORD	_fUpdateSelection	:1;	// 31: If true, update sel at level 0
	  };
	};

#define	CD_LTR	2
#define	CD_RTL	3

	WORD		_nContextDir		:2;	// 0: no context; else CD_LTR or CD_RTL
	WORD		_nContextAlign		:2;	// Current context alignment; default CTX_NONE
	WORD		_fNeutralOverride	:1;	// Override direction of neutrals for layout
	WORD		_fSuppressNotify	:1;	// Don't send SelChange Notification if True

	WORD		_cActiveObjPosTries :2; // Counter protecting against infinite repaint 
										// loop when trying to put dragged-away 
										// in-place active object where it belongs

	WORD		_fSingleCodePage	:1;	// If TRUE, only allow single code page
										// (currently doesn't check streaming...)
	WORD		_fSelfDestruct		:1;	// This CTxtEdit is selfdestructing
	WORD		_fAutoFontSizeAdjust:1;	// Auto switching font size adjust

	// Miscellaneous bits used for BiDi input
	WORD		_fHbrCaps			:1;	// Initialization of state of hebrew and caps lock status
 
	WORD		_fActivateKbdOnFocus:1;	// Activate new kbd layout on WM_SETFOCUS
	WORD		_fOutlineView		:1;	// Outline view is active
	WORD		_fPageView			:1;	// Page view is active

	// More IME bit
	WORD		_fIMEInProgress		:1; // TRUE if IME composition is in progress

	WORD		_ClipboardFormat	:5;	// Last clipboard format used (see EN_CLIPFORMAT)

	// Shutdown bit
	WORD		_fReleaseHost			:1;	// TRUE if edit control needs to release host in 
											// edit control destructor.
	WORD		_fOOMNotified			:1;	// flag determining if a OOM notification was already sent	
	WORD		_fDualFont				:1;	// Dual font support for FE typing
											//	Default = TRUE
	WORD		_fUIFont				:1; // If TRUE, use UI font
	WORD		_fItemizePending		:1; // Updated range hasn't been itemized
	WORD		_fSelChangeCharFormat	:1;	// TRUE if the selection has been used to change
											// the character format of a specific set of
											// characters. The purpose of this has to do with
											// maintaining the illusion of having a default
											// charformat on machines whose default language
											// is a complex script i.e. Arabic. The idea is
											// that all EM_SETCHARFORMAT messages that would
											// just update the default format, are converted
											// to SCF_ALL so that all the text has the change
											// applied to it. Bug 5462 caused this change.
											// (a-rsail).
	WORD		_fExWordBreakProc		:1;	// detemines which WordbreakProc Callback to use
											// Extended or regular
	WORD		_f10DeferChangeNotify	:1;	// 1.0 mode immulation, defer selection change
											// notification until the mouse is up

	union
	{
		DWORD	_dwEditStyle;
		struct
		{
			DWORD	_fSystemEditMode	:1;	//        1: Behave more like sys edit
			DWORD	_fSystemEditBeep	:1;	//        2: Beep when system edit does
			DWORD	_fExtendBackColor	:1; //        4: Extend BkClr to margin
			DWORD	_fUnusedEditStyle1	:1;	//        8: SES_MAPCPS not used
			DWORD	_fUnusedEditStyle2	:1;	//       16: SES_EMULATE10 not used
			DWORD	_fUnusedEditStyle3	:1;	//       32: SES_USECRLF not used
			DWORD	_fUnusedEditStyle4	:1;	//       64: SES_USEAIMM handled in cmsgflt
			DWORD	_fUnusedEditStyle5	:1;	//      128: SES_NOIME handled in cmsgflt
			DWORD	_fUnusedEditStyle6	:1; //      256: SES_ALLOWBEEPS not used
			DWORD	_fUpperCase			:1;	//      512: Convert all input to upper case
			DWORD	_fLowerCase			:1;	//     1024: Convert all input to lower case
			DWORD	_fNoInputSequenceChk:1;	//     2048: Disable ISCheck
			DWORD	_fBiDi				:1;	//     4096: Set Bidi document
			DWORD	_fScrollCPOnKillFocus:1;//     8192: Scroll to cp=0 upon Kill focus
			DWORD	_fXltCRCRLFtoCR		:1;	//    16384: Translate CRCRLF to CR instead of ' '
			DWORD	_fDraftMode			:1;	//    32768: Use draftmode fonts
			DWORD	_fUseCTF			:1;	// 0x010000: SES_USECTF handled in cmsgflt
			DWORD	_fHideGridlines		:1;	// 0x020000: if 0-width gridlines not displayed
			DWORD	_fUseAtFont			:1;	// 0x040000: use @ font
			DWORD	_fCustomLook		:1;	// 0x080000: use new look
			DWORD	_fLBScrollNotify	:1;	// 0x100000: REListbox - notify before/after scroll window
		};
	};

	void (WINAPI* _pfnHyphenate)(WCHAR*, LANGID, long, HYPHRESULT*);
	SHORT		_dulHyphenateZone;		// Hyphenation zone

	ITextMsgFilter *	_pMsgFilter;		// Pointer to message filter.

#ifndef NOPRIVATEMESSAGE
	CMsgCallBack *		_pMsgCallBack;
	CTextNotify	*		_pMsgNotify;
#endif

private:

	SHORT		_cpAccelerator;			// Range for accelerator
	BYTE		_bTypography;			// Typography options
	BYTE		_bMouseFlags;			// CTRL, Mouse buttons, SHIFT
	SHORT		_cFreeze;				// Freeze count
	WORD		_wZoomNumerator;
	WORD		_wZoomDenominator;

	// Have to have mouse point on a per-instance basis to handle
	// simultaneous scrolling of two or more controls.
	// TODO: convert this back to DWORD from whence it came (lparam)
	POINT		_mousePt;				// Last known mouse position.

	// NOTE: the int's can be switched to SHORTs, since pixels are used and
	// 32768 pixels is a mighty big screen! 

	DWORD		_cchTextMost;			// Maximum allowed text

	LONG		_cpFirstStrong;			// cp of first strong directional character.
										// used for plain text controls whose direcitonality
										// depends on text input into the control.


	friend class CRchTxtPtr;

	IUnknown *	_punk;					// IUnknown to use

	class CUnknown : public IUnknown
	{
		friend class CCallMgr;
	private:

		DWORD	_cRefs;					// Reference count

	public:

		void	Init() {_cRefs = 1; }

		HRESULT WINAPI	QueryInterface(REFIID riid, void **ppvObj);
		ULONG WINAPI	AddRef();
		ULONG WINAPI	Release();
	};

	friend class CUnknown;

	CUnknown			_unk;				// Object that implements IUnknown	
	CTxtStory			_story;
	CTxtSelection *		_psel;				// Selection object

};

extern const COLORREF g_Colors[];
class CCellColor
{
public:
	COLORREF	_crCellCustom1;		// Custom color 1
	COLORREF	_crCellCustom2;		// Custom color 2

	CCellColor()	{_crCellCustom1 = _crCellCustom2 = 0;}
	LONG	GetColorIndex(COLORREF cr);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_format.h ===
/*
 *	_FORMAT.H
 *	
 *	Purpose:
 *		CCharFormatArray and CParaFormatArray
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _FORMAT_H
#define _FORMAT_H

#include "textserv.h"

#define celGrow     8
#define FLBIT		0x80000000

//+-----------------------------------------------------------------------
// 	Interface IFormatCache
// 	Interface ICharFormatCache
// 	Interface IParaFormatCache
//
//	Format caches - Used by the host to manage the cache of CHARFORMAT
// 	and PARAFORMAT structures.  Note that these interfaces DON'T derive from
//  IUnknown
//------------------------------------------------------------------------

interface IFormatCache
{
	virtual LONG		AddRef(LONG iFormat) = 0;
	virtual LONG	 	Release(LONG iFormat) = 0;
	virtual void		Destroy() = 0;
};

template <class FORMAT>
interface ITextFormatCache : public IFormatCache
{
	virtual HRESULT 	Cache(const FORMAT *pFormat, LONG *piFormat) = 0;
	virtual HRESULT		Deref(LONG iFormat, const FORMAT **ppFormat) const = 0;
};

interface ICharFormatCache : public ITextFormatCache<CCharFormat>
{
};

interface IParaFormatCache : public ITextFormatCache<CParaFormat>
{
};

void	ReleaseFormats(LONG iCF, LONG iPF);

HRESULT	CreateFormatCaches();
HRESULT	DestroyFormatCaches();


// ===========================  CFixArray  =================================

// This array class ensures stability of the indexes. Elements are freed by
// inserting them in a free list, and the array is never shrunk.
// The first UINT of ELEM is used to store the index of next element in the
// free list.

class CFixArrayBase
{
private:
	char*	_prgel;			// array of elements
	LONG 	_cel;			// total count of elements (including free ones)
	LONG	_ielFirstFree; 	// - first free element
	LONG 	_cbElem;		// size of each element
#ifdef _WIN64
	LONG	_cbPad;			// use in Win64 to make sure each element + RefCount is
							//	64 bit aligned.
#else
	#define _cbPad	0
#endif

public:
	CFixArrayBase (LONG cbElem);
	~CFixArrayBase ()				{Free();}

	void*	Elem(LONG iel) const	{return _prgel + iel * _cbElem;}
	LONG 	Count() const			{return _cel;}

	LONG 	Add ();
	void 	Free (LONG ielFirst);
	void 	Free ();

	HRESULT	Deref  (LONG iel, const void **ppel) const;
	LONG	AddRef (LONG iel);
	LONG	Release(LONG iel);
	HRESULT	Cache  (const void *pel, LONG *piel);

#ifdef DEBUG
	void CheckFreeChainFn(LPSTR szFile, INT nLine); 
#endif

protected:
	LONG &	RefCount(LONG iel);

private:
	LONG	Find   (const void *pel);
};

template <class ELEM> 
class CFixArray : public CFixArrayBase
{
public:
	CFixArray () : CFixArrayBase (sizeof(ELEM)) 	{}
											//@cmember Get ptr to <p iel>'th
	ELEM *	Elem(LONG iel) const			// element
			{return (ELEM *)CFixArrayBase::Elem(iel);}

protected:									//@cmember Get ptr to <p iel>'th
	LONG &	RefCount(LONG iel)				// ref count
			{return CFixArrayBase::RefCount(iel);}
};

#ifdef DEBUG
#define CheckFreeChain()\
			CheckFreeChainFn(__FILE__, __LINE__)
#else
#define CheckFreeChain()
#endif // DEBUG


//================================  CCharFormatArray  ==============================

class CCharFormatArray : public CFixArray<CCharFormat>, public ICharFormatCache
{
protected:
	LONG 	Find(const CCharFormat *pCF);

public:
	CCharFormatArray() : CFixArray<CCharFormat>()	{}

	// ICharFormatCache
	virtual HRESULT		Cache(const CCharFormat *pCF, LONG *piCF);
	virtual HRESULT		Deref(LONG iCF, const CCharFormat **ppCF) const;
	virtual LONG	 	AddRef(LONG iCF);
	virtual LONG	 	Release(LONG iCF);
	virtual void		Destroy();
};


//===============================  CParaFormatArray  ==================================

class CParaFormatArray : public CFixArray<CParaFormat>, public IParaFormatCache
{
protected:	
	LONG 	Find(const CParaFormat *pPF);

public:
	CParaFormatArray() : CFixArray<CParaFormat>()	{}

	// IParaFormatCache
	virtual HRESULT 	Cache(const CParaFormat *pPF, LONG *piPF);
	virtual HRESULT		Deref(LONG iPF, const CParaFormat **ppPF) const;
	virtual LONG	 	AddRef(LONG iPF);
	virtual LONG	 	Release(LONG iPF);
	virtual void		Destroy();
};


//===============================  CTabsArray  ==================================

class CTabsArray : public CFixArray<CTabs>
{
protected:	
	LONG 		Find(const LONG *prgxTabs, LONG cTab);

public:
	CTabsArray() : CFixArray<CTabs>()	{}
	~CTabsArray();

	LONG 		Cache(const LONG *prgxTabs, LONG cTab);
	const LONG *Deref(LONG iTabs) const;

	LONG	 	AddRef (LONG iTabs);
	LONG	 	Release(LONG iTabs);
};

// Access to the format caches
ICharFormatCache *GetCharFormatCache();
IParaFormatCache *GetParaFormatCache();
CTabsArray		 *GetTabsCache();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_hyph.h ===
/*
 *	_HYPH.H
 *	
 *	Purpose:
 *		CHyphCache class
 *	
 *	Authors:
 *		Keith Curtis
 */

#ifndef _HYPH_H
#define _HYPH_H

//This structure should only be used by the CHyphCache class
struct HYPHENTRY
{
	UINT khyph;
	WCHAR chHyph;
};

class CHyphCache : private CArray <HYPHENTRY>
{
	int Add(UINT khyph, WCHAR chHyph);

public:
	int Find(UINT khyph, WCHAR chHyph);
	void GetAt(int iHyph, UINT &khyph, WCHAR &chHyph);
};

#endif //_HYPH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_font.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _FONT.H -- Declaration of classes comprising font caching |
 *	
 *	Purpose:
 *		Font cache
 *	
 *	Owner: <nl>
 *		David R. Fulmer (original RE 1.0 code)<nl>
 *		Christian Fortini (initial conversion to C++)<nl>
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		8/6/95		jonmat Devised dynamic expanding cache for widths.
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#ifndef _FONT_H
#define _FONT_H

#include "_kern.h"

// Forwards
class CFontCache;
class CDevDesc;
class CDisplay;
// =============================  CCcs  ========================
// CCcs - caches font metrics and character size for one font

#define DEFAULTCACHESIZE	0			// size - 1
#define INITIALCACHESIZE	7			// size - 1 = 7; 2^n-1; size = 8
#define PERFCHECKEPOCH		64			// If changed, you must recalc
										//  and change COLLISION_SHIFT below.

static const INT maxCacheSize = 511;

SHORT GetFontNameIndex(const WCHAR *pFontName);
BYTE  GetFontLegitimateSize(LONG iFont, BOOL fUIFont, int iCharRep);
BOOL  SetFontLegitimateSize(LONG iFont, BOOL fUIFont, BYTE bSize, BOOL fFEcpg);
void  SetFontSignature(LONG iFont, QWORD qwFontSig);
const WCHAR *GetFontName(LONG iFont);
UINT  GetTextCharsetInfoPri(HDC hdc, FONTSIGNATURE* pcsi, DWORD dwFlags);
QWORD GetFontSignatureFromFace(int ifont, QWORD* pqwFontSig = NULL);
void  FreeFontNames();

enum FONTINDEX
{
	IFONT_ARIAL		= 0,
	IFONT_TMSNEWRMN	= 1,
	IFONT_SYMBOL	= 2,
	IFONT_SYSTEM	= 3
};

typedef unsigned int CCSHASHKEY;

extern const WCHAR *szArial;
extern const WCHAR *szTimesNewRoman;
extern const WCHAR *szSymbol;
extern const WCHAR *szSystem;
extern const WCHAR *szWingdings;

//Not automatically added to font table
extern const WCHAR *szMicrosSansSerif;
extern const WCHAR *szMSSansSerif;
extern const WCHAR *szMangal;
extern const WCHAR *szLatha;
extern const WCHAR *szRaavi;
extern const WCHAR *szShruti;
extern const WCHAR *szTunga;
extern const WCHAR *szGautami;
extern const WCHAR *szCordiaNew;
extern const WCHAR *szTahoma;
extern const WCHAR *szArialUnicode;
extern const WCHAR *szSylfaen;
extern const WCHAR *szSyriac;
extern const WCHAR *szThaana;

/*
 *	CWidthCache
 *
 *	@class	Lightweight Unicode width cache.
 *
 *
 *	Owner: <nl>
 *		Jon Matousek (jonmat) <nl>
 */
struct CacheEntry
{
	WCHAR	ch;
	SHORT	width;
};

class CWidthCache 
{
//@access	Private methods and data
	friend class CCcs;
private:
						
	INT		_cacheSize;			//@cmember	size is total cache slots - 1.

	INT		_cacheUsed;			//@cmember	for statistics, num slots in use.
	INT		_collisions;		//@cmember	for statistics, num fetches required.
	INT		_accesses;			//@cmember	for statistics, total num accesses.
	BOOL	_fMaxPerformance;	//@cmember	for statistics, TRUE if grown to max.

	SHORT	_dupCJK;
							//@cmember	default storage for widths.
	CacheEntry	_defaultWidthCache[DEFAULTCACHESIZE+1];
							//@cmember	pointers to storage for widths.
	CacheEntry *(_pWidthCache);

	__forceinline BOOL	FLookasideCharacter(WCHAR ch)
	{
		if (ch < 0x3400)
			return FALSE;

		if (IN_RANGE(0x3400, ch, 0x9FFF) ||		// CJK ideograph
			IN_RANGE(0xF900, ch, 0xFAFF) ||		// CJK compatibility ideograph
			IN_RANGE(0xAC00, ch, 0xD7FF))		// Hangul
			 return TRUE;

		return FALSE;
	}

							//@cmember	Get location where width is stored.
	inline CacheEntry * GetEntry( const WCHAR ch )
	{	// logical & is really a MOD, as all of the bits
		// of cacheSize are turned on; the value of cacheSize is
		// required to be of the form 2^n-1.
		return &_pWidthCache[ ch & _cacheSize ];
	}

							//@cmember	See if cache is performing within spec.
	void	CheckPerformance();
							//@cmember	Increase width cache size.
	BOOL	GrowCache( CacheEntry **widthCache, INT *cacheSize, INT *cacheUsed);

	//@access Public Methods
	public:
							//@cmember	Called before GetWidth
	BOOL	CheckWidth (const WCHAR ch, LONG &dup);
							//@cmember	Fetch width if CheckWidth ret FALSE.

	void	Free();			//@cmember	Recycle width cache

	CWidthCache();			//@cmember	Construct width cache
	~CWidthCache();			//@cmember	Free dynamic mem
};


class CCcs
{
	friend class CFontCache;

private:
	CCSHASHKEY _ccshashkey;	// Hash key
	DWORD 	_dwAge;			// for LRU algorithm
	SHORT	_iFont;			// Index into FONTNAME table
	SHORT	_cRefs;			// ref. count

	class CWidthCache _widths;

public:
	QWORD	_qwFontSig;		// Internal font signature flags

	HDC		_hdc;			// HDC font is selected into
	HFONT 	_hfont;			// Windows font handle

	void*	_sc;			// A handle to the Uniscribe glyph width/font cmap information

	//REVIEW (keithcu) We should make these into at least 24 bit or possibly 32 bit values,
	//or at least use unsigned values so that we don't overflow as easily.
	SHORT	_yHeightRequest;// Font height requested (logical units)
	SHORT	_yHeight;		// Total height of char cell (logical units)
	SHORT 	_yDescent;		// Distance from baseline to char cell bottom (logical units)

	SHORT	_xAveCharWidth;	// Average character width in logical units
	SHORT 	_xOverhangAdjust;// Overhang for synthesized fonts in logical units

	SHORT	_dyULOffset;	// Underline offset
	SHORT	_dyULWidth;		// Underline width
	SHORT	_dySOOffset;	// Strikeout offset
	SHORT	_dySOWidth;		// Strikeout width

	USHORT	_weight;		// Font weight
	USHORT	_wCodePage;		// Font code page

	BYTE	_bCharSetRequest; //Requested charset
	BYTE	_bCharSet;		// Font CharSet
	BYTE	_bCMDefault;	// Used in calculation of _bConvertMode
	BYTE	_bConvertMode;	// CONVERTMODE: CVT_NONE, CVT_WCTMB, CVT_LOWBYTE

	BYTE	_bPitchAndFamily;// Font pitch and family
	TFLOW	_tflow;			 // Tflow of _hfont
	BYTE	_bQuality;		 // LOGFONT quality

	BYTE 	_fValid:1;			// CCcs is valid
	BYTE	_fFixPitchFont:1;	// Font has fixed character width
	BYTE	_fItalic:1;			// Font is italic
	BYTE	_fFECharSet:1;		// Font has FE charset
	BYTE	_fForceTrueType:1;	// Font has been forced to be truetype
	BYTE	_fCustomTextOut:1;	// Should we use the ICustomTextOut handlers?
	BYTE	_fUseAtFont:1;		// Switch to @ font

private:

    BOOL    Compare (const CCharFormat * const pCF, HDC hdc, DWORD dwFlags);
    BOOL    MakeFont(const CCharFormat * const pCF);
	void 	DestroyFont();
	BOOL	GetMetrics(WCHAR *szNewFaceName = 0);
	HFONT	GetFontWithMetrics(LOGFONT *plf, WCHAR* szNewFaceName);
	BOOL	FillWidth(WCHAR ch, LONG &dup);

public:
	CCcs ()		{_fValid = FALSE;}
	~CCcs ()	{if(_fValid) Free();}

	void GetFontOverhang(LONG *pdupOverhang, LONG *pdupUnderhang);
	void GetOffset(const CCharFormat * const pCF, LONG dvpInch,
				   LONG *pyOffset, LONG *pyAdjust);

	BOOL 	Init(const CCharFormat * const pCF);
	void 	Free();
	void 	AddRef() 				{_cRefs++;}
	void 	Release() 				{if(_cRefs) _cRefs--;}

	BOOL	Include(WCHAR ch, LONG &dup)
	{
		if(!_widths.CheckWidth(ch, dup))
			return FillWidth(ch, dup);
		return TRUE;
	}
	BYTE	BestCharRep(BYTE iCharRep, BYTE iCharRepDefault, int fFontMatching);

	SHORT	AdjustFEHeight(BOOL fAjdust)
			{return ((fAjdust && _fFECharSet) ? W32MulDiv(_yHeight, 15, 100) : 0);}
};


// FONTINFO cache

typedef union 
{
	WORD	wFlags;
	struct
	{
		WORD	fCached			:1;		// Font signature was already cached
		WORD	fBadFaceName	:1;		// Face is junk or doesnt exist in the system
		WORD	fTrueType		:1;		// Font is TrueType
		WORD	fBitmap			:1;		// Font is Bitmap
		WORD	fNonBiDiAscii	:1;		// Font is non-BiDi, single charset and support ASCII
		WORD	fScaleByCpg		:1;		// Scale the font based on given codepage
		WORD	fThaiDTP		:1;		// Thai DTP font
	};
} FONTINFO_FLAGS;

class CFontFamilyMember
{
public:
	CFontFamilyMember(LONG weight, BOOL fItalic)
	{
		_weight = weight; _fItalic = fItalic;
	}
	void Free() {_kc.Free();}
	CKernCache* GetKernCache() {return &_kc;}

	LONG		_weight;
	BOOL		_fItalic;
	CKernCache  _kc;
};

class CFontFamilyMgr
{
public:
	CFontFamilyMgr::~CFontFamilyMgr();
	CFontFamilyMember *GetFontFamilyMember(LONG weight, BOOL fItalic);
	CArray <CFontFamilyMember> _rgf;
};


struct FONTINFO
{
	const WCHAR 	*szFontName;
	QWORD 			qwFontSig; 			// Font signature
	BYTE			bSizeUI;			// UI font legitimate size (in point)
	BYTE			bSizeNonUI;			// Non-UI font legitimate size
	FONTINFO_FLAGS	ff;					// flags
	CFontFamilyMgr*	_pffm;				// Information which is different for
};										//  bold/italic variants of a font



// =============================  CFontCache  =====================================================
// CFontCache - maintains up to FONTCACHESIZE font caches

//The low 2 bits are reserved for passing down the TFLOW of the text
const DWORD FGCCSUSETRUETYPE = 0x04;
const DWORD FGCCSUSEATFONT = 0x08;

class CFontCache
{
	friend class CCcs;

private:
	CCcs	_rgccs[FONTCACHESIZE];
	DWORD 	_dwAgeNext;
	struct {
		CCSHASHKEY	ccshashkey;
		CCcs		*pccs;
	} quickHashSearch[CCSHASHSEARCHSIZE+1];

private:
	CCcs* 	GrabInitNewCcs(const CCharFormat * const pCF, HDC hdc, DWORD dwFlags);
	CCSHASHKEY MakeHashKey(const CCharFormat *pCF);
public:
	void Init();

	CFontFamilyMgr * GetFontFamilyMgr(LONG iFont);
	CKernCache * GetKernCache(LONG iFont, LONG weight, BOOL fItalic);

	CCcs*	GetCcs(CCharFormat *pCF, const LONG dvpInch, DWORD dwFlags, HDC hdc = 0);
	FONTINFO_FLAGS	GetInfoFlags(int ifont);
};


extern CFontCache & fc();			// font cache manager

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_frunptr.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _FRUNPTR.H  -- CFormatRunPtr class declaration |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		06-25-95	alexgo	cleanup and commenting
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _FRUNPTR_H
#define _FRUNPTR_H

#include "_array.h"
#include "_text.h"
#include "_runptr.h"
#include "_format.h"

#define	CharFormat 0
#define	ParaFormat 1


typedef enum {
	IGNORE_CURRENT_FONT = 0,
	MATCH_CURRENT_CHARSET = 1,
	MATCH_FONT_SIG = 2,
	MATCH_ASCII = 4,
	GET_HEIGHT_ONLY = 8,
} FONT_MATCHING;

/*
 *	CFormatRunPtr
 *
 *	@class	A Run pointer over an array of CFormatRun structures.
 *	This pointer understands how to add remove character/paragraph
 *	formatting
 *
 *	@base	public | CRunPtr<lt>CFormatRun<gt>
 *
 *	@devnote	The format run pointer has one extra interesting state
 *				transistion beyond the normal CRunPtrBase transistions.
 *
 *				If this run pointer is in the NULL state, then InitRuns may
 *				be used to create or fetch the correct run array for the
 *				run pointer.  Note that if a run array is already allocated
 *				it will be simply be fetched and used.  This allows us to
 *				treat unitialized run pointers the same as run pointers to
 *				an uninitialized document.
 *				@xref See also <mf CFormatRunPtr::InitRuns>
 */
class CFormatRunPtr : public CRunPtr<CFormatRun>
{
	friend class CRchTxtPtr;
	friend class CTxtRange;
	friend class CReplaceFormattingAE;
	friend class CUniscribe;

//@access Public Methods
public:
#ifdef DEBUG
	BOOL	Invariant(void) const;			//@cmember	Invariant tests
#endif
								
	CFormatRunPtr(const CFormatRunPtr &rp)	//@cmember	Copy Constructor
		: CRunPtr<CFormatRun>((CRunPtrBase&)rp) {}
								
	CFormatRunPtr(CFormatRuns *pfr)			//@cmember	Constructor
		: CRunPtr<CFormatRun>((CRunArray *)pfr) {}
								
	short	GetFormat() const;			//@cmember	Get current format index

	void	SetLevel (CBiDiLevel& level);		//@cmember Set run's embedding level
	
	BYTE	GetLevel (CBiDiLevel* pLevel = NULL);//@cmember Get run's embedding level

	BOOL	SameLevel (CFormatRunPtr* prp)
	{
		return !(IsValid() && GetRun(0)->_level._value != prp->GetRun(0)->_level._value);
	}

	BOOL	SameLevel (BYTE	bLevel)
	{
		return !(IsValid() && GetRun(0)->_level._value != bLevel);
	}

//@access Private Methods
private:
								//@cmember Format Run Array management
	BOOL	InitRuns(LONG ich, LONG cch, CFormatRuns **ppfrs);
								//@cmember Formatting replacement
	void	Delete(LONG cch, IFormatCache *pf, LONG cchMove);
								//@cmember Formatting insertion
	LONG	InsertFormat(LONG cch, LONG iformat, IFormatCache *pf);
								//@cmember Merge two adjacent formatting runs
	void	MergeRuns(LONG iRun, IFormatCache *pf);
								//@cmember Split run
	void	SplitFormat(IFormatCache *pf);
								//@cmember Sets the format for the current run
	LONG	SetFormat(LONG ifmt, LONG cch, IFormatCache *pf, CBiDiLevel* pLevel = NULL);
								//@cmember Extends formatting from previous run
	void	AdjustFormatting(LONG cch, IFormatCache *pf);
								//@cmember Remove <p cRun>
	void 	Remove (LONG cRun, IFormatCache *pf);
};


enum MASKOP
{
	MO_OR = 0,
	MO_AND,
	MO_EXACT
};

class CTxtEdit;

class CCFRunPtr : public CFormatRunPtr
{
	friend class CRchTxtPtr;
	friend class CTxtRange;

public:
	CTxtEdit *_ped;

	CCFRunPtr(const CRchTxtPtr &rtp);	//@cmember	Copy Constructor
	CCFRunPtr(const CFormatRunPtr &rp, CTxtEdit *ped);

	LONG	CountAttributes(LONG cUnit, LONG cchMax, LONG cp, LONG cchText, LONG Unit)
						{return 0;}
	BOOL	IsHidden()	{return IsMask(CFE_HIDDEN);}
	BOOL	IsLinkProtected()	{return IsMask(CFE_LINKPROTECTED);}
	BOOL	IsMask(DWORD dwMask, MASKOP mo = MO_OR);

	BOOL	IsInHidden();			//@cmember True if in hidden text
	LONG	FindUnhidden();			//@cmember Find nearest unhidden CF
	LONG	FindUnhiddenBackward();	//@cmember Find previous unhidden CF
	LONG	FindUnhiddenForward();	//@cmember Find previous unhidden CF
	const CCharFormat *	GetCF()
				{return _ped->GetCharFormat(GetFormat());}
	DWORD	GetEffects()
				{return GetCF()->_dwEffects;}

	int		MatchFormatSignature(const CCharFormat* pCF, int iCharRep, int fMatchCurrent, QWORD* pqwFontSig = NULL);

	//@member Get font info for code page
	bool GetPreferredFontInfo(
		BYTE	iCharRep,
		BYTE &	iCharRepRet,
		SHORT &	iFont,
		SHORT &	yHeight,
		BYTE &	bPitchAndFamily,
		int		iFormat,
		int		iMatchCurrent = MATCH_FONT_SIG,
		int		*piFormat = NULL
	);
};

class CPFRunPtr : public CFormatRunPtr
{
	friend class CRchTxtPtr;
	friend class CTxtRange;

public:
	CTxtEdit *_ped;

	CPFRunPtr(const CRchTxtPtr &rtp);	//@cmember	Copy Constructor
								//@cmember Find Heading before cpMost
	LONG	FindHeading(LONG cch, LONG& lHeading);
	BOOL	FindRowEnd(LONG TableLevel);//@cmember Move past row end
	BOOL	InTable();			//@cmember True if paraformat is in table
	BOOL	IsCollapsed();		//@cmember True if paraformat is collapsed
	BOOL	IsTableRowDelimiter();//@cmember True if paraformat is TableRowDelimeter
	LONG	FindExpanded();		//@cmember Find nearest expanded PF
	LONG	FindExpandedBackward();//@cmember Find previous expanded PF
	LONG	FindExpandedForward();//@cmember Find next expanded PF
	const CParaFormat *	GetPF()
				{return _ped->GetParaFormat(GetFormat());}
	LONG	GetOutlineLevel();	//@cmember Get outline level
	LONG	GetStyle();			//@cmember Get style
	LONG	GetMinTableLevel(LONG cch);//@cmember Get min tbl lvl in cch chars
	LONG	GetTableLevel();	//@cmember Get table level at this ptr
	BOOL	ResolveRowStartPF();//@cmember Resolve table row start PF 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_host.h ===
/*	@doc INTERNAL
 *
 *	@module _HOST.H  Text Host for Window's Rich Edit Control |
 *	
 *
 *	Original Author: <nl>
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		8/1/95	ricksa	Revised interface definition
 */
#ifndef _HOST_H
#define _HOST_H

#ifndef NOWINDOWHOSTS

#include "textserv.h"
#include "textsrv2.h"
#include "dynarray.h"

#ifndef NOACCESSIBILITY
// UNDONE:
//	Need to include this file int the project
#include "oleacc.h"
#endif

#include "_notmgr.h"

/*
 *	TXTEFFECT
 *
 *	@enum	Defines different background styles control
 */
enum TXTEFFECT {
	TXTEFFECT_NONE = 0,				//@emem	no special backgoround effect
	TXTEFFECT_SUNKEN,				//@emem	draw a "sunken 3-D" look
};


// @doc EXTERNAL 

// ============================  CTxtWinHost  ================================================
// Implement the windowed version of the Plain Text control

/*
 *	CTxtWinHost
 *	
 * 	@class	Text Host for Window's Rich Edit Control implementation class
 *
 */
class CTxtWinHost : public ITextHost2
#ifndef NOACCESSIBILITY
	, public IAccessible
#endif
{

public:
	HWND		_hwnd;					// control window
	HWND		_hwndParent;			// parent window

	ITextServices	*_pserv;			// pointer to Text Services object

	ULONG		_crefs;					// reference count

// Properties

	DWORD		_dwStyle;				// style bits
	DWORD		_dwExStyle;				// extended style bits

	unsigned	_fBorder			:1;	// control has border
	unsigned	_fInBottomless		:1;	// inside bottomless callback
	unsigned	_fInDialogBox		:1;	// control is in a dialog box
	unsigned	_fEnableAutoWordSel	:1;	// enable Word style auto word selection?
	unsigned	_fIconic			:1;	// control window is iconic
	unsigned	_fHidden			:1;	// control window is hidden
	unsigned	_fNotSysBkgnd		:1;	// not using system background color
	unsigned	_fWindowLocked		:1;	// window is locked (no update)
	unsigned	_fRegisteredForDrop	:1; // whether host has registered for drop
	unsigned	_fVisible			:1;	// Whether window is visible or not.
	unsigned	_fResized			:1;	// resized while hidden
	unsigned	_fDisabled			:1;	// Window is disabled.
	unsigned	_fKeyMaskSet		:1;	// if ENM_KEYEVENTS has been set
	unsigned	_fMouseMaskSet		:1;	// if ENM_MOUSEEVENTS has been set
	unsigned	_fScrollMaskSet		:1;	// if ENM_SCROLLEVENTS has been set
	unsigned	_fUseSpecialSetSel	:1; // TRUE = use EM_SETSEL hack to not select
										// empty controls to make dialog boxes work.
	unsigned	_fEmSetRectCalled	:1;	// TRUE - application called EM_SETRECT
	unsigned	_fAccumulateDBC		:1;	// TRUE - need to cumulate ytes from 2 WM_CHAR msgs
										// we are in this mode when we receive VK_PROCESSKEY
	unsigned	_fANSIwindow		:1;	// TRUE - window created as "RichEdit20A"
	unsigned	_fTextServiceFree	:1;	// TRUE - Text Services freed at shutdown.
	unsigned	_fMouseover			:1; // TRUE - Mouse Over window
	COLORREF 	_crBackground;			// background color
    RECT        _rcViewInset;           // view rect inset /r client rect

	HIMC		_oldhimc;				// previous IME Context
	// TODO: the following could be a two-bit field as part of the unsigned field above
	DWORD		_usIMEMode;				// mode of IME operation
										// either 0 or ES_SELFIME or ES_NOIME
	HPALETTE	_hpal;					// Logical palette to use.

	TCHAR		_chPassword;			// Password char. If null, no password
	TCHAR		_chLeadByte;			// use when we are in _fAccumulateDBC mode
	SHORT		_sWidth;				// Last client width given by WM_SIZE
	char		_yInset;
	char		_xInset;
	CTxtWinHost	*_pnextdel;


public:
	// Initialization
	virtual BOOL Init(
					HWND hwnd, 
					const CREATESTRUCT *pcs,
					BOOL fIsAnsi,
					BOOL fIs10Mode);

	void	SetScrollBarsForWmEnable(BOOL fEnable);


	void	OnSetMargins(
				DWORD fwMargin,
				DWORD xLeft,
				DWORD xRight);

	virtual void	SetScrollInfo(
				INT fnBar,
				BOOL fRedraw);

	// helpers
	HRESULT	CreateTextServices();
	void *	CreateNmhdr(UINT uiCode, LONG cb);
	void	HostRevokeDragDrop(void);
	void	HostRegisterDragDrop();
	void    OnSunkenWindowPosChanging(HWND hwnd, WINDOWPOS *pwndpos);
	LRESULT OnSize(HWND hwnd, WORD fwSizeType, int nWidth, int nHeight);
	virtual TXTEFFECT TxGetEffects() const;
	HRESULT	OnTxVisibleChange(BOOL fVisible);
	void	SetDefaultInset();
	BOOL	IsTransparentMode() 
	{
		return (_dwExStyle & WS_EX_TRANSPARENT);
	}

	// Keyboard messages
	virtual LRESULT	OnKeyDown(WORD vKey, DWORD dwFlags);
	virtual LRESULT	OnChar(WORD vKey, DWORD dwFlags);
	
	// System notifications
	virtual void 	OnSysColorChange();
	virtual LRESULT OnGetDlgCode(WPARAM wparam, LPARAM lparam);

	// Other messages
	LRESULT OnGetOptions() const;
	void	OnSetOptions(WORD wOp, DWORD eco);
	void	OnSetReadOnly(BOOL fReadOnly);
	void	OnGetRect(LPRECT prc);
	void	OnSetRect(LPRECT prc, BOOL fNewBehavior, BOOL fRedraw);


public:
	CTxtWinHost();
	virtual ~CTxtWinHost();
	void	Shutdown();

	// Window creation/destruction
	static 	CTxtWinHost *OnNCCreate(
						HWND hwnd, 
						const CREATESTRUCT *pcs,
						BOOL fIsAnsi,
						BOOL fIs10Mode);

	static 	void 	OnNCDestroy(CTxtWinHost *ped);
	virtual LRESULT OnCreate(const CREATESTRUCT *pcs);

	// -----------------------------
	//	IUnknown interface
	// -----------------------------

    virtual HRESULT 		WINAPI QueryInterface(REFIID riid, void **ppvObject);
    virtual ULONG 			WINAPI AddRef(void);
    virtual ULONG 			WINAPI Release(void);

	// -----------------------------
	//	ITextHost interface
	// -----------------------------
	//@cmember Get the DC for the host
	virtual HDC 		TxGetDC();

	//@cmember Release the DC gotten from the host
	virtual INT			TxReleaseDC(HDC hdc);
	
	//@cmember Show the scroll bar
	virtual BOOL 		TxShowScrollBar(INT fnBar, BOOL fShow);

	//@cmember Enable the scroll bar
	virtual BOOL 		TxEnableScrollBar (INT fuSBFlags, INT fuArrowflags);

	//@cmember Set the scroll range
	virtual BOOL 		TxSetScrollRange(
							INT fnBar, 
							LONG nMinPos, 
							INT nMaxPos, 
							BOOL fRedraw);

	//@cmember Set the scroll position
	virtual BOOL 		TxSetScrollPos (INT fnBar, INT nPos, BOOL fRedraw);

	//@cmember InvalidateRect
	virtual void		TxInvalidateRect(LPCRECT prc, BOOL fMode);

	//@cmember Send a WM_PAINT to the window
	virtual void 		TxViewChange(BOOL fUpdate);
	
	//@cmember Create the caret
	virtual BOOL		TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight);

	//@cmember Show the caret
	virtual BOOL		TxShowCaret(BOOL fShow);

	//@cmember Set the caret position
	virtual BOOL		TxSetCaretPos(INT x, INT y);

	//@cmember Create a timer with the specified timeout
	virtual BOOL 		TxSetTimer(UINT idTimer, UINT uTimeout);

	//@cmember Destroy a timer
	virtual void 		TxKillTimer(UINT idTimer);

	//@cmember Scroll the content of the specified window's client area
	virtual void		TxScrollWindowEx (
							INT dx, 
							INT dy, 
							LPCRECT lprcScroll, 
							LPCRECT lprcClip,
							HRGN hrgnUpdate, 
							LPRECT lprcUpdate, 
							UINT fuScroll);
	
	//@cmember Get mouse capture
	virtual void		TxSetCapture(BOOL fCapture);

	//@cmember Set the focus to the text window
	virtual void		TxSetFocus();

	//@cmember Establish a new cursor shape
	virtual void		TxSetCursor(HCURSOR hcur, BOOL fText);

	//@cmember Changes the mouse cursor
	virtual HCURSOR		TxSetCursor2(HCURSOR hcur, BOOL bText) { return ::SetCursor(hcur);}

	//@cmember Notification that text services is freed
	virtual void		TxFreeTextServicesNotification();

	//@cmember Converts screen coordinates of a specified point to the client coordinates 
	virtual BOOL 		TxScreenToClient (LPPOINT lppt);

	//@cmember Converts the client coordinates of a specified point to screen coordinates
	virtual BOOL		TxClientToScreen (LPPOINT lppt);

	//@cmember Request host to activate text services
	virtual HRESULT		TxActivate( LONG * plOldState );

	//@cmember Request host to deactivate text services
   	virtual HRESULT		TxDeactivate( LONG lNewState );

	//@cmember Retrieves the coordinates of a window's client area
	virtual HRESULT		TxGetClientRect(LPRECT prc);

	//@cmember Get the view rectangle relative to the inset
	virtual HRESULT		TxGetViewInset(LPRECT prc);

	//@cmember Get the default character format for the text
	virtual HRESULT 	TxGetCharFormat(const CHARFORMAT **ppCF );

	//@cmember Get the default paragraph format for the text
	virtual HRESULT		TxGetParaFormat(const PARAFORMAT **ppPF);

	//@cmember Get the background color for the window
	virtual COLORREF	TxGetSysColor(int nIndex);

	//@cmember Get the background (either opaque or transparent)
	virtual HRESULT		TxGetBackStyle(TXTBACKSTYLE *pstyle);

	//@cmember Get the maximum length for the text
	virtual HRESULT		TxGetMaxLength(DWORD *plength);

	//@cmember Get the bits representing requested scroll bars for the window
	virtual HRESULT		TxGetScrollBars(DWORD *pdwScrollBar);

	//@cmember Get the character to display for password input
	virtual HRESULT		TxGetPasswordChar(TCHAR *pch);

	//@cmember Get the accelerator character
	virtual HRESULT		TxGetAcceleratorPos(LONG *pcp);

	//@cmember Get the native size
    virtual HRESULT		TxGetExtent(LPSIZEL lpExtent);

	//@cmember Notify host that default character format has changed
	virtual HRESULT 	OnTxCharFormatChange (const CHARFORMAT * pCF);

	//@cmember Notify host that default paragraph format has changed
	virtual HRESULT		OnTxParaFormatChange (const PARAFORMAT * pPF);

	//@cmember Bulk access to bit properties
	virtual HRESULT		TxGetPropertyBits(DWORD dwMask, DWORD *pdwBits);

	//@cmember Notify host of events
	virtual HRESULT		TxNotify(DWORD iNotify, void *pv);

	// FE Support Routines for handling the Input Method Context
	virtual HIMC		TxImmGetContext(void);
	virtual void		TxImmReleaseContext(HIMC himc);

	//@cmember Returns HIMETRIC size of the control bar.
	virtual HRESULT		TxGetSelectionBarWidth (LONG *lSelBarWidth);

    // ITextHost2 methods
	virtual BOOL		TxIsDoubleClickPending();
	virtual HRESULT		TxGetWindow(HWND *phwnd);
	virtual HRESULT		TxSetForegroundWindow();
	virtual HPALETTE	TxGetPalette();
	virtual HRESULT		TxGetFEFlags(LONG *pFlags);
	virtual HRESULT		TxGetEditStyle(DWORD dwItem, DWORD *pdwData);
	virtual HRESULT		TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle);
    virtual HRESULT TxEBookLoadImage( LPWSTR lpszName,	// name of image
									  LPARAM * pID,	    // E-Book supplied image ID
                                      SIZE * psize,    // returned size of image (pixels)
									 DWORD *pdwFlags); // returned flags for Float

    virtual HRESULT		TxEBookImageDraw(LPARAM ID,		      // id of image to draw
										HDC hdc,             // drawing HDC
										POINT *topLeft,      // top left corner of where to draw
										RECT  *prcRenderint, // parm pointer to render rectangle
										BOOL fSelected);	  // TRUE if image is in selected state

	virtual HRESULT		TxGetHorzExtent(LONG *plHorzExtent);

#ifndef NOACCESSIBILITY
	ITypeInfo	*_pTypeInfo;

	virtual HRESULT	InitTypeInfo() {return E_NOTIMPL;}
	
	////////////////////////// IDispatch Methods /////////////////////////////////
	STDMETHOD(GetTypeInfoCount)(UINT __RPC_FAR *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames,
            				 LCID lcid, DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams,
					  VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr);

	////////////////////////// IAccessible Methods /////////////////////////////////
    STDMETHOD(get_accParent)(IDispatch **ppdispParent) {return S_FALSE;}    
    STDMETHOD(get_accChildCount)(long *pcountChildren)	{return S_FALSE;}    
    STDMETHOD(get_accChild)(VARIANT varChild, IDispatch **ppdispChild) {return S_FALSE;}    
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName) {return S_FALSE;}    
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue) {return S_FALSE;}    
    STDMETHOD(get_accDescription)(VARIANT varChild, BSTR *pszDescription) {return S_FALSE;}    
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole) {return S_FALSE;}    
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState) {return S_FALSE;}    
    STDMETHOD(get_accHelp)(VARIANT varChild, BSTR *pszHelp) {return S_FALSE;}    
    STDMETHOD(get_accHelpTopic)(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic) {return S_FALSE;}    
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut) {return S_FALSE;}    
    STDMETHOD(get_accFocus)(VARIANT *pvarChild) {return S_FALSE;}
    STDMETHOD(get_accSelection)(VARIANT *pvarChildren) {return S_FALSE;}
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction) {return S_FALSE;}    
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild) {return S_FALSE;}    
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild) 
    								{return S_FALSE;}
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt) {return S_FALSE;}    
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChild) {return S_FALSE;}    
    STDMETHOD(accDoDefaultAction)(VARIANT varChild) {return S_FALSE;}    
    STDMETHOD(put_accName)(VARIANT varChild, BSTR szName) {return S_FALSE;}    
    STDMETHOD(put_accValue)(VARIANT varChild, BSTR szValue) {return S_FALSE;}
#endif // NOACCESSIBILITY

};

#ifndef NOWINDOWHOSTS
// Work around some client's (MSN chat) problems with host deletions.
void DeleteDanglingHosts();
#endif

#define LBS_COMBOBOX    0x8000L
#define LBCB_TRACKING	WM_USER+2
#define LBCBM_PREPARE	1
#define LBCBM_START		2
#define LBCBM_END		3

// mask for LBCBM messages
#define LBCBM_PREPARE_SETFOCUS 1
#define LBCBM_PREPARE_SAVECURSOR 2


class CLbData
{
public:
	unsigned _fSelected	:1;		// indicates if the item has been selected
	UINT	_uHeight;			// Item height for owner-drawn with varibale height
	LPARAM	_lparamData;		// Item data
};

struct CHARSORTINFO
{
	WCHAR*	str;
	int		sz;
};

#define CHECKNOERROR(x) if (NOERROR != x) goto CleanExit

class CCmbBxWinHost;
class CLstBxWinHost : public CTxtWinHost, public ITxNotify
{
public:
	typedef enum {					
		//kNoSel = 0,					//LBS_NOSEL
		kSingle = 1,					//LBS_SIMPLE
		kMultiple = 2,					//LBS_MULTIPLESEL
		kExtended = 3,					//LBS_EXTENDEDSEL
		kCombo = 8						//Combo box
	} Listtype;

#ifndef NOACCESSIBILITY
public:
	// -----------------------------
	//	IUnknown interface
	// -----------------------------

    virtual HRESULT 		WINAPI QueryInterface(REFIID riid, void **ppvObject);
#endif
	
private:
	short _cWheelDelta;					//contains the delta values for mouse wheels
	int _nTopIdx;						//the item index at the top of list
										//Do not touch this unless you know what you are doing!!
	LONG	_cpLastGetRange;			//Cached cp value for last GetRange call
	int		_nIdxLastGetRange;			//Cached index for last GetRange call.
public:
	DWORD	_fOwnerDraw			:1;		//indicates if list box is owner draw
	DWORD	_fOwnerDrawVar		:1;		//indicates if list box is owner draw with variable height
	DWORD	_fSort				:1;		//determines if the list should be sorted
	DWORD	_fNoIntegralHeight	:1;		//indicates if the size of the listbox should be readjusted according
										//how many items can be fully displayed
	DWORD	_fDisableScroll		:1;		//indicates if scroll bar should be displayed at all times
	DWORD	_fNotify			:1;		//notifies parent dialog of activities done in list box.
	DWORD	_fSingleSel			:1;		// Indicates the list box is a single selection item
	DWORD	_fMouseDown 		:1;		// Indicates if the mouse is down
	DWORD	_fFocus		 		:1;		// determines if the control has focus
	DWORD	_fCapture			:1;		// determines if mouse capture is set
	DWORD	_fSearching  		:1;		// indicates if we are in type searching mode
	DWORD	_fDblClick			:1;		// flag indicating double click was received
	DWORD	_fNoResize			:1;		// internal flag to tell us if we should ignore resize messages
	DWORD	_fNotifyWinEvt		:1;		// Indicates only Notify Win Event (ACCESSIBILITY use)
	DWORD	_fHorzScroll		:1;		// enable Horz scrolling
	DWORD	_fWantKBInput		:1;		// indicates owner wants keyboard input
	DWORD	_fHasStrings		:1;		// indicates LB has string
	DWORD	_fSetRedraw			:1;		// indicates if we should handle WM_PAINT
	DWORD	_fSetScroll			:1;		// indicates if we should set scroll info after unfreeze
	DWORD	_fShutDown			:1;		// indicates listbox is shutting down
	DWORD	_fIntegralHeightOld	:1;		// previous value for _fNoIntegralHeight

	Listtype _fLstType;					//indicates current type of list box or combo box

#ifndef NOACCESSIBILITY
	DWORD	_dwWinEvent;				// Win Event code (ACCESSIBILITY use)
	int		_nAccessibleIdx;			// Index (ACCESSIBILITY use)
#endif

	LONG	GetHorzExtent() { return _lHorzExtent;}
	void	SetHorzExtent(LONG lHorzExtent) { _lHorzExtent = lHorzExtent;}
	CDynamicArray<CLbData> _rgData;		// Array/link list of the item data

protected:

	UINT		_idCtrl;				// control's unique id
	COLORREF _crSelFore;				//Selected Forground color
	COLORREF _crSelBack;				//Selected Background color
	COLORREF _crDefFore;				//Default Forground color
	COLORREF _crDefBack;				//Default Background color

	RECT	_rcViewport;				//drawable area for the items
	long _nyFont;						// Font pixel size in y direction
	long _nyItem;						//Height of the items in the list box
	
	int _nViewSize;						//number of items which is viewable at the same time

	int _nCount;						//Number of items in the list box
	int _nAnchor;						//Indicates the top selected item
										//NOTE:
										//  In a single sel list box only _nCursor is used
	int _nCursor;						//Indicates the current item which has the focus

	int _nOldCursor;					//The old cursor position for combo boxes

	int _stvidx;						// This is for a hack to workaround a bug when the display
										// is frozen ITextRange doesn't cache to scroll change

	int _nidxSearch;					// Number of characters in search string
	WCHAR*	_pwszSearch;				// pointer to allocated string
	LPARAM	_nPrevMousePos;				// Last position from Mousemove message
	CCmbBxWinHost*	_pcbHost;			// pointer to combo box win host
	long _lHorzExtent;					// Horizontal extent in pixel for Horz scrolling

protected:
	// Changes the background color
	BOOL SetColors(DWORD, DWORD, long, long);

	// Makes sure the top item is displayed at the top of the view
	BOOL ScrollToView(long nTop);

	// Sets the requested item to be at the top of the viewable space
	BOOL SetTopViewableItem(long);

	// Searches if a given index qualifies as a match
	BOOL FindString(long idx, LPCTSTR szSearch, BOOL bExact);

	// helper function for the OnMouseMove function
	void MouseMoveHelper(int, BOOL);

	// Set the height of each item in the list box in the given range
	int SetItemsHeight(int,BOOL);

	// Sum the height from iStart to iEnd for variable item height listbox
	int SumVarHeight(int iStart, int iEnd, BOOL *pfGreaterThanView = NULL);

	// Page up/down helper for Variable height LB
	int PageVarHeight(int startItem, BOOL fPageForwardDirection);

	// Setup height for Variable height LB
	BOOL SetVarItemHeight(int idx, int iHeight);

	// Find the idx for the given iHeight from idx 0
	int GetIdxFromHeight(int iHeight);

public:
	CLstBxWinHost();
	virtual ~CLstBxWinHost();

	void ResizeInset();
	// initialization function
	virtual BOOL Init(HWND,	const CREATESTRUCT *);

	// Window creation/destruction
	static 	LRESULT OnNCCreate(HWND hwnd, const CREATESTRUCT *pcs);
	static 	void OnNCDestroy(CLstBxWinHost *ped);
	virtual LRESULT OnCreate(const CREATESTRUCT *pcs);

	////////////////////////// helper functions ////////////////////////////////////
	static wchar_t * wcscat(wchar_t * dst, const wchar_t * src)
	{
        wchar_t * cp = dst;
		while(*cp) cp++;		 // find null character in first string
        while( *cp++ = *src++ ); // Copy src over dst 
        return( dst );
	}

	// given a source string the destination string contains a sorted version
	// separated by <CR>
	int SortInsertList(WCHAR* pszDst, WCHAR* pszSrc);

	// Sets the indents for the listbox
	BOOL SetListIndent(int fLeftIndent);

	// Equivalent to CompareString except int is a reference to an item index
	int CompareIndex(LPCTSTR szInsert, int nIndex);
	
	// Returns the position a string should be in a sorted list
	int GetSortedPosition(LPCTSTR, int, int);

	// Updates the system color settings
	void UpdateSysColors();
	
	// Inits search string
	void InitSearch();
	
	// Prevents the window from updating itself
	long Freeze();

	// Frees the window to update itself
	long Unfreeze();

	// Retrieves the range give the top and bottom index
	BOOL GetRange(long, long, ITextRange**);	

	// Inserts the string at the requested index
	BOOL InsertString(long, LPCTSTR);

	// Removes the string from the listbox
	BOOL RemoveString(long, long);

	// Retrieves the string at the requested index
	long GetString(long, PWCHAR);

	// Deselects all the items in the list box
	BOOL ResetContent();

	// Retrieves the nearest valid item from a given point
	int GetItemFromPoint(const POINT *);

	// Tells if a given points is within the listbox's rect
	BOOL PointInRect(const POINT *);

	// Sets the cursor position and draws the rect
	void SetCursor(HDC, int, BOOL);

	// Recalulates the height so no partial text will be displayed
	BOOL RecalcHeight(int, int);

	// Reset Listbox items color
	void ResetItemColor();

	// returns of listbox is single selection
	inline BOOL IsSingleSelection() const {return _fSingleSel;}
	
	// Returns the current top index
	inline long GetTopIndex() const { return _nTopIdx;}
	
	// Checks if the mouse has been captured
	inline BOOL GetCapture() const { return _fCapture;}

	// return the item count
	inline int GetCount() const	{return _nCount;}

	// returns the anchor position
	inline int GetAnchor() const {return _nAnchor;}

	// returns the cursor position
	inline int GetCursor() const {return _nCursor;}

	// returns the viewsize
	inline int GetViewSize() const {return _nViewSize;}

	// returns the font height
	inline int GetFontHeight() const {return _nyFont;}

	// returns the item height
	inline int GetItemHeight() const {return _nyItem;}

	// returns the displays freeze count
	inline short FreezeCount() const;

	// initialize mouse wheel variable to zero
	inline void InitWheelDelta() { _cWheelDelta = 0;}

	BOOL IsItemViewable(long idx);

	// Determines if index is selected
	inline BOOL IsSelected(long nIdx)
	{
#ifdef _DEBUG
		Assert(nIdx < -1 || _nCount <= nIdx);
		if (nIdx < -1 || _nCount <= nIdx) return FALSE;
#endif
		if (nIdx < 0)
			return FALSE;
		else
			return _rgData[nIdx]._fSelected;
	}

	// Returns the ItemData of a given index
	inline LPARAM GetData(long nIdx)
	{		
		return _rgData.Get(nIdx)._lparamData;
	}

	// Check if we need to do custom look for ListBox
	LRESULT OnSetEditStyle(WPARAM, LPARAM);

	//Custom look
	BOOL IsCustomLook();

	/////////////////////ListBox Message Handling functions /////////////////////////
	// Set the height of the items in the list box
	BOOL LbSetItemHeight(WPARAM, LPARAM);
	
	// Set the selection state for the items in the range
	BOOL LbSetSelection(long, long, int, long, long);

	// Sets the requested item to be at the top of the list box
	long LbSetTopIndex(long);

	// Makes sure the requested index is visible
	BOOL LbShowIndex(long, BOOL);

	// Retrieves the index give a string and starting position
	long LbFindString(long, LPCTSTR, BOOL);	

	// Inserts the string at the requested location
	long LbInsertString(long, LPCTSTR);

	// Range to delete
	long LbDeleteString(long, long);

	// Sets the Item data
	void LbSetItemData(long, long, LPARAM);

	// returns the item rect of a given index
	BOOL LbGetItemRect(int, RECT*);

	// Notifies parent when an item is deleted
	void LbDeleteItemNotify(int, int);
	
	// Owner draw function
	void LbDrawItemNotify(HDC, int, UINT, UINT);

	// used to insert a list of strings rather than individually
	int LbBatchInsert(WCHAR* psz);

	BOOL LbEnableDraw()
	{
		return _fSetRedraw;
	};

	// Handles LB_GETCURSEL
	LRESULT LbGetCurSel();

	///////////////////////// Message Map functions //////////////////////////////
	// if subclassed then make these functions virtual

	// Handles the WM_MOUSEMOVE message
	LRESULT OnMouseWheel(WPARAM, LPARAM);
	
	// Handles the WM_LBUTTONDOWN message
	LRESULT OnLButtonDown(WPARAM wparam, LPARAM lparam);

	// Handles the WM_MOUSEMOVE message
	LRESULT OnMouseMove(WPARAM, LPARAM);

	// Handles the WM_LBUTTONUP message
	LRESULT OnLButtonUp(WPARAM, LPARAM, int ff = 0);

	// Handles the WM_VSCROLL message
	LRESULT OnVScroll(WPARAM, LPARAM);

	// Handles the WM_TIMER message
	LRESULT OnTimer(WPARAM, LPARAM);

	// Handles the WM_KEYDOWN message
	LRESULT OnKeyDown(WPARAM, LPARAM, int);
	
	// Hanldes the WM_CAPTURECHANGED message
	LRESULT OnCaptureChanged(WPARAM, LPARAM);

	// Handles the WM_CHAR message
	virtual LRESULT	OnChar(WORD, DWORD);

	// Handles the WM_SYSCOLORCHANGE message
	virtual void OnSysColorChange();

	// Handles the WM_SETTINGCHANGE message
	void OnSettingChange(WPARAM, LPARAM);

	// Handles the WM_SETCURSOR message
	LRESULT OnSetCursor();

	// Handles the WM_SETREDRAW message
	LRESULT OnSetRedraw(WPARAM);

	// Handles the WM_HSCROLL message
	LRESULT OnHScroll(WPARAM, LPARAM);

	//////////////////////////// overridden Tx fn's ////////////////////////////////
	//@cmember Get the bits representing requested scroll bars for the window
	virtual HRESULT	TxGetScrollBars(DWORD *pdwScrollBar);
	
	//@cmember Bulk access to bit properties
	virtual HRESULT	TxGetPropertyBits(DWORD, DWORD *);

	virtual TXTEFFECT TxGetEffects() const;

	//@cmember Notify host of events
	virtual HRESULT	TxNotify(DWORD iNotify, void *pv);

	//@cmember Show the scroll bar
	virtual BOOL TxShowScrollBar(INT fnBar, BOOL fShow);

	//@cmember Enable the scroll bar
	virtual BOOL TxEnableScrollBar (INT fuSBFlags, INT fuArrowflags);

	//@cmember Show the caret
	virtual BOOL TxShowCaret(BOOL fShow) {return TRUE;}

	//@cmember Create the caret
	virtual BOOL TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight) {return FALSE;}

	//@cmember Set the scroll range
	virtual void SetScrollInfo(INT, BOOL);

	//@cmember Get the horizontal extent
	virtual HRESULT	TxGetHorzExtent(LONG *plHorzExtent);

	/////////////////////////// Combobox helper fn's ///////////////////////////////
	void OnCBTracking(WPARAM, LPARAM);

	static int QSort(CHARSORTINFO rg[], int nStart, int nEnd);


#ifndef NOACCESSIBILITY
	HRESULT	InitTypeInfo();

	////////////////////////// IAccessible Methods /////////////////////////////////
    STDMETHOD(get_accParent)(IDispatch **ppdispParent); 
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);
    STDMETHOD(get_accChildCount)(long *pcountChildren);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);    
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);   
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);    
    STDMETHOD(get_accFocus)(VARIANT *pvarChild);    
    STDMETHOD(get_accSelection)(VARIANT *pvarChildren);    
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);    
   	STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);    
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);    
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);    
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChild);    
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
#endif // NOACCESSIBILITY

    // ITxNotify methods
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
    					LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData ) { ; }
	virtual void 	OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
						LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
	virtual void	Zombie() { ; };
};

#ifndef NOACCESSIBILITY
// --------------------------------------------------------------------------
//
//  Although CListBoxSelection() is based off of IEnumVARIANT.  
//	It will hand back the proper IDs so you can pass them to the real 
//	listbox parent object.
//
// --------------------------------------------------------------------------
class CListBoxSelection : public IEnumVARIANT
{
    public:
        // IUnknown
        virtual STDMETHODIMP            QueryInterface(REFIID, void**);
        virtual STDMETHODIMP_(ULONG)    AddRef(void);
        virtual STDMETHODIMP_(ULONG)    Release(void);

        // IEnumVARIANT
        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum);

        CListBoxSelection(int, int, LPINT, BOOL);
        ~CListBoxSelection();

    protected:
        int     _cRef;
        int     _idChildCur;
        int     _cSel;
        LPINT   _piSel;
};
#endif

#ifndef DEBUG
#define AttCheckRunTotals(_fCF)
#define AttCheckPFRuns(_fCF)
#endif

#define ECO_STYLES (ECO_AUTOVSCROLL | ECO_AUTOHSCROLL | ECO_NOHIDESEL | \
						ECO_READONLY | ECO_WANTRETURN | ECO_SAVESEL | \
						ECO_SELECTIONBAR | ES_NOIME | ES_SELFIME | ES_VERTICAL)

#endif // NOWINDOWHOSTS

#endif // _HOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_ime.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _ime.h -- support for IME APIs |
 *	
 *	Purpose:
 *		Most everything to do with FE composition string editing passes
 *		through here.
 *	
 *	Authors: <nl>
 *		Jon Matousek  <nl>
 *		Justin Voskuhl  <nl>
 *		Hon Wah Chan  <nl>
 * 
 *	History: <nl>
 *		10/18/1995		jonmat	Cleaned up level 2 code and converted it into
 *								a class hierarchy supporting level 3.
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 *
 */								 

#ifndef _IME_H
#define _IME_H


class CTextMsgFilter;

// defines for IME Level 2 and 3
#define	IME_LEVEL_2		2
#define IME_LEVEL_3		3
#define IME_PROTECTED	4

/*
 *	IME
 *
 *	@class	base class for IME support.
 *
 *	@devnote
 *		For level 2, at caret IMEs, the IME will draw a window directly over the text giving the
 *		impression that the text is being processed by the application--this is called pseudo inline.
 *		All UI is handled by the IME. This mode is currenlty bypassed in favor of level 3 true inline (TI);
 *		however, it would be trivial to allow a user preference to select this mode. Some IMEs may have
 *		a "special" UI, in which case level 3 TI is *NOT* used, necessitating level 2.
 *
 *		For level 2, near caret IMEs, the IME will draw a very small and obvious window near the current
 *		caret position in the document. This currently occurs for PRC(?) and Taiwan.
 *		All UI is handled by the IME.
 *
 *		For level 3, at caret IMEs, the composition string is drawn by the application, which is called
 *		true inline, bypassing the level 2 "composition window".
 *		Currently, we allow the IME to support all remaining UI *except* drawing of the composition string.
 */
class CIme
{
	friend LRESULT OnGetIMECompositionMode ( CTextMsgFilter &TextMsgFilter );
	friend HRESULT CompositionStringGlue ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
	friend HRESULT EndCompositionGlue ( CTextMsgFilter &TextMsgFilter, BOOL fForceDelete);
	friend void CheckDestroyIME ( CTextMsgFilter &TextMsgFilter );


	//@access	Protected data
	protected:
	short	_imeLevel;								//@cmember IME Level 2 or 3
	short	_cIgnoreIMECharMsg;						//@cmember Level 2 IME use to eat WM_IME_CHAR message
	short	_fIgnoreEndComposition;					//@cmember ignore the next End Composition message
	short	_fIMETerminated;						//@cmember indicate this IME has been terminated
	short	_fSkipFirstOvertype;					//@cmember skip first overtype if selection is 
													//	deleted on StartComposition
	short	_fGotFinalString;						//@cmember indicate if we have received final string


	//@access	Public methods
	public:
	
	virtual ~CIme() {};

	INT		_compMessageRefCount;					//@cmember so as not to delete if recursed.
	short	_fDestroy;								//@cmember set when object wishes to be deleted.
													//@cmember	Handle WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter ) = 0;
													//@cmember	Handle WM_IME_COMPOSITION and WM_IME_ENDCOMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter ) = 0;
													//@cmember	Handle post WM_IME_CHAR	to update comp window.
	virtual void PostIMEChar( CTextMsgFilter &TextMsgFilter ) = 0;

													//@cmember	Handle WM_IME_NOTIFY
	virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fCCompWindow ) = 0;

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg, WPARAM wParam, BOOL &fTerminateIME ) = 0;

	virtual LRESULT GetIMECompositionMode ( CTextMsgFilter &TextMsgFilter ) = 0;

	enum TerminateMode
	{ 
			TERMINATE_NORMAL = 1,
			TERMINATE_FORCECANCEL = 2
	};

	void	TerminateIMEComposition(CTextMsgFilter &TextMsgFilter,
				CIme::TerminateMode mode);			//@cmember	Terminate current IME composition session.
	
													//@cmember	check if we need to ignore WM_IME_CHAR messages
	BOOL	IgnoreIMECharMsg() { return _cIgnoreIMECharMsg > 0; }
													//@cmember	skip WM_IME_CHAR message
	void	SkipIMECharMsg() { _cIgnoreIMECharMsg--; }
													//@cmember	accept WM_IME_CHAR message
	void	AcceptIMECharMsg() { _cIgnoreIMECharMsg = 0; }

	static	void	CheckKeyboardFontMatching ( long cp, CTextMsgFilter *pTextMsgFilter, ITextFont *pTextFont );	//@cmember	Check current font/keyboard matching.	

	BOOL	IsTerminated ()							//@cmember	Return _fIMETerminated
	{
		return _fIMETerminated; 
	}

	INT		GetIMELevel () 							//@cmember	Return the current IME level.
	{
		return _imeLevel;
	}

	static HRESULT CheckInsertResultString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter, 
		short *pcch = NULL, int *pcbSize = 0, WCHAR *pOutputBuff = NULL );

	//@access	Protected methods



	protected:										//@cmember	Get composition string, convert to unicode.
	
	static INT GetCompositionStringInfo( HIMC hIMC, DWORD dwIndex, WCHAR *uniCompStr, INT cchUniCompStr, BYTE *attrib, INT cbAttrib, LONG *cursorCP, LONG *cchAttrib, UINT kbCodePage, BOOL bUnicodeIME, BOOL bUsingAimm );

	void	SetCompositionFont ( CTextMsgFilter &TextMsgFilter, ITextFont *pTextFont );	//@cmember	Setup for level 2 and 3 composition and candidate window's font.
	void	SetCompositionForm ( CTextMsgFilter &TextMsgFilter );	//@cmember	Setup for level 2 IME composition window's position.
};

/*
 *	IME_Lev2
 *
 *	@class	Level 2 IME support.
 *
 */
class CIme_Lev2 : public CIme 
{

	//@access	Public methods
	public:											//@cmember	Handle level 2 WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 2 WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle post WM_IME_CHAR	to update comp window.
	virtual void PostIMEChar( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 2 WM_IME_NOTIFY
	virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fIgnore );
													//@cmember  Handle IME notify message
	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg, WPARAM wParam, BOOL &fTerminateIME );
													//@cmember  Handle IME mouse Operation
	virtual LRESULT GetIMECompositionMode ( CTextMsgFilter &TextMsgFilter );
													//@cmember  Return current composition mode
	CIme_Lev2( CTextMsgFilter &TextMsgFilter );
	virtual ~CIme_Lev2();

	ITextFont	*_pTextFont;						//@cmember  base format	

};

/*
 *	IME_PROTECTED
 *
 *	@class	IME_PROTECTED
 *
 */
class CIme_Protected : public CIme 
{
	//@access	Public methods
	public:											//@cmember	Handle level 2 WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter )
		{_imeLevel	= IME_PROTECTED; return S_OK;}
													//@cmember	Handle level 2 WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle post WM_IME_CHAR	to update comp window.
	virtual void PostIMEChar( CTextMsgFilter &TextMsgFilter )
		{}
													//@cmember	Handle level 2 WM_IME_NOTIFY
	virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fIgnore )
		{return S_FALSE;}
	
	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg, WPARAM wParam, BOOL &fTerminateIME )
		{fTerminateIME = TRUE; return FALSE;}
	virtual LRESULT GetIMECompositionMode ( CTextMsgFilter &TextMsgFilter )
		{ return ICM_NOTOPEN;}

};

/*
 *	IME_Lev3
 *
 *	@class	Level 3 IME support.
 *
 */
class CIme_Lev3 : public CIme_Lev2 
{
	//@access	Private data
	private:										

	//@access	Protected data
	protected:
	long	_ichStart;								//@cmember	maintain starting ich.
	long	_cchCompStr;							//@cmember	maintain composition string's cch.

	short	_sIMESuportMouse;						//@cmember IME mouse support
	WPARAM	_wParamBefore;							//@cmember Previous wParam sent to IME
	HWND	_hwndIME;								//@cmember current IME hWnd

	long	_crTextColor;							//@cmember current font text color
	long	_crBkColor;								//@cmember current font background color

	// Helper function
													//@cmember get imeshare color for the attribute
	COLORREF GetIMEShareColor(CIMEShare *pIMEShare, DWORD dwAttribute, DWORD dwProperty);	

	//@access	Public methods
	public:											//@cmember	Handle level 3 WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 3 WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 3 WM_IME_NOTIFY
	virtual HRESULT	IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fCCompWindow );

	void			SetCompositionStyle ( CTextMsgFilter &TextMsgFilter, UINT attribute, ITextFont *pTextFont );

	CIme_Lev3( CTextMsgFilter &TextMsgFilter );
	virtual ~CIme_Lev3() {};

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg, WPARAM wParam, BOOL &fTerminateIME );
	virtual BOOL	IMESupportMouse ( CTextMsgFilter &TextMsgFilter );
	virtual LRESULT GetIMECompositionMode ( CTextMsgFilter &TextMsgFilter );

	public:

	short		_fUpdateWindow;						//@cmember Update Window after closing CandidateWindow
	short		_fHandlingFinalString;				//@cmember In the middle of handling final result string

	long GetIMECompositionStart()
	{ return _ichStart; }

	long GetIMECompositionLen()
	{ return _cchCompStr; }

};

/*
 *	Special IME_Lev3 for Korean Hangeul -> Hanja conversion
 *
 *	@class	Hangual IME support.
 *
 */
class CIme_HangeulToHanja : public CIme_Lev3 
{
	//@access	Private data
	private:

	public:		
	CIme_HangeulToHanja( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle Hangeul WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle Hangeul WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg, WPARAM wParam, BOOL &fTerminateIME )
		{fTerminateIME = TRUE; return FALSE;}
};

// Glue functions to call the respective methods of an IME object stored in the ed.
HRESULT StartCompositionGlue ( CTextMsgFilter &TextMsgFilter  );
HRESULT CompositionStringGlue ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
HRESULT EndCompositionGlue ( CTextMsgFilter &TextMsgFilter, BOOL fForceDelete);
void	PostIMECharGlue ( CTextMsgFilter &TextMsgFilter );
HRESULT IMENotifyGlue ( const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter ); // @parm the containing text edit.
HRESULT	IMEMouseCheck(CTextMsgFilter &TextMsgFilter, UINT *pmsg, WPARAM *pwparam, LPARAM *plparam, LRESULT *plres);

// IME helper functions.
void	IMECompositionFull ( CTextMsgFilter &TextMsgFilter );
LRESULT	OnGetIMECompositionMode ( CTextMsgFilter &TextMsgFilter ); 
BOOL	IMECheckGetInvertRange(CTextMsgFilter *ed, LONG &, LONG &);
void	CheckDestroyIME ( CTextMsgFilter &TextMsgFilter );
BOOL	IMEHangeulToHanja ( CTextMsgFilter &TextMsgFilter );
BOOL	IMEMessage ( CTextMsgFilter &TextMsgFilter, UINT uMsg, 
					WPARAM wParam, LPARAM lParam, BOOL bPostMessage );
HIMC	LocalGetImmContext ( CTextMsgFilter &TextMsgFilter );
void	LocalReleaseImmContext ( CTextMsgFilter &TextMsgFilter, HIMC hIMC );

long	IMEShareToTomUL ( UINT ulID );

#define TEST_LEFT		0x0001
#define TEST_RIGHT		0x0002
#define TEST_TOP		0x0004
#define TEST_BOTTOM		0x0008
#define TEST_ALL		(TEST_LEFT | TEST_RIGHT | TEST_TOP | TEST_BOTTOM)
LONG	TestPoint ( POINT &pt1, POINT &pt2, POINT &ptTest, LONG lTestOption, LONG lTextFlow );
#endif // define _IME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_ls.h ===
/*
 *  _LS.H
 *  
 *  Purpose:
 *		Line Services wrapper object class used to connect RichEdit with
 *		Line Services.
 *  
 *  Author:
 *		Murray Sargent
 *
 *	Copyright (c) 1997-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _LS_H
#define _LS_H

extern "C" {
#define ols COls
#define lsrun CLsrun
#define lscontext CLineServices
#include "lscbk.h"
#include "lsdnfin.h"
#include "lsdnset.h"
#include "lstxtcfg.h"
#include "lsimeth.h"
#include "plsline.h"
#include "lslinfo.h"
#include "lschp.h"
#include "lspap.h"
#include "plspap.h"
#include "lstxm.h"
#include "lsdevres.h"
#include "lscontxt.h"
#include "lscrline.h"
#include "lsqline.h"
#include "lssetdoc.h"
#include "lsdsply.h"
#include "heights.h"
#include "lsstinfo.H"
#include "lsulinfo.H"
#include "plsstinf.h"
#include "plsulinf.h"
#include "plstabs.h"
#include "lstabs.h"
#include "robj.h"
#include "ruby.h"
#include "tatenak.h"
#include "warichu.h"
#include "lsffi.h"
#include "lstfset.h"
#include "lsqsinfo.h"
#include "lscell.h"
#include "lshyph.h"
#include "lskysr.h"
}

struct CLineServices
{
public:

LSERR WINAPI CreateLine(LSCP cp, long duaWidth,
						BREAKREC *pBreakRecIn,  DWORD cBreakRecIn, DWORD cMaxOut,
						BREAKREC *pBreakRecOut, DWORD *pcBreakRecOut,
						LSLINFO* plsinfo, PLSLINE* pplsline)
				{return LsCreateLine(this, cp, duaWidth,
							pBreakRecIn,  cBreakRecIn, cMaxOut,
							pBreakRecOut, pcBreakRecOut,
							plsinfo, pplsline);}


LSERR WINAPI SetBreaking(DWORD cLsBrk, const LSBRK* rgLsBrk,
					DWORD cKinsokuCat, const BYTE *prgbrkpairsKinsoku)

				{return LsSetBreaking(this, cLsBrk, rgLsBrk,
								cKinsokuCat, prgbrkpairsKinsoku);}

LSERR WINAPI SetDoc(BOOL fDisplay, BOOL fEqualRes, const LSDEVRES* plsdevres)
				{return LsSetDoc(this, fDisplay, fEqualRes, plsdevres);}

LSERR WINAPI DestroyLine(PLSLINE plsline)
				{return LsDestroyLine(this, plsline);}

LSERR WINAPI dnFinishRegular(LSDCP cp, PLSRUN plsrun, PCLSCHP pclschp, PDOBJ pdobj, PCOBJDIM pcobjdim)
				{return LsdnFinishRegular(this, cp, plsrun, pclschp, pdobj, pcobjdim);}

LSERR WINAPI dnQueryObjDimRange(PLSDNODE plsdnode1, PLSDNODE plsdnode2, POBJDIM pobjdim)
				{return LsdnQueryObjDimRange(this, plsdnode1, plsdnode2, pobjdim);}
 
LSERR WINAPI dnSetRigidDup(PLSDNODE plsdnode, LONG dup)
				{return LsdnSetRigidDup(this, plsdnode, dup);}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_kern.h ===
/*	_KERN.H
 *	
 *	Purpose:
 *		Latin pair-kerning cache.
 *	
 *	Authors:
 *		Keith Curtis
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_array.h"

struct KPE
{
	WCHAR chFirst;
	WCHAR chSecond;

	short du;
};

typedef unsigned int KERNHASHKEY;

enum KernCacheInitState
{
	Unitialized,	//Don't know if there are kerning pairs
	Initialized,	//There are kerning pairs
	NoKerningPairs	//No kerning pairs found
};

class CKernCache
{
public:
	CKernCache::CKernCache()
	{
		_kcis = Unitialized;
	}
	BOOL FInit(HFONT hfont);

	void Free(void)
	{
		_pmpkpe.Clear(AF_DELETEMEM);
	}

	void Add(WCHAR chFirst, WCHAR chSecond, LONG du);
	LONG FetchDup(WCHAR chFirst, WCHAR chSecond, long dvpFont);

private:
	void Init(HFONT hfont);
	inline int Hash(KERNHASHKEY kernhashkey)
	{
		return kernhashkey % _pmpkpe.Count();
	}
	static inline KERNHASHKEY MakeHashKey(WCHAR chFirst, WCHAR chSecond)
	{
		return chFirst | (chSecond << 16);
	}

	CArray<KPE> _pmpkpe;
	KernCacheInitState _kcis;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_magelln.h ===
/*
 *	@doc
 *
 *	@module _MAGELLN.H -- Declaration of class to handle Magellan mouse. |
 *	
 *	Authors: <nl>
 *		Jon Matousek 
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */

#if !defined(_MAGELLN_H) && !defined(NOMAGELLAN)	// Win NT/95 only class.
#define _MAGELLN_H

#include "_edit.h"


// All of the knobs for magellan mouse scrolling.

const LONG	DEAD_ZONE_TWIPS			= 60;	// 3 pixels normally
const DWORD FAST_ROLL_SCROLL_TRANSITION_TICKS = 900;  // in mili seconds.
const INT FASTER_ROLL1_COUNT		= 5;
const INT FASTER_ROLL2_COUNT		= 10;

const WORD SMOOTH_ROLL_CLINES		= 2;	// multiples of rolls for roll1, roll2.
const int SMOOTH_ROLL_NUM			= 1;
const int SMOOTH_ROLL_DENOM			= 3;

class CMagellan {

	friend class CMagellanBMPStateWrap;

private:
	VOID CheckInstallMagellanTrackTimer (CTxtEdit &ed);
	VOID CheckRemoveMagellanUpdaterTimer (CTxtEdit &ed);
	BOOL InvertMagellanDownBMP ( CDisplay *pdp, BOOL fTurnOn, HDC repaintDC );

	WORD		_fMagellanBitMapOn	:1;	// TRUE if the MDOWN bitmap is displayed.
	WORD		_fMButtonScroll		:1;	// Auto scrolling initiated via magellan-mouse.
	WORD		_fLastScrollWasRoll	:1;	// scroll will be wither roll or mdown.

 	SHORT		_ID_currMDownBMP;		// Resource ID of _MagellanMDownBMP.
	HBITMAP		_MagellanMDownBMP;		// Loaded BMP
	POINTUV		_ptStart;				// Magellan mouse's start scroll pt.

public:

	BOOL MagellanStartMButtonScroll(CTxtEdit &ed, POINT ptxy);
	VOID MagellanEndMButtonScroll( CTxtEdit &ed );
	VOID MagellanRollScroll(CDisplay *pdp, int direction, WORD cLines, int speedNum, int speedDenom, BOOL fAdditive );
	VOID TrackUpdateMagellanMButtonDown ( CTxtEdit &ed, POINT mousePt);

	BOOL IsAutoScrolling() {return _fMButtonScroll;}
	BOOL ContinueMButtonScroll(CTxtEdit *ped, INT x, INT y);

	~CMagellan() { Assert( !_MagellanMDownBMP && !_fMButtonScroll /* client state problems? */); }

};

class CMagellanBMPStateWrap {
private:
	BOOL _fMagellanState;
	HDC _repaintDC;
	CTxtEdit &_ed;
public:
	CMagellanBMPStateWrap(CTxtEdit &ed, HDC repaintDC);
	~CMagellanBMPStateWrap();
};

#endif // _MAGELLN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_ldte.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _LDTE.H - Lighweight Data Transfer Engine |
 *
 *		Declaration for CLightDTEngine class
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef __LDTE_H__
#define __LDTE_H__

#include "_m_undo.h"
#include "_dragdrp.h"

class CTxtRange;
class CTxtEdit;

/*
 *	DataObjectInfo
 *
 *	Purpose:
 *		enumeration of bit flags used to indicate what operations
 *		are possible from a given data object.
 */

typedef enum tagDataObjectInfo
{
	DOI_NONE			= 0,
	DOI_CANUSETOM		= 1,	// TOM<-->TOM optimized data transfers
	DOI_CANPASTEPLAIN	= 2,	// plain text pasting available
	DOI_CANPASTERICH	= 4, 	// rich text pasting available 
	DOI_CANPASTEOLE		= 8,	// object may be pasted as an OLE embedding
								// (note that this flag may be combined with
								// others). 
} DataObjectInfo;

class CLightDTEngine;

typedef struct _READHGLOBAL
{								// Used by RtfHGlobalToRange()
	LPSTR	ptext;				// ANSI string remaining to be read
	LONG	cbLeft;				// Bytes remaining (might exceed string len)
} READHGLOBAL;

typedef struct _WRITEHGLOBAL
{								// Used by RtfHGlobalToRange()
	HGLOBAL	hglobal;
	LONG	cch;				// Count of ASCII chars written (a cb)
	LONG	cb;					// Count of bytes in hglobal
} WRITEHGLOBAL;

// the following macro (should be an in-line function...) defines
// the formula by which in-memory buffers will grow. It is exponential
// (sort of "if we needed this much memory, chances are we'll need at
// least as much more) but the actual growth factor should be played with
// to achieve better performance across most common scenarios
#define GROW_BUFFER(cbCurrentSize, cbRequestedGrowth)  (ULONG)max(2*(cbCurrentSize), (cbCurrentSize) + 2*(cbRequestedGrowth))

//DWORD packed flags for PasteDataObjectToRange.  Make sure new values
//are assigned such that flags can be or'd together.
#define PDOR_NONE		0x00000000 //No flags
#define PDOR_NOQUERY	0x00000001 //Do not call QueryAcceptData
#define PDOR_DROP		0x00000002 //This is a drop operation

class CLightDTEngine
{
public:
	CLightDTEngine();

	~CLightDTEngine();

	void Init(CTxtEdit * ped);

	void ReleaseDropTarget();

	void Destroy();

	// clipboard
	HRESULT CopyRangeToClipboard(CTxtRange *prg, LONG lStreamFormat);
	HRESULT CutRangeToClipboard (CTxtRange *prg, LONG lStreamFormat, 
								 IUndoBuilder *publdr);
	DWORD	CanPaste( IDataObject *pdo, CLIPFORMAT cf, DWORD flags );

	void	FlushClipboard(void);

	// data object
	HRESULT RangeToDataObject( CTxtRange *prg, LONG lStreamFormat,
										IDataObject **ppdo );
	HRESULT PasteDataObjectToRange( IDataObject *pdo, CTxtRange *prg, 
									CLIPFORMAT cf, REPASTESPECIAL *rps,
									IUndoBuilder *publdr, DWORD dwFlags );
	HRESULT CreateOleObjFromDataObj( IDataObject *pdo, CTxtRange *prg, 
									 REPASTESPECIAL *rps, INT iFormatEtc,
									 IUndoBuilder *publdr );

	// drag drop
	HRESULT GetDropTarget( IDropTarget **ppDropTarget );
	HRESULT StartDrag( CTxtSelection *psel, IUndoBuilder *publdr );
	BOOL fInDrag();

	// file I/O
	LONG LoadFromEs( CTxtRange *prg, LONG lStreamFormat, EDITSTREAM *pes, 
							 BOOL fTestLimit, IUndoBuilder *publdr);
	LONG SaveToEs(	 CTxtRange *prg, LONG lStreamFormat,
							 EDITSTREAM *pes );

	// conversion routines
	HGLOBAL AnsiPlainTextFromRange( CTxtRange *prg );
	HGLOBAL UnicodePlainTextFromRange( CTxtRange *prg );
	HGLOBAL RtfFromRange( CTxtRange *prg, LONG lStreamFormat );

	// direct clipboard support
	HRESULT RenderClipboardFormat(WPARAM wFmt);
	HRESULT RenderAllClipboardFormats();
	HRESULT DestroyClipboard();

	LONG 	ReadPlainText( CTxtRange *prg, EDITSTREAM *pes, BOOL fTestLimit,
								IUndoBuilder *publdr, LONG lStreamFormat);
protected:

	LONG	WritePlainText( CTxtRange *prg, EDITSTREAM *pes, LONG lStreamFormat);
	HRESULT HGlobalToRange(DWORD dwFormatIndex, HGLOBAL hGlobal, LPTSTR ptext,
									CTxtRange *prg,	IUndoBuilder *	publdr);
	HRESULT DIBToRange(HGLOBAL hGlobal,	CTxtRange *prg,	IUndoBuilder *	publdr);
	LONG	GetStreamCodePage(LONG lStreamFormat);

	CTxtEdit *		_ped;
	CDropTarget *	_pdt;		// the current drop target
	IDataObject *	_pdo;		// data object that may be on the clipboard.
	BYTE			_fUseLimit;	// Whether to use limit text in calculation
								// Note: if we need more flags do the bit 
								// field thing.
	BYTE			_fOleless;  // Ole clipboard support?
};

/*
 *	CLightDTEngine::Init (ped)
 *
 *	@mfunc
 *		initializes the object
 */
inline void CLightDTEngine::Init(
	CTxtEdit *ped)					// @parm text 
{
	_ped = ped;
}

/*
 *	CLightDTEngine::ReleaseDropTarget (ped)
 *
 *	@mfunc
 *		Releases the drop target if there is one.
 */
inline void CLightDTEngine::ReleaseDropTarget()
{
	if (_pdt)
	{
		_pdt->Release();
		_pdt = NULL;
	}
}

/*
 *	CLightDTEngine::fInDrag ()
 *
 *	@mfunc
 *		Tells whether a drag operation is occuring
 */
inline BOOL CLightDTEngine::fInDrag()
{
	return (_pdt != NULL) ? _pdt->fInDrag() : FALSE;
}

#endif // !__LDTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_layout.h ===
/*
 *	_LAYOUT.H
 *	
 *	Purpose:
 *		CLayout class
 *	
 *	Owner:<nl>
 *		Murray Sargent: Initial table implementation
 *		Keith Curtis:	Factored into a separate class for
 *						performance, simplicity
 * 
 *	Copyright (c) 1999-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _LAYOUT_H
#define _LAYOUT_H

#include "_format.h"


// ==========================  CLayout ===================================
// Holds an array of lines and has the ability to do rich layout.

class CLayout : public CLineArray				//CLayout *plo;
{
public:
			CLayout()  {_iCFCells = -1; _iPFCells = -1;}
			~CLayout() {DeleteSubLayouts(0, -1); ReleaseFormats(_iCFCells, _iPFCells);}

	void	DeleteSubLayouts(LONG ili, LONG cLine);
	virtual BOOL IsNestedLayout() const {return TRUE;}
			BOOL IsTableRow() {return _iPFCells >= 0;}

	//Helper routines
	LONG	LineFromVpos (CDisplayML *pdp, LONG vPos, LONG *pdvpLine, LONG *pcpFirst);
	LONG	VposFromLine (CDisplayML *pdp, LONG ili);
	const	CCharFormat *GetCFCells();
	const	CParaFormat *GetPFCells() const;
	static	const CLayout *GetLORowAbove(CLine *pli, LONG ili,
										 CLine *pliMain = NULL, LONG iliMain = 0);
	TFLOW	GetTflow() const {return _tflow;}
	void	SetTflow(TFLOW tflow) {_tflow = tflow;}

	static	CLine *	FindTopCell(LONG &cch, CLine *pli, LONG &ili, LONG dul, LONG &dy,
								LONG *pdyHeight, CLine *pliMain, LONG iliMain, LONG *pcLine);
	CLine * FindTopRow(CLine *pliStart, LONG ili, CLine *pliMain, LONG iliMain, const CParaFormat *pPF);
			LONG	GetVertAlignShift(LONG uCell, LONG dypText);

	//The Big 4 methods
	BOOL	Measure (CMeasurer& me, CLine *pli, LONG ili, UINT uiFlags, 
					 CLine *pliTarget = NULL, LONG iliMain = 0, CLine *pliMain = NULL, LONG *pdvpMax = NULL);
	BOOL	Render(CRenderer &re, CLine *pli, const RECTUV *prcView, BOOL fLastLine, LONG ili, LONG cLine);
    LONG    CpFromPoint(CMeasurer &me, POINTUV pt, const RECTUV *prcClient, 
						CRchTxtPtr * const ptp, CLinePtr * const prp, BOOL fAllowEOL,
						HITTEST *pHit, CDispDim *pdispdim, LONG *pcpActual,
						CLine *pliParent = NULL, LONG iliParent = 0);
    LONG    PointFromTp (CMeasurer &me, const CRchTxtPtr &tp, const RECTUV *prcClient, BOOL fAtEnd,	
						POINTUV &pt, CLinePtr * const prp, UINT taMode, CDispDim *pdispdim = NULL);

	LONG			_dvp;			// The height of the array
protected:
    LONG			_cpMin;			// First character in layout

	// REVIEW: _tflow and _dvlBrdrTop can be BYTEs
	LONG			_tflow;			// Textflow for layout
	WORD			_dvpBrdrTop;	// Max table row top border
	WORD			_dvpBrdrBot;	// Max table row bottom border
	SHORT			_iCFCells;		// iCF for CLines representing table-row cells
	SHORT			_iPFCells;		// iPF for CLines representing table-row cells
};

#endif //_LAYOUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_line.h ===
/*
 *	_LINE.H
 *	
 *	Purpose:
 *		CLine class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#ifndef _LINE_H
#define _LINE_H

#include "_runptr.h"

class CDisplay;
class CDisplayML;
class CMeasurer;
class CRenderer;
class CDispDim;
class CLayout;
class CLinePtr;
// ============================	 CLine	=====================================
// line - keeps track of a line of text
// All metrics are in rendering device units

class CLine : public CTxtRun
{
	friend class CMeasurer;
	friend class CRenderer;
	friend class CDisplaySL;
	friend struct COls;

	union
	{
		struct
		{
		USHORT	_dvpDescent;	// Distance from baseline to bottom of line
		USHORT	_dvpHeight;		// Line height
		};
		CLayout *_plo;			// Pointer to nested layout iff _fIsNestedLayout
	};
public:
	SHORT	_upStart;			// Line start position (line indent + line shift)
	USHORT	_dup;				// Line width not incl _upStart, trailing whitespace

	BYTE	_bNumber;			// Abstract paragraph number (0 is unnumbered)

	BYTE	_cObjectWrapLeft:3;	// How far back in backing store to look for objects
	BYTE	_cObjectWrapRight:3;// that we are wrapping around
	BYTE	_fFirstWrapLeft:1;	// TRUE iff the first line of a wrapped object
	BYTE	_fFirstWrapRight:1;	// TRUE iff the first line of a wrapped object

	BYTE	_ihyph : 5;			// Index into hyphenation table (0 is no hyphenation)
	BYTE	_cchEOP:2;			// Count of EOP chars; 0 if no EOP this line
	BYTE	_fIsNestedLayout:1;	// TRUE iff line has a nested layout

	BYTE	_nHeading:4;		// Heading level (0 if not heading)
	BYTE	_fCollapsed:1;		// Line is collapsed
	BYTE	_fFirstOnPage:1;	// Line is first one on page
	BYTE	_fHasFF:1;			// Line ends with FF (FormFeed)
	BYTE	_fHasEOP:1;			// Line ends with CR or LF

	BYTE	_fHasSpecialChars:1;// Has EURO, tabs, OLE, etc.
	BYTE	_fFirstInPara:1;	// First line in paragraph
	BYTE	_fPageBreakBefore:1;// PFE_PAGEBREAKBEFORE TRUE
	BYTE	_fUseOffscreenDC:1;	// Line should be rendered offscreen
	BYTE	_fOffscreenOnce:1;	// Only render Offscreen once--after edits
	BYTE	_fIncludeCell:1;	// Include CELL in line after nested table

public:
	// !!!!! CLine should not have any virtual methods !!!!!!

	// The "big four" line methods: measure, render, CchFromUp, UpFromCch 
	BOOL Measure (CMeasurer& me, UINT uiFlags, CLine *pliTarget = NULL);
	BOOL Render (CRenderer& re, BOOL fLastLine);

	LONG CchFromUp(CMeasurer& me, POINTUV pt, CDispDim *pdispdim = NULL,
					 HITTEST *pHit = NULL, LONG *pcpActual = NULL) const;
	LONG UpFromCch(CMeasurer& me, LONG cchMax, UINT taMode,
					 CDispDim *pdispdim = NULL, LONG *pdy = NULL) const;

	CLayout *GetPlo() const {return IsNestedLayout() ? _plo : 0;}
	void SetPlo(CLayout *plo) {_plo = plo; _fIsNestedLayout = _plo != 0;}
	// Helper functions
	BOOL IsNestedLayout(void) const {return _fIsNestedLayout;}
	LONG GetHeight () const;
	LONG GetDescent() const;
	void Init ()				{ZeroMemory(this, sizeof(CLine));}
	BOOL IsEqual (CLine& li);
};

// ==========================  CLineArray  ===================================
// Array of lines
typedef CArray<CLine> CLineArray;

// ==========================  CLinePtr	 ===================================
// Maintains position in a array of lines

class CLinePtr : public CRunPtr<CLine>
{
protected:
	CDisplay *	_pdp;
	CLine *		_pLine;	

public:
	CLinePtr (CDisplay *pdp);
	CLinePtr (CLinePtr& rp) : CRunPtr<CLine> (rp)	{}

	void Init ( CLine & );
	void Init ( CLineArray & );
    
	// Alternate initializer
	void 	Set(LONG iRun, LONG ich, CLineArray *pla = NULL);

	// Direct cast to a run index
	operator LONG() const			{return _iRun;}

	// Get the run index (line number)
	LONG GetLineIndex(void) const	{return _iRun;}
	LONG GetAdjustedLineLength();

	LONG GetCchLeft() const;
	CDisplay *GetPdp() const		{return _pdp;}

	// Dereferencing
	BOOL	IsValid() const; 
	CLine *	operator ->() const;		
    CLine &	operator *() const;      
	CLine & operator [](LONG dRun);
	CLine * GetLine() const;
	WORD	GetNumber();
	WORD	GetHeading()	{return GetLine()->_nHeading;}
    
	// Pointer arithmetic
	BOOL	operator --(int);
	BOOL	operator ++(int);

	// Character position control
	LONG	GetIch() const		{return _ich;}
	BOOL	Move(LONG cch);
	BOOL	SetCp(LONG cp, BOOL fAtEnd, LONG lNest = 0);
    BOOL	OperatorPostDeltaSL(LONG Delta);
    BOOL	MoveSL(LONG cch);

	// Array management 
    // These should assert, but gotta be here
    
    // Strictly speaking, these members should never be called for the single
    // line case.  The base class better assert
    
	void Remove (LONG cRun)
    {
        CRunPtr<CLine>::Remove(cRun);
    }

	BOOL Replace(LONG cRun, CArrayBase *parRun)
    {
        return CRunPtr<CLine>::Replace(cRun, parRun);
    }
	
	// Assignment from a run index
	CRunPtrBase& operator =(LONG iRun) {SetRun(iRun, 0); return *this;}

	LONG	FindParagraph(BOOL fForward);
	LONG	CountPages(LONG &cPage, LONG cchMax, LONG cp, LONG cchText) const;
	void	FindPage(LONG *pcpMin, LONG *pcpMost, LONG cpMin, LONG cch, LONG cchText);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_msremsg.h ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	_MSREMSG.H
 
 *
 *	Purpose:  
 *		This file contains private Richedit messages and data.
 *
 *	Author:	<nl>
 *		12/20/99 honwch
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#ifndef	_MSREMSG_H
#define	_MSREMSG_H

#ifndef	_C_MSGADVISESINK
#define _C_MSGADVISESINK
class CTextMsgFilter;
class CMsgCallBack
{
public:
	CMsgCallBack(CTextMsgFilter *pTextMsgFilter) {_pTextMsgFilter = pTextMsgFilter;};
	~CMsgCallBack() {};

	HRESULT HandlePostMessage(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres);

	HRESULT	NotifyEvents(DWORD dwEvent);

private:
	CTextMsgFilter *_pTextMsgFilter;
};
#endif

typedef struct tagALTDISPLAYATTRIBUTE
{
	COLORREF	crText;
	COLORREF	crBk;
	COLORREF	crLine;	
	WORD		lsStyle;
	WORD		wMask;
}	ALTDISPLAYATTRIBUTE;

// Bit fields for EM_GETDOCFLAGS
#define	GDF_READONLY		0x0001
#define GDF_OVERTYPE		0x0002
#define GDF_SINGLECPG		0x0004
#define GDF_RICHTEXT		0x0008
#define GDF_ALL (GDF_READONLY | GDF_OVERTYPE | GDF_SINGLECPG | GDF_RICHTEXT)

// Bits for the ALTDISPLAYATTRIBUTE wMask
#define	ADA_CRTEXT		0x0001
#define ADA_CRBK		0x0002
#define ADA_LSLINE		0x0004
#define ADA_CRLINE		0x0008

// Bits for NotifyEvents dwEvent
#define	NE_ENTERTOPLEVELCALLMGR		0x0001
#define NE_EXITTOPLEVELCALLMGR		0x0002
#define NE_CALLMGRSELCHANGE			0x0004
#define NE_CALLMGRCHANGE			0x0008
#define NE_LAYOUTCHANGE				0x0010
#define NE_MODEBIASCHANGE			0x0020

// Option for EM_SETUIM
#define SES_USEAIMM11				0x0001
#define SES_USEAIMM12				0x0002

#define	EM_PRI_MSG					(WM_USER + 0x07000)

#define EM_INSERTOBJ				(EM_PRI_MSG + 0)
#define	EM_SETCALLBACK				(EM_PRI_MSG + 1)
#define EM_SETUPNOTIFY				(EM_PRI_MSG + 2)
#define EM_GETDOCFLAGS				(EM_PRI_MSG + 3)
#define EM_SETUIM					(EM_PRI_MSG + 4)
#define EM_GETPARATXTFLOW			(EM_PRI_MSG + 5)

#endif	// _MSREMSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_notmgr.h ===
/*
 *	_NOTMGR.H
 *
 *	Purpose:
 *		Notification Manager declarations
 *
 *	Author:
 *		AlexGo	6/5/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _NOTMGR_H_
#define _NOTMGR_H_

// forward declaration
class CNotifyMgr;

// Set cp to this to signal that the control has converted from rich to plain.
const DWORD CONVERT_TO_PLAIN = 0xFFFFFFFE;

// id values used in NOTIFY_DATA
#define	NOTIFY_DATA_TEXT_ID		0x0001		// used by RTEXT

// Flags values used in NOTIFY_DATA
#define	TN_TX_CELL_SHRINK		0x0001		// indicate some text cells have been removed.

typedef struct 
{
	DWORD	id;
	DWORD	dwFlags;
	VOID	*pData;
} NOTIFY_DATA;

/*
 *	ITxNotify
 *
 *	Purpose:
 *		a notification sink for events happening to the backing store,
 *		used by the Notification Manager
 */
class ITxNotify
{
public:
	virtual void OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
					LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData ) = 0;
	virtual void OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
					LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData ) = 0;
	virtual void Zombie() = 0;

private:
	ITxNotify *	_pnext;

	friend class CNotifyMgr;	// so it can manipulate _pnext
};


/*
 *	CNotifyMgr
 *
 *	Purpose:
 *		the general notification manager; keeps track of all interested 
 *		notification sinks
 */

class CNotifyMgr
{
public:
	void Add( ITxNotify *pITN );
	void Remove( ITxNotify *pITN );
	void NotifyPreReplaceRange( ITxNotify *pITNignore, LONG cp, LONG cchDel, 
			LONG cchNew, LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData = NULL );
	void NotifyPostReplaceRange( ITxNotify *pITNignore, LONG cp, LONG cchDel, 
			LONG cchNew, LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData = NULL );

	CNotifyMgr();
	~CNotifyMgr();

private:

	ITxNotify *	_pitnlist;
};

#endif //_NOTMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_measure.h ===
/*
 *	_MEASURE.H
 *	
 *	Purpose:
 *		CMeasurer class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#ifndef _MEASURE_H
#define _MEASURE_H

#include "_rtext.h"
#include "_line.h"
#include "_disp.h"

#ifndef NOLINESERVICES
#include "_ols.h"
#endif

class CCcs;
class CDevDesc;
class CPartialUpdate;
class CUniscribe;
class COleObject;


const short BITMAP_WIDTH_SUBTEXT = 4;
const short BITMAP_HEIGHT_SUBTEXT = 4;

const short BITMAP_WIDTH_HEADING = 10;
const short BITMAP_HEIGHT_HEADING = 10;

#define TA_STARTOFLINE	32768
#define TA_ENDOFLINE	16384
#define TA_LOGICAL		8192
#define TA_CELLTOP		4096

// ===========================  CMeasurer  ===============================
// CMeasurer - specialized rich text pointer used to compute text metrics.
// All metrics are computed and stored in device units for the device
// indicated by _pdd.
class CMeasurer : public CRchTxtPtr
{
	friend class CLayout;
	friend class CDisplay;
	friend class CDisplayML;
	friend class CDisplayPrinter;
	friend class CDisplaySL;
	friend class CLine;
	friend struct COls;
	friend class CUniscribe;
#ifndef NOLINESERVICES
	friend LSERR WINAPI OlsOleFmt(PLNOBJ plnobj, PCFMTIN pcfmtin, FMTRES *pfmres);
	friend LSERR WINAPI OlsGetRunTextMetrics(POLS pols, PLSRUN plsrun,
				enum lsdevice deviceID, LSTFLOW kTFlow, PLSTXM plsTxMet);
	friend LSERR WINAPI OlsFetchPap(POLS pols, LSCP	cpLs, PLSPAP plspap);
	friend LSERR WINAPI OlsGetRunCharKerning(POLS, PLSRUN, LSDEVICE, LPCWSTR, DWORD, LSTFLOW, int*);
	friend LSERR WINAPI OlsFetchTabs(POLS, LSCP, PLSTABS, BOOL*,long *, WCHAR*);
#endif

public:
	CMeasurer (const CDisplay* const pdp);
	CMeasurer (const CDisplay* const pdp, const CRchTxtPtr &rtp);
	virtual ~CMeasurer();

	const CDisplay* GetPdp() const 		{return _pdp;}

	void 	AdjustLineHeight();

	COleObject *GetObjectFromCp(LONG cp) const
	{return GetPed()->GetObjectMgr()->GetObjectFromCp(cp);}

#ifndef NOLINESERVICES
	COls *	GetPols();
	CUniscribe* Getusp() const { return GetPed()->Getusp(); }
#endif

	CCcs*	GetCcs(const CCharFormat *pCF);
	CCcs*	GetCcsFontFallback(const CCharFormat *pCF, WORD wScript);
	CCcs*	ApplyFontCache(BOOL fFallback, WORD wScript);
	
	void	CheckLineHeight();
	CCcs *	Check_pccs(BOOL fBullet = FALSE);
	LONG	GetNumber() const			{return _wNumber;}
	WCHAR	GetPasswordChar() const		{return _chPassword;}
	const CParaFormat *Get_pPF()		{return _pPF;}
	LONG	GetCch() const				{return _li._cch;}
	void	SetCch(LONG cch)			{_li._cch = cch;}
	CLine & GetLine(void)				{return _li;}
	LONG	GetRightIndent()			{return _upRight;}
	HITTEST	HitTest(LONG x);
	BOOL	fFirstInPara() const		{return _li._fFirstInPara;}
	BOOL	fUseLineServices() const	{return GetPed()->fUseLineServices();}
	BOOL	IsRenderer() const			{return _fRenderer;}
	BOOL	IsMeasure() const			{return _fMeasure;}
	LONG	LUtoDU(LONG u)	{ return MulDiv(u, _fTarget ? _durInch : _dupInch, LX_PER_INCH);}
	LONG	LVtoDV(LONG v)	{ return MulDiv(v, _fTarget ? _dvrInch : _dvpInch, LX_PER_INCH);}
	const	CLayout *GetLayout()	{return _plo;}
	void	SetLayout(const CLayout *plo) {_plo = plo;}
	LONG	GetDulLayout()	{return _dulLayout;}
	LONG	GetCchLine() const {return _cchLine;}
	LONG	GetPBorderWidth(LONG dxlLine);
	void	SetDulLayout(LONG dul) {_dulLayout = dul;}
	void	SetIhyphPrev(LONG ihyphPrev) {_ihyphPrev = ihyphPrev;}
	LONG	GetIhyphPrev(void) {return _ihyphPrev;}
	TFLOW	GetTflow() const {return _pdp->GetTflow();}
	void	NewLine(BOOL fFirstInPara);
	void	NewLine(const CLine &li);
	LONG    MeasureLeftIndent();
	LONG	MeasureRightIndent();
	LONG 	MeasureLineShift();
	LONG	MeasureText(LONG cch);
	BOOL 	MeasureLine(UINT uiFlags, CLine* pliTarget = NULL);
	LONG	MeasureTab(unsigned ch);
	void	SetNumber(WORD wNumber);
	void	UpdatePF()					{_pPF = GetPF();}
	LONG	XFromU(LONG u);
	LONG	UFromX(LONG x);

	CCcs*	GetCcsBullet(CCharFormat *pcfRet);
	void	SetUseTargetDevice(BOOL fUseTargetDevice);
	BOOL	FUseTargetDevice(void)		{return _fTarget || _dvpInch == _dvrInch;}
	BOOL	FAdjustFELineHt()			{return !(GetPed()->Get10Mode()) && !fUseUIFont() && _pdp->IsMultiLine();}
	void	SetGlyphing(BOOL fGlyphing);

protected:
	void	Init(const CDisplay *pdp);
	LONG 	Measure(LONG dulMax, LONG cchMax, UINT uiFlags);
	LONG	MeasureBullet();
	LONG	GetBullet(WCHAR *pch, CCcs *pccs, LONG *pdup);
	void	UpdateWrapState(USHORT &dvpLine, USHORT &dvpDescent);
	void	UpdateWrapState(USHORT &dvpLine, USHORT &dvpDescent, BOOL fLeft);

	BOOL	FormatIsChanged();
	void	ResetCachediFormat();
	LONG	DUtoLU(LONG u) {return MulDiv(u, LX_PER_INCH, _fTarget ? _durInch : _dupInch);}
	LONG	FindCpDraw(LONG cpStart, int cobjectPrev, BOOL fLeft);

private:
    void 	RecalcLineHeight(CCcs *,
			const CCharFormat * const pCF);	// Helper to recalc max line height

	COleObject*	FindFirstWrapObj(BOOL fLeft);
	void	RemoveFirstWrap(BOOL fLeft);
	int		CountQueueEntries(BOOL fLeft);
	void	AddObjectToQueue(COleObject *pobjAdd);

protected:
		  CLine		_li;			// Line we are measuring
	const CDisplay*	_pdp;			// Display we are operating in
	const CDevDesc*	_pddReference;	// Reference device

	CArray<COleObject*> _rgpobjWrap;// A queue of objects to wrapped around
		  LONG		_dvpWrapLeftRemaining;	//For objects being wrapped around,
		  LONG		_dvpWrapRightRemaining; //how much of the height is remaining

		  LONG		_dvrInch;		// Resolution of reference device
		  LONG		_durInch;

		  LONG		_dvpInch;		// Resolution of presentation device
		  LONG		_dupInch;

		  LONG		_dulLayout;		// Width of layout we are measuring in

		  LONG		_cchLine;		// If !_fMeasure, tells us number of chars on line
		  CCcs*		_pccs;			// Current font cache
  const CParaFormat *_pPF;			// Current CParaFormat
	const CLayout  *_plo;			// Current layout we are measuring in (0 if SL)

		  LONG		_dxBorderWidths;// Cell border widths
		  SHORT		_dupAddLast;	// Last char considered but unused for line
		  WCHAR		_chPassword;	// Password character if any
		  WORD		_wNumber;		// Number offset
		  SHORT		_iFormat;		// Current format
		  SHORT		_upRight;		// Line right indent
		  BYTE		_ihyphPrev;		// Hyphenation information for previous line
									// Used for support of khyphChangeAfter
		  BYTE		_fRenderer:1;	// 0/1 for CMeasurer/CRenderer, resp.
		  BYTE		_fTarget:1;		// TRUE if we are supposed to be using
									//  reference metrics for laying out text
		  BYTE		_fFallback:1;	// Current font cache is fallback font
		  BYTE		_fGlyphing:1;	// In the process of creating glyphs
		  BYTE		_fMeasure:1;	// TRUE if we are measuring. Else, we are
									// rendering or we are hit-testing which means we need
									// to justify the text and that data cached at measure time is valid.
};


// Values for uiFlags in MeasureLine()
#define MEASURE_FIRSTINPARA 	0x0001
#define MEASURE_BREAKATWORD 	0x0002
#define MEASURE_BREAKBEFOREWIDTH 0x0004	// Breaks at character before target width
#define MEASURE_IGNOREOFFSET	0x0008


// Returned error codes for Measure(), MeasureText(), MeasureLine()
#define MRET_FAILED		-1
#define MRET_NOWIDTH	-2

inline BOOL CMeasurer::FormatIsChanged()
{
	return !_pccs || _iFormat != _rpCF.GetFormat() || _fFallback;
}

inline void CMeasurer::ResetCachediFormat()
{
	_iFormat = _rpCF.GetFormat();
}

const int duMax = tomForward;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_m_undo.h ===
/*
 *	_M_UNDO.H
 *
 *	Purpose:
 *		Declares multilevel undo interfaces and classes
 *
 *	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef __M_UNDO_H__
#define __M_UNDO_H__

#include "_callmgr.h"

// Forward declaration to get around dependency cycle
class CTxtEdit;
class IUndoBuilder;

/*
 *	MergeDataTypes
 *
 *	@enum	Tags indicating the different data types that can be
 *			sent in IAntiEvent::MergeData
 */
enum MergeDataTypes
{
	MD_SIMPLE_REPLACERANGE	= 1,	//@emem a simple replace range; 
									//usually just typing or backspace
	MD_SELECTIONRANGE		= 2		//@emem the selection location
};

/*
 *	SimpleReplaceRange
 *
 *	@stuct	SimpleReplaceRange | has the data from a replace range operation
 *			*except* for any deleted characters.  If we don't have to save
 *			the deleted characters, we don't.
 */
struct SimpleReplaceRange
{
	LONG	cpMin;		//@field	cpMin of new text
	LONG	cpMax;		//@field	cpMax of new text
	LONG	cchDel;		//@field 	number of characters deleted
};

/*
 *	SELAEFLAGS
 *
 *	@enum	Flags to control how the selection range info should be treated
 */
enum SELAE
{
	SELAE_MERGE = 1,
	SELAE_FORCEREPLACE	= 2
};

/*
 *	SelRange
 *
 *	@struct SelRange | has the data for a selection's location _and_ the 
 *			information needed to generate an undo action for the selection
 *			placement
 *	
 *	@comm	-1 may be used to NO-OP any field
 */
struct SelRange
{
	LONG	cp;			//@field	Active end
	LONG	cch;		//@field	Signed extension
	LONG	cpNext;		//@field	cp for the inverse of this action
	LONG	cchNext;	//@field	Extension for the inverse of this action
	SELAE	flags;		//@field	Controls how this info is interpreted
};

/*
 *	IAntiEvent
 *
 *	Purpose:
 *		Antievents undo 'normal' events, like typing a character
 */
class IAntiEvent 
{
public:
	virtual void Destroy( void ) = 0;

	// It should be noted that CTxtEdit * here is really just a general
	// closure, i.e. it could be expressed by void *.  However, since
	// this interface is currently just used internally, I've opted
	// to use the extra type-checking.  alexgo
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr ) = 0;

	// This method will let us merge in arbitrary data for things like
	// group typing
	virtual HRESULT MergeData( DWORD dwDataType, void *pdata) = 0;

	// This method is called when antievent is committed to undo stack.
	// Allows us to handle re-entrancy better for OLE objects.
	virtual void OnCommit(CTxtEdit *ped) = 0;

	// These two methods allow antievents to be chained together in
	// a linked list
	virtual	void SetNext(IAntiEvent *pNext) = 0;
	virtual IAntiEvent *GetNext() = 0;
protected:
	~IAntiEvent() {;}
};

/*
 *	IUndoMgr
 *
 *	Purpose:
 *		Interface for managing "stacks" of antievents
 */
class IUndoMgr
{
public:
	virtual void		Destroy () = 0;
	virtual LONG		SetUndoLimit (LONG cUndoLim) = 0;
	virtual LONG		GetUndoLimit () = 0;
	virtual HRESULT		PushAntiEvent (UNDONAMEID idName, IAntiEvent *pae) = 0;
	virtual HRESULT		PopAndExecuteAntiEvent (void* pAE) = 0;
	virtual UNDONAMEID	GetNameIDFromAE (void *pAE) = 0;
	virtual IAntiEvent *GetMergeAntiEvent () = 0;
	virtual void *		GetTopAECookie () = 0;
	virtual	void		ClearAll () = 0;
	virtual BOOL		CanUndo () = 0;
	virtual void		StartGroupTyping () = 0;
	virtual void		StopGroupTyping () = 0;

protected:
	~IUndoMgr() {;}
};

/*
 *	USFlags
 *
 *	@enum
 *		Flags affecting the behaviour of Undo stacks
 */
enum USFlags
{
	US_UNDO			= 1,	//@emem Regular undo stack
	US_REDO			= 2		//@emem	Undo stack is for REDO functionality
};
	
/*
 *	CUndoStack
 *	
 *	@class
 *		Manages a stack of antievents.  These antievents are kept in
 *		a resizable ring buffer.  Exports the IUndoMgr interface
 */
class CUndoStack : public IUndoMgr
{
//@access	Public Methods
public:
	virtual void	Destroy();					//@cmember Destroy
	virtual LONG	SetUndoLimit(LONG cUndoLim);//@cmember Set item limit
	virtual LONG	GetUndoLimit();
												//@cmember	Add an AE to stack
	virtual HRESULT PushAntiEvent(UNDONAMEID idName, IAntiEvent *pae);
												//@cmember Execute most recent
	virtual HRESULT PopAndExecuteAntiEvent(void *pAE);//   antievent or upto pAE  
	virtual UNDONAMEID GetNameIDFromAE(void *pAE);//@cmember Get name of given AE 
	virtual IAntiEvent *GetMergeAntiEvent();	//@cmember Get most recent AE
												//			of merge state
	virtual void *	GetTopAECookie();			//@cmember Get cookie for top AE
	virtual	void	ClearAll();					//@cmember Delete all AEs
	virtual BOOL	CanUndo();					//@cmember Something to undo?
	virtual void	StartGroupTyping();			//@cmember Starts group typing
	virtual void	StopGroupTyping();			//@cmember Stops group typing

	// Public methods; not part of IUndoMgr
	HRESULT	EnableSingleLevelMode();			//@cmember RE1.0 undo mode
	void	DisableSingleLevelMode();			//@cmember Back to RE2.0 mode
												//@cmember Are we in 1.0 mode?
	BOOL	GetSingleLevelMode() {return _fSingleLevelMode;}

	CUndoStack(CTxtEdit *ped, LONG &cUndoLim, USFlags flags);

private:
	~CUndoStack();

	struct UndoAction
	{
		IAntiEvent * pae;
		UNDONAMEID	 id;
	};

	void Next();						//@cmember Moves by 1
	void Prev();						//@cmember Moves by -1
	LONG GetPrev();						//@cmember Get previous index
										//@cmember TRUE iff cookie ae is in ae list
	BOOL IsCookieInList(IAntiEvent *pae, IAntiEvent *paeCookie);
										//@cmember Transfer this object to new stack
	void TransferToNewBuffer(UndoAction *prgnew, LONG dwLimNew);

	UndoAction *_prgActions;			//@cmember List of AEs
	LONG 		_cUndoLim;				//@cmember Undo limit
	LONG		_index;					//@cmember Current index
	CTxtEdit *	_ped;					//@cmember Big Papa

	DWORD		_fGroupTyping	  :1;	//@cmember Group Typing flag
	DWORD		_fMerge			  :1;	//@cmember Merge flag
	DWORD		_fRedo			  :1;	//@cmember Stack is the redo stack
	DWORD		_fSingleLevelMode :1;	//@cmember TRUE if single level undo
										// mode is on. Valid only for undo,
};										// i.e., not for redo stack

/*
 *	IUndoBuilder
 *
 *	Purpose:
 *		Provides a closure for collecting a sequence of antievents (such
 *		as all of the antievents involved in doing an intraedit drag-move
 *		operation.
 */
class IUndoBuilder
{
public:
	// Names antievent collection
	virtual void SetNameID( UNDONAMEID idName ) = 0;

	// Adds new antievent to collection
	virtual HRESULT AddAntiEvent( IAntiEvent *pae ) = 0;

	// Gets topmost antievent in this undo context.  This method
	// is useful for grouped typing (merging antievents)
	virtual IAntiEvent *GetTopAntiEvent() = 0;

	// Commits antievent collection
	virtual HRESULT Done() = 0;

	// Get rid of any antievents that have been collected
	virtual void Discard() = 0;

	// Notify that a group-typing session should start (forwarded
	// to the undo manager)
	virtual void StartGroupTyping() = 0;

	// Notify that a group-typing session should stop (forwarded
	// to the undo manager)
	virtual void StopGroupTyping() = 0;
};  

/*
 *	UBFlags
 *
 *	@enum
 *		Flags affecting the behaviour of Undo builders
 */
enum UBFlags
{
	UB_AUTOCOMMIT		= 1,	//@emem Call IUndoBuilder::Done before delete
	UB_REDO				= 2,	//@emem	Undo builder is for REDO functionality
	UB_DONTFLUSHREDO	= 4		//@emem Don't flush redo stack when adding
								//		antievents to undo stack
};

/*
 *	CGenUndoBuilder
 *
 *	@class
 *		A general purpose undo builder.  It can be easily allocated and freed
 *		on the stack and simply puts new antievents at the beginning of an
 *		antievent linked list.  NO attempt is made to optimize or reorder
 *		antievents.
 */
class CGenUndoBuilder : public IUndoBuilder, public IReEntrantComponent
{
//@access	Public methods
public:
	virtual void SetNameID( UNDONAMEID idName );	//@cmember Set the name
	virtual HRESULT AddAntiEvent(IAntiEvent *pae);	//@cmember Add an AE
	virtual IAntiEvent *GetTopAntiEvent( );			//@cmember Get top AE
	virtual HRESULT Done();							//@cmember Commit AEs
	virtual void Discard();							//@cmember Discard AEs
	virtual void StartGroupTyping();				//@cmember Start GT
	virtual void StopGroupTyping();					//@cmember Stop GT

	CGenUndoBuilder(CTxtEdit *ped, DWORD flags,		//@cmember Constructor
					IUndoBuilder **ppubldr = NULL);
	~CGenUndoBuilder( );							//@cmember Destructor

	// IReEntrantComponent methods
	virtual void OnEnterContext() {;}				//@cmember Reentered notify

//@access	Private methods
private:
	IUndoBuilder *	_publdrPrev;					//@cmember Ptr to undobldr
													//		   higher in stack
	IUndoMgr *		_pundo;							//@cmember Ptr to undo mgr
	CTxtEdit *		_ped;							//@cmember Ptr to edit contxt
	UNDONAMEID		_idName;						//@cmember Current name
	IAntiEvent *	_pfirstae;						//@cmember AE list
	UINT			_fAutoCommit:1;					//@cmember AutoCommit on?
	UINT			_fStartGroupTyping:1;			//@cmember GroupTyping on?
	UINT			_fRedo:1;						//@cmember UB destination is
													//		   the redo stack
	UINT			_fDontFlushRedo:1;				//@cmember Don't flush redo
													//	stack; i.e. we are
													//	invoking a redo action
	UINT			_fInactive:1;					//@cmember TRUE if undo enabled
};

/*
 *	CUndoStackGuard
 *
 *	@class
 *		A stack based class which helps manage reentrancy for the undo stack
 */
class CUndoStackGuard : public IReEntrantComponent
{
//@access	Public Methods
public:
	virtual void OnEnterContext();					//@cmember reentered notify

	CUndoStackGuard(CTxtEdit *ped);					//@cmember Constructor
	~CUndoStackGuard();								//@cmember Destructor
													//@cmember Execute the undo
	HRESULT SafeUndo(IAntiEvent *pae, IUndoBuilder *publdr);// actions in <p pae>
	BOOL	WasReEntered()  {return _fReEntered;}	//@cmember Return reentered flag 

//@access	Private Data
private:
	CTxtEdit *				_ped;					//@cmember Edit context
	volatile IAntiEvent *	_paeNext;				//@cmember Antievent loop ptr
	volatile HRESULT		_hr;					//@cmember Cached hr
	IUndoBuilder *			_publdr;				//@cmember Undo/redo context
	BOOL					_fReEntered;			//@cmember Have we been
};													//		   been reentered?

// Helper Functions. 

// Loop through a chain of antievents and destroy them
void DestroyAEList(IAntiEvent *pae);

// Loop through a chain of antievents and call OnCommit
void CommitAEList(CTxtEdit *ped, IAntiEvent *pae);

// Handles merging and/or creation of selection antievent info
HRESULT HandleSelectionAEInfo(CTxtEdit *ped, IUndoBuilder *publdr, 
			LONG cp, LONG cch, LONG cpNext, LONG cchNext, SELAE flags);

#endif // !__M_UNDO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_osdc.h ===
/*	@doc INTERNAL
 *
 *	@module _OSDC.H  Off Screen DC class |
 *	
 *	Define class for off screen DC
 *
 *	Original Author: <nl>
 *		Ricksa
 *
 *	History: <nl>
 *		1/11/96	ricksa	Created
 *
 *	Copyright (c) 1996-1998, Microsoft Corporation. All rights reserved.
 */
#ifndef __OSDC_H__
#define __OSDC_H__

/*
 *	COffscreenDC
 *	
 * 	@class	The COffscreenDC is a helper that creates, fills and destroys
 *			an off screen DC and its bitmaps.
 *
 */
class COffscreenDC
{
//@access Public Methods
public:
									//@cmember Constructor - create null object.
				COffscreenDC()		{_hdc = NULL;}

									//@cmember Destructor - clean up allocated 
									// resources if any.
				~COffscreenDC()		{FreeData();}
	
									//@cmember Initialize data based on input DC
	HDC			Init(HDC hdc, LONG xWidth, LONG yHeight, COLORREF crBackground);

									//@cmember Get DC for offscreen rendering
	HDC			GetDC()		{return _hdc;}
	void		GetDimensions(LONG *pdxp, LONG *pdyp);//@cmember the dimensions of the bitmap
									//@cmember Fill bitmap associated with off
									// screen rendering with background color.
	void		FillBitmap(LONG dxp, LONG dyp);

									//@cmember Render off screen bitmap to hdc
	void		RenderBitMap(HDC hdc, LONG xLeft, LONG yTop, LONG xWidth, LONG yHeight);

									//@cmember Get a copy of a bitmap from hdc
	BOOL		Get(HDC hdc, LONG xLeft, LONG yTop, LONG xWidth, LONG yHeight);

									//@cmember Reallocate bitmap for render
	BOOL		Realloc(LONG xWidth, LONG yHeight);

									//@cmember Select in a palette
	void		SelectPalette(HPALETTE hpa);

//@access Private Methods
private:
									//@cmember Free all data associated with object
	void		FreeData();

//@access Private Data 
private:
	HDC			_hdc;		//@cmember HDC for off screen DC
	HBITMAP		_hbmpOld;	//@cmember bitmap when DC created
	HBITMAP		_hbmp;		//@cmember compatible bitmap for render
	HPALETTE	_hpalOld;	//@cmember palette used by DC
};

/*
 *	COffscreenDC::FillBitmap (xWidth, yHeight)
 *
 *	@mfunc	
 *		Fill bitmap
 */
inline void COffscreenDC::FillBitmap(
	LONG dxp,		//@parm Width to fill with background color
	LONG dyp)		//@parm height to fill with background color
{
	// Erase background
	RECT rcClient;
	rcClient.top = rcClient.left = 0;
	rcClient.right = dxp;
	rcClient.bottom = dyp;
	ExtTextOut(_hdc, 0, 0, ETO_OPAQUE, &rcClient, NULL, 0, NULL);
}

/*
 *	COffscreenDC::RenderBitMap(hdc, xLeft, yTop, xWidth, yHeight)
 *
 *	@mfunc	
 *		Render bitmap to input DC
 */
inline void COffscreenDC::RenderBitMap(
	HDC  hdc,			//@parm HDC to render to
	LONG xLeft,			//@parm left position to start render
	LONG yTop,			//@parm top top position to start render
	LONG xWidth,		//@parm width to render
	LONG yHeight)		//@parm height to render
{
	BitBlt(hdc, xLeft, yTop, xWidth, yHeight, _hdc, 0, 0, SRCCOPY);
}
	
/*
 *	COffscreenDC::Get(hdc, xLeft, yTop, xWidth, yHeight)
 *
 *	@mfunc	
 *		Get a copy of a bitmap from another DC
 *
 *	@rdesc
 *		TRUE - succeeded
 *		FALSE - Failed
 */
inline BOOL COffscreenDC::Get(
	HDC  hdc,			//@parm HDC to copy from
	LONG xLeft,			//@parm left position of source bitmap
	LONG yTop,			//@parm top top position of source bitmap
	LONG xWidth,		//@parm width of bitmap
	LONG yHeight)		//@parm height to bitmap
{
	return BitBlt(_hdc, 0, 0, xWidth, yHeight, hdc, xLeft, yTop, SRCCOPY);
}

#endif __OSDC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_range.h ===
/*
 *	@doc
 *
 *	@module _RANGE.H -- CTxtRange Class |
 *	
 *		This class implements the internal text range and the TOM ITextRange
 *	
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *		Alex Gounares (floating ranges, etc.)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _RANGE_H
#define _RANGE_H

#include "_text.h"
#include "_m_undo.h"
#include "_rtext.h"
#include "_edit.h"
#include "_uspi.h"

long	FPPTS_TO_TWIPS(float x);
#define TWIPS_TO_FPPTS(x) (((float)(x)) * (float)0.05)

class CTxtEdit;
class CTxtFont;

/*
 *	SELRR
 *
 *	@enum	flags used to control how ReplaceRange (RR) should generate
 *			selection anti-events
 */
enum SELRR
{
	SELRR_IGNORE		= 0,
    SELRR_REMEMBERRANGE = 1,
    SELRR_REMEMBERCPMIN = 2,
    SELRR_REMEMBERENDIP = 3
};

/*
 *	FINDWORD_TYPE
 *
 *	@enum	defines the different cases for finding a word
 */
enum FINDWORD_TYPE {
	FW_EXACT	= 1,		//@emem	Finds the word exactly (no extra chars)
	FW_INCLUDE_TRAILING_WHITESPACE = 2,	//@emem find the word plus the 
							// following whitespace (ala double-clicking)
};

enum MOVES
{
	MOVE_START = -1,
	MOVE_IP = 0,
	MOVE_END = 1,
};

enum MATCHES
{
	MATCH_UNTIL = 0,
	MATCH_WHILE = 1
};

enum EOPADJUST
{
	NONEWCHARS = 0,
	NEWCHARS = 1
};

enum PROTECT 
{
	PROTECTED_YES,
	PROTECTED_NO,
	PROTECTED_ASK 
};

enum CHECKPROTECT
{
	CHKPROT_BACKWARD = -1,
	CHKPROT_EITHER, 
	CHKPROT_FORWARD, 
	CHKPROT_TOM
};

// Substring's input flags
#define SUBSTR_INSPANCHARSET		1
#define SUBSTR_INSPANBLOCK			2

// Substring's output charflags
#define SUBSTR_OUTCCLTR				1
#define SUBSTR_OUTCCRTL				2

enum CSCONTROL
{
	CSC_NORMAL,
	CSC_SNAPTOCLUSTER,
	CSC_NOMULTICHARBACKUP
};

class CCharFlags
{
public:
	BYTE	_bFirstStrong;			// flag for first strong character
	BYTE	_bContaining;			// flags for all presented characters
};


#define	SCF_IGNORESELAE	 0x80000000
#define SCF_IGNORENOTIFY 0x40000000	// use it with real caution! Caller must do it itself.

/*
 *	CTxtRange
 *	
 * 	@class
 *		The CTxtRange class implements RichEdit's text range, which is the
 *		main conduit through which changes are made to the document.
 *		The range inherits from the rich-text ptr, adding a signed length
 *		insertion-point char-format index, and a ref count for use when
 *		instantiated as a TOM ITextRange.  The range object also contains
 *		a flag that reveals whether the range is a selection (with associated
 *		screen behavior) or just a simple range.  This distinction is used
 *		to simplify some of the code.
 *
 *		Some methods are virtual to allow CTxtSelection objects to facilitate
 *		UI features and selection updating.
 *
 *		See tom.doc for lots of discussion on range and selection objects and
 *		on all methods in ITextRange, ITextSelection, ITextFont, and ITextPara.
 */
class CTxtRange : public ITextSelection, public CRchTxtPtr
{
	friend CTxtFont;

//@access Protected Data
protected:
	LONG	_cch;			//@cmember # chars in range. _cch > 0 for active
							//			end at range end (cpMost)
	LONG	_cRefs;			//@cmember ITextRange/ITextSelection ref count

	short	_iFormat;		//@cmember Character format for degenerate range

	union
	{
	  WORD _wFlags;			// All together now
	  struct
	  {
		WORD  _nSelExpandLevel:4;//@cmember Table level to expand to
		WORD  _fSel :1;			//@cmember True iff this is a CTxtSelection
		WORD  _fDragProtection :1;	//@cmember True is this range should think
								//	it's protected.  Set by drag/drop code
		WORD  _fDontUpdateFmt:1;//@cmember Don't update _iFormat
		WORD  _fDualFontMode:1;	//@cmember Set during dual font mode
		WORD  _fUseiFormat:1;	//@cmember Use iFormat when replacing 
								// a non-degenerate range
		WORD  _fMoveBack:1;		//@cmember TRUE if last change moved backward
		WORD  _fSelHasEOP:1;	//@cmember TRUE if Sel has EOP
		WORD  _fSelExpandCell:1;//@cmember TRUE if Sel has CELL but no TRDs at level
		WORD  _fUseBackwardPFFmt:1;	//@cmember Use backward PF format
	  };
	};

//@access Public methods
public:

#ifdef DEBUG
	BOOL	Invariant( void ) const;
	BOOL	IsOneEndUnHidden() const;
#endif // DEBUG

	CTxtRange(const CTxtRange &rg);
	CTxtRange(CTxtEdit *ped, LONG cp = 0, LONG cch = 0);
	CTxtRange(CRchTxtPtr &rtp, LONG cch = 0);
	virtual	~CTxtRange();

	virtual CRchTxtPtr& 	operator =(const CRchTxtPtr &rtp);
	virtual CTxtRange&		operator =(const CTxtRange &rg);

	// ITxNotify methods
										//@cmember Handles notifications
	virtual void OnPreReplaceRange(		//  prior to ReplaceRange calls
				LONG cp, LONG cchDel, LONG cchNew,
				LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData);
										//@cmember Handles notifications for
	virtual void OnPostReplaceRange(	//  floating range and display updates
				LONG cp, LONG cchDel, LONG cchNew,
				LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData);
	virtual	void Zombie();				//@cmember Convert range into zombie

	void	SetIgnoreFormatUpdate(BOOL fUpdate) { _fDontUpdateFmt = fUpdate; }

	void	SetDualFontMode(BOOL fDualFontMode) {_fDualFontMode = fDualFontMode; }

	// Internal cp/cch methods
    LONG 	GetCch (void) const			//@cmember Get signed character count
				{return _cch;}
	BOOL	IsSel()						{return _fSel;}
	BOOL	fExpandCell() const			{return _fSelExpandCell;}
	BOOL	fHasEOP() const				{return _fSelHasEOP;}
    BOOL 	CpInRange (LONG cp) const;	//@cmember Says if cp is in this range
										//@cmember Says if cch chars can fit
	BOOL	CheckTextLength (LONG cch, LONG *pcch = NULL);
										//@cmember Used after _cp change to set
	LONG	CheckChange(LONG cpSave, BOOL fExtend);//  selection-changed flag, choose _cch
										//@cmember In outline mode, maintain _fSelHasEOP
	BOOL	CheckIfSelHasEOP(LONG cpSave, LONG cchSave, BOOL fDoRange = FALSE);
	void	CalcTableExpandParms();		//@cmember Calculate table Expand members
										//@cmember Insert table row
	LONG	InsertTableRow(const CParaFormat *pPF, IUndoBuilder *publdr); 
										//@cmember TRUE for valid sequence
	BOOL	IsInputSequenceValid(WCHAR* pwch, LONG cch, BOOL fOver, BOOL* pfBaseChar = NULL);
 
	// GetRange() is faster than calling GetCpMin() and GetCpMost();
    LONG    GetCpMin () const;			//@cmember Get cp of first char in range
    LONG    GetCpMost () const;			//@cmember Get cp just beyond last char in range
										//@cmember Get range ends and count
	LONG	GetRange (LONG& cpMin, LONG& cpMost) const;
    BOOL	Set(LONG cp, LONG cch);
	LONG	SetCp(LONG cp, BOOL fExtend);
	LONG	GetAdjustedTextLength() const
				{return GetPed()->GetAdjustedTextLength();}

	// Range specific methods
	LONG	Move(LONG cch, BOOL fExtend);	
	void 	Collapser(long fStart);
	void 	FlipRange();
	LONG 	CleanseAndReplaceRange (LONG cchS, WCHAR const *pchS, BOOL fTestLimit, 
				IUndoBuilder *publdr, WCHAR *pchD = NULL, LONG* pcchMove = NULL, DWORD dwFlags = 0);
	LONG	CheckLimitReplaceRange (LONG cch, WCHAR const *pch,
				BOOL fTestLimit, IUndoBuilder *publdr, QWORD qwCharFlags,
				LONG *pcchMove, LONG cpFirst, int iMatchCurrent, DWORD &dwFlags);
	HRESULT	HexToUnicode (IUndoBuilder *publdr);
	HRESULT	UnicodeToHex (IUndoBuilder *publdr);
	void	Delete(IUndoBuilder *publdr, SELRR selaemode);
	void	DeleteTerminatingEOP(IUndoBuilder *publdr);
	BOOL	BypassHiddenText(LONG iDir, BOOL fExtend);
	void	CheckMergedCells(IUndoBuilder *publdr);
	void	CheckTopCells(IUndoBuilder *publdr);
	static BOOL	CheckCells(CELLPARMS *prgCellParms,	const CParaFormat *	pPF1,
					   const CParaFormat *pPF0, DWORD dwMaskCell, DWORD dwMaskCellAssoc);
	BOOL	AdjustEndEOP (EOPADJUST NewChars);

	// Outline management
	void	CheckOutlineLevel(IUndoBuilder *publdr);
	HRESULT	ExpandOutline  (LONG Level, BOOL fWholeDocument);
	HRESULT	OutlineExpander(LONG Level, BOOL fWholeDocument);
	HRESULT	Promote		   (LPARAM lparam, IUndoBuilder *publdr);

	// ReplaceRange must be virtual since the callers of
	// CLightDTEngine::CutRangeToClipboard() cast CTxtSelection* to CTxtRange*
	virtual	LONG	DeleteWithTRDCheck(IUndoBuilder *publdr, SELRR selaemode,
									   LONG *pcchMove, DWORD dwFlags);
	virtual	LONG 	ReplaceRange(LONG cchNew, TCHAR const *pch, IUndoBuilder *publdr,
						SELRR selaemode, LONG *pcchMove = NULL, DWORD dwFlags = 0);
	virtual	BOOL 	Update(BOOL fScrollIntoView);

	// Rich-text methods
	// Get/Set Char/Para Format methods
	void 	Update_iFormat(LONG iFmtDefault);
	QWORD	GetCharRepMask(BOOL fUseDocFormat = FALSE);	//@cmember Get range charset mask
	LONG	Get_iCF();						//@cmember Get range CF index
	LONG	Get_iFormat() {return _iFormat;}//@cmember Get _iFormat for quick peek
	LONG	GetiFormat() const;
    BOOL	Set_iCF(LONG iFormat);			//@cmember Set range CF index
	PROTECT	IsProtected(CHECKPROTECT chkprot);	//@cmember Is range protected?
	BOOL	IsZombie() {return !GetPed();}	//@cmember Is range zombied?
	BOOL	IsHidden();
	BOOL	WriteAccessDenied ();
	DWORD	GetCharFormat(CCharFormat *pCF, DWORD flags = 0) const;
	DWORD	GetParaFormat(CParaFormat *pPF, DWORD dwMask2) const;
	void	SetDragProtection(BOOL fSet)	// Convinces range it's protected
				{_fDragProtection = fSet;}	//  w/o modifying backing store
	HRESULT	CharFormatSetter (const CCharFormat *pCF, DWORD dwMask, DWORD dwMask2 = 0);
	HRESULT	ParaFormatSetter (const CParaFormat *pPF, DWORD dwMask);

	HRESULT	SetCharFormat(const CCharFormat *pCF, DWORD flags,
						  IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaFormat(const CParaFormat *pPF,
						  IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaStyle (const CParaFormat *pPF,
						  IUndoBuilder *publdr, DWORD dwMask);
	void	SetCellParms(CELLPARMS *prgCellParms, LONG cCell, BOOL fConvertLowCells, IUndoBuilder *publdr);
											//@cmember Format range CharSets
	// Complex script feature :- Itemization
	BOOL	ItemizeRuns(IUndoBuilder *publdr, BOOL fUnicodeBiDi = FALSE, BOOL fUseCtxLevel = FALSE);
#ifndef NOCOMPLEXSCRIPTS
	HRESULT BiDiLevelFromFSM (const CBiDiFSM* pfsm);
#endif
	LONG	GetRunsPF (CRchTxtPtr* prtp, CFormatRunPtr* prpPF, LONG& cchLeft);
#if defined(DEBUG)  && !defined(NOFULLDEBUG)
	void	DebugFont (void);
#endif

	// Find enclosing unit methods
	HRESULT	Expander		(long Unit, BOOL fExtend, LONG *pDelta,
							 LONG *pcpMin, LONG *pcpMost);
	void	FindAttributes	(LONG *pcpMin, LONG *pcpMost, LONG Unit) const;
	void	FindCell		(LONG *pcpMin, LONG *pcpMost) const;
    BOOL    FindObject		(LONG *pcpMin, LONG *pcpMost) const;
    void    FindParagraph	(LONG *pcpMin, LONG *pcpMost) const;
	void	FindRow			(LONG *pcpMin, LONG *pcpMost, LONG Level = -1) const;
    void    FindSentence	(LONG *pcpMin, LONG *pcpMost) const;
	BOOL	FindVisibleRange(LONG *pcpMin, LONG *pcpMost) const;
    void    FindWord		(LONG *pcpMin, LONG *pcpMost, 
								FINDWORD_TYPE type)const;
	LONG	CountCells		(LONG &cCell, LONG cchMax);

	LONG	AdvanceCRLF(CSCONTROL csc, BOOL fExtend);
	LONG	BackupCRLF (CSCONTROL csc, BOOL fExtend);
	BOOL	AdjustCRLF (LONG iDir);
	LONG    FindWordBreak(INT action,  BOOL fExtend);

	BOOL	CheckTableSelection(BOOL fUpdate, BOOL fEnableExpandCell,
								BOOL *pfTRDsInvolved, DWORD dwFlags);
	BOOL	CheckLinkProtection(DWORD &dwFlags,	LONG &iFormat);

	void	SetUseiFormat(BOOL fUseiFormat) {_fUseiFormat = fUseiFormat;}

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

    // ITextRange methods
    STDMETHODIMP GetText (BSTR *pbstr);
    STDMETHODIMP SetText (BSTR bstr);
    STDMETHODIMP GetChar (long *pch);
    STDMETHODIMP SetChar (long ch);
    STDMETHODIMP GetDuplicate (ITextRange **ppRange);
    STDMETHODIMP GetFormattedText (ITextRange **ppRange);
    STDMETHODIMP SetFormattedText (ITextRange *pRange);
    STDMETHODIMP GetStart (long *pcpFirst);
    STDMETHODIMP SetStart (long cpFirst);
    STDMETHODIMP GetEnd (long *pcpLim);
    STDMETHODIMP SetEnd (long cpLim);
    STDMETHODIMP GetFont (ITextFont **pFont);
    STDMETHODIMP SetFont (ITextFont *pFont);
    STDMETHODIMP GetPara (ITextPara **pPara);
    STDMETHODIMP SetPara (ITextPara *pPara);
    STDMETHODIMP GetStoryLength (long *pcch);
    STDMETHODIMP GetStoryType (long *pValue);
    STDMETHODIMP Collapse (long bStart);
    STDMETHODIMP Expand (long Unit, long *pDelta);
    STDMETHODIMP GetIndex (long Unit, long *pIndex);
    STDMETHODIMP SetIndex (long Unit, long Index, long Extend);
    STDMETHODIMP SetRange (long cpActive, long cpOther);
    STDMETHODIMP InRange (ITextRange * pRange, long *pb);
    STDMETHODIMP InStory (ITextRange * pRange, long *pb);
    STDMETHODIMP IsEqual (ITextRange * pRange, long *pb);
    STDMETHODIMP Select ();
    STDMETHODIMP StartOf (long Unit, long Extend, long * pDelta);
    STDMETHODIMP EndOf (long Unit, long Extend, long * pDelta);
    STDMETHODIMP Move (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveStart (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveEnd (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveStartWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveEndWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveUntil (VARIANT FAR* Cset, long Count, long * pDelta);
    STDMETHODIMP MoveStartUntil (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveEndUntil (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP FindText (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP FindTextStart (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP FindTextEnd (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP Delete (long Unit, long Count, long * pDelta);
    STDMETHODIMP Cut (VARIANT * ppIDataObject);
    STDMETHODIMP Copy (VARIANT * ppIDataObject);
    STDMETHODIMP Paste (VARIANT * pIDataObject, long Format);
    STDMETHODIMP CanPaste (VARIANT * pIDataObject, long Format, long * pb);
    STDMETHODIMP CanEdit (long * pbCanEdit);
    STDMETHODIMP ChangeCase (long Type);
    STDMETHODIMP GetPoint (long Type, long * px, long * py);
    STDMETHODIMP SetPoint (long x, long y, long Type, long Extend);
    STDMETHODIMP ScrollIntoView (long Value);
    STDMETHODIMP GetEmbeddedObject (IUnknown ** ppv);


    // ITextSelection methods
    STDMETHODIMP GetFlags (long * pFlags) ;
    STDMETHODIMP SetFlags (long Flags) ;
    STDMETHODIMP GetType  (long * pType) ;
	STDMETHODIMP MoveLeft (long Unit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveRight(long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveUp   (long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveDown (long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP HomeKey  (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP EndKey   (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP TypeText (BSTR bstr) ;


//@access Private ITextRange helper methods
private:
	void	RangeValidateCp (LONG cp, LONG cch);
	LONG	Comparer (ITextRange * pv);
	LONG	SpanSubstring (CUniscribe* pusp, CFormatRunPtr* pcrp, WCHAR* pwchString, 
						LONG cchString, WORD& uSubStrLevel, DWORD dwInFlags, CCharFlags* pCharflags,
						WORD& wBiDiLangId);
	HRESULT EndSetter(LONG cp, BOOL fOther);
	HRESULT Finder	 (BSTR bstr, long Count, long Flags, LONG *pDelta,
						MOVES Mode);
	HRESULT GetLong  (LONG lValue, long *pLong);
	HRESULT	IsTrue	 (BOOL f, long *pB);
	HRESULT Matcher	 (VARIANT *Cset, long Count, LONG *pDelta, MOVES Mode,
						MATCHES Match);
	HRESULT	Mover	 (long Unit, long Count, LONG *pDelta, MOVES Mode);
	HRESULT	Replacer (LONG cchNew, TCHAR const *pch, DWORD dwFlags = 0);

	LONG	CalcTextLenNotInRange();
};



// Useful Unicode range definitions for use with MoveWhile/Until methods

#define	CodeRange(n, m)	0x8000000 | ((m) - (n)) << 16 | n

#define	CR_ASCII		CodeRange(0x0, 0x7f)
#define	CR_ANSI			CodeRange(0x0, 0xff)
#define	CR_ASCIIPrint	CodeRange(0x20, 0x7e)
#define	CR_Latin1		CodeRange(0x20, 0xff)
#define	CR_Latin1Supp	CodeRange(0xa0, 0xff)
#define	CR_LatinXA		CodeRange(0x100, 0x17f)
#define	CR_LatinXB		CodeRange(0x180, 0x24f)
#define	CR_IPAX			CodeRange(0x250, 0x2af)
#define	CR_SpaceMod		CodeRange(0x2b0, 0x2ff)
#define	CR_Combining	CodeRange(0x300, 0x36f)
#define	CR_Greek		CodeRange(0x370, 0x3ff)
#define	CR_BasicGreek	CodeRange(0x370, 0x3cf)
#define	CR_GreekSymbols	CodeRange(0x3d0, 0x3ff)
#define	CR_Cyrillic		CodeRange(0x400, 0x4ff)
#define	CR_Armenian		CodeRange(0x530, 0x58f)
#define	CR_Hebrew		CodeRange(0x590, 0x5ff)
#define	CR_BasicHebrew	CodeRange(0x5d0, 0x5ea)
#define	CR_HebrewXA		CodeRange(0x590, 0x5cf)
#define	CR_HebrewXB		CodeRange(0x5eb, 0x5ff)
#define	CR_Arabic		CodeRange(0x600, 0x6ff)
#define	CR_BasicArabic	CodeRange(0x600, 0x652)
#define	CR_ArabicX		CodeRange(0x653, 0x6ff)
#define	CR_Devengari	CodeRange(0x900, 0x97f)
#define	CR_Bengali		CodeRange(0x980, 0x9ff)
#define	CR_Gurmukhi		CodeRange(0xa00, 0xa7f)
#define	CR_Gujarati		CodeRange(0xa80, 0xaff)
#define	CR_Oriya		CodeRange(0xb00, 0xb7f)
#define	CR_Tamil		CodeRange(0xb80, 0xbff)
#define	CR_Teluga		CodeRange(0xc00, 0xc7f)
#define	CR_Kannada		CodeRange(0xc80, 0xcff)
#define	CR_Malayalam	CodeRange(0xd00, 0xd7f)
#define	CR_Thai 		CodeRange(0xe00, 0xe7f)
#define	CR_Lao  		CodeRange(0xe80, 0xeff)
#define	CR_GeorgianX	CodeRange(0x10a0, 0xa0cf)
#define	CR_BascGeorgian	CodeRange(0x10d0, 0x10ff)
#define	CR_Hanguljamo	CodeRange(0x1100, 0x11ff)
#define	CR_LatinXAdd	CodeRange(0x1e00, 0x1eff)
#define	CR_GreekX		CodeRange(0x1f00, 0x1fff)
#define	CR_GenPunct		CodeRange(0x2000, 0x206f)
#define	CR_SuperScript	CodeRange(0x2070, 0x207f)
#define	CR_SubScript	CodeRange(0x2080, 0x208f)
#define	CR_SubSuperScrp	CodeRange(0x2070, 0x209f)
#define	CR_Currency		CodeRange(0x20a0, 0x20cf)
#define	CR_CombMarkSym	CodeRange(0x20d0, 0x20ff)
#define	CR_LetterLike	CodeRange(0x2100, 0x214f)
#define	CR_NumberForms	CodeRange(0x2150, 0x218f)
#define	CR_Arrows		CodeRange(0x2190, 0x21ff)
#define	CR_MathOps		CodeRange(0x2200, 0x22ff)
#define	CR_MiscTech		CodeRange(0x2300, 0x23ff)
#define	CR_CtrlPictures	CodeRange(0x2400, 0x243f)
#define	CR_OptCharRecog	CodeRange(0x2440, 0x245f)
#define	CR_EnclAlphaNum	CodeRange(0x2460, 0x24ff)
#define	CR_BoxDrawing	CodeRange(0x2500, 0x257f)
#define	CR_BlockElement	CodeRange(0x2580, 0x259f)
#define	CR_GeometShapes	CodeRange(0x25a0, 0x25ff)
#define	CR_MiscSymbols	CodeRange(0x2600, 0x26ff)
#define	CR_Dingbats		CodeRange(0x2700, 0x27bf)
#define	CR_CJKSymPunct	CodeRange(0x3000, 0x303f)
#define	CR_Hiragana		CodeRange(0x3040, 0x309f)
#define	CR_Katakana		CodeRange(0x30a0, 0x30ff)
#define	CR_Bopomofo		CodeRange(0x3100, 0x312f)
#define	CR_HangulJamo	CodeRange(0x3130, 0x318f)
#define	CR_CJLMisc		CodeRange(0x3190, 0x319f)
#define	CR_EnclCJK		CodeRange(0x3200, 0x32ff)
#define	CR_CJKCompatibl	CodeRange(0x3300, 0x33ff)
#define	CR_Hangul		CodeRange(0x3400, 0x3d2d)
#define	CR_HangulA		CodeRange(0x3d2e, 0x44b7)
#define	CR_HangulB		CodeRange(0x44b8, 0x4dff)
#define	CR_CJKIdeograph	CodeRange(0x4e00, 0x9fff)
#define	CR_PrivateUse	CodeRange(0xe000, 0xf800)
#define	CR_CJKCompIdeog	CodeRange(0xf900, 0xfaff)
#define	CR_AlphaPres	CodeRange(0xfb00, 0xfb4f)
#define	CR_ArabicPresA	CodeRange(0xfb50, 0xfdff)
#define	CR_CombHalfMark	CodeRange(0xfe20, 0xfe2f)
#define	CR_CJKCompForm	CodeRange(0xfe30, 0xfe4f)
#define	CR_SmallFormVar	CodeRange(0xfe50, 0xfe6f)
#define	CR_ArabicPresB	CodeRange(0xfe70, 0xfefe)
#define	CR_HalfFullForm	CodeRange(0xff00, 0xffef)
#define	CR_Specials		CodeRange(0xfff0, 0xfffd)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_objmgr.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _objmgr.h   Class declaration for the object manager class |
 *
 *  Author: alexgo 11/4/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#ifndef __OBJMGR_H__
#define __OBJMGR_H__

#include "_coleobj.h"
#include "_array.h"
#include "_m_undo.h"

class CTxtEdit;
class CTxtRange;

/*
 *	@enum	return values for HandleClick
 */	
enum ClickStatus
{
	CLICK_IGNORED			= 0,
	CLICK_OBJDEACTIVATED	= 1,
	CLICK_SHOULDDRAG		= 2,
	CLICK_OBJSELECTED		= 3
};

typedef CArray<COleObject *> ObjectArray;

/*
 *	CObjectMgr
 *
 *	@class	keeps track of a collection of OLE embedded objects as well as
 *			various state tidbits
 */
class CObjectMgr
{
public:
	LONG			GetObjectCount(); 			//@cmember count # of objects 
	LONG			GetLinkCount();				//@cmember count # of links
	COleObject *	GetObjectFromCp(LONG cp);	//@cmember fetch object ptr
	COleObject *	GetObjectFromIndex(LONG index); //@cmember fetch obj ptr
												//@cmember insert object
	HRESULT			InsertObject(CTxtRange *prg, REOBJECT *preobj, 
						IUndoBuilder *publdr);
												//@cmember re-inserts the given
												// object
	HRESULT			RestoreObject(COleObject *pobj);

	IRichEditOleCallback *GetRECallback()		//@cmember return the callback
					{return _precall;}
												//@cmember set the OLE callback
	void			SetRECallback(IRichEditOleCallback *precall);			
												//@cmember sets a temporary flag
												// indicating whether or not
												// a UI update is pending.
	void			SetShowUIPending(BOOL fPending)
												{_fShowUIPending = fPending;}

	BOOL			GetShowUIPending()			//@cmember get _fShowUIPending
												{return _fShowUIPending;}
										   		//@cmember sets the inplace
												// active object
	void			SetInPlaceActiveObject(COleObject *pobj)
												{ _pobjactive = pobj; }
	COleObject *	GetInPlaceActiveObject()	//@cmember get the active obj
												{ return _pobjactive; }
	BOOL			GetHelpMode()				//@cmember in help mode?
												{ return _fInHelpMode; }
	void			SetHelpMode(BOOL fHelp)		//@cmember set the help mode
												{ _fInHelpMode = fHelp; }
												//@cmember Set the host names
	HRESULT			SetHostNames(LPWSTR pszApp, LPWSTR pszDoc);
	LPWSTR			GetAppName()				//@cmember get the app name
												{ return _pszApp; }
	LPWSTR			GetDocName()				//@cmember get the doc name
												{ return _pszDoc; }
												//@cmember activate an object
												//if appropriate
	BOOL			HandleDoubleClick(CTxtEdit *ped, const POINTUV &pt, DWORD flags);
												//@cmember an object may be
												// selected or de-activated.
	ClickStatus		HandleClick(CTxtEdit *ped, const POINTUV &pt);
												//@cmember an object may be
												// selected or deselected.
	void			HandleSingleSelect(CTxtEdit *ped, LONG cp, BOOL fHiLite);
												//@cmember an object is
												// being selected by itself.
	COleObject *	GetSingleSelect(void)		{return _pobjselect;}
												//@cmember Count cObject
	LONG			CountObjects(LONG& rcObject,// objects up to cchMax
						LONG cp);				// chars away

												//@cmember Handles the deletion
												// of objects.
	void			ReplaceRange(LONG cp, LONG cchDel,
						IUndoBuilder *publdr);
												//@cmember Count the number
												//of objects in a range.
	LONG			CountObjectsInRange(LONG cpMin, LONG cpMost);
												//@cmember Get the first
												//object in a range.
	COleObject *	GetFirstObjectInRange(LONG cpMin, LONG cpMost);
								//@cmember activate objects of one class as
								//as another
	HRESULT ActivateObjectsAs(REFCLSID rclsid, REFCLSID rclsidAs);

	LONG FindIndexForCp(LONG cp);	//@cmember does a binary search for cp
									//@cmember find an object near a point

#ifdef DEBUG
	void			DbgDump(void);
#endif

	CObjectMgr();								//@cmember constructor
	~CObjectMgr();								//@cmember destructor

private:
	ObjectArray		_objarray;		//@cmember	Array of embedded objects
	LONG			_lastindex;		//@cmember	Last index used 
									// (lookup optimization)
	IRichEditOleCallback *_precall;	//@cmember	Callback for various OLE 
									// operations.
	COleObject *	_pobjactive;	//@cmember	Object that is currently
									// inplace active 
	COleObject *	_pobjselect;	//@cmember	Object that is currently
									// individually selected (not active)
	LPWSTR		_pszApp;			//@cmember 	Name of app
	LPWSTR		_pszDoc;			//@cmember 	Name of "document"

	unsigned int	_fShowUIPending:1;//@cmember a UI update is pending
	unsigned int	_fInHelpMode:1;	//@cmember in context sensitive help mode?
};

#endif  //__OBJMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_rtflog.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFLOG.H -- RichEdit RTF Log Class Definition |
 *
 *		This file contains the class declarations for an RTF log class
 *		which can be used to track the hit counts of RTF tags encountered
 *		by the RTF reader
 *
 *	Authors:<nl>
 *		Created for RichEdit 2.0:	Brad Olenick 
 *
 *	Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFLOG_H
#define __RTFLOG_H

#include "tokens.h"	

extern INT cKeywords;

class CRTFLog
{
public:
	typedef size_t INDEX;
	typedef INDEX *PINDEX;
	typedef DWORD ELEMENT;
	typedef ELEMENT *PELEMENT;

	CRTFLog();				//@cmember CRTFLog constructor
	inline ~CRTFLog();		//@cmember CRTFLog destructor

	BOOL FInit() const 
		{ return _rgdwHits ? TRUE : FALSE; }	//@cmember Determines whether object is init'd

	INDEX ISize() const 
		{ return cKeywords; }			//@cmember Number of elements in log

	inline BOOL AddAt(INDEX i);					//@cmember Increment hit count for element at index i
	inline BOOL AddAt(LPCSTR lpcstrKeyword);	//@cmember Increment hit count for RTF keyword 	
	inline BOOL AddAt(TOKEN token);				//@cmember Increment hit count for RTF token

	inline ELEMENT GetAt(INDEX i) const
		{ return (*this)[i]; }											//@cmember Get hit count for element i
	inline BOOL GetAt(LPCSTR lpcstrKeyword, PELEMENT pelemCount) const;	//@cmember Get hit count for RTF keyword
	inline BOOL GetAt(TOKEN token, PELEMENT pelemCount) const;			//@cmember Get hit count for RTF token

	void Reset();						//@cmember Reset all hit count values to 0

	UINT UGetWindowMsg() const;			//@cmember Get window msg ID used for log change notifications

private:
	// we manage all updates through AddAt to 
	// facilitate change notifications
	ELEMENT &operator[](INDEX);				//@cmember Access element i for l-value
	const ELEMENT &operator[](INDEX) const;	//@cmember Access element i for r-value

	LPCSTR LpcstrLogFilename() const;	//@cmember Get name of log filename

	BOOL IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX pi) const;	//@cmember Get log index for keyword
	BOOL IIndexOfToken(TOKEN token, PINDEX pi) const;				//@cmember Get log index for token

	void ChangeNotify(INDEX i) const
		{ 
			PostMessage(HWND_BROADCAST, UGetWindowMsg(), i, 0);
		}	//@cmember Notify clients of change to element i
	void ChangeNotifyAll() const 
		{ ChangeNotify(ISize() + 1); }						//@cmember Notify clients of log refresh

	HANDLE _hfm;		//@cmember Handle to file mapping
	HANDLE _hfile;		//@cmember Handle to file behind file mapping
	PELEMENT _rgdwHits;	//@cmember Handle to view of file mapping
	UINT _uMsg;			//@cmember Window msg ID for change notifications
};


/*
 *	CRTFLog::~CRTFLog
 *	
 *	@mfunc
 *		Destructor - cleans up memory-mapped file and underlying resources
 *
 */
inline CRTFLog::~CRTFLog()
{
	if(_rgdwHits)
	{
		UnmapViewOfFile(_rgdwHits);
	}

	if(_hfm)
	{
		CloseHandle(_hfm);
	}

	if(_hfile)
	{
		CloseHandle(_hfile);
	}
}


/*
 *	CRTFLog::AddAt(INDEX i)
 *	
 *	@mfunc
 *		Increments the hit count for log element, i, and
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(INDEX i)
{
	(*this)[i]++;

	// change notification
	ChangeNotify(i);

	return TRUE;
}


/*
 *	CRTFLog::AddAt(LPCSTR lpcstrKeyword)
 *	
 *	@mfunc
 *		Increments the hit count for log element corresponding
 *		to the RTF keyword, lpcstrKeyword, and 
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(LPCSTR lpcstrKeyword)
{
	INDEX i;

	if(!IIndexOfKeyword(lpcstrKeyword, &i))
	{
		return FALSE;
	}

	return AddAt(i);
}


/*
 *	CRTFLog::AddAt(TOKEN token)
 *	
 *	@mfunc
 *		Increments the hit count for log element corresponding
 *		to the RTF token, token, and 
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(TOKEN token)
{
	INDEX i;

	if(!IIndexOfToken(token, &i))
	{
		return FALSE;
	}

	return AddAt((INDEX)i);
}


/*
 *	CRTFLog::GetAt(LPCSTR lpcstKeyword, PELEMENT pelemCount)
 *	
 *	@mfunc
 *		Gets the hit count for log element corresponding to the
 *		RTF keyword, lpcstrKeywor
 *
 *	@rdesc
 *		BOOL		indicates whether a hit count was found for the element
 */
inline BOOL CRTFLog::GetAt(LPCSTR lpcstrKeyword, PELEMENT pelemCount) const
{
	INDEX i;
	
	if(!IIndexOfKeyword(lpcstrKeyword, &i))
	{
		return FALSE;
	}

	if(pelemCount)
	{
		*pelemCount = (*this)[i];
	}

	return TRUE;
}
	

/*
 *	CRTFLog::GetAt(LPCSTR lpcstKeyword, PELEMENT pelemCount)
 *	
 *	@mfunc
 *		Gets the hit count for log element corresponding to the
 *		RTF token, token
 *
 *	@rdesc
 *		BOOL		indicates whether a hit count was found for the element
 */
inline BOOL CRTFLog::GetAt(TOKEN token, PELEMENT pelemCount) const
{
	INDEX i;
	
	if(!IIndexOfToken(token, &i))
	{
		return FALSE;
	}

	if(pelemCount)
	{
		*pelemCount = (*this)[i];
	}

	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_ols.h ===
/*
 *  _OLS.H
 *  
 *  Purpose:
 *		COls Line Services object class used to connect RichEdit with
 *		Line Services.
 *  
 *  Authors:
 *		Original RichEdit LineServices code: Rick Sailor
 *		Murray Sargent
 *
 *	Copyright (c) 1997-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _OLS_H
#define _OLS_H

#include "_common.h"
#include "_cfpf.h"
#ifndef NOCOMPLEXSCRIPTS
#include "usp10.h"
#endif

#define CP_BULLET			0x80000000

// ===============================  CLsrun =====================================
// CLsrun - LineServices run structure
struct CLsrun
{
	LONG				_cp;	// the starting cp of the run
	const CCharFormat*	_pCF;	// pointer to the character formatting
	struct CLsrun*		_pNext;	// next linked (shaped together) run
#ifndef NOCOMPLEXSCRIPTS
	SCRIPT_ANALYSIS		_a;		// run's analysis (will be 0 if non-complex script)
#endif
private:
	BYTE		_fSelected:1;	// Is this run selected?
	BYTE		_fFallback:1;	// Is font fallback applied?
public:
	void	SetSelected(BOOL fSelected) {_fSelected = fSelected;}
	BOOL	IsSelected();
	BOOL	IsBullet() {return _cp & CP_BULLET;}
	void	SetFallback(BOOL fFallback) {_fFallback = fFallback;}
	BOOL	IsFallback() {return _fFallback;}
};

// ===============================  CLsrunChunk =====================================
// CLsrunChunk - Manages a chunk of PLSRUNs
class CLsrunChunk
{
public:
	PLSRUN _prglsrun;
	int		_cel;
};

// ===============================  COls  =====================================
// COls - LineServices object class

class CTxtEdit;
class CMeasurer;
class CDispDim;

struct COls
{
public:
	CMeasurer *_pme;				// Active CMeasurer or CRenderer
	PLSLINE	   _plsline;			// Line cache
	LONG	   _cp;					// cpMin for _plsline
	const CDisplay *_pdp;			// Current Display object, used to determine if display
									// object changed without receiving focus messages
	CArray<long> _rgcp;				// Array for CP mapping
	CArray<CLsrunChunk> _rglsrunChunk;	// Array of ClsrunChunks


	// Note: might be better to alloc the following only if needed
	LSTBD _rgTab[MAX_TAB_STOPS];	// Buffer used by pfnFetchTabs
	WCHAR _szAnm[CCHMAXNUMTOSTR + 4];//numbering + braces + space + end character
	WCHAR _rgchTemp[64];			// Temporary buffer for passwords and allcaps, etc.
	int			_cchAnm;			// cch in use
	CCharFormat _CFBullet;			// Character formatting for anm run
	LONG		_cEmit;				// Brace emitting protection (0 - balance)

	COls() {}
	~COls();

	//CP matching, reverser brace support
	LONG GetCpLsFromCpRe(LONG cpRe);
	LONG GetCpReFromCpLs(LONG cpLs);
	LONG BracesBeforeCp(LONG cpLs);
	BOOL AddBraceCp(LONG cpLs);

	PLSRUN CreatePlsrun(void);

	void QueryLineInfo(LSLINFO &lslinfo, LONG *pupStart, LONG *pdupWidth);
	BOOL SetLsChp(DWORD dwObjId, PLSRUN plsrun, PLSCHP plschp);
	BOOL SetRun(PLSRUN plsrun);
	PLSRUN GetPlsrun(LONG cp, const CCharFormat *pCF, BOOL fAutoNumber);
	LSERR WINAPI FetchAnmRun(long cp, LPCWSTR *plpwchRun, DWORD *pcchRun,
							 BOOL *pfHidden, PLSCHP plsChp, PLSRUN *pplsrun);
	void	CchFromUp(POINTUV pt, CDispDim *pdispdim, LONG *pcpActual);
	void	CreateOrGetLine();
	void	DestroyLine(CDisplay *pdp);
	HRESULT	Init(CMeasurer *pme); 
	BOOL	MeasureLine(CLine *pliTarget);
	LONG	MeasureText(LONG cch, UINT taMode, CDispDim *pdispdim);
	BOOL	RenderLine(CLine &li, BOOL fLastLine);
	CMeasurer * GetMeasurer() {return _pme;}
	CRenderer * GetRenderer() {return (CRenderer*) _pme;}

};

extern COls* g_pols;
extern const LSIMETHODS vlsimethodsOle;
extern CLineServices *g_plsc;		// LineServices Context

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_render.h ===
/*
 *	_RENDER.H
 *	
 *	Purpose:
 *		CRenderer class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _RENDER_H
#define _RENDER_H

#include "_measure.h"
#include "_rtext.h"
#include "_osdc.h"


BOOL IsTooSimilar(COLORREF cr1, COLORREF cr2);

class CDisplay;

// ==========================  CRenderer  ==================================
// CRenderer - specialized text pointer used for rendering text

class CRenderer : public CMeasurer
{
	friend struct COls;
	friend struct CLsrun;
#ifndef NOLINESERVICES
	friend LSERR OlsDrawGlyphs(POLS,PLSRUN,BOOL,BOOL,PCGINDEX,const int*,const int*,PGOFFSET,PGPROP,
		PCEXPTYPE,DWORD,LSTFLOW,UINT,const POINT*,PCHEIGHTS,long,long,const RECT*);
	friend LSERR WINAPI OlsOleDisplay(PDOBJ pdobj, PCDISPIN pcdispin);
	friend LSERR WINAPI OlsDrawTextRun(POLS, PLSRUN, BOOL, BOOL, const POINT *,LPCWSTR, const int *,DWORD,LSTFLOW,
	UINT, const POINT *, PCHEIGHTS,	long, long,	const RECT *);
#endif

private:
    RECTUV		_rcView;			// View rect (_hdc logical coords)
    RECTUV		_rcRender;			// Rendered rect (_hdc logical coords)
    RECTUV		_rc;				// Running clip/erase rect (_hdc logical coords)
	RECTUV		_rcErase;			// Rectangle to use for erasing iff _fEraseOnFirstDraw
    LONG        _dupLine;			// Total width of line REVIEW (keithcu) still needed
	LONG		_cpAccelerator;		// Accelerator cp if any (-1 if none).

	COLORREF	_crBackground;		// Default background color
	COLORREF	_crForeDisabled;	// Foreground color for disabled text
	COLORREF	_crShadowDisabled;	// Shadow color for disabled text
	COLORREF	_crTextColor;		// Default text color

	COLORREF	_crCurBackground;	// Current background color
	COLORREF	_crCurTextColor;	// Current text color

	COffscreenDC _osdc;				// Manager for offscreen DC
	HDC			_hdc;				// Current hdc
	HDC			_hdcBitmap;			// Memory hdc for background BitBlts
	HBITMAP		_hbitmapSave;		// Saved hbitmap when _hdcMem being used
	SHORT		_dxBitmap;			// Background bitmap width
	SHORT		_dyBitmap;			// Background bitmap height

	union
	{
	  DWORD		_dwFlags;			// All together now
	  struct
	  {
		DWORD	_fDisabled:1;		// Draw text with disabled effects?
		DWORD	_fErase:1;	    	// Erase background (non transparent)
    	DWORD	_fSelected:1;   	// Render run with selection colors
		DWORD	_fLastChunk:1;		// Rendering last chunk
		DWORD	_fSelectToEOL:1;	// Whether selection runs to end of line
		DWORD	_fRenderSelection:1;// Render selection?
		DWORD	_fBackgroundColor:1;// Some text in the line has non-default 
									// background color.
		DWORD	_fEnhancedMetafileDC:1;	// Use ExtTextOutA to hack around all
										// sort of Win95FE EMF or font problems
		DWORD	_fFEFontOnNonFEWin9x:1; // have to use ExtTextOutW even for EMF.
		DWORD	_fSelectedPrev:1;	// TRUE if prev run selected
		DWORD	_fStrikeOut:1;		// TRUE if current run is struckout
		DWORD	_fEraseOnFirstDraw:1;//Draw opaquely for first run?
		DWORD	_fDisplayDC:1;		// Display dc
	  };
	};

	LOGPALETTE *_plogpalette;
	POINTUV	 	_ptCur;				// Current rendering position on screen
	BYTE		_bUnderlineType;	// Underline type
	COLORREF	_crUnderlineClr;	// Underline color

			void	Init();			// Initialize most members to zero

			void	UpdatePalette(COleObject *pobj);

			void	RenderText(const WCHAR* pch, LONG cch);

			BOOL	SetNewFont();
			BOOL	FindDrawEntry(LONG cp);

	//Rotation wrappers;
			void	EraseTextOut(HDC hdc, const RECTUV *prc, BOOL fSimple = FALSE);
		
			BOOL 	RenderChunk(LONG &cchChunk, const WCHAR *pchRender, LONG cch);
			LONG	RenderTabs(LONG cchChunk);
			BOOL	RenderBullet();

public:
	CRenderer (const CDisplay * const pdp);
	CRenderer (const CDisplay * const pdp, const CRchTxtPtr &rtp);
	~CRenderer ();

	        void    operator =(const CLine& li)     {*(CLine*)this = li;}

			BOOL	IsSimpleBackground() const;
			void	RenderExtTextOut(POINTUV ptuv, UINT fuOptions, RECT *prc, PCWSTR pch, UINT cch, const INT *rgdxp);

			BOOL	EraseRect(const RECTUV *prc, COLORREF crBack);
			void	EraseLine();

			COLORREF GetDefaultBackColor() const	{return _crBackground;}
			COLORREF GetDefaultTextColor() const	{return _crTextColor;}
			COLORREF GetTextColor(const CCharFormat *pCF);
			void	SetDefaultBackColor(COLORREF cr);
			void	SetDefaultTextColor(COLORREF cr);
			void	SetTextColor(COLORREF cr);
			void	SetSelected(BOOL f)				{_fSelected = f;}
			void	SetErase(BOOL f)				{_fErase = f;}

	const	POINTUV& GetCurPoint() const			{return _ptCur;}
			void	SetCurPoint(const POINTUV &pt)	{_ptCur = pt;}
			void	SetRcView(const RECTUV *prcView){_rcView = *prcView; _rcRender = *prcView;}
			void	SetRcViewTop(LONG top)			{_rcView.top = top;}
			void	SetRcBottoms(LONG botv, LONG botr)	{_rcView.bottom = botv; _rcRender.bottom = botr;}
	const	RECTUV&	GetRcRender()					{return _rcRender;}
	const	RECTUV&	GetRcView()						{return _rcView;}

	const	RECTUV&	GetClipRect() const				{return _rc;}
			void	SetClipRect(void);
            void    SetClipLeftRight(LONG dup);
			HDC		GetDC()	const					{return _hdc;}

			BOOL	StartRender(const RECTUV &rcView, const RECTUV &rcRender);

			LONG	DrawTableBorders(const CParaFormat *pPF, LONG x, LONG yHeightRow, 
									 LONG iDrawBottomLine, LONG dulRow,
									 const CParaFormat *pPFAbove);
			COLORREF GetColorFromIndex(LONG icr, BOOL fForeColor,
									   const CParaFormat *pPF) const;
			COLORREF GetShadedColorFromIndices(LONG icrf, LONG icrb, LONG iShading,					//@parm Shading in .01 percent
									   const CParaFormat *pPF) const;
			void	DrawWrappedObjects(CLine *pliFirst, CLine *pliLast, LONG cpFirst, const POINTUV &ptFirst);
			void	EndRender(CLine *pliFirst, CLine *pliLast, LONG cpFirst, const POINTUV &ptFirst);
			void	FillRectWithColor(const RECTUV *prc, COLORREF cr);
			void 	NewLine (const CLine &li);
			BOOL	RenderLine(CLine &li, BOOL fLastLine);
			void	RenderOffscreenBitmap(HDC hdc, LONG dup, LONG dvp);
			BOOL	RenderOutlineSymbol();
			HDC		StartLine(CLine &li, BOOL fLastLine, LONG &cpSelMin, LONG &cpSelMost, LONG &dup, LONG &dvp);
			void	EraseToBottom();
			void	EndLine(HDC hdcSave, LONG dup, LONG dvp);
			void	RenderStrikeOut(LONG upStart, LONG vpStart, LONG dup, LONG dvp);
			void	RenderUnderline(LONG upStart, LONG vpStart, LONG dup, LONG dvp);
			void	DrawLine(const POINTUV &ptStart, const POINTUV &ptEnd);
			void	SetFontAndColor(const CCharFormat *pCF);
			HDC		SetupOffscreenDC(LONG& dup, LONG& dvp, BOOL fLastLine);
			void	SetupUnderline(BYTE bULType, BYTE bULColorIdx, COLORREF crULColor = tomAutoColor);
			CONVERTMODE	GetConvertMode();
			BOOL	fFEFontOnNonFEWin9x()			{return _fFEFontOnNonFEWin9x;}
			BOOL	UseXOR(COLORREF cr);
			BOOL	fDisplayDC() { return _fDisplayDC; }
};

/*
 * 	BottomOfRender (rcView, rcRender)
 *
 *	@mfunc
 *		Calculate maximum logical unit to render.
 *
 *	@rdesc
 *		Maximum pixel to render
 *
 *	@devnote
 *		This function exists to allow the renderer and dispml to be able
 *		to calculate the maximum pixel for rendering in exactly the same
 *		way.
 */
inline LONG BottomOfRender(const RECTUV& rcView, const RECTUV& rcRender)
{
	return min(rcView.bottom, rcRender.bottom);
}		

class CBrush
{
	COLORREF	_cr;		// Current color
	HBRUSH		_hbrushOld;	// HBRUSH when CBrush is created
	HBRUSH		_hbrush;	// Current HBRUSH
	CRenderer *	_pre;		// Renderer to use (for rotation)

public:
	CBrush(CRenderer *pre) {_pre = pre; _hbrush = 0;} 
	~CBrush();

	void	Draw(LONG u1, LONG v1, LONG u2, LONG v2, LONG dxpLine,
				 COLORREF cr, BOOL fHideGridlines);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_rtfread.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFREAD.H -- RichEdit RTF Reader Class Definition |
 *
 *		This file contains the type declarations used by the RTF reader
 *		for the RICHEDIT control
 *
 *	Authors:<nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFREAD_H
#define __RTFREAD_H

#include "_rtfconv.h"

#if defined(DEBUG)
#include "_rtflog.h"
#endif

typedef SHORT	ALIGN;

/*
 *		Destinations of the stuff we may read in while parsing
 */
enum
{
	destRTF,
	destColorTable,
	destFontTable,
	destObject,
	destObjectClass,
	destObjectName,
	destObjectData,			// Keep next 2 together
	destPicture,			// Keep next 3 together
	destField,
	destFieldResult,
	destFieldInstruction,
	destParaNumbering,
	destParaNumText,
	destRealFontName,
	destFollowingPunct,
	destLeadingPunct,
	destDocumentArea,
	destNULL,
	destStyleSheet,
	destShapeName,
	destShapeValue,
	destNestTableProps,
	destMAX					// This must be last entry
};


/*
 *		Super or subscripting state
 */
enum
{
	sSub = -1,
	sNoSuperSub,
	sSuper
};

enum DEFAULTFONT
{
	DEFFONT_NOCH = 0,
	DEFFONT_LTRCH,
	DEFFONT_RTLCH,
	DEFFONT_LOCH,
	DEFFONT_HICH,
	DEFFONT_DBCH
};

typedef struct tagDefFont
{
	SHORT sHandle;
	SHORT sSize;
} DEFFONT;

/*
 *	@struct STATE | 
 *		Structure to save current reader state
 */
struct STATE
{
	WORD		cbSkipForUnicodeMax;	//@field Bytes to skip after \uN is read
	SHORT		iCF;					//@field CF index at LBRACE

	// Miscellaneous flags
	unsigned	fBullet			 : 1;	//@field group is a \\pn bullet group
	unsigned	fRealFontName	 : 1;	//@field found a real font name when parsing
	unsigned	fBackground		 : 1;	//@field background being processed
	unsigned	fShape			 : 1;	//@field {\shp...} being processed

	// BiDi flags
	unsigned	fRightToLeftPara : 1;	//@field Para text going right to left ?
	unsigned	fZeroWidthJoiner : 1;	//@field Zero Width Joiner ?

	// xchg 12370: keep numbering indent separate
	SHORT		sIndentNumbering;		//@field numbering indent
	SHORT		sDest;					//@field Current destination
	int			nCodePage;				//@field Current code page


	// Scratch pad variables
	TEXTFONT *	ptf;					//@field Ptr to font table entry to fill
	BYTE		bRed;					//@field Color table red entry
	BYTE		bGreen;					//@field Color table green entry
	BYTE		bBlue;					//@field Color table blue entry
	char		iDefFont;				//@field Default font (\dbch, \rtlch, etc.)
	STATE * 	pstateNext;				//@field Next state on stack
	STATE * 	pstatePrev;				//@field Previous state on stack

	CParaFormat *pPF;					//@field PF for the state to which 
										//	delta's are applied
	DWORD		dwMaskPF;
	DWORD		dwMaskPF2;

	DEFFONT		rgDefFont[6];			//@cmember Default fonts for \dbch, etc.

	STATE() {};
										//@cmember Adds or applies PF to state's PF
	BOOL AddPF(const CParaFormat &PF,
				LONG lDocType, DWORD dwMask, DWORD dwMask2);
	void DeletePF();					//@cmember Deletes PF for state
	void SetCodePage(LONG CodePage);
};

typedef struct TableState
{
	BYTE	_cCell;
	BYTE	_iCell;
} TABLESTATE;

class CRTFRead ;
class COleObject;


class RTFREADOLESTREAM : public OLESTREAM
{
	OLESTREAMVTBL OLEStreamVtbl;	// @member - memory for  OLESTREAMVTBL
public:
	 CRTFRead *Reader;				// @cmember EDITSTREAM to use

	RTFREADOLESTREAM::RTFREADOLESTREAM ()
	{
		lpstbl = & OLEStreamVtbl ;
	}		
};

#define	NSTYLES		(NHSTYLES + 1)
#define CCELLS		((1 + CELL_EXTRA)*MAX_TABLE_CELLS)
/*
 *	CRTFRead
 *
 *	@class	RichEdit RTF reader class.
 *
 *	@base	public | CRTFConverter
 */
class CRTFRead : public CRTFConverter
{

//@access Private Methods and Data
	// Lexical analyzer outputs
	LONG		_iParam;				//@cmember Control-word parameter
	TOKEN		_token;					//@cmember Current control-word token
	TOKEN		_tokenLast;				//@cmember Previous token
	BYTE *		_szText;				//@cmember Current BYTE text string

	// Used for reading in
	BYTE		_rgStyles[NSTYLES];		//@cmember Style handle table
	SHORT		_Style;					//@cmember Current style handle
	LONG		_cbBinLeft;				//@cmember cb of bin data left to read
	BYTE *		_pchRTFBuffer;			//@cmember Buffer for GetChar()
	BYTE *		_pchRTFCurrent;			//@cmember Current position in buffer
	BYTE *		_pchRTFEnd;				//@cmember End of buffer
	BYTE *		_pchHexCurr;			//@cmember Current position within
										//  _szText when reading object data
	INT			_nStackDepth;			//@cmember Stack depth
	STATE *		_pstateStackTop;		//@cmember Stack top
	STATE *		_pstateLast;			//@cmember Last STATE allocated
	LONG		_cpThisPara;			//@cmember Start of current paragraph

	DWORD		_dwMaskCF;				//@cmember Character format mask
	DWORD		_dwMaskCF2;				//@cmember Character format mask 2
	CParaFormat	_PF;					//@cmember Paragraph format changes
	DWORD		_dwMaskPF;				//@cmember Paragraph format mask
	DWORD		_dwMaskPF2;				//@cmember Paragraph format mask

	LONG		_cTab;					//@cmember Count of defined tabs
	LONG		_dxCell;				//@cmember Half space betw table cells
	LONG		_cCell;					//@cmember Count of cells in table row
	LONG		_iCell;					//@cmember Current cell in table row
	COLORREF	_crCellCustom1;			//@cmember First custom cell color
	COLORREF	_crCellCustom2;			//@cmember Second custom cell color
	LONG		_rgxCell[CCELLS];		//@cmember Cell right boundaries
	LONG		_xCellPrev;				//@cmember Previous \cellx N
	LONG		_xRowOffset;			//@cmember Row offset to ensure rows fall along left margin
	DWORD		_dwBorderColors;		//@cmember Border colors
	DWORD		_dwCellColors;			//@cmember Cell border and back colors
	DWORD		_dwShading;				//@cmember Shading in hundredths of per cent (could be 1 byte)
	WORD		_wBorders;				//@cmember Border styles
	WORD		_wBorderSpace;			//@cmember Border/text spaces
	WORD		_wBorderWidth;			//@cmember Border widths
	SHORT		_iTabsTable;			//@cmember _iTabs used by last table
	TABLESTATE	_rgTableState[MAXTABLENEST];
	DWORD		_dwRowResolveFlags;		//@cmember Flags for row start resolution

	COleObject *_pobj;					//@cmember Pointer to our object

	union
	{
	  DWORD		_dwFlagsUnion;			// All together now
	  struct
	  {
		WORD	_fFailedPrevObj	 : 1;	//@cmember Fail to get prev object ?
		WORD	_fNeedIcon		 : 1;	//@cmember Objects needs an icon pres
		WORD	_fNeedPres		 : 1;	//@cmember Use stored presenation.
		WORD	_fGetColorYet	 : 1;	//@cmember used for AutoColor detect
		WORD	_fRightToLeftDoc : 1;	//@cmember Document is R to L ?
		WORD	_fReadDefFont	 : 1;	//@cmember True if we've read a default
										// 		   font from RTF input
		WORD	_fSymbolField	 : 1;	//@cmember TRUE if handling SYMBOL field
		WORD	_fSeenFontTable	 : 1;	//@cmember True if \fonttbl	processed 
		WORD	_fCharSet		 : 1;	//@cmember True if \fcharset processed
		WORD    _fNoRTFtoken     : 1;   //@cmember True in 1.0 mode if \rtf hasn't been seen
		WORD	_fInTable		 : 1;	//@cmember True if pasting into table
		WORD	_fStartRow		 : 1;	//@cmember True if AddText should start row
		WORD	_fNo_iTabsTable	 : 1;	//@cmember Suppress _iTabsTable changes
		WORD	_fParam			 : 1;	//@cmember TRUE if token has param
		WORD	_fNotifyLowFiRTF : 1;	//@cmember TRUE if EN_LOWFIRTF
		WORD	_fMac			 : 1;	//@cmember TRUE if \mac file
		BYTE	_bDocType;				//@cmember Document Type
		BYTE	_fRTLRow		 : 1;	//@cmember RightToLeft table row
		BYTE	_fNon0CharSet	 : 1;	//@cmember CharSet other than ANSI_CHARSET found
		BYTE	_fBody			 : 1;	//@cmember TRUE when body text has started
		BYTE	_f1stControlWord : 1;	//@cmember TRUE if 1st ctrl word in group
		BYTE	_fCellxOK		 : 1;	//@cmember TRUE if \cellx okay to handle
	  };
	};

	SHORT		_sDefaultFont;			//@cmember Default font to use
	SHORT       _sDefaultBiDiFont;      //@cmember Default Bidi font to use
	SHORT		_sDefaultLanguage;		//@cmember Default language to use
	SHORT		_sDefaultLanguageFE;	//@cmember Default FE language to use

	SHORT		_sDefaultTabWidth;		//@cmember Default tabwidth to use
	SHORT		_iKeyword;				//@cmember Keyword index of last token

	WCHAR		_szNumText[cchMaxNumText];	//@cmember Scratch pad for numbered lists

	int			_nCodePage;				//@cmember default codepage (RTF-read-level)
	int			_cchUsedNumText;		//@cmember space used in szNumText

	RTFOBJECT *	_prtfObject;			//@cmember Ptr to RTF Object
	RTFREADOLESTREAM RTFReadOLEStream;	//@cmember RTFREADOLESTREAM to use
	DWORD		_dwFlagsShape;			//@cmember Shape flags

	WCHAR *		_szUnicode;				//@cmember String to hold Unicoded chars
	LONG		_cchUnicode;			//@cmember Size of _szUnicode in WCHARs
	DWORD		_cchMax;				//@cmember Max cch that can still be inserted
	LONG		_cpFirst;				//@cmember Starting cp for insertion

	// Object attachment placeholder list
	LONG *		_pcpObPos;
	int			_cobPosFree;
	int 		_cobPos;

	DWORD		_dwCellBrdrWdths;		//@cmember Current cell border widths
	LONG		_dyRow;					//@cmember Current row height \trrh N
	WORD		_wNumberingStyle;		//@cmember Numbering style to use
	SHORT		_iTabsLevel1;			//@cmember _iTabs for table level 1
	BYTE		_bTabType;				//@cmember left/right/center/deciml/bar tab
	BYTE		_bTabLeader;			//@cmember none/dotted/dashed/underline

	BYTE		_bBorder;				//@cmember Current border segment
	BYTE		_iCharRepBiDi;			//@cmember Default system's BiDi char repertoire
	BYTE		_bCellFlags;			//@cmember Cell flags, e.g., merge flags
	BYTE		_bShapeNameIndex;		//@cmember Shape name index
	BYTE		_bAlignment;			//@cmember Alignment for tables

	// Lexical Analyzer Functions
	void	DeinitLex();				//@cmember Release lexer storage
	BOOL	InitLex();					//@cmember Alloc lexer storage
	EC		SkipToEndOfGroup();			//@cmember Skip to matching }
	TOKEN	TokenFindKeyword(			//@cmember Find _token for szKeyword
				BYTE *szKeyword, const KEYWORD *prgKeyword, LONG cKeyword);
	TOKEN	TokenGetHex();				//@cmember Get next byte from hex input
	TOKEN	TokenGetKeyword();			//@cmember Get next control word
	TOKEN	TokenGetText(BYTE ch);		//@cmember Get text in between ctrl words
	TOKEN	TokenGetToken();			//@cmember Get next {, }, \\, or text
	BOOL 	FInDocTextDest() const;		//@cmember Is reader in document text destination
										//@cmember Send LowFi notif. if enabled
	void	CheckNotifyLowFiRTF(BOOL fEnable = FALSE); 

	// Input Functions
	LONG	FillBuffer();				//@cmember Fill input buffer
	BYTE	GetChar();					//@cmember Return char from input buffer
	BYTE	GetCharEx();				//@cmember Return char from input buffer incl \'xx
	BYTE	GetHex();					//@cmember Get next hex value from input
	BYTE	GetHexSkipCRLF();			//@cmember Get next hex value from input
	void	GetParam(char ach);			//@cmember Get keyword's numeric parameter
	void	ReadFontName(STATE *pstate, int iAllASCII);//@cmember Copy font name into state
	BOOL	UngetChar();				//@cmember Decrement input buffer ptr
	BOOL	UngetChar(UINT cch);		//@cmember Decrement input buffer ptr 'cch' times

	// Reader Functions
										//@cmember Insert text into range
	EC		AddText(WCHAR *pch, LONG cch, BOOL fNumber, BOOL fUN = FALSE);
	void	Apply_CF();					//@cmember Apply _CF changes
	SHORT	Apply_PF();					//@cmember Apply _PF changes
	COLORREF GetColor(DWORD dwMask);	//@cmember Get color _iParam for mask
	LONG	GetStandardColorIndex();	//@cmember Get std index <-> _iparam
	LONG	GetCellColorIndex();		//@cmember Get cell index <-> _iparam
	EC		HandleChar(WORD ch);		//@cmember Insert single Unicode
	EC		HandleEndGroup();			//@cmember Handle }
	EC		HandleEndOfPara();			//@cmember Insert EOP into range
	void	HandleCell();				//@cmember Handle \cell
	void	HandleCellx(LONG iParam);	//@cmember Handle \cellx
										//@cmember Handle Word EQ field
	EC		HandleEq(CTxtRange &rg, CTxtPtr &tp);
	void	HandleFieldEndGroup();		//@cmember Handle Field End Group
	EC		HandleFieldInstruction();	//@cmember	Handle field instruction
	EC		HandleFieldSymbolFont(BYTE *pch); //@cmember Handle \\f "Facename" in symbol
						//@cmember	Handle specific SYMBOL field instruction
	EC		HandleFieldSymbolInstruction(BYTE *pch, BYTE *szSymbol);
	EC		HandleNumber();				//@cmember Handle _iParam as textToken
	EC		HandleStartGroup();			//@cmember Handle {
	enum { CONTAINS_NONASCII, ALL_ASCII };
										//@cmember Insert szText into range
	EC		HandleText(BYTE *szText, int iAllASCII, LONG cchText = -1);
	EC		HandleTextToken(STATE *pstate);//@cmember Handle tokenText
	EC		HandleToken();				//@cmember Grand _token switchboard
	void	HandleUN(STATE *pstate);	//@cmember Handle \uN sequence
	BOOL	IsLowMergedCell();			//@cmember TRUE iff low merged cell
	void	Pard(STATE *pstate);		//@cmember Set default para props
	void	SelectCurrentFont(INT iFont);//@cmember Select font <p iFont>
	void	SetPlain(STATE *pstate);	//@cmember Setup _CF for \plain
	void	DelimitRow(WCHAR *szRowDelimiter);	//@cmember Insert start-of-row
	void	InitializeTableRowParms();	//@cmember Restore table parms to initial state
	BOOL	StoreDestination(STATE *pstate, LONG dest);//@cmember Store STATE destination if ok

	// Object functions
	EC		HexToByte(BYTE *rgchHex, BYTE *pb);
	void	FreeRtfObject();
	EC		StrAlloc(WCHAR ** ppsz, BYTE * sz);
	BOOL	ObjectReadFromEditStream(void);
	BOOL	ObjectReadEBookImageInfoFromEditStream(void); //@to get e-book image info
	BOOL	StaticObjectReadFromEditStream(int cb = 0);
	BOOL	ObjectReadSiteFlags( REOBJECT * preobj);
	
	void	SetBorderParm(WORD& Parm, LONG Value);
	BOOL 	CpgInfoFromFaceName(TEXTFONT *ptf);	//@cmember Determines 
										// charset/cpg based on TEXTFONT::szName
	void	HandleSTextFlow(int mode);	//@cmember Handle S Text Flow

//@access Public Methods
public:
		//@cmember RTF reader constructor
	CRTFRead(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags);
	inline ~CRTFRead();					//@cmember CRTFRead destructor

	LONG	ReadRtf();					//@cmember Main Entry to RTF reader

	LONG	ReadData(BYTE *pbBuffer, LONG cbBuffer); // todo friend
	LONG	ReadBinaryData(BYTE *pbBuffer, LONG cbBuffer);
	LONG	SkipBinaryData(LONG cbSkip);
	LONG	ReadRawText(char	**pszRawText);				//@cmember Read in raw text

// Member functions/data to test coverage of RTF reader
#if defined(DEBUG)
public:
	void TestParserCoverage();
private:
	CHAR *PszKeywordFromToken(TOKEN token);
	BOOL FTokIsSymbol(TOKEN tok);
	BOOL FTokFailsCoverageTest(TOKEN tok);

	BOOL _fTestingParserCoverage;

private:
	// member data for RTF tag logging
	CRTFLog *_prtflg;
#endif //DEBUG
};

/*
 *	PointsToFontHeight(cHalfPoints)
 *
 *	@func
 *		Convert half points to font heights
 *
 *	@parm int |
 *		sPointSize |		Font height in half points
 *
 *	@rdesc
 *		LONG				The corresponding CCharFormat.yHeight value
 */
#define PointsToFontHeight(cHalfPoints) (((LONG) cHalfPoints) * 10)


/*
 *	CRTFRead::~CRTFRead
 *
 *	@mdesc
 *		Destructor 
 *
 */
inline CRTFRead::~CRTFRead()
{
// TODO: Implement RTF tag logging for the Mac and WinCE
#if defined(DEBUG) && !defined(NOFULLDEBUG)
	if(_prtflg)
	{
		delete _prtflg;
		_prtflg = NULL;
	}
#endif
}
#endif // __RTFREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_select.h ===
/*
 *	_SELECT.H
 *	
 *	Purpose:
 *		CTxtSelection class
 *	
 *	Owner:
 *		David R. Fulmer (original code)
 *		Christian Fortini
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _SELECT_H
#define _SELECT_H

#include "_range.h"
#include "_m_undo.h"

// amount of time, in milisecs, before pending characters force a display update
#define ticksPendingUpdate 100	// 100 mili secs ~ display at least 10 characters per second.

class CDisplay;
class CLinePtr;

typedef enum
{
	smNone,
	smWord,
	smLine,
	smPara
} SELMODE;

enum
{
	CARET_NONE	= 0,
	CARET_CUSTOM = 1,
	CARET_BIDI = 2,
	CARET_THAI = 4,
	CARET_INDIC = 8
};

class CTxtSelection : public CTxtRange
{
#ifdef DEBUG
public:
	BOOL Invariant( void ) const; // Invariant checking.
#endif // DEBUG

//@access Protected Data
protected:
	CDisplay	*_pdp;			// display this selection belong to

	LONG	_cpSel;				// active end of displayed selection
	LONG	_cchSel;			// length of displayed selection

	LONG 	_upCaret;			// caret x on screen
	LONG 	_vpCaret;			// caret y on screen 
	LONG 	_upCaretReally;		// real caret x (/r start of line) for vertical moves
	INT 	_dvpCaret;			// caret height

	union
	{
	  DWORD _dwFlags;			// All together now
	  struct
	  {
	   DWORD _fCaretNotAtBOL:1;	// If at BOL, show caret at prev EOL
	   DWORD _fDeferUpdate	:1;	// Defer updating selection/caret on screen
	   DWORD _fInAutoWordSel:1;	// Current selection used auto word sel
	   DWORD _fShowCaret	:1;	// Show caret on screen
	   DWORD _fShowSelection:1;	// Show selection on screen

	   DWORD _fIsChar		:1;	// Currently adding a single char
	   DWORD _fObSelected	:1;	// An embedded object is selected
	   DWORD _fAutoSelectAborted : 1; // Whether auto word selection is aborted
	   DWORD _fCaretCreated	:1;	// Caret has been created
	   DWORD _fNoKeyboardUpdate :1; // Keyboard is not updated while in UpdateCaret()
	   DWORD _fEOP			:1;	// InsertEOP() has been called
	   DWORD _fHomeOrEnd	:1;	// Home or End key is being processed
	   DWORD _fAutoVScroll	:1;	// 1.0 specific: flag indicating autoscrolling should be applied
	   DWORD _fForceScrollCaret:1; // 1.0 specific: force caret to scroll
	   DWORD _fShowCellLine	:1;	// Show line for CELL following TRED
	   DWORD _fUpdatedFromCp0:1;// Updated selection from cp = 0
	  };
	};
	
	SELMODE	_SelMode;			// 0 none, 1 Word, 2 Line, 3 Paragraph
	DWORD	_ticksPending;		// Count of chars inserted without UpdateWindow
	LONG 	_cpAnchor;			// Initial anchor for auto word select
	LONG	_cpAnchorMin;		// Initial selection cpMin/cpMost for select
	LONG	_cpAnchorMost;		//  modes
	LONG 	_cpWordMin;			// Start of anchor word in word select mode
	LONG 	_cpWordMost;		// End   of anchor word in word select mode
	LONG	_cpWordPrev;		// Previous anchor word end

	HBITMAP	_hbmpCaret;			// Used for funky carets, like BiDi/ital carets
	DWORD	_dwCaretInfo;		// Current caret info used to avoid new create

//@access Public Methods
public:
	CTxtSelection(CDisplay * const pdp);
	~CTxtSelection();

	CRchTxtPtr&	operator =(const CRchTxtPtr& rtp);
	CTxtRange&  operator =(const CTxtRange &rg);

	// Set the display
	void	SetDisplay(CDisplay *pdp) { _pdp = pdp; }

	// Information for Selection Change notification

	void 	SetSelectionInfo(SELCHANGE *pselchg);

	// Replacement
	LONG	DeleteWithTRDCheck(IUndoBuilder *publdr, SELRR selaemode,
							   LONG *pcchMove, DWORD dwflags);
	LONG	ReplaceRange(LONG cchNew, WCHAR const *pch, 
						IUndoBuilder *publdr, SELRR fCreateAE, LONG* pcchMove = NULL,
						DWORD dwFlags = 0);

	// Info for recalc line / UpdateView
	void	ClearCchPending()			{_ticksPending = 0;}
	LONG	GetScrSelMin() const		{return min(_cpSel, _cpSel - _cchSel);}
	LONG	GetScrSelMost() const		{return max(_cpSel, _cpSel - _cchSel);}
	BOOL	PuttingChar() const			{return _fIsChar;}

	// General updating
	virtual	BOOL 	Update(BOOL fScrollIntoView);

	BOOL	DeferUpdate()			
				{const BOOL fRet = _fDeferUpdate; _fDeferUpdate = TRUE; return fRet;}
	BOOL	DoDeferedUpdate(BOOL fScrollIntoView)		
				{_fDeferUpdate = FALSE; return Update(fScrollIntoView);}

	void	SetAutoVScroll(BOOL bAuto) {_fAutoVScroll = bAuto;}
	BOOL	GetAutoVScroll()	{return _fAutoVScroll;}
	BOOL	GetShowCellLine()	{return _fShowCellLine;}

	void	SetForceScrollCaret(BOOL bAuto) {_fForceScrollCaret = bAuto;}
	BOOL	GetForceScrollCaret() {return _fForceScrollCaret;}

	// method used by selection anti-event for out-of-phase updates
	void	SetDelayedSelectionRange(LONG cp, LONG cch);
	void	StopGroupTyping();

	// Caret management
	BOOL	CaretNotAtBOL() const;
	void	CheckTableIP(BOOL fOpenLine);
	void	CreateCaret();
	void	DeleteCaretBitmap(BOOL fReset);
	BOOL	IsCaretHorizontal() const;
	INT		GetCaretHt()				{return _dvpCaret;}
	LONG	GetUpCaretReally();
	LONG	GetUpCaret()	const			{return _upCaret;}
	LONG	GetVpCaret()	const			{return _vpCaret;}
	BOOL	IsCaretNotAtBOL() const		{return _fCaretNotAtBOL;}
	BOOL 	IsCaretInView() const;
	BOOL 	IsCaretShown() const		{return _fShowCaret && !_cch;}
	BOOL	IsUpdatedFromCp0() const	{return _fUpdatedFromCp0;}
	LONG	LineLength(LONG *pcp) const;
	BOOL	SetUpPosition(LONG upCaret, CLinePtr& rp, BOOL fBottomLine, BOOL fExtend);
	BOOL 	ShowCaret(BOOL fShow);
	BOOL 	UpdateCaret(BOOL fScrollIntoView, BOOL fForceCaret = FALSE);
	BOOL	GetCaretPoint(RECTUV &rcClient, POINTUV &pt, CLinePtr *prp, BOOL fBeforeCp);
	BOOL	MatchKeyboardToPara();

	// Selection management
	void	ClearPrevSel()				{ _cpSel = 0; _cchSel = 0; }
	BOOL	GetShowSelection()			{return _fShowSelection;}
	BOOL	ScrollWindowful(WPARAM wparam, BOOL fExtend);
	void 	SetSelection(LONG cpFirst, LONG cpMost);
	BOOL	ShowSelection(BOOL fShow);
	void	Beep()						{GetPed()->Beep();}

	// Selection with the mouse
	void 	CancelModes	(BOOL fAutoWordSel = FALSE);
	void 	ExtendSelection(const POINTUV pt);
	BOOL	PointInSel	(const POINTUV pt, RECTUV *prcClient = NULL, HITTEST Hit = HT_Undefined) const;
	void 	SelectAll	();
	void 	SelectUnit	(const POINTUV pt, LONG Unit);
	void 	SelectWord	(const POINTUV pt);
 	void 	SetCaret	(const POINTUV pt, BOOL fUpdate = TRUE);

	// Keyboard movements
	BOOL 	Left	(BOOL fCtrl, BOOL fExtend);
	BOOL	Right	(BOOL fCtrl, BOOL fExtend);
	BOOL	Up		(BOOL fCtrl, BOOL fExtend);
	BOOL	Down	(BOOL fCtrl, BOOL fExtend);
	BOOL	Home	(BOOL fCtrl, BOOL fExtend);
	BOOL	End		(BOOL fCtrl, BOOL fExtend);
	BOOL	PageUp	(BOOL fCtrl, BOOL fExtend);
	BOOL	PageDown(BOOL fCtrl, BOOL fExtend);

	// Editing
	BOOL	PutChar	 (DWORD ch, DWORD dwFlags, IUndoBuilder *publdr, LCID lcid = 0);
	void	SetIsChar(BOOL);
	void	CheckUpdateWindow();
	BOOL	InsertEOP(IUndoBuilder *publdr, WCHAR ch = 0);
	LONG	InsertTableRow (const CParaFormat *pPF, IUndoBuilder *publdr,
							BOOL fFixCellBorders = FALSE);
	
	// Keyboard switching support.
	void	CheckChangeKeyboardLayout();
	bool	CheckChangeFont (const HKL hkl, UINT iCharRep, LONG iSelFormat = 0, QWORD qwCharFlags = 0);
	UINT	CheckSynchCharSet(QWORD dwCharFlags = 0);

	// from CTxtRange
	BOOL	Delete  (DWORD flags, IUndoBuilder *publdr);
	BOOL	Backspace(BOOL fCtrl, IUndoBuilder *publdr);

	const CParaFormat* GetPF();

	// note that the parameters are different than CTxtRange::SetCharFormat
	// intentionally; the selection has extra options available to it.
	HRESULT	SetCharFormat(const CCharFormat *pCF, DWORD flags,  
									IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaFormat(const CParaFormat *pPF,
									IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);

	// Auto word selection helper
	void	InitClickForAutWordSel(const POINTUV pt);

	// dual font helper for CTxtSelection::PutChar
	void	SetupDualFont();

	// IUnknown and IDispatch methods handled by CTxtRange methods

	// ITextRange methods can use ITextRange methods directly, since
	// they either don't modify the display of the selection (get methods), or
	// they have appropriate virtual character to call on selection functions.

	// ITextSelection methods
	STDMETHODIMP GetFlags (long *pFlags) ;
	STDMETHODIMP SetFlags (long Flags) ;
	STDMETHODIMP GetType  (long *pType) ;
	STDMETHODIMP MoveLeft (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveRight(long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveUp	  (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveDown (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP HomeKey  (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP EndKey   (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP TypeText (BSTR bstr) ;
	STDMETHODIMP SetPoint (long x, long y, long Extend) ;

//@access Protected Methods
protected:

	// Protected update method
	void	UpdateSelection();

	// Protected caret management method
	INT 	GetCaretHeight(INT *pyDescent) const;

	HRESULT	GeoMover (long Unit, long Count, long Extend,
					  long *pDelta, LONG iDir);
	HRESULT Homer	 (long Unit, long Extend, long *pDelta,
					  BOOL (CTxtSelection::*pfn)(BOOL, BOOL));

	// Auto Select Word Helpers
	void	UpdateForAutoWord();
	void	AutoSelGoBackWord(
				LONG *pcpToUpdate,
				int iDirToPrevWord,
				int	iDirToNextWord);

	void	ExtendToWordBreak(BOOL fAfterEOP, INT iDir);
	BOOL	CheckPlainTextFinalEOP();
};

/*
 *	CSelPhaseAdjuster
 *
 *	@class	This class is put on the stack and used to temporarily hold
 *			selection cp values until the control is "stable" (and thus,
 *			we can safely set the selection
 */
class CSelPhaseAdjuster : public IReEntrantComponent
{
//@access	Public methods
public:

	// IReEntrantComponent methods

	virtual	void OnEnterContext()	{;}		//@cmember re-entered notify

	CSelPhaseAdjuster(CTxtEdit *ped);		//@cmember constructor
	~CSelPhaseAdjuster();					//@cmember destructor

	void CacheRange(LONG cp, LONG cch);		//@cmember stores the sel range

//@access	Private data
private:
	CTxtEdit *		_ped;					//@cmember edit context
	LONG			_cp;					//@cmember sel active end to set
	LONG			_cch;					//@cmember sel extension
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_rtext.h ===
/*
 *	_RTEXT.H
 *	
 *	Purpose:
 *		Base classes for rich-text manipulation
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 */

#ifndef _RTEXT_H
#define _RTEXT_H

#include "_edit.h"
#include "_array.h"
#include "_doc.h"
#include "_text.h"
#include "_runptr.h"
#include "_frunptr.h"
#include "_notmgr.h"



//#pragma warning(disable: 4250)	

#define yHeightCharMost	32760

class CTxtEdit;
class CTxtRange;
class CRchTxtPtr;

// ReplaceRange's flags
enum
{
	RR_ITMZ_NOUNICODEBIDI	= 0,
	RR_ITMZ_UNICODEBIDI		= 1,
	RR_ITMZ_NONE			= 2,

	RR_UNLINK				= 8,
	RR_UNHIDE				= 16,
	RR_NO_TRD_CHECK			= 32,
	RR_NO_LP_CHECK			= 64,
	RR_NO_CHECK_TABLE_SEL	= 128,
	RR_NEW_CHARS			= 256
};

extern BOOL IsWhiteSpace(unsigned ch);

// ==============================  CRchTxtPtr  =====================================================
// Keeps physical positions corresponding to text character position (cp)
// within current text block, formatting runs, objects, unknown RTF runs,
// and floating ranges.

class CRchTxtPtr : public ITxNotify
{
public:

#ifdef DEBUG
    BOOL Invariant( void ) const;
	int	 m_InvariantCheckInterval;
	LONG GetParaNumber() const;
#endif  // DEBUG

	CTxtPtr			_rpTX;		// rp in the plain text array
	CFormatRunPtr	_rpCF;		// rp in character format runs
	CFormatRunPtr	_rpPF;		// rp in paragraph format runs

// Useful constructors

	CRchTxtPtr(CTxtEdit *ped);
	CRchTxtPtr(CTxtEdit *ped, LONG cp);
	CRchTxtPtr(const CRchTxtPtr& rtp);
	CRchTxtPtr(const CDisplay * pdp);

	virtual CRchTxtPtr& operator =(const CRchTxtPtr& rtp)
	{
		_rpTX._ped = rtp._rpTX._ped;
		SetCp(rtp.GetCp());
		return *this;
	}

	LONG 	Move(LONG cch);
	LONG	AdvanceCRLF();
	LONG	BackupCRLF(BOOL fDiacriticCheck = TRUE);
#ifndef NOCOMPLEXSCRIPTS
	LONG	SnapToCluster(INT iDirection = 0);
#endif
	LONG	SetCp( LONG cp);
	void	BindToCp(LONG cp);
	void	CheckFormatRuns();
	LONG	GetCp() const			{ return _rpTX.GetCp(); }
	LONG	GetTextLength() const	{ return _rpTX.GetTextLength(); }
	LONG	GetObjectCount() const	{ return GetPed()->GetObjectCount(); }
	CTxtEdit *GetPed() const		{ return _rpTX._ped; }
	const WCHAR * GetPch(LONG &cchvalid) { return _rpTX.GetPch(cchvalid); }
	WCHAR 	GetChar()				{ return _rpTX.GetChar(); }
	WCHAR 	GetPrevChar()			{ return _rpTX.GetPrevChar(); }
	LONG	GetPlainText(LONG cchBuff, WCHAR *pch, LONG cpMost, BOOL fTextize, BOOL fUseCRLF);
	void	ValidateCp(LONG &cp) const;
	LONG	GetCachFromCch(LONG cch);
	LONG	GetCchFromCach(LONG cach);

	// Text manipulation methods

	// Range operations
	LONG	ReplaceRange(LONG cchOld, LONG cchNew, WCHAR const *pch,
						 IUndoBuilder *publdr, LONG iFormat,
						 LONG *pcchMove = NULL, DWORD dwFlags = 0);
	BOOL 	ItemizeReplaceRange(LONG cchUpdate, LONG cchMove,
						IUndoBuilder *publdr, BOOL fUnicodeBidi = FALSE);
	BOOL	ChangeCase(LONG cch, LONG Type, IUndoBuilder *publdr);
	LONG	UnitCounter (LONG iUnit, LONG &	cUnit, LONG cchMax, BOOL fNotAtBOL = FALSE);
	void	ExtendFormattingCRLF();
	LONG	ExpandRangeFormatting(LONG cchRange, LONG cchMove, LONG& cchAdvance);

	// Search and word-break support
	LONG	FindText(LONG cpMax, DWORD dwFlags, WCHAR const *pch,
					 LONG cchToFind);
	LONG	FindWordBreak(INT action, LONG cpMost = -1);

	// Text-run management
	LONG 	GetIchRunCF();
	LONG	GetIchRunPF();
	LONG 	GetCchRunCF();
	LONG 	GetCchLeftRunCF();
	LONG 	GetCchLeftRunPF();
	
	// Character & paragraph format retrieval
	const CCharFormat* GetCF() const;
	const CParaFormat* GetPF() const;
	LONG	Get_iCF();						//@cmember Get CF index
	LONG	Get_iPF();						//@cmember Get PF index

	BOOL	IsCollapsed() const	{return (GetPF()->_wEffects & PFE_COLLAPSED) != 0;}
	BOOL	IsHidden() const	{return (GetCF()->_dwEffects & CFE_HIDDEN)   != 0;}
	BOOL	InTable() const		{return (GetPF()->_wEffects & PFE_TABLE)     != 0;}
	BOOL	IsParaRTL() const	{return (GetPF()->_wEffects & PFE_RTLPARA)   != 0;}

    // ITxNotify methods
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
    					LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData ) { ; }
	virtual void 	OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
						LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData ) { ; }
	virtual void	Zombie();

	BOOL	Check_rpCF();
	BOOL	Check_rpPF();

protected:
	void	InitRunPtrs();
	BOOL	IsRich();
	bool  	fUseUIFont() const {return GetPed()->fUseUIFont();}
	BOOL	IsInOutlineView() const {return GetPed()->IsInOutlineView();}
	void	SetRunPtrs(LONG cp, LONG cpFrom);

private:
	LONG	ReplaceRangeFormatting(LONG cchOld, LONG cchNew, LONG iFormat,
							IUndoBuilder *publdr,
							IAntiEvent **ppaeCF, IAntiEvent **ppaePF,
							LONG cchMove, LONG cchPrevEOP, LONG cchNextEOP,
							LONG cchSaveBefore = 0, LONG cchSaveAfter = 0);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_text.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _TEXT.H	-- Declaration for a CTxtRun pointer |
 *	
 *	CTxtRun pointers point at the plain text runs (CTxtArray) of the
 *	backing store and derive from CRunPtrBase via the CRunPtr template.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _TEXT_H
#define _TEXT_H

#include "_runptr.h"
#include "_doc.h"
#include "textserv.h"
#include "_m_undo.h"

class CRchTxtPtr;
class CTxtEdit;
class CTxtIStream;

/*
 *	CTxtPtr
 *
 *	@class
 *		provides access to the array of characters in the backing store
 *		(i.e. <c CTxtArray>)
 *
 *	@base 	public | CRunPtr<lt>CTxtArray<gt>
 *
 *	@devnote
 *		The state transitions for this object are the same as those for
 *		<c CRunPtrBase>.  <md CTxtPtr::_cp> simply caches the current
 *		cp (even though it can be derived from _iRun and _ich).  _cp is
 *		used frequently enough (and computing may be expensive) that 
 *		caching the value is worthwhile.
 *
 *		CTxtPtr's *may* be put on the stack, but do so with extreme
 *		caution.  These objects do *not* float; if a change is made to 
 *		the backing store while a CTxtPtr is active, it will be out
 *		of sync and may lead to a crash.  If such a situation may 
 *		exist, use a <c CTxtRange> instead (as these float and keep 
 *		their internal text && format run pointers up-to-date).  
 *
 *		Otherwise, a CTxtPtr is a useful, very lightweight plain 
 *		text scanner.
 */

// FindEOP() result flags.  Low byte used for cchEOP
#define FEOP_CELL	256
#define FEOP_EOP	512

// FindWhiteSpace input flags
#define FWS_SKIP		1
#define FWS_BOUNDTOPARA	2
#define FWS_MOVE	256

class CTxtPtr : public CRunPtr<CTxtBlk>
{
	// Only CRchTxtPtr is allowed to call private methods like replace range.  
	friend class CRchTxtPtr;

//@access Public Methods
public:
#ifdef DEBUG
	BOOL Invariant( void ) const;		//@cmember	Invariant checking
	void Update_pchCp() const;
	void MoveGapToEndOfBlock () const;
#endif	// DEBUG

	CTxtPtr(CTxtEdit *ped, LONG cp);	//@cmember	Constructor
	CTxtPtr(const CTxtPtr &tp);			//@cmember	Copy Constructor

	LONG	GetText(LONG cch, TCHAR *pch);	//@cmember 	Fetch <p cch> chars
#ifndef NOCOMPLEXSCRIPTS
									//@cmember Fetch <p cch> chars with usp xlat	
	LONG	GetTextForUsp(LONG cch, TCHAR *pch, BOOL fNeutralOverride);
#endif
	LONG	GetPlainText(LONG cch, WCHAR *pchBuff,
					LONG cpMost, BOOL fTextize, BOOL fUseCRLF = TRUE);
	WCHAR	NextCharCount(LONG& cch);	//@cmember Move, GetChar, decrement
	WCHAR	NextChar();				//@cmember Advance to & return next char
	WCHAR	PrevChar();				//@cmember Backup to & return previous char
	WCHAR	GetChar();				//@cmember Fetch char at current cp
	WCHAR	GetPrevChar();			//@cmember Fetch char at previous cp
	LONG	GetTextLength() const;	//@cmember Get total cch for this document
	const WCHAR* GetPch(LONG& cchValid) const;//@cmember	Get ptr to block of chars

							//@cmember	Get ptr to a reverse block of chars
	const WCHAR* GetPchReverse(LONG& cchValidReverse, LONG* pcchValid = NULL) const;
	QWORD	GetCharFlagsInRange(LONG cch, BYTE bCharSetDefault);

	// The text array has its own versions of these methods (overuling
	// those in runptr base so that <md CTxtPtr::_cp> can be correctly
	// maintained.

	LONG	BindToCp(LONG cp);	//@cmember Rebinds text pointer to cp
	LONG 	SetCp(LONG cp);		//@cmember Sets the cp for the run ptr
	LONG	GetCp() const 		//@cmember Gets the current cp
	{ 
		// NB! Don't do invariant checking here so floating
		// range mechanism can work OK
		return _cp; 
	};
	void	Zombie();			//@cmember Turn this tp into a zombie

	LONG	Move(LONG cch);		//@cmember Move cp by cch chars
	
	// Advance/backup/adjust safe over CRLF and UTF-16 word pairs
	LONG	AdjustCRLF(LONG iDir = -1);//@cmember Backup to start of multichar
	LONG	AdvanceCRLF(BOOL fMulticharAdvance = TRUE);	//@cmember	Advance over multichar
							 	//@cmember Backup over multichar 
	LONG	BackupCRLF(BOOL fMulticharBackup = TRUE);
	BOOL	IsAtStartOfCell();	//@cmember Does GetCp() follow a CELL or SOTR?
	BOOL	IsAfterEOP();		//@cmember Does GetCp() follow an EOP?
	BOOL	IsAfterTRD(WCHAR ch);//@cmember Does _cp follow table-row delimiter?
	BOOL	IsAtBOSentence();	//@cmember At beginning of a sentence?
	BOOL	IsAtBOWord();		//@cmember At beginning of word?
	BOOL	IsAtEOP();			//@cmember Is _cp at an EOP marker?
	BOOL	IsAtTRD(WCHAR ch);	//@cmember Is _cp at table-row delimiter?
	LONG	MoveWhile(LONG cchRun, WCHAR chFirst, WCHAR chLast, BOOL fInRange);
	
	// Search
								//@cmember Find indicated text
	LONG	FindText(LONG cpMost, DWORD dwFlags, WCHAR const *pch, LONG cch);
								//@cmember Find next EOP
	LONG	FindEOP(LONG cchMax, LONG *pResults = NULL);
								//@cmember Find next exact	match to <p pch>
	LONG	FindExact(LONG cchMax, WCHAR *pch);
	LONG	FindBOSentence(LONG cch);	//@cmember	Find beginning of sentence
	LONG	FindOrSkipWhiteSpaces(LONG cchMax, DWORD dwFlags = 0, DWORD* pdwResult = NULL);
	LONG	FindWhiteSpaceBound(LONG cchMin, LONG& cpStart, LONG& cpEnd, DWORD dwFlags = 0);

	// Word break support
	LONG	FindWordBreak(INT action, LONG cpMost = -1);//@cmember	Find next word break
	LONG	TranslateRange(LONG cch, UINT CodePage,
						   BOOL fSymbolCharSet, IUndoBuilder *publdr);

//@access	Private methods and data
private:
							//@cmember	Replace <p cchOld> characters with 
							// <p cchNew> characters from <p pch>
	LONG	ReplaceRange(LONG cchOld, LONG cchNew, WCHAR const *pch,
									IUndoBuilder *publdr, IAntiEvent *paeCF,
									IAntiEvent *paePF);

							//@cmember	undo helper
	void 	HandleReplaceRangeUndo(LONG cchOld, LONG cchNew, 
						IUndoBuilder *publdr, IAntiEvent *paeCF,
						IAntiEvent *paePF); 

									//@cmember	Insert a range of text helper
									// for ReplaceRange					
	LONG 	InsertRange(LONG cch, WCHAR const *pch);
	void 	DeleteRange(LONG cch);	//@cmember  Delete range of text helper
									// for ReplaceRange
		// support class for FindText
	class CTxtFinder
	{
	public:
		BOOL FindText(const CTxtPtr &tp, LONG cpMost, DWORD dwFlags, 
					  const WCHAR *pchToFind, LONG cchToFind, 
					  LONG &cpFirst, LONG &cpLast);
		//@cmember Same functionality as CTxtPtr::FindText wrapper
		
	private:
		inline BOOL CharComp(WCHAR ch1, WCHAR ch2) const;
		inline BOOL CharCompIgnoreCase(WCHAR ch1, WCHAR ch2) const;
		LONG FindChar(WCHAR ch, CTxtIStream &tistr);	
		//@cmember Advances cp to char matching ch from CTxtIStream
		LONG MatchString(const WCHAR *pchToFind, LONG cchToFind, CTxtIStream &tistr);
		//@cmember Advances cp if chars in pchToFind match next chars from CTxtIStream
		LONG MatchStringBiDi(const WCHAR *pchToFind, LONG cchToFind, CTxtIStream &tistr);
		//@cmember Like MatchString, but with checks for special Arabic/Hebrew chars
		
		LONG _cchToSearch;		//@cmember # of chars to search for current FindText call
		BOOL _fSearchForward;
		BOOL _fIgnoreCase;
		BOOL _fMatchAlefhamza;	//@cmember Flags derived from dwFlags from FindText for
		BOOL _fMatchKashida;	//	Arabic/Hebrew searches
		BOOL _fMatchDiac;
		int _iDirection;		//@cmember +/-1 to step through pchToFind
	};

	LONG		_cp;		//@cmember	Character position in text stream
#ifdef DEBUG
	const WCHAR *_pchCp;	// Points to string at cp for ease in debugging
#endif

public:
	CTxtEdit *	_ped;		//@cmember	Ptr to text edit class needed for
							//  things like word break proc and used a lot
							//  by derived classes
};

/*
 *	CTxtIStream
 *
 *	@class
 *		Refinement of the CTxtPtr class which implements an istream-like interface.
 *		Given a CTxtPtr and a direction, a CTxtFinder object returns a char
 *		for every call to GetChar.  No putzing around with the buffer gap is 
 *		necessary, and expensive calls to Move and GetPch are kept to an
 *		absolute minimum.
 *		
 *	@base 	private | CTxtPtr
 *
 *	@devnote
 *		At present, this class is used in the implementation of the CTxtFinder
 *		class.  Finds require fast scanning of the sequence of characters leading
 *		in either direction from the cp.  Calls to Move and GetPch slow down
 *		such scanning significantly, so this class implements a unidirectional 
 *		istream-like scanner which avoids unnecessary calls to these expensive
 *		CTxtPtr methods.
 */
class CTxtIStream : private CTxtPtr
{
public:
	enum { DIR_FWD, DIR_REV };
	typedef WCHAR (CTxtIStream::*PFNGEWCHAR)();

							//@cmember Creates istr to read in iDir
	CTxtIStream(const CTxtPtr &tp, int iDir);

	inline WCHAR GetChar() 	//@cmember Returns next char in stream dir
		{ return (this->*_pfnGetChar)(); }
 
private:
	WCHAR GetNextChar();	//@cmember Returns next char in fwd dir	
	WCHAR GetPrevChar();	//@cmember Returns next char in rev dir

 	void FillPchFwd();		//@cmember Refreshes _pch and _cch with chars in fwd dir
 	void FillPchRev();		//@cmember Refreshes _pch and _cch with chars in rev dir

	PFNGEWCHAR _pfnGetChar;	//@cmember Func ptr to routine which get next char in iDir
	LONG _cch;				//@cmember Count of valid chars in _pch in iDir
	const WCHAR *_pch;		//@cmember Next _cch chars in iDir
};

// =======================   Misc. routines  ====================================================

void	TxCopyText(WCHAR const *pchSrc, WCHAR *pchDst, LONG cch);
//LONG	TxFindEOP(const WCHAR *pchBuff, LONG cch);
INT		CALLBACK TxWordBreakProc(WCHAR const *pch, INT ich, INT cb, INT action);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_rtfconv.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFCONV.H -- RichEdit RTF Converter Base Class Definition |
 *
 *	Description:
 *		This file contains the type declarations used by both the RTF reader
 *		and writer for the RICHEDIT control
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		sz's in the RTF*.? files usually refer to LPSTRs, not LPWSTRs
 *
 *	Copyright (c) 1995-2002, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFCONV_H
#define __RTFCONV_H

#include "_edit.h"
#include "_array.h"
#include "_range.h"
#include "_rtext.h"
#include "tokens.h"

extern const KEYWORD rgKeyword[];
extern const KEYWORD rgShapeKeyword[];

#define	LBRACE	TEXT('{')
#define	BSLASH	TEXT('\\')
#define	RBRACE	TEXT('}')
#define ZERO	TEXT('0')

// Character property bits like an ASCII-only ANSI C LC_CTYPE types
#define fUC			0x01		// A-Z
#define	fLC			0x02		// a-z
#define fDG			0x04		// 0-9
#define	fSP			0x08		// Space chars
#define	fPN			0x10		// Punctuation chars
#define fCT			0x20		// Control chars
#define	fBL			0x40		// Blank chars
#define fHX			0x80		// 0-9, a-f, or A-F

#define	fAlpha		(fUC + fLC)
#define	fAlphaNum	(fAlpha + fDG)

extern const BYTE rgbCharClass[256];

#define Classify(_ch)		(rgbCharClass[_ch])
#define IsLC(_ch)			((Classify(_ch) & fLC))
#define IsASCIIAlpha(_ch)	((Classify(_ch) & fAlpha))
#define IsDigit(_ch)		((Classify(_ch) & fDG))
#define IsXDigit(_ch)		((Classify(_ch) & fHX))
#define IsAlphaNum(_ch) 	((Classify(_ch) & fAlphaNum))
#define IsAlphaNumBlank(_ch) ((Classify(_ch) & (fAlphaNum + fBL)))

template <class T> unsigned int DiffPtrs(T *pA, T *pB)
{
	return pA - pB;
}

//#define DiffPtrs(_pA, _pB, _type) ((UINT) (((_type *) (_pA)) - ((_type *) (_pB))))

extern INT  cKeywords;
extern INT  cShapeKeywords;
extern const COLORREF g_Colors[];
extern const char szEndGroupCRLF[];

#define szaCRLF		(BYTE *)&szEndGroupCRLF[1]

/*
 *		Converter Error Codes
 */
enum
{
	ecNoError = 0,						// Success
	ecCantUnicode,
	ecColorTableOverflow,
	ecExpectingRtfKeyword,
	ecExpectingStartGroup,
	ecFontTableOverflow,
	ecGeneralFailure,
	ecKeywordTooLong,
	ecLexInitFailed,
	ecNoMemory,
	ecParserBusy,
	ecPutCharFailed,
	ecStackOverflow,
	ecStackUnderflow,
	ecUnexpectedChar,
	ecUnexpectedEOF,
	ecUnexpectedToken,
	ecUnGetCharFailed,
	ecTextMax,
	ecStreamOutObj,
	ecStreamInObj,
	ecTruncateAtCRLF,
	ecFormatCache,
	ecUTF8NotUsed,
	ecAbort,
	ecLastError							// Total error messages
};

typedef	INT	EC;

/*
 *	@struct RTFOBJECT |
 *		Object data transfer structure
 */
typedef struct _rtfobject
{
	SHORT	sType;				// @field object type (ROT_*)
	SHORT	sPictureType;		// @field specific type of sPicture
	SHORT	cBitsPerPixel;		// @field # bits per pixel, if bitmap
	SHORT	cColorPlanes;		// @field # color planes, if bitmap
	SHORT	cBytesPerLine;		// @field # bytes per raster line, if bitmap
	BOOL	fSetSize;			// @field Let client tell server the size
	LONG	xExt, yExt;			// @field dimensions in pixels for pictures, twips for
								//	for objects
	LONG	xScale, yScale;		// @field scaling percentage along axes
	SHORT	xExtGoal, yExtGoal;	// @field desired dimensions in twips for pictures
	RECT	rectCrop;			// @field cropping information in twips
	WCHAR *	szClass;			// @field object class
	WCHAR *	szName;				// @field object name

	// On RTF generation
	LONG	xExtPict, yExtPict;	// @field metafile dimensions
	LPBYTE	pbResult;			// metafile depiction of the object
	ULONG	cbResult;
} RTFOBJECT;

/*
 *	@enum ROTYPE | The values for OBJECT.sType
 *
 *		Keep this in sync with rgszROT in rtfwrit.cpp
 */
enum ROTYPE
{
	ROT_Bitmap,					// @emem Bitmap
	ROT_Metafile,				// @emem Metafile
	ROT_DIB,					// @emem Device-Independent Bitmap
	ROT_JPEG,					// @emem JPEG blip
	ROT_PNG,					// @emem PNG blip

	ROT_Embedded,				// @emem Embedded Object
	ROT_Link,					// @emem Linked Object
	ROT_AutoLink,				// @emem Autolink
	ROT_MacEdition,				// @emem Mac object

	ROT_EBookImage,				// @emem Ebook Image object
};

/*
 *		DEFINE's
 */
#define cachBufferMost		4096
#define	cachTextMax			( 512 + 1 )
#define	cachKeywordMax		( 32 + 1 )
#define	cachParamMax		( 11 + 1 )
#define cFooChunk			8
#define MAXTABLENEST		16

// Characters to give to RichEdit

#if	( cachTextMax - 1 ) % 2 == 1
#error "cachTextMax  - 1 MUST be even"
#endif

#if ( cachParamMax - 1 ) < 11
#error "cachParamMax MUST be >= 11"
#endif

/*
 * Some RTF defaults
 */
#ifdef NEVER
// we don't care about margins, just indents
#define dxDefaultLeftMargin		1800
#define dxDefaultRightMargin	1800

#else
#define dxDefaultLeftMargin		0
#define dxDefaultRightMargin	0
#endif

// next two in half points
#define	yDefaultFontSize		( 12 * 2 )
#define dyDefaultSuperscript	6

#define RESERVED_FONT_HANDLES	0x800

/*
 *	@struct TEXTFONT |
 *		text font structure
 */
typedef struct _textfont
{
	SHORT		sHandle;				// @field RTF input font handle
	BYTE		iCharRep;				// @field Font character repertoire
	BYTE		bPitchAndFamily;		// @field Font family
	SHORT		iFont;					// @field Font name index
	WCHAR		szName[LF_FACESIZE+1];	// @field Font name
	SHORT		sCodePage;				// @field Code page for font 
										// 			(INVALID_CODEPAGE == not set)
	BYTE		fNameIsDBCS;			// @field Indicates if szName is DBCS stuffed into Unicode buffer
	BYTE		fCpgFromSystem;			// @field Indicates is cpg was 
										// 			retrieved from system based
										//			on font name.
} TEXTFONT;

/*
 *		Global variables for the scope of the entire parser/reader
 */
#ifdef DEBUG
extern CHAR *		rgszParseError[];
extern CHAR *		szDest[];
#endif

#define cchMaxNumText 16

// tagged font info
typedef struct _tfi
{
	WCHAR *szNormalName;
	WCHAR *szTaggedName;
	BYTE iCharRep;
} TFI;

typedef CArray<TEXTFONT> TEXTFONTS;
typedef CArray<COLORREF> COLORREFS;

const short INVALID_CODEPAGE = -1;
const short INVALID_LANGUAGE = -1;

// default value for \ucN tag
const int iUnicodeCChDefault = 1;

/*
 *	CRTFConverter
 *
 *	@class	RTF converter base class used by CRTFRead and CRTFWrite
 */
class CRTFConverter
{
//@access Protected Data Members
protected:
	TEXTFONTS	_fonts;				// @cmember Font table
	COLORREFS	_colors;			// @cmember Color table
	EC			_ecParseError;		// @cmember Error code
	CTxtEdit *	_ped;				// @cmember CTxtEdit
	CTxtRange *	_prg;				// @cmember CTxtRange to replace/write from
	EDITSTREAM *_pes;				// @cmember EDITSTREAM to use
	DWORD		_dwFlags;			// @cmember See #defines below
	CCharFormat	_CF;				// @cmember Character formatting info
	BYTE		_iCharRep;			// @cmember Converter char set (ANSI, UTF7, UTF8)
	char		_bTableLevel;		// @cmember Table level (0 for no table)
	char		_bTableLevelIP;		// @cmember Table level at insertion point

	static TFI *_rgtfi;				// @cmember Pointer to the first font substitute record
	static INT _ctfi;				// @cmember Number of the font substitute records
	static WCHAR *_pchFontSubInfo;	// @cmember Font strings for substitutions

//@access Protected Functions
	void ReadFontSubInfo(void);

	enum PARSEFONTNAME { PFN_SUCCESS, PFN_FAIL, PFN_EOF };
	PARSEFONTNAME ParseFontName(WCHAR *pchBuf,
							WCHAR *pchBufMax,
							WCHAR chDelimiter,
							WCHAR **pszName,
							BYTE &iCharRep,
							BOOL &fSetCharSet,
							WCHAR **ppchBufNew) const;
	BOOL FontSubstitute(WCHAR *szTaggedName, 
						WCHAR *szNormalName, 
						BYTE *piCharRep);
	BOOL FindTaggedFont(const WCHAR *szNormalName, BYTE iCharRep, WCHAR **ppchTaggedName);	 
									// @cmember	Find font name with additional special tag 
									// corresponding to szNormalName & iCharRep
	BOOL IsTaggedFont(const WCHAR *szName, BYTE *piCharRep, WCHAR **ppchNormalName);
								   	// @cmember Figure out is szName font name with additional tag
								   	// corresponding to piCharRep

//@access Public Functions

public:
	CRTFConverter(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags, BOOL fRead);
	inline ~CRTFConverter();
	static void FreeFontSubInfo();

protected:
#if defined(DEBUG)
	// for capturing RTF as its read from or written to a file
	HANDLE _hfileCapture;
#endif
};

#define	fRTFNoObjs	1
#define	fRTFFE	8					// Check this

#define IsUTF8	((_dwFlags & (0xFFFF0000 | SF_USECODEPAGE)) \
					 == ((CP_UTF8 << 16) | SF_USECODEPAGE))

/*
 *	CRTFConverter::~CRTFConverter()
 *
 *	@mfunc
 *		RTF Converter destructor
 */
inline CRTFConverter::~CRTFConverter()
{
#if defined(DEBUG)
	if(_hfileCapture)
	{
		CloseHandle(_hfileCapture);
		_hfileCapture = NULL;
	}
#endif
}

#endif // __RTFCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_rtfwrit.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFWRIT.H -- RichEdit RTF Writer Class Definition |
 *
 *	Description:
 *		This file contains the type declarations used by the RTF writer
 *		for the RICHEDIT control
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFWRIT_H
#define __RTFWRIT_H

#include "_rtfconv.h"
extern const KEYWORD rgKeyword[];

#define PUNCT_MAX	1024


class CRTFWrite ;


class RTFWRITEOLESTREAM : public OLESTREAM
{
	OLESTREAMVTBL OLEStreamVtbl;	// @member - memory for  OLESTREAMVTBL
public:
	 CRTFWrite *Writer;				// @cmember CRTFwriter to use

	RTFWRITEOLESTREAM::RTFWRITEOLESTREAM ()
	{
		lpstbl = & OLEStreamVtbl ;
	}		
};

enum									// Control-Word-Format indices
{
	CWF_STR, CWF_VAL, CWF_GRP, CWF_AST, CWF_GRV, CWF_SVAL
};

#define chEndGroup RBRACE

/*
 *	CRTFWrite
 *
 *	@class	RTF writer class.
 *
 *	@base	public | CRTFConverter
 *
 */
class CRTFWrite : public CRTFConverter
{
private:
	LONG		_cchBufferOut;			//@cmember # chars in output buffer
	LONG		_cchOut;				//@cmember Total # chars put out
	LONG		_cbCharLast;			//@cmember # bytes in char last written

	BYTE		_fBullet : 1;			//@cmember Currently in a bulleted style
	BYTE		_fBulletPending : 1;	//@cmember Set if next output should bull
	BYTE		_fNeedDelimeter : 1;	//@cmember Set if next char must be nonalphanumeric
	BYTE        _fIncludeObjects : 1;   //@cmember Set if objects should be included in stream
	BYTE		_fRangeHasEOP : 1;		//@cmember Set if _prg has EOP
	BYTE		_fNCRForNonASCII : 1;	//@cmember Put /uN for nonASCII
	BYTE		_fRowHasNesting : 1;	//@cmember Row has nested row(s)
	BYTE		_fFieldResult : 1;		//@cmember Writing out a fldrslt

	BYTE		_iCell;					//@cmember Index of current cell in current row
	BYTE		_cCell;					//@cmember Count of CELLs in current row

	char *		_pchRTFBuffer;			//@cmember Ptr to RTF write buffer
	BYTE *		_pbAnsiBuffer;			//@cmember Ptr to buffer used for conversion
	char *		_pchRTFEnd;				//@cmember Ptr to RTF-write-buffer end
	LONG		_symbolFont;			//@cmember Font number of Symbol used by Bullet style
	RTFWRITEOLESTREAM RTFWriteOLEStream;//@cmember RTFWRITEOLESTREAM to use
	LONG		_nHeadingStyle;			//@cmember Deepest heading # found
	LONG		_nNumber;				//@cmember Current number in para (1-based)
	LONG		_nFont;					//@cmember Current number font index
	LONG		_nFieldFont;			//@cmember font change during fieldResult, to make RE30 hyperlink code happy
	LONG		_cpg;					//@cmember Current number code page
	const CParaFormat *_pPF;			//@cmember Current para format

										//@cmember Build font/color tables
	EC			BuildTables		(CRchTxtPtr &rtp, LONG cch, BOOL& fNameIsDBCS);
	inline void	CheckDelimiter()		//@cmember Put ' ' if need delimiter
	{
		if(_fNeedDelimeter)
		{
			_fNeedDelimeter = FALSE;
			PutChar(' ');
		}
	};

										//@cmember Handle table delimeters
	BOOL		CheckInTable	(CRchTxtPtr *prtp, LONG *pcch);
	BOOL		FlushBuffer		();		//@cmember Stream out output buffer
										//@cmember Get index of <p colorref>
	LONG		LookupColor		(COLORREF colorref);
										//@cmember Get font index for <p pCF>
	LONG		LookupFont		(CCharFormat const *pCF);
										//@cmember Translate backing idx to RTF idx
	LONG		TranslateColorIndex(LONG  icr, const CParaFormat *pPF);
										//@cmember "printf" to output buffer
	BOOL _cdecl printF			(CONST CHAR *szFmt, ...);
										//@cmember Put char <p ch> in output buffer
	EC			PutBorders		(BOOL fInTable);
	BOOL		PutChar			(CHAR ch);
										//@cmember Put control word <p iCtrl> with value <p iValue> into output buffer
	BOOL		PutCtrlWord		(LONG iFormat, LONG iCtrl, LONG iValue = 0);
										//@cmember Put shape control word <p iCtrl> with value <p iValue>
	BOOL		PutShapeParm	(LONG iCtrl, LONG iValue);
										//@cmember Put string <p sz> in output buffer
	void		PutPar();				//@cmember Put \par with appropriate \r\n
	BOOL		Puts			(CHAR const *sz, LONG cb);
										//@cmember Write char format <p pCF>
	LONG		WriteCharFormat	(CRchTxtPtr *prtp, LONG cch, LONG nCodePage);
	EC			WriteColorTable	();		//@cmember Write color table
	EC			WriteFontTable	();		//@cmember Write font table
	EC			WriteInfo		();		//@cmember Write document info
										//@cmember Write para format <p pPF>
	EC			WriteParaFormat	(CRchTxtPtr *prtp, LONG *pcch);
										//@cmember Write PC data <p szData>
	EC			WritePcData		(const WCHAR *szData, INT nCodePage = CP_ACP, BOOL fIsDBCS = FALSE );
										//@cmember Write <p cch> chars of text <p pch>
	EC			WriteText		(LONG cwch, LPCWSTR lpcwstr, INT nCodePage, BOOL fIsDBCS,
								 BOOL fQuadBackSlash);
	EC			WriteTextChunk	(LONG cwch, LPCWSTR lpcwstr, INT nCodePage, BOOL fIsDBCS,
								 BOOL fQuadBackSlash);

// OBJECT
	EC			WriteObject		(LONG cp, COleObject *pobj);
	BOOL		GetRtfObjectMetafilePict(HGLOBAL hmfp, RTFOBJECT &rtfobject, SIZEL &sizelGoal);
	BOOL		GetRtfObject	(REOBJECT &reobject, RTFOBJECT &rtfobject);
	EC			WriteRtfObject	(RTFOBJECT & rtfOb, BOOL fPicture);
	BOOL		ObjectWriteToEditstream(REOBJECT &reObject, RTFOBJECT &rtfobject);
	EC			WritePicture	(RTFOBJECT &rtfObject);
	EC			WriteDib		(RTFOBJECT &rtfObject);
	EC			WriteBackgroundInfo(CDocInfo *pDocInfo);

	enum 		{ MAPTOKWD_ANSI, MAPTOKWD_UNICODE };
	inline BOOL	MapsToRTFKeywordW(WCHAR wch);
	inline BOOL	MapsToRTFKeywordA(char ch);
	int 		MapToRTFKeyword	(void *pv, int cch, int iCharEncoding, BOOL fQuadBackSlash);

public:
											//@cmember Constructor
	CRTFWrite(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags);
	~CRTFWrite() {FreePv(_pbAnsiBuffer);}	//@cmember Destructor

	LONG		WriteRtf();				//@cmember Main write entry used by
										//  CLiteDTEngine
	LONG		WriteData		(BYTE * pbBuffer, LONG cbBuffer);
	LONG		WriteBinData	(BYTE * pbBuffer, LONG cbBuffer);

};										


#endif // __RTFWRIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_tomdoc.h ===
/*
 *	@doc TOM
 *
 *	@module _tomdoc.H -- CTxtDoc Class |
 *	
 *		This class implements the TOM ITextDocument interface
 *	
 *	@devnote
 *		This class depends on the internal RichEdit CTxtStory class, but is
 *		separate, that is, a CTxtDoc has a ptr to the internal CTxtStory,
 *		rather than CTxtDoc deriving from ITextDocument.  This choice
 *		was made so that edit control instances that don't use the
 *		ITextDocument interface don't have to have the extra vtable ptr.
 *
 *		When this class is destroyed, it doesn't destroy the internal
 *		CTxtStory object (CTxtEdit::_pdoc).  However the TOM client's
 *		perception is that the document is no longer in memory, so the internal
 *		document should be cleared.  It's the client's responsibility to save
 *		the document, if desired, before releasing it.
 *
 *	@future
 *		Generalize so that CTxtDoc can handle multiple CTxtStory's.
 */

#ifndef _tomdoc_H
#define _tomdoc_H

#include "_range.h"

class CTxtDoc : public ITextDocument
{
//@access Public methods
public:
	CTxtDoc(CTxtEdit *ped);

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

    // ITextDocument methods
	STDMETHODIMP GetName (BSTR * pName);		//@cmember Get document filename
	STDMETHODIMP GetCount (long *pCount);		//@cmember Get count of stories in document
	STDMETHODIMP _NewEnum(IEnumRange **ppenum);	//@cmember Get stories enumerator
	STDMETHODIMP Item (long Index, ITextRange **pprange);//@cmember Get <p Index>th story
	STDMETHODIMP Save (VARIANT * pVar);			//@cmember Save this document
	STDMETHODIMP BeginEditCollection ();		//@cmember Turn on undo grouping
	STDMETHODIMP EndEditCollection ();			//@cmember Turn off undo grouping

//@access Private data
private:
	CTxtEdit *		_ped;		//@cmember CTxtEdit this belongs to
	TCHAR *			_pName;		//@cmember Filename of document
	LONG			_cRefs;		//@cmember Reference count
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_undoid.h ===
/*
 *	_undoid.h
 *
 *	Purpose:
 *		Undo ID defintions.  These ID's are used to lookup string names
 *		in our resources for the various undo operations
 *
 *	Author:
 *		AlexGo  4/13/95
 */

#ifndef __UNDOID_H__
#define __UNDOID_H__

//
//	typing operations
//

#define UID_TYPING			1
#define	UID_REPLACESEL		2
#define UID_DELETE			3

//
//	data transfer operations
//

#define	UID_DRAGDROP		4
#define UID_CUT				5
#define UID_PASTE			6
#define UID_LOAD			7

#endif // __UNDOID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_runptr.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RUNPTR.H -- Text run and run pointer class defintion |
 *	
 *	Original Author:	<nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95	alexgo	Commenting and Cleanup
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#ifndef _RUNPTR_H
#define _RUNPTR_H

#include "_array.h"
#include "_doc.h"

typedef CArray<CTxtRun> CRunArray;

/*
 *	CRunPtrBase
 *
 *	@class	Base run pointer functionality.  Keeps a position within an array
 *  	of text runs.
 *
 *	@devnote	Run pointers go through three different possible states :
 *
 *	NULL:	there is no data and no array (frequently a startup condition) <nl>
 *			<mf CRunPtrBase::SetRunArray> will transition from this state to 
 *			the Empty state.  It is typically up to the derived class to
 *			define when that method should be called. IsValid() fails. <nl>
 *
 *			<md CRunPtrBase::_pRuns> == NULL <nl>
 *			<md CRunPtrBase::_iRun> == 0 <nl>
 *			<md CRunPtrBase::_ich> == 0 <nl>
 *
 *	Empty:	an array class exists, but there is no data (can happen if all 
 *			of the elements in the array are deleted).  IsValid() fails.<nl>
 *	 		<md CRunPtrBase::_pRuns> != NULL <nl>
 *			<md CRunPtrBase::_iRun> == 0 <nl>
 *			<md CRunPtrBase::_ich> <gt>= 0 <nl>
 *			<md CRunPtrBase::_pRuns-<gt>Count()> == 0 <nl>
 *
 *	Normal:	the array class exists and has data; IsValid() succeeds and
 *			<md CRunPtrBase::_pRuns-<gt>Elem[] is defined <nl>
 *			<md CRunPtrBase::_pRuns> != NULL <nl>
 *			<md CRunPtrBase::_iRun> >= 0 <nl>
 *			<md CRunPtrBase::_ich> >= 0 <nl>
 *			<md _pRuns>-<gt>Count() > 0 <nl>		
 *	
 *	Note that in order to support the empty and normal states, the actual 
 *	array element at <md CRunPtrBase::_iRun> must be explicitly fetched in
 *	any method that may need it.
 *
 *	Currently, there is no way to transition to the NULL state from any of
 *  the other states.  If we needed to, we could support that by explicitly 
 *	fetching the array from the document on demand.
 *
 *	Note that only <md CRunPtrBase::_iRun> is kept.  We could also keep 
 * 	a pointer to the actual run (i.e. _pRun).  Earlier versions of this
 *	engine did in fact do this.  I've opted to not do this for several
 *	reasons: <nl>
 *		1. If IsValid(), _pRun is *always* available by calling Elem(_iRun).
 * 		Therefore, there is nominally no need to keep both _iRun and _pRun.<nl>
 *		2. Run pointers are typically used to either just move around
 *		and then fetch data or move and fetch data every time (like during 
 *		a measuring loop).  In the former case, there is no need to always
 *		bind _pRun; you can just do it on demand.  In the latter case, the
 *		two models are equivalent.  
 */

class CRunPtrBase
{
	friend class CDisplayML;
	friend class CDisplaySL;

//@access Public methods
public:

#ifdef DEBUG
	BOOL	Invariant() const;				//@cmember	Invariant tests
	void	ValidatePtr(void *pRun) const;	//@cmember	Validate <p pRun>
	LONG 	CalcTextLength() const;			//@cmember  Get total cch in runs
#define	VALIDATE_PTR(pRun)	ValidatePtr(pRun)

#else
#define	VALIDATE_PTR(pRun)
#endif // DEBUG

	CRunPtrBase(CRunArray *pRuns);			//@cmember	Constructor
	CRunPtrBase(CRunPtrBase& rp);			//@cmember	Constructor

	// Run Control
	void	SetRunArray(CRunArray *pRuns)	//@cmember Set run array for this
	{										// run ptr
		_pRuns = pRuns;
	}
	BOOL 	SetRun(LONG iRun, LONG ich);	//@cmember Set this runptr to run
											// <p iRun> & char offset <p ich>
	BOOL	NextRun();						//@cmember Advance to next run
	BOOL	PrevRun();						//@cmember Go back to prev run
	BOOL	ChgRun(LONG cRun)				//@cmember Move <p cRun> runs
	{										// returning TRUE if successful
		return SetRun(_iRun + cRun, 0);
	}	
											//@cmember Count <p cRun> runs 
	LONG	CountRuns(LONG &cRun,			// returning cch counted and
				LONG cchMax,				// updating <p cRun>
				LONG cp,
				LONG cchText) const;
											//@cmember Find run range limits
	void	FindRun (LONG *pcpMin,
				LONG *pcpMost, LONG cpMin, LONG cch, LONG cchText) const;

	CTxtRun * GetRun(LONG cRun) const;		//@cmember Retrieve run element at 
											// offset <p cRun> from this run
	LONG	Count() const					//@cmember	Get count of runs
	{
		return _pRuns->Count();
	}
	BOOL	SameRuns(CRunPtrBase *prp)		//@cmember Return TRUE iff same runs
	{
		return _pRuns == prp->_pRuns;
	}
	BOOL	SameRun(CRunPtrBase *prp)
	{
		return SameRuns(prp) && _iRun == prp->_iRun;
	}

	// Character position control
								//@cmember	Set cp for this run ptr = <p cp>
	LONG 	BindToCp(LONG cp, LONG cchText = tomForward);
	LONG 	CalculateCp() const;//@cmember	Add _cch's up to _iRun, _ich
	LONG	Move(LONG cch);		//@cmember	Move cp by <p cch> chars

	void 	AdjustBackward();	//@cmember	If on the edge of two runs, 
								// adjust to end of left (previous) run
	void	AdjustForward();	//@cmember	If at the edge of two runs,
								// adjust to start of right (next) run
	LONG 	GetIch() const		//@cmember	Return <md CRunPtrBase::_ich>
				{Assert(IsValid()); return _ich;}
	LONG 	GetIRun() const		//@cmember	Return <md CRunPtrBase::_iRun>
				{Assert(IsValid()); return _iRun;}
	void 	SetIch(LONG ich)	//@cmember	Set <md CRunPtrBase::_ich>
				{Assert(IsValid()); _ich = ich;}
	LONG	GetCchLeft() const;	//@cmember	Return GetRun(0)->_cch - GetIch()								
	inline BOOL	IsValid() const	//@cmember	Return FALSE if run ptr is in
	{							// empty or NULL states.  TRUE otherwise
		return _pRuns && _pRuns->Count();
	}

	void	SetToNull();		//@cmember	Clears data from run pointer

//@access Protected Data
protected:
	CRunArray *	_pRuns;	    	//@cmember	Pointer to CTxtRun array
	LONG 		_iRun;  	    //@cmember	Index of current run in array
	LONG 		_ich;		    //@cmember	Char offset inside current run
};


/*
 *	CRunPtr	(template)
 *
 *	@class	a template over CRunPtrBase allowing for type-safe versions of
 *		run pointers
 * 
 *	@tcarg	class 	| CElem | run array class to be used
 *
 *	@base	public | CRunPtrBase
 */
template <class CElem>
class CRunPtr : public CRunPtrBase
{
public:
	CRunPtr (void)								//@cmember	Constructor
		: CRunPtrBase (0) {}
	CRunPtr (CRunArray *pRuns)					//@cmember	Constructor
		: CRunPtrBase (pRuns) {}
	CRunPtr (CRunPtrBase& rp)					//@cmember	Constructor
		: CRunPtrBase (rp) {}

	// Array management 
										
	CElem *	Add (LONG cRun, LONG *pielIns)	//@cmember Add <p cRun> 	
	{											// elements at end of array
		return (CElem *)_pRuns->Add(cRun, pielIns);
	}
										
	CElem *	Insert (LONG cRun)					//@cmember Insert <p cRun>
	{											// elements at current pos
		return (CElem *)_pRuns->Insert(_iRun, cRun);
	}
										
	void 	Remove (LONG cRun)	//@cmember Remove <p cRun>
	{											// elements at current pos
		_pRuns->Remove (_iRun, cRun);
	}
										//@cmember	Replace <p cRun> elements
										// at current position with those
										// from <p parRun>
	BOOL 	Replace (LONG cRun, CArrayBase *parRun)
	{
		return _pRuns->Replace(_iRun, cRun, parRun);
	}

	CElem *	Elem(LONG iRun) const		//@cmember	Get ptr to run <p iRun>
	{
		return (CElem *)_pRuns->Elem(iRun);
	}
										
	CElem *	GetRun(LONG cRun) const		//@cmember	Get ptr <p cRun> runs
	{									//  away from current run
		return Elem(_iRun + cRun);
	}

	void	IncPtr(CElem *&pRun) const	//@cmember	Increment ptr <p pRun>
	{
		VALIDATE_PTR(pRun);				// Allow invalid ptr after ++ for
		pRun++;							//  for loops
	}
										
	CElem *	GetPtr(CElem *pRun, LONG cRun) const//@cmember Get ptr <p cRun>
	{											// runs away from ptr <p pRun>
		VALIDATE_PTR(pRun + cRun);
		return pRun + cRun;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_textnot.h ===
/*
 *	_TXTNOT.H
 *
 *	Purpose:
 *		Text Notification Manager declarations
 *
 *	Author:
 *		Honwch	1/12/2000
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _TXTNOT_H_
#define _TXTNOT_H_

#include "_notmgr.h"

class CTxtEdit;

/*
 *	CTextNotify
 *
 *	@class
 *		CTextNotify forwards notification to Messgae Filter
 *
 */
class CTextNotify : public ITxNotify
{
//@access Public Methods
public:
	CTextNotify(CTxtEdit * ped) { _ped = ped; }
	~CTextNotify();
	//
	// ITxNotify Interface
	//
	void 	OnPreReplaceRange( 
				LONG cp, 
				LONG cchDel, 
				LONG cchNew,
				LONG cpFormatMin, 
				LONG cpFormatMax, 
				NOTIFY_DATA *pNotifyData );

	void 	OnPostReplaceRange( 
				LONG cp, 
				LONG cchDel, 
				LONG cchNew,
				LONG cpFormatMin, 
				LONG cpFormatMax, 
				NOTIFY_DATA *pNotifyData );

	void	Zombie() {_ped = NULL;};

	BOOL	Add(ITxNotify *pMsgFilterNotify);
	BOOL	Remove(ITxNotify *pMsgFilterNotify);

//@access Protected Methods
protected:
	CTxtEdit	*_ped;
	ITxNotify	*_pMsgFilterNotify;
};

#endif _TXTNOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_tomfmt.h ===
/*
 *	@doc
 *
 *	@module _tomfmt.h -- CTxtFont and CTxtPara Classes |
 *	
 *		This class implements the TOM ITextFont and ITextPara interfaces
 *	
 *	Author: <nl>
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _tomformat_H
#define _tomformat_H

#include "_range.h"

extern const BYTE g_rgREtoTOMAlign[];

// CTxtFormat: base class for CTxtFont and CTxtPara

class CTxtFormat
{
protected:
	CTxtFormat(CTxtRange *prg);
	~CTxtFormat();

	long		_cRefs;
	CTxtRange *	_prg;

	HRESULT	CanChange(long *pBool, BOOL fPara);
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, long Type, long Value);
	HRESULT	IsTrue		 (BOOL f, long *pB);
	BOOL	IsZombie()	 {return _prg && _prg->IsZombie();}
};


class CTxtFont : public ITextFont, CTxtFormat
{
	friend	CTxtRange;
	friend	CTxtEdit;

	CCharFormat	_CF;
	DWORD		_dwMask;			// CHARFORMAT2 mask
	TMPDISPLAYATTR	_tmpDisplayAttr;	// Temp display attribute
	union
	{
	  DWORD _dwFlags;				// All together now
	  struct
	  {
		DWORD _fApplyLater : 1;		// Delay call to _prg->CharFormatSetter()
		DWORD _fCacheParms : 1;		// Update _CF now but not on GetXs
		DWORD _fApplyToTmp : 1;		// Apply change to temp. display attributes
	  };
	};

public:
	CTxtFont(CTxtRange *prg);

	// IUnknown methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch methods
	STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
	STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
	STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

	// ITextFont methods
	STDMETHODIMP GetDuplicate(ITextFont **ppFont);
	STDMETHODIMP SetDuplicate(ITextFont *pFont);
	STDMETHODIMP CanChange(long *pB);
	STDMETHODIMP IsEqual(ITextFont *pFont, long *pB);
	STDMETHODIMP Reset(long Value);
	STDMETHODIMP GetStyle(long *pValue);
	STDMETHODIMP SetStyle(long Value);
	STDMETHODIMP GetAllCaps(long *pValue);
	STDMETHODIMP SetAllCaps(long Value);
	STDMETHODIMP GetAnimation(long *pValue);
	STDMETHODIMP SetAnimation(long Value);
	STDMETHODIMP GetBackColor(long *pValue);
	STDMETHODIMP SetBackColor(long Value);
	STDMETHODIMP GetBold(long *pValue);
	STDMETHODIMP SetBold(long Value);
	STDMETHODIMP GetEmboss(long *pValue);
	STDMETHODIMP SetEmboss(long Value);
	STDMETHODIMP GetForeColor(long *pValue);
	STDMETHODIMP SetForeColor(long Value);
	STDMETHODIMP GetHidden(long *pValue);
	STDMETHODIMP SetHidden(long Value);
	STDMETHODIMP GetEngrave(long *pValue);
	STDMETHODIMP SetEngrave(long Value);
	STDMETHODIMP GetItalic(long *pValue);
	STDMETHODIMP SetItalic(long Value);
	STDMETHODIMP GetKerning(float *pValue);
	STDMETHODIMP SetKerning(float Value);
	STDMETHODIMP GetLanguageID(long *pValue);
	STDMETHODIMP SetLanguageID(long Value);
	STDMETHODIMP GetName(BSTR *pbstr);
	STDMETHODIMP SetName(BSTR bstr);
	STDMETHODIMP GetOutline(long *pValue);
	STDMETHODIMP SetOutline(long Value);
	STDMETHODIMP GetPosition(float *pValue);
	STDMETHODIMP SetPosition(float Value);
	STDMETHODIMP GetProtected(long *pValue);
	STDMETHODIMP SetProtected(long Value);
	STDMETHODIMP GetShadow(long *pValue);
	STDMETHODIMP SetShadow(long Value);
	STDMETHODIMP GetSize(float *pValue);
	STDMETHODIMP SetSize(float Value);
	STDMETHODIMP GetSmallCaps(long *pValue);
	STDMETHODIMP SetSmallCaps(long Value);
	STDMETHODIMP GetSpacing(float *pValue);
	STDMETHODIMP SetSpacing(float Value);
	STDMETHODIMP GetStrikeThrough(long *pValue);
	STDMETHODIMP SetStrikeThrough(long Value);
	STDMETHODIMP GetSubscript(long *pValue);
	STDMETHODIMP SetSubscript(long Value);
	STDMETHODIMP GetSuperscript(long *pValue);
	STDMETHODIMP SetSuperscript(long Value);
	STDMETHODIMP GetUnderline(long *pValue);
	STDMETHODIMP SetUnderline(long Value);
	STDMETHODIMP GetWeight(long *pValue);
	STDMETHODIMP SetWeight(long Value);

//@access Private ITextFont helper methods
private:
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, DWORD dwMask, long Type, long Value);
	HRESULT	EffectGetter (long *ptomBool, DWORD dwMask);
	HRESULT	EffectSetter (long Value, DWORD dwMask, DWORD dwEffect);
	HRESULT	FormatSetter (DWORD dwMask);
	HRESULT	UpdateFormat ();
};


class CTxtPara : public ITextPara, CTxtFormat
{
	friend	CTxtRange;
	friend	CTxtEdit;

	CParaFormat	_PF;
	DWORD		_dwMask;			// PARAFORMAT2 mask
	union
	{
	  DWORD _dwFlags;				// All together now
	  struct
	  {
		DWORD _fApplyLater : 1;		// Delay call to _prg->ParaFormatSetter()
		DWORD _fCacheParms : 1;		// Update _PF now but not on GetXs
	  };
	};
	LONG		_rgxTabs[MAX_TAB_STOPS];// Place to store tabs till committed

public:
	CTxtPara(CTxtRange *prg);
	~CTxtPara();

	// IUnknown methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch methods
	STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
	STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
	STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

	// ITextPara methods
	STDMETHODIMP GetDuplicate(ITextPara **ppPara);
	STDMETHODIMP SetDuplicate(ITextPara *pPara);
	STDMETHODIMP CanChange(long *pB);
	STDMETHODIMP IsEqual(ITextPara *pPara, long *pB);
	STDMETHODIMP Reset(long Value);
	STDMETHODIMP GetStyle(long *pValue);
	STDMETHODIMP SetStyle(long Value);

	STDMETHODIMP GetAlignment(long *pValue);
	STDMETHODIMP SetAlignment(long Value);
	STDMETHODIMP GetHyphenation(long *pValue);
	STDMETHODIMP SetHyphenation(long Value);
	STDMETHODIMP GetFirstLineIndent(float *pValue);
	STDMETHODIMP GetKeepTogether(long *pValue);
	STDMETHODIMP SetKeepTogether(long Value);
	STDMETHODIMP GetKeepWithNext(long *pValue);
	STDMETHODIMP SetKeepWithNext(long Value);
	STDMETHODIMP GetLeftIndent(float *pValue);
	STDMETHODIMP GetLineSpacing(float *pValue);
	STDMETHODIMP GetLineSpacingRule(long *pValue);
    STDMETHODIMP GetListAlignment(long * pValue);
    STDMETHODIMP SetListAlignment(long Value);
    STDMETHODIMP GetListLevelIndex(long * pValue);
    STDMETHODIMP SetListLevelIndex(long Value);
    STDMETHODIMP GetListStart(long * pValue);
    STDMETHODIMP SetListStart(long Value);
    STDMETHODIMP GetListTab(float * pValue);
    STDMETHODIMP SetListTab(float Value);
	STDMETHODIMP GetListType(long *pValue);
	STDMETHODIMP SetListType(long Value);
	STDMETHODIMP GetNoLineNumber(long *pValue);
	STDMETHODIMP SetNoLineNumber(long Value);
	STDMETHODIMP GetPageBreakBefore(long *pValue);
	STDMETHODIMP SetPageBreakBefore(long Value);
	STDMETHODIMP GetRightIndent(float *pValue);
	STDMETHODIMP SetRightIndent(float Value);
	STDMETHODIMP SetIndents(float StartIndent, float LeftIndent, float RightIndent);
	STDMETHODIMP SetLineSpacing(long LineSpacingRule, float LineSpacing);
	STDMETHODIMP GetSpaceAfter(float *pValue);
	STDMETHODIMP SetSpaceAfter(float Value);
	STDMETHODIMP GetSpaceBefore(float *pValue);
	STDMETHODIMP SetSpaceBefore(float Value);
	STDMETHODIMP GetWidowControl(long *pValue);
	STDMETHODIMP SetWidowControl(long Value);

	STDMETHODIMP GetTabCount(long *pValue);
	STDMETHODIMP AddTab(float tpPos, long tbAlign, long tbLeader);
	STDMETHODIMP ClearAllTabs();
	STDMETHODIMP DeleteTab(float tbPos);
	STDMETHODIMP GetTab(long iTab, float *ptbPos, long *ptbAlign, long *ptbLeader);

	HRESULT	FormatSetter (DWORD dwMask);

//@access Private ITextPara helper methods
private:
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, DWORD dwMask, long Type, long Value);
	HRESULT	EffectGetter (long * ptomBool, DWORD dwMask);
	HRESULT	EffectSetter (long Value, DWORD dwMask);
	HRESULT	UpdateFormat ();
	void	CheckTabsAddRef();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_txtbrk.h ===
/*
 *		Text Breaker & Bit stream break array class definition
 *		
 *		File:    _txtbrk.h
 * 		Create:  Mar 29, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */


#ifndef _TXTBRK_H
#define _TXTBRK_H

// DEBUG definition
#ifdef BITVIEW
#define	BVDEBUG		_DEBUG
#define Assert		ASSERT
#else
#define BVDEBUG		DEBUG
#endif


// The number of buffer breaks before the sync point
#define	CWORD_TILLSYNC		3	// Thai wordbreak engine is expected to be in sync within 3 words
#define CCLUSTER_TILLSYNC	1	// Indic cluster is normally in sync in within 1

// Abstract Data type
#define ITEM				UINT

// CPU register size
//#define RSIZE				(sizeof(ITEM)*8)
#define RSIZE				32

// Mask most/least significant <n> bits
#define MASK_LOW(u, n)		( ((ITEM)(u)) & (1<<(n))-1 )
#define MASK_HIGH(u, n)		~MASK_LOW(u, RSIZE-n)

// BreakArray Exit convention
#ifdef BVDEBUG
#define PUSH_STATE(x,y,z)	PushState(x,y,z)
#define VALIDATE(x)			Validate(x)
#else
#define PUSH_STATE(x,y,z)
#define VALIDATE(x)			x
#endif

// Who put the state?
#define INSERTER			0
#define REMOVER				1
#define COLLAPSER			2
#define REPLACER			3


#ifdef BVDEBUG
typedef struct {
	LONG	who;
	LONG	ibGap;
	LONG	cbGap;
	LONG	cbBreak;
	LONG	cbSize;
	LONG	cp;
	LONG	cch;
} BVSTATE;
#endif

class CBreakArray : public CArray<ITEM>
{
public:
#ifdef BITVIEW
	friend class CBitView;
#endif

	CBreakArray();
	~CBreakArray() {}

	BOOL		IsValid() const { return Count() > 0; }
	void		CheckArray();

	LONG		InsertBreak (LONG cp, LONG cch);
	LONG		RemoveBreak (LONG cp, LONG cch);
	LONG 		ReplaceBreak (LONG cp, LONG cchOld, LONG cchNew);
	void		ClearBreak (LONG cp, LONG cch);
	void		SetBreak (LONG cp, BOOL fOn);
	BOOL		GetBreak (LONG cp);

	LONG		CollapseGap (void);
private:

	// n-Bits shifting methods
	void		ShUp (LONG iel, LONG cel, LONG n);
	void		ShDn (LONG iel, LONG cel, LONG n);

	// Size (in bits)
	LONG		_ibGap;			// offset from start of array to gap
	LONG		_cbGap;			// gap size
	LONG		_cbBreak;		// number of valid break
	LONG		_cbSize;		// bit array size (excluded the sentinel element)
#ifdef BITVIEW
	LONG		_cCollapse;		// how many time collapse?
#endif

public:
	LONG		GetCchBreak() { return _cbBreak; }
#ifdef BVDEBUG
	LONG		GetCbSize() { return _cbSize; }
	LONG		Validate(LONG cchRet);		
	void		PushState(LONG cp, LONG cch, LONG who);
#endif
#ifdef BITVIEW
	LONG		SetCollapseCount();
#endif

protected:
#ifdef BVDEBUG
	BVSTATE		_s;
#endif
	LONG		AddBreak(LONG cp, LONG cch);
};


#ifndef BITVIEW


///////	Complex script text breaker class
// 
//		The engine to handle cluster and (dictionary-based) word breaking method
//		used by most SouthEast Asian languages such as Thai, Lao, Burmese etc.
//
//		Create: Mar 12, 1998
//

enum BREAK_UNIT
{
	BRK_WORD		= 1,
	BRK_CLUSTER 	= 2,
	BRK_BOTH		= 3
};

class CTxtBreaker : public ITxNotify
{
public:
	CTxtBreaker(CTxtEdit *ped);
	~CTxtBreaker();

	// Breaker allocation
	BOOL				AddBreaker(UINT brkUnit);

	// Breaker refreshing
	void				Refresh();

	// Query methods
#ifndef NOCOMPLEXSCRIPTS
	BOOL				CanBreakCp (BREAK_UNIT brk, LONG cp);
#else
	BOOL				CanBreakCp (BREAK_UNIT brk, LONG cp) { return FALSE; }
#endif

	// ITxNotify methods

	virtual void    	OnPreReplaceRange (LONG cp, LONG cchDel, LONG cchNew,
										LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData);
	virtual void    	OnPostReplaceRange (LONG cp, LONG cchDel, LONG cchNew,
										LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData);
	virtual void		Zombie() {};

private:
	CTxtEdit*			_ped;
	CBreakArray*		_pbrkWord;		// word-break array (per codepoint property)
	CBreakArray*		_pbrkChar;		// cluster-break array (per codepoint property)
};

#endif	// !BITVIEW

#endif	// _TXTBRK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_version.h ===
#define RICHEDIT_VER "5.41.21.2500"
#define RICHEDIT_VERMAJ 41
#define RICHEDIT_VERMIN 21
#define RICHEDIT_VERBUILD 2500
#ifdef DEBUG
#define RICHEDIT_BUILD RICHEDIT_VER ## " (Debug)"
#else
#define RICHEDIT_BUILD RICHEDIT_VER
#endif
#define RICHEDIT_HEADER "Msftedit " ## RICHEDIT_BUILD
#define RTF_GENINFO "{\\*\\generator " ## RICHEDIT_HEADER ## ";}"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_urlsup.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	_URLSUP.H	URL detection support |
 *
 *	Author:	alexgo (4/1/96)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _URLSUP_H_
#define _URLSUP_H_

#include "_dfreeze.h"
#include "_notmgr.h"
#include "_range.h"

class CTxtEdit;
class IUndoBuilder;

// Maximum URL length. It's a good thing to have a protection like
// this to make sure we don't select the whole document; and we really
// need this for space-containing URLs.

// Note (keithcu). I bumped these values up because of RAID 7210. I thought about
// removing this support altogether, but it's nice to have and speeds up
// performance when you are inserting angle brackets inside URLs and you
// do the left one first.
#define URL_MAX_SIZE			4096


// for MoveByDelimiter
#define	URL_EATWHITESPACE		32
#define URL_STOPATWHITESPACE	1
#define	URL_EATNONWHITESPACE	0
#define URL_STOPATNONWHITESPACE	2
#define	URL_EATPUNCT			0
#define URL_STOPATPUNCT			4
#define	URL_EATNONPUNCT			0
#define URL_STOPATNONPUNCT		8
#define URL_STOPATCHAR			16

// need this one to initialize a scan with something invalid
#define URL_INVALID_DELIMITER	TEXT(' ')

#define LEFTANGLEBRACKET	TEXT('<')
#define RIGHTANGLEBRACKET	TEXT('>')

/*
 *	CDetectURL
 *
 *	@class	This class watches edit changes and automatically
 *			changes detected URL's into links (see CFE_LINK && EN_LINK)
 */
class CDetectURL : public ITxNotify
{
//@access	Public Methods
public:
	// constructor/destructor

	CDetectURL(CTxtEdit *ped);				//@cmember constructor
	~CDetectURL();							//@cmember destructor

	// ITxNotify methods
											//@cmember Called before a change
	virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                       LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
											//@cmember Called after a change
	virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                       LONG cpFormatMin, LONG cpFormatMax, NOTIFY_DATA *pNotifyData );
	virtual void	Zombie();				//@cmember Turn into a zombie

	// useful methods

	void	ScanAndUpdate(IUndoBuilder *publdr);//@cmember Scan changed area 
											//			& update link status
											//@cmember Return TRUE if text is a URL
	BOOL IsURL(CTxtPtr &tp, LONG cch, BOOL *pfURLLeadin);

//@access	Private Methods and Data
private:

	// Worker routines for ScanAndUpdate
	BOOL GetScanRegion(LONG& cpStart, LONG& cpEnd);//@cmember Get region to
											//		check & clear accumulator

	static void ExpandToURL(CTxtRange& rg, LONG &cchAdvance);		
											//@cmember Expand range to next
											//		   URL candidate
	static void SetURLEffects(CTxtRange& rg, IUndoBuilder *publdr);	//@cmember Set
											//	 desired URL effects

											//@cmember Remove URL effects if
											// appropriate
	void CheckAndCleanBogusURL(CTxtRange& rg, BOOL &fDidClean, IUndoBuilder *publdr);

											//@cmember Scan along for white
											// space / not whitespace,
											// punctuation / non punctuation
											// and remember what stopped scan
	static LONG MoveByDelimiters(const CTxtPtr& tp, LONG iDir, DWORD grfDelimiters, 
							WCHAR *pchStopChar);

	static LONG GetAngleBracket(CTxtPtr &tp, LONG cch = 0);
	static WCHAR BraceMatch(WCHAR chEnclosing);
			
	CTxtEdit *				_ped;			//@cmember Edit context
	CAccumDisplayChanges 	_adc;			//@cmember Change accumulator

	// FUTURE (alexgo): we may want to add more options to detection,
	// such as the charformat to use on detection, etc.
};

#endif // _URLSUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_uspi.h ===
/*
 *		Uniscribe interface (& related classes) class definition
 *		
 *		File:    _uspi.h
 * 		Create:  Jan 10, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */
 
#ifndef NOCOMPLEXSCRIPTS

#ifndef _USPI_H
#define _USPI_H

#include "_ls.h"
#include "usp10.h"		// Uniscribe SDK protocol


// classes
//
class CFormatRunPtr;
class CMeasurer;
class CTxtEdit;
class CUniscribe;
class CBiDiFSM;
class CTxtBreaker;


#define ALIGN(x)            		(int)(((x)+3) & ~3)		// dword aligning
#define GLYPH_COUNT(c)          	((((c)*3)/2)+16)
#define MAX_CLIENT_BUF				512						// size (in byte) of internal buffer

// USP client parameters block
//
#define cli_string                  0x00000001
#define cli_psi                     0x00000002
#define cli_psla                    0x00000004
#define cli_pwgi					0x00000008
#define cli_psva					0x00000010
#define cli_pcluster				0x00000020
#define cli_pidx					0x00000040
#define cli_pgoffset				0x00000080

#define cli_Itemize                 (cli_string | cli_psi)
#define cli_Break                   (cli_psla)
#define cli_Shape					(cli_pwgi | cli_psva | cli_pcluster)
#define cli_Place					(cli_pidx | cli_pgoffset)
#define cli_ShapePlace				(cli_Shape | cli_Place)



#ifndef LOCALE_SNATIVEDIGITS
#define LOCALE_SNATIVEDIGITS		0x00000013
#endif



/////   LANG
//
//      The following defines are temporary - they will be removed once they
//      have been added to the standard NLS header files.


#ifndef LANG_KHMER
#define LANG_KHMER       			0x53       // Cambodia
#endif
#ifndef LANG_LAO
#define LANG_LAO         			0x54       // Lao
#endif
#ifndef LANG_MONGOLIAN
#define LANG_MONGOLIAN   			0x50       // Mongolia
#endif
#ifndef LANG_TIBETAN
#define LANG_TIBETAN     			0x51       // Tibet
#endif
#ifndef LANG_URDU
#define LANG_URDU        			0x20       // India / Pakistan
#endif



//
// Memory block will contain USPCLIENT -the table of ptrs, as a memory block's header
// followed by subtables then requested data blocks. All things tie together as a
// contiguous data area so client can free the whole thing in one shot.
//


// SI subtable
//
typedef struct tagUSP_CLIENT_SI
{
	//
	// ScriptItemize's
	//
	WCHAR*          pwchString;
	int             cchString;
	SCRIPT_ITEM*    psi;
} USP_CLIENT_SI, *PUSP_CLIENT_SI;

// SB subtable
//
typedef struct tagUSP_CLIENT_SB
{
	//
	// ScriptBreak's
	//
	SCRIPT_LOGATTR* psla;
} USP_CLIENT_SB, *PUSP_CLIENT_SB;

// SS & SP subtable
typedef struct tagUSP_CLIENT_SSP
{
	//
	// ScriptShape's
	//
	WORD*			pwgi;
	WORD*			pcluster;
	SCRIPT_VISATTR*	psva;

	//
	// ScriptPlace's
	//
	int*			pidx;
	GOFFSET*		pgoffset;
} USP_CLIENT_SSP, *PUSP_CLIENT_SSP;


// header (root) table
//
typedef struct tagUSP_CLIENT
{
	PUSP_CLIENT_SI  si;
	PUSP_CLIENT_SB  sb;
	PUSP_CLIENT_SSP	ssp;
} USP_CLIENT, *PUSP_CLIENT;



// buffer request structure
//
typedef struct tagBUF_REQ
{
	int             size;	// size of requested element
	int             c;		// count of requested element
	PVOID*          ppv;	// ref to ptr of requested buffer
} BUF_REQ;


typedef enum
{
	DIGITS_NOTIMPL = 0,
	DIGITS_CTX,
	DIGITS_NONE,
	DIGITS_NATIONAL
} DIGITSHAPE;


#define		IsCS(x)				(BOOL)((x)==U_COMMA || (x)==U_PERIOD || (x)==U_COLON)


// CUniscribe's internal buffer request flag
//
#define 	igb_Glyph			1
#define 	igb_VisAttr			2
#define 	igb_Pidx			4



// LS Callback's static return buffer
#define 	celAdvance			32

class CBufferBase
{
public:
	CBufferBase(int cbElem) { _cbElem = cbElem; }
	void*	GetPtr(int cel);
	void	Release();
protected:
	void*	_p;
	int		_cElem;
	int		_cbElem;
};

template <class ELEM>
class CBuffer : public CBufferBase
{
public:
	CBuffer() : CBufferBase(sizeof(ELEM)) {}
	~CBuffer() { Release(); }
	ELEM*	Get(int cel) { return (ELEM*)GetPtr(cel); }
};


///////	Uniscribe interface object class
// 		
//
BOOL	IsSupportedOS();

class CUniscribe
{
public:
	CUniscribe();
	~CUniscribe();

	WORD	ApplyDigitSubstitution (BYTE bDigitSubstMode);

	// public helper functions
	//
	const   SCRIPT_PROPERTIES*  GeteProp (WORD eScript);
	const   CBiDiFSM*           GetFSM ();

	BOOL    CreateClientStruc (BYTE* pbBufIn, LONG cbBufIn, PUSP_CLIENT* ppc, LONG cchString, DWORD dwMask);
	void	SubstituteDigitShaper (PLSRUN plsrun, CMeasurer* pme);

	inline BOOL CacheAllocGlyphBuffers(int cch, int& cGlyphs, WORD*& pwgi, SCRIPT_VISATTR*& psva)
	{
		cGlyphs = GLYPH_COUNT(cch);
		return (pwgi = GetGlyphBuffer(cGlyphs)) && (psva = GetVABuffer(cGlyphs));
	}

	inline BOOL IsValid()	{return TRUE;}

	BOOL	GetComplexCharRep(const SCRIPT_PROPERTIES* psp, BYTE iCharRepDefault, BYTE& iCharRepOut);
	BYTE	GetRtlCharRep(CTxtEdit* ped, CRchTxtPtr* prtp);

	// higher level services
	//
	int     ItemizeString (USP_CLIENT* pc, WORD uInitLevel, int* pcItems, WCHAR* pwchString, int cch,
						   BOOL fUnicodeBidi, WORD wLangId = LANG_NEUTRAL);
	int     ShapeString (PLSRUN plsrun, SCRIPT_ANALYSIS* psa, CMeasurer* pme, const WCHAR* pwch, int cch,
						 WORD*& pwgi, WORD* pwlc, SCRIPT_VISATTR*& psva);
	int     PlaceString (PLSRUN plsrun, SCRIPT_ANALYSIS* psa, CMeasurer* pme, const WORD* pcwgi, int cgi,
						 const SCRIPT_VISATTR* psva, int* pgdx, GOFFSET* pgduv, ABC* pABC);
	int		PlaceMetafileString (PLSRUN plsrun, CMeasurer* pme, const WCHAR* pwch, int cch, PINT* ppiDx);

private:
	// private helper functions
	//
	HDC     PrepareShapeDC (PLSRUN plsrun, CMeasurer* pme, HRESULT hrReq, HFONT& hOrgFont);
	BYTE	GetCDMCharRep(BYTE iCharRepDefault);
	DWORD	GetNationalDigitLanguage(LCID lcid);

	// get callback static buffers
	//
	SCRIPT_VISATTR*	GetVABuffer(int cel) { return _rgva.Get(cel); }
	WORD*			GetGlyphBuffer(int cel) { return _rgglyph.Get(cel); }
	int*			GetWidthBuffer(int cel) { return _rgwidth.Get(cel); }
	GOFFSET*		GetGoffsetBuffer(int cel) { return _rgGoffset.Get(cel); }

	// LS callback (static) buffers
	//
	CBuffer<WORD>				_rgglyph;
	CBuffer<int>				_rgwidth;
	CBuffer<GOFFSET>			_rgGoffset;
	CBuffer<SCRIPT_VISATTR>		_rgva;

	// pointer to BidiLevel Finite State Machine
	CBiDiFSM*                   _pFSM;

	// pointer to script properties resource table
	const SCRIPT_PROPERTIES**   _ppProp;

	WORD						_wesNationalDigit;	// National digit script ID
	BYTE						_iCharRepRtl;		// Right to left char rep to use
	BYTE						_iCharRepCDM;		// CDM char repertoire to use
};

extern CUniscribe*      g_pusp;
extern int				g_cMaxScript;		// Maximum number of script produced by Uniscribe

// Virtual script ID
#define	SCRIPT_MAX_COUNT	((WORD)g_cMaxScript)
#define	SCRIPT_WHITE		SCRIPT_MAX_COUNT + 1



///////	Bidi Finite State Machine class
// 		
//		(detail: bidifsm2.html)
//
//		Revise: 12-28-98 (wchao)
//

// inputs class:
#define 	NUM_FSM_INPUTS		5
typedef enum
{
	chLTR = 0,
	chRTL,
	digitLTR,
	digitRTL,
	chGround					// Neutralize current level down to initial level
} INPUT_CLASS;

// states:
#define		NUM_FSM_STATES		6
typedef enum
{
	S_A = 0,
	S_B,
	S_C,
	S_X,
	S_Y,
	S_Z
} STATES;


class CBiDiFSMCell
{
public:
	CBiDiLevel	_level;			// BiDi level
	USHORT  	_uNext;			// Offset to the next state relative to FSM start
};


class CBiDiFSM
{
public:
	CBiDiFSM (CUniscribe* pusp) { _pusp = pusp; }
	~CBiDiFSM ();

	BOOL                Init (void);
	INPUT_CLASS         InputClass (const CCharFormat* pcCF, CTxtPtr* ptp, LONG cchRun) const;
	HRESULT             RunFSM (CRchTxtPtr* prtp, LONG cRuns, LONG cRunsStart, BYTE bBaseLevel) const;

	inline void			SetFSMCell (CBiDiFSMCell* pCell, CBiDiLevel* pLevel, USHORT uNext)
	{
		pCell->_level	= *pLevel;
		pCell->_uNext	= uNext;
	}


private:
	short               _nState;		// number of state
	short               _nInput;		// number of input class
	CUniscribe*         _pusp;			// Uniscribe obj associated with
	CBiDiFSMCell*       _pStart;		// start FSM
};

#endif		// _USPI_H

#endif		// NOCOMPLEXSCRIPTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_util.h ===
/*
 *	_UTIL.H
 *
 *	Purpose:
 *		declarations for various useful utility functions
 *
 *	Author:
 *		alexgo (4/25/95)
 */

#ifndef __UTIL_H__
#define __UTIL_H__

HGLOBAL DuplicateHGlobal( HGLOBAL hglobal );
INT CountMatchingBits(const DWORD *a, const DWORD *b, INT total);
HRESULT ObjectReadSiteFlags(REOBJECT * preobj);


//Default values for drag scrolling
//(that aren't already defined by windows).
#define DEFSCROLLMAXVEL 100	//Cursor velocity above which we will not
							//drag scroll (units=.01 in/sec).
#define DEFSCROLLVAMOUNT 50	//Vert. scroll amount per interval (units=.01 in)
#define DEFSCROLLHAMOUNT 50 //Horz. scroll amount per interval (units=.01 in)

//Stuff from OLESTD samples

//Ole clipboard format defines.
#define CF_EMBEDSOURCE      "Embed Source"
#define CF_EMBEDDEDOBJECT   "Embedded Object"
#define CF_LINKSOURCE       "Link Source"
#define CF_OBJECTDESCRIPTOR "Object Descriptor"
#define CF_FILENAME         "FileName"
#define CF_OWNERLINK        "OwnerLink"

HRESULT OleStdSwitchDisplayAspect(
			LPOLEOBJECT			lpOleObj,
			LPDWORD				lpdwCurAspect,
			DWORD				dwNewAspect,
			HGLOBAL				hMetaPict,
			BOOL				fDeleteOldAspect,
			BOOL				fSetupViewAdvise,
			LPADVISESINK		lpAdviseSink,
			BOOL FAR *			lpfMustUpdate);
LPUNKNOWN OleStdQueryInterface(
			LPUNKNOWN			lpUnk,
			REFIID				riid);

void OleUIDrawShading(LPRECT lpRect, HDC hdc);

VOID OleSaveSiteFlags(LPSTORAGE pstg, DWORD dwFlags, DWORD dwUser, DWORD dvAspect);

INT	AppendString( BYTE **, BYTE *, int *, int * );

/****************************************************************************/
/*		     Stabilization classes				    						*/
/*        These are used to stabilize objects during re-entrant calls       */
/****************************************************************************/

//+-------------------------------------------------------------------------
//
//  Class: 	CSafeRefCount
//
//  Purpose: 	A concrete class for objects like the default handler to
//				inherit from.  CSafeRefCount will keep track of reference
//				counts, nesting counts, and zombie states, allowing objects
//				to easily manage the liveness of their memory images.
//
//  Interface:	
//
//  History:    dd-mmm-yy Author    Comment
//   			01-Aug-94 alexgo    author
//
//--------------------------------------------------------------------------

class CSafeRefCount
{
public:
	ULONG	SafeAddRef();
	ULONG	SafeRelease();
	ULONG	IncrementNestCount();
	ULONG	DecrementNestCount();
	BOOL	IsZombie();
   
			CSafeRefCount();
	virtual ~CSafeRefCount();

protected:
    VOID    Zombie();

private:

	ULONG	m_cRefs;
	ULONG	m_cNest;

	ULONG	m_fInDelete		:1;
	ULONG   m_fForceZombie	:1;
};

//+-------------------------------------------------------------------------
//
//  Class:	CStabilize
//
//  Purpose: 	An instance of this class should be allocated on the
//				stack of every object method that makes an outgoing call.
//				The contstructor takes a pointer to the object's base
//				CSafeRefCount class.
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
// 				01-Aug-94 alexgo    author
//
//  Notes:	The constructor will increment the nest count of the
//			object while the destructor will decrement it.
//
//--------------------------------------------------------------------------

class CStabilize
{
public:
	inline CStabilize( CSafeRefCount *pObjSafeRefCount );
	inline ~CStabilize();

private:
	CSafeRefCount *	m_pObjSafeRefCount;
};

inline CStabilize::CStabilize( CSafeRefCount *pObjSafeRefCount )
{
	pObjSafeRefCount->IncrementNestCount();
	m_pObjSafeRefCount = pObjSafeRefCount;
}

inline CStabilize::~CStabilize()
{
	m_pObjSafeRefCount->DecrementNestCount();
}

/*
 *	SafeReleaseAndNULL(IUnknown **ppUnk)
 *
 *	Purpose:
 *      Helper for getting stable pointers during destruction or other times
 *
 *	Notes: 
 *      Not thread safe, must provide higher level synchronization.
 */

inline void SafeReleaseAndNULL(IUnknown **ppUnk)
{
    if (*ppUnk != NULL)
    {
    IUnknown *pUnkSave = *ppUnk;
    *ppUnk = NULL;
    pUnkSave->Release();
    }
}

BOOL FIsIconMetafilePict(HGLOBAL hmfp);
HANDLE OleStdGetMetafilePictFromOleObject(
        LPOLEOBJECT         lpOleObj,
        DWORD               dwDrawAspect,
        LPSIZEL             lpSizelHim,
        DVTARGETDEVICE FAR* ptd);
HGLOBAL OleGetObjectDescriptorDataFromOleObject(
        LPOLEOBJECT pObj,
        DWORD       dwAspect,
        POINTL      ptl,
        LPSIZEL     pszl);

// Default size for stack buffer
#define MAX_STACK_BUF 256

/*
 *	CTempBuf
 *	
 * 	@class	A simple temporary buffer allocator class that will allocate
 *			buffers on the stack up to MAX_STACK_BUF and then use the 
 *			heap thereafter. 
 */
class CTempBuf
{
//@access Public Data
public:
							//@cmember Constructor
							CTempBuf();

							//@cmember Destructor
							~CTempBuf();

							//@cmember Get buffer of size cb
	void *					GetBuf(LONG cb);

//@access Private Data
private:

							//@cmember Sets up initial state of object
	void					Init();

							//@cmember Frees any buffers allocated from heap
	void					FreeBuf();

							//@cmember Buffer on stack to use
	char					_chBuf[MAX_STACK_BUF];

							//@cmember Pointer to buffer to use
	void *					_pv;

							//@cmember Size of currently allocated buffer
	LONG					_cb;
};

/*
 *	CTempBuf::CTempBuf
 *
 *	@mfunc	Initialize object
 *
 */
inline CTempBuf::CTempBuf()
{
	Init();
}

/*
 *	CTempBuf::~CTempBuf
 *
 *	@mfunc	Free any resources attached to this object
 *
 */
inline CTempBuf::~CTempBuf()
{
	FreeBuf();
}

/*
 *	CTempCharBuf
 *	
 * 	@class	A wrapper for the temporary buffer allocater that returns a buffer of
 *			char's.
 *
 *	@base	private | CTempBuf
 */
class CTempWcharBuf : private CTempBuf
{
//@access Public Data
public:

							//@cmember Get buffer of size cch wide characters
	WCHAR *					GetBuf(LONG cch);
};


/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer of the requested size
 *
 *	@rdesc	Pointer to buffer or NULL if one could not be allocated
 *
 */
inline WCHAR *CTempWcharBuf::GetBuf(
	LONG cch)				//@parm size of buffer needed in *characters*
{
	return (WCHAR *) CTempBuf::GetBuf(cch * sizeof(WCHAR));
}


/*
 *	CTempCharBuf
 *	
 * 	@class	A wrapper for the temporary buffer allocater that returns a buffer of
 *			char's.
 *
 *	@base	private | CTempBuf
 */
class CTempCharBuf : private CTempBuf
{
//@access Public Data
public:

							//@cmember Get buffer of size cch characters
	char *					GetBuf(LONG cch);
};


/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer of the requested size
 *
 *	@rdesc	Pointer to buffer or NULL if one could not be allocated
 *
 */
inline char *CTempCharBuf::GetBuf(LONG cch)
{
	return (char *) CTempBuf::GetBuf(cch * sizeof(TCHAR));
}


// Author revision color table
extern const COLORREF rgcrRevisions[]; 

// Only fixed number of revision color so don't let the table overflow.
#define REVMASK	7

int FindPrimeLessThan(int num);


#endif // !__UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\_w32sys.h ===
/*
 *	_w32sys.h
 *	
 *	Purpose:
 *		Isolate various Win 32 system dependencies.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#ifndef _W32SYS_H

#define _W32SYS_H

#ifndef NOFEPROCESSING
#define OBSOLETE	// need this to get old IMEShare defines
#include "imeshare.h"
#else
// Some class declarations to keep the compiler happy
struct IMESTYLE;
struct IMECOLORSTY;
struct CIMEShare;
#endif

#include "_array.h"

#ifndef THICKCARET
#define duCaret		1
#else
#define duCaret		2
#endif

#ifdef LIMITEDMEMORY
#define FONTCACHESIZE 8
#define CCSHASHSEARCHSIZE	15
#define DEFAULT_UNDO_SIZE 20
#else
#define FONTCACHESIZE 24
#define CCSHASHSEARCHSIZE	31
#define DEFAULT_UNDO_SIZE 100
#endif

#ifdef SLOWCPU
#define NUMPASTECHARSWAITCURSOR 1024
#else
#define NUMPASTECHARSWAITCURSOR (1024*32)
#endif

#ifndef NOMEMORYH
#include "memory.h"								// for memmove
#endif

#define	RSHIFT	1
#define	LSHIFT	2
#define	RCTRL	0x10
#define	LCTRL	0x20
#define	RALT	0x40
#define	LALT	0x80

#define SHIFT	(RSHIFT + LSHIFT)
#define ALT		(RALT + LALT)
#define CTRL	(RCTRL + LCTRL)

#define	HOTEURO			0x1000
#define ALT0			0x2000
#define ALTNUMPAD		0x4000
#define LETAFTERSHIFT	0x8000

// special virtual keys copied from Japan MSVC ime.h
#define VK_KANA         0x15
#define VK_KANJI        0x19

// Initialization flags that can be used in system.ini for testing purposes
#define SYSINI_USELS		0x1
#define SYSINI_BIDI			0x2
#define SYSINI_USEAIMM		0x4
#define SYSINI_DEBUGFONT	0x8
#define SYSINI_DEBUGGCF125X	0x10
#define SYSINI_USECTF		0x20

/*
 *	GetCaretDelta ()
 *	
 *	@func 	Get size of caret to add to current caret position to get the 
 *	maximum extent needed to display caret.
 *
 *	@rdesc	Size of caret over 1 pixel
 *
 *	@devnote	This exists solely to abstract this calculation 
 *	to handle a variable size caret.
 */
inline int GetCaretDelta()
{
	return duCaret - 1;
}


// Used in rtfread.cpp to keep track of lossy rtf.
#ifdef PWORD_CONVERTER_V2
#define REPORT_LOSSAGE
#endif 

//Windows CE defines which need to be before their function declarations
#ifdef UNDER_CE
typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;
#endif


// Defines for some Codepages
#define CP_JAPAN			932
#define CP_KOREAN			949
#define CP_CHINESE_TRAD		950
#define CP_CHINESE_SIM		936
#define CP_HEBREW			1255
#define CP_ARABIC			1256
#define CP_THAI				874
#define CP_VIETNAMESE		1258
#define CP_ULE				1200			// Unicode
#define CP_UBE				1201

#define IsUnicodeCP(cp)		(((cp) & ~1) == CP_ULE)

// Newly introduced Indic language ID
#if(WINVER < 0x500)
#define	LANG_HINDI			0x39
#define	LANG_KONKANI		0x57
#define	LANG_NEPALI			0x61
#define	LANG_BENGALI		0x45
#define	LANG_PUNJABI		0x46
#define	LANG_GUJARATHI		0x47
#define	LANG_ORIYA			0x48
#define	LANG_TAMIL			0x49
#define	LANG_TELUGU			0x4a
#define	LANG_KANNADA		0x4b
#define	LANG_MALAYALAM		0x4c
#define	LANG_ASSAMESE		0x4d
#define	LANG_MARATHI		0x4e
#define	LANG_SANSKRIT		0x4f
#endif

// Other possibly missing defines
#ifndef LANG_THAI
#define LANG_THAI                        0x1e
#endif

#define ANSI_INDEX			0					// Keep these indices in sync
#define	EASTEUROPE_INDEX	1					//  with rgCodePage[] and
#define RUSSIAN_INDEX		2					//  rgCharSet[] if entries
#define GREEK_INDEX			3					//  exist in these arrays.
#define TURKISH_INDEX		4
#define HEBREW_INDEX		5
#define ARABIC_INDEX		6
#define BALTIC_INDEX		7
#define VIET_INDEX			8
#define DEFAULT_INDEX		9
#define SYMBOL_INDEX		10
#define THAI_INDEX			11
#define SHIFTJIS_INDEX		12
#define GB2312_INDEX		13
#define HANGUL_INDEX		14
#define BIG5_INDEX			15
#define PC437_INDEX			16
#define OEM_INDEX			17
#define MAC_INDEX			18

#define NCHARSETS			19		// Size of charset-oriented tables

#define ARMENIAN_INDEX		19		// Start of Unicode-only repertoires
#define	SYRIAC_INDEX		20
#define THAANA_INDEX		21
#define DEVANAGARI_INDEX	22
#define BENGALI_INDEX		23
#define GURMUKHI_INDEX		24
#define GUJARATI_INDEX		25
#define ORIYA_INDEX			26
#define TAMIL_INDEX			27
#define TELUGU_INDEX		28
#define KANNADA_INDEX		29
#define MALAYALAM_INDEX		30
#define SINHALA_INDEX		31
#define	LAO_INDEX			32
#define	TIBETAN_INDEX		33
#define	MYANMAR_INDEX		34
#define GEORGIAN_INDEX		35
#define JAMO_INDEX			36
#define ETHIOPIC_INDEX		37
#define CHEROKEE_INDEX		38
#define ABORIGINAL_INDEX	39
#define OGHAM_INDEX			40
#define RUNIC_INDEX			41
#define	KHMER_INDEX			42
#define	MONGOLIAN_INDEX		43
#define	BRAILLE_INDEX		44
#define	YI_INDEX			45
									// Keep next four in same order as
#define JPN2_INDEX			46		//  SHIFTJIS_INDEX to BIG5_INDEX
#define CHS2_INDEX			47
#define KOR2_INDEX			48
#define CHT2_INDEX			49

#define NCHARREPERTOIRES	50		// Size of keyboard and font-binding tables

#define INDIC_FIRSTINDEX	DEVANAGARI_INDEX
#define INDIC_LASTINDEX		SINHALA_INDEX

#define	PC437_CHARSET		254

// Flags which can be passed down to REExtTextOut
// The low 2 bits are reserved for passing down the TFLOW of the text
const DWORD fETOFEFontOnNonFEWin9x = 0x04;
const DWORD fETOCustomTextOut	   = 0x08;

#define IsSymbolOrOEMCharRep(x)	(x == SYMBOL_INDEX || x == OEM_INDEX)

enum CC
{
	CC_ARABIC,
	CC_HEBREW,
	CC_RTL,
	CC_LTR,
	CC_EOP,
	CC_ASCIIDIGIT,
	CC_NEUTRAL
};

#define IsRTL(cc)		(cc <= CC_RTL)

const SHORT sLanguageEnglishUS = 0x0409;
const SHORT sLanguageMask	 = 	0x03ff;
const SHORT sLanguageArabic	 = 	0x0401;
const SHORT sLanguageHebrew	 = 	0x040d;
// FUTURE: currently this const == sLanguageEnglishUS
//			for no reason except that it was this way 
//			in RE1.0 BiDi. Consider changing, or sticking 
//			the real language in, and changing the logic
//			of handling wLang a bit.
const SHORT sLanguageNonBiDi =	0x0409;


// Logical unit definition
const int LX_PER_INCH = 1440;
const int LY_PER_INCH = 1440;

// HIMETRIC units per inch (used for conversion)
const int HIMETRIC_PER_INCH = 2540;

#if defined(DEBUG)

void* __cdecl operator new(size_t nSize, char *szFile, int nLine);
#define NEW_DEBUG new(__FILE__, __LINE__)
#define new NEW_DEBUG

void UpdateMst(void);

struct MST
{
	char *szFile;
	int  cbAlloc;
}; //Memory Statistics;

extern MST vrgmst[];

#endif //DEBUG

#ifdef CopyMemory
#undef CopyMemory
#endif
#ifdef MoveMemory
#undef MoveMemory
#endif
#ifdef FillMemory
#undef FillMemory
#endif
#ifdef ZeroMemory
#undef ZeroMemory
#endif
#ifdef CompareMemory
#undef CompareMemory
#endif

#ifndef	KF_ALTDOWN
#define KF_ALTDOWN    0x2000
#endif

// Use for our version of ExtTextOut 

enum CONVERTMODE
{
	CVT_NONE,			// Use Unicode (W) CharWidth/TextOut APIs
	CVT_WCTMB,			// Convert to MBCS using WCTMB and _wCodePage
	CVT_LOWBYTE			// Use low byte of 16-bit chars (for SYMBOL_CHARSET
};						//  and when code page isn't installed)

// Opaque Type
class CTxtSelection;
class CTxtEdit;
class CCharFormat;
class CCcs;

enum UN_FLAGS 
{
	UN_NOOBJECTS				= 1,
	UN_CONVERT_WCH_EMBEDDING	= 2
};

#undef GetStringTypeEx
#undef CharLower
#undef CharLowerBuff
#undef CharUpperBuff
#undef CreateIC
#undef CreateFile
#undef CreateFontIndirect
#undef CompareString
#undef DefWindowProc
#undef GetKeyboardLayout
#undef GetProfileSection
#undef GetKerningPairs
#undef GetTextMetrics
#undef GetTextFace
#undef GetWindowLong
#undef GetWindowLongPtr
#undef GetClassLong
#undef LoadBitmap
#undef LoadCursor
#undef LoadLibrary
#undef SendMessage
#undef SetWindowLong
#undef SetWindowLongPtr
#undef PostMessage
#undef lstrcmp
#undef lstrcmpi
#undef PeekMessage
#undef GetModuleFileName
#undef GlobalAlloc 
#undef GlobalFree
#undef GlobalFlags
#undef GlobalReAlloc
#undef GlobalLock
#undef GlobalHandle
#undef GlobalUnlock
#undef GlobalSize

// Bits used in _fFEFontInfo:
#define JPN_FONT_AVAILABLE		0x0001		// True if Jpn font is available
#define KOR_FONT_AVAILABLE		0x0002		// True if Kor font is available
#define BIG5_FONT_AVAILABLE		0x0004		// True if Trad. Chinese font is available
#define GB_FONT_AVAILABLE		0x0008		// True if Simplified Chinese font is available	
#define FEUSER_LCID				0x0010		// True if User LCID is FE LCID
#define FEUSER_CODEPAGE			0x0060		//  indicate which User FE codepage its
#define FEUSER_CP_JPN			0x0000		//	 =00 for JPN
#define FEUSER_CP_KOR			0x0020		//	 =20 for KOR
#define FEUSER_CP_BIG5			0x0040		//	 =40 for BIG5
#define FEUSER_CP_GB			0x0060		//	 =60 for GB
#define FEDATA_NOT_INIT			0xFFFF		// No data yet

class CConvertStrW
{
public:
    operator WCHAR *();

protected:
    CConvertStrW();
    ~CConvertStrW();
    void Free();

    LPWSTR   _pwstr;
    WCHAR    _awch[MAX_PATH * 2];
};

inline CConvertStrW::CConvertStrW()
{
    _pwstr = NULL;
}

inline CConvertStrW::~CConvertStrW()
{
    Free();
}

inline CConvertStrW::operator WCHAR *()
{
    return _pwstr;
}

class CStrInW : public CConvertStrW
{
public:
    CStrInW(LPCSTR pstr);
    CStrInW(LPCSTR pstr, UINT uiCodePage);
    CStrInW(LPCSTR pstr, int cch, UINT uiCodePage);
    int strlen();

protected:
    CStrInW();
    void Init(LPCSTR pstr, int cch, UINT uiCodePage);

    int _cwchLen;
	UINT _uiCodePage;
};

inline CStrInW::CStrInW()
{
}

inline int CStrInW::strlen()
{
    return _cwchLen;
}


// Mask bit for temp display Attributes
#define APPLY_TMP_FORECOLOR	0x0001		// Apply temp. text color
#define	APPLY_TMP_BACKCOLOR	0x0002		// Apply temp. background color

// Actions for GetTmpColor
#define GET_TEMP_TEXT_COLOR			1
#define GET_TEMP_BACK_COLOR			2
#define GET_TEMP_UL_COLOR			3

typedef struct _tmpDispAttrib
{
	WORD		wMask;				// Mask for temp display Attributes
	BYTE		bUnderlineType;		// Temp Underline type
	COLORREF	crTextColor;		// Temp Foreground color
	COLORREF	crBackColor;		// Temp Background color
	COLORREF	crUnderlineColor;	// Temp Underline color
} TMPDISPLAYATTR;

class CTmpDisplayAttrArray : public CArray<TMPDISPLAYATTR>
{
public:
	CTmpDisplayAttrArray() {};
	~CTmpDisplayAttrArray() {};
};

typedef DWORD (WINAPI* PFN_GETLAYOUT)(HDC);
typedef DWORD (WINAPI* PFN_SETLAYOUT)(HDC, DWORD);
#ifdef wcsicmp
#undef wcsicmp
#endif											

class CW32System
{
private :
	static DWORD		_dwPlatformId;				// platform GetVersionEx();
	static LCID			_syslcid;

public :
	static CIMEShare	*_pIMEShare;
	static UINT			_fRegisteredXBox;			// flag indicating if listbox and combobox were registered
	static DWORD		_dwMajorVersion;			// major version from GetVersionEx()
	static DWORD		_dwMinorVersion;			// minor version from GetVersionEx()
	static INT			_icr3DDarkShadow;			// value to use for COLOR_3DDKSHADOW
	static UINT			_MSIMEMouseMsg;				// mouse operation
	static UINT			_MSIMEReconvertMsg;			// reconversion
	static UINT			_MSIMEReconvertRequestMsg;	// reconversion request
	static UINT			_MSIMEDocFeedMsg;			// document feed
	static UINT			_MSIMEQueryPositionMsg;		// query position
	static UINT			_MSIMEServiceMsg;			// checking MSIME98 or later

	static UINT			_MSMouseRoller;				// mouse scrolling

	// Misc flags used for more precise character classification
	static WORD			_fFEFontInfo;
	static BYTE			_fLRMorRLM;

	// Misc flags used for FE
	static BYTE			_fHaveIMMProcs;
	static BYTE			_fHaveAIMM;
	static BYTE			_fHaveIMMEShare;
	static BYTE			_fLoadAIMM10;

	static	CTmpDisplayAttrArray *_arTmpDisplayAttrib;

	CW32System();

	~CW32System();

	static DWORD AddRef();
	static DWORD Release();

	// Platform testing
	static bool OnWinNTFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && IsFELCID(_syslcid );
	}
	static bool OnWinNTNonFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && !IsFELCID(_syslcid );
	}
	static bool OnWinNT5()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && 5 == _dwMajorVersion;
	}
	static bool OnWinNT4()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && 4 == _dwMajorVersion;
	}
	static bool OnWin9xFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && IsFELCID(_syslcid );
	}
	static bool OnWin9x()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
	}
	static bool OnWin95()
	{
		return OnWin9x() && (4 == _dwMajorVersion) && (0 == _dwMinorVersion);
	}
	static bool OnWin95FE()
	{
		return OnWin95() && IsFELCID(_syslcid );
	}
	static bool OnWin9xThai()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && PRIMARYLANGID(_syslcid) == LANG_THAI;
	}
	static bool OnWin9xBiDi()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && IsBiDiLcid(_syslcid);
	}
	static bool OnBiDiOS()
	{
		return IsBiDiLcid(_syslcid) != 0;
	}
	struct WM_CHAR_INFO
	{
		bool _fAccumulate;
		bool _fLeadByte;
		bool _fTrailByte;
		bool _fIMEChar;
	};

	static UINT GetACP() {return _ACP;}

	static LCID GetSysLCID() {return _syslcid;}

#ifndef NOANSIWINDOWS
	static LRESULT ANSIWndProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, BOOL fIs10Mode );
	static void AnsiFilter( UINT &msg, WPARAM &wparam, LPARAM lparam, void *pvoid, BOOL fIs10Mode = FALSE );
#endif
	static HGLOBAL WINAPI GlobalAlloc( UINT uFlags, DWORD dwBytes );
	static HGLOBAL WINAPI GlobalFree( HGLOBAL hMem );
	static UINT WINAPI GlobalFlags( HGLOBAL hMem );
	static HGLOBAL WINAPI GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags );
	static DWORD WINAPI GlobalSize( HGLOBAL hMem );
	static PVOID WINAPI GlobalLock( HGLOBAL hMem );
	static HGLOBAL WINAPI GlobalHandle( LPCVOID pMem );
	static BOOL WINAPI GlobalUnlock( HGLOBAL hMem );
	static void WINAPI REGetCharWidth(
		HDC		hdc,
		WCHAR	ch,
		INT		*pdxp,
		UINT	uiCodePage,
		BOOL	fCustomTextOut);
	static DWORD WINAPI GetKerningPairs(HDC hdc, DWORD ckp, KERNINGPAIR *pkp);

	static void EraseTextOut(HDC hdc, const RECT *prc);

	static void WINAPI REExtTextOut(
		CONVERTMODE cm,
		UINT uiCodePage,
		HDC hdc,
		int x,
		int y,
		UINT fuOptions,
		CONST RECT *lprc,
		const WCHAR *lpString,
		UINT cch,
		CONST INT *lpDx,
		DWORD dwETOFlags);

	static CONVERTMODE WINAPI DetermineConvertMode( HDC hdc, BYTE tmCharSet );
	static void WINAPI CalcUnderlineInfo(HDC hdc, CCcs *pccs, TEXTMETRIC *ptm );
	static BOOL WINAPI EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows );
	static BOOL WINAPI ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG nMax );
	static BOOL WINAPI IsEnhancedMetafileDC( HDC hdc );
	static HPALETTE WINAPI ManagePalette(
		HDC hdc,
		CONST LOGPALETTE *plogpal,
		HPALETTE &hpalOld,
		HPALETTE &hpalNew
	);
	static UINT WINAPI SetTextAlign(
		HDC hdc,
		UINT fMode
	);
	static BOOL WINAPI InvertRect(
		HDC hdc,
		CONST RECT *lprc
	);

	static BOOL PtInRect(const RECT *prc, POINT pt)
	{
		return ::PtInRect(prc, pt);
	}
	static BOOL PtInRect(const RECTUV *prc, POINTUV pt)
	{
		POINT ptxy = {pt.u, pt.v};
		return ::PtInRect((RECT*) prc, ptxy);
	}

	static void InflateRect(RECT *prc, int dxp, int dyp)
	{
		::InflateRect(prc, dxp, dyp);
	}
	static void InflateRect(RECTUV *prc, int dup, int dvp)
	{
		::InflateRect((RECT*) prc, dup, dvp);
	}

	static BOOL IntersectRect(RECT *prcDest, CONST RECT *prc1, CONST RECT *prc2)
	{
		return ::IntersectRect(prcDest, prc1, prc2);
	}

	static BOOL IntersectRect(RECTUV *prcDest, CONST RECTUV *prc1, CONST RECTUV *prc2)
	{
		return ::IntersectRect((RECT*) prcDest, (RECT*) prc1, (RECT*) prc2);
	}

	static void GetFacePriCharSet(HDC hdc, LOGFONT* plf);

	static BOOL WINAPI WinLPtoDP(HDC hdc, LPPOINT lppoints, int nCount);
    static BOOL WINAPI WinDPtoLP(HDC hdc, LPPOINT lppoints, int nCount);

	static long WINAPI WvsprintfA(LONG cb, LPSTR szBuf, LPCSTR szFmt, va_list arglist);

	static int WINAPI MulDivFunc(int nNumber, int nNumerator, int nDenominator);

	static inline LONG HimetricToDevice(LONG z, LONG dzpInch)
	{
		return MulDivFunc(z, dzpInch, HIMETRIC_PER_INCH);
	}
	static inline LONG DeviceToHimetric(LONG z, LONG dzpInch)
	{
		return MulDivFunc(z, HIMETRIC_PER_INCH, dzpInch);
	}

	//
	// Case insensitive ASCII compare
	//
	static BOOL ASCIICompareI( const BYTE *pstr1, const BYTE *pstr2, int iCount )
	{
		int i;	
		for (i = 0; i < iCount && !((pstr1[i] ^ pstr2[i]) & ~0x20); i++)
			;
		return i == iCount;
	}

	//
	// Allocate and convert a MultiByte string to a wide character string
	// Allocated strings must be freed with delete
	//
	static WCHAR *ConvertToWideChar( const char *pstr )
	{
		int istrlen = 0;
		if(pstr)
			for (istrlen; pstr[istrlen]; istrlen++);
		WCHAR *pnew = new WCHAR[istrlen + 1];
		if(pnew && (!pstr || 0 != ::MultiByteToWideChar( 
								CP_ACP, 0, pstr, -1, pnew, istrlen + 1)))
		{
			return pnew;
		}
		return NULL;
	}

	//
	// functions for memory and string management
	//
#ifdef DEBUG
	static void  PvSet(void *pv, char *szFile, int line);
	static PVOID PvAllocDebug(ULONG cbBuf, UINT uiMemFlags, char *szFile, int line);
	static PVOID PvReAllocDebug(PVOID pvBuf, DWORD cbBuf, char *szFile, int line);
	static void  FreePvDebug(PVOID pvBuf);
#endif
	static PVOID PvAlloc(ULONG cbBuf, UINT uiMemFlags);
	static PVOID PvReAlloc(PVOID pvBuf, DWORD cbBuf);
	static void	FreePv(PVOID pvBuf);

	static inline void *MoveMemory(void *dst, const void *src, size_t cb)
	{
		Assert(cb >= 0);
		return memmove(dst, src, cb);
	}

	static inline void *CopyMemory(void *dst, const void *src, size_t cb)
	{
		// Will work for overlapping regions
		Assert(cb >= 0);
		return MoveMemory(dst, src, cb);
	}

	static inline void *FillMemory(void *dst, int fill, size_t cb)
	{
		return memset(dst, fill, cb);
	}

	static inline void *ZeroMemory(void *dst, size_t cb)
	{
		Assert(cb >= 0);
		return memset(dst, 0, cb);
	}

	static inline int CompareMemory(const void *s1, const void *s2, size_t cb)
	{
		return memcmp(s1, s2, cb);
	}

	static size_t wcslen(const wchar_t *wcs);
	static wchar_t * wcscpy(wchar_t * dst, const wchar_t * src);
	static int wcscmp(const wchar_t * src, const wchar_t * dst);
	static int wcsicmp(const wchar_t * src, const wchar_t * dst);
	static wchar_t * wcsncpy (wchar_t * dest, const wchar_t * source, size_t count);
	static int wcsnicmp(const wchar_t *first, const wchar_t *last, size_t count);
	static unsigned long strtoul(const char *);

#ifndef NOFEPROCESSING
	// ----------------------------------
	// IME Support
	// ----------------------------------
	static BOOL ImmInitialize( void );
	static void ImmTerminate( void );
	static LONG ImmGetCompositionStringA ( HIMC, DWORD, PVOID, DWORD, BOOL );
	static LONG ImmGetCompositionStringW ( HIMC, DWORD, PVOID, DWORD, BOOL  );
	static HIMC ImmGetContext ( HWND, BOOL );
	static BOOL ImmSetCompositionFontA ( HIMC, LPLOGFONTA, BOOL );
	static BOOL ImmSetCompositionWindow ( HIMC, LPCOMPOSITIONFORM, BOOL );
	static BOOL ImmReleaseContext ( HWND, HIMC, BOOL );
	static DWORD ImmGetProperty ( HKL, DWORD, BOOL );
	static BOOL ImmGetCandidateWindow ( HIMC, DWORD, LPCANDIDATEFORM, BOOL );
	static BOOL ImmSetCandidateWindow ( HIMC, LPCANDIDATEFORM, BOOL );
	static BOOL ImmNotifyIME ( HIMC, DWORD, DWORD, DWORD, BOOL );
	static HIMC ImmAssociateContext ( HWND, HIMC, BOOL );
	static UINT ImmGetVirtualKey ( HWND, BOOL );
	static HIMC ImmEscape ( HKL, HIMC, UINT, PVOID, BOOL );
	static BOOL ImmGetOpenStatus ( HIMC, BOOL );
	static BOOL ImmSetOpenStatus ( HIMC, BOOL, BOOL );
	static BOOL ImmGetConversionStatus ( HIMC, LPDWORD, LPDWORD, BOOL );
	static BOOL ImmSetConversionStatus ( HIMC, DWORD, DWORD, BOOL );
	static HWND ImmGetDefaultIMEWnd ( HWND , BOOL);
	static BOOL ImmSetCompositionStringW (HIMC, DWORD, PVOID, DWORD, PVOID, DWORD, BOOL);
	static BOOL ImmIsIME ( HKL, BOOL );
	static BOOL FSupportSty ( UINT, UINT );
	static const IMESTYLE * PIMEStyleFromAttr ( const UINT );
	static const IMECOLORSTY * PColorStyleTextFromIMEStyle ( const IMESTYLE * );
	static const IMECOLORSTY * PColorStyleBackFromIMEStyle ( const IMESTYLE * );
	static BOOL FBoldIMEStyle ( const IMESTYLE * );
	static BOOL FItalicIMEStyle ( const IMESTYLE * );
	static BOOL FUlIMEStyle ( const IMESTYLE * );
	static UINT IdUlIMEStyle ( const IMESTYLE * );
	static COLORREF RGBFromIMEColorStyle ( const IMECOLORSTY * );
#endif	// NOFEPROCESSING

	// ----------------------------------
	// National Language Keyboard support
	// ----------------------------------
	static HKL	CheckChangeKeyboardLayout (BYTE iCharRep);
	static HKL	ActivateKeyboard (LONG iCharRep);
	static QWORD GetCharFlags125x(WCHAR ch);
	static BOOL GetKeyboardFlag (WORD dwKeyMask, WORD wKey);
	static WORD GetKeyboardFlags ()				{return _wKeyboardFlags;}
	static HKL  GetKeyboardLayout (DWORD dwThreadID);
	static DWORD GetKeyPadNumber ()				{return _dwNumKeyPad;}
	static WORD GetDeadKey ()					{return _wDeadKey;}
	static void InitKeyboardFlags ();
	static void RefreshKeyboardLayout ();
	static void ResetKeyboardFlag (WORD wFlag)	{_wKeyboardFlags &= ~wFlag;}
	static void SetDeadKey (WORD wDeadKey)		{_wDeadKey = wDeadKey;}
	static void SetKeyboardFlag (WORD wFlag)	{_wKeyboardFlags |= wFlag;}
	static void SetKeyPadNumber (DWORD dwNum)	{_dwNumKeyPad = dwNum;}
	static bool UsingHebrewKeyboard ()
					{return PRIMARYLANGID(_hklCurrent) == LANG_HEBREW;}
	static void InitPreferredFontInfo();
	static bool SetPreferredFontInfo(
		int iCharRep,
		bool fUIFont,
		SHORT iFont,
		BYTE yHeight,
		BYTE bPitchAndFamily
	);
	static bool GetPreferredFontInfo(
		int iCharRep,
		bool fUIFont,
		SHORT& iFont,
		BYTE& yHeight,
		BYTE& bPitchAndFamily
	);
	static bool IsExternalFontCheckActive() {return false;}
	static bool GetExternalPreferredFontInfo(
		const WCHAR *pch,
		LONG	cch,
		BYTE &	iCharRep,
		SHORT &	iFont,
		BYTE &	bPitchAndFamily,
		bool	fUIFont
	)	{ return false;}
	static int GetTextCharsetInfo(
		HDC hdc,                // handle to device context
		LPFONTSIGNATURE lpSig,  // pointer to structure to receive data
		DWORD dwFlags           // reserved; must be zero
	);
	static SHORT GetPreferredFontHeight(	
		bool	fUIFont,
		BYTE	iCharRepOrg, 
		BYTE	iCharRepNew, 
		SHORT	yOrgHeight
	);
	static void CheckInstalledFEFonts();
	static void CheckInstalledKeyboards();
	static bool IsFontAvail( HDC hDC, int iCharRep, bool fUIFont = false, short *piFontIndex = NULL,
		WCHAR *pFontName = NULL);
	static bool IsDefaultFontDefined(LONG iCharRep, bool fUIFont, SHORT &iFont);
#ifndef NOFEPROCESSING
	static bool IsFEFontInSystem( int cpg );
	static UINT GetFEFontInfo( void );
	static int IsFESystem()
	{
		return IsFELCID( _syslcid );
	}
#else
	static bool IsFEFontInSystem( int ) { return FALSE; }
	static UINT GetFEFontInfo( void ) { return 0; };
	static int IsFESystem() { return FALSE; }
#endif

	// Helper routines to get data from temp display attributes array
	static short GetTmpDisplayAttrIdx(TMPDISPLAYATTR &tmpDisplayAttr);
	static short GetTmpUnderline(SHORT idx);
	static bool  GetTmpColor(SHORT idx, COLORREF &crTmpColor, INT iAction);

#ifndef NOACCESSIBILITY 
	// ----------------------------------
	// Accessability Support
	// ----------------------------------
	static HRESULT VariantCopy(VARIANTARG FAR*  pvargDest, VARIANTARG FAR*  pvargSrc);
	static LRESULT LResultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk);
	static HRESULT CreateStdAccessibleProxyW(HWND hwnd, LPCWSTR pClassName, LONG idObject, REFIID riid, void** ppvObject);
	static HRESULT AccessibleObjectFromWindow(HWND hWnd, DWORD dwID, REFIID riidInterface, void ** ppvObject);
	static BOOL BlockInput(BOOL fBlock);
	static UINT	SendInput(UINT nInputs, LPINPUT pInputs, int cbSize);
	static VOID	NotifyWinEvent(DWORD dwEvent, HWND hWnd, LONG lObjectType, LONG lObjectId);
#endif
	
	// ----------------------------------
	// OLE Support
	// ----------------------------------
	static HRESULT LoadRegTypeLib ( REFGUID, WORD, WORD, LCID, ITypeLib ** );
	static HRESULT LoadTypeLib ( const OLECHAR *, ITypeLib ** );
	static HRESULT LoadTypeLibEx( LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib );
	static BSTR SysAllocString ( const OLECHAR * );
	static BSTR SysAllocStringLen ( const OLECHAR *, UINT );
	static void SysFreeString ( BSTR );
	static UINT SysStringLen ( BSTR );
	static void VariantInit ( VARIANTARG * );
	static void VariantClear ( VARIANTARG * );
	static HRESULT OleCreateFromData ( LPDATAOBJECT, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** );
	static void CoTaskMemFree ( PVOID );
	static HRESULT CreateBindCtx ( DWORD, LPBC * );
	static HANDLE OleDuplicateData ( HANDLE, CLIPFORMAT, UINT );
	static HRESULT CoTreatAsClass ( REFCLSID, REFCLSID );
	static HRESULT ProgIDFromCLSID ( REFCLSID, LPOLESTR * );
	static HRESULT OleConvertIStorageToOLESTREAM ( LPSTORAGE, LPOLESTREAM );
	static HRESULT OleConvertIStorageToOLESTREAMEx ( LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM );
	static HRESULT OleSave ( LPPERSISTSTORAGE, LPSTORAGE, BOOL );
	static HRESULT StgCreateDocfileOnILockBytes ( ILockBytes *, DWORD, DWORD, IStorage ** );
	static HRESULT CreateILockBytesOnHGlobal ( HGLOBAL, BOOL, ILockBytes ** );
	static HRESULT OleCreateLinkToFile ( LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** );
	static PVOID CoTaskMemAlloc ( ULONG );
	static PVOID CoTaskMemRealloc ( PVOID, ULONG );
	static HRESULT OleInitialize ( PVOID );
	static void OleUninitialize ( );
	static HRESULT OleSetClipboard ( IDataObject * );
	static HRESULT OleFlushClipboard ( );
	static HRESULT OleIsCurrentClipboard ( IDataObject * );
	static HRESULT DoDragDrop ( IDataObject *, IDropSource *, DWORD, DWORD * );
	static HRESULT OleGetClipboard ( IDataObject ** );
	static HRESULT RegisterDragDrop ( HWND, IDropTarget * );
	static HRESULT OleCreateLinkFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** );
	static HRESULT OleCreateStaticFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** );
	static HRESULT OleDraw ( IUnknown *, DWORD, HDC, LPCRECT );
	static HRESULT OleSetContainedObject ( IUnknown *, BOOL );
	static HRESULT CoDisconnectObject ( IUnknown *, DWORD );
	static HRESULT WriteFmtUserTypeStg ( IStorage *, CLIPFORMAT, LPOLESTR );
	static HRESULT WriteClassStg ( IStorage *, REFCLSID );
	static HRESULT SetConvertStg ( IStorage *, BOOL );
	static HRESULT ReadFmtUserTypeStg ( IStorage *, CLIPFORMAT *, LPOLESTR * );
	static HRESULT ReadClassStg ( IStorage *pstg, CLSID * );
	static HRESULT OleRun ( IUnknown * );
	static HRESULT RevokeDragDrop ( HWND );
	static HRESULT CreateStreamOnHGlobal ( HGLOBAL, BOOL, IStream ** );
	static HRESULT GetHGlobalFromStream ( IStream *pstm, HGLOBAL * );
	static HRESULT OleCreateDefaultHandler ( REFCLSID, IUnknown *, REFIID, void ** );
	static HRESULT CLSIDFromProgID ( LPCOLESTR, LPCLSID );
	static HRESULT OleConvertOLESTREAMToIStorage ( LPOLESTREAM, IStorage *, const DVTARGETDEVICE * );
	static HRESULT OleLoad ( IStorage *, REFIID, IOleClientSite *, void ** );
	static HRESULT ReleaseStgMedium ( LPSTGMEDIUM );
	static HRESULT CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
					DWORD dwClsContext, REFIID riid, PVOID *ppv);
	static HRESULT OleCreateFromFile (REFCLSID, LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, LPVOID *);
	static void FreeOle();

#ifndef NOFEPROCESSING
	static void FreeIME();
	static BOOL HaveIMEShare();
	static BOOL getIMEShareObject(CIMEShare **ppIMEShare);	
	static BOOL IsAIMMLoaded() { return _fHaveAIMM; }
	static BOOL GetAimmObject(IUnknown **ppAimm);
	static BOOL LoadAIMM(BOOL fUseAimm12);
	static HRESULT AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres);
	static HRESULT AIMMGetCodePage (HKL hKL, UINT *uCodePage);
	static HRESULT AIMMActivate (BOOL fRestoreLayout);
	static HRESULT AIMMDeactivate (void);
	static HRESULT AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize, HWND hWnd);
	static HRESULT AIMMUnfilterClientWindows(HWND hWnd);
	static UINT GetDisplayGUID (HIMC hIMC, UINT uAttribute);
#endif	// NOFEPROCESSING
	
	int __cdecl sprintf(char * buff, char *fmt, ...);

#ifdef DEBUG
	int	__cdecl strcmp(const char *, const char *);
	char *	__cdecl strrchr(const char *, int);
	char *	__cdecl strcat(char *, const char *);
#endif

	// ----------------------------------
	// Useful ANSI<-->Unicode conversion
	//          and language id routines
	// ----------------------------------
	static int	MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, 
					int cwch = -1, UINT codepage = CP_ACP,
					UN_FLAGS flags = UN_CONVERT_WCH_EMBEDDING);
	static int	UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch = -1,
					UINT uiCodePage = CP_ACP);
	static int	MBTWC(INT CodePage, DWORD dwFlags, LPCSTR pstrMB, int cchMB,
					LPWSTR pstrWC, int cchWC, LPBOOL pfNoCodePage);
	static int	WCTMB(INT CodePage, DWORD dwFlags, LPCWSTR pstrWC, int cchWC,
					LPSTR pstrMB, int cchMB, LPCSTR	pchDefault, LPBOOL pfUsedDef,
					LPBOOL pfNoCodePage, BOOL fTestCodePage = FALSE);
	static int	VerifyFEString(INT cpg, LPCWSTR pstrWC, int cchWC, BOOL	fTestInputCpg);
	static HGLOBAL TextHGlobalAtoW( HGLOBAL hglobal );
	static HGLOBAL TextHGlobalWtoA( HGLOBAL hglobal );
	static LONG  CharRepFontSig(QWORD qwFontSig, BOOL fFirstAvailable);
	static UINT  CharRepFromLID(WORD lid, BOOL fPlane2 = FALSE);
	static LONG	 CharRepFromCharSet(BYTE bCharSet);
	static INT	 CharRepFromCodePage(LONG CodePage);
	static LONG  CharRepFromFontSig(QWORD qwFontSig)
					{return CharRepFontSig(qwFontSig, FALSE);}
	static BYTE  CharSetFromCharRep(LONG iCharRep);
	static INT	CodePageFromCharRep(LONG iCharRep);
	static QWORD FontSigFromCharRep(LONG iCharRep);

#ifndef NOCOMPLEXSCRIPTS
	static HKL	FindDirectionalKeyboard(BOOL fRTL);
#else
	static HKL	FindDirectionalKeyboard(BOOL fRTL) {return NULL;}
#endif
	static BYTE GetCharSet(INT cpg, int *piCharRep = NULL);
	static BYTE MatchFECharRep(QWORD qwCharFlags, QWORD qwFontSig);
	static BYTE GetFirstAvailCharRep(QWORD qwFontSig)
					{return CharRepFontSig(qwFontSig, TRUE);}
	static UINT GetKeyboardCharRep(DWORD dwMakeAPICall = 0);
	static UINT GetKeyboardCodePage(DWORD dwMakeAPICall = 0)
					{return CodePageFromCharRep(GetKeyboardCharRep(dwMakeAPICall));}
	static LCID GetKeyboardLCID(DWORD dwMakeAPICall = 0);
	static UINT GetLocaleCharRep();
	static HKL	GetPreferredKbd(LONG iCharRep) {return _hkl[iCharRep];}
	static void	SetPreferredKbd(LONG iCharRep, HKL hkl) {_hkl[iCharRep] = hkl;}
	static UINT GetSystemDefaultCodePage()
					{return CodePageFromCharRep(CharRepFromLID(GetSystemDefaultLangID()));}
	static int	GetTrailBytesCount(BYTE ach, UINT cpg);

	static BOOL Is8BitCodePage(unsigned CodePage);
	static BOOL Is8BitCharRep(unsigned iCharRep)
					{return IN_RANGE(ANSI_INDEX, iCharRep, THAI_INDEX);}
	static BOOL IsAlef(WCHAR ch);
	static BOOL IsBiDiCharSet(unsigned CharSet)
					{return IN_RANGE(HEBREW_CHARSET, CharSet, ARABIC_CHARSET);}
	static BOOL IsBiDiCharRep(unsigned iCharRep)
					{return IN_RANGE(HEBREW_INDEX, iCharRep, ARABIC_INDEX) ||
							IN_RANGE(SYRIAC_INDEX, iCharRep, THAANA_INDEX);}
	static BOOL IsIndicCharRep(unsigned iCharRep)
					{return IN_RANGE(INDIC_FIRSTINDEX, iCharRep, INDIC_LASTINDEX);}
	static bool IsBiDiCodePage(int cpg)
					{return	IN_RANGE(CP_HEBREW, cpg, CP_ARABIC);}
	static bool IsBiDiKbdInstalled()
					{return	_hkl[HEBREW_INDEX] || _hkl[ARABIC_INDEX];}
	static bool IsThaiKbdInstalled()
					{return	_hkl[THAI_INDEX] != 0;}
	static bool IsIndicKbdInstalled();
	static bool IsComplexKbdInstalled()
					{return	IsBiDiKbdInstalled() || IsThaiKbdInstalled() || IsIndicKbdInstalled();}
	static bool IsVietnameseCodePage(int cpg)
					{return	cpg == CP_VIETNAMESE;}
	static BOOL IsDiacritic(WCHAR ch);
	static BOOL IsBiDiDiacritic(WCHAR ch);
	static BOOL IsBiDiKashida(WCHAR ch)
					{return ch == 0x0640;}
	static BOOL IsBiDiLcid(LCID lcid);
	static BOOL IsIndicLcid(LCID lcid);
	static BOOL IsComplexScriptLcid(LCID lcid);
#ifndef NOCOMPLEXSCRIPTS
	static BOOL IsDiacriticOrKashida(WCHAR ch, WORD wC3Type);
#else
	static BOOL IsDiacriticOrKashida(WCHAR, WORD) { return FALSE; }
#endif
	static bool IsFELCID(LCID lcid);
	static BOOL IsFECharSet (BYTE bCharSet);
	static BOOL IsFECharRep (BYTE iCharRep)
					{return IN_RANGE(SHIFTJIS_INDEX, iCharRep, BIG5_INDEX);}
	static bool IsFECodePage(int cpg)
					{return	IN_RANGE(CP_JAPAN, cpg, CP_CHINESE_TRAD);}
	static BOOL IsFECodePageFont (DWORD dwFontSig);
	static BOOL IsRTLCharRep(BYTE iCharRep)
					{return IN_RANGE(HEBREW_INDEX, iCharRep, ARABIC_INDEX);}
	static BOOL IsRTLCharSet(BYTE bCharSet);
		   BOOL IsStrongDirectional(CC cc)	{return cc <= CC_LTR;}
	static BOOL IsVietCdmSequenceValid(WCHAR ch1, WCHAR ch2);
	static BOOL IsUTF8BOM(BYTE *pstr);

	static WPARAM ValidateStreamWparam(WPARAM wparam);

	static CC	MECharClass(WCHAR ch);

	static HDC GetScreenDC();


	// ----------------------------------
	// Unicode Wrapped Functions
	// ----------------------------------

	// We could use inline and a function pointer table to improve efficiency and code size.

	static ATOM WINAPI RegisterREClass(
		const WNDCLASSW *lpWndClass
	);
	static BOOL GetVersion(
		DWORD *pdwPlatformId,
		DWORD *pdwMajorVersion,
		DWORD *pdwMinorVersion
	);
	static BOOL GetStringTypes(
		LCID	lcid,
		LPCTSTR lpSrcStr,
		int		cchSrc,
		LPWORD	lpCharType1,
		LPWORD	lpCharType3
	);
	static BOOL WINAPI GetStringTypeEx(
		LCID     Locale,
		DWORD    dwInfoType,
		LPCWSTR lpSrcStr,
		int      cchSrc,
		LPWORD   lpCharType
	);
	static LPWSTR WINAPI CharLower(LPWSTR pwstr);
	static DWORD WINAPI CharLowerBuff(LPWSTR pwstr, DWORD cchLength);
	static DWORD WINAPI CharUpperBuff(LPWSTR pwstr, DWORD cchLength);
	static HDC WINAPI CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData
	);
	static HANDLE WINAPI CreateFile(
        LPCWSTR                 lpFileName,
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDisposition,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile
    );

	static HFONT WINAPI CreateFontIndirect(CONST LOGFONTW * plfw);
	static int WINAPI CompareString ( 
		LCID  Locale,			// locale identifier 
		DWORD  dwCmpFlags,		// comparison-style options 
		LPCWSTR  lpString1,		// pointer to first string 
		int  cch1,			// size, in bytes or characters, of first string 
		LPCWSTR  lpString2,		// pointer to second string 
		int  cch2 			// size, in bytes or characters, of second string  
	);
	static LRESULT WINAPI DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	static int WINAPI GetObject(HGDIOBJ hgdiObj, int cbBuffer, PVOID lpvObj);
	static DWORD APIENTRY GetProfileSection(
		LPCWSTR lpAppName,
		LPWSTR lpReturnedString,
		DWORD nSize
	);
	static int WINAPI GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
	);
	static BOOL WINAPI GetTextMetrics(HDC hdc, LPTEXTMETRICW lptm);
	static BOOL WINAPI GetTextMetrics(HDC hdc, LOGFONTW &lf, TEXTMETRICW &tm);
	static LONG WINAPI GetWindowLong(HWND hWnd, int nIndex);
	static LONG_PTR WINAPI GetWindowLongPtr(HWND hWnd, int nIndex);
	static DWORD WINAPI GetClassLong(HWND hWnd, int nIndex);
	static HBITMAP WINAPI LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName);
	static HBITMAP WINAPI GetPictureBitmap(IStream *pstm);
	static HCURSOR WINAPI LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName);
	static HINSTANCE WINAPI LoadLibrary(LPCWSTR lpLibFileName);
	static LRESULT WINAPI SendMessage(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam
	);
	static LONG WINAPI SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong);
	static LONG WINAPI SetWindowLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNew);
	static BOOL WINAPI PostMessage(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam
	);
	static BOOL WINAPI UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance);
	static int WINAPI lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2);
	static BOOL WINAPI PeekMessage(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax,
        UINT    wRemoveMsg
	);
	static DWORD WINAPI GetModuleFileName(
		HMODULE hModule,
		LPWSTR lpFilename,
		DWORD nSize
    );
	static DWORD GetCurrentThreadId(void);
	static BOOL TrackMouseLeave(HWND hWnd);
	static COLORREF GetCtlBorderColor(BOOL fMousedown, BOOL fMouseover);
	static COLORREF GetCtlBkgColor(BOOL fMousedown, BOOL fMouseover);
	static COLORREF GetCtlTxtColor(BOOL fMousedown, BOOL fMouseover, BOOL fDisabled);
	static void DrawBorderedRectangle(
		HDC hdc,
		RECT *prc,
		COLORREF crBorder,
		COLORREF crBackground
	);			
	static void DrawArrow(
		HDC hdc,
		RECT *prc,
		COLORREF crArrow
	);

private:
	// System Parameters
	static BOOL		_fSysParamsOk;			// System Parameters have been Initialized
	static INT 		_dupSystemFont;				// average char width of system font
	static INT 		_dvpSystemFont;			// height of system font
	static INT		_ySysFontLeading;		// System font internal leading
	static BOOL 	_fUsePalette;
	static LONG 	_xPerInchScreenDC;		// Pixels per inch used for conversions ...
	static LONG 	_yPerInchScreenDC;		// ... and determining whether screen or ...
	static INT		_cxBorder;				// GetSystemMetricx(SM_CXBORDER)...
	static INT		_cyBorder;				// GetSystemMetricx(SM_CYBORDER)...
	static INT		_cxVScroll;				// Width/height of scrlbar arw bitmap
	static INT		_cyHScroll;				// Width of scrlbar arw bitmap
	static LONG 	_dxSelBar;
	static INT		_sysiniflags;			// Start using line services from the start

	static UINT		_ACP;					// Current Ansi code page identifier

	static HDC		_hdcScreen;
	// Double click distances
	static INT		_cxDoubleClk;
	static INT		_cyDoubleClk;	

	// Double Click Time in milliseconds
	static INT		_DCT;

	//Width of hot zone (in pixels) for auto-scrolling
    static WORD	_nScrollInset;
    //Delay (in ms) before scrolling
    static WORD _nScrollDelay;
	//Interval (in ms) at which we scroll
    static WORD _nScrollInterval;
	//Amount of horizontal scroll at each interval (pixels)
	static WORD _nScrollHAmount;
	//Amount of vertical scroll at each interval (pixels)
	static WORD _nScrollVAmount;
	//Amount of time to wait for determining start of drag operation
	static WORD _nDragDelay;
	//Minimun distance that must be traversed within drag delay time interval
	static WORD _nDragMinDist;
	//Keyboard deadkey
	static WORD _wDeadKey;
	//Keyboard shift/ctrl/alt/lock status
	static WORD _wKeyboardFlags;
	//North/South sizing cursor (double arrow)
	static HCURSOR _hcurSizeNS;
	//West/East sizing cursor (double arrow)
	static HCURSOR _hcurSizeWE;
	//Northwest/Southeast sizing cursor (double arrow)
	static HCURSOR _hcurSizeNWSE;
	//Northeast/Southwest sizing cursor (double arrow)
	static HCURSOR _hcurSizeNESW;
	//Number of Lines to scroll with a mouse roller wheel, -1 for pages
	static LONG	_cLineScroll;
	//System Font Handle.  This one need only be done once.
	static HFONT _hSystemFont;
	//Default Font Handle.  This one need only be done once.
	static HFONT _hDefaultFont;
	//System Keyboard Layout
	static HKL _hklCurrent;
	static HKL _hkl[NCHARREPERTOIRES];

	// Ref Count
	static DWORD _cRefs;

	//AltNumericKeyboard number
	static DWORD _dwNumKeyPad;

	//Digit substitution mode (context, none, national)
	static BYTE	_bDigitSubstMode;

	//SYSTEM_FONT charset
	static BYTE _bCharSetSys;

public:
	static INT	GetDupSystemFont()	 {return _dupSystemFont; }
	static INT	GetDvpSystemFont()	 {return _dvpSystemFont; }
	static INT	GetSysFontLeading()	 {return _ySysFontLeading; }
	static LONG GetXPerInchScreenDC(){return _xPerInchScreenDC; }
	static LONG GetYPerInchScreenDC(){return _yPerInchScreenDC; }
	static INT	GetCxBorder()		 {return _cxBorder; }
	static INT	GetCyBorder()		 {return _cyBorder; }
	static INT	GetCyHScroll()		 {return _cyHScroll; }
	static INT	GetCxVScroll()		 {return _cxVScroll; }
	static LONG GetDxSelBar()		 {return _dxSelBar; }
    static WORD GetScrollInset()	 {return _nScrollInset; }
    static WORD GetScrollDelay()	 {return _nScrollDelay; }
    static WORD GetScrollInterval()	 {return _nScrollInterval; }
	static WORD GetScrollHAmount()	 {return _nScrollHAmount; }
	static WORD GetScrollVAmount()	 {return _nScrollVAmount; }
	static INT	GetCxDoubleClk()	 {return _cxDoubleClk; }
	static INT	GetCyDoubleClk()	 {return _cyDoubleClk; }
	static INT	GetDCT()			 {return _DCT; }
	static WORD GetDragDelay()		 {return _nDragDelay; }
	static WORD GetDragMinDist()	 {return _nDragMinDist; }
	static LONG GetRollerLineScrollCount();
	static HCURSOR GetSizeCursor(LPTSTR idcur);
	static HFONT GetSystemFont()	 {return _hSystemFont; }
	static BYTE ReadRegDigitSubstitutionMode();
	static BYTE GetDigitSubstitutionMode() {return _bDigitSubstMode;}
	static bool fUseAimm()			 {return (_sysiniflags & SYSINI_USEAIMM) != 0;}
	static bool fUseCTF()			 {return (_sysiniflags & SYSINI_USECTF) != 0;}
	static bool fUseBiDi()			 {return (_sysiniflags & SYSINI_BIDI) != 0;} 
	static bool fUseLs()			 {return (_sysiniflags & SYSINI_USELS) != 0;} 
	static bool fDebugFont()		 {return (_sysiniflags & SYSINI_DEBUGFONT) != 0;} 
	static int  DebugDefaultCpg()    {return HIWORD(_sysiniflags);}
	static BOOL FUsePalette()		 {return _fUsePalette; }
	static void InitSysParams(BOOL fUpdate = FALSE);
	static DWORD GetRefs()			 {return _cRefs;}
	static BYTE	GetSysCharSet()		 {return _bCharSetSys;}
	static BOOL IsForegroundFrame(HWND);

	// Should also be wrapped but aren't.  Used for debugging.
	// MessageBox
	// OutputDebugString

	// lstrcmpiA should also be wrapped for Win CE's sake but the code
	// that uses it is ifdeffed out for WINCE.

	// Mirroring API entry points
	static PFN_GETLAYOUT			_pfnGetLayout;
	static PFN_SETLAYOUT			_pfnSetLayout;

#ifndef NODRAFTMODE
public:
	static bool GetDraftModeFontInfo(
		SHORT &iFont,
		SHORT &yHeight,
		QWORD &qwFontSig,
		COLORREF &crColor
	);

private:
	struct DraftModeFontInfo {
		SHORT _iFont;
		SHORT _yHeight;
		QWORD _qwFontSig;
		COLORREF _crTextColor;
	};
	static struct DraftModeFontInfo _draftModeFontInfo;
#endif
};

extern CW32System *W32;
HKL	   g_hkl[];

// This fixes a problem with MulDiv reference in _font.h
#define W32MulDiv					W32->MulDivFunc

#if !defined(W32SYS_CPP)

#define OnWinNTFE					W32->OnWinNTFE
#define OnWin95FE					W32->OnWin95FE
#if defined(DEBUG)
#define PvAlloc(cbBuf, uiMemFlags)	W32->PvAllocDebug(cbBuf, uiMemFlags, __FILE__, __LINE__)
#define PvReAlloc(pv, cbBuf)		W32->PvReAllocDebug(pv, cbBuf, __FILE__, __LINE__)
#define PvSet(pv)					W32->PvSet(pv, __FILE__, __LINE__)
#define FreePv						W32->FreePvDebug
#else
#define PvAlloc						W32->PvAlloc
#define PvReAlloc					W32->PvReAlloc
#define FreePv						W32->FreePv
#define PvSet(pv)
#endif
#define CopyMemory					W32->CopyMemory
#define MoveMemory					W32->MoveMemory
#define FillMemory					W32->FillMemory
#define ZeroMemory					W32->ZeroMemory
#define CompareMemory				W32->CompareMemory
#define GlobalAlloc					W32->GlobalAlloc
#define GlobalFree					W32->GlobalFree
#define GlobalFlags					W32->GlobalFlags
#define	GlobalReAlloc				W32->GlobalReAlloc
#define	GlobalSize					W32->GlobalSize
#define	GlobalLock					W32->GlobalLock
#define	GlobalHandle				W32->GlobalHandle
#define	GlobalUnlock				W32->GlobalUnlock

#define ImmInitialize				W32->ImmInitialize
#define ImmTerminate				W32->ImmTerminate

#define ImmGetCompositionStringA	W32->ImmGetCompositionStringA
#define ImmGetCompositionStringW	W32->ImmGetCompositionStringW
#define ImmGetContext				W32->ImmGetContext
#define ImmSetCompositionFontA		W32->ImmSetCompositionFontA
#define ImmSetCompositionWindow		W32->ImmSetCompositionWindow
#define ImmReleaseContext			W32->ImmReleaseContext
#define ImmGetProperty				W32->ImmGetProperty
#define ImmGetCandidateWindow		W32->ImmGetCandidateWindow
#define ImmSetCandidateWindow		W32->ImmSetCandidateWindow
#define ImmNotifyIME				W32->ImmNotifyIME
#define ImmAssociateContext			W32->ImmAssociateContext
#define ImmGetVirtualKey			W32->ImmGetVirtualKey
#define ImmEscape					W32->ImmEscape
#define ImmGetOpenStatus			W32->ImmGetOpenStatus
#define ImmSetOpenStatus			W32->ImmSetOpenStatus
#define ImmGetConversionStatus		W32->ImmGetConversionStatus
#define ImmSetConversionStatus		W32->ImmSetConversionStatus
#define ImmGetDefaultIMEWnd			W32->ImmGetDefaultIMEWnd
#define ImmSetCompositionStringW	W32->ImmSetCompositionStringW
#define ImmIsIME					W32->ImmIsIME
#define LoadRegTypeLib				W32->LoadRegTypeLib
#define LoadTypeLib					W32->LoadTypeLib
#define SysAllocString				W32->SysAllocString
#define SysAllocStringLen			W32->SysAllocStringLen
#define SysFreeString				W32->SysFreeString
#define SysStringLen				W32->SysStringLen
#define VariantInit					W32->VariantInit
#define VariantClear				W32->VariantClear
#define OleCreateFromData			W32->OleCreateFromData
#define CoTaskMemFree				W32->CoTaskMemFree
#define CreateBindCtx				W32->CreateBindCtx
#define OleDuplicateData			W32->OleDuplicateData
#define CoTreatAsClass				W32->CoTreatAsClass
#define ProgIDFromCLSID				W32->ProgIDFromCLSID
#define OleConvertIStorageToOLESTREAM W32->OleConvertIStorageToOLESTREAM
#define OleConvertIStorageToOLESTREAMEx W32->OleConvertIStorageToOLESTREAMEx
#define OleSave						W32->OleSave
#define StgCreateDocfileOnILockBytes W32->StgCreateDocfileOnILockBytes
#define CreateILockBytesOnHGlobal	W32->CreateILockBytesOnHGlobal
#define OleCreateLinkToFile			W32->OleCreateLinkToFile
#define CoTaskMemAlloc				W32->CoTaskMemAlloc
#define CoTaskMemRealloc			W32->CoTaskMemRealloc
#define OleInitialize				W32->OleInitialize
#define OleUninitialize				W32->OleUninitialize
#define OleSetClipboard				W32->OleSetClipboard
#define OleFlushClipboard			W32->OleFlushClipboard
#define OleIsCurrentClipboard		W32->OleIsCurrentClipboard
#define DoDragDrop					W32->DoDragDrop
#define OleGetClipboard				W32->OleGetClipboard
#define RegisterDragDrop			W32->RegisterDragDrop
#define OleCreateLinkFromData		W32->OleCreateLinkFromData
#define OleCreateStaticFromData		W32->OleCreateStaticFromData
#define OleDraw						W32->OleDraw
#define OleSetContainedObject		W32->OleSetContainedObject
#define CoDisconnectObject			W32->CoDisconnectObject
#define WriteFmtUserTypeStg			W32->WriteFmtUserTypeStg
#define WriteClassStg				W32->WriteClassStg
#define SetConvertStg				W32->SetConvertStg
#define ReadFmtUserTypeStg			W32->ReadFmtUserTypeStg
#define ReadClassStg				W32->ReadClassStg
#define OleRun						W32->OleRun
#define RevokeDragDrop				W32->RevokeDragDrop
#define CreateStreamOnHGlobal		W32->CreateStreamOnHGlobal
#define GetHGlobalFromStream		W32->GetHGlobalFromStream
#define OleCreateDefaultHandler		W32->OleCreateDefaultHandler
#define CLSIDFromProgID				W32->CLSIDFromProgID
#define OleConvertOLESTREAMToIStorage W32->OleConvertOLESTREAMToIStorage
#define OleLoad						W32->OleLoad
#define ReleaseStgMedium			W32->ReleaseStgMedium
#define CoCreateInstance			W32->CoCreateInstance

#ifndef NOFEPROCESSING
#define FSupportSty					W32->FSupportSty
#define PIMEStyleFromAttr			W32->PIMEStyleFromAttr
#define PColorStyleTextFromIMEStyle W32->PColorStyleTextFromIMEStyle
#define PColorStyleBackFromIMEStyle W32->PColorStyleBackFromIMEStyle
#define FBoldIMEStyle				W32->FBoldIMEStyle
#define FItalicIMEStyle				W32->FItalicIMEStyle
#define FUlIMEStyle					W32->FUlIMEStyle
#define IdUlIMEStyle				W32->IdUlIMEStyle
#define RGBFromIMEColorStyle		W32->RGBFromIMEColorStyle
#endif	// NOFEPROCESSING

#define fHaveIMMProcs				W32->_fHaveIMMProcs
#define fHaveAIMM					W32->_fHaveAIMM
#define fLoadAIMM10					W32->_fLoadAIMM10
#define dwPlatformId				W32->_dwPlatformId
#define icr3DDarkShadow				W32->_icr3DDarkShadow
#define MSIMEMouseMsg				W32->_MSIMEMouseMsg				
#define MSIMEReconvertMsg			W32->_MSIMEReconvertMsg		
#define MSIMEReconvertRequestMsg	W32->_MSIMEReconvertRequestMsg
#define MSIMEDocFeedMsg				W32->_MSIMEDocFeedMsg
#define MSIMEQueryPositionMsg		W32->_MSIMEQueryPositionMsg
#define MSIMEServiceMsg				W32->_MSIMEServiceMsg

#define CharRepFromCharSet			W32->CharRepFromCharSet
#define CharRepFromCodePage			W32->CharRepFromCodePage
#define CharSetFromCharRep			W32->CharSetFromCharRep
#define CodePageFromCharRep			W32->CodePageFromCharRep
#define MECharClass					W32->MECharClass
#define MbcsFromUnicode				W32->MbcsFromUnicode	
#define UnicodeFromMbcs				W32->UnicodeFromMbcs
#define TextHGlobalAtoW				W32->TextHGlobalAtoW
#define TextHGlobalWtoA				W32->TextHGlobalWtoA
#define CharRepFromLID				W32->CharRepFromLID
#define In125x						W32->In125x	

#define Is8BitCharRep				W32->Is8BitCharRep
#define Is8BitCodePage				W32->Is8BitCodePage
#define IsAlef						W32->IsAlef
#define IsAmbiguous					W32->IsAmbiguous
#define IsBiDiCharRep				W32->IsBiDiCharRep
#define IsBiDiCharSet				W32->IsBiDiCharSet
#define IsBiDiDiacritic				W32->IsBiDiDiacritic
#define IsBiDiKashida				W32->IsBiDiKashida
#define IsBiDiKbdInstalled			W32->IsBiDiKbdInstalled
#define IsDiacritic					W32->IsDiacritic
#define IsDiacriticOrKashida		W32->IsDiacriticOrKashida
#define IsFECharRep					W32->IsFECharRep
#define IsFECharSet					W32->IsFECharSet	
#define IsFELCID					W32->IsFELCID	
#define IsRTLCharRep				W32->IsRTLCharRep
#define IsRTLCharSet				W32->IsRTLCharSet	
#define IsStrongDirectional			W32->IsStrongDirectional
#define IsThaiKbdInstalled			W32->IsThaiKbdInstalled
#define IsIndicKbdInstalled			W32->IsIndicKbdInstalled
#define IsComplexKbdInstalled		W32->IsComplexKbdInstalled
#define	IsTrailByte					W32->IsTrailByte
#define IsVietCdmSequenceValid		W32->IsVietCdmSequenceValid
	
#define	GetCharSet					W32->GetCharSet	
#define	FontSigFromCharRep			W32->FontSigFromCharRep
#define GetFirstAvailCharRep		W32->GetFirstAvailCharRep
#define MatchFECharRep				W32->MatchFECharRep
#define	GetKeyboardCharRep			W32->GetKeyboardCharRep	
#define	GetKeyboardCodePage			W32->GetKeyboardCodePage	
#define	GetKeyboardLCID				W32->GetKeyboardLCID	
#define	GetLocaleCharRep			W32->GetLocaleCharRep
#define	GetSystemDefaultCodePage	W32->GetSystemDefaultCodePage
#define GetTrailBytesCount			W32->GetTrailBytesCount	
#define	MBTWC						W32->MBTWC	
#define	WCTMB						W32->WCTMB
#define VerifyFEString				W32->VerifyFEString		
#define	GetKerningPairs				W32->GetKerningPairs

#define CharLower					W32->CharLower
#define CharLowerBuff				W32->CharLowerBuff
#define CharUpperBuff				W32->CharUpperBuff
#define CreateIC					W32->CreateIC
#define CreateFile					W32->CreateFile
#define CreateFontIndirect			W32->CreateFontIndirect
#define CompareString				W32->CompareString
#define DefWindowProc				W32->DefWindowProc
#define GetDeadKey					W32->GetDeadKey
#define GetKeyboardFlag				W32->GetKeyboardFlag
#define GetKeyboardFlags			W32->GetKeyboardFlags
#define GetKeyboardLayout			W32->GetKeyboardLayout
#define GetKeyPadNumber				W32->GetKeyPadNumber
#define GetProfileSection			W32->GetProfileSection
#define GetTextMetrics				W32->GetTextMetrics
#define GetTextFace					W32->GetTextFace
#define GetWindowLong				W32->GetWindowLong
#define GetWindowLongPtr			W32->GetWindowLongPtr
#define GetClassLong				W32->GetClassLong
#define InitKeyboardFlags			W32->InitKeyboardFlags
#define IsEnhancedMetafileDC		W32->IsEnhancedMetafileDC
#define LoadBitmap					W32->LoadBitmap
#define LoadCursor					W32->LoadCursor
#define LoadLibrary					W32->LoadLibrary
#define ResetKeyboardFlag			W32->ResetKeyboardFlag
#define SendMessage					W32->SendMessage
#define SetDeadKey					W32->SetDeadKey
#define SetKeyboardFlag				W32->SetKeyboardFlag
#define SetKeyPadNumber				W32->SetKeyPadNumber
#define SetWindowLong				W32->SetWindowLong
#define SetWindowLongPtr			W32->SetWindowLongPtr
#define PostMessage					W32->PostMessage
#define lstrcmpi					W32->lstrcmpi
#define PeekMessage					W32->PeekMessage
#define WinLPtoDP                   W32->WinLPtoDP
#define WinDPtoLP                   W32->WinDPtoLP
#define MulDiv						W32->MulDivFunc

#define InflateRect					W32->InflateRect
#define PtInRect					W32->PtInRect
#define IntersectRect				W32->IntersectRect

#define InflateRect					W32->InflateRect
#define PtInRect					W32->PtInRect
#define IntersectRect				W32->IntersectRect

// AIMM wrapper
#define IsAIMMLoaded				W32->IsAIMMLoaded
#define LoadAIMM					W32->LoadAIMM
#define CallAIMMDefaultWndProc		W32->AIMMDefWndProc
#define GetAIMMKeyboardCP			W32->AIMMGetCodePage
#define ActivateAIMM				W32->AIMMActivate
#define DeactivateAIMM				W32->AIMMDeactivate
#define FilterClientWindowsAIMM		W32->AIMMFilterClientWindows
#define UnfilterClientWindowsAIMM	W32->AIMMUnfilterClientWindows
#define sprintf						W32->sprintf

#ifdef DEBUG
#define strrchr						W32->strrchr
#define strcmp						W32->strcmp
#define strcat						W32->strcat
#endif

#define wcslen						W32->wcslen
#define wcscpy						W32->wcscpy
#define wcscmp						W32->wcscmp
#define wcsicmp						W32->wcsicmp
#define wcsncpy						W32->wcsncpy

#define W32GetLayout					(*W32->_pfnGetLayout)
#define W32SetLayout					(*W32->_pfnSetLayout)

#define GetTmpTextColor(a, b)		W32->GetTmpColor(a, b, GET_TEMP_TEXT_COLOR)
#define GetTmpBackColor(a, b)		W32->GetTmpColor(a, b, GET_TEMP_BACK_COLOR)
#define GetTmpUnderlineColor(a, b)	W32->GetTmpColor(a, b, GET_TEMP_UL_COLOR)
#define GetTmpDisplayAttrIdx		W32->GetTmpDisplayAttrIdx
#define GetTmpUnderline				W32->GetTmpUnderline

#define GetACP						W32->GetACP
#define GetSysLCID					W32->GetSysLCID

#define SetTextAlign				W32->SetTextAlign
#define	InvertRect					W32->InvertRect

#endif // !defined(W32SYS_CPP)

#ifndef offsetof
#define offsetof(s,m) ((size_t)&(((s*)0)->m))
#endif

#ifdef UNDER_CE

// The follwing definitions do not exist in the Windows CE environment but we emulate them.
// The values have been copied from the appropriate win32 header files.
// These definitions should be removed if Ce adds them

// Scroll Bars
#ifndef ESB_ENABLE_BOTH
#define ESB_ENABLE_BOTH				0x0000
#define ESB_DISABLE_BOTH			0x0003
#endif

// Text alignment values
#ifndef TA_TOP
#define TA_TOP                      0
#define TA_BOTTOM                   8
#define TA_BASELINE                 24
#define TA_CENTER                   6
#define TA_LEFT                     0
#define TA_RIGHT					2
#endif

// Device Technology.  This one is mostly used for exclusion
#ifndef DT_METAFILE
#define DT_METAFILE         5   // Metafile, VDM
#endif

// FInd/Replace options
#ifndef FR_DOWN
#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004
#endif

// Window messages
#ifndef WM_NCMOUSEMOVE
#define WM_NCMOUSEMOVE                  0x00A0
#endif
#ifndef WM_NCMBUTTONDBLCLK
#define WM_NCMBUTTONDBLCLK              0x00A9
#endif
#ifndef WM_DROPFILES
#define WM_DROPFILES                    0x0233
#endif

// Clipboard formats
#ifndef CF_METAFILEPICT
#define CF_METAFILEPICT     3
#endif

/* Pen Styles : Windows CE only supports PS_DASH */
#ifndef PS_DOT
#define PS_DOT PS_DASH
#endif
#ifndef PS_DASHDOT
#define PS_DASHDOT PS_DASH
#endif
#ifndef PS_DASHDOTDOT
#define PS_DASHDOTDOT PS_DASH
#endif

// Missing APIs
#define GetMessageTime()	0
#define IsIconic(hwnd)		0
#define SetWindowOrgEx(hdc, xOrg, yOrg, pt)
#define SetViewportExtEx(hdc, nX, nY, lpSize)
#define SetWindowExtEx(hdc, x, y, lpSize)

// Unsupported messages.
// FUTURE : Perhaps we should ifdef the code the messages control
#ifndef WS_EX_TRANSPARENT
#define WS_EX_TRANSPARENT       0x00000020L
#endif

#ifndef WM_MOUSEACTIVATE
#define WM_MOUSEACTIVATE			0x0021
#endif

#ifndef WM_SYSCOLORCHANGE
#define WM_SYSCOLORCHANGE               0x0015
#endif

#ifndef WM_STYLECHANGING
#define WM_STYLECHANGING                0x007C
#endif

#ifndef WM_WINDOWPOSCHANGING
#define WM_WINDOWPOSCHANGING            0x0046
#endif

#ifndef WM_SETCURSOR
#define WM_SETCURSOR                    0x0020
#endif

#ifndef WM_NCPAINT
#define WM_NCPAINT                      0x0085
#endif

#ifndef SM_SWAPBUTTON
#define SM_SWAPBUTTON           23
#endif

#ifndef TPM_RIGHTBUTTON
#define TPM_RIGHTBUTTON 0x0002L
#endif

#define RegisterClipboardFormatA(s)  RegisterClipboardFormatW(TEXT(s))

/*
 * EDITWORDBREAKPROC
 */
typedef int (CALLBACK* EDITWORDBREAKPROC)(LPWSTR lpch, int ichCurrent, int cch, int code);
#ifndef WB_LEFT
#define WB_LEFT            0
#define WB_RIGHT           1
#define WB_ISDELIMITER     2
#endif

#ifndef OUT_TT_ONLY_PRECIS
#define OUT_TT_ONLY_PRECIS         7
#endif

// Mapping Modes : Win CE only supports MM_TEXT
#ifndef MM_TEXT
#define MM_TEXT             1
#define SetMapMode(hdc, mapmode)
WINGDIAPI inline int WINAPI GetMapMode(HDC)
{
	return MM_TEXT;
}
#endif

#ifndef HANGUL_CHARSET
#define HANGUL_CHARSET HANGEUL_CHARSET
#endif

#endif	// UNDER_CE

#endif	// _W32SYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\makefile.inc ===
!IF defined(SLATE_REGISTER) && defined(MAKEDLL)

$(REGSVR_MARKER) : $(REGSVR_FILE)
	regsvr32 /s /c $(REGSVR_FILE)
	time /T > $(REGSVR_MARKER)

!ENDIF

clean: $(REGSVR_MARKER)
        -del $(REGSVR_MARKER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\unicode.inc ===
!if 0

Copyright (C) Microsoft Corporation, 2000 - 2000

Module Name:

    unicode.inc

!endif

CharWidth = unicode

C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE

#
# Don't conlict with shlobj.h PickIconDlg
#

C_DEFINES = $(C_DEFINES) -D_SHLOBJ_NO_PICKICONDLG

!ifdef USE_MFC
USE_MFCUNICODE = 1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\ansi.inc ===
!if 0

Copyright (C) Microsoft Corporation, 2000 - 2000

Module Name:

    ansi.inc

!endif

CharWidth = ansi

#
# Don't conlict with shlobj.h PickIconDlg
#

C_DEFINES = $(C_DEFINES) -D_SHLOBJ_NO_PICKICONDLG

ALT_PROJECT_TARGET = win95
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\basestr.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by basestr.rc
//
#define IDS_SNAPIN_FAILED_INIT          12000
#define IDS_VIEW                        12001
#define IDS_VIEW_LARGE                  12002
#define IDS_VIEW_SMALL                  12003
#define IDS_VIEW_LIST                   12004
#define IDS_VIEW_DETAIL                 12005
#define IDS_VIEW_HTML                   12006
#define IDS_ARRANGE_ICONS               12007
#define IDS_ARRANGE_AUTO                12008
#define IDS_LINE_UP_ICONS               12009
#define IDS_NAME                        12010
#define IDS_TYPE                        12011
#define IDS_ADD_TO_FAVORITES            12012
#define IDS_ORGANIZEFAVORITES           12013
#define IDS_MESSAGE_NOT_FOUND_ERROR     12014
#define IDS_NODE_NOT_FOUND              12015
#define IDS_E_UNEXPECTED                12016

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\tom41\tom.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Jul 12 16:06:11 2001
 */
/* Compiler settings for tom.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tomtmp_h__
#define __tomtmp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITextDocument_FWD_DEFINED__
#define __ITextDocument_FWD_DEFINED__
typedef interface ITextDocument ITextDocument;
#endif 	/* __ITextDocument_FWD_DEFINED__ */


#ifndef __ITextRange_FWD_DEFINED__
#define __ITextRange_FWD_DEFINED__
typedef interface ITextRange ITextRange;
#endif 	/* __ITextRange_FWD_DEFINED__ */


#ifndef __ITextSelection_FWD_DEFINED__
#define __ITextSelection_FWD_DEFINED__
typedef interface ITextSelection ITextSelection;
#endif 	/* __ITextSelection_FWD_DEFINED__ */


#ifndef __ITextFont_FWD_DEFINED__
#define __ITextFont_FWD_DEFINED__
typedef interface ITextFont ITextFont;
#endif 	/* __ITextFont_FWD_DEFINED__ */


#ifndef __ITextPara_FWD_DEFINED__
#define __ITextPara_FWD_DEFINED__
typedef interface ITextPara ITextPara;
#endif 	/* __ITextPara_FWD_DEFINED__ */


#ifndef __ITextStoryRanges_FWD_DEFINED__
#define __ITextStoryRanges_FWD_DEFINED__
typedef interface ITextStoryRanges ITextStoryRanges;
#endif 	/* __ITextStoryRanges_FWD_DEFINED__ */


#ifndef __ITextDocument2_FWD_DEFINED__
#define __ITextDocument2_FWD_DEFINED__
typedef interface ITextDocument2 ITextDocument2;
#endif 	/* __ITextDocument2_FWD_DEFINED__ */


#ifndef __ITextMsgFilter_FWD_DEFINED__
#define __ITextMsgFilter_FWD_DEFINED__
typedef interface ITextMsgFilter ITextMsgFilter;
#endif 	/* __ITextMsgFilter_FWD_DEFINED__ */


#ifndef __ITextDocument_FWD_DEFINED__
#define __ITextDocument_FWD_DEFINED__
typedef interface ITextDocument ITextDocument;
#endif 	/* __ITextDocument_FWD_DEFINED__ */


#ifndef __ITextRange_FWD_DEFINED__
#define __ITextRange_FWD_DEFINED__
typedef interface ITextRange ITextRange;
#endif 	/* __ITextRange_FWD_DEFINED__ */


#ifndef __ITextSelection_FWD_DEFINED__
#define __ITextSelection_FWD_DEFINED__
typedef interface ITextSelection ITextSelection;
#endif 	/* __ITextSelection_FWD_DEFINED__ */


#ifndef __ITextFont_FWD_DEFINED__
#define __ITextFont_FWD_DEFINED__
typedef interface ITextFont ITextFont;
#endif 	/* __ITextFont_FWD_DEFINED__ */


#ifndef __ITextPara_FWD_DEFINED__
#define __ITextPara_FWD_DEFINED__
typedef interface ITextPara ITextPara;
#endif 	/* __ITextPara_FWD_DEFINED__ */


#ifndef __ITextStoryRanges_FWD_DEFINED__
#define __ITextStoryRanges_FWD_DEFINED__
typedef interface ITextStoryRanges ITextStoryRanges;
#endif 	/* __ITextStoryRanges_FWD_DEFINED__ */


#ifndef __ITextDocument2_FWD_DEFINED__
#define __ITextDocument2_FWD_DEFINED__
typedef interface ITextDocument2 ITextDocument2;
#endif 	/* __ITextDocument2_FWD_DEFINED__ */


#ifndef __ITextMsgFilter_FWD_DEFINED__
#define __ITextMsgFilter_FWD_DEFINED__
typedef interface ITextMsgFilter ITextMsgFilter;
#endif 	/* __ITextMsgFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_tom_0000 */
/* [local] */ 










extern RPC_IF_HANDLE __MIDL_itf_tom_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tom_0000_v0_0_s_ifspec;


#ifndef __tom_LIBRARY_DEFINED__
#define __tom_LIBRARY_DEFINED__

/* library tom */
/* [version][uuid] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_tom_0000_0001
    {	tomFalse	= 0,
	tomTrue	= -1,
	tomUndefined	= -9999999,
	tomToggle	= -9999998,
	tomAutoColor	= -9999997,
	tomDefault	= -9999996,
	tomSuspend	= -9999995,
	tomResume	= -9999994,
	tomApplyNow	= 0,
	tomApplyLater	= 1,
	tomTrackParms	= 2,
	tomCacheParms	= 3,
	tomApplyTmp	= 4,
	tomBackward	= 0xc0000001,
	tomForward	= 0x3fffffff,
	tomMove	= 0,
	tomExtend	= 1,
	tomNoSelection	= 0,
	tomSelectionIP	= 1,
	tomSelectionNormal	= 2,
	tomSelectionFrame	= 3,
	tomSelectionColumn	= 4,
	tomSelectionRow	= 5,
	tomSelectionBlock	= 6,
	tomSelectionInlineShape	= 7,
	tomSelectionShape	= 8,
	tomSelStartActive	= 1,
	tomSelAtEOL	= 2,
	tomSelOvertype	= 4,
	tomSelActive	= 8,
	tomSelReplace	= 16,
	tomEnd	= 0,
	tomStart	= 32,
	tomCollapseEnd	= 0,
	tomCollapseStart	= 1,
	tomClientCoord	= 256,
	tomAllowOffClient	= 512,
	tomNone	= 0,
	tomSingle	= 1,
	tomWords	= 2,
	tomDouble	= 3,
	tomDotted	= 4,
	tomDash	= 5,
	tomDashDot	= 6,
	tomDashDotDot	= 7,
	tomWave	= 8,
	tomThick	= 9,
	tomHair	= 10,
	tomDoubleWave	= 11,
	tomHeavyWave	= 12,
	tomLongDash	= 13,
	tomThickDash	= 14,
	tomThickDashDot	= 15,
	tomThickDashDotDot	= 16,
	tomThickDotted	= 17,
	tomThickLongDash	= 18,
	tomLineSpaceSingle	= 0,
	tomLineSpace1pt5	= 1,
	tomLineSpaceDouble	= 2,
	tomLineSpaceAtLeast	= 3,
	tomLineSpaceExactly	= 4,
	tomLineSpaceMultiple	= 5,
	tomAlignLeft	= 0,
	tomAlignCenter	= 1,
	tomAlignRight	= 2,
	tomAlignJustify	= 3,
	tomAlignDecimal	= 3,
	tomAlignBar	= 4,
	tomAlignInterWord	= 3,
	tomAlignInterLetter	= 4,
	tomAlignScaled	= 5,
	tomAlignGlyphs	= 6,
	tomAlignSnapGrid	= 7,
	tomSpaces	= 0,
	tomDots	= 1,
	tomDashes	= 2,
	tomLines	= 3,
	tomThickLines	= 4,
	tomEquals	= 5,
	tomTabBack	= -3,
	tomTabNext	= -2,
	tomTabHere	= -1,
	tomListNone	= 0,
	tomListBullet	= 1,
	tomListNumberAsArabic	= 2,
	tomListNumberAsLCLetter	= 3,
	tomListNumberAsUCLetter	= 4,
	tomListNumberAsLCRoman	= 5,
	tomListNumberAsUCRoman	= 6,
	tomListNumberAsSequence	= 7,
	tomListParentheses	= 0x10000,
	tomListPeriod	= 0x20000,
	tomListPlain	= 0x30000,
	tomCharacter	= 1,
	tomWord	= 2,
	tomSentence	= 3,
	tomParagraph	= 4,
	tomLine	= 5,
	tomStory	= 6,
	tomScreen	= 7,
	tomSection	= 8,
	tomColumn	= 9,
	tomRow	= 10,
	tomWindow	= 11,
	tomCell	= 12,
	tomCharFormat	= 13,
	tomParaFormat	= 14,
	tomTable	= 15,
	tomObject	= 16,
	tomPage	= 17,
	tomMatchWord	= 2,
	tomMatchCase	= 4,
	tomMatchPattern	= 8,
	tomUnknownStory	= 0,
	tomMainTextStory	= 1,
	tomFootnotesStory	= 2,
	tomEndnotesStory	= 3,
	tomCommentsStory	= 4,
	tomTextFrameStory	= 5,
	tomEvenPagesHeaderStory	= 6,
	tomPrimaryHeaderStory	= 7,
	tomEvenPagesFooterStory	= 8,
	tomPrimaryFooterStory	= 9,
	tomFirstPageHeaderStory	= 10,
	tomFirstPageFooterStory	= 11,
	tomNoAnimation	= 0,
	tomLasVegasLights	= 1,
	tomBlinkingBackground	= 2,
	tomSparkleText	= 3,
	tomMarchingBlackAnts	= 4,
	tomMarchingRedAnts	= 5,
	tomShimmer	= 6,
	tomWipeDown	= 7,
	tomWipeRight	= 8,
	tomAnimationMax	= 8,
	tomLowerCase	= 0,
	tomUpperCase	= 1,
	tomTitleCase	= 2,
	tomSentenceCase	= 4,
	tomToggleCase	= 5,
	tomReadOnly	= 0x100,
	tomShareDenyRead	= 0x200,
	tomShareDenyWrite	= 0x400,
	tomPasteFile	= 0x1000,
	tomCreateNew	= 0x10,
	tomCreateAlways	= 0x20,
	tomOpenExisting	= 0x30,
	tomOpenAlways	= 0x40,
	tomTruncateExisting	= 0x50,
	tomRTF	= 0x1,
	tomText	= 0x2,
	tomHTML	= 0x3,
	tomWordDocument	= 0x4,
	tomBold	= 0x80000001,
	tomItalic	= 0x80000002,
	tomUnderline	= 0x80000004,
	tomStrikeout	= 0x80000008,
	tomProtected	= 0x80000010,
	tomLink	= 0x80000020,
	tomSmallCaps	= 0x80000040,
	tomAllCaps	= 0x80000080,
	tomHidden	= 0x80000100,
	tomOutline	= 0x80000200,
	tomShadow	= 0x80000400,
	tomEmboss	= 0x80000800,
	tomImprint	= 0x80001000,
	tomDisabled	= 0x80002000,
	tomRevised	= 0x80004000,
	tomNormalCaret	= 0,
	tomKoreanBlockCaret	= 0x1,
	tomIncludeInset	= 0x1,
	tomIgnoreCurrentFont	= 0,
	tomMatchFontCharset	= 0x1,
	tomMatchFontSignature	= 0x2,
	tomCharset	= 0x80000000,
	tomRE10Mode	= 0x1,
	tomUseAtFont	= 0x2,
	tomTextFlowMask	= 0xc,
	tomTextFlowES	= 0,
	tomTextFlowSW	= 0x4,
	tomTextFlowWN	= 0x8,
	tomTextFlowNE	= 0xc,
	tomUsePassword	= 0x10,
	tomNoIME	= 0x80000,
	tomSelfIME	= 0x40000
    }	tomConstants;










EXTERN_C const IID LIBID_tom;

#ifndef __ITextDocument_INTERFACE_DEFINED__
#define __ITextDocument_INTERFACE_DEFINED__

/* interface ITextDocument */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C0-A1DF-11ce-8098-00AA0047BE5D")
    ITextDocument : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryCount( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryRanges( 
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSaved( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSaved( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDefaultTabStop( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDefaultTabStop( 
            /* [in] */ float Value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE New( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Freeze( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Unfreeze( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEditCollection( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEditCollection( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Undo( 
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Redo( 
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Range( 
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RangeFromPoint( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelection )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryCount )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryRanges )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaved )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSaved )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTabStop )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTabStop )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *New )( 
            ITextDocument __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unfreeze )( 
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEditCollection )( 
            ITextDocument __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEditCollection )( 
            ITextDocument __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Range )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeFromPoint )( 
            ITextDocument __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        END_INTERFACE
    } ITextDocumentVtbl;

    interface ITextDocument
    {
        CONST_VTBL struct ITextDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextDocument_GetName(This,pName)	\
    (This)->lpVtbl -> GetName(This,pName)

#define ITextDocument_GetSelection(This,ppSel)	\
    (This)->lpVtbl -> GetSelection(This,ppSel)

#define ITextDocument_GetStoryCount(This,pCount)	\
    (This)->lpVtbl -> GetStoryCount(This,pCount)

#define ITextDocument_GetStoryRanges(This,ppStories)	\
    (This)->lpVtbl -> GetStoryRanges(This,ppStories)

#define ITextDocument_GetSaved(This,pValue)	\
    (This)->lpVtbl -> GetSaved(This,pValue)

#define ITextDocument_SetSaved(This,Value)	\
    (This)->lpVtbl -> SetSaved(This,Value)

#define ITextDocument_GetDefaultTabStop(This,pValue)	\
    (This)->lpVtbl -> GetDefaultTabStop(This,pValue)

#define ITextDocument_SetDefaultTabStop(This,Value)	\
    (This)->lpVtbl -> SetDefaultTabStop(This,Value)

#define ITextDocument_New(This)	\
    (This)->lpVtbl -> New(This)

#define ITextDocument_Open(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Open(This,pVar,Flags,CodePage)

#define ITextDocument_Save(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Save(This,pVar,Flags,CodePage)

#define ITextDocument_Freeze(This,pCount)	\
    (This)->lpVtbl -> Freeze(This,pCount)

#define ITextDocument_Unfreeze(This,pCount)	\
    (This)->lpVtbl -> Unfreeze(This,pCount)

#define ITextDocument_BeginEditCollection(This)	\
    (This)->lpVtbl -> BeginEditCollection(This)

#define ITextDocument_EndEditCollection(This)	\
    (This)->lpVtbl -> EndEditCollection(This)

#define ITextDocument_Undo(This,Count,prop)	\
    (This)->lpVtbl -> Undo(This,Count,prop)

#define ITextDocument_Redo(This,Count,prop)	\
    (This)->lpVtbl -> Redo(This,Count,prop)

#define ITextDocument_Range(This,cp1,cp2,ppRange)	\
    (This)->lpVtbl -> Range(This,cp1,cp2,ppRange)

#define ITextDocument_RangeFromPoint(This,x,y,ppRange)	\
    (This)->lpVtbl -> RangeFromPoint(This,x,y,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetName_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB ITextDocument_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetSelection_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);


void __RPC_STUB ITextDocument_GetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetStoryCount_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_GetStoryCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetStoryRanges_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);


void __RPC_STUB ITextDocument_GetStoryRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetSaved_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextDocument_GetSaved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_SetSaved_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextDocument_SetSaved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetDefaultTabStop_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextDocument_GetDefaultTabStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_SetDefaultTabStop_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextDocument_SetDefaultTabStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_New_Proxy( 
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_New_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Open_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Flags,
    /* [in] */ long CodePage);


void __RPC_STUB ITextDocument_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Save_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Flags,
    /* [in] */ long CodePage);


void __RPC_STUB ITextDocument_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Freeze_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Unfreeze_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_Unfreeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_BeginEditCollection_Proxy( 
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_BeginEditCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_EndEditCollection_Proxy( 
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_EndEditCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Undo_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *prop);


void __RPC_STUB ITextDocument_Undo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Redo_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *prop);


void __RPC_STUB ITextDocument_Redo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Range_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long cp1,
    /* [in] */ long cp2,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextDocument_Range_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_RangeFromPoint_Proxy( 
    ITextDocument __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextDocument_RangeFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextDocument_INTERFACE_DEFINED__ */


#ifndef __ITextRange_INTERFACE_DEFINED__
#define __ITextRange_INTERFACE_DEFINED__

/* interface ITextRange */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextRange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C2-A1DF-11ce-8098-00AA0047BE5D")
    ITextRange : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetChar( 
            /* [retval][out] */ long __RPC_FAR *pch) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetChar( 
            /* [in] */ long ch) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate( 
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFormattedText( 
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFormattedText( 
            /* [in] */ ITextRange __RPC_FAR *pRange) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStart( 
            /* [retval][out] */ long __RPC_FAR *pcpFirst) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStart( 
            /* [in] */ long cpFirst) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEnd( 
            /* [retval][out] */ long __RPC_FAR *pcpLim) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEnd( 
            /* [in] */ long cpLim) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFont( 
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFont( 
            /* [in] */ ITextFont __RPC_FAR *pFont) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPara( 
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPara( 
            /* [in] */ ITextPara __RPC_FAR *pPara) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryLength( 
            /* [retval][out] */ long __RPC_FAR *pcch) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryType( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Collapse( 
            /* [in] */ long bStart) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Expand( 
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetIndex( 
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetRange( 
            /* [in] */ long cpActive,
            /* [in] */ long cpOther) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InRange( 
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InStory( 
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Select( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartOf( 
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndOf( 
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStart( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEnd( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveWhile( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStartWhile( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEndWhile( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveUntil( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStartUntil( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEndUntil( 
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindText( 
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindTextStart( 
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindTextEnd( 
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Cut( 
            /* [out] */ VARIANT __RPC_FAR *pVar) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Copy( 
            /* [out] */ VARIANT __RPC_FAR *pVar) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Paste( 
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanPaste( 
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanEdit( 
            /* [retval][out] */ long __RPC_FAR *pbCanEdit) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChangeCase( 
            /* [in] */ long Type) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPoint( 
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetPoint( 
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ScrollIntoView( 
            /* [in] */ long Value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEmbeddedObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextRangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextRange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextRange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextRange __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChar )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pch);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChar )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long ch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormattedText )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormattedText )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStart )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpFirst);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStart )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpFirst);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnd )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpLim);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnd )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpLim);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPara )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPara )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryLength )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryType )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Collapse )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long bStart);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndex )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndex )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRange )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpActive,
            /* [in] */ long cpOther);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InRange )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InStory )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            ITextRange __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOf )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOf )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStart )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEnd )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveWhile )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartWhile )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndWhile )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUntil )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartUntil )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndUntil )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindText )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextStart )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextEnd )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cut )( 
            ITextRange __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )( 
            ITextRange __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Paste )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanPaste )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanEdit )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pbCanEdit);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeCase )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Type);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPoint )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPoint )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScrollIntoView )( 
            ITextRange __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbeddedObject )( 
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);
        
        END_INTERFACE
    } ITextRangeVtbl;

    interface ITextRange
    {
        CONST_VTBL struct ITextRangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextRange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextRange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextRange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextRange_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextRange_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextRange_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextRange_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextRange_GetText(This,pbstr)	\
    (This)->lpVtbl -> GetText(This,pbstr)

#define ITextRange_SetText(This,bstr)	\
    (This)->lpVtbl -> SetText(This,bstr)

#define ITextRange_GetChar(This,pch)	\
    (This)->lpVtbl -> GetChar(This,pch)

#define ITextRange_SetChar(This,ch)	\
    (This)->lpVtbl -> SetChar(This,ch)

#define ITextRange_GetDuplicate(This,ppRange)	\
    (This)->lpVtbl -> GetDuplicate(This,ppRange)

#define ITextRange_GetFormattedText(This,ppRange)	\
    (This)->lpVtbl -> GetFormattedText(This,ppRange)

#define ITextRange_SetFormattedText(This,pRange)	\
    (This)->lpVtbl -> SetFormattedText(This,pRange)

#define ITextRange_GetStart(This,pcpFirst)	\
    (This)->lpVtbl -> GetStart(This,pcpFirst)

#define ITextRange_SetStart(This,cpFirst)	\
    (This)->lpVtbl -> SetStart(This,cpFirst)

#define ITextRange_GetEnd(This,pcpLim)	\
    (This)->lpVtbl -> GetEnd(This,pcpLim)

#define ITextRange_SetEnd(This,cpLim)	\
    (This)->lpVtbl -> SetEnd(This,cpLim)

#define ITextRange_GetFont(This,pFont)	\
    (This)->lpVtbl -> GetFont(This,pFont)

#define ITextRange_SetFont(This,pFont)	\
    (This)->lpVtbl -> SetFont(This,pFont)

#define ITextRange_GetPara(This,pPara)	\
    (This)->lpVtbl -> GetPara(This,pPara)

#define ITextRange_SetPara(This,pPara)	\
    (This)->lpVtbl -> SetPara(This,pPara)

#define ITextRange_GetStoryLength(This,pcch)	\
    (This)->lpVtbl -> GetStoryLength(This,pcch)

#define ITextRange_GetStoryType(This,pValue)	\
    (This)->lpVtbl -> GetStoryType(This,pValue)

#define ITextRange_Collapse(This,bStart)	\
    (This)->lpVtbl -> Collapse(This,bStart)

#define ITextRange_Expand(This,Unit,pDelta)	\
    (This)->lpVtbl -> Expand(This,Unit,pDelta)

#define ITextRange_GetIndex(This,Unit,pIndex)	\
    (This)->lpVtbl -> GetIndex(This,Unit,pIndex)

#define ITextRange_SetIndex(This,Unit,Index,Extend)	\
    (This)->lpVtbl -> SetIndex(This,Unit,Index,Extend)

#define ITextRange_SetRange(This,cpActive,cpOther)	\
    (This)->lpVtbl -> SetRange(This,cpActive,cpOther)

#define ITextRange_InRange(This,pRange,pb)	\
    (This)->lpVtbl -> InRange(This,pRange,pb)

#define ITextRange_InStory(This,pRange,pb)	\
    (This)->lpVtbl -> InStory(This,pRange,pb)

#define ITextRange_IsEqual(This,pRange,pb)	\
    (This)->lpVtbl -> IsEqual(This,pRange,pb)

#define ITextRange_Select(This)	\
    (This)->lpVtbl -> Select(This)

#define ITextRange_StartOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> StartOf(This,Unit,Extend,pDelta)

#define ITextRange_EndOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndOf(This,Unit,Extend,pDelta)

#define ITextRange_Move(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Move(This,Unit,Count,pDelta)

#define ITextRange_MoveStart(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveStart(This,Unit,Count,pDelta)

#define ITextRange_MoveEnd(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveEnd(This,Unit,Count,pDelta)

#define ITextRange_MoveWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveStartWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveEndWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveUntil(This,Cset,Count,pDelta)

#define ITextRange_MoveStartUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartUntil(This,Cset,Count,pDelta)

#define ITextRange_MoveEndUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndUntil(This,Cset,Count,pDelta)

#define ITextRange_FindText(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindText(This,bstr,cch,Flags,pLength)

#define ITextRange_FindTextStart(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextStart(This,bstr,cch,Flags,pLength)

#define ITextRange_FindTextEnd(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextEnd(This,bstr,cch,Flags,pLength)

#define ITextRange_Delete(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Delete(This,Unit,Count,pDelta)

#define ITextRange_Cut(This,pVar)	\
    (This)->lpVtbl -> Cut(This,pVar)

#define ITextRange_Copy(This,pVar)	\
    (This)->lpVtbl -> Copy(This,pVar)

#define ITextRange_Paste(This,pVar,Format)	\
    (This)->lpVtbl -> Paste(This,pVar,Format)

#define ITextRange_CanPaste(This,pVar,Format,pb)	\
    (This)->lpVtbl -> CanPaste(This,pVar,Format,pb)

#define ITextRange_CanEdit(This,pbCanEdit)	\
    (This)->lpVtbl -> CanEdit(This,pbCanEdit)

#define ITextRange_ChangeCase(This,Type)	\
    (This)->lpVtbl -> ChangeCase(This,Type)

#define ITextRange_GetPoint(This,Type,px,py)	\
    (This)->lpVtbl -> GetPoint(This,Type,px,py)

#define ITextRange_SetPoint(This,x,y,Type,Extend)	\
    (This)->lpVtbl -> SetPoint(This,x,y,Type,Extend)

#define ITextRange_ScrollIntoView(This,Value)	\
    (This)->lpVtbl -> ScrollIntoView(This,Value)

#define ITextRange_GetEmbeddedObject(This,ppv)	\
    (This)->lpVtbl -> GetEmbeddedObject(This,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ITextRange_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextRange_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetChar_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pch);


void __RPC_STUB ITextRange_GetChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetChar_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long ch);


void __RPC_STUB ITextRange_SetChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetDuplicate_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextRange_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetFormattedText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextRange_GetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetFormattedText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange);


void __RPC_STUB ITextRange_SetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStart_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcpFirst);


void __RPC_STUB ITextRange_GetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetStart_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpFirst);


void __RPC_STUB ITextRange_SetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetEnd_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcpLim);


void __RPC_STUB ITextRange_GetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetEnd_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpLim);


void __RPC_STUB ITextRange_SetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetFont_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);


void __RPC_STUB ITextRange_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetFont_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont);


void __RPC_STUB ITextRange_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetPara_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);


void __RPC_STUB ITextRange_GetPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetPara_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara);


void __RPC_STUB ITextRange_SetPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStoryLength_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcch);


void __RPC_STUB ITextRange_GetStoryLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStoryType_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextRange_GetStoryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Collapse_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long bStart);


void __RPC_STUB ITextRange_Collapse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Expand_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetIndex_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [retval][out] */ long __RPC_FAR *pIndex);


void __RPC_STUB ITextRange_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetIndex_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Index,
    /* [in] */ long Extend);


void __RPC_STUB ITextRange_SetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetRange_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpActive,
    /* [in] */ long cpOther);


void __RPC_STUB ITextRange_SetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_InRange_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_InRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_InStory_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_InStory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_IsEqual_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Select_Proxy( 
    ITextRange __RPC_FAR * This);


void __RPC_STUB ITextRange_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_StartOf_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_StartOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_EndOf_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_EndOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Move_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStart_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEnd_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveWhile_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStartWhile_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStartWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEndWhile_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEndWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveUntil_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStartUntil_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStartUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEndUntil_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEndUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindText_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindTextStart_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindTextStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindTextEnd_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindTextEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Delete_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Cut_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *pVar);


void __RPC_STUB ITextRange_Cut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Copy_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *pVar);


void __RPC_STUB ITextRange_Copy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Paste_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Format);


void __RPC_STUB ITextRange_Paste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_CanPaste_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Format,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_CanPaste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_CanEdit_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pbCanEdit);


void __RPC_STUB ITextRange_CanEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_ChangeCase_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Type);


void __RPC_STUB ITextRange_ChangeCase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetPoint_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Type,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py);


void __RPC_STUB ITextRange_GetPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetPoint_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y,
    /* [in] */ long Type,
    /* [in] */ long Extend);


void __RPC_STUB ITextRange_SetPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_ScrollIntoView_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextRange_ScrollIntoView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetEmbeddedObject_Proxy( 
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB ITextRange_GetEmbeddedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextRange_INTERFACE_DEFINED__ */


#ifndef __ITextSelection_INTERFACE_DEFINED__
#define __ITextSelection_INTERFACE_DEFINED__

/* interface ITextSelection */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C1-A1DF-11ce-8098-00AA0047BE5D")
    ITextSelection : public ITextRange
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [retval][out] */ long __RPC_FAR *pFlags) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ LONG Flags) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetType( 
            /* [retval][out] */ long __RPC_FAR *pType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveLeft( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveRight( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveUp( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveDown( 
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE HomeKey( 
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndKey( 
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE TypeText( 
            /* [in] */ BSTR bstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextSelection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextSelection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextSelection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChar )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pch);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChar )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long ch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormattedText )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormattedText )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStart )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpFirst);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStart )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpFirst);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnd )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpLim);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnd )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpLim);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPara )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPara )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryLength )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryType )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Collapse )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long bStart);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndex )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndex )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRange )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpActive,
            /* [in] */ long cpOther);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InRange )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InStory )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            ITextSelection __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOf )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOf )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStart )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEnd )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveWhile )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartWhile )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndWhile )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUntil )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartUntil )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndUntil )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindText )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextStart )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextEnd )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cut )( 
            ITextSelection __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )( 
            ITextSelection __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Paste )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanPaste )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanEdit )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pbCanEdit);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeCase )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Type);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPoint )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPoint )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScrollIntoView )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbeddedObject )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pFlags);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ LONG Flags);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveLeft )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveRight )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUp )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveDown )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HomeKey )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndKey )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TypeText )( 
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        END_INTERFACE
    } ITextSelectionVtbl;

    interface ITextSelection
    {
        CONST_VTBL struct ITextSelectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextSelection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextSelection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextSelection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextSelection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextSelection_GetText(This,pbstr)	\
    (This)->lpVtbl -> GetText(This,pbstr)

#define ITextSelection_SetText(This,bstr)	\
    (This)->lpVtbl -> SetText(This,bstr)

#define ITextSelection_GetChar(This,pch)	\
    (This)->lpVtbl -> GetChar(This,pch)

#define ITextSelection_SetChar(This,ch)	\
    (This)->lpVtbl -> SetChar(This,ch)

#define ITextSelection_GetDuplicate(This,ppRange)	\
    (This)->lpVtbl -> GetDuplicate(This,ppRange)

#define ITextSelection_GetFormattedText(This,ppRange)	\
    (This)->lpVtbl -> GetFormattedText(This,ppRange)

#define ITextSelection_SetFormattedText(This,pRange)	\
    (This)->lpVtbl -> SetFormattedText(This,pRange)

#define ITextSelection_GetStart(This,pcpFirst)	\
    (This)->lpVtbl -> GetStart(This,pcpFirst)

#define ITextSelection_SetStart(This,cpFirst)	\
    (This)->lpVtbl -> SetStart(This,cpFirst)

#define ITextSelection_GetEnd(This,pcpLim)	\
    (This)->lpVtbl -> GetEnd(This,pcpLim)

#define ITextSelection_SetEnd(This,cpLim)	\
    (This)->lpVtbl -> SetEnd(This,cpLim)

#define ITextSelection_GetFont(This,pFont)	\
    (This)->lpVtbl -> GetFont(This,pFont)

#define ITextSelection_SetFont(This,pFont)	\
    (This)->lpVtbl -> SetFont(This,pFont)

#define ITextSelection_GetPara(This,pPara)	\
    (This)->lpVtbl -> GetPara(This,pPara)

#define ITextSelection_SetPara(This,pPara)	\
    (This)->lpVtbl -> SetPara(This,pPara)

#define ITextSelection_GetStoryLength(This,pcch)	\
    (This)->lpVtbl -> GetStoryLength(This,pcch)

#define ITextSelection_GetStoryType(This,pValue)	\
    (This)->lpVtbl -> GetStoryType(This,pValue)

#define ITextSelection_Collapse(This,bStart)	\
    (This)->lpVtbl -> Collapse(This,bStart)

#define ITextSelection_Expand(This,Unit,pDelta)	\
    (This)->lpVtbl -> Expand(This,Unit,pDelta)

#define ITextSelection_GetIndex(This,Unit,pIndex)	\
    (This)->lpVtbl -> GetIndex(This,Unit,pIndex)

#define ITextSelection_SetIndex(This,Unit,Index,Extend)	\
    (This)->lpVtbl -> SetIndex(This,Unit,Index,Extend)

#define ITextSelection_SetRange(This,cpActive,cpOther)	\
    (This)->lpVtbl -> SetRange(This,cpActive,cpOther)

#define ITextSelection_InRange(This,pRange,pb)	\
    (This)->lpVtbl -> InRange(This,pRange,pb)

#define ITextSelection_InStory(This,pRange,pb)	\
    (This)->lpVtbl -> InStory(This,pRange,pb)

#define ITextSelection_IsEqual(This,pRange,pb)	\
    (This)->lpVtbl -> IsEqual(This,pRange,pb)

#define ITextSelection_Select(This)	\
    (This)->lpVtbl -> Select(This)

#define ITextSelection_StartOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> StartOf(This,Unit,Extend,pDelta)

#define ITextSelection_EndOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndOf(This,Unit,Extend,pDelta)

#define ITextSelection_Move(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Move(This,Unit,Count,pDelta)

#define ITextSelection_MoveStart(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveStart(This,Unit,Count,pDelta)

#define ITextSelection_MoveEnd(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveEnd(This,Unit,Count,pDelta)

#define ITextSelection_MoveWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveStartWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveEndWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveUntil(This,Cset,Count,pDelta)

#define ITextSelection_MoveStartUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartUntil(This,Cset,Count,pDelta)

#define ITextSelection_MoveEndUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndUntil(This,Cset,Count,pDelta)

#define ITextSelection_FindText(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindText(This,bstr,cch,Flags,pLength)

#define ITextSelection_FindTextStart(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextStart(This,bstr,cch,Flags,pLength)

#define ITextSelection_FindTextEnd(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextEnd(This,bstr,cch,Flags,pLength)

#define ITextSelection_Delete(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Delete(This,Unit,Count,pDelta)

#define ITextSelection_Cut(This,pVar)	\
    (This)->lpVtbl -> Cut(This,pVar)

#define ITextSelection_Copy(This,pVar)	\
    (This)->lpVtbl -> Copy(This,pVar)

#define ITextSelection_Paste(This,pVar,Format)	\
    (This)->lpVtbl -> Paste(This,pVar,Format)

#define ITextSelection_CanPaste(This,pVar,Format,pb)	\
    (This)->lpVtbl -> CanPaste(This,pVar,Format,pb)

#define ITextSelection_CanEdit(This,pbCanEdit)	\
    (This)->lpVtbl -> CanEdit(This,pbCanEdit)

#define ITextSelection_ChangeCase(This,Type)	\
    (This)->lpVtbl -> ChangeCase(This,Type)

#define ITextSelection_GetPoint(This,Type,px,py)	\
    (This)->lpVtbl -> GetPoint(This,Type,px,py)

#define ITextSelection_SetPoint(This,x,y,Type,Extend)	\
    (This)->lpVtbl -> SetPoint(This,x,y,Type,Extend)

#define ITextSelection_ScrollIntoView(This,Value)	\
    (This)->lpVtbl -> ScrollIntoView(This,Value)

#define ITextSelection_GetEmbeddedObject(This,ppv)	\
    (This)->lpVtbl -> GetEmbeddedObject(This,ppv)


#define ITextSelection_GetFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFlags(This,pFlags)

#define ITextSelection_SetFlags(This,Flags)	\
    (This)->lpVtbl -> SetFlags(This,Flags)

#define ITextSelection_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ITextSelection_MoveLeft(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveLeft(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveRight(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveRight(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveUp(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveUp(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveDown(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveDown(This,Unit,Count,Extend,pDelta)

#define ITextSelection_HomeKey(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> HomeKey(This,Unit,Extend,pDelta)

#define ITextSelection_EndKey(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndKey(This,Unit,Extend,pDelta)

#define ITextSelection_TypeText(This,bstr)	\
    (This)->lpVtbl -> TypeText(This,bstr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_GetFlags_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pFlags);


void __RPC_STUB ITextSelection_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_SetFlags_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ LONG Flags);


void __RPC_STUB ITextSelection_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_GetType_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pType);


void __RPC_STUB ITextSelection_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveLeft_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveRight_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveRight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveUp_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveDown_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_HomeKey_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_HomeKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_EndKey_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_EndKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_TypeText_Proxy( 
    ITextSelection __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextSelection_TypeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextSelection_INTERFACE_DEFINED__ */


#ifndef __ITextFont_INTERFACE_DEFINED__
#define __ITextFont_INTERFACE_DEFINED__

/* interface ITextFont */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextFont;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C3-A1DF-11ce-8098-00AA0047BE5D")
    ITextFont : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate( 
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDuplicate( 
            /* [in] */ ITextFont __RPC_FAR *pFont) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanChange( 
            /* [retval][out] */ long __RPC_FAR *pB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ ITextFont __RPC_FAR *pFont,
            /* [retval][out] */ long __RPC_FAR *pB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStyle( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStyle( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAllCaps( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAllCaps( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAnimation( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAnimation( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetBackColor( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetBackColor( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetBold( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetBold( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEmboss( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEmboss( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetForeColor( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetForeColor( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetHidden( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetHidden( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEngrave( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEngrave( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetItalic( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetItalic( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKerning( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKerning( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLanguageID( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetLanguageID( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetOutline( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetOutline( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPosition( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPosition( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetProtected( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetProtected( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetShadow( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetShadow( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSize( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSmallCaps( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSmallCaps( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpacing( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpacing( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStrikeThrough( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStrikeThrough( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSubscript( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSubscript( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSuperscript( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSuperscript( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetUnderline( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetUnderline( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetWeight( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetWeight( 
            /* [in] */ long Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextFontVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextFont __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextFont __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextFont __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDuplicate )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanChange )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont,
            /* [retval][out] */ long __RPC_FAR *pB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStyle )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllCaps )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllCaps )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAnimation )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAnimation )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackColor )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackColor )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBold )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBold )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmboss )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEmboss )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForeColor )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForeColor )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHidden )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHidden )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEngrave )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEngrave )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItalic )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItalic )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKerning )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKerning )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageID )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLanguageID )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutline )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutline )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPosition )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPosition )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtected )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProtected )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetShadow )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetShadow )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSize )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSmallCaps )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSmallCaps )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpacing )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpacing )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStrikeThrough )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStrikeThrough )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubscript )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSubscript )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuperscript )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSuperscript )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUnderline )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUnderline )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWeight )( 
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWeight )( 
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);
        
        END_INTERFACE
    } ITextFontVtbl;

    interface ITextFont
    {
        CONST_VTBL struct ITextFontVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextFont_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextFont_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextFont_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextFont_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextFont_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextFont_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextFont_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextFont_GetDuplicate(This,ppFont)	\
    (This)->lpVtbl -> GetDuplicate(This,ppFont)

#define ITextFont_SetDuplicate(This,pFont)	\
    (This)->lpVtbl -> SetDuplicate(This,pFont)

#define ITextFont_CanChange(This,pB)	\
    (This)->lpVtbl -> CanChange(This,pB)

#define ITextFont_IsEqual(This,pFont,pB)	\
    (This)->lpVtbl -> IsEqual(This,pFont,pB)

#define ITextFont_Reset(This,Value)	\
    (This)->lpVtbl -> Reset(This,Value)

#define ITextFont_GetStyle(This,pValue)	\
    (This)->lpVtbl -> GetStyle(This,pValue)

#define ITextFont_SetStyle(This,Value)	\
    (This)->lpVtbl -> SetStyle(This,Value)

#define ITextFont_GetAllCaps(This,pValue)	\
    (This)->lpVtbl -> GetAllCaps(This,pValue)

#define ITextFont_SetAllCaps(This,Value)	\
    (This)->lpVtbl -> SetAllCaps(This,Value)

#define ITextFont_GetAnimation(This,pValue)	\
    (This)->lpVtbl -> GetAnimation(This,pValue)

#define ITextFont_SetAnimation(This,Value)	\
    (This)->lpVtbl -> SetAnimation(This,Value)

#define ITextFont_GetBackColor(This,pValue)	\
    (This)->lpVtbl -> GetBackColor(This,pValue)

#define ITextFont_SetBackColor(This,Value)	\
    (This)->lpVtbl -> SetBackColor(This,Value)

#define ITextFont_GetBold(This,pValue)	\
    (This)->lpVtbl -> GetBold(This,pValue)

#define ITextFont_SetBold(This,Value)	\
    (This)->lpVtbl -> SetBold(This,Value)

#define ITextFont_GetEmboss(This,pValue)	\
    (This)->lpVtbl -> GetEmboss(This,pValue)

#define ITextFont_SetEmboss(This,Value)	\
    (This)->lpVtbl -> SetEmboss(This,Value)

#define ITextFont_GetForeColor(This,pValue)	\
    (This)->lpVtbl -> GetForeColor(This,pValue)

#define ITextFont_SetForeColor(This,Value)	\
    (This)->lpVtbl -> SetForeColor(This,Value)

#define ITextFont_GetHidden(This,pValue)	\
    (This)->lpVtbl -> GetHidden(This,pValue)

#define ITextFont_SetHidden(This,Value)	\
    (This)->lpVtbl -> SetHidden(This,Value)

#define ITextFont_GetEngrave(This,pValue)	\
    (This)->lpVtbl -> GetEngrave(This,pValue)

#define ITextFont_SetEngrave(This,Value)	\
    (This)->lpVtbl -> SetEngrave(This,Value)

#define ITextFont_GetItalic(This,pValue)	\
    (This)->lpVtbl -> GetItalic(This,pValue)

#define ITextFont_SetItalic(This,Value)	\
    (This)->lpVtbl -> SetItalic(This,Value)

#define ITextFont_GetKerning(This,pValue)	\
    (This)->lpVtbl -> GetKerning(This,pValue)

#define ITextFont_SetKerning(This,Value)	\
    (This)->lpVtbl -> SetKerning(This,Value)

#define ITextFont_GetLanguageID(This,pValue)	\
    (This)->lpVtbl -> GetLanguageID(This,pValue)

#define ITextFont_SetLanguageID(This,Value)	\
    (This)->lpVtbl -> SetLanguageID(This,Value)

#define ITextFont_GetName(This,pbstr)	\
    (This)->lpVtbl -> GetName(This,pbstr)

#define ITextFont_SetName(This,bstr)	\
    (This)->lpVtbl -> SetName(This,bstr)

#define ITextFont_GetOutline(This,pValue)	\
    (This)->lpVtbl -> GetOutline(This,pValue)

#define ITextFont_SetOutline(This,Value)	\
    (This)->lpVtbl -> SetOutline(This,Value)

#define ITextFont_GetPosition(This,pValue)	\
    (This)->lpVtbl -> GetPosition(This,pValue)

#define ITextFont_SetPosition(This,Value)	\
    (This)->lpVtbl -> SetPosition(This,Value)

#define ITextFont_GetProtected(This,pValue)	\
    (This)->lpVtbl -> GetProtected(This,pValue)

#define ITextFont_SetProtected(This,Value)	\
    (This)->lpVtbl -> SetProtected(This,Value)

#define ITextFont_GetShadow(This,pValue)	\
    (This)->lpVtbl -> GetShadow(This,pValue)

#define ITextFont_SetShadow(This,Value)	\
    (This)->lpVtbl -> SetShadow(This,Value)

#define ITextFont_GetSize(This,pValue)	\
    (This)->lpVtbl -> GetSize(This,pValue)

#define ITextFont_SetSize(This,Value)	\
    (This)->lpVtbl -> SetSize(This,Value)

#define ITextFont_GetSmallCaps(This,pValue)	\
    (This)->lpVtbl -> GetSmallCaps(This,pValue)

#define ITextFont_SetSmallCaps(This,Value)	\
    (This)->lpVtbl -> SetSmallCaps(This,Value)

#define ITextFont_GetSpacing(This,pValue)	\
    (This)->lpVtbl -> GetSpacing(This,pValue)

#define ITextFont_SetSpacing(This,Value)	\
    (This)->lpVtbl -> SetSpacing(This,Value)

#define ITextFont_GetStrikeThrough(This,pValue)	\
    (This)->lpVtbl -> GetStrikeThrough(This,pValue)

#define ITextFont_SetStrikeThrough(This,Value)	\
    (This)->lpVtbl -> SetStrikeThrough(This,Value)

#define ITextFont_GetSubscript(This,pValue)	\
    (This)->lpVtbl -> GetSubscript(This,pValue)

#define ITextFont_SetSubscript(This,Value)	\
    (This)->lpVtbl -> SetSubscript(This,Value)

#define ITextFont_GetSuperscript(This,pValue)	\
    (This)->lpVtbl -> GetSuperscript(This,pValue)

#define ITextFont_SetSuperscript(This,Value)	\
    (This)->lpVtbl -> SetSuperscript(This,Value)

#define ITextFont_GetUnderline(This,pValue)	\
    (This)->lpVtbl -> GetUnderline(This,pValue)

#define ITextFont_SetUnderline(This,Value)	\
    (This)->lpVtbl -> SetUnderline(This,Value)

#define ITextFont_GetWeight(This,pValue)	\
    (This)->lpVtbl -> GetWeight(This,pValue)

#define ITextFont_SetWeight(This,Value)	\
    (This)->lpVtbl -> SetWeight(This,Value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetDuplicate_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont);


void __RPC_STUB ITextFont_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetDuplicate_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont);


void __RPC_STUB ITextFont_SetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_CanChange_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextFont_CanChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_IsEqual_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextFont_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_Reset_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetStyle_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetStyle_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetAllCaps_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetAllCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetAllCaps_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetAllCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetAnimation_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetAnimation_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetBackColor_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetBackColor_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetBold_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetBold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetBold_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetBold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetEmboss_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetEmboss_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetEmboss_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetEmboss_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetForeColor_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetForeColor_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetHidden_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetHidden_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetEngrave_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetEngrave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetEngrave_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetEngrave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetItalic_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetItalic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetItalic_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetItalic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetKerning_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetKerning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetKerning_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetKerning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetLanguageID_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetLanguageID_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetName_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ITextFont_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetName_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextFont_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetOutline_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetOutline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetOutline_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetOutline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetPosition_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetPosition_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetProtected_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetProtected_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetShadow_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetShadow_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSize_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSize_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSmallCaps_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSmallCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSmallCaps_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSmallCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSpacing_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSpacing_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetStrikeThrough_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetStrikeThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetStrikeThrough_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetStrikeThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSubscript_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSubscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSubscript_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSubscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSuperscript_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSuperscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSuperscript_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSuperscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetUnderline_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetUnderline_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetWeight_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetWeight_Proxy( 
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextFont_INTERFACE_DEFINED__ */


#ifndef __ITextPara_INTERFACE_DEFINED__
#define __ITextPara_INTERFACE_DEFINED__

/* interface ITextPara */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextPara;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C4-A1DF-11ce-8098-00AA0047BE5D")
    ITextPara : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate( 
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDuplicate( 
            /* [in] */ ITextPara __RPC_FAR *pPara) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanChange( 
            /* [retval][out] */ long __RPC_FAR *pB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ ITextPara __RPC_FAR *pPara,
            /* [retval][out] */ long __RPC_FAR *pB) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStyle( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStyle( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAlignment( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAlignment( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetHyphenation( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetHyphenation( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFirstLineIndent( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKeepTogether( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKeepTogether( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKeepWithNext( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKeepWithNext( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLeftIndent( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLineSpacing( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLineSpacingRule( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListAlignment( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListAlignment( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListLevelIndex( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListLevelIndex( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListStart( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListStart( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListTab( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListTab( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListType( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListType( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetNoLineNumber( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetNoLineNumber( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPageBreakBefore( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPageBreakBefore( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetRightIndent( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetRightIndent( 
            /* [in] */ float Value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetIndents( 
            /* [in] */ float StartIndent,
            /* [in] */ float LeftIndent,
            /* [in] */ float RightIndent) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetLineSpacing( 
            /* [in] */ long LineSpacingRule,
            /* [in] */ float LineSpacing) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpaceAfter( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpaceAfter( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpaceBefore( 
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpaceBefore( 
            /* [in] */ float Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetWidowControl( 
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetWidowControl( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetTabCount( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddTab( 
            /* [in] */ float tbPos,
            /* [in] */ long tbAlign,
            /* [in] */ long tbLeader) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ClearAllTabs( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteTab( 
            /* [in] */ float tbPos) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetTab( 
            /* [in] */ long iTab,
            /* [out] */ float __RPC_FAR *ptbPos,
            /* [out] */ long __RPC_FAR *ptbAlign,
            /* [out] */ long __RPC_FAR *ptbLeader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextParaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextPara __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextPara __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextPara __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDuplicate )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanChange )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara,
            /* [retval][out] */ long __RPC_FAR *pB);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStyle )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAlignment )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlignment )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHyphenation )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHyphenation )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstLineIndent )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeepTogether )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKeepTogether )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeepWithNext )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKeepWithNext )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLeftIndent )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineSpacing )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineSpacingRule )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListAlignment )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListAlignment )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListLevelIndex )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListLevelIndex )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStart )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStart )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListTab )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListTab )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListType )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListType )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNoLineNumber )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNoLineNumber )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPageBreakBefore )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPageBreakBefore )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRightIndent )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRightIndent )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndents )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float StartIndent,
            /* [in] */ float LeftIndent,
            /* [in] */ float RightIndent);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLineSpacing )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long LineSpacingRule,
            /* [in] */ float LineSpacing);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceAfter )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpaceAfter )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceBefore )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpaceBefore )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWidowControl )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWidowControl )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTabCount )( 
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddTab )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float tbPos,
            /* [in] */ long tbAlign,
            /* [in] */ long tbLeader);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearAllTabs )( 
            ITextPara __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteTab )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ float tbPos);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTab )( 
            ITextPara __RPC_FAR * This,
            /* [in] */ long iTab,
            /* [out] */ float __RPC_FAR *ptbPos,
            /* [out] */ long __RPC_FAR *ptbAlign,
            /* [out] */ long __RPC_FAR *ptbLeader);
        
        END_INTERFACE
    } ITextParaVtbl;

    interface ITextPara
    {
        CONST_VTBL struct ITextParaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextPara_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextPara_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextPara_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextPara_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextPara_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextPara_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextPara_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextPara_GetDuplicate(This,ppPara)	\
    (This)->lpVtbl -> GetDuplicate(This,ppPara)

#define ITextPara_SetDuplicate(This,pPara)	\
    (This)->lpVtbl -> SetDuplicate(This,pPara)

#define ITextPara_CanChange(This,pB)	\
    (This)->lpVtbl -> CanChange(This,pB)

#define ITextPara_IsEqual(This,pPara,pB)	\
    (This)->lpVtbl -> IsEqual(This,pPara,pB)

#define ITextPara_Reset(This,Value)	\
    (This)->lpVtbl -> Reset(This,Value)

#define ITextPara_GetStyle(This,pValue)	\
    (This)->lpVtbl -> GetStyle(This,pValue)

#define ITextPara_SetStyle(This,Value)	\
    (This)->lpVtbl -> SetStyle(This,Value)

#define ITextPara_GetAlignment(This,pValue)	\
    (This)->lpVtbl -> GetAlignment(This,pValue)

#define ITextPara_SetAlignment(This,Value)	\
    (This)->lpVtbl -> SetAlignment(This,Value)

#define ITextPara_GetHyphenation(This,pValue)	\
    (This)->lpVtbl -> GetHyphenation(This,pValue)

#define ITextPara_SetHyphenation(This,Value)	\
    (This)->lpVtbl -> SetHyphenation(This,Value)

#define ITextPara_GetFirstLineIndent(This,pValue)	\
    (This)->lpVtbl -> GetFirstLineIndent(This,pValue)

#define ITextPara_GetKeepTogether(This,pValue)	\
    (This)->lpVtbl -> GetKeepTogether(This,pValue)

#define ITextPara_SetKeepTogether(This,Value)	\
    (This)->lpVtbl -> SetKeepTogether(This,Value)

#define ITextPara_GetKeepWithNext(This,pValue)	\
    (This)->lpVtbl -> GetKeepWithNext(This,pValue)

#define ITextPara_SetKeepWithNext(This,Value)	\
    (This)->lpVtbl -> SetKeepWithNext(This,Value)

#define ITextPara_GetLeftIndent(This,pValue)	\
    (This)->lpVtbl -> GetLeftIndent(This,pValue)

#define ITextPara_GetLineSpacing(This,pValue)	\
    (This)->lpVtbl -> GetLineSpacing(This,pValue)

#define ITextPara_GetLineSpacingRule(This,pValue)	\
    (This)->lpVtbl -> GetLineSpacingRule(This,pValue)

#define ITextPara_GetListAlignment(This,pValue)	\
    (This)->lpVtbl -> GetListAlignment(This,pValue)

#define ITextPara_SetListAlignment(This,Value)	\
    (This)->lpVtbl -> SetListAlignment(This,Value)

#define ITextPara_GetListLevelIndex(This,pValue)	\
    (This)->lpVtbl -> GetListLevelIndex(This,pValue)

#define ITextPara_SetListLevelIndex(This,Value)	\
    (This)->lpVtbl -> SetListLevelIndex(This,Value)

#define ITextPara_GetListStart(This,pValue)	\
    (This)->lpVtbl -> GetListStart(This,pValue)

#define ITextPara_SetListStart(This,Value)	\
    (This)->lpVtbl -> SetListStart(This,Value)

#define ITextPara_GetListTab(This,pValue)	\
    (This)->lpVtbl -> GetListTab(This,pValue)

#define ITextPara_SetListTab(This,Value)	\
    (This)->lpVtbl -> SetListTab(This,Value)

#define ITextPara_GetListType(This,pValue)	\
    (This)->lpVtbl -> GetListType(This,pValue)

#define ITextPara_SetListType(This,Value)	\
    (This)->lpVtbl -> SetListType(This,Value)

#define ITextPara_GetNoLineNumber(This,pValue)	\
    (This)->lpVtbl -> GetNoLineNumber(This,pValue)

#define ITextPara_SetNoLineNumber(This,Value)	\
    (This)->lpVtbl -> SetNoLineNumber(This,Value)

#define ITextPara_GetPageBreakBefore(This,pValue)	\
    (This)->lpVtbl -> GetPageBreakBefore(This,pValue)

#define ITextPara_SetPageBreakBefore(This,Value)	\
    (This)->lpVtbl -> SetPageBreakBefore(This,Value)

#define ITextPara_GetRightIndent(This,pValue)	\
    (This)->lpVtbl -> GetRightIndent(This,pValue)

#define ITextPara_SetRightIndent(This,Value)	\
    (This)->lpVtbl -> SetRightIndent(This,Value)

#define ITextPara_SetIndents(This,StartIndent,LeftIndent,RightIndent)	\
    (This)->lpVtbl -> SetIndents(This,StartIndent,LeftIndent,RightIndent)

#define ITextPara_SetLineSpacing(This,LineSpacingRule,LineSpacing)	\
    (This)->lpVtbl -> SetLineSpacing(This,LineSpacingRule,LineSpacing)

#define ITextPara_GetSpaceAfter(This,pValue)	\
    (This)->lpVtbl -> GetSpaceAfter(This,pValue)

#define ITextPara_SetSpaceAfter(This,Value)	\
    (This)->lpVtbl -> SetSpaceAfter(This,Value)

#define ITextPara_GetSpaceBefore(This,pValue)	\
    (This)->lpVtbl -> GetSpaceBefore(This,pValue)

#define ITextPara_SetSpaceBefore(This,Value)	\
    (This)->lpVtbl -> SetSpaceBefore(This,Value)

#define ITextPara_GetWidowControl(This,pValue)	\
    (This)->lpVtbl -> GetWidowControl(This,pValue)

#define ITextPara_SetWidowControl(This,Value)	\
    (This)->lpVtbl -> SetWidowControl(This,Value)

#define ITextPara_GetTabCount(This,pCount)	\
    (This)->lpVtbl -> GetTabCount(This,pCount)

#define ITextPara_AddTab(This,tbPos,tbAlign,tbLeader)	\
    (This)->lpVtbl -> AddTab(This,tbPos,tbAlign,tbLeader)

#define ITextPara_ClearAllTabs(This)	\
    (This)->lpVtbl -> ClearAllTabs(This)

#define ITextPara_DeleteTab(This,tbPos)	\
    (This)->lpVtbl -> DeleteTab(This,tbPos)

#define ITextPara_GetTab(This,iTab,ptbPos,ptbAlign,ptbLeader)	\
    (This)->lpVtbl -> GetTab(This,iTab,ptbPos,ptbAlign,ptbLeader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetDuplicate_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara);


void __RPC_STUB ITextPara_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetDuplicate_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara);


void __RPC_STUB ITextPara_SetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_CanChange_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextPara_CanChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_IsEqual_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextPara_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_Reset_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetStyle_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetStyle_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetAlignment_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetAlignment_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetHyphenation_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetHyphenation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetHyphenation_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetHyphenation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetFirstLineIndent_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetFirstLineIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetKeepTogether_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetKeepTogether_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetKeepTogether_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetKeepTogether_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetKeepWithNext_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetKeepWithNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetKeepWithNext_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetKeepWithNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLeftIndent_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLeftIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLineSpacing_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLineSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLineSpacingRule_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLineSpacingRule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListAlignment_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListAlignment_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListLevelIndex_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListLevelIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListLevelIndex_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListLevelIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListStart_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListStart_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetListTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListType_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListType_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetNoLineNumber_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetNoLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetNoLineNumber_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetNoLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetPageBreakBefore_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetPageBreakBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetPageBreakBefore_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetPageBreakBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetRightIndent_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetRightIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetRightIndent_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetRightIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetIndents_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float StartIndent,
    /* [in] */ float LeftIndent,
    /* [in] */ float RightIndent);


void __RPC_STUB ITextPara_SetIndents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetLineSpacing_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long LineSpacingRule,
    /* [in] */ float LineSpacing);


void __RPC_STUB ITextPara_SetLineSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetSpaceAfter_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetSpaceAfter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetSpaceAfter_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetSpaceAfter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetSpaceBefore_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetSpaceBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetSpaceBefore_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetSpaceBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetWidowControl_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetWidowControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetWidowControl_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetWidowControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetTabCount_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextPara_GetTabCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_AddTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float tbPos,
    /* [in] */ long tbAlign,
    /* [in] */ long tbLeader);


void __RPC_STUB ITextPara_AddTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_ClearAllTabs_Proxy( 
    ITextPara __RPC_FAR * This);


void __RPC_STUB ITextPara_ClearAllTabs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_DeleteTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ float tbPos);


void __RPC_STUB ITextPara_DeleteTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetTab_Proxy( 
    ITextPara __RPC_FAR * This,
    /* [in] */ long iTab,
    /* [out] */ float __RPC_FAR *ptbPos,
    /* [out] */ long __RPC_FAR *ptbAlign,
    /* [out] */ long __RPC_FAR *ptbLeader);


void __RPC_STUB ITextPara_GetTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextPara_INTERFACE_DEFINED__ */


#ifndef __ITextStoryRanges_INTERFACE_DEFINED__
#define __ITextStoryRanges_INTERFACE_DEFINED__

/* interface ITextStoryRanges */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextStoryRanges;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CC497C5-A1DF-11ce-8098-00AA0047BE5D")
    ITextStoryRanges : public IDispatch
    {
    public:
        virtual /* [restricted][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long Index,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoryRangesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextStoryRanges __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextStoryRanges __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [restricted][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            ITextStoryRanges __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        END_INTERFACE
    } ITextStoryRangesVtbl;

    interface ITextStoryRanges
    {
        CONST_VTBL struct ITextStoryRangesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoryRanges_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoryRanges_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoryRanges_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoryRanges_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextStoryRanges_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextStoryRanges_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextStoryRanges_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextStoryRanges__NewEnum(This,ppunkEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppunkEnum)

#define ITextStoryRanges_Item(This,Index,ppRange)	\
    (This)->lpVtbl -> Item(This,Index,ppRange)

#define ITextStoryRanges_GetCount(This,pCount)	\
    (This)->lpVtbl -> GetCount(This,pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [restricted][id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges__NewEnum_Proxy( 
    ITextStoryRanges __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum);


void __RPC_STUB ITextStoryRanges__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges_Item_Proxy( 
    ITextStoryRanges __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextStoryRanges_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges_GetCount_Proxy( 
    ITextStoryRanges __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextStoryRanges_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoryRanges_INTERFACE_DEFINED__ */


#ifndef __ITextDocument2_INTERFACE_DEFINED__
#define __ITextDocument2_INTERFACE_DEFINED__

/* interface ITextDocument2 */
/* [object][nonextensible][dual][version][uuid] */ 


EXTERN_C const IID IID_ITextDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01c25500-4268-11d1-883a-3c8b00c10000")
    ITextDocument2 : public ITextDocument
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachMsgFilter( 
            /* [in] */ IUnknown __RPC_FAR *pFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEffectColor( 
            /* [in] */ long Index,
            /* [in] */ COLORREF cr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEffectColor( 
            /* [in] */ long Index,
            /* [out] */ COLORREF __RPC_FAR *pcr) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetCaretType( 
            /* [retval][out] */ long __RPC_FAR *pCaretType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE SetCaretType( 
            /* [in] */ long CaretType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetImmContext( 
            /* [retval][out] */ long __RPC_FAR *pContext) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseImmContext( 
            /* [in] */ long Context) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPreferredFont( 
            /* [in] */ long cp,
            /* [in] */ long CodePage,
            /* [in] */ long Option,
            /* [in] */ long curCodepage,
            /* [in] */ long curFontSize,
            /* [out] */ BSTR __RPC_FAR *pbstr,
            /* [out] */ long __RPC_FAR *pPitchAndFamily,
            /* [out] */ long __RPC_FAR *pNewFontSize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetNotificationMode( 
            /* [retval][out] */ long __RPC_FAR *pMode) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE SetNotificationMode( 
            /* [in] */ long Mode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetClientRect( 
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *pLeft,
            /* [out] */ long __RPC_FAR *pTop,
            /* [out] */ long __RPC_FAR *pRight,
            /* [out] */ long __RPC_FAR *pBottom) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetSelectionEx( 
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ long __RPC_FAR *phWnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFEFlags( 
            /* [out] */ long __RPC_FAR *pFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateWindow( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckTextLimit( 
            long cch,
            long __RPC_FAR *pcch) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMEInProgress( 
            long Mode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SysBeep( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ long Mode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ long Notify) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDocumentFont( 
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppITextFont) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDocumentPara( 
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppITextPara) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCallManager( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppVoid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseCallManager( 
            IUnknown __RPC_FAR *pVoid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextDocument2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextDocument2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextDocument2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelection )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryCount )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryRanges )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaved )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSaved )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTabStop )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTabStop )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ float Value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *New )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unfreeze )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEditCollection )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEditCollection )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Range )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeFromPoint )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachMsgFilter )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEffectColor )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Index,
            /* [in] */ COLORREF cr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEffectColor )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Index,
            /* [out] */ COLORREF __RPC_FAR *pcr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCaretType )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCaretType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCaretType )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long CaretType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImmContext )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pContext);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseImmContext )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Context);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPreferredFont )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long cp,
            /* [in] */ long CodePage,
            /* [in] */ long Option,
            /* [in] */ long curCodepage,
            /* [in] */ long curFontSize,
            /* [out] */ BSTR __RPC_FAR *pbstr,
            /* [out] */ long __RPC_FAR *pPitchAndFamily,
            /* [out] */ long __RPC_FAR *pNewFontSize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNotificationMode )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pMode);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotificationMode )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Mode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientRect )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *pLeft,
            /* [out] */ long __RPC_FAR *pTop,
            /* [out] */ long __RPC_FAR *pRight,
            /* [out] */ long __RPC_FAR *pBottom);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelectionEx )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindow )( 
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *phWnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFEFlags )( 
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *pFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateWindow )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckTextLimit )( 
            ITextDocument2 __RPC_FAR * This,
            long cch,
            long __RPC_FAR *pcch);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IMEInProgress )( 
            ITextDocument2 __RPC_FAR * This,
            long Mode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SysBeep )( 
            ITextDocument2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Mode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Notify);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentFont )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppITextFont);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentPara )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppITextPara);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallManager )( 
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppVoid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseCallManager )( 
            ITextDocument2 __RPC_FAR * This,
            IUnknown __RPC_FAR *pVoid);
        
        END_INTERFACE
    } ITextDocument2Vtbl;

    interface ITextDocument2
    {
        CONST_VTBL struct ITextDocument2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextDocument2_GetName(This,pName)	\
    (This)->lpVtbl -> GetName(This,pName)

#define ITextDocument2_GetSelection(This,ppSel)	\
    (This)->lpVtbl -> GetSelection(This,ppSel)

#define ITextDocument2_GetStoryCount(This,pCount)	\
    (This)->lpVtbl -> GetStoryCount(This,pCount)

#define ITextDocument2_GetStoryRanges(This,ppStories)	\
    (This)->lpVtbl -> GetStoryRanges(This,ppStories)

#define ITextDocument2_GetSaved(This,pValue)	\
    (This)->lpVtbl -> GetSaved(This,pValue)

#define ITextDocument2_SetSaved(This,Value)	\
    (This)->lpVtbl -> SetSaved(This,Value)

#define ITextDocument2_GetDefaultTabStop(This,pValue)	\
    (This)->lpVtbl -> GetDefaultTabStop(This,pValue)

#define ITextDocument2_SetDefaultTabStop(This,Value)	\
    (This)->lpVtbl -> SetDefaultTabStop(This,Value)

#define ITextDocument2_New(This)	\
    (This)->lpVtbl -> New(This)

#define ITextDocument2_Open(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Open(This,pVar,Flags,CodePage)

#define ITextDocument2_Save(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Save(This,pVar,Flags,CodePage)

#define ITextDocument2_Freeze(This,pCount)	\
    (This)->lpVtbl -> Freeze(This,pCount)

#define ITextDocument2_Unfreeze(This,pCount)	\
    (This)->lpVtbl -> Unfreeze(This,pCount)

#define ITextDocument2_BeginEditCollection(This)	\
    (This)->lpVtbl -> BeginEditCollection(This)

#define ITextDocument2_EndEditCollection(This)	\
    (This)->lpVtbl -> EndEditCollection(This)

#define ITextDocument2_Undo(This,Count,prop)	\
    (This)->lpVtbl -> Undo(This,Count,prop)

#define ITextDocument2_Redo(This,Count,prop)	\
    (This)->lpVtbl -> Redo(This,Count,prop)

#define ITextDocument2_Range(This,cp1,cp2,ppRange)	\
    (This)->lpVtbl -> Range(This,cp1,cp2,ppRange)

#define ITextDocument2_RangeFromPoint(This,x,y,ppRange)	\
    (This)->lpVtbl -> RangeFromPoint(This,x,y,ppRange)


#define ITextDocument2_AttachMsgFilter(This,pFilter)	\
    (This)->lpVtbl -> AttachMsgFilter(This,pFilter)

#define ITextDocument2_SetEffectColor(This,Index,cr)	\
    (This)->lpVtbl -> SetEffectColor(This,Index,cr)

#define ITextDocument2_GetEffectColor(This,Index,pcr)	\
    (This)->lpVtbl -> GetEffectColor(This,Index,pcr)

#define ITextDocument2_GetCaretType(This,pCaretType)	\
    (This)->lpVtbl -> GetCaretType(This,pCaretType)

#define ITextDocument2_SetCaretType(This,CaretType)	\
    (This)->lpVtbl -> SetCaretType(This,CaretType)

#define ITextDocument2_GetImmContext(This,pContext)	\
    (This)->lpVtbl -> GetImmContext(This,pContext)

#define ITextDocument2_ReleaseImmContext(This,Context)	\
    (This)->lpVtbl -> ReleaseImmContext(This,Context)

#define ITextDocument2_GetPreferredFont(This,cp,CodePage,Option,curCodepage,curFontSize,pbstr,pPitchAndFamily,pNewFontSize)	\
    (This)->lpVtbl -> GetPreferredFont(This,cp,CodePage,Option,curCodepage,curFontSize,pbstr,pPitchAndFamily,pNewFontSize)

#define ITextDocument2_GetNotificationMode(This,pMode)	\
    (This)->lpVtbl -> GetNotificationMode(This,pMode)

#define ITextDocument2_SetNotificationMode(This,Mode)	\
    (This)->lpVtbl -> SetNotificationMode(This,Mode)

#define ITextDocument2_GetClientRect(This,Type,pLeft,pTop,pRight,pBottom)	\
    (This)->lpVtbl -> GetClientRect(This,Type,pLeft,pTop,pRight,pBottom)

#define ITextDocument2_GetSelectionEx(This,ppSel)	\
    (This)->lpVtbl -> GetSelectionEx(This,ppSel)

#define ITextDocument2_GetWindow(This,phWnd)	\
    (This)->lpVtbl -> GetWindow(This,phWnd)

#define ITextDocument2_GetFEFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFEFlags(This,pFlags)

#define ITextDocument2_UpdateWindow(This)	\
    (This)->lpVtbl -> UpdateWindow(This)

#define ITextDocument2_CheckTextLimit(This,cch,pcch)	\
    (This)->lpVtbl -> CheckTextLimit(This,cch,pcch)

#define ITextDocument2_IMEInProgress(This,Mode)	\
    (This)->lpVtbl -> IMEInProgress(This,Mode)

#define ITextDocument2_SysBeep(This)	\
    (This)->lpVtbl -> SysBeep(This)

#define ITextDocument2_Update(This,Mode)	\
    (This)->lpVtbl -> Update(This,Mode)

#define ITextDocument2_Notify(This,Notify)	\
    (This)->lpVtbl -> Notify(This,Notify)

#define ITextDocument2_GetDocumentFont(This,ppITextFont)	\
    (This)->lpVtbl -> GetDocumentFont(This,ppITextFont)

#define ITextDocument2_GetDocumentPara(This,ppITextPara)	\
    (This)->lpVtbl -> GetDocumentPara(This,ppITextPara)

#define ITextDocument2_GetCallManager(This,ppVoid)	\
    (This)->lpVtbl -> GetCallManager(This,ppVoid)

#define ITextDocument2_ReleaseCallManager(This,pVoid)	\
    (This)->lpVtbl -> ReleaseCallManager(This,pVoid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_AttachMsgFilter_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pFilter);


void __RPC_STUB ITextDocument2_AttachMsgFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetEffectColor_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Index,
    /* [in] */ COLORREF cr);


void __RPC_STUB ITextDocument2_SetEffectColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetEffectColor_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Index,
    /* [out] */ COLORREF __RPC_FAR *pcr);


void __RPC_STUB ITextDocument2_GetEffectColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetCaretType_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCaretType);


void __RPC_STUB ITextDocument2_GetCaretType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetCaretType_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long CaretType);


void __RPC_STUB ITextDocument2_SetCaretType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetImmContext_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pContext);


void __RPC_STUB ITextDocument2_GetImmContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_ReleaseImmContext_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Context);


void __RPC_STUB ITextDocument2_ReleaseImmContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetPreferredFont_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long cp,
    /* [in] */ long CodePage,
    /* [in] */ long Option,
    /* [in] */ long curCodepage,
    /* [in] */ long curFontSize,
    /* [out] */ BSTR __RPC_FAR *pbstr,
    /* [out] */ long __RPC_FAR *pPitchAndFamily,
    /* [out] */ long __RPC_FAR *pNewFontSize);


void __RPC_STUB ITextDocument2_GetPreferredFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetNotificationMode_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pMode);


void __RPC_STUB ITextDocument2_GetNotificationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetNotificationMode_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Mode);


void __RPC_STUB ITextDocument2_SetNotificationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetClientRect_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Type,
    /* [out] */ long __RPC_FAR *pLeft,
    /* [out] */ long __RPC_FAR *pTop,
    /* [out] */ long __RPC_FAR *pRight,
    /* [out] */ long __RPC_FAR *pBottom);


void __RPC_STUB ITextDocument2_GetClientRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetSelectionEx_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);


void __RPC_STUB ITextDocument2_GetSelectionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetWindow_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *phWnd);


void __RPC_STUB ITextDocument2_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetFEFlags_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *pFlags);


void __RPC_STUB ITextDocument2_GetFEFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_UpdateWindow_Proxy( 
    ITextDocument2 __RPC_FAR * This);


void __RPC_STUB ITextDocument2_UpdateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_CheckTextLimit_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    long cch,
    long __RPC_FAR *pcch);


void __RPC_STUB ITextDocument2_CheckTextLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_IMEInProgress_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    long Mode);


void __RPC_STUB ITextDocument2_IMEInProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SysBeep_Proxy( 
    ITextDocument2 __RPC_FAR * This);


void __RPC_STUB ITextDocument2_SysBeep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_Update_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Mode);


void __RPC_STUB ITextDocument2_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_Notify_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Notify);


void __RPC_STUB ITextDocument2_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetDocumentFont_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppITextFont);


void __RPC_STUB ITextDocument2_GetDocumentFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetDocumentPara_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppITextPara);


void __RPC_STUB ITextDocument2_GetDocumentPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetCallManager_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppVoid);


void __RPC_STUB ITextDocument2_GetCallManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_ReleaseCallManager_Proxy( 
    ITextDocument2 __RPC_FAR * This,
    IUnknown __RPC_FAR *pVoid);


void __RPC_STUB ITextDocument2_ReleaseCallManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextDocument2_INTERFACE_DEFINED__ */


#ifndef __ITextMsgFilter_INTERFACE_DEFINED__
#define __ITextMsgFilter_INTERFACE_DEFINED__

/* interface ITextMsgFilter */
/* [object][nonextensible][version][uuid] */ 


EXTERN_C const IID IID_ITextMsgFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3787420-4267-11d1-883a-3c8b00c10000")
    ITextMsgFilter : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachDocument( 
            /* [in] */ HWND hwnd,
            /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc,
            /* [in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HandleMessage( 
            /* [out][in] */ UINT __RPC_FAR *pmsg,
            /* [out][in] */ WPARAM __RPC_FAR *pwparam,
            /* [out][in] */ LPARAM __RPC_FAR *plparam,
            /* [out] */ LRESULT __RPC_FAR *plres) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachMsgFilter( 
            /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextMsgFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextMsgFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextMsgFilter __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachDocument )( 
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc,
            /* [in] */ IUnknown __RPC_FAR *punk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleMessage )( 
            ITextMsgFilter __RPC_FAR * This,
            /* [out][in] */ UINT __RPC_FAR *pmsg,
            /* [out][in] */ WPARAM __RPC_FAR *pwparam,
            /* [out][in] */ LPARAM __RPC_FAR *plparam,
            /* [out] */ LRESULT __RPC_FAR *plres);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachMsgFilter )( 
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter);
        
        END_INTERFACE
    } ITextMsgFilterVtbl;

    interface ITextMsgFilter
    {
        CONST_VTBL struct ITextMsgFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextMsgFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextMsgFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextMsgFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextMsgFilter_AttachDocument(This,hwnd,pTextDoc,punk)	\
    (This)->lpVtbl -> AttachDocument(This,hwnd,pTextDoc,punk)

#define ITextMsgFilter_HandleMessage(This,pmsg,pwparam,plparam,plres)	\
    (This)->lpVtbl -> HandleMessage(This,pmsg,pwparam,plparam,plres)

#define ITextMsgFilter_AttachMsgFilter(This,pMsgFilter)	\
    (This)->lpVtbl -> AttachMsgFilter(This,pMsgFilter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_AttachDocument_Proxy( 
    ITextMsgFilter __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc,
    /* [in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB ITextMsgFilter_AttachDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_HandleMessage_Proxy( 
    ITextMsgFilter __RPC_FAR * This,
    /* [out][in] */ UINT __RPC_FAR *pmsg,
    /* [out][in] */ WPARAM __RPC_FAR *pwparam,
    /* [out][in] */ LPARAM __RPC_FAR *plparam,
    /* [out] */ LRESULT __RPC_FAR *plres);


void __RPC_STUB ITextMsgFilter_HandleMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_AttachMsgFilter_Proxy( 
    ITextMsgFilter __RPC_FAR * This,
    /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter);


void __RPC_STUB ITextMsgFilter_AttachMsgFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextMsgFilter_INTERFACE_DEFINED__ */

#endif /* __tom_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\classreg.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      classreg.cpp
 *
 *  Contents:  Class registration code
 *
 *  History:   3-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"

#ifdef DBG
CTraceTag tagDllRegistration (_T("MMC Dll Registration"), _T("MMC Dll Registration"));
#endif //DBG

/*+-------------------------------------------------------------------------*
 * szObjScript
 *
 * Standard registration script template for all objects.  '%' characters
 * that we want to end up in the final script must be doubled (i.e. "%%")
 * because this string is used as a format string for sprintf.  sprintf
 * will convert "%%" to "%" during formatting.
 *--------------------------------------------------------------------------*/

static const WCHAR szObjScript[] =
    L"HKCR"                                                                     L"\n"
    L"{"                                                                        L"\n"
    L"    %%VProgID%% = s '%%VClassName%%'"                                     L"\n"
    L"    {"                                                                    L"\n"
    L"        CLSID = s '%%VCLSID%%'"                                           L"\n"
    L"    }"                                                                    L"\n"
    L"    %%VVersionIndependentProgID%% = s '%%VClassName%%'"                   L"\n"
    L"    {"                                                                    L"\n"
    L"        CLSID = s '%%VCLSID%%'"                                           L"\n"
    L"        CurVer = s '%%VProgID%%'"                                         L"\n"
    L"    }"                                                                    L"\n"
    L"    NoRemove CLSID"                                                       L"\n"
    L"    {"                                                                    L"\n"
    L"        ForceRemove %%VCLSID%% = s '%%VClassName%%'"                      L"\n"
    L"        {"                                                                L"\n"
    L"            ProgID = s '%%VProgID%%'"                                     L"\n"
    L"            VersionIndependentProgID = s '%%VVersionIndependentProgID%%'" L"\n"
    L"            %%ServerType%% = s '%%VFileName%%'"                           L"\n"
    L"            {"                                                            L"\n"
    L"                val ThreadingModel = s 'Apartment'"                       L"\n"
    L"            }"                                                            L"\n"
    L"            %s"    /* szCtlScript substituted here if necessary */        L"\n"
    L"        }"                                                                L"\n"
    L"    }"                                                                    L"\n"
    L"}";


/*+-------------------------------------------------------------------------*
 * szCtlScript
 *
 * Additional registration script elements for controls.  Note that '%'
 * characters we want to end up in the final script DO NOT need to be
 * doubled, because this string is used as a sprintf replacement parameter
 * (which are substituted as-is) and not the format string (where "%%"'s
 * are converted to "%").
 *--------------------------------------------------------------------------*/

static const WCHAR szCtlScript[] =
    L"            ForceRemove 'Programmable'"                                   L"\n"
    L"            ForceRemove 'Control'"                                        L"\n"
    L"            ForceRemove 'ToolboxBitmap32' = s '%VFileName%, %VBitmapID%'" L"\n"
    L"            'MiscStatus' = s '0'"                                         L"\n"
    L"            {"                                                            L"\n"
    L"                '1' = s '131473'"                                         L"\n"
    L"            }"                                                            L"\n"
    L"            'TypeLib' = s '%VLIBID%'"                                     L"\n"
    L"            'Version' = s '%VVersion%'";


/*+-------------------------------------------------------------------------*
 * MMCUpdateRegistry
 *
 * Registers a COM object or control.  This function typically isn't used
 * directly, but indirectly via DECLARE_MMC_OBJECT_REGISTRATION or
 * DECLARE_MMC_CONTROL_REGISTRATION.
 *
 * This function uses a class (ATL::CRegObject) that ATL only documents
 * indirectly.  Search MSDN for "StringRegister" to find sketchy details.
 *--------------------------------------------------------------------------*/

HRESULT WINAPI MMCUpdateRegistry (
    BOOL                        bRegister,      // I:register or unregister?
    const CObjectRegParams*     pObjParams,     // I:object registration parameters
    const CControlRegParams*    pCtlParams)     // I:control registration parameters (optional)
{
    DECLARE_SC(sc, TEXT("MMCUpdateRegistry"));

    /*
     * validate required inputs
     */
    sc = ScCheckPointers (pObjParams, E_FAIL);
    if(sc)
        return sc.ToHr();

    /*
     * string-ify the CLSID
     */
    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID (pObjParams->m_clsid, &spszClsid);
    if (sc)
        return sc.ToHr();

    /*
     * specify the standard object substitution parameters for CRegObject
     */
    ::ATL::ATL::CRegObject ro;  // hack around nested namespace bug in ATL30
    _ATL_REGMAP_ENTRY rgObjEntries[] =
    {
        {   L"VCLSID",                    spszClsid											},
        {   L"VFileName",                 pObjParams->m_strModuleName.data()				},
        {   L"VClassName",                pObjParams->m_strClassName.data()					},
        {   L"VProgID",                   pObjParams->m_strProgID.data()					},
        {   L"VVersionIndependentProgID", pObjParams->m_strVersionIndependentProgID.data()	},
        {   L"ServerType",				  pObjParams->m_strServerType.data()				},
    };

#ifdef DBG
	std::wstring strReplacements;
#endif

    for (int i = 0; i < countof (rgObjEntries); i++)
    {
        sc = ro.AddReplacement (rgObjEntries[i].szKey, rgObjEntries[i].szData);
        if (sc)
            return (sc.ToHr());

		AddReplacementTrace (strReplacements,
							 rgObjEntries[i].szKey,
							 rgObjEntries[i].szData);
    }


    /*
     * if we're registering a control, add its substitution parameters for CRegObject
     */
    if (pCtlParams != NULL)
    {
        /*
         * string-ify the LIBID
         */
        CCoTaskMemPtr<WCHAR> spszLibid;
        sc = StringFromCLSID (pCtlParams->m_libid, &spszLibid);
        if (sc)
            return (sc.ToHr());

        _ATL_REGMAP_ENTRY rgCtlEntries[] =
        {
            {   L"VLIBID",      spszLibid								},
            {   L"VBitmapID",   pCtlParams->m_strToolboxBitmapID.data()	},
            {   L"VVersion",    pCtlParams->m_strVersion.data()			},
        };

        for (int i = 0; i < countof (rgCtlEntries); i++)
        {
            sc = ro.AddReplacement (rgCtlEntries[i].szKey, rgCtlEntries[i].szData);
            if (sc)
                return (sc.ToHr());
	
			AddReplacementTrace (strReplacements,
								 rgCtlEntries[i].szKey,
								 rgCtlEntries[i].szData);
        }
    }

    /*
     * format the registration script
     */
    WCHAR szRegScript[countof(szObjScript) + countof(szCtlScript)];
    swprintf (szRegScript, szObjScript, (pCtlParams != NULL) ? szCtlScript : L"");

    USES_CONVERSION;
    Trace (tagDllRegistration, _T("Registration script:\n%s"), W2T(szRegScript));
    Trace (tagDllRegistration, W2CT(strReplacements.data()));

    /*
     * (un)register!
     */
    sc = (bRegister) ? ro.StringRegister   (szRegScript)
                     : ro.StringUnregister (szRegScript);

	if (sc)
	    return sc.ToHr();

	// change the module path to the absolute one, if we know it
	if ( bRegister && pObjParams->m_strModulePath.length() != 0 )
	{
		// format class ID key.
		tstring strKey = tstring(_T("CLSID\\")) + W2CT( spszClsid );
		strKey += tstring(_T("\\")) + W2CT( pObjParams->m_strServerType.c_str() );

		// see what type of value we need to put
		DWORD dwValueType = CModulePath::PlatformSupports_REG_EXPAND_SZ_Values() ?
							REG_EXPAND_SZ : REG_SZ;

		CRegKey keyServer;
		LONG lRet = keyServer.Open(HKEY_CLASSES_ROOT, strKey.c_str() , KEY_WRITE);
		if (lRet == ERROR_SUCCESS)
		{
			RegSetValueEx( keyServer, NULL, 0, dwValueType,
						   (CONST BYTE *)( W2CT( pObjParams->m_strModulePath.c_str() ) ),
						   (pObjParams->m_strModulePath.length() + 1) * sizeof(TCHAR) );
		}
	}

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\comobjects.cpp ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       comobjects.cpp
//
//  Contents:   Base code for com objects exported by Object Model.
//
//  Classes:    CMMCStrongReferences
//
//  History:    16-May-2000 AudriusZ     Created
//
//--------------------------------------------------------------------

#include "stdafx.h"
#include <atlcom.h>
#include "comerror.h"
#include "events.h"
#include "comobjects.h"


/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::AddRef
 *
 * PURPOSE: (static) puts a strong reference on mmc
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    DWORD    -
 *
\***************************************************************************/
DWORD CMMCStrongReferences::AddRef()
{
    return GetSingletonObject().InternalAddRef();
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::Release
 *
 * PURPOSE: (static) releases strong reference from MMC
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    DWORD
 *
\***************************************************************************/
DWORD CMMCStrongReferences::Release()
{
    return GetSingletonObject().InternalRelease();
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::LastRefReleased
 *
 * PURPOSE: returns whether the last strong reference was released
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    bool    - true == last ref was released
 *
\***************************************************************************/
bool CMMCStrongReferences::LastRefReleased()
{
    return GetSingletonObject().InternalLastRefReleased();
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::CMMCStrongReferences
 *
 * PURPOSE: constructor
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
\***************************************************************************/
CMMCStrongReferences::CMMCStrongReferences() :
    m_dwStrongRefs(0),
    m_bLastRefReleased(false)
{
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::GetSingletonObject
 *
 * PURPOSE: (helper) returns reference to the singleton object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CMMCStrongReferences& - singleto object
 *
\***************************************************************************/
CMMCStrongReferences& CMMCStrongReferences::GetSingletonObject()
{
    static CMMCStrongReferences singleton;
    return singleton;
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::InternalAddRef
 *
 * PURPOSE: (helper) implements strong addreff
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    DWORD    -
 *
\***************************************************************************/
DWORD CMMCStrongReferences::InternalAddRef()
{
    return ++m_dwStrongRefs;
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::InternalRelease
 *
 * PURPOSE: (helper) implements strong release
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    DWORD    -
 *
\***************************************************************************/
DWORD CMMCStrongReferences::InternalRelease()
{
    if (--m_dwStrongRefs == 0)
        m_bLastRefReleased = true;

    return m_dwStrongRefs;
}

/***************************************************************************\
 *
 * METHOD:  CMMCStrongReferences::InternalLastRefReleased
 *
 * PURPOSE: (helper) returns whether the last strong ref was released
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    bool    - true == last ref was released
 *
\***************************************************************************/
bool CMMCStrongReferences::InternalLastRefReleased()
{
    return m_bLastRefReleased;
}

/***************************************************************************\
 *
 * FUNCTION:  GetComObjectEventSource
 *
 * PURPOSE: returns singleton for emmiting Com Object Events
            [ScOnDisconnectObjects() currently is the only event]
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CEventSource<CComObjectObserver>&
 *
\***************************************************************************/
MMCBASE_API
CEventSource<CComObjectObserver>&
GetComObjectEventSource()
{
    static CEventSource<CComObjectObserver> evSource;
    return evSource;
}

/***************************************************************************/
// static members of class CConsoleEventDispatcherProvider
MMCBASE_API
CConsoleEventDispatcher *CConsoleEventDispatcherProvider::s_pDispatcher = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\conuistr.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by conuistr.rc
//
#define IDR_MAINFRAME                   128
#define IDR_AMCTYPE                     129
#define IDR_MUIFRIENDLYNAME             130
#define IDS_NEWFOLDER                   181
#define IDS_NEWFAVORITE                 182
#define IDS_FAVFOLDER                   185
#define IDS_ABOUT_ON                    186
#define IDS_FAVORITES                   187
#define ID_HELP_HELPTOPICS              12804
#define IDS_FAVORITES_ACTIVATE          12811
#define IDS_ACTION_COULD_NOTBE_COMPLETED 12813
#define ID_CONSOLE_ADDREMOVESNAPIN      13201
#define ID_CONSOLE_PROPERTIES           13220
#define ID_CUSTOMIZE_VIEW               13231
#define ID_SNAPIN_ABOUT                 13242
#define IDS_WARNING                     13244
#define IDS_TaskpadChangeButtonText     13300
#define IDS_CONSOLE_READONLY            13301
#define IDS_CONVERT_FILE_FORMAT         13302
#define IDS_CONVERT_FILE_FORMAT_CLOSE   13303
#define IDS_CantCloseLastPersistableView 13304
#define IDS_UnableToOpenDocumentMessage 13305
#define IDS_UnableToSaveDocumentMessage 13306
#define IDS_NoActiveView                13307
#define IDS_MENU_FILE                   13308
#define IDS_MENU_VIEW                   13309
#define IDS_MENU_WINDOW                 13310
#define IDS_MENU_HELP                   13311
#define AMC_IDS_WEBCTRL_FAILED_CREATE   13312
#define IDS_ModeAuthor                  13313
#define IDS_ModeUserFull                13314
#define IDS_ModeUserMDI                 13315
#define IDS_ModeUserSDI                 13316
#define IDS_ModeAuthor_Description      13317
#define IDS_ModeUserFull_Description    13318
#define IDS_ModeUserMDI_Description     13319
#define IDS_ModeUserSDI_Description     13320
#define IDS_AUTHORMODE_NOTALLOWED       13321
#define ID_FILE_SNAPINMANAGER           13322
#define IDS_NODEMGR_FAILED              13323
#define IDS_AUTHORMODE_NOTALLOWED_FORSCRIPTS 13324
#define IDS_APP_NAME                    13325
#define ID_VIEW_OPTIONS                 13326
#define IDS_TempDirNotFound             13327
#define ID_WINDOW_TILEVERTICALLY        13328
#define ID_WINDOW_CLOSEALL              13329
#define IDS_Empty                       13330
#define IDS_DiskFull                    13331
#define ID_HELP_WEBTUTORIAL             13332
#define IDS_INVALIDFILE                 13333
#define ID_WINDOW_ACTIVATEWINDOW        13333
#define IDS_InvalidVersion              13334
#define IDS_UnableToLoadSomePortionOfTheTree 13335
#define IDS_FORCE_SDI_PROMPT            13336
#define IDS_NewerVersionRequired        13337
#define ID_VIEW_DESCRIPTIONBAR          13338
#define IDS_PROGRESS                    13339
#define IDS_STATUS_STATIC               13340
#define IDR_REBAR                       13341
#define ID_MENU_ACTION                  13342
#define IDS_CONSOLE_PROPERTIES          13343
#define IDS_LISTSAVE_ER1                13344
#define IDS_LISTSAVE_ER2                13345
#define IDS_LISTSAVE_ER3                13346
#define IDS_ANSI_FILE_TYPE              13347
#define IDS_UNICODE_FILE_TYPE           13348
#define IDS_MENUOPEN                    13349
#define IDS_MENURUNAS                   13350
#define IDS_MENUAUTHOR                  13351
#define IDS_APP_VERSION                 13352
#define IDS_FILESAVE_MESSAGE            13353
#define ID_MENU_VIEW                    13354
#define IDS_HELP_ON                     13355
#define IDS_HELP_ON_SNAPIN              13356
#define IDS_ASK_TO_SAVE                 13357
#define IDS_ClosePropertyPagesBeforeClosingTheDoc 13358
#define IDS_FileNotFound                13359
#define IDS_ExploredWindowFailed        13360
#define IDS_MMC_DOCUMENT                13361
#define IDS_MMCWillCancelPropertySheets 13368
#define IDS_CLOSE                       13375
#define IDS_NEXTWINDOW                  13376
#define IDS_SNAPINMGR_CLOSEPROPSHEET    13377
#define IDS_MENU_MMC_ACTION             13378
#define IDS_MENU_MMC_VIEW               13379
#define IDS_MENU_MMC_FAVORITES          13380
#define IDS_MMC_VERB_CUT                13381
#define IDS_MMC_VERB_COPY               13382
#define IDS_MMC_VERB_PASTE              13383
#define IDS_MMC_VERB_DELETE             13384
#define IDS_MMC_VERB_PROPERTIES         13385
#define IDS_MMC_GENL_UPONELEVEL         13386
#define IDS_MMC_GENL_SCOPE              13387
#define IDS_MMC_VERB_REFRESH            13388
#define IDS_MMC_VERB_PRINT              13389
#define IDS_MMC_VERB_RENAME             13390
#define IDS_MMC_VERB_OPEN               13391
#define IDS_MMC_WEB_BACK                13392
#define IDS_MMC_WEB_FORWARD             13393
#define IDS_MMC_WEB_STOP                13394
#define IDS_MMC_WEB_REFRESH             13395
#define IDS_MMC_WEB_HOME                13396
#define IDS_MMC_GENL_CONTEXTHELP        13397
#define IDS_SAVE_LIST_BUTTON            13398
#define IDS_CloseDocNotLastView         13399
#define IDS_NORMAL                      13400
#define MMC_E_RESULT_ITEM_NOT_FOUND     13401
#define MMC_E_NO_BOOKMARK               13402
#define MMC_E_NOLIST                    13403
#define MMC_E_NO_SELECTED_ITEMS         13404
#define MMC_E_OBJECT_IS_GONE            13405
#define MMC_E_INVALID_COLUMN_INDEX      13406
#define MMC_E_ZERO_COLUMN_INVISIBLE     13408
#define IDS_EMPTY_LIST_MESSAGE          13409
#define MMC_E_NO_MULTISELECT            13410
#define MMC_E_ViewNotExtended           13411
#define MMC_E_NotOnHostedFrame          13412
#define MMC_E_NO_OCX_IN_VIEW            13413
#define MMC_E_INCORRECT_IE_VERSION      13414
#define MMC_E_UnableToLaunchMMC32       13415
#define MMC_E_UnableToLaunchMMC64       13416
#define IDS_DragDrop_CopyHere           13417
#define IDS_DragDrop_MoveHere           13418
#define IDS_DragDrop_Cancel             13419
#define IDS_TabAccessiblity_DefaultAction 13420
#define IDS_FileSize_TB                 13421
#define IDS_FileSize_GB                 13422
#define IDS_FileSize_MB                 13423
#define IDS_FileSize_KB                 13424
#define IDS_FileSize_bytes              13425
#define IDS_ConfirmDeleteTempFiles      13426
#define IDS_NODEMGR_FAILED_9x           13427
#define AFX_IDS_APP_TITLE               0xE000
#define AFX_IDS_IDLEMESSAGE             0xE001
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_MRU_FILE1               0xE110
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#define IDS_EXPORT_LIST                 57654
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151
#define ID_INDICATOR_EXT                0xE700
#define ID_INDICATOR_CAPS               0xE701
#define ID_INDICATOR_NUM                0xE702
#define ID_INDICATOR_SCRL               0xE703
#define ID_INDICATOR_OVR                0xE704
#define ID_INDICATOR_REC                0xE705
#define ID_VIEW_TOOLBAR                 0xE800
#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13
#define AFX_IDS_MDICHILD                0xEF1F
#define AFX_IDS_PREVIEW_CLOSE           0xF005

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\mmcerror.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mmcerror.cpp
//
//  Contents:  Class definitions for mmc debug support code.
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "conuistr.h" // needed for IDR_MAINFRAME
#define  cchMaxSmallLine 256


#ifdef DBG
CTraceTag tagSCConversion(TEXT("SC"), TEXT("Conversion"));
CTraceTag tagCallDump(    TEXT("Function calls"), TEXT("ALL") );
#endif //DBG



//############################################################################
//############################################################################
//
// Definition of GetStringModule() - used by all binaries
//
//############################################################################
//############################################################################
HINSTANCE GetStringModule()
{
    return SC::GetHinst();
}

//############################################################################
//############################################################################
//
// Implementation of class SC
//
//############################################################################
//############################################################################

// static variables
HINSTANCE SC::s_hInst = 0;
HWND      SC::s_hWnd  = NULL;
DWORD     SC::s_dwMainThreadID = -1;

#ifdef DBG
UINT      SC::s_CallDepth = 0;
#endif

// accessors for the static variables.
void
SC::SetHinst(HINSTANCE hInst)
{
    s_hInst = hInst;
}

void
SC::SetHWnd(HWND hWnd)
{
    s_hWnd = hWnd;
}


void
SC::SetMainThreadID(DWORD dwThreadID)
{
    ASSERT(-1 != dwThreadID);
    s_dwMainThreadID = dwThreadID;
}

#ifdef DBG

SC&
SC::operator = (const SC& other)
{
    m_facility = other.m_facility;
    m_value = other.m_value;
    return *this;
}

SC::SC(const SC& other)
:   m_szFunctionName(NULL),
    m_szSnapinName(NULL)
{
    *this = other;
}


/*+-------------------------------------------------------------------------*
 *
 * SC::SetFunctionName
 *
 * PURPOSE: Sets the debug function name to the supplied string.
 *
 * PARAMETERS:
 *    LPCTSTR  szFunctionName : the supplied string.
 *
 * RETURNS:
 *    inline void
 *
 *+-------------------------------------------------------------------------*/
inline void SC::SetFunctionName(LPCTSTR szFunctionName)
{
    m_szFunctionName = szFunctionName;

    INCREMENT_CALL_DEPTH();

    // This computes the format string based on the call depth.
    // eg if s_CallDepth is 4, the string is "    %s"  (four spaces)
    //    if s_CallDepth is 5, the string is "     %s"  (five spaces)

    LPCTSTR szFormatString = TEXT("                                        %s");
    UINT    maxLen = _tcslen(szFormatString);

    UINT    formatLen = s_CallDepth + 2; // the -2 is for the "%s"

    formatLen = (formatLen < maxLen ? formatLen : maxLen);

    Trace(tagCallDump, szFormatString + (maxLen - formatLen), szFunctionName);
}

#endif

/*+-------------------------------------------------------------------------*
 *
 * SC::ToHr
 *
 * PURPOSE: Converts from a status code (SC) to an HRESULT. USE SPARINGLY.
 *
 * PARAMETERS: None
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
SC::ToHr() const
{
    HRESULT hr = S_OK;
    switch(GetFacility())
    {
    default:
        ASSERT(0 && "Should not come here.");
        break;

    case FACILITY_WIN:
        hr = HRESULT_FROM_WIN32 (GetCode());
        break;

    case FACILITY_MMC:
        Trace (tagSCConversion, _T("Converting from MMC error code to HRESULT, probable loss of fidelity"), *this);
        hr = (GetCode() != 0) ? E_UNEXPECTED : S_OK;
        break;

    case FACILITY_HRESULT:
        hr = (HRESULT) GetCode();
        break;
    }

    return hr;

}

/*+-------------------------------------------------------------------------*
 *
 * SC::GetErrorMessage
 *
 * PURPOSE: Writes the error message corresponding to the error code to
 *          the buffer pointed to by szMessage.
 *
 * PARAMETERS:
 *    UINT   maxLength : The maximum no of characters to output.
 *    LPTSTR szMessage : Pointer to the buffer to use. Must be non-null.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void SC::GetErrorMessage(UINT maxLength, /*[OUT]*/ LPTSTR szMessage) const
{
    ASSERT(szMessage != NULL && maxLength > 0);
    if (szMessage == NULL || maxLength == 0)
        return;

    szMessage[0] = 0;

    switch(GetFacility())
    {
    default:
        ASSERT(0 && "SC::GetErrorMessage: Unknown SC facility.");
        break;

    case FACILITY_WIN:
    case FACILITY_HRESULT:
        {
            int nChars = 0;

            if ( GetCode() == E_UNEXPECTED )
            {
                nChars = ::LoadString(SC::GetHinst(), IDS_E_UNEXPECTED, szMessage, maxLength);
            }
            else
            {
                DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;
                void  *lpSource = NULL;

                // add XML module to be searched as well
                HMODULE hmodXML = GetModuleHandle(_T("msxml.dll"));
                if (hmodXML)
                {
                    dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
                    lpSource = hmodXML;
                }

                DWORD dwMessageID = GetCode();

                // reverse values made by HRESULT_FROM_WIN32
                // Not sure why ::FormatMessage does not work with such values,
                // but we need to convert them back, or else there won't be any messages
                if ( (dwMessageID & 0xFFFF0000) == ((FACILITY_WIN32 << 16) | 0x80000000) )
                    dwMessageID &= 0x0000FFFF;

                nChars = ::FormatMessage(   dwFlags,
                                            lpSource,
                                            dwMessageID,
                                            0,          /*dwLangID*/
                                            szMessage,  /*lpBuffer*/
                                            maxLength,  /*nSize*/
                                            0           /*Arguments*/
                                        );
            }

            if (nChars)
                break;

            // if former failed - add a default error
            nChars = ::LoadString(SC::GetHinst(), IDS_MESSAGE_NOT_FOUND_ERROR, szMessage, maxLength);

            if (nChars == 0)
            {
                // too bad. we can only use hardcoded one
                _tcsncpy(szMessage, _T("Unknown error"), maxLength);
                szMessage[maxLength - 1] = 0;
            }
        }
        break;

    case FACILITY_MMC:
        {
            int nChars = ::LoadString(GetHinst(), GetCode(), szMessage, maxLength);
            if(nChars == 0) // did not exist
            {
                nChars = ::LoadString(GetHinst(), IDS_MESSAGE_NOT_FOUND_ERROR, szMessage, maxLength);
                ASSERT(nChars > 0);
            }
        }
        break;
    }
}


/*+-------------------------------------------------------------------------*
 *
 * SC::GetHelpID
 *
 * PURPOSE: Returns the help ID associated with a status code
 *
 * RETURNS:
 *    DWORD
 *
 *+-------------------------------------------------------------------------*/
DWORD
SC::GetHelpID()
{
    return 0; // TODO
}

LPCTSTR
SC::GetHelpFile()
{
    static TCHAR szFilePath[MAX_PATH] = TEXT("\0");

    // set the path if not already set
    if(*szFilePath == TEXT('\0') )
    {
        DWORD dwCnt = ExpandEnvironmentStrings(_T("%WINDIR%\\help\\mmc.chm"), szFilePath, MAX_PATH);
        ASSERT(dwCnt != 0);
    }

    return szFilePath;
}

void SC::Throw() throw(SC)
{
    // make exact copy of itself and destroy it (forces all the output)
#ifdef DBG
    {
        SC sc(*this);
        sc.SetFunctionName(m_szFunctionName);
        // forget the debug info - it will not be usefull anyway
        // This will turn off the Trace on destructor
        SetFunctionName(NULL);
    }
#endif // DBG

    throw(*this);
}

void SC::Throw(HRESULT hr)
{
    (*this) = hr;
    Throw();
}


/*+-------------------------------------------------------------------------*
 *
 * SC::FatalError
 *
 * PURPOSE:  Terminates the application.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
SC::FatalError() const
{
    MMCErrorBox(*this);
    exit(1);
}

/*+-------------------------------------------------------------------------*
 *
 * SC::FromLastError
 *
 * PURPOSE:  Fill SC with value from GetLastError.
 *
 *           The SC is guaranteed to contain a failure code (i.e. IsError()
 *           will return true) when this function returns.
 *
 * RETURNS:  Reference to the current SC
 *
 *+-------------------------------------------------------------------------*/
SC& SC::FromLastError()
{
    FromWin32 (::GetLastError());

	/*
	 * Some APIs will fail without setting extended error information.
	 * Presumably this function was called in response to an error, so
	 * we always want this SC to indicate *some* sort of error.  If the
	 * failing API neglected to set extended error information, give
	 * this SC a generic error code
	 */
	if (!IsError())
		MakeSc (FACILITY_HRESULT, E_FAIL);

	ASSERT (IsError());
	return (*this);
}

//############################################################################
//############################################################################
//
// Error formatting
//
//############################################################################
//############################################################################
/*
 *  Purpose:    Formats an error message
 *
 *  Parameters:
 *      ids     String describing the operation in progress
 *      sc      Error code describing the problem encountered
 *      pstrMessage
 *              the resulting message.
 */
void FormatErrorIds(UINT ids, SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage)
{
    TCHAR   sz[cchMaxSmallLine];
    LoadString(SC::GetHinst(), IDR_MAINFRAME, sz, cchMaxSmallLine);
    FormatErrorString(sz, sc, maxLength, szMessage);
}

//
// Returns a short version of an error message associated a given SC.
//
void FormatErrorShort(SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage)
{
    FormatErrorString(NULL, sc, maxLength, szMessage, TRUE);
}

//
// FormatErrorString formats an error message from any SC
//
// Parameters:
//      szOperation
//              String describing the operation in progress
//              May be NULL if sc is sufficient.
//      szMessage
//              the resulting message.
//      fShort
//              TRUE if you want the error message only (no header/footer)
//
void FormatErrorString(LPCTSTR szOperation, SC sc , UINT maxLength, /*[OUT]*/ LPTSTR szMessage, BOOL fShort)
{
    sc.GetErrorMessage(maxLength, szMessage);
    // TODO: add p
}

//############################################################################
//############################################################################
//
// MMCErrorBox
//
//############################################################################
//############################################################################

/*
 *  MMCErrorBox
 *
 *  Purpose:    Displays an Error Box for the given SZ.
 *          NOTE: This is the one that actually puts-up the dialog.
 *
 *  Parameters:
 *      sz          Pointer to the message to display
 *      fuStyle     As per windows MessageBox
 *
 *  Return value:
 *      int         Button Pressed to dismiss the ErrorBox
 */
int MMCErrorBox(LPCTSTR szMessage, UINT fuStyle )
{
    INT             id;

    // If not system modal (background thread), force task modal.
     if (!(fuStyle &  MB_SYSTEMMODAL))
        fuStyle |= MB_TASKMODAL;

    TCHAR   szCaption[cchMaxSmallLine];
    LoadString(SC::GetHinst(), IDR_MAINFRAME, szCaption, cchMaxSmallLine);

    // get window to parent the message box
    HWND hWndActive = SC::GetHWnd();

    // cannot parent on hidden window!
    if ( !IsWindowVisible(hWndActive) )
        hWndActive = NULL;

    id = ::MessageBox(hWndActive, szMessage, szCaption, fuStyle);

    return id;
}


/*+-------------------------------------------------------------------------*
 *
 * MMCErrorBox
 *
 * PURPOSE: Displays an error box with the specified message and style
 *
 * PARAMETERS:
 *    UINT  idsOperation :
 *    UINT  fuStyle :
 *
 * RETURNS:
 *    int: Button pressed
 *
 *+-------------------------------------------------------------------------*/
int
MMCErrorBox(UINT idsOperation, UINT fuStyle)
{
    TCHAR sz[cchMaxSmallLine];
    LoadString(SC::GetHinst(), idsOperation, sz, cchMaxSmallLine);
    return MMCErrorBox(sz, fuStyle);
}


/*
 *  MMCErrorBox
 *
 *  Purpose:    Displays a complex Error Box, given the operation
 *              and the status code
 *
 *  Parameters:
 *      ids         description of the operation that failed.
 *      SC          Status Code to report
 *      fuStyle     As per windows MessageBox
 *
 *  Return value:
 *      int         Button Pressed to dismiss the ErrorBox
 */
int MMCErrorBox(UINT ids, SC sc, UINT fuStyle)
{
    TCHAR sz[cchMaxSmallLine];
    LoadString(SC::GetHinst(), ids, sz, cchMaxSmallLine);
    return MMCErrorBox(sz, sc, fuStyle);
}

/*
 *  MMCErrorBox
 *
 *  Purpose:    Displays a complex Error Box, given the operation
 *              and the status code
 *
 *  Parameters:
 *      szOperation Description of the operation that failed.
 *      sz          Status Code to report
 *      fuStyle     As per windows MessageBox
 *
 *  Return value:
 *      int         Button Pressed to dismiss the ErrorBox
 */
int MMCErrorBox(LPCTSTR szOperation, SC sc, UINT fuStyle)
{
    TCHAR sz[cchMaxSmallLine];
    FormatErrorString(szOperation, sc, cchMaxSmallLine, sz);
    return MMCErrorBox(sz, fuStyle);
}

/*
 *  MMCErrorBox
 *
 *  Purpose:    Displays an Error Box for the given Status Code.
 *
 *  Parameters:
 *      SC          Status Code to report
 *      fuStyle     As per windows MessageBox
 *
 *  Return value:
 *      int         Button Pressed to dismiss the ErrorBox
 */
int MMCErrorBox(SC sc, UINT fuStyle)
{
    TCHAR sz[cchMaxSmallLine];
    FormatErrorString(NULL, sc, cchMaxSmallLine, sz);
    return MMCErrorBox(sz, fuStyle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\nodemgrstr.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nodemgrstr.rc
//
#define IDS_NODEINIT_DESC               1
#define IDS_SCOPETREE_DESC              2
#define IDS_DOCCONFIG_DESC              4
#define IDS_ALL_CATEGORIES              213
#define IDS_ACTIVEXCONTROL              214
#define IDS_PROPERTIES                  14000
#define IDS_COLUMNS                     14001
#define IDS_CREATE_NEW                  14002
#define IDS_SNAPIN_CREATE_FAILED        14003
#define IDS_SNAPIN_FAILED               14004
#define IDS_SNAPIN_POLICYFAILURE        14005
#define IDS_VERSION                     14006
#define IDS_ABOUT                       14007
#define IDS_FOLDER                      14008
#define IDS_CUSTOMIZE                   14009
#define IDS_HTML                        14010
#define IDS_SHORTCUT                    14011
#define IDS_ENUMERATED                  14012
#define IDS_SNAPINSTR                   14013
#define IDS_CONTROL_NAME                14014
#define IDS_CATEGORY                    14015
#define IDS_NO_PERMISSION_SHUTDOWN      14016
#define IDS_VENDOR                      14017
#define IDS_ColumnsCouldNotBePersisted  14018
#define IDS_SNAPIN_NOTALLOWED           14019
#define IDS_EXTENSION_NOTALLOWED        14020
#define IDS_ViewSettingCouldNotBePersisted 14021
#define IDS_SNAPIN_SAVE_FAILED          14022
#define MMC_E_SnapinNotAdded            14023
#define IDS_WizardTitleFont             14024
#define MMC_E_SNAPINNOTFOUND            14025
#define IDS_NOT_INSTALLED2              14027
#define ID_SNP_PROPERTIES               14028
#define ID_SNP_MANAGER_TITLE            14029
#define ID_SNP_UP                       14030
#define ID_SNP_DELETE                   14031
#define IDS_VIEW_FILTERED               14032
#define ID_SNP_STANDALONE               14033
#define ID_SNP_ALLSNAPINS               14034
#define ID_SNP_EXTENSION                14035
#define IDS_WizardTitleFontSize         14036
#define IDS_NOT_INSTALLED               14037
#define IDS_SNAPINTYPE0                 14038
#define IDS_SNAPINTYPE1                 14039
#define IDS_SNAPINTYPE2                 14040
#define IDS_EXTENSION                   14041
#define SNP_DELETE_TITLE                14042
#define SNP_DELETE_TEXT                 14043
#define IDS_ROOTFOLDER_NAME             14044
#define SNPADD_ERROR1                   14045
#define IDS_SELECT_ALL                  14046
#define IDS_EXPLORE                     14047
#define IDS_OPEN                        14048
#define IDS_CUT                         14049
#define IDS_COPY                        14050
#define IDS_PASTE                       14051
#define IDS_DELETE                      14052
#define IDS_PRINT                       14053
#define IDS_REFRESH                     14054
#define IDS_RENAME                      14055
#define IDS_DOCKING                     14056
#define IDS_NEW_TASKPAD_FROM_HERE       14057
#define IDS_SNAPINMANAGER               14058
#define IDS_ARRANGE_NAME                14059
#define IDS_ARRANGE_TYPE                14060
#define IDS_ARRANGE_SIZE                14061
#define IDS_ARRANGE_DATE                14062
#define IDS_TASK                        14063
#define IDS_SCOPE_PANE                  14064
#define IDS_MMC_MENU_ACTION             14065
#define IDS_MMC_MENU_VIEW               14066
#define IDS_NEW_FOLDER_NAME             14067
#define IDS_PROP_ON_MULTIOBJ            14068
#define IDS_TASKPAD_NAME_REQUIRED_ERROR 14069
#define IDS_COMCAT_LOAD_ERR             14070
#define IDS_CLASSCAT_ENUM_ERR           14071
#define IDS_COMCAT_NONAME               14072
#define IDS_SHORTCUT_FILES              14077
#define IDS_BROWSE_SHORTCUT             14078
#define IDS_HTML_FILES                  14079
#define IDS_BROWSE_WEBLINK              14080
#define IDS_ACTIVEX_FILES               14081
#define IDS_BROWSE_ACTIVEX              14082
#define IDS_NOT_IMPLEMENTED             14083
#define IDS_CONSOLE_TOPIC               14084
#define IDS_MMC_MENU_FAVORITES          14085
#define IDS_SAVE_LIST                   14086
#define IDS_TASKPAD_ROOT_FOLDER_NAME    14087
#define IDS_INVALID_COMMAND             14088
#define IDS_RETARGET_BUTTON_TEXT        14089
#define IDS_INVALID_CONTEXT_LEVEL       14090
#define IDS_ITEM_DOES_NOT_EXIST         14091
#define IDS_NEW_TASKPAD                 14092
#define IDS_NEWTASK                     14093
#define IDS_MOVETO                      14094
#define IDS_ORDER                       14095
#define IDS_NEWGROUP                    14096
#define IDS_TASKPADS                    14097
#define IDS_TPSTYLE_VERT                14098
#define IDS_TPSTYLE_VERT_DESCR          14099
#define IDS_TPSTYLE_HORZ                14100
#define IDS_TPSTYLE_HORZ_DESCR          14101
#define IDS_TPSTYLE_NOLIST              14102
#define IDS_TPSTYLE_NOLIST_DESCR        14103
#define IDS_BROWSE_SYMBOL               14104
#define IDS_SYMBOL_FILES                14105
#define IDS_TPSTYLE_LONGDESCR           14106
#define IDS_TPSTYLE_LONGDESCR_DESCR     14107
#define IDS_TaskProps_MenuCommand       14108
#define IDS_TaskProps_CommandLine       14109
#define IDS_TaskProps_TaskpadList       14110
#define IDS_TaskProps_ConsoleTree       14111
#define IDS_TaskProps_Minimized         14112
#define IDS_TaskProps_Maximized         14113
#define IDS_TaskProps_Restored          14114
#define IDS_TaskProps_ModifyTitle       14115
#define IDS_TaskProps_ProgramFilter     14116
#define IDS_TaskProps_ErrorNoTaskName   14117
#define IDS_TaskProps_ErrorNoCommand    14118
#define IDS_TargetNodeName              14119
#define IDS_TargetNodeParentName        14120
#define IDS_TARGETNODELOCATE            14121
#define IDS_TaskProps_TargetNode        14122
#define IDS_TASK_MENU_COMMAND_REQUIRED  14123
#define IDS_COLUMN_TASK                 14124
#define IDS_COLUMN_TOOLTIP              14125
#define IDS_InvalidTarget               14126
#define IDS_EDIT_TASKPAD                14127
#define IDS_SNAPIN_FAILED_INIT_NAME     14128
#define IDS_SNAPIN_FAILED_INIT_CLSID    14129
#define IDS_NOT_AVAILABLE               14130
#define IDS_SYMBOL_REQUIRED             14131
#define IDS_NO_TASKPAD                  14132
#define IDS_DELETE_TASKPAD              14133
#define IDS_TaskpadWiz_NamePageTitle    14134
#define IDS_TaskpadWiz_NamePageSubtitle 14135
#define IDS_TaskpadWiz_NodeTypePageTitle 14136
#define IDS_TaskpadWiz_NodeTypePageSubtitle 14137
#define IDS_TaskpadWiz_StylePageTitle   14138
#define IDS_TaskpadWiz_StylePageSubtitle 14139
#define IDS_TaskpadWiz_TitlePageTitle   14140
#define IDS_TaskpadWiz_TitlePageSubtitle 14141
#define IDS_TaskWiz_CmdLinePageTitle    14142
#define IDS_TaskWiz_CmdLinePageSubtitle 14143
#define IDS_TaskWiz_MenuPageTitle       14144
#define IDS_TaskWiz_MenuPageSubtitle    14145
#define IDS_TaskWiz_NamePageTitle       14146
#define IDS_TaskWiz_NamePageSubtitle    14147
#define IDS_TaskWiz_SymbolPageTitle     14148
#define IDS_TaskWiz_SymbolPageSubtitle  14149
#define IDS_TaskWiz_TypePageTitle       14150
#define IDS_TaskWiz_TypePageSubtitle    14151
#define IDS_Small                       14152
#define IDS_Medium                      14153
#define IDS_Large                       14154
#define IDS_TASKSOURCE_RESULT           14155
#define IDS_TASKSOURCE_SCOPE            14156
#define IDS_TaskWiz_FavoritePage_Title  14157
#define IDS_TaskWiz_FavoritePage_Subtitle 14158
#define IDS_FOLDERSNAPIN_DESC           14159
#define IDS_BUILTIN_SNAPIN_PROVIDER     14160
#define IDS_OCXWiz_ControlPageTitle     14162
#define IDS_HTMLSNAPIN_DESC             14163
#define IDS_OCXWiz_ControlPageSubTitle  14166
#define IDS_OCXSNAPIN_DESC              14167
#define IDS_MMC_CONTEXTHELP             14170
#define MMC_E_CannotChangeProperty      14171
#define MMC_E_CannotRemoveProperty      14172
#define MMC_E_UnrecognizedProperty      14173
#define MMC_E_TheVerbNotEnabled         14174
#define IDS_ExplorerView                14175
#define MMC_E_CannotDisableExtension    14176
#define IDS_ViewExtSnapinName           14177
#define IDS_UnknownSnapinName           14178

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\mmcbase.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      mmcbase.cpp
 *
 *  Contents:  Main entry point for mmcbase.dll
 *
 *  History:   7-Jan-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "atlimpl.cpp"
#include "atlwin.cpp"


static SC ScInitAsMFCExtensionModule (HINSTANCE hInstance);

// the one and only instance.
CComModule _Module;


/*+-------------------------------------------------------------------------*
 *
 * DllMain
 *
 * PURPOSE:     The main DLL entry point
 *
 * PARAMETERS:
 *    HANDLE  hModule :
 *    DWORD   dwReason :
 *    LPVOID  lpReserved :
 *
 * RETURNS:
 *    BOOL APIENTRY
 *
 *+-------------------------------------------------------------------------*/
BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD  dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // set the module instance for error codes.
        SC::SetHinst(hInstance);

        /*
         * attach this module to MFC's resource search path
         */
        if (ScInitAsMFCExtensionModule(hInstance).IsError())
            return (FALSE); // bail out

        _Module.Init(NULL, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }

    return TRUE;    // ok
}


/*+-------------------------------------------------------------------------*
 * ScInitAsMFCExtensionModule
 *
 * Initializes this module as an MFC extension.  This is required so MFC
 * code will automatically search this module for resources (in particular,
 * strings).
 *--------------------------------------------------------------------------*/

static SC ScInitAsMFCExtensionModule (HINSTANCE hInstance)
{
    DECLARE_SC (sc, _T("ScInitAsMFCExtensionModule"));

    /*
     * extensionDLL must be static so it lives as long as dynLinkLib below
     */
    static AFX_EXTENSION_MODULE extensionDLL = { 0 };

    if (!AfxInitExtensionModule (extensionDLL, hInstance))
        return (sc = E_FAIL);

    /*
     * Declare a static CDynLinkLibrary for MMC.  Its constructor will
     * add it to the list of modules MFC will search for resources.  It
     * must be static so it will live as long as MMC.
     */
    new CDynLinkLibrary (extensionDLL);

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mmcdebug.rc
//
#define IDC_TRACE_FILENAME              86
#define IDC_TRACE_TO_COM2               91
#define IDC_TRACE_OUTPUTDEBUGSTRING     92
#define IDC_TRACE_TO_FILE               93
#define IDC_TRACE_DEBUG_BREAK           95
#define IDC_TRACE_SELECT_ALL            96
#define IDC_TRACE_DEFAULT               97
#define IDC_TRACE_DUMP_STACK            1000
#define IDC_TRACE_STACKLEVELS           1001
#define IDD_DEBUG_TRACE_DIALOG          1003
#define IDD_PICKICON                    1004
#define IDC_PICKPATH                    1005
#define IDC_PICKICON                    1006
#define IDC_PICKBROWSE                  1007
#define IDS_ICONFILES                   1008
#define IDC_TRACE_LIST                  1032

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\eventlock.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       eventlock.cpp
//
//  This file contains code needed to fire script event in a safer way
//  Locks made on stack will postpone firing the event on particular interface
//  as long as the last lock is released.
//--------------------------------------------------------------------------

#include "stdafx.h"
#include <comdef.h>
#include <vector>
#include <queue>
#include "eventlock.h"
#include "mmcobj.h"

// since the templates will be used from outside the library
// we need to instantiale them explicitly in order to get them exported
template class CEventLock<AppEvents>;
 
/***************************************************************************\
 *
 * METHOD:  CEventBuffer::ScEmitOrPostpone
 *
 * PURPOSE: The method will add methods to the queue. If interface is not locked
 *          it will emit it immediately, else it will postpone it till appropriate
 *          call to Unlock()
 *
 * PARAMETERS:
 *    IDispatch *pDispatch - sink interface to receive the event
 *    DISPID dispid        - method's disp id
 *    CComVariant *pVar    - array of arguments to method call
 *    int count            - count of arguments in the array
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CEventBuffer::ScEmitOrPostpone(IDispatch *pDispatch, DISPID dispid, CComVariant *pVar, int count)
{
    DECLARE_SC(sc, TEXT("CEventBuffer::ScEmitOrPostpone"));

    // construct the postponed data
    DispCallStr call_data;
    call_data.spDispatch = pDispatch;
    call_data.dispid = dispid;
    call_data.vars.insert(call_data.vars.begin(), pVar, pVar + count);

    // store the data for future use
    m_postponed.push(call_data);

    // emit rigt away if not locked
    if (!IsLocked())
        sc = ScFlushPostponed();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CEventBuffer::ScFlushPostponed
 *
 * PURPOSE: method will invoke all events currently in it's queue
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CEventBuffer::ScFlushPostponed()
{
    DECLARE_SC(sc, TEXT("CEventBuffer::ScFlushPostponed"));

    SC sc_last_error;

    // for each event in queue
    while (m_postponed.size())
    {
        // ectract event from the queue
        DispCallStr call_data = m_postponed.front();
        m_postponed.pop();
    
        // check the dispatch pointer
        sc = ScCheckPointers(call_data.spDispatch, E_POINTER);
        if (sc)
        {
            sc_last_error = sc; // continue even if some calls failed
            sc.TraceAndClear();
            continue;
        }

        // construct parameter structure
        CComVariant varResult;
		DISPPARAMS disp = { call_data.vars.begin(), NULL, call_data.vars.size(), 0 };

        // invoke the method on event sink
        sc = call_data.spDispatch->Invoke(call_data.dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
        if (sc)
        {
            sc_last_error = sc; // continue even if some calls failed
            sc.TraceAndClear();
            continue;
        }
        // event methods should not return any values.
        // but even if the do (thru varResult) - we do not care, just ignore that.
    }

    // will return sc_last_error (not sc - we already traced it)
    return sc_last_error;
}

/***************************************************************************\
 *
 * FUNCTION:  GetEventBuffer
 *
 * PURPOSE: This function provides access to static object created in it's body
 *          Having it as template allows us to define as many static objects as
 *          interfaces we have.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CEventBuffer&  - reference to the static object created inside
 *
\***************************************************************************/
MMCBASE_API CEventBuffer& GetEventBuffer()
{
	static CEventBuffer buffer;
	return buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\mmcdebug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mmctrace.cpp
//
//  Contents:  Implementation of the debug trace code
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include <imagehlp.h>
#include "util.h"



//--------------------------------------------------------------------------
#ifdef DBG
//--------------------------------------------------------------------------

// a few global traces
CTraceTag tagError        (TEXT("Trace"),              TEXT("Error"),    TRACE_OUTPUTDEBUGSTRING);
CTraceTag tagDirtyFlag    (TEXT("Persistence"),        TEXT("MMC Dirty Flags"));
CTraceTag tagPersistError (TEXT("Persistence"),        TEXT("Snapin Dirty Flags"));
CTraceTag tagCoreLegacy   (TEXT("LEGACY mmccore.lib"), TEXT("TRACE (legacy, mmccore.lib)"));
CTraceTag tagConUILegacy  (TEXT("LEGACY mmc.exe"),     TEXT("TRACE (legacy, mmc.exe)"));
CTraceTag tagNodemgrLegacy(TEXT("LEGACY mmcndmgr.dll"),TEXT("TRACE (legacy, mmcndmgr.dll)"));
CTraceTag tagSnapinError  (TEXT("Snapin Error"),       TEXT("Snapin Error"), TRACE_OUTPUTDEBUGSTRING);

// szTraceIniFile must be a sz, so it exists before "{" of WinMain.
// if we make it a CStr, it may not be constructed when some of the
// tags are constructed, so we won't restore their value.
LPCTSTR const szTraceIniFile = TEXT("MMCTrace.INI");

//############################################################################
//############################################################################
//
//  Implementation of global Trace functions
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * Trace
 *
 * PURPOSE:     Maps the Trace statement to the proper method call.
 *              This is needed (instead of doing directly ptag->Trace())
 *              to garantee that no code is added in the ship build.
 *
 * PARAMETERS:
 *    CTraceTag & tag :        the tag controlling the debug output
 *    LPCTSTR     szFormat :   printf style formatting string
 *                ... :        printf style parameters, depends on szFormat
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
Trace( const CTraceTag & tag, LPCTSTR szFormat, ... )
{
    va_list     marker;
    va_start(marker, szFormat);
    tag.TraceFn(szFormat, marker);
    va_end(marker);
}


/*+-------------------------------------------------------------------------*
 *
 * TraceDirtyFlag
 *
 * PURPOSE: Used to trace into the objects that cause MMC to be in a dirty
 *          state, requiring a save.
 *
 * PARAMETERS:
 *    LPCTSTR  szComponent : The class name
 *    bool     bDirty      : whether or not the object is dirty.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceDirtyFlag  (LPCTSTR szComponent, bool bDirty)
{
    Trace(tagDirtyFlag, TEXT("%s : %s"), szComponent, bDirty ? TEXT("true") : TEXT("false"));
}

void
TraceBaseLegacy  (LPCTSTR szFormat, ... )
{
    va_list     marker;
    va_start(marker, szFormat);
    tagCoreLegacy.TraceFn(szFormat, marker);
    va_end(marker);
}

void
TraceConuiLegacy  (LPCTSTR szFormat, ... )
{
    va_list     marker;
    va_start(marker, szFormat);
    tagConUILegacy.TraceFn(szFormat, marker);
    va_end(marker);
}

void
TraceNodeMgrLegacy(LPCTSTR szFormat, ... )
{
    va_list     marker;
    va_start(marker, szFormat);
    tagNodemgrLegacy.TraceFn(szFormat, marker);
    va_end(marker);
}


/*+-------------------------------------------------------------------------*
 *
 * TraceError
 *
 * PURPOSE:     Used to send error traces.
 *
 * PARAMETERS:
 *    LPCTSTR  szModuleName : The module in which the error occurred.
 *    SC       sc           : The error.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceError(LPCTSTR szModuleName, const SC& sc)
{
    TCHAR szTemp[256];

    sc.GetErrorMessage (countof(szTemp), szTemp);
    StripTrailingWhitespace (szTemp);

    Trace(tagError, TEXT("Module %s, SC = 0x%08X = %d\r\n = \"%s\""),
          szModuleName, sc.GetCode(), LOWORD(sc.GetCode()), szTemp);
}


/*+-------------------------------------------------------------------------*
 *
 * TraceErrorMsg
 *
 * PURPOSE:     Used to send formatted error traces.  This is not SC-based, but
 *                              it does use tagError as its controlling trace tag.
 *
 * PARAMETERS:
 *    LPCTSTR  szErrorMsg : Error message to display.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceErrorMsg(LPCTSTR szFormat, ...)
{
    va_list     marker;
    va_start(marker, szFormat);
    tagError.TraceFn(szFormat, marker);
    va_end(marker);
}

/*+-------------------------------------------------------------------------*
 *
 * TraceSnapinError
 *
 * PURPOSE:     Used to send snapin error traces. The method should use
 *              DECLARE_SC so that we can get the method name from sc.
 *
 *
 * PARAMETERS:
 *    LPCTSTR  szError : Additional error message.
 *    SC       sc :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceSnapinError(LPCTSTR szError, const SC& sc)
{
    TCHAR szTemp[256];

    sc.GetErrorMessage (countof(szTemp), szTemp);
    StripTrailingWhitespace (szTemp);

    Trace(tagSnapinError, TEXT("Snapin %s encountered in %s  error %s, hr = 0x%08X\r\n = \"%s\""),
          sc.GetSnapinName(), sc.GetFunctionName(), szError, sc.ToHr(), szTemp);
}

/*+-------------------------------------------------------------------------*
 *
 * TraceSnapinPersistenceError
 *
 * PURPOSE:     outputs traces for persistence and snapin error tags
 *
 * PARAMETERS:
 *    LPCTSTR  szError : Error message.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
TraceSnapinPersistenceError(LPCTSTR szError)
{
    Trace(tagSnapinError,   szError);
    Trace(tagPersistError,  szError);
}

//############################################################################
//############################################################################
//
//  Implementation of class CTraceTags
//
//############################################################################
//############################################################################
CTraceTags * GetTraceTags()
{
    static CTraceTags s_traceTags;
    return &s_traceTags;
}


//############################################################################
//############################################################################
//
//  Implementation of class CTraceTag
//
//############################################################################
//############################################################################
CStr &
CTraceTag::GetFilename()
{
    /*
     * these statics are local to this function so we'll be sure they're
     * initialized, if this function is called during app/DLL initialization
     */
    static  CStr    strFile;
    static  BOOL    fInitialized    = FALSE;

    if(!fInitialized)
    {
        TCHAR   szTraceFile[OFS_MAXPATHNAME];
        ::GetPrivateProfileString(TEXT("Trace File"), TEXT("Trace File"),
                                  NULL, szTraceFile, OFS_MAXPATHNAME, szTraceIniFile);

        strFile = (_tcslen(szTraceFile)==0) ? TEXT("\\mmctrace.out") : szTraceFile;
        fInitialized = TRUE;
    }

    return strFile;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::GetStackLevels
 *
 * PURPOSE: Returns a reference to the number of stack levels to display.
 *          Auto initializes from the ini file.
 *
 * RETURNS:
 *    unsigned int &
 *
 *+-------------------------------------------------------------------------*/
unsigned int &
CTraceTag::GetStackLevels()
{
    static unsigned int nLevels = 3; // the default.
    static BOOL fInitialized = FALSE;

    if(!fInitialized)
    {
        TCHAR   szStackLevels[OFS_MAXPATHNAME];
        ::GetPrivateProfileString(TEXT("Stack Levels"), TEXT("Stack Levels"),
                                  NULL, szStackLevels, OFS_MAXPATHNAME, szTraceIniFile);

        if(_tcslen(szStackLevels)!=0)
            nLevels = szStackLevels[0] - TEXT('0');
        fInitialized = TRUE;
    }

    return nLevels;
}



HANDLE  CTraceTag::s_hfileCom2 = 0;
HANDLE  CTraceTag::s_hfile     = 0;

/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::CTraceTag
 *
 * PURPOSE: Constructor
 *
 * PARAMETERS:
 *    LPCTSTR  szCategory :     The category of the trace.
 *    LPCTSTR  szName :         The name of the trace.
 *    DWORD    dwDefaultFlags : The initial (and default) output setting.
 *
 *+-------------------------------------------------------------------------*/
CTraceTag::CTraceTag(LPCTSTR szCategory, LPCTSTR szName, DWORD dwDefaultFlags /*= 0*/)
: m_szCategory(szCategory),
  m_szName(szName)
{
    m_dwDefaultFlags = dwDefaultFlags;
    m_dwFlags        = dwDefaultFlags;

    //  Get the value from TRACE.INI
    m_dwFlags = ::GetPrivateProfileInt(szCategory, szName, dwDefaultFlags, szTraceIniFile);

    // add it to the end of the list.
    CTraceTags *pTraceTags = GetTraceTags();
    if(NULL != pTraceTags)
        pTraceTags->push_back(this); // add this tag to the list.

    // call the OnEnable function if any flags have been set.
    if(FAny())
    {
        OnEnable();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::~CTraceTag
 *
 * PURPOSE: Destructor
 *
 *+-------------------------------------------------------------------------*/
CTraceTag::~CTraceTag()
{
    // close the open handles.
    if (s_hfileCom2 && (s_hfileCom2 != INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(s_hfileCom2);
        s_hfileCom2 = INVALID_HANDLE_VALUE;
    }
    if (s_hfile && (s_hfile != INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(s_hfile);
        s_hfile = INVALID_HANDLE_VALUE;
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::TraceFn
 *
 * PURPOSE:     Processes a Trace statement based on the flags
 *              of the tag.
 *
 * PARAMETERS:
 *    LPCTSTR       szFormat : printf style format string
 *    va_list  marker :   argument block to pass to _vsnprintf
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/

void CTraceTag::TraceFn(LPCTSTR szFormat, va_list marker) const
{
    CStr            strT;
    CStr            str;

    // Get out quick if no outputs are enabled.
    if (!FAny())
        return;

    // first, format the string as provided.
    strT.FormatV(szFormat, marker);

    // next, prepend the name of the tag.
    str.Format(TEXT("%s: %s\r\n"), GetName(), strT);

    // send the string to all appropriate outputs
    OutputString(str);

    if(FDumpStack()) // dump the caller's info to the stack.
    {
        DumpStack();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::OutputString
 *
 * PURPOSE: Outputs the specified string to all appropriate outputs
 *          (Debug string, COM2, or file)
 *
 * PARAMETERS:
 *    CStr & str :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CTraceTag::OutputString(const CStr &str) const
{
    UINT            cbActual    = 0;

    //---------------------------------------------------------------
    // Output to OutputDebugString if needed
    //---------------------------------------------------------------
    if (FDebug())
        OutputDebugString(str);

    USES_CONVERSION;

    //---------------------------------------------------------------
    // Output to COM2 if needed
    //---------------------------------------------------------------
    if (FCom2())
    {
        // create the file if it hasn't been created yet.
        if (!s_hfileCom2)
        {
            s_hfileCom2 = CreateFile(TEXT("com2:"),
                    GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_WRITE_THROUGH,
                    NULL);

            if (s_hfileCom2 == INVALID_HANDLE_VALUE)
            {
                //::MessageBox(TEXT("COM2 is not available for debug trace"), MB_OK | MB_ICONINFORMATION);
            }
        }

        // output to file.
        if (s_hfileCom2 != INVALID_HANDLE_VALUE)
        {
            ASSERT(::WriteFile(s_hfileCom2, T2A((LPTSTR)(LPCTSTR)str), str.GetLength(), (LPDWORD) &cbActual, NULL));
            ASSERT(::FlushFileBuffers(s_hfileCom2));
        }
    }

    //---------------------------------------------------------------
    // Output to File if needed
    //---------------------------------------------------------------
    if (FFile())
    {
        // create the file if it hasn't been created yet.
        if (!s_hfile)
        {
            s_hfile = CreateFile(GetFilename(),
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL);
            if (s_hfile != INVALID_HANDLE_VALUE)
            {
                ::SetFilePointer(s_hfile, NULL, NULL, FILE_END);

                // for Unicode files, write the Unicode prefix when the file is first created (ie it has a length of zero)
#ifdef UNICODE
                DWORD dwFileSize = 0;
                if( (::GetFileSize(s_hfile, &dwFileSize) == 0) && (dwFileSize == 0) )
                {
                    const WCHAR chPrefix  = 0xFEFF;
                    const DWORD cbToWrite = sizeof (chPrefix);
                    DWORD       cbWritten = 0;

                    ::WriteFile (s_hfile, &chPrefix, cbToWrite, &cbWritten, NULL);
                }
#endif
                // write an initial line.
                CStr strInit = TEXT("\n*********************Start of debugging session*********************\r\n");
                ::WriteFile(s_hfile, ((LPTSTR)(LPCTSTR)strInit), strInit.GetLength() * sizeof(TCHAR), (LPDWORD) &cbActual, NULL);
            }
        }
        if (s_hfile == INVALID_HANDLE_VALUE)
        {
            static BOOL fOpenFailed = FALSE;
            if (!fOpenFailed)
            {
                CStr str;

                fOpenFailed = TRUE;     // Do this first, so the MbbErrorBox and str.Format
                                        // do not cause problems with their trace statement.

                str.Format(TEXT("The DEBUG ONLY trace log file '%s' could not be opened"), GetFilename());
                //MbbErrorBox(str, ScFromWin32(::GetLastError()));
            }
        }
        else
        {
            // write to the file.
            ::WriteFile(s_hfile, ((LPTSTR)(LPCTSTR)str), str.GetLength() *sizeof(TCHAR), (LPDWORD) &cbActual, NULL);
        }
    }

    //---------------------------------------------------------------
    // DebugBreak if needed
    //---------------------------------------------------------------
    if (FBreak())
        MMCDebugBreak();
}


/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::Commit
 *
 * PURPOSE: Sets the flags equal to the temporary flags setting.
 *          If any flags are enabled where previously no flags were, also
 *          calls OnEnable(). If no flags are enabled where previously flags
 *          were enabled, calls OnDisable()
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CTraceTag::Commit()
{
    if((0 != m_dwFlags) && (0 == m_dwFlagsTemp))
    {
        // disable if flags have changed from non-zero to zero
        OnDisable();
    }
    else if((0 == m_dwFlags) && (0 != m_dwFlagsTemp))
    {
        // enable if flags have changed from 0 to non-zero
        OnEnable();
    }

    m_dwFlags     = m_dwFlagsTemp;
}



//############################################################################
//############################################################################
//
//  Stack dump related code - copied from MFC with very few modifications.
//
//############################################################################
//############################################################################

static LPVOID __stdcall FunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddress);
static DWORD_PTR __stdcall GetModuleBase(HANDLE hProcess, DWORD_PTR dwReturnAddress);

#define MODULE_NAME_LEN 64
#define SYMBOL_NAME_LEN 128

struct MMC_SYMBOL_INFO
{
    DWORD_PTR dwAddress;
    DWORD_PTR dwOffset;
    CHAR    szModule[MODULE_NAME_LEN];
    CHAR    szSymbol[SYMBOL_NAME_LEN];
};

static LPVOID __stdcall FunctionTableAccess(HANDLE hProcess, DWORD_PTR dwPCAddress)
{
    return SymFunctionTableAccess(hProcess, dwPCAddress);
}

static DWORD_PTR __stdcall GetModuleBase(HANDLE hProcess, DWORD_PTR dwReturnAddress)
{
    IMAGEHLP_MODULE moduleInfo;

    if (SymGetModuleInfo(hProcess, dwReturnAddress, &moduleInfo))
        return moduleInfo.BaseOfImage;
    else
    {
        MEMORY_BASIC_INFORMATION memoryBasicInfo;

        if (::VirtualQueryEx(hProcess, (LPVOID) dwReturnAddress,
            &memoryBasicInfo, sizeof(memoryBasicInfo)))
        {
            DWORD cch = 0;
            char szFile[MAX_PATH] = { 0 };

         cch = GetModuleFileNameA((HINSTANCE)memoryBasicInfo.AllocationBase,
                                         szFile, MAX_PATH);

         // Ignore the return code since we can't do anything with it.
         if (!SymLoadModule(hProcess,
               NULL, ((cch) ? szFile : NULL),
               NULL, (DWORD_PTR) memoryBasicInfo.AllocationBase, 0))
            {
                DWORD dwError = GetLastError();
                //TRACE1("Error: %d\n", dwError);
            }
         return (DWORD_PTR) memoryBasicInfo.AllocationBase;
      }
        else
            /*TRACE1("Error is %d\n", GetLastError())*/;
    }

    return 0;
}




/*+-------------------------------------------------------------------------*
 *
 * ResolveSymbol
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    HANDLE        hProcess :
 *    DWORD         dwAddress :
 *    SYMBOL_INFO & siSymbol :
 *
 * RETURNS:
 *    static BOOL
 *
 *+-------------------------------------------------------------------------*/

static BOOL ResolveSymbol(HANDLE hProcess, DWORD_PTR dwAddress,
    MMC_SYMBOL_INFO &siSymbol)
{
    BOOL fRetval = TRUE;

    siSymbol.dwAddress = dwAddress;

    union {
        CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + 255];
        IMAGEHLP_SYMBOL  sym;
    };

    CHAR szUndec[256];
    CHAR szWithOffset[256];
    LPSTR pszSymbol = NULL;
    IMAGEHLP_MODULE mi;

    memset(&siSymbol, 0, sizeof(MMC_SYMBOL_INFO));
    mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (!SymGetModuleInfo(hProcess, dwAddress, &mi))
        lstrcpyA(siSymbol.szModule, "<no module>");
    else
    {
        LPSTR pszModule = strchr(mi.ImageName, '\\');
        if (pszModule == NULL)
            pszModule = mi.ImageName;
        else
            pszModule++;

        lstrcpynA(siSymbol.szModule, pszModule, countof(siSymbol.szModule));
       lstrcatA(siSymbol.szModule, "! ");
    }

    __try
    {
        sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        sym.Address = dwAddress;
        sym.MaxNameLength = 255;

        if (SymGetSymFromAddr(hProcess, dwAddress, &(siSymbol.dwOffset), &sym))
        {
            pszSymbol = sym.Name;

            if (UnDecorateSymbolName(sym.Name, szUndec, countof(szUndec),
                UNDNAME_NO_MS_KEYWORDS | UNDNAME_NO_ACCESS_SPECIFIERS))
            {
                pszSymbol = szUndec;
            }
            else if (SymUnDName(&sym, szUndec, countof(szUndec)))
            {
                pszSymbol = szUndec;
            }

            if (siSymbol.dwOffset != 0)
            {
                wsprintfA(szWithOffset, "%s + %d bytes", pszSymbol, siSymbol.dwOffset);
                pszSymbol = szWithOffset;
            }
      }
      else
          pszSymbol = "<no symbol>";
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pszSymbol = "<EX: no symbol>";
        siSymbol.dwOffset = dwAddress - mi.BaseOfImage;
    }

    lstrcpynA(siSymbol.szSymbol, pszSymbol, countof(siSymbol.szSymbol));
    return fRetval;
}


/*+-------------------------------------------------------------------------*
 *
 * CTraceTag::DumpStack
 *
 * PURPOSE: Does a stack trace and sends it to the appropriate outputs.
 *          Mostly copied from AfxDumpStack.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CTraceTag::DumpStack() const
{
    const int UNINTERESTING_CALLS = 3; // the lines of display which are in CTraceTag code and should not be displayed.

    CStr str;

    //OutputString("=== Begin Stack Dump ===\r\n");

    std::vector<DWORD_PTR> adwAddress;
    HANDLE hProcess = ::GetCurrentProcess();
    if (SymInitialize(hProcess, NULL, FALSE))
    {
        // force undecorated names to get params
        DWORD dw = SymGetOptions();
        dw &= ~SYMOPT_UNDNAME;
        SymSetOptions(dw);

        HANDLE hThread = ::GetCurrentThread();
        CONTEXT threadContext;

        threadContext.ContextFlags = CONTEXT_FULL;

        if (::GetThreadContext(hThread, &threadContext))
        {
            STACKFRAME stackFrame;
            memset(&stackFrame, 0, sizeof(stackFrame));
            stackFrame.AddrPC.Mode = AddrModeFlat;

            DWORD dwMachType;

#if defined(_M_IX86)
            dwMachType                  = IMAGE_FILE_MACHINE_I386;

            // program counter, stack pointer, and frame pointer
            stackFrame.AddrPC.Offset    = threadContext.Eip;
            stackFrame.AddrStack.Offset = threadContext.Esp;
            stackFrame.AddrStack.Mode   = AddrModeFlat;
            stackFrame.AddrFrame.Offset = threadContext.Ebp;
            stackFrame.AddrFrame.Mode   = AddrModeFlat;
#elif defined(_M_AMD64)
            // only program counter
            dwMachType                  = IMAGE_FILE_MACHINE_AMD64;
            stackFrame.AddrPC.Offset    = threadContext.Rip;
#elif defined(_M_IA64)
            // from <root>\com\ole32\common\stackwlk.cxx
            dwMachType                  = IMAGE_FILE_MACHINE_IA64;
            stackFrame.AddrPC.Offset    = threadContext.StIIP;
#else
#error("Unknown Target Machine");
#endif

            int nFrame;
            for (nFrame = 0; nFrame < GetStackLevels() + UNINTERESTING_CALLS; nFrame++)
            {
                if (!StackWalk(dwMachType, hProcess, hProcess,
                    &stackFrame, &threadContext, NULL,
                    FunctionTableAccess, GetModuleBase, NULL))
                {
                    break;
                }

                adwAddress.push_back(stackFrame.AddrPC.Offset);
            }
        }
    }
    else
    {
        DWORD dw = GetLastError();
        char sz[100];
        wsprintfA(sz,
            "AfxDumpStack Error: IMAGEHLP.DLL wasn't found. "
            "GetLastError() returned 0x%8.8X\r\n", dw);
        OutputString(sz);
    }

    // dump it out now
    int nAddress;
    int cAddresses = adwAddress.size();
    for (nAddress = UNINTERESTING_CALLS; nAddress < cAddresses; nAddress++)
    {
        MMC_SYMBOL_INFO info;
        DWORD_PTR dwAddress = adwAddress[nAddress];

        char sz[20];
        wsprintfA(sz, "        %8.8X: ", dwAddress);
        OutputString(sz);

        if (ResolveSymbol(hProcess, dwAddress, info))
        {
            OutputString(info.szModule);
            OutputString(info.szSymbol);
        }
        else
            OutputString("symbol not found");
        OutputString("\r\n");
    }

    //OutputString("=== End Stack Dump ===\r\n");
}

//--------------------------------------------------------------------------
#endif // DBG
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\pickicon.cpp ===
/*
 * pickicon - Icon picker
 */

#include "stdafx.h"
#include "pickicon.h"
#include "windowsx.h"
#include "commdlg.h"
#include "resource.h"
#include "util.h"

#define cA(a) (sizeof(a)/sizeof(a[0]))

typedef TCHAR TCH;

typedef struct COFN {           /* common open file name */
    OPENFILENAME ofn;           /* The thing COMMDLG wants */
    TCH tsz[MAX_PATH];          /* Where we build the name */
    TCH tszFilter[100];         /* File open/save filter */
} COFN, *PCOFN;

/*****************************************************************************
 *
 *  InitOpenFileName
 *
 *  Initialize a COFN structure.
 *
 *****************************************************************************/

void PASCAL
InitOpenFileName(HWND hwnd, PCOFN pcofn, UINT ids, LPCTSTR pszInit)
{
    int itchMax;
    TCH tch;

    ZeroMemory(&pcofn->ofn, sizeof(pcofn->ofn));
    pcofn->ofn.lStructSize |= sizeof(pcofn->ofn);
    pcofn->ofn.hwndOwner = hwnd;
    pcofn->ofn.lpstrFilter = pcofn->tszFilter;
    pcofn->ofn.lpstrFile = pcofn->tsz;
    pcofn->ofn.nMaxFile = MAX_PATH;
    pcofn->ofn.Flags |= (OFN_HIDEREADONLY | OFN_NOCHANGEDIR);

    /* Get the filter string */
    itchMax = LoadString(SC::GetHinst(), ids, pcofn->tszFilter, cA(pcofn->tszFilter));

    if (itchMax) {
        /* Marker character must not be DBCS */
        tch = pcofn->tszFilter[itchMax-1];
        LPTSTR ptsz = pcofn->tszFilter;
        while (ptsz < &pcofn->tszFilter[itchMax]) {
            if (*ptsz == tch) *ptsz++ = '\0';
            else ptsz = CharNext(ptsz);
        }
    }

    /* Set the initial value */
    lstrcpyn(pcofn->tsz, pszInit, cA(pcofn->tsz));
}


/*
 *  Instance info for the dialog.
 */
typedef struct PIDI {		/* PickIcon dialog instance */
    LPTSTR ptszIconPath;	/* Which file? */
    UINT ctchIconPath;
    int iIconIndex;		/* Which icon number? */
    int *piIconIndex;
    TCH tszCurFile[MAX_PATH];	/* The path in the list box */
} PIDI, *PPIDI;

#define cxIcon GetSystemMetrics(SM_CXICON)
#define cyIcon GetSystemMetrics(SM_CYICON)

/*****************************************************************************
 *
 *  PickIcon_ppidiHdlg
 *
 *	Extract the PPIDI from an hdlg.
 *
 *****************************************************************************/

#define PickIcon_ppidiHdlg(hdlg) ((PPIDI)GetWindowLongPtr(hdlg, DWLP_USER))

/*****************************************************************************
 *
 *  PickIcon_OnMeasureItem
 *
 *	Tell USER the size of each item.
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnMeasureItem(HWND hdlg, LPMEASUREITEMSTRUCT lpmi, PPIDI ppidi)
{
    lpmi->itemWidth = cxIcon + 12;
    lpmi->itemHeight = cyIcon + 4;
}

/*****************************************************************************
 *
 *  PickIcon_OnDrawItem
 *
 *	Draw an icon.
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnDrawItem(HWND hdlg, LPDRAWITEMSTRUCT lpdi, PPIDI ppidi)
{
    SetBkColor(lpdi->hDC, GetSysColor((lpdi->itemState & ODS_SELECTED) ?
					COLOR_HIGHLIGHT : COLOR_WINDOW));

    /* repaint the selection state */
    ExtTextOut(lpdi->hDC, 0, 0, ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL);

	/*
	 * Preserve icon shape when BitBlitting it to a
	 * mirrored DC.
	 */
	DWORD dwLayout=0L;
	if ((dwLayout=GetLayout(lpdi->hDC)) & LAYOUT_RTL)
	{
		SetLayout(lpdi->hDC, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
	}

    /* draw the icon centered in the rectangle */
    if ((int)lpdi->itemID >= 0) {
	DrawIcon(lpdi->hDC,
		(lpdi->rcItem.left + lpdi->rcItem.right - cxIcon) / 2,
		(lpdi->rcItem.bottom + lpdi->rcItem.top - cyIcon) / 2,
		(HICON)lpdi->itemData);
    }

	/*
	 * Restore the DC to its previous layout state.
	 */
	if (dwLayout & LAYOUT_RTL)
	{
		SetLayout(lpdi->hDC, dwLayout);
	}

    /* if it has the focus, draw the focus */
    if (lpdi->itemState & ODS_FOCUS) {
	DrawFocusRect(lpdi->hDC, &lpdi->rcItem);
    }
}

/*****************************************************************************
 *
 *  PickIcon_OnDeleteItem
 *
 *	USER is nuking an item.  Clean it up.
 *
 *****************************************************************************/

#define PickIcon_OnDeleteItem(hdlg, lpdi, ppidi) \
    DestroyIcon((HICON)(lpdi)->itemData)

/*****************************************************************************
 *
 *  PickIcon_FillIconList
 *
 *	Fill in all the icons.  If the user picks a bad place, we leave
 *	garbage in the path (so he can edit the name) and leave the list
 *	box blank.
 *
 *****************************************************************************/

void PickIcon_FillIconList(HWND hdlg, PPIDI ppidi)
{
    HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    HWND hwnd = GetDlgItem(hdlg, IDC_PICKICON);
    if (!IsWindow (hwnd))
        return;

    ListBox_SetColumnWidth(hwnd, cxIcon + 12);
    ListBox_ResetContent(hwnd);

	TCHAR szFile[cA(ppidi->tszCurFile)];
    GetDlgItemText(hdlg, IDC_PICKPATH, szFile, cA(szFile));

	// support indirect paths (e.g. %SystemRoot%\...")
	TCHAR szExpandedFile[cA(ppidi->tszCurFile)];
	ExpandEnvironmentStrings (szFile, szExpandedFile, cA(szExpandedFile));

	if (SearchPath(0, szExpandedFile, 0, cA(ppidi->tszCurFile),
				   ppidi->tszCurFile, 0)) {
ExtractIcons:
		int cIcons;
		cIcons = ExtractIconEx(ppidi->tszCurFile, 0, 0, 0, 0);
		if (cIcons) {
			HICON *rgIcons = (HICON *)LocalAlloc(LPTR, cIcons * sizeof(HICON));
			if (rgIcons) {
				cIcons = (int)ExtractIconEx(ppidi->tszCurFile, 0,
											rgIcons, NULL, cIcons);
				if (cIcons) {
					int iicon;
					SendMessage(hwnd, WM_SETREDRAW, 0, 0);
					for (iicon = 0; iicon < cIcons; iicon++) {
						ListBox_AddString(hwnd, rgIcons[iicon]);
					}
					if (ListBox_SetCurSel(hwnd, ppidi->iIconIndex) == LB_ERR) {
						ListBox_SetCurSel(hwnd, 0);
					}
					SendMessage(hwnd, WM_SETREDRAW, 1, 0);
				} else {		/* Mysteriously unable to extract */
				}
				LocalFree((HLOCAL)rgIcons);
			} else {			/* Not enough memory to load icons */
			}
		} else {			/* No icons in the file */
		}
		// if indirect path was specified (e.g. "%SystemRoot%\..."), preserve indirection
		if ((lstrcmp (szExpandedFile, szFile)            != 0) &&
			(lstrcmp (szExpandedFile, ppidi->tszCurFile) == 0))
			lstrcpy (ppidi->tszCurFile, szFile);
		SetDlgItemText(hdlg, IDC_PICKPATH, ppidi->tszCurFile);
	} else {				/* File not found */
		SC sc;
		MMCErrorBox (sc.FromWin32(ERROR_FILE_NOT_FOUND));
		goto ExtractIcons;
	}

    InvalidateRect(hwnd, 0, 1);
    SetCursor(hcurOld);
}

/*****************************************************************************
 *
 *  PickIcon_OnInitDialog
 *
 *	Dialog init.  Populate the list box with what we came in with.
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnInitDialog(HWND hdlg, PPIDI ppidi)
{
    SetWindowLongPtr(hdlg, DWLP_USER, (LPARAM)ppidi);
    SetDlgItemText(hdlg, IDC_PICKPATH,
		   lstrcpyn(ppidi->tszCurFile,
			    ppidi->ptszIconPath, cA(ppidi->tszCurFile)));
    SendDlgItemMessage(hdlg, IDC_PICKPATH, EM_LIMITTEXT,
		       ppidi->ctchIconPath, 0);
    PickIcon_FillIconList(hdlg, ppidi);
}

/*****************************************************************************
 *
 *  PickIcon_OnBrowse
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnBrowse(HWND hdlg, PPIDI ppidi)
{
    DWORD dw;
    COFN cofn;
    InitOpenFileName(hdlg, &cofn, IDS_ICONFILES, ppidi->tszCurFile);
    dw = GetFileAttributes(ppidi->tszCurFile);
    if (dw == 0xFFFFFFFF || (dw & FILE_ATTRIBUTE_DIRECTORY)) {
	cofn.tsz[0] = '\0';
    }

    if (GetOpenFileName(&cofn.ofn)) {
        SetDlgItemText(hdlg, IDC_PICKPATH, cofn.tsz);
        SendMessage(hdlg, DM_SETDEFID, IDOK, 0);
	PickIcon_FillIconList(hdlg, ppidi);
    }
}

/*****************************************************************************
 *
 *  PickIcon_NameChange
 *
 *  Determine whether the thing in the edit control doesn't match the
 *  thing whose icons we are showing.
 *
 *****************************************************************************/

BOOL PASCAL
PickIcon_NameChange(HWND hdlg, PPIDI ppidi)
{
    TCH tszBuffer[MAX_PATH];
    GetDlgItemText(hdlg, IDC_PICKPATH, tszBuffer, cA(tszBuffer));
    return lstrcmpi(tszBuffer, ppidi->tszCurFile);
}

/*****************************************************************************
 *
 *  PickIcon_OnOk
 *
 *	If the name has changed, treat this as a "Okay, now reload
 *	the icons" rather than "Okay, I'm finished".
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnOk(HWND hdlg, PPIDI ppidi)
{
    if (PickIcon_NameChange(hdlg, ppidi)) {
	PickIcon_FillIconList(hdlg, ppidi);
    } else {
	int iIconIndex = (int)SendDlgItemMessage(hdlg, IDC_PICKICON,
						LB_GETCURSEL, 0, 0L);
	if (iIconIndex >= 0) {	/* We have an icon */
	    *ppidi->piIconIndex = iIconIndex;
	    lstrcpyn(ppidi->ptszIconPath, ppidi->tszCurFile,
		     ppidi->ctchIconPath);
	    EndDialog(hdlg, 1);
	} else {		/* No icon, act like cancel */
	    EndDialog(hdlg, 0);
	}
    }
}

/*****************************************************************************
 *
 *  PickIcon_OnCommand
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnCommand(HWND hdlg, int id, UINT codeNotify, PPIDI ppidi)
{
    switch (id) {
    case IDOK: PickIcon_OnOk(hdlg, ppidi); break;
    case IDCANCEL: EndDialog(hdlg, 0); break;

    case IDC_PICKBROWSE: PickIcon_OnBrowse(hdlg, ppidi); break;

    /*
     *	When the name changes, remove the selection highlight.
     */
    case IDC_PICKPATH:
		if (PickIcon_NameChange(hdlg, ppidi)) {
			SendDlgItemMessage(hdlg, IDC_PICKICON, LB_SETCURSEL, (WPARAM)-1, 0);
		}
		break;

    case IDC_PICKICON:
		if (codeNotify == LBN_DBLCLK) {
			PickIcon_OnOk(hdlg, ppidi);
		}
		break;
    }
}

/*****************************************************************************
 *
 *  PickIcon_DlgProc
 *
 *	Dialog procedure.
 *
 *****************************************************************************/

/*
 * The HANDLE_WM_* macros weren't designed to be used from a dialog
 * proc, so we need to handle the messages manually.  (But carefully.)
 */

INT_PTR EXPORT
PickIcon_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    PPIDI ppidi = PickIcon_ppidiHdlg(hdlg);

    switch (wm) {
    case WM_INITDIALOG: PickIcon_OnInitDialog(hdlg, (PPIDI)lParam); break;

    case WM_COMMAND:
	PickIcon_OnCommand(hdlg, (int)GET_WM_COMMAND_ID(wParam, lParam),
				 (UINT)GET_WM_COMMAND_CMD(wParam, lParam),
				 ppidi);
	break;

    case WM_DRAWITEM:
	PickIcon_OnDrawItem(hdlg, (LPDRAWITEMSTRUCT)lParam, ppidi);
	break;

    case WM_MEASUREITEM:
	PickIcon_OnMeasureItem(hdlg, (LPMEASUREITEMSTRUCT)lParam, ppidi);
	break;

    case WM_DELETEITEM:
	PickIcon_OnDeleteItem(hdlg, (LPDELETEITEMSTRUCT)lParam, ppidi);
	break;

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}


/*****************************************************************************
 *
 *  PickIconDlg
 *
 *	Ask the user to pick an icon.
 *
 *	hwnd - owner window
 *	ptszIconPath - (in) default icon file
 *		      (out) chosen icon file
 *	ctchIconPath - size of ptszIconPath buffer
 *	piIconIndex - (in) default icon index
 *		      (out) index of chosen icon
 *
 *	If the dialog box is cancelled, then no values are changed.
 *
 *****************************************************************************/

MMCBASE_API INT_PTR PASCAL
PickIconDlg(HWND hwnd, LPTSTR ptszIconPath, UINT ctchIconPath, int *piIconIndex)
{
    PIDI pidi;

    pidi.ptszIconPath = ptszIconPath;
    pidi.ctchIconPath = ctchIconPath;
    pidi.piIconIndex = piIconIndex;
    pidi.iIconIndex = *piIconIndex;

    return DialogBoxParam(SC::GetHinst(), MAKEINTRESOURCE(IDD_PICKICON), hwnd,
			  PickIcon_DlgProc, (LPARAM)&pidi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=mmcbase
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=_DllMainCRTStartup
UMTYPE=windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

SYNCHRONIZE_BLOCK = 1
USE_NATIVE_EH     = 1
USE_RTTI          = 1
USE_VCCOM         = 1
USE_STL           = 1
USE_STATIC_ATL    = 1
ATL_VER           = 30
USE_MSVCRT        = 1
USE_WTL           = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
	..\..\core\$(CharWidth)\$(O)\uicore.lib

TARGETLIBS = \
   $(SDK_LIB_PATH)\kernel32.lib 	\
   $(SDK_LIB_PATH)\user32.lib   	\
   $(SDK_LIB_PATH)\gdi32.lib    	\
   $(SDK_LIB_PATH)\oleaut32.lib 	\
   $(SDK_LIB_PATH)\ole32.lib    	\
   $(SDK_LIB_PATH)\advapi32.lib 	\
   $(SDK_LIB_PATH)\uuid.lib     	\
   $(SDK_LIB_PATH)\comctl32.lib 	\
   $(SDK_LIB_PATH)\comdlg32.lib 	\
   $(SDK_LIB_PATH)\shell32.lib  	\
   $(SDK_LIB_PATH)\imagehlp.lib		\

INCLUDES = \
	..\;					\
	..\..\core;				\
	..\..\inc;				\
	..\..\types\idl\$(O);	\


DLLDEF=..\mmcbase.def


PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX = 1

SOURCES = \
	..\mmcbase.rc       \
	..\comobjects.cpp   \
	..\eventlock.cpp    \
	..\mmcbase.cpp      \
	..\mmcdebug.cpp     \
	..\mmcerror.cpp     \
	..\tracedlg.cpp     \
	..\classreg.cpp     \
	..\pickicon.cpp     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mmcdebug.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\tracedlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      tracedlg.cpp
//
//  Contents:  Implementation of the debug trace code
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "tracedlg.h"

#ifdef DBG


//############################################################################
//############################################################################
//
//  Implementation of class CTraceDialog
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::RecalcCheckboxes
 *
 * PURPOSE: Recomputes the settings of the check boxes. This is in response to 
 *          a trace tag selection change.
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CTraceDialog::RecalcCheckboxes()
{
    DWORD dwMask            = TRACE_ALL; //initialize with all ones
    bool  bAtLeastOneItem   = false;
    
    int iItem = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);

    while(iItem != -1)
    {
        CTraceTag *pTag = reinterpret_cast<CTraceTag *>(m_listCtrl.GetItemData(iItem));
        ASSERT(pTag != NULL);
        if(pTag == NULL)
            return;

        bAtLeastOneItem = true;
        dwMask &= pTag->GetFlag(TRACE_ALL); // AND all the selected item's bits.
        iItem =  m_listCtrl.GetNextItem(iItem, LVNI_SELECTED);
    }

    // disable the checkbox if no item selected.
    ::EnableWindow(GetDlgItem(IDC_TRACE_TO_COM2),          bAtLeastOneItem);
    ::EnableWindow(GetDlgItem(IDC_TRACE_OUTPUTDEBUGSTRING),bAtLeastOneItem);
    ::EnableWindow(GetDlgItem(IDC_TRACE_TO_FILE),          bAtLeastOneItem);
    ::EnableWindow(GetDlgItem(IDC_TRACE_DEBUG_BREAK),      bAtLeastOneItem);
    ::EnableWindow(GetDlgItem(IDC_TRACE_DUMP_STACK),       bAtLeastOneItem);

    if(!bAtLeastOneItem)
        return;

    CheckDlgButton(IDC_TRACE_TO_COM2,           dwMask & TRACE_COM2              ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_TRACE_OUTPUTDEBUGSTRING, dwMask & TRACE_OUTPUTDEBUGSTRING ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_TRACE_TO_FILE,           dwMask & TRACE_FILE              ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_TRACE_DEBUG_BREAK,       dwMask & TRACE_DEBUG_BREAK       ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_TRACE_DUMP_STACK,        dwMask & TRACE_DUMP_STACK        ? BST_CHECKED : BST_UNCHECKED);

}


/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnSelChanged
 *
 * PURPOSE: Handles a selection change notification.
 *
 * PARAMETERS: 
 *    int      idCtrl :
 *    LPNMHDR  pnmh :
 *    BOOL&    bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT 
CTraceDialog::OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{    
    RecalcCheckboxes();
    return 0;
}


/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnColumnClick
 *
 * PURPOSE:    Handles the column click notification - causes a sort by the 
 *           specified column.
 *
 * PARAMETERS: 
 *    int      idCtrl :
 *    LPNMHDR  pnmh :
 *    BOOL&    bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnColumnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    NM_LISTVIEW *pnmlv = (NM_LISTVIEW *) pnmh;
    m_dwSortData = pnmlv->iSubItem; // iSubItem is the column clicked on. Cache this value for later
    DoSort();
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::SetMaskFromCheckbox
 *
 * PURPOSE: Sets the trace tag flag from the state of the specified check box.
 *
 * PARAMETERS: 
 *    UINT   idControl :    The check box control
 *    DWORD  dwMask :       The bit(s) to enable/disable depending on the state
 *                          of the control.
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void            
CTraceDialog::SetMaskFromCheckbox(UINT idControl, DWORD dwMask)
{
    bool bEnabled = IsDlgButtonChecked(idControl) == BST_CHECKED;
    
    int iItem = m_listCtrl.GetNextItem(-1, LVNI_SELECTED);
    ASSERT(iItem != -1);

    while(iItem != -1)
    {
        CTraceTag *pTag = reinterpret_cast<CTraceTag *>(m_listCtrl.GetItemData(iItem));
        ASSERT(pTag != NULL);
        if(pTag == NULL)
            return;

        if(bEnabled)
            pTag->SetFlag(dwMask);
        else
            pTag->ClearFlag(dwMask);

        // update the UI
        m_listCtrl.SetItemText(iItem, COLUMN_ENABLED, pTag->FAnyTemp() ? TEXT("X") : TEXT(""));

        iItem = m_listCtrl.GetNextItem(iItem, LVNI_SELECTED);
    }

    // sort the items again
    DoSort();
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::DoSort
 *
 * PURPOSE: Perform a sort of the items in the dialog
 *
 * RETURNS: 
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CTraceDialog::DoSort()
{
    m_listCtrl.SortItems(CompareItems, m_dwSortData); 
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnOutputToCOM2
 *
 * PURPOSE:     Handles checking/unchecking the "output to Com2" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnOutputToCOM2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_TO_COM2,           TRACE_COM2);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnOutputDebugString
 *
 * PURPOSE:    Handles checking/unchecking the "OutputDebugString" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnOutputDebugString(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_OUTPUTDEBUGSTRING, TRACE_OUTPUTDEBUGSTRING);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnOutputToFile
 *
 * PURPOSE:     Handles checking/unchecking the "output to File" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnOutputToFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_TO_FILE,           TRACE_FILE);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnDebugBreak
 *
 * PURPOSE:     Handles checking/unchecking the "DebugBreak" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnDebugBreak(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_DEBUG_BREAK,       TRACE_DEBUG_BREAK);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnDumpStack
 *
 * PURPOSE: Handles checking/unchecking the "Stack Dump" button.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnDumpStack(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetMaskFromCheckbox(IDC_TRACE_DUMP_STACK,        TRACE_DUMP_STACK);
    return 0;
}



/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnRestoreDefaults
 *
 * PURPOSE:     Restores the default (canned) settings of all trace tags.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnRestoreDefaults(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CTraceTags::iterator iter;

    CTraceTags * pTraceTags = GetTraceTags();
    if(NULL == pTraceTags)
        goto Error;

    for(iter = pTraceTags->begin(); iter != pTraceTags->end(); iter++)
    {
        (*iter)->RestoreDefaults();
    }

    RecalcCheckboxes();

Cleanup:
    return 0;

Error:
    goto Cleanup;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnSelectAll
 *
 * PURPOSE:     Selects all trace tags.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnSelectAll(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int cItems = m_listCtrl.GetItemCount();
    for(int i=0; i< cItems; i++)
    {
        m_listCtrl.SetItemState(i, LVIS_SELECTED, LVIS_SELECTED);
    }

    RecalcCheckboxes();
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::CompareItems
 *
 * PURPOSE:     The callback routine to compare two items in the list control.
 *
 * PARAMETERS: 
 *    LPARAM  lp1 :
 *    LPARAM  lp2 :
 *    LPARAM  lpSortData :
 *
 * RETURNS: 
 *    int CALLBACK
 *
 *+-------------------------------------------------------------------------*/
int CALLBACK
CTraceDialog::CompareItems(LPARAM lp1, LPARAM lp2, LPARAM lpSortData)
{
    CTraceTag *pTag1 = reinterpret_cast<CTraceTag *>(lp1);
    CTraceTag *pTag2 = reinterpret_cast<CTraceTag *>(lp2);

    if(!pTag1 && !pTag2)
    {
        ASSERT(0 && "Should not come here.");
        return 0;
    }

    switch(lpSortData)
    {
    default:
        ASSERT(0 && "Should not come here.");
        return 0;

    case COLUMN_CATEGORY:
        return _tcscmp(pTag1->GetCategory(), pTag2->GetCategory());
        break;

    case COLUMN_NAME:
        return _tcscmp(pTag1->GetName(), pTag2->GetName());
        break;

    case COLUMN_ENABLED:
        {
            BOOL b1 = (pTag1->FAnyTemp()) ? 0 : 1;
            BOOL b2 = (pTag2->FAnyTemp()) ? 0 : 1;

            return b1 - b2;
        }
        break;
    }
    
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnInitDialog
 *
 * PURPOSE:     Initializes the dialog - adds columns, sets the file name
 *              and inserts all rows.
 *
 * PARAMETERS: 
 *    UINT    uMsg :
 *    WPARAM  wParam :
 *    LPARAM  lParam :
 *    BOOL&   bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_listCtrl.Attach(GetDlgItem(IDC_TRACE_LIST));
    m_editStackLevels.Attach(GetDlgItem(IDC_TRACE_STACKLEVELS));
    m_editStackLevels.LimitText(1); // one character only.
    
    // insert the columns - no need to localize since debug only.
    m_listCtrl.InsertColumn(COLUMN_CATEGORY, TEXT("Category") ,LVCFMT_LEFT, 150, 0);
    m_listCtrl.InsertColumn(COLUMN_NAME,     TEXT("Name"    ) ,LVCFMT_LEFT, 150, 0);
    m_listCtrl.InsertColumn(COLUMN_ENABLED,  TEXT("Enabled" ) ,LVCFMT_LEFT, 80, 0);

    // set the full row select style.
    m_listCtrl.SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);
    m_listCtrl.SortItems(CompareItems, COLUMN_CATEGORY); // the default sort.

    // Set the file name.
    SetDlgItemText(IDC_TRACE_FILENAME, CTraceTag::GetFilename());

    //Set the stack level
    SetDlgItemInt(IDC_TRACE_STACKLEVELS, CTraceTag::GetStackLevels());

    CTraceTags * pTraceTags = GetTraceTags();
    if(NULL == pTraceTags)
        return 0;


    int i = 0;
    for(CTraceTags::iterator iter = pTraceTags->begin(); iter != pTraceTags->end(); iter++, i++)
    {
        int iItem = m_listCtrl.InsertItem(LVIF_PARAM | LVIF_TEXT, 
                                          i, (*iter)->GetCategory(), 0, 0, 0, (LPARAM) (*iter));
        m_listCtrl.SetItemText(iItem, COLUMN_NAME,      (*iter)->GetName());
        m_listCtrl.SetItemText(iItem, COLUMN_ENABLED,   (*iter)->FAny() ? TEXT("X") : TEXT(""));

        // set up the tag for a temporary change.
        (*iter)->SetTempState();
    }
    RecalcCheckboxes();

    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnCancel
 *
 * PURPOSE:     Handles the Cancel button. Exits without committing changes.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_listCtrl.Detach();
    EndDialog (false);
    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CTraceDialog::OnOK
 *
 * PURPOSE:     Exits and commits changes.
 *
 * PARAMETERS: 
 *    WORD  wNotifyCode :
 *    WORD  wID :
 *    HWND  hWndCtl :
 *    BOOL& bHandled :
 *
 * RETURNS: 
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
LRESULT
CTraceDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Set the file name from the edit control
    TCHAR szFilename[OFS_MAXPATHNAME];
    GetDlgItemText(IDC_TRACE_FILENAME, (LPTSTR)szFilename, OFS_MAXPATHNAME);
    CTraceTag::GetFilename()    = szFilename;

    // Set the stack levels
    TCHAR szStackLevels[2];
    GetDlgItemText(IDC_TRACE_STACKLEVELS, (LPTSTR)szStackLevels, 2);
    int nLevels = szStackLevels[0] - TEXT('0'); // convert to integer.
    CTraceTag::GetStackLevels() = nLevels;

    CTraceTags::iterator iter;

    CTraceTags * pTraceTags = GetTraceTags();
    if(NULL == pTraceTags)
        goto Error;

    // save all the trace tags out to the .ini file
    for(iter = pTraceTags->begin(); iter != pTraceTags->end(); iter++)
    {
        CStr str;
        CTraceTag *pTag = *iter;
        if(!pTag)
            goto Error;

        pTag->Commit();

        // write out the trace tag ONLY if the setting is not the same as the default. Avoids clutter.
        str.Format(TEXT("%d"), pTag->GetAll());
        ::WritePrivateProfileString(pTag->GetCategory(), pTag->GetName(), (LPCTSTR)str, szTraceIniFile);
    }
    m_listCtrl.Detach();

    // write out the values into the ini file.
    ::WritePrivateProfileString(TEXT("Trace File"),   TEXT("Trace File"),   (LPCTSTR)szFilename,    szTraceIniFile);
    ::WritePrivateProfileString(TEXT("Stack Levels"), TEXT("Stack Levels"), (LPCTSTR)szStackLevels, szTraceIniFile);

Cleanup:
    EndDialog (true);
    return 1;

Error:
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * DoDebugTraceDialog
 *
 * PURPOSE:     Exported routine (DEBUG build only) to bring up the trace dialog.
 *
 * RETURNS: 
 *    MMCBASE_API void
 *
 *+-------------------------------------------------------------------------*/
MMCBASE_API void DoDebugTraceDialog()
{
    CTraceDialog dlg;
    dlg.DoModal();
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\version.h ===
#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "MMC Base DLL"
#define VER_INTERNALNAME_STR            "mmcbase.dll"
#define VER_ORIGINALFILENAME_STR        "mmcbase.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7CC9B821_F32B_4880_930E_33ADDFF3F376__INCLUDED_)
#define AFX_STDAFX_H__7CC9B821_F32B_4880_930E_33ADDFF3F376__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//############################################################################
//############################################################################
//
// Preprocessor settings.
//
//############################################################################
//############################################################################

// This #define causes  MMCBASE_API to be set to __declspec(dllexport)
#define MMCBASE_EXPORTS 1

//############################################################################
//############################################################################
//
// This is an MFC extension DLL, so we need the MFC header
//
//############################################################################
//############################################################################
#include "afxwin.h"

//############################################################################
//############################################################################
//
// ATL and  other classes
//
//############################################################################
//############################################################################

#define _WTL_NO_AUTOMATIC_NAMESPACE

#include <atlbase.h>
extern CComModule _Module;
#include <atlwin.h>
#include <atlapp.h>
#include <atlgdi.h>

/*
 * Delcarations of ImageList_Read and ImageList_Write copied from commctrl.h.
 *
 * Here's why:
 *
 * commctrl.h is included by afx.h.  At that time objidl.h (where IStream
 * is defined) hasn't been included yet, so the declaration of these
 * functions is skipped in commctrl.h.
 *
 * The definition of WTL::CImageList assumes that these functions have been
 * declared, so we have to go to this pain here, after IStream has been
 * declared.
 */
WINCOMMCTRLAPI HIMAGELIST WINAPI ImageList_Read(LPSTREAM pstm);
WINCOMMCTRLAPI BOOL       WINAPI ImageList_Write(HIMAGELIST himl, LPSTREAM pstm);

#include <atlctrls.h>

//############################################################################
//############################################################################
//
// STL and  other classes
//
//############################################################################
//############################################################################
#include <algorithm>
#include <exception>
#include <string>
#include <list>
#include <set>
#include <vector>
#include <map>
#include <iterator>

//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include "dbg.h"
#include "cstr.h"
#include "mmcdebug.h"
#include "mmcerror.h"
#include "countof.h"
#include "autoptr.h"
#include "classreg.h"

//############################################################################
//############################################################################
//
// include common strings.
//
//############################################################################
//############################################################################
#include "..\base\basestr.h"

//############################################################################
//############################################################################
//
// Debug support for legacy traces.
//
//############################################################################
//############################################################################
#ifdef TRACE
#undef TRACE
#endif

#ifdef DBG

#define TRACE TraceBaseLegacy

#else // DBG

#define TRACE               ;/##/

#endif DBG



#endif // !defined(AFX_STDAFX_H__7CC9B821_F32B_4880_930E_33ADDFF3F376__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\base\tracedlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      tracedlg.h
//
//  Contents:  Declaration of the debug trace code
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#ifndef TRACEDLG_H
#define TRACEDLG_H
#pragma once

#ifdef DBG

// forward class declarations
class CTraceDialog;

class CTraceDialog : public CDialogImpl<CTraceDialog>
{
    typedef CDialogImpl<CTraceDialog> BC;
// Construction
public:
    CTraceDialog() : m_dwSortData(0) {}

    enum { IDD = IDD_DEBUG_TRACE_DIALOG };

    // compare tags based on columns.
    static int CALLBACK CompareItems(LPARAM lp1, LPARAM lp2, LPARAM lpSortData);

// Implementation
protected:
    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG,              OnInitDialog)
        COMMAND_ID_HANDLER (IDOK,                       OnOK)
        COMMAND_ID_HANDLER (IDCANCEL,                   OnCancel)
        COMMAND_ID_HANDLER(IDC_TRACE_TO_COM2,           OnOutputToCOM2)
        COMMAND_ID_HANDLER(IDC_TRACE_OUTPUTDEBUGSTRING, OnOutputDebugString)
        COMMAND_ID_HANDLER(IDC_TRACE_TO_FILE,           OnOutputToFile)
        COMMAND_ID_HANDLER(IDC_TRACE_DEBUG_BREAK,       OnDebugBreak)
        COMMAND_ID_HANDLER(IDC_TRACE_DUMP_STACK,        OnDumpStack)
        COMMAND_ID_HANDLER(IDC_TRACE_DEFAULT,           OnRestoreDefaults)
        COMMAND_ID_HANDLER(IDC_TRACE_SELECT_ALL,        OnSelectAll)
        NOTIFY_HANDLER    (IDC_TRACE_LIST, LVN_ITEMCHANGED, OnSelChanged)
        NOTIFY_HANDLER    (IDC_TRACE_LIST, LVN_COLUMNCLICK, OnColumnClick)
    END_MSG_MAP();


    LRESULT OnInitDialog        (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK                (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel            (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnOutputToCOM2      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOutputDebugString (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOutputToFile      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDebugBreak        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDumpStack         (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRestoreDefaults   (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelectAll         (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSelChanged        (int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnColumnClick       (int idCtrl, LPNMHDR pnmh, BOOL& bHandled );


    void    RecalcCheckboxes();
    void    DoSort();

private:
    enum
    {
        COLUMN_CATEGORY = 0,
        COLUMN_NAME     = 1,
        COLUMN_ENABLED  = 2
    };

    void            SetMaskFromCheckbox(UINT idControl, DWORD dwMask);

    WTL::CListViewCtrl m_listCtrl;
    WTL::CEdit         m_editStackLevels;
    DWORD              m_dwSortData;

};

#endif // DBG

#endif  // TRACEDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\cab\i386\htmlhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       htmlhelp.h
//
//--------------------------------------------------------------------------

/****************************************************************************
*                                                                           *
* HtmlHelp.h                                                                *
*                                                                           *
* Copyright (c) 1996-1997, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __HTMLHELP_H__
#define __HTMLHELP_H__

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

// Defines for Win64
#ifndef _WIN64
#define DWORD_PTR DWORD
#endif

// Commands to pass to HtmlHelp()

#define HH_DISPLAY_TOPIC        0x0000
#define HH_HELP_FINDER          0x0000  // WinHelp equivalent
#define HH_DISPLAY_TOC          0x0001  // not currently implemented
#define HH_DISPLAY_INDEX        0x0002  // not currently implemented
#define HH_DISPLAY_SEARCH       0x0003  // not currently implemented
#define HH_SET_WIN_TYPE         0x0004
#define HH_GET_WIN_TYPE         0x0005
#define HH_GET_WIN_HANDLE       0x0006
#define HH_ENUM_INFO_TYPE       0x0007  // Get Info type name, call repeatedly to enumerate, -1 at end
#define HH_SET_INFO_TYPE        0x0008  // Add Info type to filter.
#define HH_SYNC                 0x0009
#define HH_RESERVED1            0x000A
#define HH_RESERVED2            0x000B
#define HH_RESERVED3            0x000C
#define HH_KEYWORD_LOOKUP       0x000D
#define HH_DISPLAY_TEXT_POPUP   0x000E  // display string resource id or text in a popup window
#define HH_HELP_CONTEXT         0x000F  // display mapped numeric value in dwData
#define HH_TP_HELP_CONTEXTMENU  0x0010  // text popup help, same as WinHelp HELP_CONTEXTMENU
#define HH_TP_HELP_WM_HELP      0x0011  // text popup help, same as WinHelp HELP_WM_HELP
#define HH_CLOSE_ALL            0x0012  // close all windows opened directly or indirectly by the caller
#define HH_ALINK_LOOKUP         0x0013  // ALink version of HH_KEYWORD_LOOKUP
#define HH_GET_LAST_ERROR       0x0014  // not currently implemented // See HHERROR.h
#define HH_ENUM_CATEGORY        0x0015	// Get category name, call repeatedly to enumerate, -1 at end
#define HH_ENUM_CATEGORY_IT     0x0016  // Get category info type members, call repeatedly to enumerate, -1 at end
#define HH_RESET_IT_FILTER      0x0017  // Clear the info type filter of all info types.
#define HH_SET_INCLUSIVE_FILTER 0x0018  // set inclusive filtering method for untyped topics to be included in display
#define HH_SET_EXCLUSIVE_FILTER 0x0019  // set exclusive filtering method for untyped topics to be excluded from display
#define HH_INITIALIZE            0x001C  // Initializes the help system.
#define HH_UNINITIALIZE          0x001D  // Uninitializes the help system.
#define HH_PRETRANSLATEMESSAGE  0x00fd  // Pumps messages. (NULL, NULL, MSG*). 
#define HH_SET_GLOBAL_PROPERTY  0x00fc  // Set a global property. (NULL, NULL, HH_GPROP)

#define HHWIN_PROP_TAB_AUTOHIDESHOW (1 << 0)    // Automatically hide/show tri-pane window
#define HHWIN_PROP_ONTOP            (1 << 1)    // Top-most window
#define HHWIN_PROP_NOTITLEBAR       (1 << 2)    // no title bar
#define HHWIN_PROP_NODEF_STYLES     (1 << 3)    // no default window styles (only HH_WINTYPE.dwStyles)
#define HHWIN_PROP_NODEF_EXSTYLES   (1 << 4)    // no default extended window styles (only HH_WINTYPE.dwExStyles)
#define HHWIN_PROP_TRI_PANE         (1 << 5)    // use a tri-pane window
#define HHWIN_PROP_NOTB_TEXT        (1 << 6)    // no text on toolbar buttons
#define HHWIN_PROP_POST_QUIT        (1 << 7)    // post WM_QUIT message when window closes
#define HHWIN_PROP_AUTO_SYNC        (1 << 8)    // automatically ssync contents and index
#define HHWIN_PROP_TRACKING         (1 << 9)    // send tracking notification messages
#define HHWIN_PROP_TAB_SEARCH       (1 << 10)   // include search tab in navigation pane
#define HHWIN_PROP_TAB_HISTORY      (1 << 11)   // include history tab in navigation pane
#define HHWIN_PROP_TAB_FAVORITES    (1 << 12)   // include favorites tab in navigation pane
#define HHWIN_PROP_CHANGE_TITLE     (1 << 13)   // Put current HTML title in title bar
#define HHWIN_PROP_NAV_ONLY_WIN     (1 << 14)   // Only display the navigation window
#define HHWIN_PROP_NO_TOOLBAR       (1 << 15)   // Don't display a toolbar
#define HHWIN_PROP_MENU             (1 << 16)   // Menu
#define HHWIN_PROP_TAB_ADVSEARCH    (1 << 17)   // Advanced FTS UI.
#define HHWIN_PROP_USER_POS         (1 << 18)   // After initial creation, user controls window size/position
#define HHWIN_PROP_TAB_CUSTOM1      (1 << 19)   // Use custom tab #1
#define HHWIN_PROP_TAB_CUSTOM2      (1 << 20)   // Use custom tab #2
#define HHWIN_PROP_TAB_CUSTOM3      (1 << 21)   // Use custom tab #3
#define HHWIN_PROP_TAB_CUSTOM4      (1 << 22)   // Use custom tab #4
#define HHWIN_PROP_TAB_CUSTOM5      (1 << 23)   // Use custom tab #5
#define HHWIN_PROP_TAB_CUSTOM6      (1 << 24)   // Use custom tab #6
#define HHWIN_PROP_TAB_CUSTOM7      (1 << 25)   // Use custom tab #7
#define HHWIN_PROP_TAB_CUSTOM8      (1 << 26)   // Use custom tab #8
#define HHWIN_PROP_TAB_CUSTOM9      (1 << 27)   // Use custom tab #9
#define HHWIN_TB_MARGIN             (1 << 28)   // the window type has a margin

#define HHWIN_PARAM_PROPERTIES      (1 << 1)    // valid fsWinProperties
#define HHWIN_PARAM_STYLES          (1 << 2)    // valid dwStyles
#define HHWIN_PARAM_EXSTYLES        (1 << 3)    // valid dwExStyles
#define HHWIN_PARAM_RECT            (1 << 4)    // valid rcWindowPos
#define HHWIN_PARAM_NAV_WIDTH       (1 << 5)    // valid iNavWidth
#define HHWIN_PARAM_SHOWSTATE       (1 << 6)    // valid nShowState
#define HHWIN_PARAM_INFOTYPES       (1 << 7)    // valid apInfoTypes
#define HHWIN_PARAM_TB_FLAGS        (1 << 8)    // valid fsToolBarFlags
#define HHWIN_PARAM_EXPANSION       (1 << 9)    // valid fNotExpanded
#define HHWIN_PARAM_TABPOS          (1 << 10)   // valid tabpos
#define HHWIN_PARAM_TABORDER        (1 << 11)   // valid taborder
#define HHWIN_PARAM_HISTORY_COUNT   (1 << 12)   // valid cHistory
#define HHWIN_PARAM_CUR_TAB         (1 << 13)   // valid curNavType

#define HHWIN_BUTTON_EXPAND         (1 << 1)    // Expand/contract button
#define HHWIN_BUTTON_BACK           (1 << 2)    // Back button
#define HHWIN_BUTTON_FORWARD        (1 << 3)    // Forward button
#define HHWIN_BUTTON_STOP           (1 << 4)    // Stop button
#define HHWIN_BUTTON_REFRESH        (1 << 5)    // Refresh button
#define HHWIN_BUTTON_HOME           (1 << 6)    // Home button
#define HHWIN_BUTTON_BROWSE_FWD     (1 << 7)    // not implemented
#define HHWIN_BUTTON_BROWSE_BCK     (1 << 8)    // not implemented
#define HHWIN_BUTTON_NOTES          (1 << 9)    // not implemented
#define HHWIN_BUTTON_CONTENTS       (1 << 10)   // not implemented
#define HHWIN_BUTTON_SYNC           (1 << 11)   // Sync button
#define HHWIN_BUTTON_OPTIONS        (1 << 12)   // Options button
#define HHWIN_BUTTON_PRINT          (1 << 13)   // Print button
#define HHWIN_BUTTON_INDEX          (1 << 14)   // not implemented
#define HHWIN_BUTTON_SEARCH         (1 << 15)   // not implemented
#define HHWIN_BUTTON_HISTORY        (1 << 16)   // not implemented
#define HHWIN_BUTTON_FAVORITES      (1 << 17)   // not implemented
#define HHWIN_BUTTON_JUMP1          (1 << 18)
#define HHWIN_BUTTON_JUMP2          (1 << 19)
#define HHWIN_BUTTON_ZOOM           (1 << 20)
#define HHWIN_BUTTON_TOC_NEXT       (1 << 21)
#define HHWIN_BUTTON_TOC_PREV       (1 << 22)

#define HHWIN_DEF_BUTTONS           \
            (HHWIN_BUTTON_EXPAND |  \
             HHWIN_BUTTON_BACK |    \
             HHWIN_BUTTON_OPTIONS | \
             HHWIN_BUTTON_PRINT)

// Button IDs

#define IDTB_EXPAND             200
#define IDTB_CONTRACT           201
#define IDTB_STOP               202
#define IDTB_REFRESH            203
#define IDTB_BACK               204
#define IDTB_HOME               205
#define IDTB_SYNC               206
#define IDTB_PRINT              207
#define IDTB_OPTIONS            208
#define IDTB_FORWARD            209
#define IDTB_NOTES              210 // not implemented
#define IDTB_BROWSE_FWD         211
#define IDTB_BROWSE_BACK        212
#define IDTB_CONTENTS           213 // not implemented
#define IDTB_INDEX              214 // not implemented
#define IDTB_SEARCH             215 // not implemented
#define IDTB_HISTORY            216 // not implemented
#define IDTB_FAVORITES          217 // not implemented
#define IDTB_JUMP1              218
#define IDTB_JUMP2              219
#define IDTB_CUSTOMIZE          221
#define IDTB_ZOOM               222
#define IDTB_TOC_NEXT           223
#define IDTB_TOC_PREV           224

// Notification codes

#define HHN_FIRST       (0U-860U)
#define HHN_LAST        (0U-879U)

#define HHN_NAVCOMPLETE   (HHN_FIRST-0)
#define HHN_TRACK         (HHN_FIRST-1)
#define HHN_WINDOW_CREATE (HHN_FIRST-2)

typedef struct tagHHN_NOTIFY
{
    NMHDR   hdr;
    PCSTR   pszUrl; // Multi-byte, null-terminated string
} HHN_NOTIFY;

typedef struct tagHH_POPUP
{
    int       cbStruct;      // sizeof this structure
    HINSTANCE hinst;         // instance handle for string resource
    UINT      idString;      // string resource id, or text id if pszFile is specified in HtmlHelp call
    LPCTSTR   pszText;       // used if idString is zero
    POINT     pt;            // top center of popup window
    COLORREF  clrForeground; // use -1 for default
    COLORREF  clrBackground; // use -1 for default
    RECT      rcMargins;     // amount of space between edges of window and text, -1 for each member to ignore
    LPCTSTR   pszFont;       // facename, point size, char set, BOLD ITALIC UNDERLINE
} HH_POPUP;

typedef struct tagHH_AKLINK
{
    int       cbStruct;     // sizeof this structure
    BOOL      fReserved;    // must be FALSE (really!)
    LPCTSTR   pszKeywords;  // semi-colon separated keywords
    LPCTSTR   pszUrl;       // URL to jump to if no keywords found (may be NULL)
    LPCTSTR   pszMsgText;   // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszMsgTitle;  // Message text to display in MessageBox if pszUrl is NULL and no keyword match
    LPCTSTR   pszWindow;    // Window to display URL in
    BOOL      fIndexOnFail; // Displays index if keyword lookup fails.
} HH_AKLINK;

enum {
    HHWIN_NAVTYPE_TOC,
    HHWIN_NAVTYPE_INDEX,
    HHWIN_NAVTYPE_SEARCH,
    HHWIN_NAVTYPE_FAVORITES,
    HHWIN_NAVTYPE_HISTORY,   // not implemented
    HHWIN_NAVTYPE_AUTHOR,
    HHWIN_NAVTYPE_CUSTOM_FIRST = 11
};

enum {
    IT_INCLUSIVE,
    IT_EXCLUSIVE,
    IT_HIDDEN,
};

typedef struct tagHH_ENUM_IT
{
    int       cbStruct;          // size of this structure
    int       iType;             // the type of the information type ie. Inclusive, Exclusive, or Hidden
    LPCSTR    pszCatName;        // Set to the name of the Category to enumerate the info types in a category; else NULL
    LPCSTR    pszITName;         // volitile pointer to the name of the infotype. Allocated by call. Caller responsible for freeing
    LPCSTR    pszITDescription;  // volitile pointer to the description of the infotype.
} HH_ENUM_IT, *PHH_ENUM_IT;

typedef struct tagHH_ENUM_CAT
{
    int       cbStruct;          // size of this structure
    LPCSTR    pszCatName;        // volitile pointer to the category name
    LPCSTR    pszCatDescription; // volitile pointer to the category description
} HH_ENUM_CAT, *PHH_ENUM_CAT;

typedef struct tagHH_SET_INFOTYPE
{
    int       cbStruct;          // the size of this structure
    LPCSTR    pszCatName;        // the name of the category, if any, the InfoType is a member of.
    LPCSTR    pszInfoTypeName;   // the name of the info type to add to the filter
} HH_SET_INFOTYPE, *PHH_SET_INFOTYPE;

typedef DWORD HH_INFOTYPE;
typedef HH_INFOTYPE* PHH_INFOTYPE;

enum {
    HHWIN_NAVTAB_TOP,
    HHWIN_NAVTAB_LEFT,
    HHWIN_NAVTAB_BOTTOM,
};

#define HH_MAX_TABS 19  // maximum number of tabs

enum {
    HH_TAB_CONTENTS,
    HH_TAB_INDEX,
    HH_TAB_SEARCH,
    HH_TAB_FAVORITES,
    HH_TAB_HISTORY,
    HH_TAB_AUTHOR,

    HH_TAB_CUSTOM_FIRST = 11,
    HH_TAB_CUSTOM_LAST = HH_MAX_TABS
};

#define HH_MAX_TABS_CUSTOM (HH_TAB_CUSTOM_LAST - HH_TAB_CUSTOM_FIRST + 1)

// HH_DISPLAY_SEARCH Command Related Structures and Constants

#define HH_FTS_DEFAULT_PROXIMITY (-1)

typedef struct tagHH_FTS_QUERY
{
    int cbStruct;            // Sizeof structure in bytes.
    BOOL fUniCodeStrings;    // TRUE if all strings are unicode.
    LPCTSTR pszSearchQuery;  // String containing the search query.
    LONG iProximity;         // Word proximity.
    BOOL fStemmedSearch;     // TRUE for StemmedSearch only.
    BOOL fTitleOnly;         // TRUE for Title search only.
    BOOL fExecute;           // TRUE to initiate the search.
    LPCTSTR pszWindow;       // Window to display in
} HH_FTS_QUERY;

// HH_WINTYPE Structure

typedef struct tagHH_WINTYPE {
    int     cbStruct;        // IN: size of this structure including all Information Types
    BOOL    fUniCodeStrings; // IN/OUT: TRUE if all strings are in UNICODE
    LPCTSTR pszType;         // IN/OUT: Name of a type of window
    DWORD   fsValidMembers;  // IN: Bit flag of valid members (HHWIN_PARAM_)
    DWORD   fsWinProperties; // IN/OUT: Properties/attributes of the window (HHWIN_)

    LPCTSTR pszCaption;      // IN/OUT: Window title
    DWORD   dwStyles;        // IN/OUT: Window styles
    DWORD   dwExStyles;      // IN/OUT: Extended Window styles
    RECT    rcWindowPos;     // IN: Starting position, OUT: current position
    int     nShowState;      // IN: show state (e.g., SW_SHOW)

    HWND  hwndHelp;          // OUT: window handle
    HWND  hwndCaller;        // OUT: who called this window

    HH_INFOTYPE* paInfoTypes;  // IN: Pointer to an array of Information Types

    // The following members are only valid if HHWIN_PROP_TRI_PANE is set

    HWND  hwndToolBar;      // OUT: toolbar window in tri-pane window
    HWND  hwndNavigation;   // OUT: navigation window in tri-pane window
    HWND  hwndHTML;         // OUT: window displaying HTML in tri-pane window
    int   iNavWidth;        // IN/OUT: width of navigation window
    RECT  rcHTML;           // OUT: HTML window coordinates

    LPCTSTR pszToc;         // IN: Location of the table of contents file
    LPCTSTR pszIndex;       // IN: Location of the index file
    LPCTSTR pszFile;        // IN: Default location of the html file
    LPCTSTR pszHome;        // IN/OUT: html file to display when Home button is clicked
    DWORD   fsToolBarFlags; // IN: flags controling the appearance of the toolbar
    BOOL    fNotExpanded;   // IN: TRUE/FALSE to contract or expand, OUT: current state
    int     curNavType;     // IN/OUT: UI to display in the navigational pane
    int     tabpos;         // IN/OUT: HHWIN_NAVTAB_TOP, HHWIN_NAVTAB_LEFT, or HHWIN_NAVTAB_BOTTOM
    int     idNotify;       // IN: ID to use for WM_NOTIFY messages
    BYTE    tabOrder[HH_MAX_TABS + 1];    // IN/OUT: tab order: Contents, Index, Search, History, Favorites, Reserved 1-5, Custom tabs
    int     cHistory;       // IN/OUT: number of history items to keep (default is 30)
    LPCTSTR pszJump1;       // Text for HHWIN_BUTTON_JUMP1
    LPCTSTR pszJump2;       // Text for HHWIN_BUTTON_JUMP2
    LPCTSTR pszUrlJump1;    // URL for HHWIN_BUTTON_JUMP1
    LPCTSTR pszUrlJump2;    // URL for HHWIN_BUTTON_JUMP2
    RECT    rcMinSize;      // Minimum size for window (ignored in version 1)
    int     cbInfoTypes;    // size of paInfoTypes;
    LPCTSTR pszCustomTabs;  // multiple zero-terminated strings
} HH_WINTYPE, *PHH_WINTYPE;

enum {
    HHACT_TAB_CONTENTS,
    HHACT_TAB_INDEX,
    HHACT_TAB_SEARCH,
    HHACT_TAB_HISTORY,
    HHACT_TAB_FAVORITES,

    HHACT_EXPAND,
    HHACT_CONTRACT,
    HHACT_BACK,
    HHACT_FORWARD,
    HHACT_STOP,
    HHACT_REFRESH,
    HHACT_HOME,
    HHACT_SYNC,
    HHACT_OPTIONS,
    HHACT_PRINT,
    HHACT_HIGHLIGHT,
    HHACT_CUSTOMIZE,
    HHACT_JUMP1,
    HHACT_JUMP2,
    HHACT_ZOOM,
    HHACT_TOC_NEXT,
    HHACT_TOC_PREV,
    HHACT_NOTES,

    HHACT_LAST_ENUM,
};

typedef struct tagHHNTRACK
{
    NMHDR   hdr;
    PCSTR   pszCurUrl;      // Multi-byte, null-terminated string
    int     idAction;       // HHACT_ value
    HH_WINTYPE* phhWinType; // Current window type structure
} HHNTRACK;

HWND
WINAPI
HtmlHelpA(
    HWND hwndCaller,
    LPCSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );

HWND
WINAPI
HtmlHelpW(
    HWND hwndCaller,
    LPCWSTR pszFile,
    UINT uCommand,
    DWORD_PTR dwData
    );
#ifdef UNICODE
#define HtmlHelp  HtmlHelpW
#else
#define HtmlHelp  HtmlHelpA
#endif // !UNICODE

// Use the following for GetProcAddress to load from hhctrl.ocx

#define ATOM_HTMLHELP_API_ANSI    (LPTSTR)((DWORD)((WORD)(14)))
#define ATOM_HTMLHELP_API_UNICODE (LPTSTR)((DWORD)((WORD)(15)))

///////////////////////////////////////////////////////////////////////////////
//
// Global Control Properties. 
//
typedef enum tagHH_GPROPID
{
    HH_GPROPID_SINGLETHREAD=1,      // VARIANT_BOOL: True for single thread
    HH_GPROPID_TOOLBAR_MARGIN=2,    // long: Provides a left/right margin around the toolbar.
    HH_GPROPID_UI_LANGUAGE=3,       // long: LangId of the UI.
    HH_GPROPID_CURRENT_SUBSET=4,    // BSTR: Current subset.
    HH_GPROPID_CONTENT_LANGUAGE=5   // long: LandId for desired content.
} HH_GPROPID;

///////////////////////////////////////////////////////////////////////////////
//
// Global Property structure
//
#ifdef __oaidl_h__

#pragma pack(push, 8)

typedef struct tagHH_GLOBAL_PROPERTY
{
    HH_GPROPID  id;
    VARIANT     var;
} HH_GLOBAL_PROPERTY ;

#pragma pack(pop)
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __HTMLHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\cab\i386\collect.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       collect.h
//
//--------------------------------------------------------------------------

//*********************************************************************************************************************************************
//
//      File: collect.h
//  Author: Donald Drake
//  Purpose: Defines classes to support titles, collections, locations and folders

#ifndef _COLLECT_H
#define _COLLECT_H

#undef CLASS_IMPORT_EXPORT
#ifdef HHCTRL // define this only when building the HHCtrl DLL
  #define CLASS_IMPORT_EXPORT /**/
#else
 #ifdef HHSETUP // define this only when building the HHSetup DLL
  #define CLASS_IMPORT_EXPORT __declspec( dllexport )
 #else
  #define CLASS_IMPORT_EXPORT __declspec( dllimport )
 #endif
#endif

#ifndef HHCTRL

#undef COUNT
#define COUNT(x)

#undef MI_COUNT
#define MI_COUNT(x)

#undef SI_COUNT
#define SI_COUNT(x)

#undef MI2_COUNT
#define MI2_COUNT(x)

#undef AUTO_CLASS_COUNT_CHECK
#define AUTO_CLASS_COUNT_CHECK(x)

#undef CHECK_CLASS_COUNT
#define CHECK_CLASS_COUNT(x)

#undef DUMP_CLASS_COUNT
#define DUMP_CLASS_COUNT(x)

#endif

#ifdef HHCTRL
#include "parserhh.h"
#else
#include "parser.h"
#endif

#define  F_MSDN         0x0001
#define  F_TITLELOCAL   0x0002
#define  F_INDEXLOCAL   0x0004

#define ENGLANGID 1033

#define MAX_LEVELS 100

typedef struct LocationHistory {
   CHAR * SampleLocation;
   CHAR * FileName;
   CHAR * IndexFileName;
   CHAR * QueryFileName;
   CHAR * LocationId;
   DWORD CollectionNumber;
   DWORD Version;
   DWORD LastPromptedVersion;
   BOOL bSupportsMerge;
   LocationHistory *pNext;
   CHAR * QueryLocation;
} LOCATIONHISTORY;

DWORD CLASS_IMPORT_EXPORT AllocSetValue(const CHAR *value, CHAR **dest);

// forward declarations
class CLocation;
class CTitle;
class CCollection;
class CFolder;
class CSlotLookupTable;
class CExTitle;
class CColList;

typedef struct ListItem {
   void *pItem;
   ListItem *Next;
} LISTITEM;

class CLASS_IMPORT_EXPORT CPointerList {
private:
   LISTITEM *m_pHead;

public:
   CPointerList()
   {
      m_pHead = NULL;
   }

   ~CPointerList();
   void RemoveAll();
   LISTITEM *Add(void *);
   LISTITEM *First();
   LISTITEM *Next(LISTITEM *p) { return p->Next; }
};

#ifdef HHCTRL // define this only when building the HHCtrl DLL

//
// <mc>
// This lookup table will facilitate a quick translation of a "slot" number into a CFolder* as well as a
// HASH value into a CFolder*. This will be done using two DWORDS per CFolder object, one for the HASH value
// and one for the CFolder*. After ALL the CFolders for a given collection have been created and this lookup
// table is fully populated the SortAndAssignSlots() member will be called. This will sort the table by HASH
// value and will assign the slot values back to the CFolders according to the sorted order. This will make
// slot --> CFolder* lookup a simple array index and will also allow us to use a bsearch for the
// HASH --> CFolder* lookup. Note that only leaf level CFolders have useful hash values, for the non leaf
// CFolders we will assign a hash of -1, these items in the table will then appear at the end of the table
// and will not interfear with a bsearch operation when translating a hash into a pSLT.
// </mc>
//
class CSlotLookupTable
{
public:
   CSlotLookupTable();
   ~CSlotLookupTable();

   static int FASTCALL ltqs_callback(const void *elem1, const void *elem2);
   void AddValue(CFolder* pFolder);
   void SortAndAssignSlots(void);
   CFolder* HashToCFolder(HASH hash);

   CFolder* SlotToCFolder(DWORD dwSlot)
   {
      if ( dwSlot > 0 && dwSlot <= m_uiTotalCnt )        // Slot 0 reserved for error case.
         return m_pSLT[dwSlot].pCFolder;
      else
         return NULL;
   }

private:
   struct _slt
   {
      HASH  hash;
      CFolder* pCFolder;
   };

   struct _slt*  m_pSLT;
   unsigned  m_uiTotalAllocated;
   unsigned  m_uiTotalCnt;
   unsigned  m_uiHashCnt;
};

#endif

class CLASS_IMPORT_EXPORT CFolder SI_COUNT(CFolder)
{
private:
   CHAR *Title;                           // name of the folder
   WCHAR *pwcTitle;
   DWORD Order;
   LANGID LangId;
   DWORD dwSlot;
   CExTitle* pExTitle;
   CFolder *pNext, *pKid, *pParent;
   //
   // This DWORD value is being added to support .CHM level subsetting.
   //
   WORD                     iLevel;
   WORD                     f_Filter:    1;  // render into filter LB.
   WORD                     f_Available: 1;  // render into Available LB.
   WORD                     f_F_Open:    1;  // Expanded or closed ?
   WORD                     f_A_Open:    1;  // Expanded or closed ?
   WORD                     f_HasHash:   1;  // Does Node have a prefix hash ?
   WORD                     f_IsOrphan:  1;  // Is this node an orphane ?
   WORD                     f_IsVisable: 1;  // Indicates membership in the currently selected TOC subset.

public:
   CFolder();
   ~CFolder();
   BOOL bIsVisable() { return (BOOL)f_IsVisable; }
   void SetTitle(const  CHAR *);
   void SetTitle(const  WCHAR *);
   void SetExTitlePtr(CExTitle* pTitle);
   CHAR *GetTitle() {  return Title; }
   const WCHAR *GetTitleW();
   void SetLanguage(LANGID Id) { LangId = Id; }
   LANGID GetLanguage() { return LangId; }
   void SetOrder(DWORD);
   DWORD GetOrder();
   // Returns the next sibling folder given a folder entry
   CFolder * GetNextFolder();
   void SetNextFolder(CFolder *p) { pNext = p; }
   // Returns the first child of a given folder if it exists
   CFolder * GetFirstChildFolder();
   void SetFirstChildFolder(CFolder *p) { pKid = p; }
   // Add a new folder as child of a given folder
   CFolder * AddChildFolder(const CHAR *szName, DWORD Order, DWORD *pError, LANGID LangId = ENGLANGID);
   CFolder * AddChildFolder(const WCHAR *szName, DWORD Order, DWORD *pError, LANGID LangId = ENGLANGID);
   DWORD AddChildFolder(CFolder *newFolder);
   void SetParent(CFolder *p) { pParent = p; }
   CFolder * GetParent() { return pParent; }

friend class CSlotLookupTable;
friend class CDefineSS;
friend class CStructuralSubset;

};


class CLASS_IMPORT_EXPORT CCollection SI_COUNT(CCollection)
{
public:
   CCollection();
   ~CCollection();
   void ConfirmTitles() { m_bConfirmTitles = TRUE; }
   void SetSampleLocation(const CHAR *);
   CHAR *GetSampleLocation();
   void SetMasterCHM(const CHAR *szName, LANGID Lang);
   BOOL GetMasterCHM(CHAR ** szName, LANGID *Lang);
   // Opens and loads the contents of the file into data structures
   DWORD Open(const CHAR * FileName);
   void SetSampleLocation(const WCHAR *);
   const WCHAR *GetSampleLocationW();
   void SetMasterCHM(const WCHAR *szName, LANGID Lang);
   BOOL GetMasterCHM(WCHAR ** szName, LANGID *Lang);
   // Opens and loads the contents of the file into data structures
   DWORD Open(const WCHAR * FileName);
   // Saves any changes made to the internal data structures to the file.
   DWORD Save();
   DWORD Close();

   void AddRef() { m_dwRef++; }

   DWORD GetVersion() { return m_dwVersion; }
   void SetVersion(DWORD dw) { m_dwVersion = dw; }
   // navigating the collection
   // Returns the first folder in the collection
   CFolder * GetRootFolder() { return m_pRootFolder; }
   CFolder * GetVisableRootFolder() { return m_pRootFolder->GetFirstChildFolder(); } // Returns the visable root.
   // Returns the first title
   CTitle * GetFirstTitle();
   // Locates a title based on id
   CTitle * FindTitle(const CHAR * Id, LANGID LangId = ENGLANGID);
   CTitle * FindTitle(const WCHAR * Id, LANGID LangId = ENGLANGID);
    // Try multiple LangIds, before failing.
#ifdef HHCTRL
    CTitle * FindTitleNonExact(const CHAR * Id, LANGID LangId) ;
#endif // #ifdef HHCTRL


   // Returns the first location
   CLocation* FirstLocation();
   // Finds a location based on a name
   CLocation * FindLocation(const CHAR * Name, UINT* puiVolumeOrder = NULL );

   // collection entry management
   CColList * FindCollection(CHAR *szFileName);
   CColList * AddCollection();
   void RemoveCollectionEntry(CHAR *szFileName);

   //Adds a new folder to the top level of the table of contents, with the given name and order and returns a pointer to that folder object.  A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
   CFolder * AddFolder(const CHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId = ENGLANGID);

   DWORD DeleteFolder(CFolder *);
   //Adds a title based on the provided information.
   //A return of NULL indicates a failure and pDWORD will be
   //populated with one of  above DWORD codes.  Note: you must add or
   //find a CLocation object or pass null to indication no location is in
   // use (local file).
   CTitle * AddTitle(const CHAR * Id, const CHAR * FileName, const CHAR * IndexFile,
              const CHAR * Query, const CHAR *SampleLocation, LANGID Lang,
              UINT uiFlags, CLocation *pLocation,  DWORD *pDWORD,
              BOOL bSupportsMerge = FALSE, const CHAR *QueryLocation = NULL);


   // Adds location based on the given information. A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
   CLocation * AddLocation(const CHAR * Title, const CHAR * Path, const CHAR * Id, const CHAR * Volume, DWORD *pDWORD);

   CLocation * FindLocation(const WCHAR * Name, UINT* puiVolumeOrder = NULL );
   CFolder * AddFolder(const WCHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId = ENGLANGID);
   CTitle * AddTitle(const WCHAR * Id, const WCHAR * FileName,
              const WCHAR * IndexFile, const WCHAR * Query,
              const WCHAR *SampleLocation, LANGID Lang, UINT uiFlags,
              CLocation *pLocation,  DWORD *pDWORD,
              BOOL bSupportsMerge = FALSE, const WCHAR *QueryLocation = NULL);
   CLocation * AddLocation(const WCHAR * Title, const WCHAR * Path, const WCHAR * Id, const WCHAR * Volume, DWORD *pDWORD);

   DWORD RemoveCollection(BOOL bRemoveLocalFiles = FALSE);

   DWORD GetRefTitleCount() { return m_dwTitleRefCount; }
   // Merges the currently installed titles for the collection into the specified filename (path determined internally)
   BOOL MergeKeywords(CHAR * pwzFilename );
   BOOL MergeKeywords(WCHAR * pwzFilename );
   DWORD GetColNo() { return m_dwColNo; }
   PCSTR GetCollectionFileName(void) { return m_szFileName; }
   const WCHAR *GetCollectionFileNameW(void);
   BOOL IsDirty() { return m_bDirty;}
   void IncrementRefTitleCount() { m_dwTitleRefCount++; }
   void DecrementRefTitleCount() { m_dwTitleRefCount--; }
   void Dirty() { m_bDirty = TRUE; }

   LANGID GetLangId(const CHAR *FileName);
   LANGID GetLangId(const WCHAR *FileName);
private:  // functions

   DWORD AddRefedTitle(CFolder *pFolder);
   // removing objects
   DWORD DeleteTitle(CTitle *);
   void DeleteLocalFiles(LOCATIONHISTORY *pHist, CTitle *pTitle);
   DWORD DeleteLocation(CLocation *);

   DWORD CheckTitleRef(const CHAR *pId, const LANGID Lang);
   DWORD CheckTitleRef(const WCHAR *pId, const LANGID Lang);
   DWORD ParseFile(const CHAR *FileName);
   DWORD HandleCollection(CParseXML *parser, CHAR *sz);
   DWORD HandleCollectionEntry(CParseXML *parser, CHAR *sz);
   DWORD HandleFolder(CParseXML *parser, CHAR *token);
   DWORD HandleLocation(CParseXML *parser, CHAR *token);
   DWORD HandleTitle(CParseXML *parser, CHAR *token);
   void DeleteChildren(CFolder **p);
   void DeleteFolders(CFolder **p);
   BOOL WriteFolders(CFolder **p);
   BOOL WriteFolder(CFolder **p);
   DWORD AllocCopyValue(CParseXML *parser, CHAR *token, CHAR **dest);
   CTitle *NewTitle();
   CLocation *NewLocation();

private:
   BOOL m_bRemoveLocalFiles;
   BOOL m_bRemoved;
   DWORD Release();
   CHAR * m_szFileName;
   WCHAR * m_pwcFileName;
   CHAR * m_szMasterCHM;
   WCHAR * m_pwcMasterCHM;
   CHAR * m_szSampleLocation;
   WCHAR * m_pwcSampleLocation;
   LANGID m_MasterLangId;
   CTitle * m_pFirstTitle;
   CTitle * m_pTitleTail;
   CLocation * m_pFirstLocation;
   CLocation * m_pLocationTail;
   CFolder *m_pRootFolder;
   DWORD m_locationnum;
   CFIFOString m_Strings;
   CFolder *m_pParents[MAX_LEVELS];
   DWORD m_dwCurLevel;
   DWORD m_dwLastLevel;
   DWORD m_dwNextColNo;
   DWORD m_dwColNo;
   DWORD m_dwTitleRefCount;
   BOOL m_bConfirmTitles;
   DWORD m_dwRef;
   DWORD m_dwVersion;
   HANDLE m_fh;
   BOOL m_bDirty;
   CColList *m_pColListHead;
   CColList *m_pColListTail;
public:
   CPointerList  m_RefTitles;
   BOOL m_bFailNoFile;
   BOOL m_bAllFilesDeleted;
};

class CColList
{
private:
	DWORD m_dwColNo;
	CHAR * m_szFileName;
	CColList *m_pNext;
public:
	CColList();
	~CColList();
	void SetColNo(DWORD dw) { m_dwColNo = dw; }
	void SetFileName(CHAR *szFileName);
	DWORD GetColNo() { return m_dwColNo; }
	CHAR *GetFileName() { return m_szFileName; }
	CColList *GetNext() { return m_pNext; }
	void SetNext(CColList *p) { m_pNext = p; }
};

class CLASS_IMPORT_EXPORT CTitle SI_COUNT(CTitle)
{
private:
   CHAR * Id;                      // Title identifier
   WCHAR *pwcId;
   LANGID  Language;               // language identifier
   CTitle *NextTitle;              // pointer to the next title
public:
   LOCATIONHISTORY *m_pHead, *m_pTail;
   void SetId(const CHAR *);
   void SetId(const WCHAR *);
   void SetLanguage(LANGID);
   CHAR * GetId();
   const WCHAR * GetIdW();
   LANGID GetLanguage();
   LOCATIONHISTORY *GetLocation(DWORD Index);
   CTitle* GetNextTitle();
   ~CTitle();
   CTitle();
   LOCATIONHISTORY *NewLocationHistory();
   DWORD AddLocationHistory(DWORD ColNo, const CHAR *FileName, const CHAR *IndexFile, const CHAR *Query, const CLocation *pLocation, const CHAR *Sample, const CHAR *QueryLocation, BOOL bSupportsMerge);
   DWORD AddLocationHistory(DWORD ColNo, const WCHAR *FileName, const WCHAR *IndexFile, const WCHAR *Query, const CLocation *pLocation, const WCHAR *Sample, const WCHAR *QueryLocation, BOOL bSupportsMerge);
   void SetNextTitle(CTitle *p) { NextTitle = p; }
};

class CLASS_IMPORT_EXPORT CLocation SI_COUNT(CLocation)
{
private:
   CHAR * Id;
   CHAR * Title;                          // Friendly name for the title
   CHAR * Path;                           // location of the device
   CHAR * Volume;
   WCHAR * pwcId;
   WCHAR * pwcTitle;                          // Friendly name for the title
   WCHAR * pwcPath;                           // location of the device
   WCHAR * pwcVolume;
   CLocation *NextLocation;        // pointer to the next location if it exists
public:
   DWORD m_ColNum;
   CLocation()
   {
      Id = NULL;
      Title = NULL;
      Path = NULL;
      Volume = NULL;
      NextLocation = NULL;
        pwcId = NULL;
        pwcTitle = NULL;
        pwcPath = NULL;
        pwcVolume = NULL;
    }

   ~CLocation()
   {
      if (Id)
         delete Id;
      if (Title)
         delete Title;
      if (Path)
         delete Path;
      if (Volume)
         delete Volume;
      if (pwcId)
         delete pwcId;
      if (pwcTitle)
         delete pwcTitle;
      if (pwcPath)
         delete pwcPath;
      if (pwcVolume)
         delete pwcVolume;
   }

   void SetNextLocation(CLocation *p) { NextLocation = p; }
   void SetId(const CHAR *);
   void SetTitle(const CHAR *);
   void SetPath(const CHAR *);
   void SetVolume(const CHAR *);
   CHAR * GetId() const;
   CHAR * GetTitle();
   CHAR * GetPath();
   CHAR * GetVolume();
   void SetId(const WCHAR *);
   void SetTitle(const WCHAR *);
   void SetPath(const WCHAR *);
   void SetVolume(const WCHAR *);
   const WCHAR * GetIdW();
   const WCHAR * GetTitleW();
   const WCHAR * GetPathW();
   const WCHAR * GetVolumeW();

   // Returns the next location
   CLocation *GetNextLocation();
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\cab\i386\parser.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       parser.h
//
//--------------------------------------------------------------------------

//*********************************************************************************************************************************************
//
//      File: Parser.h
//  Author: Donald Drake
//  Purpose: Defines classes to support parsing tokens from a xml file

#ifndef _PARSER_H
#define _PARSER_H

#undef CLASS_IMPORT_EXPORT
#ifdef HHCTRL // define this only when building the HHCtrl DLL
  #define CLASS_IMPORT_EXPORT /**/
#else
 #ifdef HHSETUP // define this only when building the HHSetup DLL
  #define CLASS_IMPORT_EXPORT __declspec( dllexport )
 #else
  #define CLASS_IMPORT_EXPORT __declspec( dllimport )
 #endif
#endif

#define MAX_LINE_LEN 1024

#define F_OK 0
#define F_NOFILE 1
#define F_READ 2
#define F_WRITE 3
#define F_MEMORY 4
#define F_EOF 5
#define F_END 6
#define F_TAGMISSMATCH 7
#define F_MISSINGENDTAG 8
#define F_NOTFOUND 9
#define F_NOPARENT 10
#define F_NULL 11
#define F_NOTITLE 12
#define F_LOCATION 13
#define F_REFERENCED 14
#define F_DUPLICATE 15
#define F_DELETE 16
#define F_CLOSE 17
#define F_EXISTCHECK 19

class CParseXML {
private: // data

	TCHAR m_cCurToken[MAX_LINE_LEN];
	TCHAR m_cCurWord[MAX_LINE_LEN];
	TCHAR m_cCurBuffer[MAX_LINE_LEN];
	FILE *m_fh;
	TCHAR * m_pCurrentIndex;
	DWORD m_dwError;

private: // functions
	DWORD Read();
	DWORD SetError(DWORD dw) { m_dwError = dw; return m_dwError; }
public:

	CParseXML() {
		m_fh = NULL;
		m_cCurBuffer[0] = '\0';
		m_pCurrentIndex = NULL;
		m_dwError = F_OK;
	}

	~CParseXML() {
		End();
	}

	TCHAR * GetFirstWord(TCHAR *);
	TCHAR * GetValue(TCHAR *);

	DWORD Start(const TCHAR *szFile);
	void End();
	TCHAR *GetToken();
	DWORD GetError() { return m_dwError; }
};

// class to support a FIFO queue of strings
typedef struct  fifo {
	TCHAR *string;
	fifo *prev;
} FIFO;

class CLASS_IMPORT_EXPORT  CFIFOString {
private:

	FIFO *m_fifoTail;

public:

	CFIFOString() { m_fifoTail = NULL; }
	~CFIFOString();
	void RemoveAll();

	DWORD AddTail(TCHAR *sz);
	DWORD GetTail(TCHAR **sz);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\cpsyscolor.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cpsyscolor.h
//
//--------------------------------------------------------------------------


//////////////////////////////////////////////////////////////////////////////
// CProxy_SysColorEvents
template <class T>
class CProxy_SysColorEvents : public IConnectionPointImpl<T, &DIID__SysColorEvents, CComDynamicUnkArray>
{
public:
//methods:
//_SysColorEvents : IDispatch
public:
	void Fire_SysColorChange()
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\cic.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cic.cpp
//
//--------------------------------------------------------------------------

// cic.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f cicps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "cic.h"

#include "cic_i.c"
#include "MMCCtrl.h"
#include "MMCTask.h"
#include "MMClpi.h"
#include "ListPad.h"
#include "SysColorCtrl.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MMCCtrl,        CMMCCtrl)
    OBJECT_ENTRY(CLSID_MMCTask,        CMMCTask)
    OBJECT_ENTRY(CLSID_MMCListPadInfo, CMMCListPadInfo)
    OBJECT_ENTRY(CLSID_ListPad,        CListPad)
    OBJECT_ENTRY(CLSID_SysColorCtrl,   CSysColorCtrl)
END_OBJECT_MAP()

// cut from ndmgr_i.c (yuck) !!!
const IID IID_ITaskPadHost = {0x4f7606d0,0x5568,0x11d1,{0x9f,0xea,0x00,0x60,0x08,0x32,0xdb,0x4a}};


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\dispobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dispobj.h
//
//--------------------------------------------------------------------------

// MMCDisplayObject.h : Declaration of the CMMCDisplayObject

#ifndef __DISPOBJ_H_
#define __DISPOBJ_H_

#include "resource.h"       // main symbols
#include "mmc.h"

/////////////////////////////////////////////////////////////////////////////
// CMMCDisplayObject
class ATL_NO_VTABLE CMMCDisplayObject :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMMCDisplayObject, &CLSID_MMCDisplayObject>,
    public IDispatchImpl<IMMCDisplayObject, &IID_IMMCDisplayObject, &LIBID_CICLib>
{
public:
    CMMCDisplayObject();
   ~CMMCDisplayObject();

    HRESULT Init (MMC_TASK_DISPLAY_OBJECT * pdo);

    // Strange registration. Why does this class has MMCTask registration script here?
    // But this object is not in object-map, so ATL wont use this script.
    DECLARE_MMC_OBJECT_REGISTRATION(
		g_szCicDll,
        CLSID_MMCTask,
        _T("MMCTask class"),
        _T("MMCTask.MMCTask.1"),
        _T("MMCTask.MMCTask"))

DECLARE_NOT_AGGREGATABLE(CMMCDisplayObject)

BEGIN_COM_MAP(CMMCDisplayObject)
    COM_INTERFACE_ENTRY(IMMCDisplayObject)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMMCDisplayObject
public:
    STDMETHOD(get_DisplayObjectType)(long* pVal);
    STDMETHOD(get_FontFamilyName   )(BSTR* pVal);
    STDMETHOD(get_URLtoEOT         )(BSTR* pVal);
    STDMETHOD(get_SymbolString     )(BSTR* pVal);
    STDMETHOD(get_MouseOverBitmap  )(BSTR* pVal);
    STDMETHOD(get_MouseOffBitmap   )(BSTR* pVal);

private:
    long m_type;
    BSTR m_bstrFontFamilyName;
    BSTR m_bstrURLtoEOT;
    BSTR m_bstrSymbolString;
    BSTR m_bstrMouseOffBitmap;
    BSTR m_bstrMouseOverBitmap;

// Ensure that default copy constructor & assignment are not used.
    CMMCDisplayObject(const CMMCDisplayObject& rhs);
    CMMCDisplayObject& operator=(const CMMCDisplayObject& rhs);
};

#endif //__MMCTASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\dispobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dispobj.cpp
//
//--------------------------------------------------------------------------

// DispObj.cpp : Implementation of CMMCDisplayObject
#include "stdafx.h"
#include "cic.h"
#include "DispObj.h"
#include "mmc.h"
#include <wtypes.h>                             

/////////////////////////////////////////////////////////////////////////////
// CMMCDisplayObject
CMMCDisplayObject::CMMCDisplayObject()
{
    m_type = MMC_TASK_DISPLAY_UNINITIALIZED;

    m_bstrFontFamilyName  =
    m_bstrURLtoEOT        =
    m_bstrSymbolString    =
    m_bstrMouseOffBitmap  =
    m_bstrMouseOverBitmap = NULL;
}
CMMCDisplayObject::~CMMCDisplayObject()
{
    if (m_bstrFontFamilyName)   SysFreeString(m_bstrFontFamilyName);
    if (m_bstrURLtoEOT)         SysFreeString(m_bstrURLtoEOT);
    if (m_bstrSymbolString)     SysFreeString(m_bstrSymbolString);
    if (m_bstrMouseOffBitmap)   SysFreeString(m_bstrMouseOffBitmap);
    if (m_bstrMouseOverBitmap)  SysFreeString(m_bstrMouseOverBitmap);
}

STDMETHODIMP CMMCDisplayObject::get_DisplayObjectType(long* pVal)
{
    *pVal = m_type;
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_FontFamilyName (BSTR* pVal)
{
    if (m_bstrFontFamilyName)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrFontFamilyName);
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_URLtoEOT (BSTR* pVal)
{
    if (m_bstrURLtoEOT)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrURLtoEOT);
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_SymbolString (BSTR* pVal)
{
    if (m_bstrSymbolString)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrSymbolString);
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_MouseOffBitmap (BSTR* pVal)
{
    if (m_bstrMouseOffBitmap)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrMouseOffBitmap);
    return S_OK;
}

STDMETHODIMP CMMCDisplayObject::get_MouseOverBitmap (BSTR* pVal)
{
    if (m_bstrMouseOverBitmap)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrMouseOverBitmap);
    return S_OK;
}

HRESULT CMMCDisplayObject::Init(MMC_TASK_DISPLAY_OBJECT* pdo)
{
   _ASSERT (m_type == MMC_TASK_DISPLAY_UNINITIALIZED);
    if (m_type != MMC_TASK_DISPLAY_UNINITIALIZED)
        return E_UNEXPECTED;    // only allowed in here once

    switch (m_type = pdo->eDisplayType) {
    default:
    case MMC_TASK_DISPLAY_UNINITIALIZED:
//     _ASSERT (0 && "uninitialized MMC_TASK_DISPLAY_OBJECT struct");
        return E_INVALIDARG;
    case MMC_TASK_DISPLAY_TYPE_SYMBOL:           // fontname, EOT, symbols
        // all three fields MUST be filled out
       _ASSERT (pdo->uSymbol.szFontFamilyName && pdo->uSymbol.szURLtoEOT && pdo->uSymbol.szSymbolString);
        if (!(pdo->uSymbol.szFontFamilyName && pdo->uSymbol.szURLtoEOT && pdo->uSymbol.szSymbolString))
            return E_INVALIDARG;

        m_bstrFontFamilyName = SysAllocString (pdo->uSymbol.szFontFamilyName);
        m_bstrURLtoEOT       = SysAllocString (pdo->uSymbol.szURLtoEOT);
        m_bstrSymbolString   = SysAllocString (pdo->uSymbol.szSymbolString);
        if (m_bstrFontFamilyName && m_bstrURLtoEOT && m_bstrSymbolString)
            return S_OK;
        return E_OUTOFMEMORY;
        break;
    case MMC_TASK_DISPLAY_TYPE_VANILLA_GIF:      // (GIF) index 0 is transparent
    case MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF:    // (GIF) index 1 is transparent
    case MMC_TASK_DISPLAY_TYPE_BITMAP:           // non-transparent raster
        if ( pdo->uBitmap.szMouseOffBitmap  &&
             pdo->uBitmap.szMouseOverBitmap ){
            // if they both exist, like they're supposed to
            m_bstrMouseOffBitmap  = SysAllocString (pdo->uBitmap.szMouseOffBitmap);
            m_bstrMouseOverBitmap = SysAllocString (pdo->uBitmap.szMouseOverBitmap);
        } else if (pdo->uBitmap.szMouseOverBitmap) {
            // if only MouseOver image exists:
            // not too bad since it's probably color
            m_bstrMouseOffBitmap  = SysAllocString (pdo->uBitmap.szMouseOverBitmap);
            m_bstrMouseOverBitmap = SysAllocString (pdo->uBitmap.szMouseOverBitmap);
        } else if (pdo->uBitmap.szMouseOffBitmap) {
            // if only MouseOff image exists:
            // they're being bad, but not too bad
            m_bstrMouseOffBitmap  = SysAllocString (pdo->uBitmap.szMouseOffBitmap);
            m_bstrMouseOverBitmap = SysAllocString (pdo->uBitmap.szMouseOffBitmap);
        } else {
            // else they're really bad
            _ASSERT (0 && "MMC_TASK_DISPLAY_BITMAP uninitialized");
            return E_INVALIDARG;
        }
        if (m_bstrMouseOffBitmap && m_bstrMouseOverBitmap)
            return S_OK;
        return E_OUTOFMEMORY;
        break;
    }
    return E_UNEXPECTED;    // can't get here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\listpad.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       listpad.cpp
//
//--------------------------------------------------------------------------

// ListPad.cpp : Implementation of CListPad
#include "stdafx.h"
#include "cic.h"
#include "ListPad.h"
#include "findview.h"
#include "strings.h"

/////////////////////////////////////////////////////////////////////////////
// CListPad

HRESULT CListPad::OnPostVerbInPlaceActivate()
{
    // set up the window hierarchy
    if (m_MMChWnd == NULL)
    {
        // walk the parent windows until we hit one we recognize
        HWND hwnd = FindMMCView(m_hWnd);

        // found it!
        if (hwnd)
        {
            // hang onto this to prevent reconnections
            m_MMChWnd = hwnd;
            m_ListViewHWND = NULL;

            // send a message to pull the old switcheroo
            ::SendMessage (m_MMChWnd, MMC_MSG_CONNECT_TO_TPLV, (WPARAM)m_hWnd, (LPARAM)&m_ListViewHWND);
        }
    }

    // when navigating back to a listpad using history, need to reconnect the  listpad. The test for this
    // is that both windows already exist and the parent of the list view is the amcview, indicating that the
    // connection has not yet taken place
    if(m_MMChWnd && m_ListViewHWND && (::GetParent(m_ListViewHWND)==m_MMChWnd) ) 
    {
        // send a message to pull the old switcheroo
        ::SendMessage (m_MMChWnd, MMC_MSG_CONNECT_TO_TPLV, (WPARAM)m_hWnd, (LPARAM)&m_ListViewHWND);
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\mmcctrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcctrl.cpp
//
//--------------------------------------------------------------------------

// MMCCtrl.cpp : Implementation of CMMCCtrl
#include "stdafx.h"
#include "cic.h"
#include "MMCCtrl.h"
#include "MMCTask.h"
#include "DispObj.h"
#include "MMClpi.h"
#include "amcmsgid.h"
#include "findview.h"
#include "strings.h"


void CMMCCtrl::DoConnect ()
{
    // if we're not connected...
    if (m_spTaskPadHost == NULL) {
        HWND hwnd = FindMMCView(*dynamic_cast<CComControlBase*>(this));
        if (hwnd)
            Connect (hwnd);
    }
}

void CMMCCtrl::Connect (HWND wndCurrent)
{
    HWND hwndView = FindMMCView(wndCurrent);

    if (hwndView)
    {
        // get the control's IUnknown 
        IUnknownPtr spunk;
        ControlQueryInterface (IID_IUnknown, (void **)&spunk);
        if (spunk != NULL)
        {
            IUnknownPtr spunkMMC;
            ::SendMessage (hwndView, MMC_MSG_CONNECT_TO_CIC, (WPARAM)&spunkMMC, (LPARAM)(spunk.GetInterfacePtr()));
            if (spunkMMC != NULL)
                m_spTaskPadHost = spunkMMC;
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CMMCCtrl


HRESULT CMMCCtrl::OnDraw(ATL_DRAWINFO& di)
{
    if (m_spTaskPadHost == NULL) {
        // get window from di and find console window
        HWND wndCurrent = WindowFromDC (di.hdcDraw);
        if (wndCurrent)
            Connect (wndCurrent);
    }
    return S_OK;
}


HRESULT CMMCCtrl::OnDrawAdvanced(ATL_DRAWINFO & di)
{
    return OnDraw (di);
}

STDMETHODIMP CMMCCtrl::TaskNotify(BSTR szClsid, VARIANT * pvArg, VARIANT * pvParam)
{
    DoConnect();    // connect, if not already connected
    if(m_spTaskPadHost != NULL)
        return m_spTaskPadHost->TaskNotify (szClsid, pvArg, pvParam);
    return E_FAIL;
}

STDMETHODIMP CMMCCtrl::GetFirstTask(BSTR szTaskGroup, IDispatch** retval)
{  // called by script, when it wants buttons, etc.

    // validate parameters
    _ASSERT (retval);
    _ASSERT (!IsBadWritePtr(retval, sizeof(IDispatch*)));
    // TODO:  how do I validate a BSTR?

    if (retval == NULL || IsBadWritePtr(retval, sizeof(IDispatch*)))
        return E_INVALIDARG;
    
    // should be initialized to this already (see note below)
    *retval = NULL;

    DoConnect();    // connect, if not already connected
    if (m_spTaskPadHost == NULL)    // from note above:
        return S_OK;        // any error, pops up ugly script message box....

    // "reset":  if we have an old enumerator, blitz it.
    if (m_spEnumTASK != NULL)
        m_spEnumTASK = NULL;

    // get new enumerator
    m_spTaskPadHost->GetTaskEnumerator (szTaskGroup, &m_spEnumTASK);
    if(m_spEnumTASK != NULL)
        return GetNextTask (retval);
    return S_OK;
}

STDMETHODIMP CMMCCtrl::GetNextTask(IDispatch** retval)
{
    // validate parameters
    _ASSERT (retval);
    _ASSERT (!IsBadWritePtr(retval, sizeof(IDispatch*)));

    if (retval == NULL || IsBadWritePtr(retval, sizeof(IDispatch*)))
        return E_INVALIDARG;
    
    if (m_spEnumTASK == NULL)
        return S_OK;    // all outa enumerators

    MMC_ITASK task;
    ZeroMemory (&task, sizeof(MMC_ITASK));
    HRESULT hresult = m_spEnumTASK->Next (1, (MMC_TASK *)&task, NULL);

    if (hresult != S_OK) {
        // out of tasks (and enumerators):  no need to hang onto this any more.
        m_spEnumTASK = NULL;
        return S_OK;
    }  else {
        // convert MMC_ITASK to ITask object
        CComObject<class CMMCTask>* ctask = NULL;
        hresult = CComObject<CMMCTask>::CreateInstance(&ctask);
        if (ctask) {

            ctask->SetText (task.task.szText);
            ctask->SetHelp (task.task.szHelpString);
            ctask->SetClsid(task.szClsid);

            hresult = ctask->SetDisplayObject (&task.task.sDisplayObject);
            if (hresult == S_OK) {
                switch (task.task.eActionType) {
                case MMC_ACTION_ID:
                    hresult = ctask->SetCommandID (task.task.nCommandID);
                    break;
                case MMC_ACTION_LINK:
                    hresult = ctask->SetActionURL (task.task.szActionURL);
                    break;
                case MMC_ACTION_SCRIPT:
                    hresult = ctask->SetScript (task.task.szScript);
                    break;
                default:
                    _ASSERT (FALSE);  // bad task
                    hresult = E_UNEXPECTED;
                    break;
                }
            }

            if (SUCCEEDED(hresult)) 
                ctask->QueryInterface (IID_IDispatch, (void **)retval);
            else 
                delete ctask;
        }
    }

    FreeDisplayData (&task.task.sDisplayObject);
    if (task.task.szText)            CoTaskMemFree (task.task.szText);
    if (task.task.szHelpString)      CoTaskMemFree (task.task.szHelpString);
    if (task.szClsid)                CoTaskMemFree (task.szClsid);
    if (task.task.eActionType != MMC_ACTION_ID)
        if (task.task.szScript)
            CoTaskMemFree (task.task.szScript);

    return S_OK;
}

STDMETHODIMP CMMCCtrl::GetTitle(BSTR szTaskGroup, BSTR * retval)
{
    DoConnect();    // connect, if not already connected
    if (m_spTaskPadHost)
        m_spTaskPadHost->GetTitle (szTaskGroup, retval);
    return S_OK;
}

STDMETHODIMP CMMCCtrl::GetDescriptiveText(BSTR szTaskGroup, BSTR * retval)
{
    DoConnect();    // connect, if not already connected
    if (m_spTaskPadHost)
        m_spTaskPadHost->GetDescriptiveText (szTaskGroup, retval);
    return S_OK;
}

STDMETHODIMP CMMCCtrl::GetBackground(BSTR szTaskGroup, IDispatch** retval)
{
    DoConnect();    // connect, if not already connected
    *retval = NULL;
    if (m_spTaskPadHost) {

        MMC_TASK_DISPLAY_OBJECT tdo;
        ZeroMemory (&tdo, sizeof(tdo));

        // pass struct to host (which will pass to snapin)
        m_spTaskPadHost->GetBackground (szTaskGroup, &tdo);

        // convert struct to IDispatch object
        CComObject<class CMMCDisplayObject>* cdo = NULL;
        CComObject<CMMCDisplayObject>::CreateInstance(&cdo);
        if (cdo) {
            cdo->Init (&tdo);
            IDispatchPtr spIDispatch = cdo;
            if (*retval = spIDispatch)
                spIDispatch.Detach();
        }
        FreeDisplayData (&tdo);
    }
    return S_OK;
}
/*
STDMETHODIMP CMMCCtrl::GetBranding(BSTR szTaskGroup, IDispatch** retval)
{
    DoConnect();    // connect, if not already connected
    *retval = NULL;
    if (m_spTaskPadHost) {

        MMC_TASK_DISPLAY_OBJECT tdo;
        ZeroMemory (&tdo, sizeof(tdo));

        // pass struct to host (which will pass to snapin)
        m_spTaskPadHost->GetBranding (szTaskGroup, &tdo);

        // convert struct to IDispatch object
        CComObject<class CMMCDisplayObject>* cdo = NULL;
        CComObject<CMMCDisplayObject>::CreateInstance(&cdo);
        if (cdo) {
            cdo->AddRef();
            cdo->Init (&tdo);
            cdo->QueryInterface (IID_IDispatch, (void **)retval);
            cdo->Release();
        }
        FreeDisplayData (&tdo);
    }
    return S_OK;
}
*/
STDMETHODIMP CMMCCtrl::GetListPadInfo (BSTR szGroup, IDispatch** retval)
{
    *retval = NULL;
    DoConnect();    // connect, if not already connected
    if (m_spTaskPadHost == NULL)
        return S_OK;

    MMC_ILISTPAD_INFO ilpi;
    ZeroMemory (&ilpi, sizeof(MMC_ILISTPAD_INFO));
    m_spTaskPadHost->GetListPadInfo (szGroup, &ilpi);

    // convert struct to IDispatch
    CComObject<class CMMCListPadInfo>* clpi = NULL;
    HRESULT hr = CComObject<CMMCListPadInfo>::CreateInstance(&clpi);
    if (clpi) {
        // always set clsid, title, button text, even if NULL or empty strings
        if (ilpi.szClsid)
            hr = clpi->SetClsid (ilpi.szClsid);
        if (hr == S_OK && ilpi.info.szTitle)
            hr = clpi->SetTitle (ilpi.info.szTitle);
        if (hr == S_OK)
            hr = clpi->SetNotifyID (ilpi.info.nCommandID);
        if (hr == S_OK && ilpi.info.szButtonText)
            hr = clpi->SetText (ilpi.info.szButtonText);

        // NULL  button text => no button
        // empty button text => button without any text
        if (hr == S_OK)
            hr = clpi->SetHasButton (ilpi.info.szButtonText != NULL);

        if (SUCCEEDED(hr)) 
            clpi->QueryInterface (IID_IDispatch, (void **)retval);
        else 
            delete clpi;
    }

    // free resources
    if (ilpi.szClsid)           CoTaskMemFree (ilpi.szClsid);
    if (ilpi.info.szTitle)      CoTaskMemFree (ilpi.info.szTitle);
    if (ilpi.info.szButtonText) CoTaskMemFree (ilpi.info.szButtonText);
    return S_OK;
}

void CMMCCtrl::FreeDisplayData (MMC_TASK_DISPLAY_OBJECT* pdo)
{
    switch (pdo->eDisplayType) {
    default:
        break;
    case MMC_TASK_DISPLAY_TYPE_SYMBOL:
        if (pdo->uSymbol.szFontFamilyName)  CoTaskMemFree (pdo->uSymbol.szFontFamilyName);
        if (pdo->uSymbol.szURLtoEOT)        CoTaskMemFree (pdo->uSymbol.szURLtoEOT);
        if (pdo->uSymbol.szSymbolString)    CoTaskMemFree (pdo->uSymbol.szSymbolString);
        break;
    case MMC_TASK_DISPLAY_TYPE_BITMAP:
    case MMC_TASK_DISPLAY_TYPE_VANILLA_GIF:
    case MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF:
        if (pdo->uBitmap.szMouseOverBitmap) CoTaskMemFree (pdo->uBitmap.szMouseOverBitmap);
        if (pdo->uBitmap.szMouseOffBitmap)  CoTaskMemFree (pdo->uBitmap.szMouseOffBitmap);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\mmctask.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmctask.h
//
//--------------------------------------------------------------------------

// MMCTask.h : Declaration of the CMMCTask

#ifndef __MMCTASK_H_
#define __MMCTASK_H_

#include "resource.h"       // main symbols
#include "mmc.h"
#include <ndmgr.h>

/////////////////////////////////////////////////////////////////////////////
// CMMCTask
class ATL_NO_VTABLE CMMCTask :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMMCTask, &CLSID_MMCTask>,
    public IDispatchImpl<IMMCTask, &IID_IMMCTask, &LIBID_CICLib>
{
public:
    CMMCTask();
    ~CMMCTask();

    HRESULT SetScript        (LPOLESTR szScript);
    HRESULT SetActionURL     (LPOLESTR szActionURL);
    HRESULT SetCommandID     (LONG_PTR nID);
    HRESULT SetActionType    (long nType);
    HRESULT SetHelp          (LPOLESTR szHelp);
    HRESULT SetText          (LPOLESTR szText);
    HRESULT SetClsid         (LPOLESTR szClsid);
    HRESULT SetDisplayObject (MMC_TASK_DISPLAY_OBJECT* pdo);

    DECLARE_MMC_OBJECT_REGISTRATION(
		g_szCicDll,
        CLSID_MMCTask,
        _T("MMCTask class"),
        _T("MMCTask.MMCTask.1"),
        _T("MMCTask.MMCTask"))

DECLARE_NOT_AGGREGATABLE(CMMCTask)

BEGIN_COM_MAP(CMMCTask)
    COM_INTERFACE_ENTRY(IMMCTask)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMMCTask
public:
    STDMETHOD(get_Clsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Script)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ActionURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_CommandID)(/*[out, retval]*/ LONG_PTR *pVal);
    STDMETHOD(get_ActionType)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Help)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Text)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ScriptLanguage)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DisplayObject)(/*[out, retval]*/ IDispatch** pDispatch);

private:
    void FreeActions ();

private:
    BSTR m_bstrLanguage;
    BSTR m_bstrScript;
    BSTR m_bstrActionURL;
    BSTR m_bstrHelp;
    BSTR m_bstrText;
    BSTR m_bstrClsid;
    long m_type;
    LONG_PTR m_ID;
    IDispatchPtr m_spDisplayObject;

// Ensure that default copy constructor & assignment are not used.
    CMMCTask(const CMMCTask& rhs);
    CMMCTask& operator=(const CMMCTask& rhs);
};

#endif //__MMCTASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cic.rc
//
#define IDS_PROJNAME                    100
#define IDS_CONNECT_MSG                 101
#define IDR_NAVCTRL                     107

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\mmclpi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmclpi.h
//
//--------------------------------------------------------------------------

// MMCListPad.h : Declaration of the CMMCListPad

#ifndef __MMCLPI_H_
#define __MMCLPI_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMMCListPad
class ATL_NO_VTABLE CMMCListPadInfo :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMMCListPadInfo, &CLSID_MMCListPadInfo>,
    public IDispatchImpl<IMMCListPadInfo, &IID_IMMCListPadInfo, &LIBID_CICLib>
{
public:
    CMMCListPadInfo();
   ~CMMCListPadInfo();

   DECLARE_MMC_OBJECT_REGISTRATION(
	   g_szCicDll,
       CLSID_MMCListPadInfo,
       _T("MMCListPadInfo class"),
       _T("MMCListPadInfo.MMCListPadInfo.1"),
       _T("MMCListPadInfo.MMCListPadInfo"))

DECLARE_NOT_AGGREGATABLE(CMMCListPadInfo)

BEGIN_COM_MAP(CMMCListPadInfo)
    COM_INTERFACE_ENTRY(IMMCListPadInfo)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMMCListPadInfo
public:
    STDMETHOD(get_Title    )(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(get_Text     )(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(get_NotifyID )(/*[out, retval]*/ LONG_PTR* pVal);
    STDMETHOD(get_Clsid    )(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(get_HasButton)(/*[out, retval]*/ BOOL* pVal);

public:
    HRESULT SetTitle    (LPOLESTR szTitle);
    HRESULT SetText     (LPOLESTR szText);
    HRESULT SetClsid    (LPOLESTR szClsid);
    HRESULT SetNotifyID (LONG_PTR lID);
    HRESULT SetHasButton(BOOL b);

private:
    BSTR m_bstrTitle;
    BSTR m_bstrText;
    BSTR m_bstrClsid;
    LONG_PTR m_lNotifyID;
    BOOL m_bHasButton;

// Ensure that default copy constructor & assignment are not used.
    CMMCListPadInfo(const CMMCListPadInfo& rhs);
    CMMCListPadInfo& operator=(const CMMCListPadInfo& rhs);
};

#endif //__MMCLPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\mmctask.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmctask.cpp
//
//--------------------------------------------------------------------------

// MMCTask.cpp : Implementation of CMMCTask
#include "stdafx.h"
#include "cic.h"
#include "MMCTask.h"
#include "DispObj.h"
#include "mmc.h"
#include <wtypes.h>                             

/////////////////////////////////////////////////////////////////////////////
// CMMCTask
CMMCTask::CMMCTask()
{
    m_ID              = 0;
    m_bstrClsid       = m_bstrScript    = m_bstrLanguage  =
    m_bstrActionURL   = m_bstrHelp      = m_bstrText      = NULL;
    m_type            = MMC_ACTION_UNINITIALIZED;
}
CMMCTask::~CMMCTask()
{
    if (m_bstrScript)         SysFreeString(m_bstrScript);
    if (m_bstrActionURL)      SysFreeString(m_bstrActionURL);
    if (m_bstrHelp)           SysFreeString(m_bstrHelp);
    if (m_bstrText)           SysFreeString(m_bstrText);
    if (m_bstrClsid)          SysFreeString(m_bstrClsid);
}

STDMETHODIMP CMMCTask::get_DisplayObject (IDispatch** pDispatch)
{
    IDispatchPtr spDispatch = m_spDisplayObject;
    *pDispatch = spDispatch.Detach();
    return S_OK;
}

HRESULT CMMCTask::SetDisplayObject (MMC_TASK_DISPLAY_OBJECT* pdo)
{
    HRESULT hr = S_OK;
    CComObject<class CMMCDisplayObject>* cdo = NULL;
    CComObject<CMMCDisplayObject>::CreateInstance(&cdo);
    if (!cdo)
        hr = E_OUTOFMEMORY;
    else {
        hr = cdo->Init (pdo);
        m_spDisplayObject = cdo;
    }
    return hr;
}

STDMETHODIMP CMMCTask::get_Text(BSTR * pVal)
{
    if (m_bstrText)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrText);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_Help(BSTR * pVal)
{
    if (m_bstrHelp)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrHelp);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_ActionType(long * pVal)
{
    *pVal = m_type;
    return S_OK;
}

STDMETHODIMP CMMCTask::get_CommandID(LONG_PTR * pVal)
{
    _ASSERT (m_type == MMC_ACTION_ID);
    if (m_type != MMC_ACTION_ID)
        return E_UNEXPECTED;
    *pVal = m_ID;
    return S_OK;
}

STDMETHODIMP CMMCTask::get_ActionURL(BSTR * pVal)
{
    _ASSERT (m_type == MMC_ACTION_LINK);
    if (m_type != MMC_ACTION_LINK)
        return E_UNEXPECTED;
    if (m_bstrActionURL)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrActionURL);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_Clsid(BSTR * pVal)
{
    if (m_bstrClsid)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrClsid);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_Script(BSTR * pVal)
{
    _ASSERT (m_type == MMC_ACTION_SCRIPT);
    if (m_type != MMC_ACTION_SCRIPT)
        return E_UNEXPECTED;
    if (m_bstrScript)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrScript);
    return S_OK;
}

STDMETHODIMP CMMCTask::get_ScriptLanguage(BSTR *pVal)
{
    _ASSERT (m_type == MMC_ACTION_SCRIPT);
    if (m_type != MMC_ACTION_SCRIPT)
        return E_UNEXPECTED;
    if (m_bstrLanguage)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrLanguage);
    return S_OK;
}

int lstrncmpi (OLECHAR * first, OLECHAR * second, long ncount)
{
    for (long i=0; i<ncount; i++) {
        if (towupper (first[i]) != towupper(second[i]))
            if (towupper (first[i]) > towupper(second[i]))
                return 1;
            else
                return -1;
    }
    return 0;
}
HRESULT CMMCTask::SetScript (LPOLESTR szScript)
{
    FreeActions ();

    // look for "VBSCRIPT:", "JSCRIPT:" and "JAVASCRIPT:"
    if (!lstrncmpi (L"VBSCRIPT:", szScript, 9)) {
        m_bstrLanguage = SysAllocString (L"VBSCRIPT");
        szScript += 9;
    } else
    if (!lstrncmpi (L"JSCRIPT:", szScript, 8)) {
        m_bstrLanguage = SysAllocString (L"JSCRIPT");
        szScript += 8;
    } else
    if (!lstrncmpi (L"JAVASCRIPT:", szScript, 11)) {
        m_bstrLanguage = SysAllocString (L"JAVASCRIPT");
        szScript += 11;
    } else {
        m_bstrLanguage = SysAllocString (L"JAVASCRIPT");
    }
    if (!m_bstrLanguage)
        return E_OUTOFMEMORY;

    m_bstrScript = SysAllocString (szScript);
    if (m_bstrScript == NULL)
        return E_OUTOFMEMORY;
    m_type = MMC_ACTION_SCRIPT;
    return S_OK;
}
HRESULT CMMCTask::SetActionURL (LPOLESTR szActionURL)
{
    FreeActions ();
    m_bstrActionURL = SysAllocString (szActionURL);
    if (m_bstrActionURL == NULL)
        return E_OUTOFMEMORY;
    m_type = MMC_ACTION_LINK;
    return S_OK;
}

HRESULT CMMCTask::SetCommandID (LONG_PTR nID)
{
    FreeActions ();
    m_ID   = nID;
    m_type = MMC_ACTION_ID;
    return S_OK;
}
HRESULT CMMCTask::SetActionType(long nType)
{
    m_type = nType;
    return S_OK;
}
HRESULT CMMCTask::SetHelp (LPOLESTR szHelp)
{
    if (m_bstrHelp)  SysFreeString (m_bstrHelp);
    m_bstrHelp = SysAllocString (szHelp);
    if (!m_bstrHelp)
        return E_OUTOFMEMORY;
    return S_OK;
}
HRESULT CMMCTask::SetText (LPOLESTR szText)
{
    if (m_bstrText)  SysFreeString (m_bstrText);
    m_bstrText = SysAllocString (szText);
    if (!m_bstrText)
        return E_OUTOFMEMORY;
    return S_OK;
}

HRESULT CMMCTask::SetClsid(LPOLESTR szClsid)
{
    if (m_bstrClsid)  SysFreeString (m_bstrClsid);
    m_bstrClsid = SysAllocString (szClsid);
    if (!m_bstrClsid)
        return E_OUTOFMEMORY;
    return S_OK;
}

void CMMCTask::FreeActions ()
{
    if (m_bstrLanguage) {
        SysFreeString (m_bstrLanguage);
        m_bstrLanguage = NULL;
    }
    if (m_bstrScript) {
        SysFreeString(m_bstrScript);
        m_bstrScript = NULL;
    }
    if (m_bstrActionURL) {
        SysFreeString(m_bstrActionURL);
        m_bstrActionURL = NULL;
    }
    m_ID = 0;
    m_type = MMC_ACTION_UNINITIALIZED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\mmclpi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmclpi.cpp
//
//--------------------------------------------------------------------------

// MMCTask.cpp : Implementation of CMMCTask
#include "stdafx.h"
#include "cic.h"
#include "MMClpi.h"

/////////////////////////////////////////////////////////////////////////////
// CMMCListPad
CMMCListPadInfo::CMMCListPadInfo()
{
    m_bstrTitle  =
    m_bstrClsid  =
    m_bstrText   = NULL;
    m_lNotifyID  = 0;
    m_bHasButton = FALSE;
}
CMMCListPadInfo::~CMMCListPadInfo()
{
    if (m_bstrTitle)    SysFreeString (m_bstrTitle);
    if (m_bstrText)     SysFreeString (m_bstrText);
    if (m_bstrClsid)    SysFreeString (m_bstrClsid);
}

STDMETHODIMP CMMCListPadInfo::get_Title(BSTR * pVal)
{
    if (m_bstrTitle)
        *pVal = SysAllocString ((OLECHAR *)m_bstrTitle);
    return S_OK;
}

STDMETHODIMP CMMCListPadInfo::get_Text(BSTR * pVal)
{
    if (m_bstrText)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrText);
    return S_OK;
}

STDMETHODIMP CMMCListPadInfo::get_NotifyID(LONG_PTR * pVal)
{
    *pVal = m_lNotifyID;
    return S_OK;
}

STDMETHODIMP CMMCListPadInfo::get_Clsid(BSTR * pVal)
{
    if (m_bstrClsid)
        *pVal = SysAllocString ((const OLECHAR *)m_bstrClsid);
    return S_OK;
}

STDMETHODIMP CMMCListPadInfo::get_HasButton(BOOL* pVal)
{
    *pVal = m_bHasButton;
    return S_OK;
}

HRESULT CMMCListPadInfo::SetNotifyID(LONG_PTR nID)
{
    m_lNotifyID = nID;
    return S_OK;
}
HRESULT CMMCListPadInfo::SetTitle (LPOLESTR szTitle)
{
    if (m_bstrTitle)  SysFreeString (m_bstrTitle);
    m_bstrTitle = SysAllocString (szTitle);
    if (!m_bstrTitle)
        return E_OUTOFMEMORY;
    return S_OK;
}
HRESULT CMMCListPadInfo::SetText (LPOLESTR szText)
{
    if (m_bstrText)  SysFreeString (m_bstrText);
    m_bstrText = SysAllocString (szText);
    if (!m_bstrText)
        return E_OUTOFMEMORY;
    return S_OK;
}
HRESULT CMMCListPadInfo::SetClsid(LPOLESTR szClsid)
{
    if (m_bstrClsid)  SysFreeString (m_bstrClsid);
    m_bstrClsid = SysAllocString (szClsid);
    if (!m_bstrClsid)
        return E_OUTOFMEMORY;
    return S_OK;
}

HRESULT CMMCListPadInfo::SetHasButton (BOOL b)
{
    m_bHasButton = b;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\mmcctrl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcctrl.h
//
//--------------------------------------------------------------------------

// MMCCtrl.h : Declaration of the CMMCCtrl

#ifndef __MMCCTRL_H_
#define __MMCCTRL_H_

#include "resource.h"       // main symbols
#include "commctrl.h"       // to prevent LVITEMW redefinition in ndmgr.h
#include <ndmgr.h>

/////////////////////////////////////////////////////////////////////////////
// CMMCCtrl
class ATL_NO_VTABLE CMMCCtrl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMMCCtrl, &CLSID_MMCCtrl>,
    public CComControl<CMMCCtrl>,
    public IDispatchImpl<IMMCCtrl, &IID_IMMCCtrl, &LIBID_CICLib>,
    public IProvideClassInfo2Impl<&CLSID_MMCCtrl, &IID_IMMCCtrlEvent, &LIBID_CICLib>,
    public IPersistStreamInitImpl<CMMCCtrl>,
    public IPersistStorageImpl<CMMCCtrl>,
    public IQuickActivateImpl<CMMCCtrl>,
    public IOleControlImpl<CMMCCtrl>,
    public IOleObjectImpl<CMMCCtrl>,
    public IOleInPlaceActiveObjectImpl<CMMCCtrl>,
    public IObjectSafetyImpl<CMMCCtrl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IViewObjectExImpl<CMMCCtrl>,
    public IOleInPlaceObjectWindowlessImpl<CMMCCtrl>,
    public IDataObjectImpl<CMMCCtrl>,
    public ISpecifyPropertyPagesImpl<CMMCCtrl>,
    public IConnectionPointContainerImpl<CMMCCtrl>,
    public IConnectionPointImpl<CMMCCtrl, &IID_IMMCCtrlEvent>
{
public:
    CMMCCtrl()
    {
    }

    ~CMMCCtrl()
    {
    }

    DECLARE_MMC_CONTROL_REGISTRATION(
		g_szCicDll,
        CLSID_MMCCtrl,
        _T("MMCCtrl class"),
        _T("MMCCtrl.MMCCtrl.1"),
        _T("MMCCtrl.MMCCtrl"),
        LIBID_CICLib,
        _T("1"),
        _T("1.0"))

DECLARE_NOT_AGGREGATABLE(CMMCCtrl)

BEGIN_COM_MAP(CMMCCtrl)
    COM_INTERFACE_ENTRY(IMMCCtrl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CMMCCtrl)
    CONNECTION_POINT_ENTRY(IID_IMMCCtrlEvent)
END_CONNECTION_POINT_MAP()

BEGIN_PROPERTY_MAP(CMMCCtrl)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CMMCCtrl)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()

    STDMETHOD(TranslateAccelerator)(MSG *pMsg)
    {
        CComQIPtr<IOleControlSite,&IID_IOleControlSite> spCtrlSite (m_spClientSite);
        if(spCtrlSite)
            return spCtrlSite->TranslateAccelerator (pMsg,0);
        return S_FALSE;
    }

// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }
   STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
   {
#ifdef DIDNT_WORK_TOO_WELL
      static BOOL b = FALSE;
      if (b == TRUE) {
         b = FALSE;
         psizel->cx = psizel->cy = 121;
      } else {
         b = TRUE;
         psizel->cx = psizel->cy = 120;
      }
#else
      psizel->cx = psizel->cy = 250;
#endif
        return S_OK;
    }

// IMMCCtrl
public:
    STDMETHOD(GetBackground     )(BSTR szTaskGroup, IDispatch** retval);
//  STDMETHOD(GetBranding       )(BSTR szTaskGroup, IDispatch** retval);
    STDMETHOD(GetTitle          )(BSTR szTaskGroup, BSTR * retval);
    STDMETHOD(GetDescriptiveText)(BSTR szTaskGroup, BSTR * retval);
    STDMETHOD(GetFirstTask      )(BSTR szTaskGroup, IDispatch** retval);
    STDMETHOD(GetNextTask       )(IDispatch** retval);
    STDMETHOD(GetListPadInfo    )(BSTR szGroup, IDispatch** retval);
    STDMETHOD(TaskNotify        )(BSTR szClsid, VARIANT * pvArg, VARIANT * pvParam);

    HRESULT OnDraw(ATL_DRAWINFO& di);
    HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);

private: // helpers
   void Connect (HWND wndCurrent);
   void DoConnect ();
   void FreeDisplayData (MMC_TASK_DISPLAY_OBJECT* pdo);

private:
   ITaskPadHostPtr m_spTaskPadHost;
   IEnumTASKPtr    m_spEnumTASK;
};

#endif //__MMCCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\listpad.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       listpad.h
//
//--------------------------------------------------------------------------

// ListPad.h : Declaration of the CListPad

#ifndef __LISTPAD_H_
#define __LISTPAD_H_

#include "resource.h"       // main symbols
#include "amcmsgid.h"
#include "commctrl.h"


/////////////////////////////////////////////////////////////////////////////
// CListPad
class ATL_NO_VTABLE CListPad :
public CComObjectRootEx<CComSingleThreadModel>,
public CComCoClass<CListPad, &CLSID_ListPad>,
public CComControl<CListPad>,
public IDispatchImpl<IListPad, &IID_IListPad, &LIBID_CICLib>,
public IProvideClassInfo2Impl<&CLSID_ListPad, NULL, &LIBID_CICLib>,
public IPersistStreamInitImpl<CListPad>,
public IPersistStorageImpl<CListPad>,
public IQuickActivateImpl<CListPad>,
public IOleControlImpl<CListPad>,
public IOleObjectImpl<CListPad>,
public IOleInPlaceActiveObjectImpl<CListPad>,
public IObjectSafetyImpl<CListPad, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
public IViewObjectExImpl<CListPad>,
public IOleInPlaceObjectWindowlessImpl<CListPad>,
public IDataObjectImpl<CListPad>,
public ISpecifyPropertyPagesImpl<CListPad>
{
public:
    CListPad()
    {
        m_MMChWnd = m_ListViewHWND = NULL;
        m_bWindowOnly = TRUE;
    }
    ~CListPad()
    {
        if (m_MMChWnd)
            ::SendMessage (m_MMChWnd, MMC_MSG_CONNECT_TO_TPLV, (WPARAM)m_MMChWnd, (LPARAM)NULL);
    }

    /*+-------------------------------------------------------------------------*
     *
     * GetWndClassInfo
     *
     * PURPOSE: Need to override this to remove the CS_HREDRAW and CS_VREDRAW
     *          styles, which were causing lots of flicker. See the SDK
     *          docs under GetWndClassInfo for more details.
     *
     * RETURNS: 
     *    static CWndClassInfo&
     *
     *+-------------------------------------------------------------------------*/
    static CWndClassInfo& GetWndClassInfo() 
    { 
    	static CWndClassInfo wc = 
    	{ 
    		{ sizeof(WNDCLASSEX), CS_DBLCLKS, StartWindowProc, 
    		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, NULL, NULL }, 
    		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
    	}; 
    	return wc; 
    }


    DECLARE_MMC_CONTROL_REGISTRATION(
                                    g_szCicDll,
                                    CLSID_ListPad,
                                    _T("ListPad class"),
                                    _T("ListPad.ListPad.1"),
                                    _T("ListPad.ListPad"),
                                    LIBID_CICLib,
                                    _T("1"),
                                    _T("1.0"))

    BEGIN_COM_MAP(CListPad)
    COM_INTERFACE_ENTRY(IListPad)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CListPad)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
//  PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP()

    BEGIN_MSG_MAP(CListPad)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)

    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    MESSAGE_HANDLER(WM_NOTIFYFORMAT, OnNotifyFormat)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    END_MSG_MAP()

// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

    STDMETHOD(TranslateAccelerator)(MSG *pMsg)
    {
        // If the list view has the focus process the keys the list view can use
        // use because IE will take them before they become normal key events
        // to the focused window.
        if (::GetFocus() == m_ListViewHWND && pMsg->message == WM_KEYDOWN)
        {
            switch (pMsg->wParam)
            {
            case VK_UP:
            case VK_DOWN:
            case VK_LEFT:
            case VK_RIGHT:
            case VK_HOME:
            case VK_END:
            case VK_PRIOR:
            case VK_NEXT:
                ::TranslateMessage(pMsg);
                ::DispatchMessage(pMsg);
                return S_OK;
            }
        }

        CComQIPtr<IOleControlSite,&IID_IOleControlSite> spCtrlSite (m_spClientSite);
        if (spCtrlSite)
            return spCtrlSite->TranslateAccelerator (pMsg,0);
        return S_FALSE;
    }

public:

    LRESULT OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LRESULT lr = CComControlBase::OnSetFocus (nMsg, wParam, lParam, bHandled);
        if (m_ListViewHWND)
        {
            ::SetFocus (m_ListViewHWND);
            return TRUE;
        }
        return lr;
    }

    LRESULT OnNotify (UINT nMsg, WPARAM w, LPARAM l, BOOL& bHandled)
    {
        NMHDR* pnmhdr = reinterpret_cast<NMHDR*>(l);

        // Must handle focus changes here for active control tracking.
        // Don't forward it to the MMC window.
        if (pnmhdr->code == NM_SETFOCUS)
        {
            // if we're not UI active, request it now
            if (m_bInPlaceActive && !m_bUIActive)
                UIActivateWithNoGrab();

            return  CComControlBase::OnSetFocus (WM_SETFOCUS, NULL, NULL, bHandled);
        }
        else if (pnmhdr->code == NM_KILLFOCUS)
        {
            return  CComControlBase::OnKillFocus (WM_KILLFOCUS, NULL, NULL, bHandled);
        }

        if (m_MMChWnd != NULL)
            return(BOOL)::SendMessage (m_MMChWnd, nMsg, w, l);

        return bHandled = 0;
    }

    LRESULT OnNotifyFormat (UINT nMsg, WPARAM w, LPARAM l, BOOL& lResult)
    {   return OnNotify (nMsg, w, l, lResult);}

    LRESULT OnDestroy (UINT nMsg, WPARAM w, LPARAM l, BOOL& lResult)
    {
        if (m_MMChWnd != NULL)
        { // detach
            ::SendMessage (m_MMChWnd, MMC_MSG_CONNECT_TO_TPLV, (WPARAM)m_hWnd, (LPARAM)NULL);
            m_MMChWnd = NULL;
        }
        return lResult = 1;
    }

    LRESULT OnSize (UINT nMsg, WPARAM w, LPARAM l, BOOL& lResult)
    {
 		::SetWindowPos (m_ListViewHWND, NULL, 0, 0, LOWORD(l), HIWORD(l), SWP_NOZORDER | SWP_NOACTIVATE);
        return 1;
    }

	HRESULT OnPostVerbInPlaceActivate();
    
    // UIActivation code taken from CComControlBase::InPlaceActivate.
    // Can't call InPlaceActivate because it always forces the focus to the
    // outer window and we don't want to steal focus from the list view control.
    void UIActivateWithNoGrab()
    {
        OLEINPLACEFRAMEINFO frameInfo;
        RECT rcPos, rcClip;
        CComPtr<IOleInPlaceFrame> spInPlaceFrame;
        CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
        frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

        m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
                                          &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

        CComPtr<IOleInPlaceActiveObject> spActiveObject;
        ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

        m_bUIActive = TRUE;
        HRESULT hr = m_spInPlaceSite->OnUIActivate();
        if (FAILED(hr))
            return;

        // set ourselves up in the host.
        //
        if (spActiveObject)
        {
            if (spInPlaceFrame)
                spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
            if (spInPlaceUIWindow)
                spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
        }

        if (spInPlaceFrame)
            spInPlaceFrame->SetBorderSpace(NULL);
        if (spInPlaceUIWindow)
            spInPlaceUIWindow->SetBorderSpace(NULL);
    }

private:
    HWND m_MMChWnd;
    HWND m_ListViewHWND;
};

#endif //__LISTPAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\sysclrctrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       sysclrctrl.cpp
//
//--------------------------------------------------------------------------

// SysColorCtrl.cpp : Implementation of CSysColorCtrl
#include "stdafx.h"
#include "cic.h"
#include "SysColorCtrl.h"

#ifndef ASSERT
#define ASSERT _ASSERT
#endif
#include <mmctempl.h>

// CPlex::Create and CPlex::FreeDataChain are needed to use CList.
// These should be moved to core.lib.  I copied them from nodemgr\plex.cpp

/////////////////////////////////////////////////////////////////////////////
// CPlex

CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
    DECLARE_SC(sc, TEXT("CPlex::Create"));
    if ( (nMax <=0) || (cbElement <= 0))
    {
        sc = E_INVALIDARG;
        return NULL;
    }

    CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
                        // may throw exception
    if (!p)
    {
        sc = E_OUTOFMEMORY;
        return NULL;
    }

    p->pNext = pHead;
    pHead = p;  // change head (adds in reverse order for simplicity)
    return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
        CPlex* p = this;
        while (p != NULL)
        {
                BYTE* bytes = (BYTE*) p;
                CPlex* pNext = p->pNext;
                delete[] bytes;
                p = pNext;
        }
}

// need to subclass the top-level window hosting this control so that
// I can be assured of receiving the WM_SYSCOLORCHANGE message
static WNDPROC g_OriginalWndProc;
static HWND g_hwndTop;

// need a list of HWNDs (one for each SysColorCtrl) so that I can notify each
// one of WM_SYSCOLORCHANGE
static CList<HWND, HWND> g_listHWND;

static LRESULT SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_SYSCOLORCHANGE) {
        // post message to all SysColor controls
        POSITION pos = g_listHWND.GetHeadPosition();
        while (pos) {
            HWND hwndSysColor = g_listHWND.GetNext(pos);
            if (hwndSysColor != NULL)
                PostMessage(hwndSysColor, uMsg, wParam, lParam);
        }
    }
    return CallWindowProc(g_OriginalWndProc, hwnd, uMsg, wParam, lParam);
}

static long GetHTMLColor(int nIndex)
{
    long rgb = GetSysColor(nIndex);

    // now swap the red and the blue so HTML hosts display the color properly
    return ((rgb & 0xff) << 16) + (rgb & 0xff00) + ((rgb & 0xff0000) >> 16);
}





/////////////////////////////////////////////////////////////////////////////
// CSysColorCtrl
LRESULT CSysColorCtrl::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // if no sys color controls currently exist, subclass the top level window
    if (g_listHWND.IsEmpty()) {
        g_hwndTop = GetTopLevelParent();
        g_OriginalWndProc = (WNDPROC)::SetWindowLongPtr(g_hwndTop, GWLP_WNDPROC, (LONG_PTR)&SubclassWndProc);
    }
    else {
        _ASSERT(g_hwndTop && g_OriginalWndProc);
    }

    // add this window to the list of SysColor control windows
    g_listHWND.AddTail(m_hWnd);

    bHandled = FALSE;
    return 0;
}
LRESULT CSysColorCtrl::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // remove me from the list
    POSITION pos = g_listHWND.Find(m_hWnd);
    if (pos != NULL) {
        g_listHWND.RemoveAt(pos);
    }

    // if hwnd list is empty and we've subclassed a window, undo that.
    if (g_listHWND.IsEmpty() && g_hwndTop && g_OriginalWndProc) {
        ::SetWindowLongPtr(g_hwndTop, GWLP_WNDPROC, (LONG_PTR)g_OriginalWndProc);

        g_OriginalWndProc = NULL;
        g_hwndTop = NULL;
    }

    bHandled = FALSE;
    return 0;
}




// need to post a user defined message to handle WM_SYSCOLORCHANGE to work
// around a Win95 hang when using this control inside IE.
LRESULT CSysColorCtrl::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    PostMessage(WM_MYSYSCOLORCHANGE);
    return 0;
}

LRESULT CSysColorCtrl::OnMySysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Fire_SysColorChange();
    return 0;
}


//
// Utility Methods
//
STDMETHODIMP CSysColorCtrl::ConvertRGBToHex(long rgb, BSTR * pszHex)
{
    DECLARE_SC(sc, TEXT("CSysColorCtrl::ConvertRGBToHex"));
    sc = ScCheckPointers(pszHex);
    if (sc)
        return sc.ToHr();

    SysFreeString(*pszHex);
    *pszHex = SysAllocString(L"xxxxxx");
    if (NULL == *pszHex)
        return (sc = E_OUTOFMEMORY).ToHr();

    WCHAR wszPossibles[] = L"0123456789abcdef";
    int i = 0;
    (*pszHex)[i++] = wszPossibles[(rgb & 0xf00000) >> 20];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x0f0000) >> 16];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x00f000) >> 12];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x000f00) >> 8];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x0000f0) >> 4];
    (*pszHex)[i++] = wszPossibles[(rgb & 0x00000f)];
    (*pszHex)[i] = 0;

    return sc.ToHr();
}

STDMETHODIMP CSysColorCtrl::ConvertHexToRGB(BSTR szHex, long * pRGB)
{
    if (pRGB == NULL)
        return E_POINTER;

    // Hex string must be perfectly formatted 6 digits
    // probably should implement ISystemErrorInfo to give user more info
    // on usage errors
    if (6 != wcslen(szHex))
        return E_INVALIDARG;

    long nRed, nGreen, nBlue;
    nRed = nGreen = nBlue = 0;

    nRed += ValueOfHexDigit(szHex[0]) * 16;
    nRed += ValueOfHexDigit(szHex[1]);

    nGreen += ValueOfHexDigit(szHex[2]) * 16;
    nGreen += ValueOfHexDigit(szHex[3]);

    nBlue += ValueOfHexDigit(szHex[4]) * 16;
    nBlue += ValueOfHexDigit(szHex[5]);

    *pRGB = (nRed << 16) + (nGreen << 8) + nBlue;
    return S_OK;
}

STDMETHODIMP CSysColorCtrl::GetRedFromRGB(long rgb, short * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // for html, rgb is 00RR GGBB, not 00BB GGRR
    *pVal = LOWORD ((rgb & 0xff0000) >> 16);

    return S_OK;
}

STDMETHODIMP CSysColorCtrl::GetGreenFromRGB(long rgb, short * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // for html, rgb is 00RR GGBB, not 00BB GGRR
    *pVal = LOWORD ((rgb & 0x00ff00) >> 8);

    return S_OK;
}

STDMETHODIMP CSysColorCtrl::GetBlueFromRGB(long rgb, short * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // for html, rgb is 00RR GGBB, not 00BB GGRR
    *pVal = LOWORD ((rgb & 0x0000ff));

    return S_OK;
}



// strings supported for format
#define CSS_FORMAT L"CSS"
#define HEX_FORMAT L"HEX"
#define RGB_FORMAT L"RGB"

//
// private utility method for getting rgb from string based on format
//
HRESULT CSysColorCtrl::RGBFromString(BSTR pszColor, BSTR pszFormat, long * pRGB)
{
    DECLARE_SC(sc, TEXT("CSysColorCtrl::RGBFromString"));
    sc = ScCheckPointers(pRGB);
    if (sc)
        return sc.ToHr();

    LPWSTR pszDupFormat = _wcsdup(pszFormat);
    if (!pszDupFormat)
        return (sc = E_OUTOFMEMORY).ToHr();

    LPWSTR pszUpper = NULL;
    LPWSTR pszLower = NULL;

    pszUpper = _wcsupr(pszDupFormat);

    *pRGB = -1;
    if (0 == wcscmp(pszUpper, RGB_FORMAT)) {
        *pRGB = _wtol(pszColor);
    }
    else if (0 == wcscmp(pszUpper, HEX_FORMAT)) {
        sc = ConvertHexToRGB(pszColor, pRGB);
        if (sc.ToHr() != S_OK)
            goto Cleanup;
    }
    else if (0 == wcscmp(pszUpper, CSS_FORMAT)) {
        LPWSTR pszDupColor = _wcsdup(pszColor);
        if (!pszDupColor)
        {
            sc = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pszLower = _wcslwr(pszDupColor);
        if (0 == wcscmp(L"activeborder", pszLower)) {
            get_RGBactiveborder(pRGB);
        }
        else if (0 == wcscmp(L"activecaption", pszLower)) {
            get_RGBactivecaption(pRGB);
        }
        else if (0 == wcscmp(L"appworkspace", pszLower)) {
            get_RGBappworkspace(pRGB);
        }
        else if (0 == wcscmp(L"background", pszLower)) {
            get_RGBbackground(pRGB);
        }
        else if (0 == wcscmp(L"buttonface", pszLower)) {
            get_RGBbuttonface(pRGB);
        }
        else if (0 == wcscmp(L"buttonhighlight", pszLower)) {
            get_RGBbuttonhighlight(pRGB);
        }
        else if (0 == wcscmp(L"buttonshadow", pszLower)) {
            get_RGBbuttonshadow(pRGB);
        }
        else if (0 == wcscmp(L"buttontext", pszLower)) {
            get_RGBbuttontext(pRGB);
        }
        else if (0 == wcscmp(L"captiontext", pszLower)) {
            get_RGBcaptiontext(pRGB);
        }
        else if (0 == wcscmp(L"graytext", pszLower)) {
            get_RGBgraytext(pRGB);
        }
        else if (0 == wcscmp(L"highlight", pszLower)) {
            get_RGBhighlight(pRGB);
        }
        else if (0 == wcscmp(L"highlighttext", pszLower)) {
            get_RGBhighlighttext(pRGB);
        }
        else if (0 == wcscmp(L"inactiveborder", pszLower)) {
            get_RGBinactiveborder(pRGB);
        }
        else if (0 == wcscmp(L"inactivecaption", pszLower)) {
            get_RGBinactivecaption(pRGB);
        }
        else if (0 == wcscmp(L"inactivecaptiontext", pszLower)) {
            get_RGBinactivecaptiontext(pRGB);
        }
        else if (0 == wcscmp(L"infobackground", pszLower)) {
            get_RGBinfobackground(pRGB);
        }
        else if (0 == wcscmp(L"infotext", pszLower)) {
            get_RGBinfotext(pRGB);
        }
        else if (0 == wcscmp(L"menu", pszLower)) {
            get_RGBmenu(pRGB);
        }
        else if (0 == wcscmp(L"menutext", pszLower)) {
            get_RGBmenutext(pRGB);
        }
        else if (0 == wcscmp(L"scrollbar", pszLower)) {
            get_RGBscrollbar(pRGB);
        }
        else if (0 == wcscmp(L"threeddarkshadow", pszLower)) {
            get_RGBthreeddarkshadow(pRGB);
        }
        else if (0 == wcscmp(L"threedface", pszLower)) {
            get_RGBthreedface(pRGB);
        }
        else if (0 == wcscmp(L"threedhighlight", pszLower)) {
            get_RGBthreedhighlight(pRGB);
        }
        else if (0 == wcscmp(L"threedlightshadow", pszLower)) {
            get_RGBthreedlightshadow(pRGB);
        }
        else if (0 == wcscmp(L"threedshadow", pszLower)) {
            get_RGBthreedshadow(pRGB);
        }
        else if (0 == wcscmp(L"window", pszLower)) {
            get_RGBwindow(pRGB);
        }
        else if (0 == wcscmp(L"windowframe", pszLower)) {
            get_RGBwindowframe(pRGB);
        }
        else if (0 == wcscmp(L"windowtext", pszLower)) {
            get_RGBwindowtext(pRGB);
        }
        else {
            sc = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else {
        // should set some error here such as through ISystemErrorInfo
        sc = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    if (pszUpper)
        free(pszUpper);

    if (pszLower)
        free(pszLower);

    return sc.ToHr();
}

//
// Private utility method using only RGB format for deriving colors based
// on a starting color, a color to move towards, and a percentage to move
// towards that color.
//
HRESULT CSysColorCtrl::GetDerivedRGBFromRGB(long rgbFrom,
                                            long rgbTo,
                                            short nPercent,
                                            long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // nPercent must be between 0 and 100
    // probably should implement ISystemErrorInfo to give user more info
    // on usage errors
    if (nPercent < 0 || nPercent > 100)
        return E_INVALIDARG;

    // get the derived color based on starting color, ending color, and percentage
    // color = color + (colorTo - colorFrom) * (nPercent/100);
    long nRedFrom = (rgbFrom & 0xff0000) >> 16;
    long nRedTo = (rgbTo & 0xff0000) >> 16;
    long nRed = nRedFrom + ((nRedTo - nRedFrom)*nPercent/100);

    long nGreenFrom = (rgbFrom & 0x00ff00) >> 8;
    long nGreenTo = (rgbTo & 0x00ff00) >> 8;
    long nGreen = nGreenFrom + ((nGreenTo - nGreenFrom)*nPercent/100);

    long nBlueFrom = (rgbFrom & 0x0000ff);
    long nBlueTo = (rgbTo & 0x0000ff);
    long nBlue = nBlueFrom + ((nBlueTo - nBlueFrom)*nPercent/100);

    *pVal = (nRed << 16) + (nGreen << 8) + nBlue;
    return S_OK;
}

//
// Method for Deriving colors based on a starting color,
// a color to move towards, and a percentage to move towards that color.
//
STDMETHODIMP CSysColorCtrl::GetDerivedRGB(/*[in]*/ BSTR pszFrom,
                                          /*[in]*/ BSTR pszTo,
                                          /*[in]*/ BSTR pszFormat,
                                          /*[in]*/ short nPercent,
                                          /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    //
    // get everything into RGB format, then calculate derived color
    //

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1, rgbTo = -1;
    HRESULT hr;

    hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    hr = RGBFromString(pszTo, pszFormat, &rgbTo);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, rgbTo, nPercent, pVal);
}

STDMETHODIMP CSysColorCtrl::GetDerivedHex(/*[in]*/ BSTR pszFrom,
                                          /*[in]*/ BSTR pszTo,
                                          /*[in]*/ BSTR pszFormat,
                                          /*[in]*/ short nPercent,
                                          /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    long rgb;
    HRESULT hr = GetDerivedRGB(pszFrom, pszTo, pszFormat, nPercent, &rgb);
    if (hr != S_OK)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}


STDMETHODIMP CSysColorCtrl::Get3QuarterLightRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 75, pVal);
}

STDMETHODIMP CSysColorCtrl::Get3QuarterLightHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 75, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}

STDMETHODIMP CSysColorCtrl::GetHalfLightRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 50, pVal);
}

STDMETHODIMP CSysColorCtrl::GetHalfLightHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 50, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}

STDMETHODIMP CSysColorCtrl::GetQuarterLightRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 25, pVal);
}

STDMETHODIMP CSysColorCtrl::GetQuarterLightHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(255,255,255), 25, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}
STDMETHODIMP CSysColorCtrl::Get3QuarterDarkRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 75, pVal);
}

STDMETHODIMP CSysColorCtrl::Get3QuarterDarkHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 75, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}

STDMETHODIMP CSysColorCtrl::GetHalfDarkRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 50, pVal);
}

STDMETHODIMP CSysColorCtrl::GetHalfDarkHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 50, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}

STDMETHODIMP CSysColorCtrl::GetQuarterDarkRGB(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    return GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 25, pVal);
}

STDMETHODIMP CSysColorCtrl::GetQuarterDarkHex(/*[in]*/ BSTR pszFrom,
                                                /*[in]*/ BSTR pszFormat,
                                                /*[out, retval]*/ BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // convert from String to long using correct format to interpret from
    long rgbFrom = -1;
    HRESULT hr = RGBFromString(pszFrom, pszFormat, &rgbFrom);
    if (hr != S_OK)
        return hr;

    long rgb;
    hr = GetDerivedRGBFromRGB(rgbFrom, RGB(0,0,0), 25, &rgb);
    if (S_OK != hr)
        return hr;

    return ConvertRGBToHex(rgb, pVal);
}




//
// Properties
//

// use macro so this is easily extensible to include more properties
// Should probably move this whole thing to header to be in-line
// for even easier extensibility
#define GETPROPSIMPL(methodname, color_value) \
STDMETHODIMP CSysColorCtrl::get_HEX##methodname(BSTR * pVal) { \
    return ConvertRGBToHex(GetHTMLColor(color_value), pVal); \
} \
STDMETHODIMP CSysColorCtrl::get_RGB##methodname(long * pVal) { \
    if (pVal == NULL) return E_POINTER; \
    *pVal = GetHTMLColor(color_value); \
    return S_OK; \
}

GETPROPSIMPL(activeborder, COLOR_ACTIVEBORDER)
GETPROPSIMPL(activecaption, COLOR_ACTIVECAPTION)
GETPROPSIMPL(appworkspace, COLOR_APPWORKSPACE)
GETPROPSIMPL(background, COLOR_BACKGROUND)
GETPROPSIMPL(buttonface, COLOR_BTNFACE)
GETPROPSIMPL(buttonhighlight, COLOR_BTNHIGHLIGHT)
GETPROPSIMPL(buttonshadow, COLOR_BTNSHADOW)
GETPROPSIMPL(buttontext, COLOR_BTNTEXT)
GETPROPSIMPL(captiontext, COLOR_CAPTIONTEXT)
GETPROPSIMPL(graytext, COLOR_GRAYTEXT)
GETPROPSIMPL(highlight, COLOR_HIGHLIGHT)
GETPROPSIMPL(highlighttext, COLOR_HIGHLIGHTTEXT)
GETPROPSIMPL(inactiveborder, COLOR_INACTIVEBORDER)
GETPROPSIMPL(inactivecaption, COLOR_INACTIVECAPTION)
GETPROPSIMPL(inactivecaptiontext, COLOR_INACTIVECAPTIONTEXT)
GETPROPSIMPL(infobackground, COLOR_INFOBK)
GETPROPSIMPL(infotext, COLOR_INFOTEXT)
GETPROPSIMPL(menu, COLOR_MENU)
GETPROPSIMPL(menutext, COLOR_MENUTEXT)
GETPROPSIMPL(scrollbar, COLOR_SCROLLBAR)
GETPROPSIMPL(threeddarkshadow, COLOR_3DDKSHADOW)
GETPROPSIMPL(threedface, COLOR_3DFACE)
GETPROPSIMPL(threedhighlight, COLOR_3DHIGHLIGHT)
GETPROPSIMPL(threedlightshadow, COLOR_3DLIGHT) // Is this correct?
GETPROPSIMPL(threedshadow, COLOR_3DSHADOW)
GETPROPSIMPL(window, COLOR_WINDOW)
GETPROPSIMPL(windowframe, COLOR_WINDOWFRAME)
GETPROPSIMPL(windowtext, COLOR_WINDOWTEXT)



//
// Protected methods
//
int CSysColorCtrl::ValueOfHexDigit(WCHAR wch)
{
    switch (wch) {
    case L'0':
        return 0;
    case L'1':
        return 1;
    case L'2':
        return 2;
    case L'3':
        return 3;
    case L'4':
        return 4;
    case L'5':
        return 5;
    case L'6':
        return 6;
    case L'7':
        return 7;
    case L'8':
        return 8;
    case L'9':
        return 9;
    case L'a':
    case L'A':
        return 10;
    case L'b':
    case L'B':
        return 11;
    case L'c':
    case L'C':
        return 12;
    case L'd':
    case L'D':
        return 13;
    case L'e':
    case L'E':
        return 14;
    case L'f':
    case L'F':
        return 15;
    }

    ATLTRACE(_T("Unrecognized Hex Digit: '%c'"), wch);
    return 0;
} // ValueOfHexDigit()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\syscolorctrl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       syscolorctrl.h
//
//--------------------------------------------------------------------------

// SysColorCtrl.h : Declaration of the CSysColorCtrl

#ifndef __SYSCOLORCTRL_H_
#define __SYSCOLORCTRL_H_

#include "resource.h"       // main symbols
#include "CPsyscolor.h"

// window message to be used to send myself a message to fire the event
#define WM_MYSYSCOLORCHANGE WM_USER+1

// need to subclass the top-level window hosting this control so that
// I can be assured of receiving the WM_SYSCOLORCHANGE message
//BOOL SetupSubclass(HWND hwndTopLevel);

/////////////////////////////////////////////////////////////////////////////
// CSysColorCtrl
class ATL_NO_VTABLE CSysColorCtrl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSysColorCtrl, &CLSID_SysColorCtrl>,
    public CComControl<CSysColorCtrl>,
    public IDispatchImpl<ISysColorCtrl, &IID_ISysColorCtrl, &LIBID_CICLib>,
    public IProvideClassInfo2Impl<&CLSID_SysColorCtrl, &DIID__SysColorEvents, &LIBID_CICLib>,
    public IPersistStreamInitImpl<CSysColorCtrl>,
    public IPersistStorageImpl<CSysColorCtrl>,
    public IQuickActivateImpl<CSysColorCtrl>,
    public IOleControlImpl<CSysColorCtrl>,
    public IOleObjectImpl<CSysColorCtrl>,
    public IOleInPlaceActiveObjectImpl<CSysColorCtrl>,
    public IObjectSafetyImpl<CSysColorCtrl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IViewObjectExImpl<CSysColorCtrl>,
    public IOleInPlaceObjectWindowlessImpl<CSysColorCtrl>,
    public IDataObjectImpl<CSysColorCtrl>,
    public ISpecifyPropertyPagesImpl<CSysColorCtrl>,
    public CProxy_SysColorEvents<CSysColorCtrl>,
    public IConnectionPointContainerImpl<CSysColorCtrl>
{
public:
    CSysColorCtrl()
    {
        m_bWindowOnly = TRUE;
    }

    DECLARE_MMC_CONTROL_REGISTRATION(
		g_szCicDll,
        CLSID_SysColorCtrl,
        _T("SysColorCtrl class"),
        _T("SysColorCtrl.SysColorCtrl.1"),
        _T("SysColorCtrl.SysColorCtrl"),
        LIBID_CICLib,
        _T("1"),
        _T("1.0"))

BEGIN_COM_MAP(CSysColorCtrl)
    COM_INTERFACE_ENTRY(ISysColorCtrl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CSysColorCtrl)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CSysColorCtrl)
    CONNECTION_POINT_ENTRY(DIID__SysColorEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CSysColorCtrl)
//  MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
//  MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
//  MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
    MESSAGE_HANDLER(WM_MYSYSCOLORCHANGE, OnMySysColorChange)
END_MSG_MAP()

#if 0
// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }
#endif

    // need to override TranslateAccelerator in order to work around a
    // "feature" in IE4.  Description of the problem can be found in
    // KB article Q169434.  From the KB article:
    //
    // CAUSE: In-place active objects must always be given the first
    // chance at translating accelerator keystrokes. To satisfy this
    // requirement, the Internet Explorer calls an ActiveX control's
    // IOleInPlaceActiveObject::TranslateAccelerator method. The default
    // ATL implementation of TranslateAccelerator does not pass the
    // keystroke to the container.
    STDMETHOD(TranslateAccelerator)(MSG *pMsg) {
        CComQIPtr<IOleControlSite,&IID_IOleControlSite>
        spCtrlSite(m_spClientSite);
        if(spCtrlSite) {
            return spCtrlSite->TranslateAccelerator(pMsg,0);
        }
        return S_FALSE;
    }

// ISysColorCtrl
public:
    STDMETHOD(ConvertRGBToHex)(/*[in]*/ long rgb, /*[out, retval]*/ BSTR *pszHex);
    STDMETHOD(ConvertHexToRGB)(/*[in]*/ BSTR szHex, /*[out, retval]*/ long * pRGB);
    STDMETHOD(GetRedFromRGB)(/*[in]*/ long rgb, /*[out, retval]*/ short* pVal);
    STDMETHOD(GetGreenFromRGB)(/*[in]*/ long rgb, /*[out, retval]*/ short* pVal);
    STDMETHOD(GetBlueFromRGB)(/*[in]*/ long rgb, /*[out, retval]*/ short* pVal);

    STDMETHOD(GetDerivedRGB)(/*[in]*/ BSTR pszFrom,
                             /*[in]*/ BSTR pszTo,
                             /*[in]*/ BSTR pszFormat,
                             /*[in]*/ short nPercent,
                             /*[out, retval]*/ long * pVal);

    STDMETHOD(GetDerivedHex)(/*[in]*/ BSTR pszFrom,
                             /*[in]*/ BSTR pszTo,
                             /*[in]*/ BSTR pszFormat,
                             /*[in]*/ short nPercent,
                             /*[out, retval]*/ BSTR * pVal);

    // Wrapper methods
    // derived "light" methods calculate a color based the requested percentage from
    // a given color to white.
    STDMETHOD(Get3QuarterLightRGB)(/*[in]*/ BSTR pszFrom,
                                   /*[in]*/ BSTR pszFormat,
                                   /*[out, retval]*/ long * pVal);

    STDMETHOD(Get3QuarterLightHex)(/*[in]*/ BSTR pszFrom,
                                   /*[in]*/ BSTR pszFormat,
                                   /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(GetHalfLightRGB)(/*[in]*/ BSTR pszFrom,
                               /*[in]*/ BSTR pszFormat,
                               /*[out, retval]*/ long * pVal);

    STDMETHOD(GetHalfLightHex)(/*[in]*/ BSTR pszFrom,
                               /*[in]*/ BSTR pszFormat,
                               /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(GetQuarterLightRGB)(/*[in]*/ BSTR pszFrom,
                                  /*[in]*/ BSTR pszFormat,
                                  /*[out, retval]*/ long * pVal);

    STDMETHOD(GetQuarterLightHex)(/*[in]*/ BSTR pszFrom,
                                  /*[in]*/ BSTR pszFormat,
                                  /*[out, retval]*/ BSTR * pVal);

    // derived "dark" methods calculate a color based the requested percentage from
    // a given color to black.
    STDMETHOD(Get3QuarterDarkRGB)(/*[in]*/ BSTR pszFrom,
                                  /*[in]*/ BSTR pszFormat,
                                  /*[out, retval]*/ long * pVal);

    STDMETHOD(Get3QuarterDarkHex)(/*[in]*/ BSTR pszFrom,
                                  /*[in]*/ BSTR pszFormat,
                                  /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(GetHalfDarkRGB)(/*[in]*/ BSTR pszFrom,
                              /*[in]*/ BSTR pszFormat,
                              /*[out, retval]*/ long * pVal);

    STDMETHOD(GetHalfDarkHex)(/*[in]*/ BSTR pszFrom,
                              /*[in]*/ BSTR pszFormat,
                              /*[out, retval]*/ BSTR * pVal);

    STDMETHOD(GetQuarterDarkRGB)(/*[in]*/ BSTR pszFrom,
                                 /*[in]*/ BSTR pszFormat,
                                 /*[out, retval]*/ long * pVal);

    STDMETHOD(GetQuarterDarkHex)(/*[in]*/ BSTR pszFrom,
                                 /*[in]*/ BSTR pszFormat,
                                 /*[out, retval]*/ BSTR * pVal);

    // properties - use macro for easy extensibility
#define GETPROPS(prop_name) \
    STDMETHOD(get_RGB##prop_name)(/*[out, retval]*/ long *pVal); \
    STDMETHOD(get_HEX##prop_name)(/*[out, retval]*/ BSTR *pVal);

    GETPROPS(activeborder)
    GETPROPS(activecaption)
    GETPROPS(appworkspace)
    GETPROPS(background)
    GETPROPS(buttonface)
    GETPROPS(buttonhighlight)
    GETPROPS(buttonshadow)
    GETPROPS(buttontext)
    GETPROPS(captiontext)
    GETPROPS(graytext)
    GETPROPS(highlight)
    GETPROPS(highlighttext)
    GETPROPS(inactiveborder)
    GETPROPS(inactivecaption)
    GETPROPS(inactivecaptiontext)
    GETPROPS(infobackground)
    GETPROPS(infotext)
    GETPROPS(menu)
    GETPROPS(menutext)
    GETPROPS(scrollbar)
    GETPROPS(threeddarkshadow)
    GETPROPS(threedface)
    GETPROPS(threedhighlight)
    GETPROPS(threedlightshadow)
    GETPROPS(threedshadow)
    GETPROPS(window)
    GETPROPS(windowframe)
    GETPROPS(windowtext)

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMySysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    int ValueOfHexDigit(WCHAR wch);
    HRESULT RGBFromString(BSTR pszColor, BSTR pszFormat, long * pRGB);
    HRESULT GetDerivedRGBFromRGB(long rgbFrom, long rgbTo, short nPercent, long * pVal);
};


#endif //__SYSCOLORCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3D5905E4_523C_11D1_9FEA_00600832DB4A__INCLUDED_)
#define AFX_STDAFX_H__3D5905E4_523C_11D1_9FEA_00600832DB4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include <shellapi.h>

#include <atlbase.h>
using namespace ::ATL;
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
//#include <atlwin21.h>
#include <atlcom.h>
#include <atlctl.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#include <vector>
#include <string>
#include "tstring.h"

//############################################################################
//############################################################################
//
// Files #included from base and core.
//
//############################################################################
//############################################################################
#include "mmcdebug.h"
#include "mmcerror.h"

#include "classreg.h"
#include "strings.h"

#endif // !defined(AFX_STDAFX_H__3D5905E4_523C_11D1_9FEA_00600832DB4A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\controls\cic\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF


MAJORCOMP  = admin
MINORCOMP  = cic

TARGETNAME = cic
TARGETPATH = obj
TARGETTYPE = DYNLINK

DLLENTRY   = _DllMainCRTStartup

UMTYPE     = windows

WIN32_WINNT_VERSION = 0x0400
WIN32_IE_VERSION    = 0x0500
SUBSYSTEM_VERSION   = 4.00


USE_NATIVE_EH  = 1
USE_RTTI       = 1
USE_VCCOM      = 1
USE_STATIC_ATL = 1
ATL_VER        = 30
USE_MSVCRT     = 1
USE_STL        = 1

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
	$(SDK_LIB_PATH)\mmc.lib						\
	..\..\..\core\$(CharWidth)\$(O)\uicore.lib	\
	..\..\..\base\$(CharWidth)\$(O)\mmcbase.lib

TARGETLIBS = \
	$(SDK_LIB_PATH)\kernel32.lib     \
	$(SDK_LIB_PATH)\user32.lib       \
	$(SDK_LIB_PATH)\oleaut32.lib     \
	$(SDK_LIB_PATH)\ole32.lib        \
	$(SDK_LIB_PATH)\advapi32.lib     \
	$(SDK_LIB_PATH)\uuid.lib         \
	$(SDK_LIB_PATH)\comctl32.lib     \
	$(SDK_LIB_PATH)\gdi32.lib        \
	$(SDK_LIB_PATH)\comdlg32.lib


DLLDEF = ..\cic.def

INCLUDES = \
	..;                         \
	..\idl\$(O);                \
	..\..\..\types\idl\$(O);    \
	..\..\..\inc;				\

PRECOMPILED_INCLUDE    = ..\stdafx.h
PRECOMPILED_CXX        = 1
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp

# This target is required so $(O)\cic.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$(O)\cic.res: \
	..\idl\$(O)\cic.tlb	\

SOURCES = \
	..\cic.rc           \
	..\cic.cpp          \
	..\dispobj.cpp      \
	..\listpad.cpp      \
	..\mmcctrl.cpp      \
	..\mmclpi.cpp       \
	..\mmctask.cpp      \
	..\sysclrctrl.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amcdoc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcdoc.cpp
//
//--------------------------------------------------------------------------

// AMCDoc.cpp : implementation of the CAMCDoc class
//


#include "stdafx.h"
#include "AMC.h"

#include "AMCDoc.h"
#include "AMCView.h"
#include "treectrl.h"
#include "mainfrm.h"
#include "cclvctl.h"
#include "props.h"
#include <algorithm>
#include <vector>
#include <list>

#include "amcmsgid.h"
#include "amcpriv.h"
#include "mmcutil.h"
#include "ndmgrp.h"
#include "strtable.h"
#include "stgio.h"
#include "comdbg.h"
#include "favorite.h"
#include "mscparser.h"
#include "scriptevents.h"
// helper
tstring GetCurrentFileVersionAsString();

//############################################################################
//############################################################################
//
//  Implementation of class CMMCDocument
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CMMCDocument
 *
 *
 * PURPOSE: The COM 0bject that exposes the Document interface.
 *
 *+-------------------------------------------------------------------------*/
class CMMCDocument :
    public CMMCIDispatchImpl<Document>,
    public CTiedComObject<CAMCDoc>
{
protected:
    typedef CAMCDoc CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CMMCDocument)
    END_MMC_COM_MAP()

    //Document interface
public:
    MMC_METHOD0(Save);
    MMC_METHOD1(SaveAs,         BSTR /*bstrFilename*/);
    MMC_METHOD1(Close,          BOOL /*bSaveChanges*/);
    MMC_METHOD1(CreateProperties, PPPROPERTIES  /*ppProperties*/);

    // properties
    MMC_METHOD1(get_Views,      PPVIEWS   /*ppViews*/);
    MMC_METHOD1(get_SnapIns,    PPSNAPINS /*ppSnapIns*/);
    MMC_METHOD1(get_ActiveView, PPVIEW    /*ppView*/);
    MMC_METHOD1(get_Name,       PBSTR     /*pbstrName*/);
    MMC_METHOD1(put_Name,       BSTR      /*bstrName*/);
    MMC_METHOD1(get_Location,   PBSTR    /*pbstrLocation*/);
    MMC_METHOD1(get_IsSaved,    PBOOL    /*pBIsSaved*/);
    MMC_METHOD1(get_Mode,       PDOCUMENTMODE /*pMode*/);
    MMC_METHOD1(put_Mode,       DocumentMode /*mode*/);
    MMC_METHOD1(get_RootNode,   PPNODE     /*ppNode*/);
    MMC_METHOD1(get_ScopeNamespace, PPSCOPENAMESPACE  /*ppScopeNamespace*/);
    MMC_METHOD1(get_Application, PPAPPLICATION  /*ppApplication*/);
};

/*+-------------------------------------------------------------------------*
 * class CMMCViews
 *
 *
 * PURPOSE: The COM 0bject that exposes the Views interface.
 *
 *+-------------------------------------------------------------------------*/

// the real CMMCViews is typedef'd below.
class _CMMCViews :
    public CMMCIDispatchImpl<Views>, // the Views interface
    public CTiedComObject<CAMCDoc>
{
protected:

    typedef CAMCDoc CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(_CMMCViews)
    END_MMC_COM_MAP()

    // Views interface
public:
    MMC_METHOD1(get_Count,  PLONG /*pCount*/);
    MMC_METHOD2(Add,        PNODE /*pNode*/, ViewOptions /*fViewOptions*/);
    MMC_METHOD2(Item,       long  /*Index*/, PPVIEW /*ppView*/);
};

// this typedefs the real CMMCViews class. Implements get__NewEnum using CMMCEnumerator and a CAMCViewPosition object
typedef CMMCNewEnumImpl<_CMMCViews, CAMCViewPosition> CMMCViews;


//############################################################################
//############################################################################
//
//  Implementation of class CStringTableString
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 * CStringTableString::GetStringTable
 *
 *
 *--------------------------------------------------------------------------*/
IStringTablePrivate* CStringTableString::GetStringTable () const
{
    return (CAMCDoc::GetDocument()->GetStringTable());
}

void ShowAdminToolsOnMenu(LPCTSTR lpszFilename);


enum ENodeType
{
    entRoot,
    entSelected,
};

//############################################################################
//############################################################################
//
//  Implementation of class CAMCDoc
//
//############################################################################
//############################################################################

IMPLEMENT_DYNCREATE(CAMCDoc, CDocument)

BEGIN_MESSAGE_MAP(CAMCDoc, CDocument)
    //{{AFX_MSG_MAP(CAMCDoc)
    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
    ON_COMMAND(ID_CONSOLE_ADDREMOVESNAPIN, OnConsoleAddremovesnapin)
    ON_UPDATE_COMMAND_UI(ID_CONSOLE_ADDREMOVESNAPIN, OnUpdateConsoleAddremovesnapin)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAMCDoc construction/destruction

CAMCDoc* CAMCDoc::m_pDoc = NULL;

CAMCDoc::CAMCDoc()
    :   m_MTNodeIDForNewView(ROOTNODEID),
        m_ViewIDForNewView(0),
        m_lNewWindowOptions(MMC_NW_OPTION_NONE),
        m_bReadOnlyDoc(false),
        m_fFrameModified (false),
        m_eSaveStatus (eStat_Succeeded),
        m_pFavorites(NULL)
{
    TRACE_CONSTRUCTOR(CAMCDoc);
    DECLARE_SC (sc, TEXT("CAMCDoc::CAMCDoc"));

    CComObject<CMasterStringTable> * pStringTable;

    sc = CComObject<CMasterStringTable>::CreateInstance (&pStringTable);
    if(sc.IsError() || !pStringTable)
    {
        sc = E_OUTOFMEMORY;
        sc.FatalError();
    }

    m_spStringTable = pStringTable; // does the addref.
    if(m_spStringTable == NULL)
    {
        delete pStringTable;
        sc = E_UNEXPECTED;
        sc.FatalError();
    }

    m_pstrCustomTitle = new CStringTableString(m_spStringTable);
    if(!m_pstrCustomTitle)
    {
        sc = E_OUTOFMEMORY;
        sc.FatalError();
    }

    if (m_pDoc)
        m_pDoc->OnCloseDocument();

    // Set default version update dialog to one appropriate for explicit saves
    SetExplicitSave(true);
    m_pDoc = this;

    m_ConsoleData.m_pConsoleDocument = this;
}

CAMCDoc::~CAMCDoc()
{
    TRACE_DESTRUCTOR(CAMCDoc);

    if (m_pDoc == this)
        m_pDoc = NULL;

    if(m_pFavorites != NULL)
    {
        delete m_pFavorites;
        m_pFavorites = NULL;
    }

    delete m_pstrCustomTitle;

    // Tell the node manager to release it's reference on the scope tree
    IFramePrivatePtr spFrame;

    HRESULT hr = spFrame.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);

    if (hr == S_OK)
    {
        spFrame->SetScopeTree(NULL);
        ReleaseNodeManager();
    }

    /*
     * if we used a custom icon, revert to the default icon on the frame
     */
    if (m_CustomIcon)
    {
        CMainFrame* pMainFrame = AMCGetMainWnd();

        if (pMainFrame != NULL)
        {
            pMainFrame->SetIconEx (NULL, true);
            pMainFrame->SetIconEx (NULL, false);
        }
    }
}

void CAMCDoc::ReleaseNodeManager()
{
    m_spScopeTreePersist = NULL;
    m_spScopeTree = NULL;
    m_spStorage = NULL;
}


//############################################################################
//############################################################################
//
//  CAMCDoc Object model methods.
//
//############################################################################
//############################################################################

// Document interface

/*+-------------------------------------------------------------------------*
 * CAMCDoc::ScCreateProperties
 *
 * Creates an empty Properties collection.
 *
 * Returns:
 *      E_UNEXPECTED    scope tree wasn't available
 *      other           value returned by IScopeTree::CreateProperties
 *--------------------------------------------------------------------------*/

SC CAMCDoc::ScCreateProperties (Properties** ppProperties)
{
    DECLARE_SC (sc, _T("CAMCDoc::ScCreateProperties"));

    /*
     * insure we have a scope tree; ppProperties will be validated downstream
     */
    if (m_spScopeTree == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * get the scope tree to create a Properties collection for us
     */
    sc = m_spScopeTree->CreateProperties (ppProperties);
    if (sc)
        return (sc);

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScEnumNext
 *
 * PURPOSE: Returns the next item in the enumeration sequence
 *
 * PARAMETERS:
 *    _Position & pos :
 *    PDISPATCH & pDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScEnumNext(CAMCViewPosition &pos, PDISPATCH & pDispatch)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScEnumNext"));

    CAMCView *pView = GetNextAMCView(pos);

    if(NULL ==pView) // ran out of elements
    {
        sc = S_FALSE;
        return sc;
    }

    // at this point, we have a valid CAMCView.
    ViewPtr spMMCView = NULL;

    sc = pView->ScGetMMCView(&spMMCView);
    if(sc)
        return sc;

    if(spMMCView == NULL)
    {
        sc = E_UNEXPECTED;  // should never happen.
        return sc;
    }

    /*
     * return the IDispatch for the object and leave a ref on it for the client
     */
    pDispatch = spMMCView.Detach();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScEnumSkip
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    unsigned   long :
 *    CAMCViewPosition & pos :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScEnumSkip(unsigned long celt, unsigned long& celtSkipped,
                    CAMCViewPosition &pos)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScEnumSkip"));

    // skip celt positions, don't check the last skip.
    for(celtSkipped=0; celtSkipped<celt; celtSkipped++)
    {
        if (pos == NULL)
        {
            sc = S_FALSE;
            return sc;
        }

        // go to the next view
        GetNextAMCView(pos);
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScEnumReset
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CAMCViewPosition & pos :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScEnumReset(CAMCViewPosition &pos)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScEnumReset"));

    // reset the position to the first view.
    pos = GetFirstAMCViewPosition();

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::ScSave
//
//  Synopsis:    Saves the document.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::ScSave ()
{
    DECLARE_SC(sc, _T("CAMCDoc::ScSave"));

    // Return if there is no file name given.
    if (m_strPathName.IsEmpty())
        return sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);

    // save the document (this function may produce UI, but we tried ^ to avoid it)
    if (!DoFileSave())
        return sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScSaveAs
 *
 * PURPOSE: Saves the console file, using the specified filename.
 *
 * PARAMETERS:
 *    BSTR  bstrFilename : The path to save the file to.
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScSaveAs(BSTR bstrFilename)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScSaveAs"));

    USES_CONVERSION;

    LPCTSTR lpctstrName = OLE2T(bstrFilename);
    if(!OnSaveDocument(lpctstrName))
    {
        sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);
        return sc;
    }
    else
    {
        DeleteHelpFile ();
        SetPathName(lpctstrName);
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCDoc::ScClose
 *
 * PURPOSE: implements Document.Close for object model
 *
 * PARAMETERS:
 *    BOOL bSaveChanges - save changes before closing
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC
CAMCDoc::ScClose(BOOL bSaveChanges)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScClose"));

    if (bSaveChanges)
    {
        // cannot save ned document this way!
        if (m_strPathName.IsEmpty())
            return sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);

        // check for property sheets open
        if (FArePropertySheetsOpen(NULL))
            return sc = ScFromMMC(IDS_ClosePropertyPagesBeforeClosingTheDoc);

        // save the document (this function may produce UI, but we tried ^ to avoid it)
        if (!DoFileSave())
            return sc = ScFromMMC(IDS_UnableToSaveDocumentMessage);
    }

    OnCloseDocument();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScItem
 *
 * PURPOSE: Returns the view specified by the index.
 *
 * PARAMETERS:
 *    long    Index :
 *    View ** ppView :
 *
 * RETURNS:
 *    STDMETHOD
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScItem(long Index, PPVIEW ppView)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScItem"));

    // check parameters
    if( (Index <= 0) ||  (Index > GetNumberOfViews()) || (!ppView) )
    {
        sc = E_INVALIDARG;
        return sc;
    }

    // step to the appropriate view
    CAMCViewPosition pos = GetFirstAMCViewPosition();
    CAMCView *pView = NULL;

    for (int nCount = 0; (nCount< Index) && (pos != NULL); )
    {
        pView = GetNextAMCView(pos);
        VERIFY (++nCount);
    }

    // make sure we have a valid view.

    if( (nCount != Index) || (!pView) )
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    sc = pView->ScGetMMCView(ppView);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScMapViewOptions
 *
 * PURPOSE: helper function maps ViewOptions to view creation flags
 *
 * PARAMETERS:
 *    pNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/

static SC ScMapViewOptions( ViewOptions fViewOptions, DWORD &value)
{
    DECLARE_SC(sc, TEXT("ScMapViewOptions"));

    value = MMC_NW_OPTION_NONE;

    // test to see if parameter is correct
    const DWORD mask = (ViewOption_ScopeTreeHidden |
                        ViewOption_NoToolBars |
                        ViewOption_NotPersistable
                       );

    if (fViewOptions & (~mask))
        sc = E_INVALIDARG;

    if (fViewOptions & ViewOption_ScopeTreeHidden)
        value |= MMC_NW_OPTION_NOSCOPEPANE;
    if (fViewOptions & ViewOption_NotPersistable)
        value |= MMC_NW_OPTION_NOPERSIST;
    if (fViewOptions & ViewOption_NoToolBars)
        value |= MMC_NW_OPTION_NOTOOLBARS;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScAdd
 *
 * PURPOSE: Impelements Views.Add method
 *
 * PARAMETERS:
 *    pNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScAdd( PNODE pNode, ViewOptions fViewOptions )
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScAdd"));

    // lock AppEvents until this function is done
    LockComEventInterface(AppEvents);

    sc = ScCheckPointers(m_spScopeTree, E_POINTER);
    if (sc)
        return sc;

    DWORD dwOptions = 0;
    sc = ScMapViewOptions( fViewOptions, dwOptions );
    if (sc)
        return sc;

    MTNODEID id;
    sc = m_spScopeTree->GetNodeID(pNode, &id);
    if (sc)
        return sc;

    // Set the given node-id as the root.
    SetMTNodeIDForNewView(id);
    SetNewWindowOptions(dwOptions);
    CreateNewView( true );
    SetMTNodeIDForNewView(ROOTNODEID);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Scget_Views
 *
 * PURPOSE: Returns a pointer to the Views interface
 *          (which is implemented by the same object, but need not be)
 *
 * PARAMETERS:
 *    Views ** ppViews :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::Scget_Views(PPVIEWS ppViews)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_Views"));

    if(!ppViews)
    {
        sc = E_POINTER;
        return sc;
    }

    // init out parameter
    *ppViews = NULL;

    // create a Views if needed.
    sc = CTiedComObjectCreator<CMMCViews>::ScCreateAndConnect(*this, m_spViews);
    if(sc)
        return sc;

    sc = ScCheckPointers(m_spViews, E_UNEXPECTED);
    if (sc)
        return sc;

    // addref the pointer for the client.
    m_spViews->AddRef();
    *ppViews = m_spViews;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Scget_SnapIns
 *
 * PURPOSE: returns a pointer to the SnapIns object.
 *
 * PARAMETERS:
 *    SnapIns ** ppSnapIns :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::Scget_SnapIns(PPSNAPINS ppSnapIns)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_SnapIns"));

    if((NULL==ppSnapIns) || (NULL == m_spScopeTree) )
    {
        sc = E_POINTER;
        return sc;
    }

    sc = m_spScopeTree->QuerySnapIns(ppSnapIns);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Scget_ScopeNamespace
 *
 * PURPOSE: returns a pointer to the ScopeNamespace object.
 *
 * PARAMETERS:
 *    ScopeNamespace ** ppScopeNamespace :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::Scget_ScopeNamespace(PPSCOPENAMESPACE ppScopeNamespace)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_ScopeNamespace"));

    if((NULL==ppScopeNamespace) || (NULL == m_spScopeTree) )
    {
        sc = E_POINTER;
        return sc;
    }

    sc = m_spScopeTree->QueryScopeNamespace(ppScopeNamespace);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Scget_Count
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    long * pCount :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::Scget_Count(PLONG pCount)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_Count"));

    // check parameters
    if(!pCount)
    {
        sc = E_POINTER;
        return sc;
    }

    // this should *not* be GetNumberOfPersistedViews
    *pCount = GetNumberOfViews();

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_Name
//
//  Synopsis:    Retrive the name of the current doc.
//
//  Arguments:   [pbstrName] - Ptr to the name to be returned.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_Name (PBSTR pbstrName)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_Name"));
    sc = ScCheckPointers(pbstrName);
    if (sc)
        return sc;

    CString strPath = GetPathName();

    *pbstrName = strPath.AllocSysString();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scput_Name
//
//  Synopsis:    Sets the name of the current document.
//
//  Arguments:   [bstrName] - The new name.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scput_Name(BSTR bstrName)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scput_Name"));

    USES_CONVERSION;
    LPCTSTR lpszPath = OLE2CT(bstrName);

    SetPathName(lpszPath, FALSE /*Dont add to MRU*/);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_Mode
//
//  Synopsis:    Retrieve the document mode.
//
//  Arguments:   [pMode] - Ptr to doc mode.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_Mode (PDOCUMENTMODE pMode)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_Mode"));
    sc = ScCheckPointers(pMode);
    if (sc)
        return sc;

    if (! GetDocumentMode(pMode))
        return (sc = E_FAIL);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scput_Mode
//
//  Synopsis:    Modify the document mode.
//
//  Arguments:   [mode] - new mode for the document.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scput_Mode (DocumentMode mode)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scput_Mode"));

    // SetDocumentMode fails if document mode is invalid.
    if (! SetDocumentMode(mode))
        return (sc = E_INVALIDARG);

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_ActiveView
//
//  Synopsis:    Retrieve the Active View object.
//
//  Arguments:   [ppView] - Ptr to a ptr of View object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_ActiveView (PPVIEW ppView)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_ActiveView"));
    sc = ScCheckPointers(ppView);
    if (sc)
        return sc;

    *ppView = NULL;

    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return sc;

    CAMCView *pView = pMainFrame->GetActiveAMCView();
    if (! pView)
    {
        return (sc = ScFromMMC(IDS_NoActiveView)); // There are no active views.
    }

    // at this point, we have a valid CAMCView.
    ViewPtr spMMCView = NULL;

    sc = pView->ScGetMMCView(&spMMCView);
    if(sc)
        return sc;

    sc = ScCheckPointers(spMMCView, E_UNEXPECTED);
    if (sc)
        return sc;

    /*
     * return the object and leave a ref on it for the client
     */
    *ppView = spMMCView.Detach();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_IsSaved
//
//  Synopsis:    Returns whether the file was saved. If not,
//               it is dirty and needs to be saved.
//
//  Arguments:   [pBIsSaved] - Ptr to BOOL (IsSaved info).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_IsSaved (PBOOL pBIsSaved)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_IsSaved"));
    sc = ScCheckPointers(pBIsSaved);
    if (sc)
        return sc;

    *pBIsSaved = (IsModified() == FALSE);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_Location
//
//  Synopsis:    Gets the location of the current document.
//
//  Arguments:   [pbstrLocation] - Ptr to BSTR string in which result is returned.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_Location (PBSTR    pbstrLocation)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_Location"));
    sc = ScCheckPointers(pbstrLocation);
    if (sc)
        return sc;

    CString strFullPath = GetPathName();

    // Even if path is empty below code will return empty string.
    int nSlashLoc = strFullPath.ReverseFind(_T('\\'));
    CString strLocation = strFullPath.Left(nSlashLoc);

    *pbstrLocation = strLocation.AllocSysString();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::Scget_RootNode
//
//  Synopsis:    Returns the console root node.
//
//  Arguments:   [ppNode] - Ptr to ptr to root node obj.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::Scget_RootNode (PPNODE     ppNode)
{
    DECLARE_SC(sc, _T("CAMCDoc::Scget_RootNode"));
    sc = ScCheckPointers(ppNode);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = m_spScopeTree->QueryRootNode(ppNode);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScGetMMCDocument
 *
 * PURPOSE: Creates, AddRef's, and returns a pointer to the tied COM object.
 *
 * PARAMETERS:
 *    Document ** ppDocument :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScGetMMCDocument(Document **ppDocument)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScGetMMCDocument"));

    // parameter check
    sc = ScCheckPointers(ppDocument);
    if (sc)
        return sc;

    // init out parameter
    *ppDocument = NULL;

    // create a CAMCDoc if needed.
    sc = CTiedComObjectCreator<CMMCDocument>::ScCreateAndConnect(*this, m_sp_Document);
    if(sc)
        return sc;

    sc = ScCheckPointers(m_sp_Document, E_UNEXPECTED);
    if (sc)
        return sc;

    // addref the pointer for the client.
    m_sp_Document->AddRef();
    *ppDocument = m_sp_Document;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * GetFirstAMCViewPosition
 *
 * PURPOSE: Returns the CAMCViewPosition of the first AMCView, or NULL if there is
 *          no AMCView.
 *
 * RETURNS:
 *    CAMCViewPosition
 *
 *+-------------------------------------------------------------------------*/
CAMCViewPosition
CAMCDoc::GetFirstAMCViewPosition()     const
{
    CAMCViewPosition vpos;
    POSITION pos = GetFirstViewPosition();

    while(pos != NULL)
    {
        POSITION posTemp = pos;         // hold this value.

        CAMCView *pView = dynamic_cast<CAMCView *>(GetNextView(pos));
        if(pView != NULL)                // found the AMCView
        {
            vpos.SetPosition(posTemp); // NOT pos!
            break;
        }
    }

    return (vpos);
}



/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::GetNextAMCView
 *
 * PURPOSE: Returns the next AMCView, starting at pos (inclusive)
 *
 * PARAMETERS:
 *    CAMCViewPosition & pos :  incremented to the next AMCView, NOT the next View.
 *
 * RETURNS:
 *    CAMCView *
 *
 *+-------------------------------------------------------------------------*/

CAMCView *
CAMCDoc::GetNextAMCView(CAMCViewPosition &pos) const
{
    CAMCView *pView = NULL;

    // check parameters
    if (pos == NULL)
        return NULL;

    // pos is non-NULL at this point. Loop until we have a CAMCView.
    // Note that unless there's a bug in GetFirstAMCViewPosition or
    // GetNextAMCView, we'll only go through this loop once, since a
    // non-NULL CAMCViewPosition should always refer to a CAMCView.
    while( (NULL == pView) && (pos != NULL) )
    {
        CView *pV = GetNextView(pos.GetPosition());
        pView = dynamic_cast<CAMCView *>(pV);
    }

    // at this point, pView is the correct return value, and it had better
    // not be NULL, or we never should have had a non-NULL pos
    ASSERT (pView != NULL);

    // bump pos to the next CAMCView
    // NOTE: This is NOT redundant. Must point to a CAMCView so that
    // NULL position tests can be done.
    while(pos != NULL)
    {
        /*
         * use temporary POSITION so we won't increment the POSITION
         * inside pos until we know pos doesn't refer to a CAMCView
         */
        POSITION posT = pos.GetPosition();

        if(dynamic_cast<CAMCView *>(GetNextView(posT)) != NULL) // found a CAMCView at pos
            break;

        /*
         * update the CAMCViewPosition with the position incremented
         * by GetNextView only if we didn't find a CAMCView at its
         * previous location
         */
        pos.SetPosition (posT);
    }

#ifdef DBG
    /*
     * if we're returning a non-NULL, it'd better point to a CAMCView
     */
    if (pos != NULL)
    {
        POSITION posT = pos.GetPosition();
        ASSERT (dynamic_cast<CAMCView *>(GetNextView(posT)) != NULL);
    }
#endif

    return pView;
}



/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::InitNodeManager
 *
 * PURPOSE:
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CAMCDoc::InitNodeManager()
{
    DECLARE_SC(sc, TEXT("CAMCDoc::InitNodeManager"));

    TRACE_METHOD(CAMCDoc, InitNodeManager);

    // Should not be currently initialized
    ASSERT(m_spScopeTree == NULL && m_spScopeTreePersist == NULL);
    ASSERT(m_spStorage == NULL);

    // The string table should have been created by now
    sc = ScCheckPointers(m_spStringTable, E_FAIL);
    if(sc)
        return sc.ToHr();

    // create the favorites at this stage
    ASSERT(m_pFavorites == NULL);
    m_pFavorites = new CFavorites;
    sc = ScCheckPointers(m_pFavorites, E_OUTOFMEMORY);
    if(sc)
        return sc.ToHr();


    // Create the initial private frame
    IFramePrivatePtr spFrame;
    sc = spFrame.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
    if (sc)
        return sc.ToHr();

    // recheck teh pointer
    sc = ScCheckPointers( spFrame, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();


    // Create the scope tree
    sc = m_spScopeTree.CreateInstance(CLSID_ScopeTree, NULL, MMC_CLSCTX_INPROC);
    if (sc)
    {
        ReleaseNodeManager();
        return sc.ToHr();
    }

    // recheck the pointer
    sc = ScCheckPointers( m_spScopeTree, E_UNEXPECTED );
    if (sc)
    {
        ReleaseNodeManager();
        return sc.ToHr();
    }

    // link frame and scope tree
    sc = spFrame->SetScopeTree(m_spScopeTree);
    if(sc)
    {
        ReleaseNodeManager();
        return sc.ToHr();
    }

    // Initialize the tree
    sc = m_spScopeTree->Initialize(AfxGetMainWnd()->m_hWnd, m_spStringTable);
    if (sc)
    {
        ReleaseNodeManager();
        return sc.ToHr();
    }

    // Get the IPersistStorage interface from the scope tree
    m_spScopeTreePersist = m_spScopeTree; // query for IPersistStorage
    ASSERT(m_spScopeTreePersist != NULL);

    m_ConsoleData.SetScopeTree (m_spScopeTree);

    CMainFrame* pFrame = AMCGetMainWnd();
    m_ConsoleData.m_hwndMainFrame = pFrame->GetSafeHwnd();
    m_ConsoleData.m_pConsoleFrame = pFrame;

    return sc.ToHr();
}

BOOL CAMCDoc::OnNewDocument()
{
    TRACE_METHOD(CAMCDoc, OnNewDocument);

    USES_CONVERSION;

    // Initialize the document and scope view ...
    if (!CDocument::OnNewDocument())
        return FALSE;

    // A new file can't be read-only
    SetPhysicalReadOnlyFlag (false);

    // use latest file version
    m_ConsoleData.m_eFileVer = FileVer_Current;
    ASSERT (IsValidFileVersion (m_ConsoleData.m_eFileVer));

    // Init help doc info times to current time by default
    // Will update when file is first saved
    ::GetSystemTimeAsFileTime(&GetHelpDocInfo()->m_ftimeCreate);
    GetHelpDocInfo()->m_ftimeModify = GetHelpDocInfo()->m_ftimeCreate;

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAMCDoc diagnostics

#ifdef _DEBUG
void CAMCDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CAMCDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAMCDoc commands
inline bool UnableToSaveDocument()
{
    if (AMCGetApp()->GetMode() == eMode_Author)
        MMCMessageBox(IDS_UnableToSaveDocumentMessage);

    return false;
}

static const wchar_t* AMCViewDataStreamName     = L"ViewData";
static const wchar_t* AMCFrameDataStreamName    = L"FrameData";
static const wchar_t* AMCStringTableStorageName = L"String Table";
static const wchar_t* AMCFavoritesStreamName    = L"FavoritesStream";
static const wchar_t* AMCCustomTitleStreamName  = L"Title";
static const wchar_t* AMCColumnDataStreamName   = L"ColumnData";
static const wchar_t* AMCViewSettingDataStreamName = L"ViewSettingData"; // View settings data stream

#pragma warning( disable : 4800 )

struct FrameState
{
    WINDOWPLACEMENT windowPlacement;
    BOOL fShowStatusBarInUserMode;
    BOOL fShowToolbarInAuthorMode;
}; // struct FrameState


struct FrameState2
{
    UINT            cbSize;
    WINDOWPLACEMENT wndplFrame;
    ProgramMode     eMode;
    DWORD           dwFlags;
    // NOT USED - SIZE PRESERVED FOR COMPATIBILITY
    // DWORD           dwHelpDocIndex;
    // DWORD           dwHelpDocTime[2];
    DWORD           dwUnused;
    DWORD           dwUnused2[2];

    FrameState2 (ProgramMode eMode_   = eMode_Author,
                 DWORD       dwFlags_ = eFlag_Default) :
        cbSize         (sizeof (FrameState2)),
        eMode          (eMode_),
        dwFlags        (dwFlags_),
        // NOT USED - SIZE PRESERVED FOR COMPATIBILITY
        dwUnused(0)
        // dwHelpDocIndex (0)
    {
        // NOT USED - SIZE PRESERVED FOR COMPATIBILITY
        // ZeroMemory (dwHelpDocTime, sizeof (dwHelpDocTime));
        ZeroMemory (dwUnused2, sizeof (dwUnused2));

        ZeroMemory (&wndplFrame, sizeof (wndplFrame));
        wndplFrame.length = sizeof (wndplFrame);
    }

};  // struct FrameState2

/*+-------------------------------------------------------------------------*
 * CFrameState
 *
 * class is designated to be used instead of FrameState2 in Persist methods.
 * It implements functionality of CXMLObject while containing the same data as FrameState2
 * The original struct cannot be extended because many methods do relay on its size.
 *
 *--------------------------------------------------------------------------*/
class CFrameState : public CXMLObject, public FrameState2
{
public:
    CFrameState(ProgramMode eMode_, DWORD dwFlags_) : FrameState2 (eMode_,dwFlags_) {}
protected:
    DEFINE_XML_TYPE (XML_TAG_FRAME_STATE);
    virtual void Persist(CPersistor &persistor)
    {
        persistor.Persist(CXMLWindowPlacement(wndplFrame));

        // define the table to map enumeration values to strings
        static const EnumLiteral frameStateFlags[] =
        {
            { eFlag_ShowStatusBar,                  XML_ENUM_FSTATE_SHOWSTATUSBAR },
            { eFlag_HelpDocInvalid,                 XML_ENUM_FSTATE_HELPDOCINVALID },
            { eFlag_LogicalReadOnly,                XML_ENUM_FSTATE_LOGICALREADONLY },
            { eFlag_PreventViewCustomization,       XML_ENUM_FSTATE_PREVENTVIEWCUSTOMIZATION },
        };

        // create wrapper to persist enumeration values as strings
        CXMLBitFlags flagPersistor(dwFlags, frameStateFlags, countof(frameStateFlags));
        // persist the wrapper
        persistor.PersistAttribute(XML_ATTR_FRAME_STATE_FLAGS, flagPersistor);
    }
};

// what is the size of the Version 1.1 definition of FrameState2?
const int cbFrameState2_v11 = SIZEOF_STRUCT (FrameState2, dwUnused2 /*dwHelpDocTime*/ );


/*+-------------------------------------------------------------------------*
 * AdjustRect
 *
 * Adjusts pInnerRect so that it is completely contained within pOuterRect
 *
 * If AR_MOVE is specified, the origin of pInnerRect is moved enough (if
 * necessary) so that the right and/or bottom edges of pInnerRect coincide
 * with those of pOuterRect.  pInnerRect's origin is never moved above or to
 * the left of pOuterRect's origin.
 *
 * If AR_SIZE is specified, the right and/or bottom edges of pInnerRect are
 * moved to that they coincide with those of pOuterRect.
 *--------------------------------------------------------------------------*/

#define AR_MOVE     0x0000001
#define AR_SIZE     0x0000002

void AdjustRect (LPCRECT pOuterRect, LPRECT pInnerRect, DWORD dwFlags)
{
    /*
     * if the inner rectangle is completely within
     * the outer, there's nothing to do
     */
    if ((pInnerRect->left   >= pOuterRect->left  ) &&
        (pInnerRect->right  <= pOuterRect->right ) &&
        (pInnerRect->top    >= pOuterRect->top   ) &&
        (pInnerRect->bottom <= pOuterRect->bottom))
        return;


    /*
     * handle movement
     */
    if (dwFlags & AR_MOVE)
    {
        int dx = 0;

        /*
         * shift inner rect right?
         */
        if (pInnerRect->left < pOuterRect->left)
            dx = pOuterRect->left - pInnerRect->left;

        /*
         * shift inner rect left? (make sure we don't shift it past the
         * left of the outer rect)
         */
        else if (pInnerRect->right > pOuterRect->right)
            dx = std::_MAX (pOuterRect->right - pInnerRect->right,
                            pOuterRect->left  - pInnerRect->left);


        /*
         * make sure things are right in the vertical
         */
        int dy = 0;

        /*
         * shift inner rect down?
         */
        if (pInnerRect->top < pOuterRect->top)
            dy = pOuterRect->top - pInnerRect->top;

        /*
         * shift inner rect up? (make sure we don't shift it past the
         * top of the outer rect)
         */
        else if (pInnerRect->bottom > pOuterRect->bottom)
            dy = std::_MAX (pOuterRect->bottom - pInnerRect->bottom,
                            pOuterRect->top    - pInnerRect->top);


        /*
         * if we need to shift the inner rect, do it now
         */
        if ((dx != 0) || (dy != 0))
        {
            ASSERT (dwFlags & AR_MOVE);
            OffsetRect (pInnerRect, dx, dy);
        }
    }


    /*
     * handle sizing
     */
    if (dwFlags & AR_SIZE)
    {
        if (pInnerRect->right  > pOuterRect->right)
            pInnerRect->right  = pOuterRect->right;

        if (pInnerRect->bottom > pOuterRect->bottom)
            pInnerRect->bottom = pOuterRect->bottom;
    }
}


/*+-------------------------------------------------------------------------*
 * InsurePlacementIsOnScreen
 *
 * This function insures that the window will appear on the virtual screen,
 * and if the whole window can't be located there, that at least the most
 * interesting part is visible.
 *--------------------------------------------------------------------------*/

void InsurePlacementIsOnScreen (WINDOWPLACEMENT& wndpl)
{
    /*
     * find the monitor containing the window origin
     */
    HMONITOR hmon = MonitorFromPoint (CPoint (wndpl.rcNormalPosition.left,
                                              wndpl.rcNormalPosition.top),
                                      MONITOR_DEFAULTTONEAREST);

    MONITORINFO mi = { sizeof (mi) };
    CRect rectBounds;

    /*
     * if we could get the info for the monitor containing the window origin,
     * use it's workarea as the bounding rectangle; otherwise get the workarea
     * for the default monitor; if that failed as well, default to 640x480
     */
    if (GetMonitorInfo (hmon, &mi))
        rectBounds = mi.rcWork;
    else if (!SystemParametersInfo (SPI_GETWORKAREA, 0, &rectBounds, false))
        rectBounds.SetRect (0, 0, 639, 479);

    /*
     * position the window rectangle within the bounding rectangle
     */
    AdjustRect (rectBounds, &wndpl.rcNormalPosition, AR_MOVE | AR_SIZE);
}


//+-------------------------------------------------------------------
//
//  Member:     LoadFrame
//
//  Synopsis:   Load the Frame Data.
//
//  Note:       The app mode was already read by LoadAppMode.
//              The child frames are created so call UpdateFrameWindow.
//
//  Arguments:  None
//
//  Returns:    bool. TRUE if success.
//
//--------------------------------------------------------------------
bool CAMCDoc::LoadFrame()
// The caller is resposible for calling DeleteContents() and display a message
// to the user when this function return false.
{
    TRACE_METHOD(CAMCDoc, LoadFrame);

    // This assertion shouldn't fail until the definition of FrameState2 changes
    // in a version after 1.1.  At that time, add another cbFrameState2_vXX
    // with the new version's FrameState2 size.
    ASSERT (cbFrameState2_v11 == sizeof (FrameState2));

    if (!AssertNodeManagerIsLoaded())
        return false;

    // Open the stream containing data for the app and frame
    IStreamPtr spStream;
    HRESULT     hr;

    hr = OpenDebugStream (m_spStorage, AMCFrameDataStreamName,
                                  STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &spStream);

    ASSERT(SUCCEEDED(hr) && spStream != NULL);
    if (FAILED(hr))
        return false;


    FrameState2 fs2;
    ULONG cbRead;
    ASSERT (IsValidFileVersion (m_ConsoleData.m_eFileVer));

    // V1.0 file? Migrate it forward
    if (m_ConsoleData.m_eFileVer == FileVer_0100)
    {
        FrameState fs;
        hr = spStream->Read (&fs, sizeof(fs), &cbRead);

        // if we can't read the FrameState, the file is corrupt
        if (FAILED(hr) || (cbRead != sizeof(fs)))
            return (false);

        // migrate FrameState into FrameState2
        fs2.wndplFrame = fs.windowPlacement;

        if (fs.fShowStatusBarInUserMode)
            fs2.dwFlags |=  eFlag_ShowStatusBar;
        else
            fs2.dwFlags &= ~eFlag_ShowStatusBar;
    }

    // otherwise, current file
    else
    {
        hr = spStream->Read (&fs2, sizeof(fs2), &cbRead);

        // if we can't read the rest of the FrameState, the file is corrupt
        if (FAILED(hr) || (cbRead != sizeof(fs2)))
            return (false);
    }


    // Set the windows size and location and state
    CMainFrame* pMainFrame = AMCGetMainWnd ();
    ASSERT(pMainFrame != NULL);
    if (pMainFrame == NULL)
        return false;


    CAMCApp*    pApp = AMCGetApp();
    pApp->UpdateFrameWindow(true);
    pMainFrame->UpdateChildSystemMenus();

    // the status bar is on the child frame now
//  pMainFrame->ShowStatusBar ((fs2.dwFlags & eFlag_ShowStatusBar) != 0);


    // save the data from the file into the console data
    m_ConsoleData.m_eAppMode     = pApp->GetMode();
    m_ConsoleData.m_eConsoleMode = fs2.eMode;
    m_ConsoleData.m_dwFlags      = fs2.dwFlags;

    InsurePlacementIsOnScreen (fs2.wndplFrame);


    // if we're initializing, defer the actual show until initialization is complete
    // same if script is under control and MMC is hidden
    if (pApp->IsInitializing()
     || ( !pApp->IsUnderUserControl() && !pMainFrame->IsWindowVisible() ) )
    {
        pApp->m_nCmdShow = fs2.wndplFrame.showCmd;
        fs2.wndplFrame.showCmd = SW_HIDE;
    }

    return (pMainFrame->SetWindowPlacement (&fs2.wndplFrame));
}

//+-------------------------------------------------------------------
//
//  Member:     LoadAppMode
//
//  Synopsis:   Read the app mode from the frame and store it in CAMCApp.
//              This is needed during CAMCView::Load.
//
//  Arguments:  None
//
//  Returns:    bool. TRUE if success.
//
//--------------------------------------------------------------------
bool CAMCDoc::LoadAppMode()
{
    TRACE_METHOD(CAMCDoc, LoadAppMode);

    // Just load the application mode from frame data.
    // This assertion shouldn't fail until the definition of FrameState2 changes
    // in a version after 1.1.  At that time, add another cbFrameState2_vXX
    // with the new version's FrameState2 size.
    ASSERT (cbFrameState2_v11 == sizeof (FrameState2));

    if (!AssertNodeManagerIsLoaded())
        return false;

    // Open the stream containing data for the app and frame
    IStreamPtr spStream;
    HRESULT     hr;

    hr = OpenDebugStream (m_spStorage, AMCFrameDataStreamName,
                                  STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &spStream);

    ASSERT(SUCCEEDED(hr) && spStream != NULL);
    if (FAILED(hr))
        return false;


    FrameState2 fs2;
    ULONG cbRead;
    ASSERT (IsValidFileVersion (m_ConsoleData.m_eFileVer));

    // V1.0 file? Migrate it forward
    if (m_ConsoleData.m_eFileVer == FileVer_0100)
    {
        FrameState fs;
        hr = spStream->Read (&fs, sizeof(fs), &cbRead);

        // if we can't read the FrameState, the file is corrupt
        if (FAILED(hr) || (cbRead != sizeof(fs)))
            return (false);

        // migrate FrameState into FrameState2
        fs2.wndplFrame = fs.windowPlacement;

        if (fs.fShowStatusBarInUserMode)
            fs2.dwFlags |=  eFlag_ShowStatusBar;
        else
            fs2.dwFlags &= ~eFlag_ShowStatusBar;
    }

    // otherwise, current file
    else
    {
        hr = spStream->Read (&fs2, sizeof(fs2), &cbRead);

        // if we can't read the rest of the FrameState, the file is corrupt
        if (FAILED(hr) || (cbRead != sizeof(fs2)))
            return (false);
    }

    CAMCApp*    pApp = AMCGetApp();
    pApp->SetMode (fs2.eMode);

    return true;
}

bool CAMCDoc::LoadViews()
// Caller is resposible for calling DeleteContents() and displaying failure
// message if false is returned.
{
    TRACE_METHOD(CAMCDoc, LoadViews);

    if (!AssertNodeManagerIsLoaded())
        return false;

    // Open the tree data stream
    IStreamPtr spStream;
    HRESULT hr = OpenDebugStream(m_spStorage, AMCViewDataStreamName,
        STGM_SHARE_EXCLUSIVE | STGM_READ, &spStream);

    ASSERT(SUCCEEDED(hr) && spStream != NULL);
    if (FAILED(hr))
        return false;

    // Read the number of views persisted
    unsigned short numberOfViews;
    unsigned long bytesRead;
    hr = spStream->Read(&numberOfViews, sizeof(numberOfViews), &bytesRead);
    ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(numberOfViews));
    if (FAILED(hr) || bytesRead != sizeof(numberOfViews))
        return false;

    // Loop thru and create each view
    int failedCount = 0;
    while (numberOfViews--)
    {
        // Read the node id for the root node of the view being created.
        m_MTNodeIDForNewView = 0;
        bool bRet = m_spScopeTree->GetNodeIDFromStream(spStream, &m_MTNodeIDForNewView);

        // Read the node id for the selected node of the view being created.
        ULONG idSel = 0;
        bRet = m_spScopeTree->GetNodeIDFromStream(spStream, &idSel);

        // Read the view id of the view being created.
        hr = spStream->Read(&m_ViewIDForNewView,
                                   sizeof(m_ViewIDForNewView), &bytesRead);
        ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(m_ViewIDForNewView));
        if (FAILED(hr) || bytesRead != sizeof(m_ViewIDForNewView))
            return false;

        if (bRet || m_MTNodeIDForNewView != 0)
        {
            // Create the new view and load its data
            CAMCView* const v = CreateNewView(true);
            m_ViewIDForNewView = 0;
            ASSERT(v != NULL);
            if (v == NULL)
            {
                ++failedCount;
                continue;
            }
            if (!v->Load(*spStream))
                return false;

            v->ScSelectNode(idSel);
            v->SaveStartingSelectedNode();
            v->SetDirty (false);
            //v->GetHistoryList()->Clear();
        }
    }

    // Reset the node ID for future view creation
    m_MTNodeIDForNewView = ROOTNODEID;

    SetModifiedFlag(FALSE);
    return (failedCount == 0);
}

SC CAMCDoc::ScCreateAndLoadView(CPersistor& persistor, int nViewID, const CBookmark& rootNode)
// Caller is resposible for calling DeleteContents() and displaying failure
// message if false is returned.
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScCreateAndLoadView"));

    // Read the node id for the root node of the view being created.
    m_MTNodeIDForNewView = 0;

    MTNODEID idTemp = 0;
    bool bExactMatchFound = false; // out value from GetNodeIDFromBookmark, unused
    sc = m_spScopeTree->GetNodeIDFromBookmark(rootNode, &idTemp, bExactMatchFound);
    if(sc)
        return sc;

    m_MTNodeIDForNewView = idTemp;

    if (m_MTNodeIDForNewView != 0)
    {
        // Read the view id of the view being created.
        m_ViewIDForNewView = nViewID;
        // Create the new view and load its data
        CAMCView* const v = CreateNewView(true);
        m_ViewIDForNewView = 0;

        sc = ScCheckPointers(v, E_FAIL);
        if (sc)
            return sc;

        v->Persist(persistor);

        v->SaveStartingSelectedNode();
        v->SetDirty (false);
        //v->GetHistoryList()->Clear();
    }
    else
    {
        return sc = SC(E_UNEXPECTED);
    }

    // Reset the node ID for future view creation
    m_MTNodeIDForNewView = ROOTNODEID;
    SetModifiedFlag(FALSE);
    return sc;
}


/*+-------------------------------------------------------------------------*
 * ShowIncompatibleFileMessage
 *
 *
 *--------------------------------------------------------------------------*/

static void ShowIncompatibleFileMessage (
    LPCTSTR             pszFilename,
    ConsoleFileVersion  eFileVer)
{
    TCHAR szFileVersion[16];

    wsprintf (szFileVersion, _T("%d.%d%x"),
              GetConsoleFileMajorVersion    (eFileVer),
              GetConsoleFileMinorVersion    (eFileVer),
              GetConsoleFileMinorSubversion (eFileVer));

    CString strMessage;
    FormatString2 (strMessage, IDS_NewerVersionRequired, pszFilename, szFileVersion);

    MMCMessageBox (strMessage);
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::OnOpenDocument
 *
 * WM_OPENDOCUMENT handler for CAMCDoc.
 *--------------------------------------------------------------------------*/

BOOL CAMCDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::OnOpenDocument"));

    sc = ScOnOpenDocument(lpszPathName);
    if(sc) // found an error
    {
        DisplayFileOpenError (sc, lpszPathName);
        return false;
    }

    sc = ScFireEvent(CAMCDocumentObserver::ScDocumentLoadCompleted, this);
    if (sc)
		return false;

	/*
	 * Success!  We shouldn't think that a freshly opened console file is
	 * dirty.  If we do, someone's dirty bit processing is bogus.
	 */
	ASSERT (!IsFrameModified());

	/*
	 * Too many snap-ins leave themselves dirty after a load to leave this
	 * assert in, so we'll trace instead.  Note that this trace doesn't
	 * always indicate a snap-in problem, but it frequently does.
	 */
#ifdef DBG
//	ASSERT (!IsModified());
	if (IsModified())
		TraceErrorMsg (_T("CAMCDoc::IsModified returns true after opening"));
#endif


    return true;
}


/*+-------------------------------------------------------------------------*
 * DisplayFileOpenError
 *
 * Displays an error message if we couldn't open a console file.
 *--------------------------------------------------------------------------*/

int DisplayFileOpenError (SC sc, LPCTSTR pszFilename)
{
    // if it is any of the known errors, use a friendly string.

    if (sc == SC(STG_E_FILENOTFOUND) || sc == ScFromWin32(ERROR_FILE_NOT_FOUND))
        (sc = ScFromMMC(IDS_FileNotFound));
    else if (sc == ScFromMMC(MMC_E_INVALID_FILE))
        (sc = ScFromMMC(IDS_InvalidVersion));
    else if (sc == SC(STG_E_MEDIUMFULL))
        (sc = ScFromMMC(IDS_DiskFull));
    else
    {
        CString strError;
        AfxFormatString1(strError, IDS_UnableToOpenDocumentMessage, pszFilename);
        return (MMCErrorBox(strError));
    }

    return (MMCErrorBox(sc));
}


/*+-------------------------------------------------------------------------*
 * ScGetFileProperties
 *
 * Returns the read-only state of the given file, as well as the creation,
 * last access, and last write times (all optional).
 *
 * We determine if the file is read-only by trying to open the file for
 * writing rather than checking for FILE_ATTRIBUTE_READONLY.  We do this
 * because it will catch more read-only conditions, like the file living
 * on a read-only share or NTFS permissions preventing a write.
 *--------------------------------------------------------------------------*/

static SC ScGetFileProperties (
    LPCTSTR     lpszPathName,           /* I:name of file to check          */
    bool*       pfReadOnly,             /* O:is file read-only?             */
    FILETIME*   pftCreate,              /* O:creation time    (optional)    */
    FILETIME*   pftLastAccess,          /* O:last access time (optional)    */
    FILETIME*   pftLastWrite)           /* O:last write time  (optional)    */
{
    DECLARE_SC (sc, _T("ScGetFileProperties"));

    /*
     * validate inputs (pftCreate, pftLastAccess, and pftLastWrite are optional)
     */
    sc = ScCheckPointers (lpszPathName, pfReadOnly);
    if (sc)
        return (sc);

    /*
     * try to open the file for write; if we can't, the file is read-only
     */
    HANDLE hFile = CreateFile (lpszPathName, GENERIC_WRITE, 0, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    *pfReadOnly = (hFile == INVALID_HANDLE_VALUE);

    /*
     * if read-only then open in read mode so we'll have a handle to pass
     * to GetFileTime
     */
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hFile = CreateFile (lpszPathName, 0, 0, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            sc.FromLastError();
            return (sc);
        }
    }

    /*
     * get the timestamps on the file
     */
    if (!GetFileTime (hFile, pftCreate, pftLastAccess, pftLastWrite))
        sc.FromLastError();

    CloseHandle (hFile);
    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::ScOnOpenDocument
 *
 * PURPOSE: Opens the specified document.
 *
 * PARAMETERS:
 *    LPCTSTR  lpszPathName :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCDoc::ScOnOpenDocument(LPCTSTR lpszPathName)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScOnOpenDocument"));

    // lock AppEvents until this function is done
    LockComEventInterface(AppEvents);

    #define VIVEKJ
    #ifdef VIVEKJ

    // upgrade the console file to the XML version.
    CConsoleFile  consoleFile;
    consoleFile.ScUpgrade(lpszPathName);
    #endif


    USES_CONVERSION;

    // check inputs
    if (lpszPathName == NULL || *lpszPathName == 0)
        return (sc = E_UNEXPECTED);

    if (IsModified())
    {
        TRACE0("Warning: OnOpenDocument replaces an unsaved document.\n");
    }

    if (!AssertNodeManagerIsInitialized())
        return (sc = E_UNEXPECTED);

    /*
     * get the times for the file, as well as its read-only state
     */
    HELPDOCINFO* phdi = GetHelpDocInfo();
    sc = ScCheckPointers (phdi, E_UNEXPECTED);
    if (sc)
        return (sc);

    bool fReadOnly;
    sc = ScGetFileProperties (lpszPathName, &fReadOnly,
                              &phdi->m_ftimeCreate, NULL, &phdi->m_ftimeModify);
    if (sc)
        return (sc);

    // load the document using method from the base class (CConsoleFilePersistor)
    bool bXmlBased = false;
    CXMLDocument xmlDocument;
    IStoragePtr spStorage;
    sc = ScLoadConsole(lpszPathName, bXmlBased, xmlDocument, &spStorage);
    if (sc)
        return (sc);

    if ( bXmlBased )
    {
      // load as XML document
      sc = ScLoadFromDocument(xmlDocument);
      if(sc)
          return sc;
    }
    else
    {
        sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
        if (sc)
            return sc;

        // get the console file's version
        ASSERT (sizeof(m_ConsoleData.m_eFileVer) == sizeof(int));
        sc = m_spScopeTree->GetFileVersion(spStorage, (int*)&m_ConsoleData.m_eFileVer);
        if (sc)
            return sc;

        /*
         * check to see if this file is from a newer MMC
         */
        if (m_ConsoleData.m_eFileVer > FileVer_Current)
        {
            ShowIncompatibleFileMessage (lpszPathName, m_ConsoleData.m_eFileVer);
            return (sc = E_UNEXPECTED);
        }

        // Previous storage should have been closed and released
        ASSERT(m_spStorage == NULL);

        /*
         * Load the string table.
         */
        if (!LoadStringTable (spStorage))
            return (sc = E_UNEXPECTED);

        // Load column settings.
        do
        {
            IStreamPtr spStream;
            sc = OpenDebugStream (spStorage, AMCColumnDataStreamName,
                                  STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &spStream);
            if(sc)
                break;

            if (NULL != m_ConsoleData.m_spPersistStreamColumnData)
                sc = m_ConsoleData.m_spPersistStreamColumnData->Load(spStream);

            ASSERT(NULL != m_ConsoleData.m_spPersistStreamColumnData);

            if (sc.IsError() || (NULL == m_ConsoleData.m_spPersistStreamColumnData) )
                return (sc = E_UNEXPECTED);

        } while ( FALSE );

        // Load view settings.
        do
        {
            IStreamPtr spStream;
            sc = OpenDebugStream (spStorage, AMCViewSettingDataStreamName,
                                  STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &spStream);

            if (sc)
                break;

            IPersistStreamPtr spIPeristStreamViewSettings;
            SC sc = ScGetViewSettingsPersistorStream(&spIPeristStreamViewSettings);
            if (sc)
                break;

            sc = ScCheckPointers(spIPeristStreamViewSettings, E_UNEXPECTED);
            if (sc)
                break;

            sc = spIPeristStreamViewSettings->Load(spStream);
            if (sc)
                break;

        } while ( FALSE );


        // Load the tree
        sc = m_spScopeTreePersist->Load(spStorage);
        if (sc)
        {
            ReleaseNodeManager();
            return sc;
        }

        // Save the new storage
        m_spStorage = spStorage;

        /*
         * make sure the tree expansion happens synchronously
         */
        bool fSyncExpandWasRequired = m_spScopeTree->IsSynchronousExpansionRequired() == S_OK;
        m_spScopeTree->RequireSynchronousExpansion (true);

        // Load the favorites data before loading views and frames,
        // so that when frame/view is created the favorite data is ready.
        if (!LoadFavorites())
        {
            // bhanlon        ReleaseNodeManager();
            m_spScopeTree->RequireSynchronousExpansion (fSyncExpandWasRequired);
            return (sc = E_UNEXPECTED);
        }


        /*
         * Load string table, custom data, views and frame.  Load the
         * custom data (including the icon) before loading the views so
         * the proper icon will be used for the views as they're created.
         */
        /*
         * The LoadAppMode, LoadViews and LoadFrame should be called in that
         * order due to following reason.
         * LoadAppMode reads mode from frame-data and saves it in CAMCApp.
         * The mode is used during LoadViews (in CAMCView::Load) to set the view.
         * LoadFrame again reads the frame-data and calls CAMCApp::UpdateFrameWindow
         * to set toolbar/menus according to the mode.
         */
        if (!LoadCustomData  (m_spStorage) || !LoadAppMode() || !LoadViews() || !LoadFrame())
        {
            // bhanlon        ReleaseNodeManager();
            m_spScopeTree->RequireSynchronousExpansion (fSyncExpandWasRequired);
            return (sc = E_UNEXPECTED);
        }

        m_spScopeTree->RequireSynchronousExpansion (fSyncExpandWasRequired);
    }

    SetModifiedFlag      (false);
    SetFrameModifiedFlag (false);

    SetPhysicalReadOnlyFlag (fReadOnly);

    ASSERT (IsValidFileVersion (m_ConsoleData.m_eFileVer));
    return sc;
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::OnSaveDocument
 *
 * WM_SAVEDOCUMENT handler for CAMCDoc.
 *--------------------------------------------------------------------------*/

BOOL CAMCDoc::OnSaveDocument(LPCTSTR lpszFilename)
{
    DECLARE_SC(sc, _T("CAMCDoc::OnSaveDocument"));

    USES_CONVERSION;

    m_eSaveStatus = eStat_Succeeded;

    // Check for a valid filename
    ASSERT(lpszFilename != NULL && *lpszFilename != 0);
    if (lpszFilename == NULL || *lpszFilename == 0)
    {
        return UnableToSaveDocument();
    }

    // Ask the each view to save any data into its data
    // structures (memory) before calling IPersist*::Save.
    CAMCViewPosition pos = GetFirstAMCViewPosition();
    while (pos != NULL)
    {
        CAMCView* const pAMCView = GetNextAMCView(pos);
        sc = ScCheckPointers(pAMCView, E_UNEXPECTED);
        if (sc)
            return UnableToSaveDocument();
    }

    if (!IsCurrentFileVersion (m_ConsoleData.m_eFileVer))
    {
        // If we've arrived at this point then the user is attempting to save the file
        // from an old format into a new one and we will check to see if the user really
        // wants to do this.

        CString strMessage;

        LPCTSTR pszPathName = m_strPathName;

        // A YES/NO/(CANCEL) dialog asking if the user wants to save the file in the new format
        int nResult;

        /*
         * Bug 277586:  we don't ever want non-authors to see this dialog
         */
        if (AMCGetApp()->GetMode() != eMode_Author)
        {
            // non-authors are only saving console settings,
            // which are always in the current version
            // no need to ask for conversion - original console is not converted anyway.
            nResult = IDYES;
        }
        else if (IsExplicitSave())
        {
            // 2 button YES/NO dialog appears if this is an explicit save
            tstring strVersion = GetCurrentFileVersionAsString();
            FormatString2 (strMessage, IDS_CONVERT_FILE_FORMAT,
                           pszPathName, strVersion.c_str());

            nResult = MMCMessageBox (strMessage, MB_YESNO | MB_DEFBUTTON2);
        }
        else
        {
            // 3 button YES/NO/CANCEL appears if this dialog appears when the program
            // prompts to save changes when the user closes the document
            tstring strVersion = GetCurrentFileVersionAsString();
            FormatString2 (strMessage, IDS_CONVERT_FILE_FORMAT_CLOSE,
                           pszPathName, strVersion.c_str());

            nResult = MMCMessageBox (strMessage, MB_YESNOCANCEL | MB_DEFBUTTON3);
        }

        // If we cancel out
        if ((nResult == IDCANCEL) || ((nResult == IDNO) && IsExplicitSave()))
        {
            // Must set this variable otherwise MMC will delete the file
            m_eSaveStatus = eStat_Cancelled;
            return (false);
        }

        // If this will result in us exiting without saving
        if ((nResult == IDNO) && !IsExplicitSave())
            return (true);
    }

    // if we have more than one view, and we'll force SDI in user mode, prompt
    if ((GetNumberOfPersistedViews() > 1) &&
        (m_ConsoleData.m_eConsoleMode == eMode_User_SDI) &&
        (AMCGetApp()->GetMode()       == eMode_Author))
    {
        switch (MMCMessageBox (IDS_FORCE_SDI_PROMPT, MB_YESNOCANCEL))
        {
            case IDYES:
                /* do nothing */
                break;

            case IDNO:
                m_ConsoleData.m_eConsoleMode = eMode_User_MDI;
                break;

            case IDCANCEL:
                m_eSaveStatus = eStat_Cancelled;
                return (false);
        }
    }

    // save contents to xml document
    CXMLDocument xmlDocument;
    sc = ScSaveToDocument( xmlDocument );
    if (sc)
        return UnableToSaveDocument();

    // save xml document to file
    bool bAuthor = (AMCGetApp()->GetMode() == eMode_Author);
    sc = ScSaveConsole( lpszFilename, bAuthor, xmlDocument);
    if (sc)
        return UnableToSaveDocument();

    SetModifiedFlag      (false);
    SetFrameModifiedFlag (false);

	/*
	 * We shouldn't think that a freshly saved console file is
	 * dirty.  If we do, someone's dirty bit processing is bogus.
	 */
	ASSERT (!IsFrameModified());

	/*
	 * Too many snap-ins leave themselves dirty after a load to leave this
	 * assert in, so we'll trace instead.  Note that this trace doesn't
	 * always indicate a snap-in problem, but it frequently does.
	 */
#ifdef DBG
//	ASSERT (!IsModified());
	if (IsModified())
		TraceErrorMsg (_T("CAMCDoc::IsModified returns true after saving"));
#endif

    // if a save was just done, this can't be read-only

    // NOTE: if MMC adds support for "Save Copy As" we have
    // to determine whether a "Save As" or "Save Copy As"
    // was done before clearing the read-only status
    SetPhysicalReadOnlyFlag (false);
    m_ConsoleData.m_eFileVer = FileVer_Current;

    // Show admin tools on start menu if necessary
    ShowAdminToolsOnMenu(lpszFilename);

    return TRUE;
}



int CAMCDoc::GetNumberOfViews()
{
    TRACE_METHOD(CAMCDoc, GetNumberOfViews);

    CAMCViewPosition pos = GetFirstAMCViewPosition();
    int count = 0;

    while (pos != NULL)
    {
        GetNextAMCView(pos);
        VERIFY (++count);
    }

    return (count);
}


int CAMCDoc::GetNumberOfPersistedViews()
{
    unsigned short cPersistedViews = 0;

    CAMCViewPosition pos = GetFirstAMCViewPosition();

    while (pos != NULL)
    {
        CAMCView* v = GetNextAMCView(pos);

        if (v && v->IsPersisted())
            ++cPersistedViews;
    }

    return (cPersistedViews);
}


CAMCView* CAMCDoc::CreateNewView(bool fVisible, bool bEmitScriptEvents /*= true*/)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::CreateNewView"));
    TRACE_FUNCTION(CAMCDoc::CreateNewView);

    CDocTemplate* pTemplate = GetDocTemplate();
    ASSERT(pTemplate != NULL);

    CChildFrame* pFrame = (CChildFrame*) pTemplate->CreateNewFrame(this, NULL);
    ASSERT_KINDOF (CChildFrame, pFrame);

    if (pFrame == NULL)
    {
        TRACE(_T("Warning: failed to create new frame.\n"));
        return NULL;     // command failed
    }

    bool fOldCreateVisibleState;

    /*
     * If we're going to create the frame invisibly, set a flag in the frame.
     * When this flag is set, the frame will show itself with the
     * SW_SHOWMINNOACTIVE flag instead of the default flag.  Doing this will
     * avoid the side effect of restoring the currently active child frame
     * if it is maximized at the time the new frame is created invisibly.
     */
    // The SW_SHOWMINNOACTIVE was changed to SW_SHOWNOACTIVATE.
    // It does preserve the active window from mentioned side effect,
    // plus it also allows scripts (using Object Moded) to create invisible views,
    // position and then show them as normal (not minimized) windows,
    // thus providing same result as creating visible and then hiding the view.
    // While minimized window must be restored first in order to change their position.
    if (!fVisible)
    {
        fOldCreateVisibleState = pFrame->SetCreateVisible (false);
    }

    /*
     * update the frame as if it is to be visible; we'll hide the frame
     * later if necessary
     */
    // setting visibility to 'true' is required option for MFC to pass control
    // to OnInitialUpdate of child windows.
    pTemplate->InitialUpdateFrame (pFrame, this, true /*fVisible*/);

    if (fVisible)
    {
        // Force drawing of frame and view windows now in case a slow OCX in the result
        // pane delays the initial window update
        pFrame->RedrawWindow();
    }
    else
    {
        pFrame->SetCreateVisible (fOldCreateVisibleState);
        pFrame->ShowWindow (SW_HIDE);

        /*
         * InitialUpdateFrame will update the frame counts.  When it executes
         * the new, to-be-invisible frame will be visible, so it'll be included
         * in the count.  If the new window is the second frame, then the first
         * frame will have "1:" prepended to its title.  This is ugly, so we'll
         * update the frame counts again after the new frame has been hidden
         * to fix all of the existing frames' titles.
         */
        UpdateFrameCounts();
    }

    CAMCView* const v = pFrame->GetAMCView();

    if (!(MMC_NW_OPTION_NOPERSIST & GetNewWindowOptions()))
        SetModifiedFlag();

    ASSERT(v);

	if (!v)
		return v;

	AddObserver(static_cast<CAMCDocumentObserver&>(*v));

    // fire the event to the script
    if (bEmitScriptEvents)
    {
        CAMCApp*  pApp = AMCGetApp();

        // check
        sc = ScCheckPointers(pApp, E_UNEXPECTED);
        if (sc)
            return v;

        // forward
        sc = pApp->ScOnNewView(v);
        if (sc)
            return v;
    }

    return v;
}


void DeletePropertyPages(void)
{
    HWND hWnd = NULL;
    DWORD dwPid = 0;        // Process Id
    DWORD dwTid = 0;        // Thread Id

    while (TRUE)
    {
        USES_CONVERSION;

        // Note: No need to localize this string
        hWnd = ::FindWindowEx(NULL, hWnd, W2T( DATAWINDOW_CLASS_NAME ), NULL);
        if (hWnd == NULL)
            return; // No more windows
        ASSERT(IsWindow(hWnd));

        // Check if the window belongs to the current process
        dwTid = ::GetWindowThreadProcessId(hWnd, &dwPid);
        if (dwPid != ::GetCurrentProcessId())
            continue;

        DataWindowData* pData = GetDataWindowData (hWnd);
        ASSERT (pData != NULL);
        ASSERT (IsWindow (pData->hDlg));

        if (SendMessage(pData->hDlg, WM_COMMAND, IDCANCEL, 0L) != 0)
        {
            DBG_OUT_LASTERROR;
        }

        // Note: For some reason, the send message stays stuck in the threads
        // msg queue causing the sheet not to dismiss itself.  By posting a another
        // message( it could be anything), it kick starts the queue and the send message
        // goes through.
        ::PostMessage(pData->hDlg, WM_COMMAND, IDCANCEL, 0L);
    }
}


void CAMCDoc::DeleteContents()
{
    TRACE_METHOD(CAMCDoc, DeleteContents);

    CDocument::DeleteContents();
}


void CAMCDoc::DeleteHelpFile ()
{
    /*
     *  Delete the help file on closing a console file
     */

    // Get a node callback interface
    ASSERT(m_spScopeTree != NULL);
    // If this asserts - the document is in invalid state.
    // Most probably it's because our "Load" procedures did not perform proper
    // cleanup when we failed to load the document
    INodeCallbackPtr spNodeCallback;

    if (m_spScopeTree != NULL)
    {
        m_spScopeTree->QueryNodeCallback(&spNodeCallback);
        ASSERT(spNodeCallback != NULL);
    }

    // fill in file name and send the delete request

    if (spNodeCallback != NULL)
    {
        USES_CONVERSION;
        GetHelpDocInfo()->m_pszFileName = T2COLE(GetPathName());
        spNodeCallback->Notify(NULL, NCLBK_DELETEHELPDOC, (LPARAM)GetHelpDocInfo(), NULL);
    }
}


void CAMCDoc::OnCloseDocument()
{
    DECLARE_SC(sc, TEXT("CAMCDoc::OnCloseDocument"));

    TRACE_METHOD(CAMCDoc, OnCloseDocument);

    // Inform nodemgr about doc-closing (should change this to observer object)
    do
    {
        sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
        if (sc)
            break;

        INodeCallbackPtr spNodeCallback;
        sc = m_spScopeTree->QueryNodeCallback(&spNodeCallback);
        if (sc)
            break;

        sc = ScCheckPointers(spNodeCallback, E_UNEXPECTED);
        if (sc)
            break;

        sc = spNodeCallback->DocumentClosing();
        if (sc)
            break;

    } while ( FALSE );

    if (sc)
        sc.TraceAndClear();

    CAMCApp*  pApp = AMCGetApp();

    // check
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        sc.TraceAndClear();
    else
    {
        // forward
        sc = pApp->ScOnCloseDocument(this);
        if (sc)
            sc.TraceAndClear();
    }

    // If we are not instantiated as OLESERVER check for open property sheets.
    if (! pApp->IsMMCRunningAsOLEServer() && FArePropertySheetsOpen(NULL))
    {
        CString strMsg, strTitle;

        if (strMsg.LoadString(IDS_MMCWillCancelPropertySheets) &&
            strTitle.LoadString(IDS_WARNING))
            ::MessageBox(NULL, strMsg, strTitle, MB_OK | MB_ICONWARNING);
    }

    DeletePropertyPages();
    DeleteHelpFile ();

    CDocument::OnCloseDocument();
}


BOOL CAMCDoc::SaveModified()
{
    BOOL    fDocModified   = IsModified();
    BOOL    fFrameModified = IsFrameModified();

    // if the file is not read-only and it is modified
    if (!IsReadOnly() && (fDocModified || fFrameModified))
    {
        int idResponse;
        bool fUserMode = (AMCGetApp()->GetMode() != eMode_Author);
        bool fSaveByUserDecision = false;

        // silent saves for the various flavors of user mode
        if (fUserMode)
            idResponse = IDYES;

        // silent saves if the frame was modified but the document wasn't...
        else if (fFrameModified && !fDocModified)
        {
            /*
             * ...unless the console wasn't modified.  This will happen
             * if the user ran MMC without opening an existing console file
             * and then moved the frame window.
             */
            // ...unless the console wasn't modified.
            if (m_strPathName.IsEmpty())
                idResponse = IDNO;
            else
                idResponse = IDYES;
        }

        // otherwise, prompt
        else
        {
            CString prompt;
            FormatString1(prompt, IDS_ASK_TO_SAVE, m_strTitle);
            idResponse = AfxMessageBox(prompt, MB_YESNOCANCEL, AFX_IDP_ASK_TO_SAVE); // dont change to MMCMessageBox - different signature.
            fSaveByUserDecision = true;
        }

        switch (idResponse)
        {
            case IDCANCEL:
                return FALSE;       // don't continue

            case IDYES:
                // If so, either Save or Update, as appropriate
                // (ignore failures in User mode)

                // This save is not explicit and shows up when the user closes a modified
                // document. Set it as such. This will result in a different dialog
                // a few functions in.
                SetExplicitSave(false);
                if (!DoFileSave() && fSaveByUserDecision)
                {
                    // Restore to the default explicit save
                    SetExplicitSave(true);
                    return FALSE;       // don't continue
                }

                // Restore to the default explicit save
                SetExplicitSave(true);
                break;

            case IDNO:
                // If not saving changes, revert the document
                break;

            default:
                ASSERT(FALSE);
                break;
        }

    }

    // At this point we are committed to closing, so give each AMCView
    // a chance to do its clean-up work
    CAMCViewPosition pos = GetFirstAMCViewPosition();
    while (pos != NULL)
    {
        CAMCView* const pView = GetNextAMCView(pos);

        if (pView != NULL)
            pView->CloseView();
    }

    return TRUE;    // keep going
}



#if (_MFC_VER > 0x0600)
#error CAMCDoc::DoSave was copied from CDocument::DoSave from MFC 6.0.
#error The MFC version has changed.  See if CAMCDoc::DoSave needs to be updated.
#endif

BOOL CAMCDoc::DoSave(LPCTSTR lpszPathName, BOOL bReplace)
    // Save the document data to a file
    // lpszPathName = path name where to save document file
    // if lpszPathName is NULL then the user will be prompted (SaveAs)
    // note: lpszPathName can be different than 'm_strPathName'
    // if 'bReplace' is TRUE will change file name if successful (SaveAs)
    // if 'bReplace' is FALSE will not change path name (SaveCopyAs)
{
    CString newName = lpszPathName;
    if (newName.IsEmpty())
    {
        CDocTemplate* pTemplate = GetDocTemplate();
        ASSERT(pTemplate != NULL);

        newName = m_strPathName;
        if (bReplace && newName.IsEmpty())
        {
            newName = m_strTitle;
#ifndef _MAC
            // check for dubious filename
            int iBad = newName.FindOneOf(_T(" #%;/\\"));
#else
            int iBad = newName.FindOneOf(_T(":"));
#endif
            if (iBad != -1)
                newName.ReleaseBuffer(iBad);

#ifndef _MAC
            // append the default suffix if there is one
            CString strExt;
            if (pTemplate->GetDocString(strExt, CDocTemplate::filterExt) &&
              !strExt.IsEmpty())
            {
                ASSERT(strExt[0] == '.');
                newName += strExt;
            }
#endif
        }

        if (!AfxGetApp()->DoPromptFileName(newName,
          bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
          OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, pTemplate))
            return FALSE;       // don't even attempt to save
    }

    CWaitCursor wait;

    if (!OnSaveDocument(newName))
    {
        // This is the modified MMC implementation
#ifdef MMC_DELETE_EXISTING_FILE     // See bug 395006
        if ((lpszPathName == NULL) && (m_eSaveStatus != eStat_Cancelled))
        {
            // be sure to delete the file
            try
            {
                CFile::Remove(newName);
            }
            catch (CException* pe)
            {
                TRACE0("Warning: failed to delete file after failed SaveAs.\n");
                pe->Delete();
            }
        }
#endif
        return FALSE;
    }

    // if changing the name of the open document
    if (bReplace)
    {
        /*
         *  Delete the help file for this console file before
         *  changing its name, because the help file can't be
         *  located once the old name is lost.
         */
        DeleteHelpFile ();

        // reset the title and change the document name
        SetPathName(newName);
    }

    return TRUE;        // success
}


BOOL CAMCDoc::IsModified()
{
    TRACE_METHOD(CAMCDoc, IsModified);

    BOOL const bModified = /*CDocument::IsModified() || */
                  (m_spScopeTreePersist != NULL && m_spScopeTreePersist->IsDirty() != S_FALSE);
    if (bModified)
        return TRUE;

    // Loop thru and save each view
    CAMCViewPosition pos = GetFirstAMCViewPosition();
    while (pos != NULL)
    {
        // Get the view and skip if its the active view
        CAMCView* const v = GetNextAMCView(pos);

        if (v && v->IsDirty())
            return TRUE;
    }

    // The views should be asked about dirty before
    // asking the columns.
    if ( (NULL != m_ConsoleData.m_spPersistStreamColumnData) &&
         (S_OK == m_ConsoleData.m_spPersistStreamColumnData->IsDirty()) )
        return TRUE;

    // View data.
    IPersistStreamPtr spIPeristStreamViewSettings;
    SC sc = ScGetViewSettingsPersistorStream(&spIPeristStreamViewSettings);
    if ( (! sc.IsError()) &&
         (spIPeristStreamViewSettings != NULL) )
    {
        sc = spIPeristStreamViewSettings->IsDirty();
        if (sc == S_OK)
            return TRUE;

        sc.TraceAndClear();
    }

    return CDocument::IsModified();
}

void CAMCDoc::OnUpdateFileSave(CCmdUI* pCmdUI)
{
    pCmdUI->Enable (!IsReadOnly());
}


void CAMCDoc::OnConsoleAddremovesnapin()
{
    ASSERT(m_spScopeTree != NULL);

    // Can't run snap-in manager with active property sheets
    CString strMsg;
    LoadString(strMsg, IDS_SNAPINMGR_CLOSEPROPSHEET);
    if (FArePropertySheetsOpen(&strMsg))
        return;

    m_spScopeTree->RunSnapIn(AfxGetMainWnd()->m_hWnd);

    ::CoFreeUnusedLibraries();
}

void CAMCDoc::OnUpdateConsoleAddremovesnapin(CCmdUI* pCmdUI)
{
    pCmdUI->Enable (m_spScopeTree != NULL);
}



/*--------------------------------------------------------------------------*
 * CAMCDoc::SetMode
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCDoc::SetMode (ProgramMode eMode)
{
    /*
     * only set the modified flag if something actually changed
     */
    if (m_ConsoleData.m_eConsoleMode != eMode)
    {
        // should only be able to get here in author mode
        ASSERT (AMCGetApp()->GetMode() == eMode_Author);
        ASSERT (IsValidProgramMode (eMode));

        m_ConsoleData.m_eConsoleMode = eMode;
        SetModifiedFlag ();
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::SetConsoleFlag
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCDoc::SetConsoleFlag (ConsoleFlags eFlag, bool fSet)
{
    DWORD dwFlags = m_ConsoleData.m_dwFlags;

    if (fSet)
        dwFlags |=  eFlag;
    else
        dwFlags &= ~eFlag;

    /*
     * only set the modified flag if something actually changed
     */
    if (m_ConsoleData.m_dwFlags != dwFlags)
    {
        m_ConsoleData.m_dwFlags = dwFlags;
        SetModifiedFlag ();
    }
}

/*+-------------------------------------------------------------------------*
 *
 * mappedModes
 *
 * PURPOSE: provides map to be used when persisting ProgramMode enumeration
 *
 * NOTE:    do not remove/ change items unless you're sure no console
 *          files will be broken
 *
 *+-------------------------------------------------------------------------*/
static const EnumLiteral mappedModes[] =
{
    { eMode_Author,     XML_ENUM_PROGRAM_MODE_AUTHOR   } ,
    { eMode_User,       XML_ENUM_PROGRAM_MODE_USER     } ,
    { eMode_User_MDI,   XML_ENUM_PROGRAM_MODE_USER_MDI } ,
    { eMode_User_SDI,   XML_ENUM_PROGRAM_MODE_USER_SDI } ,
};

/*+-------------------------------------------------------------------------*
 *
 * CAMCDoc::Persist
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCDoc::Persist(CPersistor& persistor)
{
    DECLARE_SC (sc, _T("CAMCDoc::Persist"));

    CAMCApp*    pApp = AMCGetApp();

    // check required pointers before going any further
    sc = ScCheckPointers(m_spStringTable ? pApp : NULL, // + workaround to check more pointers
                         m_ConsoleData.m_pXMLPersistColumnData,
                         m_spScopeTree ?   GetFavorites() : NULL, // + same workaround ^
                         E_POINTER);
    if (sc)
        sc.Throw();

    // persist version of the document
    CStr strFileVer = 0.;
    if (persistor.IsStoring())
    {
        strFileVer = GetCurrentFileVersionAsString().c_str();

        GUID  guidConsoleId;
        sc = CoCreateGuid(&guidConsoleId);
        if (sc)
            sc.Throw();

        // this parameter is also updated in IDocConfig implementation
        // update that code when changing following lines
        CPersistor persistorGuid(persistor, XML_TAG_CONSOLE_FILE_UID);
        persistorGuid.PersistContents(guidConsoleId);
    }
    persistor.PersistAttribute(XML_ATTR_CONSOLE_VERSION, strFileVer);
    if (persistor.IsLoading())
    {
        // 'decode' the version
        LPCTSTR pstrStart = strFileVer;
        LPTSTR  pstrStop =  const_cast<LPTSTR>(pstrStart);

        UINT uiMajorVer = _tcstol(pstrStart, &pstrStop, 10) ;

        UINT uiMinorVer = 0;
        if (pstrStop != pstrStart && *pstrStop == '.')
        {
            pstrStart = pstrStop + 1;
            uiMinorVer = _tcstol(pstrStart, &pstrStop, 10) ;
        }

        UINT uiMinorSubVer = 0;
        if (pstrStop != pstrStart && *pstrStop == '.')
        {
            pstrStart = pstrStop + 1;
            uiMinorVer = _tcstol(pstrStart, &pstrStop, 10) ;
        }

        ConsoleFileVersion eVersion = (ConsoleFileVersion)MakeConsoleFileVer_(uiMajorVer,
                                                                              uiMinorVer,
                                                                              uiMinorSubVer);

        m_ConsoleData.m_eFileVer = eVersion;

        // BUGBUG: this needs to be changed when we implement 'dynamic' SC messages
        if (eVersion != FileVer_Current)
            sc.Throw(E_UNEXPECTED);
    }


    // Create a storage for binaries
    // This will create "detached" XML element which may be used by persistor's
    // childs to store binary informatio.
    // (The element is attached to XML document by calling "CommitBinaryStorage()" )
    if (persistor.IsStoring())
        persistor.GetDocument().CreateBinaryStorage();
    else
        persistor.GetDocument().LocateBinaryStorage();

    /*
     * make sure the tree expansion happens synchronously
     */
    bool fSyncExpandWasRequired = m_spScopeTree->IsSynchronousExpansionRequired() == S_OK;
    m_spScopeTree->RequireSynchronousExpansion (true);

    // historically both loading and saving is to be done in certain order
    // steps are ordered by storing order
    const int STEP_FRAME        = 1;
    const int STEP_VIEWS        = 2;
    const int STEP_APP_MODE     = 3;
    const int STEP_CUST_DATA    = 4;
    const int STEP_FAVORITES    = 5;
    const int STEP_SCOPE_TREE   = 6;
    const int STEP_VIEW_DATA    = 7;
    const int STEP_COLUMN_DATA  = 8;
    const int STEP_STRING_TABLE = 9;
    const int MIN_STEP = 1;
    const int MAX_STEP = 9;
    for (int iStep = persistor.IsStoring() ? MIN_STEP : MAX_STEP;
         persistor.IsStoring() ? (iStep <= MAX_STEP) : (iStep >= MIN_STEP);
         persistor.IsStoring() ? ++iStep : --iStep
        )
    {
        switch(iStep)
        {
        case STEP_FRAME:
            PersistFrame(persistor);
            break;
        case STEP_VIEWS:
            PersistViews(persistor);
            break;
        case STEP_APP_MODE:
            if (persistor.IsLoading())
            {
                // restore proper application mode
                ProgramMode eMode;

                // create wrapper to persist enumeration values as strings
                CXMLEnumeration modeValuePersistor(eMode, mappedModes, countof(mappedModes));

                // persist the wrapper
                persistor.PersistAttribute(XML_ATTR_APPLICATION_MODE, modeValuePersistor);

                pApp->SetMode(eMode);
            }
            break;
        case STEP_CUST_DATA:
            PersistCustomData (persistor);
            break;
        case STEP_FAVORITES:
            persistor.Persist(*GetFavorites());
            break;
        case STEP_SCOPE_TREE:
            // IDocConfig relies on tree to be under the document.
            // revisit that code if you do the change here
            sc = m_spScopeTree->Persist(reinterpret_cast<HPERSISTOR>(&persistor));
            if (sc)
                sc.Throw();
            break;
        case STEP_VIEW_DATA:
            {
               INodeCallbackPtr spNodeCallback;
               sc = m_spScopeTree->QueryNodeCallback(&spNodeCallback);
               if (sc)
                   sc.Throw();

               sc = ScCheckPointers(spNodeCallback, E_UNEXPECTED);
               if (sc)
                   sc.Throw();

               CXMLObject *pXMLViewSettings = NULL;
               sc = spNodeCallback->QueryViewSettingsPersistor(&pXMLViewSettings);
               if (sc)
                   sc.Throw();

               sc = ScCheckPointers(pXMLViewSettings, E_UNEXPECTED);
               if (sc)
                   sc.Throw();

                persistor.Persist(*pXMLViewSettings);
            }
            break;
        case STEP_COLUMN_DATA:
            persistor.Persist(*m_ConsoleData.m_pXMLPersistColumnData);
            break;
        case STEP_STRING_TABLE:
            CMasterStringTable *pMasterStringTable = dynamic_cast<CMasterStringTable *>((IStringTablePrivate *)m_spStringTable);
            if(!pMasterStringTable)
            {
                sc = E_UNEXPECTED;
                sc.Throw();
            }
            persistor.Persist(*pMasterStringTable);
            break;
        }
    }

    m_spScopeTree->RequireSynchronousExpansion (fSyncExpandWasRequired);
    SetModifiedFlag      (false);
    SetFrameModifiedFlag (false);

	/*
	 * We shouldn't think that a freshly saved console file is
	 * dirty.  If we do, someone's dirty bit processing is bogus.
	 */
	ASSERT (!IsFrameModified());

	/*
	 * Too many snap-ins leave themselves dirty after a load to leave this
	 * assert in, so we'll trace instead.  Note that this trace doesn't
	 * always indicate a snap-in problem, but it frequently does.
	 */
#ifdef DBG
//	ASSERT (!IsModified());
	if (IsModified())
		TraceErrorMsg (_T("CAMCDoc::IsModified returns true after %s"),
					   persistor.IsLoading() ? _T("opening") : _T("saving"));
#endif

    // The element used to gather binary information is attached to XML document here
    // Physically it will reside after all elements already added to persistor
    if (persistor.IsStoring())
        persistor.GetDocument().CommitBinaryStorage();
}

void CAMCDoc::PersistViews(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::PersistViews"));

    if (persistor.IsLoading())
    {
        // Read templates for new views
        CViewTemplateList view_list(XML_TAG_VIEW_LIST);
        persistor.Persist(view_list);

        // Get the means for enumerating loaded collection
        CViewTemplateList::List_Type &rList = view_list.GetList();
        CViewTemplateList::List_Type::iterator it;

        // Enumerate all the views to be created
        // Create them one-by-one
        for (it = rList.begin(); it != rList.end(); ++it)
        {
            // extract information for the new view
            int iViewID = it->first;
            const CBookmark& pbm = it->second.first;
            CPersistor& v_persistor = it->second.second;

            // create it!
            sc = ScCreateAndLoadView(v_persistor, iViewID, pbm);
            if (sc)
                sc.Throw();
        }
    }
    else // if (persistor.IsStoring())
    {
        CPersistor persistorViews(persistor, XML_TAG_VIEW_LIST);

		/*
		 * Bug 3504: enumerate views in z-order (bottom-to-top) so the
		 * z-order will be restored correctly on reload
		 */
		CMainFrame* pMainFrame = AMCGetMainWnd();
		sc = ScCheckPointers (pMainFrame, E_UNEXPECTED);
		if (sc)
			sc.Throw();

		/*
		 * get the top-most MDI child
		 */
		CWnd* pwndMDIChild = pMainFrame->MDIGetActive();
		sc = ScCheckPointers (pwndMDIChild, E_UNEXPECTED);
		if (sc)
			sc.Throw();

		/*
		 * iterate through each of the MDI children
		 */
		for (pwndMDIChild  = pwndMDIChild->GetWindow (GW_HWNDLAST);
			 pwndMDIChild != NULL;
			 pwndMDIChild  = pwndMDIChild->GetNextWindow (GW_HWNDPREV))
		{
			/*
			 * turn the generic CMDIChildWnd into a CChildFrame
			 */
			CChildFrame* pChildFrame = dynamic_cast<CChildFrame*>(pwndMDIChild);
			sc = ScCheckPointers (pChildFrame, E_UNEXPECTED);
			if (sc)
				sc.Throw();

			/*
			 * get the view for this child frame
			 */
			CAMCView* pwndView = pChildFrame->GetAMCView();
			sc = ScCheckPointers (pwndView, E_UNEXPECTED);
			if (sc)
				sc.Throw();

            // skip those not persistible
            if ( !pwndView->IsPersisted() )
                continue;

			/*
			 * persist the view
			 */
			persistorViews.Persist (*pwndView);
		}
    }
}


void CAMCDoc::PersistFrame(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::PersistFrame"));

    CFrameState fs2 (m_ConsoleData.m_eConsoleMode, m_ConsoleData.m_dwFlags);
    ASSERT (fs2.wndplFrame.length == sizeof (WINDOWPLACEMENT));

    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers (pMainFrame, E_UNEXPECTED);
    if (sc)
        sc.Throw();

    if (persistor.IsStoring())
    {
        // Get the attributes of the window.
        if (!pMainFrame->GetWindowPlacement (&fs2.wndplFrame))
            sc.Throw(E_FAIL);

        if (fs2.wndplFrame.showCmd == SW_SHOWMINIMIZED)
            fs2.wndplFrame.showCmd =  SW_SHOWNORMAL;
    }

    persistor.Persist(fs2);

    // this application setting (AppMode) is resored in AMCDoc::Persist, but saved/loaded here
    // create wrapper to persist enumeration values as strings
    CXMLEnumeration modeValuePersistor(m_ConsoleData.m_eConsoleMode, mappedModes, countof(mappedModes));
    // persist the wrapper
    persistor.PersistAttribute(XML_ATTR_APPLICATION_MODE, modeValuePersistor);

    if (persistor.IsLoading())
    {
        // Set the windows size and location and state
        CAMCApp*    pApp = AMCGetApp();
        pApp->UpdateFrameWindow(true);
        pMainFrame->UpdateChildSystemMenus();

        // the status bar is on the child frame now
        //  pMainFrame->ShowStatusBar ((fs2.dwFlags & eFlag_ShowStatusBar) != 0);

        // save the data from the file into the console data
        m_ConsoleData.m_eAppMode     = pApp->GetMode();
        m_ConsoleData.m_dwFlags      = fs2.dwFlags;

        InsurePlacementIsOnScreen (fs2.wndplFrame);

        // if we're initializing, defer the actual show until initialization is complete
        // same if script is under control and MMC is hidden
        if (pApp->IsInitializing()
         || ( !pApp->IsUnderUserControl() && !pMainFrame->IsWindowVisible() ) )
        {
            pApp->m_nCmdShow = fs2.wndplFrame.showCmd;
            fs2.wndplFrame.showCmd = SW_HIDE;
        }

        if (!pMainFrame->SetWindowPlacement (&fs2.wndplFrame))
            sc.Throw(E_FAIL);
    }
}

/*--------------------------------------------------------------------------*
 * CDocument::DoFileSave
 *
 * This is almost identical to CDocument::DoFileSave.  We just override it
 * here because we want to display a message for a read-only file before
 * throwing up the Save As dialog.
 *--------------------------------------------------------------------------*/

BOOL CAMCDoc::DoFileSave()
{
    DWORD dwAttrib = GetFileAttributes(m_strPathName);

    // attributes does not matter for user modes - it does not
    // save to the original console file anyway
    if ((AMCGetApp()->GetMode() == eMode_Author) &&
        (dwAttrib != 0xFFFFFFFF) &&
        (dwAttrib & FILE_ATTRIBUTE_READONLY))
    {
        CString strMessage;
        FormatString1 (strMessage, IDS_CONSOLE_READONLY, m_strPathName);
        MMCMessageBox (strMessage);

        // we do not have read-write access or the file does not (now) exist
        if (!DoSave(NULL))
        {
            TRACE0("Warning: File save with new name failed.\n");
            return FALSE;
        }
    }
    else
    {
        if (!DoSave(m_strPathName))
        {
            TRACE0("Warning: File save failed.\n");
            return FALSE;
        }
    }
    return TRUE;
}



/*--------------------------------------------------------------------------*
 * CAMCDoc::GetDefaultMenu
 *
 *
 *--------------------------------------------------------------------------*/

HMENU CAMCDoc::GetDefaultMenu()
{
    return (AMCGetApp()->GetMenu ());
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::GetCustomIcon
 *
 * Returns the small or large custom icon for the console.  Ownership of and
 * deletion responsibility for the icon is retained by CAMCDoc.
 *--------------------------------------------------------------------------*/

HICON CAMCDoc::GetCustomIcon (bool fLarge, CString* pstrIconFile, int* pnIconIndex) const
{
	DECLARE_SC (sc, _T("CAMCDoc::ScGetCustomIcon"));

    /*
     * if caller wants either the icon filename or index returned, get them
     */
    if ((pstrIconFile != NULL) || (pnIconIndex != NULL))
    {
        CPersistableIconData IconData;
        m_CustomIcon.GetData (IconData);

        if (pstrIconFile != NULL)
            *pstrIconFile = IconData.m_strIconFile.data();

        if (pnIconIndex != NULL)
            *pnIconIndex = IconData.m_nIndex;
    }

    /*
     * return the icon (m_CustomIcon will hold the reference for the
	 * caller)
     */
	CSmartIcon icon;
	sc = m_CustomIcon.GetIcon ((fLarge) ? 32 : 16, icon);
	if (sc)
		return (NULL);

	return (icon);
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::SetCustomIcon
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCDoc::SetCustomIcon (LPCTSTR pszIconFile, int nIconIndex)
{
    DECLARE_SC (sc, _T("CAMCDoc::SetCustomIcon"));

    CPersistableIconData IconData (pszIconFile, nIconIndex) ;

    /*
     * if there's no change, bail
     */
    if (m_CustomIcon == IconData)
        return;

    m_CustomIcon = IconData;

    HICON 		hLargeIcon = GetCustomIcon (true  /*fLarge*/);
    HICON		hSmallIcon = GetCustomIcon (false /*fLarge*/);
    CMainFrame* pMainFrame = AMCGetMainWnd();

    sc = ScCheckPointers (hLargeIcon, hSmallIcon, pMainFrame, E_UNEXPECTED);
    if (sc)
        return;

    /*
     * change the icon on the frame
     */
    pMainFrame->SetIconEx (hLargeIcon, true);
    pMainFrame->SetIconEx (hSmallIcon, false);

    /*
     * change the icon on each MDI window
     */
    CWnd* pMDIChild = pMainFrame->MDIGetActive();

    while (pMDIChild != NULL)
    {
        ASSERT_KINDOF (CMDIChildWnd, pMDIChild);
        pMDIChild->SetIcon (hLargeIcon, true);
        pMDIChild->SetIcon (hSmallIcon, false);
        pMDIChild = pMDIChild->GetWindow (GW_HWNDNEXT);
    }

    SetModifiedFlag();
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadCustomData
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadCustomData (IStorage* pStorage)
{
    HRESULT hr;
    IStoragePtr spCustomDataStorage;
    hr = OpenDebugStorage (pStorage, g_pszCustomDataStorage,
                                STGM_SHARE_EXCLUSIVE | STGM_READ,
                                &spCustomDataStorage);


    if (FAILED (hr))
        return (true);

    LoadCustomIconData  (spCustomDataStorage);
    LoadCustomTitleData (spCustomDataStorage);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadCustomIconData
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadCustomIconData (IStorage* pStorage)
{
    HRESULT hr = m_CustomIcon.Load (pStorage);

    if (FAILED (hr))
        return (false);

    /*
     * If we get here, we have a custom icon.  The view windows
     * (MDI children) haven't been created yet -- they'll get the
     * right icons automatically.  The main frame, however, already
     * exists, so we have to explicitly set its icon here.
     */
    CWnd* pMainWnd = AfxGetMainWnd();
    pMainWnd->SetIcon (GetCustomIcon (true),  true);
    pMainWnd->SetIcon (GetCustomIcon (false), false);

    return (true);
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadCustomTitleData
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadCustomTitleData (IStorage* pStorage)
{
    do  // not a loop
    {
        /*
         * Open the custom title data stream.  It may not exist, and
         * that's OK if it doesn't.  It just means we don't have a
         * custom title.
         */
        USES_CONVERSION;
        HRESULT hr;
        IStreamPtr spStream;
        hr = OpenDebugStream (pStorage, AMCCustomTitleStreamName,
                                   STGM_SHARE_EXCLUSIVE | STGM_READ,
                                   &spStream);

        BREAK_ON_FAIL (hr);

        try
        {
            /*
             * Read the stream version
             */
            DWORD dwVersion;
            *spStream >> dwVersion;

            /*
             * if this is the beta custom title format, migrate it forward
             */
            switch (dwVersion)
            {
                case 0:
                {
                    /*
                     * Read the length (in bytes) of the title
                     */
                    WORD cbTitle;
                    *spStream >> cbTitle;
                    const WORD cchTitle = cbTitle / sizeof (WCHAR);

                    /*
                     * Read the title
                     */
                    std::auto_ptr<WCHAR> spwzWideTitle (new WCHAR[cchTitle + 1]);
                    LPWSTR pwzWideTitle = spwzWideTitle.get();

                    DWORD cbRead;
                    hr = spStream->Read (pwzWideTitle, cbTitle, &cbRead);
                    BREAK_ON_FAIL (hr);

                    if (cbRead != cbTitle)
                        break;

                    /*
                     * terminate and convert the title string
                     */
                    pwzWideTitle[cchTitle] = 0;
                    if (m_pstrCustomTitle != NULL)
                        *m_pstrCustomTitle = W2T (pwzWideTitle);
                    break;
                }

                case 1:
                    if (m_pstrCustomTitle != NULL)
                        *spStream >> (*m_pstrCustomTitle);
                    break;

                default:
                    ASSERT (false);
                    break;
            }
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
            break;
        }
        catch (CMemoryException* pe)
        {
            pe->Delete();
            _com_issue_error (E_OUTOFMEMORY);
        }
    } while (false);

    return (true);
}



bool CAMCDoc::HasCustomTitle () const
{
    if(!m_pstrCustomTitle)
        return false;

    return (!m_pstrCustomTitle->str().empty());

}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadStringTable
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadStringTable (IStorage* pStorage)
{
    DECLARE_SC (sc, _T("CAMCDoc::LoadStringTable"));

    /*
     * open the string table storage
     */
    IStoragePtr spStringTableStg;
    HRESULT hr = OpenDebugStorage (pStorage, AMCStringTableStorageName,
                                        STGM_SHARE_EXCLUSIVE | STGM_READ,
                                        &spStringTableStg);


    /*
     * If there's no string table, things are OK.  We allow this so
     * we can continue to open older console files.
     */
    if (hr == STG_E_FILENOTFOUND)
        return (true);

    if (SUCCEEDED (hr))
    {
        /*
         * read the string table from the storage
         */
        try
        {
            CMasterStringTable *pMasterStringTable = dynamic_cast<CMasterStringTable *>((IStringTablePrivate *)m_spStringTable);
            if(!pMasterStringTable)
            {
                sc = E_UNEXPECTED;
                sc.Throw();
            }

            *spStringTableStg >> *pMasterStringTable;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (SUCCEEDED (hr));
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::SetCustomTitle
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCDoc::SetCustomTitle (CString strNewTitle)
{
    DECLARE_SC (sc, _T("CAMCDoc::SetCustomTitle"));

    if(!m_pstrCustomTitle)
        return;

    /*
     * if there's no change, just short out
     */
    if ((*m_pstrCustomTitle) == strNewTitle)
        return;

    /*
     * copy the new custom title
     */
    (*m_pstrCustomTitle) = strNewTitle;

    /*
     * force the frame to update
     */
    CMainFrame* pMainFrame = AMCGetMainWnd();
    sc = ScCheckPointers (pMainFrame, E_UNEXPECTED);
    if (sc)
        return;

    pMainFrame->OnUpdateFrameTitle (false);

    SetModifiedFlag();
}


/*+-------------------------------------------------------------------------*
 * CAMCDoc::GetCustomTitle
 *
 *
 *--------------------------------------------------------------------------*/

CString CAMCDoc::GetCustomTitle() const
{
    if (HasCustomTitle())
        return (m_pstrCustomTitle->data());

    CString strTitle = GetTitle();

    /*
     * strip the extension (extensions, including a separator,
     * are 4 characters or less)
     */
    int nExtSeparator = strTitle.ReverseFind (_T('.'));

    if ((nExtSeparator != -1) && ((strTitle.GetLength()-nExtSeparator) <= 4))
        strTitle = strTitle.Left (nExtSeparator);

    return (strTitle);
}

/*+-------------------------------------------------------------------------*
 * CAMCDoc::GetStringTable
 *
 *
 *--------------------------------------------------------------------------*/

IStringTablePrivate* CAMCDoc::GetStringTable() const
{
    return m_spStringTable;
}

/*+-------------------------------------------------------------------------*
 * CAMCDoc::LoadFavorites
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCDoc::LoadFavorites ()
{
    ASSERT(m_spStorage != NULL);

    // Open the stream for the cache
    IStreamPtr spStream;
    HRESULT hr = OpenDebugStream(m_spStorage, AMCFavoritesStreamName,
                     STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"FavoritesStream", &spStream);
    if (FAILED(hr)) // did not find the stream - could be an older version.
        return hr;

    hr = GetFavorites()->Read(spStream);

    return (SUCCEEDED (hr));
}


void ShowAdminToolsOnMenu(LPCTSTR lpszFilename)
{
    static const TCHAR szAdminKey[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced");
    static const TCHAR szAdminValue[] = _T("StartMenuAdminTools");
    static const TCHAR szBroadcastParam[] = _T("ShellMenu");
    static const TCHAR szYes[] = _T("YES");

    CString strPath(lpszFilename);
    int nLastSepIndex = strPath.ReverseFind (_T('\\'));

    if (nLastSepIndex != -1)
    {
        // if we got "d:\filename", make sure to include the trailing separator
        if (nLastSepIndex < 3)
            nLastSepIndex++;

        // Form full path name (accounting for current directory info)
        TCHAR   szFullPathName[MAX_PATH];
        GetFullPathName (strPath.Left(nLastSepIndex), countof(szFullPathName),
                         szFullPathName, NULL);

        // if saving to admin tools
        if (AMCGetApp()->GetDefaultDirectory() == szFullPathName)
        {
            // set reg key to add admin tools to start menu
            HKEY hkey;
            long r = RegOpenKeyEx (HKEY_CURRENT_USER, szAdminKey, 0, KEY_ALL_ACCESS, &hkey);
            ASSERT(r == ERROR_SUCCESS);

            if (r == ERROR_SUCCESS)
            {
                // get current value
                TCHAR szBuffer[4];
                DWORD dwType = REG_SZ;
                DWORD dwCount = sizeof(szBuffer);
                r = RegQueryValueEx (hkey, szAdminValue, NULL, &dwType,(LPBYTE)szBuffer, &dwCount);

                // if value isn't "YES" then change it, and broadcast change message
                if (r != ERROR_SUCCESS || dwType != REG_SZ || lstrcmpi(szBuffer, szYes) != 0)
                {
                    r = RegSetValueEx (hkey, szAdminValue, NULL, REG_SZ, (CONST BYTE *)szYes, sizeof(szYes));
                    ASSERT(r == ERROR_SUCCESS);

                    ULONG_PTR dwRes;
                    SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, (WPARAM)0,
                                        (LPARAM)szBroadcastParam, SMTO_ABORTIFHUNG|SMTO_NORMAL, 100, &dwRes);
                }

                RegCloseKey(hkey);
            }
        }
    }
}


void CAMCDoc::PersistCustomData (CPersistor &persistor)
{
    CPersistor persistorCustom(persistor, XML_TAG_CUSTOM_DATA);
    // persist custom title
    // It may not exist, and that's OK if it doesn't.
    // It just means we don't have a custom title.
    if ((persistorCustom.IsLoading()
         && persistorCustom.HasElement(XML_TAG_STRING_TABLE_STRING, XML_ATTR_CUSTOM_TITLE))
     || (persistorCustom.IsStoring() && HasCustomTitle()))
    {
        if(m_pstrCustomTitle)
            persistorCustom.PersistString(XML_ATTR_CUSTOM_TITLE, *m_pstrCustomTitle);
    }

    // persist custom icon
    CXMLPersistableIcon persIcon(m_CustomIcon);

    bool bHasIcon = persistorCustom.IsLoading() && persistorCustom.HasElement(persIcon.GetXMLType(), NULL);
    bHasIcon = bHasIcon || persistorCustom.IsStoring() && HasCustomIcon();

    if (!bHasIcon)
        return;

    persistorCustom.Persist(persIcon);

    if (persistorCustom.IsLoading())
    {
        CWnd* pMainWnd = AfxGetMainWnd();
        pMainWnd->SetIcon (GetCustomIcon (true),  true);
        pMainWnd->SetIcon (GetCustomIcon (false), false);
    }
}



/***************************************************************************\
 *
 * METHOD:  GetCurrentFileVersionAsString
 *
 * PURPOSE: formats current file version and returns a string
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CString    - resulting string
 *
\***************************************************************************/
tstring GetCurrentFileVersionAsString()
{
    TCHAR szFileVersion[16];

    // get file version data
    UINT uiMajorVer =    GetConsoleFileMajorVersion(FileVer_Current);
    UINT uiMinorVer =    GetConsoleFileMinorVersion(FileVer_Current);
    UINT uiMinorSubVer = GetConsoleFileMinorSubversion(FileVer_Current);

    if (uiMinorSubVer)
        wsprintf (szFileVersion, _T("%d.%d.%d"),  uiMajorVer,  uiMinorVer, uiMinorSubVer);
    else
        wsprintf (szFileVersion, _T("%d.%d"),  uiMajorVer,  uiMinorVer);

    return szFileVersion;
}

/***************************************************************************\
 *
 * METHOD:  CAMCDoc::ScOnSnapinAdded
 *
 * PURPOSE: Script event firing helper. Implements interface accessible from
 *          node manager
 *
 * PARAMETERS:
 *    PSNAPIN pSnapIn [in] - snapin added to the console
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCDoc::ScOnSnapinAdded(PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScOnSnapinAdded"));

    CAMCApp*  pApp = AMCGetApp();

    // check
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward
    sc = pApp->ScOnSnapinAdded(this, pSnapIn);
    if (sc)
        return sc;


    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCDoc::ScOnSnapinRemoved
 *
 * PURPOSE: Script event firing helper. Implements interface accessible from
 *          node manager
 *
 * PARAMETERS:
 *    PSNAPIN pSnapIn [in] - snapin removed from console
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCDoc::ScOnSnapinRemoved(PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::ScOnSnapinRemoved"));

    CAMCApp*  pApp = AMCGetApp();

    // check
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward
    sc = pApp->ScOnSnapinRemoved(this, pSnapIn);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCDoc::ScSetHelpCollectionInvalid
//
//  Synopsis:    A snapin is added/removed or extension is
//               enabled/disabled therefore help collection
//               no longer reflects current console file.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCDoc::ScSetHelpCollectionInvalid ()
{
    DECLARE_SC(sc, _T("CAMCDoc::ScSetHelpCollectionInvalid"));

    HELPDOCINFO *pHelpDocInfo = GetHelpDocInfo();
    sc = ScCheckPointers(pHelpDocInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    // console file modify time has to be updated for help collection.
    GetSystemTimeAsFileTime(&pHelpDocInfo->m_ftimeModify);

    return (sc);
}



SC CAMCDoc::Scget_Application(PPAPPLICATION  ppApplication)
{
    DECLARE_SC(sc, TEXT("CAMCDoc::Scget_Application"));

    // parameter check
    sc = ScCheckPointers(ppApplication, E_UNEXPECTED);
    if (sc)
        return sc;

    // initialization
    *ppApplication = NULL;

    CAMCApp*  pApp = AMCGetApp();

    // check
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return sc;

    sc = pApp->ScGet_Application(ppApplication);
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amc.h
//
//--------------------------------------------------------------------------

// AMC.h : main header file for the AMC application
//

#ifndef __AMC_H__
#define __AMC_H__

#ifndef __AFXWIN_H__
   #error include 'stdafx.h' before including this file for PCH
#endif

class CAMCDoc;

/////////////////////////////////////////////////////////////////////////////
// CAMCApp:
// See AMC.cpp for the implementation of this class
//

class CMainFrame;

class CAMCApp : public CWinApp, public CAMCViewObserver,
                public CAMCViewToolbarsObserver, public CConsoleEventDispatcher
{
    friend class CMMCApplication;
    DECLARE_DYNAMIC (CAMCApp)

    typedef std::list<HWND>             WindowList;
    typedef std::list<HWND>::iterator   WindowListIterator;

    // object model
public:
    SC      ScGet_Application(_Application **pp_Application);
    SC      ScRegister_Application(_Application *p_Application);

private:
    _ApplicationPtr m_sp_Application;

public:
    SC           ScCheckMMCPrerequisites();
    virtual BOOL PumpMessage();     // low level message pump
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual void RegisterShellFileTypes(BOOL bCompat);
    CAMCApp();

// Attributes
public:
    CMainFrame *    GetMainFrame();

// Operations
public:
    void SetDefaultDirectory();
    void SaveUserDirectory(LPCTSTR pszUserDir);
    CString GetUserDirectory();
    CString GetDefaultDirectory();

    HMENU GetMenu () const
    {
        return (m_Menu);
    }

    ProgramMode GetMode() const
    {
        ASSERT (IsValidProgramMode (m_eMode));
        return (m_eMode);
    }

    bool IsInitializing() const
    {
        return (m_fInitializing);
    }

    bool DidCloseComeFromMainPump() const
    {
        return (m_fCloseCameFromMainPump);
    }

    void ResetCloseCameFromMainPump()
    {
        m_fCloseCameFromMainPump = false;
    }

    void DelayCloseUntilIdle (bool fDelay = true)
    {
        m_fDelayCloseUntilIdle = fDelay;
    }

    bool IsWin9xPlatform() const
    {
        return m_fIsWin9xPlatform;
    }

    bool IsMMCRunningAsOLEServer() const { return m_fRunningAsOLEServer;}

    void UpdateFrameWindow(bool bUpdate);

    void InitializeMode (ProgramMode eMode);
    void SetMode (ProgramMode eMode);

    void HookPreTranslateMessage (CWnd* pwndHook);
    void UnhookPreTranslateMessage (CWnd* pwndUnhook);

    CIdleTaskQueue * GetIdleTaskQueue ();

    SC ScShowHtmlHelp(LPCTSTR pszFile, DWORD_PTR dwData);

    // helpers for script event firing
    SC ScOnNewDocument(CAMCDoc *pDocument, BOOL bLoadedFromConsole);
    SC ScOnCloseDocument(CAMCDoc *pDocument);
    SC ScOnQuitApp();
    SC ScOnSnapinAdded  (CAMCDoc *pDocument, PSNAPIN pSnapIn);
    SC ScOnSnapinRemoved(CAMCDoc *pDocument, PSNAPIN pSnapIn);
    SC ScOnNewView(CAMCView *pView);

    bool IsUnderUserControl() { return m_fUnderUserControl;}

protected:
    void SetUnderUserControl(bool bUserControl = true);

// Interfaces
private:
    BOOL InitializeOLE();
    void DeinitializeOLE();
    SC   ScUninitializeHelpControl();

    HRESULT DumpConsoleFile (CString strConsoleFile, CString strDumpFile);


private:
    SC   ScProcessAuthorModeRestrictions();

private:
    BOOL m_bOleInitialized;
    BOOL m_bDefaultDirSet;
    bool m_fAuthorModeForced;
    bool m_fInitializing;
    bool m_fDelayCloseUntilIdle;
    bool m_fCloseCameFromMainPump;
    int  m_nMessagePumpNestingLevel;
    bool m_fUnderUserControl;
    bool m_fRunningAsOLEServer;

    CIdleTaskQueue      m_IdleTaskQueue;
    ProgramMode         m_eMode;
    CMenu               m_Menu;
    CAccel              m_Accel;
    WindowList          m_TranslateMessageHookWindows;
    bool                m_fIsWin9xPlatform;

    static const TCHAR  m_szSettingsSection[];
    static const TCHAR  m_szUserDirectoryEntry[];

    bool                m_bHelpInitialized;
    DWORD               m_dwHelpCookie;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAMCApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    virtual BOOL OnIdle(LONG lCount);
    //}}AFX_VIRTUAL

// Implementation
#ifdef _DEBUG
    virtual void AssertValid() const;
#endif

    //{{AFX_MSG(CAMCApp)
    afx_msg void OnAppAbout();
    afx_msg void OnFileNewInUserMode(); // do nothing in user mode when CTRL+N is pressed. This handler prevents the hotkey from going to any WebBrowser controls
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    // Observed view events - each fires a com event
protected:
    virtual SC ScOnCloseView( CAMCView *pView );
    virtual SC ScOnViewChange( CAMCView *pView, HNODE hNode );
    virtual SC ScOnResultSelectionChange( CAMCView *pView );
    virtual SC ScOnContextMenuExecuted( PMENUITEM pMenuItem );
    virtual SC ScOnListViewItemUpdated(CAMCView *pView , int nIndex);

    // toolbar events
    virtual SC ScOnToolbarButtonClicked( );

    // Object model related code - these are in a private block
    // because CMMCApplication is a friend class
private:
    SC    ScHelp();
    SC    ScRunTestScript();

};

inline CAMCApp* AMCGetApp()
{
    extern CAMCApp theApp;
    return (&theApp);
}

inline CIdleTaskQueue * AMCGetIdleTaskQueue()
{
    return (AMCGetApp()->GetIdleTaskQueue());
}

extern const CRect g_rectEmpty;

#ifdef DBG
extern CTraceTag tagForceMirror;
#endif


/////////////////////////////////////////////////////////////////////////////

#endif //__AMC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      amc.cpp
//
//  Contents:  The one and only app
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Add code to switch views
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "AMC.h"


#include "MainFrm.h"
#include "ChildFrm.h"
#include "AMCDoc.h"
#include "AMCView.h"
#include "amcdocmg.h"
#include "sysmenu.h"
#include <shlobj.h>
#include "strings.h"
#include "macros.h"
#include "scripthost.h"
#include "HtmlHelp.h"
#include "scriptevents.h"
#include "mmcutil.h"
#include "guidhelp.h"       // for CLSID relational operators
#include "archpicker.h"
#include "classreg.h"

#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#include "websnk.h"
#include "websnk_i.c"

// We aren't picking this up from winuser.h for some reason.
#define ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(3)

/*
 * define our own Win64 symbol to make it easy to include 64-bit only
 * code in the 32-bit build, so we can exercise some code on 32-bit Windows
 * where the debuggers are better
 */
#ifdef _WIN64
#define MMC_WIN64
#endif

#ifndef MMC_WIN64
#include <wow64t.h>         // for Wow64DisableFilesystemRedirector
#endif

/*
 * multimon.h is included by stdafx.h, without defining COMPILE_MULTIMON_STUBS
 * first.  We need to include it again here after defining COMPILE_MULTIMON_STUBS
 * so we'll get the stub functions.
 */
#if (_WIN32_WINNT < 0x0500)
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#endif

#ifdef DBG
    CTraceTag  tagEnableScriptEngines(_T("MMCScriptEngines"), _T("Enable"));
    CTraceTag  tag32BitTransfer(_T("64/32-bit interop"), _T("64/32-bit interop"));
#endif

// Note: These strings do not need to be localizable.
const TCHAR CAMCApp::m_szSettingsSection[]    = _T("Settings");
const TCHAR CAMCApp::m_szUserDirectoryEntry[] = _T("Save Location");

bool CanCloseDoc(void);
SC ScExpandEnvironmentStrings (CString& str);

//############################################################################
//############################################################################
//
//  ATL Support
//
//############################################################################
//############################################################################
#include <atlimpl.cpp>
#include <atlwin.cpp>

// The one and only instance of CAtlGlobalModule
CAtlGlobalModule _Module;

//############################################################################
//############################################################################
//
//  Trace Tags
//
//############################################################################
//############################################################################
#ifdef DBG
// enable this tag if you suspect memory corruption
// and you don't mind things slowing way down

BEGIN_TRACETAG(CDebugCRTCheck)
    void OnEnable()
    {
        _CrtSetDbgFlag (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG)
                        | _CRTDBG_CHECK_ALWAYS_DF
                        | _CRTDBG_DELAY_FREE_MEM_DF);
    }
    void OnDisable()
    {
        _CrtSetDbgFlag (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG)
                        & ~(_CRTDBG_CHECK_ALWAYS_DF
                            | _CRTDBG_DELAY_FREE_MEM_DF) );
    }
END_TRACETAG(CDebugCRTCheck, TEXT("Debug CRTs"), TEXT("Memory Check - SLOW!"))

CTraceTag tagAMCAppInit(TEXT("CAMCView"), TEXT("InitInstance"));
CTraceTag tagATLLock(TEXT("ATL"), TEXT("Lock/Unlock"));  // used by atlconui.h
CTraceTag tagGDIBatching(TEXT("CAMCView"), TEXT("Disable Graphics/GDI Batching"));
CTraceTag tagForceMirror(TEXT("Mirroring"), TEXT("Force MMC windows to be mirrored on non-mirrored systems"));
#endif

//############################################################################
//############################################################################
//
//  Implementation of class CMMCApplication - the root level
//  automation class
//
//############################################################################
//############################################################################
class CMMCApplication :
    public CMMCIDispatchImpl<_Application, &CLSID_Application>,
    public CComCoClass<CMMCApplication, &CLSID_Application>,
    // support for connection points (script events)
    public IConnectionPointContainerImpl<CMMCApplication>,
    public IConnectionPointImpl<CMMCApplication, &DIID_AppEvents, CComDynamicUnkArray>,
    public IProvideClassInfo2Impl<&CLSID_Application, &DIID_AppEvents, &LIBID_MMC20>
    {
public:
    BEGIN_MMC_COM_MAP(CMMCApplication)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
    END_MMC_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CMMCApplication)

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		CObjectRegParams op (
			CLSID_Application,
			_T("mmc.exe"),
			_T("MMC Application Class"),
			_T("MMC20.Application.1"),
			_T("MMC20.Application"),
			_T("LocalServer32") );

		return (MMCUpdateRegistry (bRegister, &op, NULL));
	}

    //hooks into ATL's construction
    HRESULT InternalFinalConstructRelease(); // not FinalConstruct() - this is to work around a bogus ATL assert.

    BEGIN_CONNECTION_POINT_MAP(CMMCApplication)
        CONNECTION_POINT_ENTRY(DIID_AppEvents)
    END_CONNECTION_POINT_MAP()

    // overriden to do more job than the base class does
    virtual ::SC ScOnDisconnectObjects();

private:

    //IMMCApplication
public:
    void  STDMETHODCALLTYPE  Help();
    void  STDMETHODCALLTYPE  Quit();
    STDMETHOD(get_Document)     (Document **ppDocument);
    STDMETHOD(Load)             (BSTR bstrFilename);
    STDMETHOD(get_Frame)        (Frame **ppFrame);
    STDMETHOD(get_Visible)      (BOOL *pVisible);
    STDMETHOD(Show)             ();
    STDMETHOD(Hide)             ();
    STDMETHOD(get_UserControl)  (PBOOL pUserControl);
    STDMETHOD(put_UserControl)  (BOOL  bUserControl);
    STDMETHOD(get_VersionMajor) (PLONG pVersionMajor);
    STDMETHOD(get_VersionMinor) (PLONG pVersionMinor);

private:
    // Return the CAMCApp only if it is initialized. We do not want
    // object model methods to operate on app while initializing.
    CAMCApp *GetApp()
    {
        CAMCApp *pApp = AMCGetApp();
        if ( (! pApp) || (pApp->IsInitializing()) )
            return NULL;

        return pApp;
    }
};

//############################################################################
//############################################################################
//
//  Event map for application events
//
//############################################################################
//############################################################################

DISPATCH_CALL_MAP_BEGIN(AppEvents)

    DISPATCH_CALL1( OnQuit,                   PAPPLICATION )
    DISPATCH_CALL2( OnDocumentOpen,           PDOCUMENT,        BOOL)
    DISPATCH_CALL1( OnDocumentClose,          PDOCUMENT )
    DISPATCH_CALL2( OnSnapInAdded,            PDOCUMENT,  PSNAPIN )
    DISPATCH_CALL2( OnSnapInRemoved,          PDOCUMENT,  PSNAPIN )
    DISPATCH_CALL1( OnNewView,                PVIEW )
    DISPATCH_CALL1( OnViewClose,              PVIEW )
    DISPATCH_CALL2( OnViewChange,             PVIEW,      PNODE );
    DISPATCH_CALL2( OnSelectionChange,        PVIEW,      PNODES )
    DISPATCH_CALL1( OnContextMenuExecuted,    PMENUITEM );
    DISPATCH_CALL0( OnToolbarButtonClicked )
    DISPATCH_CALL1( OnListUpdated,            PVIEW )

DISPATCH_CALL_MAP_END()



/*+-------------------------------------------------------------------------*
 *
 * CMMCApplication::InternalFinalConstructRelease
 *
 * PURPOSE: Hands the CAMCApp a pointer to the 'this' object.
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplication::InternalFinalConstructRelease()
{
    DECLARE_SC(sc, TEXT("CMMCApplication::InternalFinalConstructRelease"));

    // Dont use GetApp, we need to get CAMCApp even if it is not fully initialized.
    CAMCApp *pApp = AMCGetApp();
    sc = ScCheckPointers(pApp);
    if(sc)
        return sc.ToHr(); // some wierd error.

    sc = pApp->ScRegister_Application(this);

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplication::GetFrame
 *
 * PURPOSE: A static function that hooks into the COM interface entry list
 *          and allows a tear-off object to be created that implements the
 *          Frame interface.
 *
 * PARAMETERS:
 *    void*   pv :   Defined by ATL to hold a pointer to the CMMCApplication object
 *                   because this is a static method.
 *    REFIID  riid :  As per QI
 *    LPVOID* ppv :   As per QI
 *    DWORD   dw :   ignored
 *
 * RETURNS:
 *    HRESULT WINAPI
 *
 *+-------------------------------------------------------------------------*/
STDMETHODIMP
CMMCApplication::get_Frame(Frame **ppFrame)
{
    DECLARE_SC(sc, TEXT("CMMCApplication::get_Frame"));

    if(!ppFrame)
    {
        sc = E_POINTER;
        return sc.ToHr();
    }

    // get the app
    CAMCApp *pApp = GetApp();
    if(NULL == pApp)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }


    CMainFrame *pMainFrame = pApp->GetMainFrame();
    if(!pMainFrame)
    {
        sc = E_UNEXPECTED;
        return sc.ToHr();
    }

    sc = pMainFrame->ScGetFrame(ppFrame);

    return sc.ToHr();
}


STDMETHODIMP
CMMCApplication::get_Document(Document **ppDocument)
{
    DECLARE_SC(sc, TEXT("CMMCApplication::get_Document"));

    CAMCDoc* const pDoc = CAMCDoc::GetDocument();

    ASSERT(ppDocument != NULL);
    if(ppDocument == NULL || (pDoc == NULL))
    {
        sc = E_POINTER;
        return sc.ToHr();
    }

    sc = pDoc->ScGetMMCDocument(ppDocument);
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCApplication::Load
 *
 * PURPOSE: implements Application.Load for object model
 *
 * PARAMETERS:
 *    BSTR bstrFilename - console file to load
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP
CMMCApplication::Load(BSTR bstrFilename)
{
    DECLARE_SC(sc, TEXT("CMMCApplication::Load"));

    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    USES_CONVERSION;
    pApp->OpenDocumentFile(OLE2CT(bstrFilename));
    return sc.ToHr();
}


void
STDMETHODCALLTYPE CMMCApplication::Help()
{
    DECLARE_SC(sc, TEXT("CMMCApplication::Help"));

    CAMCApp *pApp = GetApp();

    if(NULL == pApp)
    {
        sc = E_UNEXPECTED;
        return;
    }

    sc = pApp->ScHelp();
    if(sc)
        return;

    return;
}

void
STDMETHODCALLTYPE CMMCApplication::Quit()
{
    SC sc;
    CAMCApp *pApp = GetApp();

    if(NULL == pApp)
        goto Error;

    // confiscate the control from user
    pApp->SetUnderUserControl(false);

    // get mainframe
    {
        CMainFrame * pMainFrame = pApp->GetMainFrame();
        if(NULL == pMainFrame)
            goto Error;

        // close it gracefully.
        pMainFrame->PostMessage(WM_CLOSE);
    }

Cleanup:
    return;
Error:
    sc = E_UNEXPECTED;
    TraceError(TEXT("CMMCApplication::Quit"), sc);
    goto Cleanup;
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplication::get_VersionMajor
 *
 * PURPOSE: Returns the major version number for the installed version of MMC.
 *
 * PARAMETERS:
 *    PLONG  pVersionMajor :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplication::get_VersionMajor(PLONG pVersionMajor)
{
    DECLARE_SC(sc, TEXT("CMMCApplication::get_VersionMajor"));

    sc = ScCheckPointers(pVersionMajor);
    if(sc)
        return sc.ToHr();

    *pVersionMajor = MMC_VERSION_MAJOR;

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCApplication::get_VersionMinor
 *
 * PURPOSE: Returns the minor version number for the installed version of MMC.
 *
 * PARAMETERS:
 *    PLONG  pVersionMinor :
 *
 * RETURNS:
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT
CMMCApplication::get_VersionMinor(PLONG pVersionMinor)
{
    DECLARE_SC(sc, TEXT("CMMCApplication::get_VersionMinor"));

    sc = ScCheckPointers(pVersionMinor);
    if(sc)
        return sc.ToHr();

    *pVersionMinor = MMC_VERSION_MINOR;

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::get_Visible
//
//  Synopsis:    Returns the visible property
//
//  Arguments:   [PBOOL] - out bool
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::get_Visible (PBOOL pbVisible)
{
    DECLARE_SC(sc, _T("CMMCApplication::get_Visible"));
    sc = ScCheckPointers(pbVisible);
    if (sc)
        return sc.ToHr();

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    CMainFrame *pMainFrame = pApp->GetMainFrame();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    *pbVisible = pMainFrame->IsWindowVisible();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::Show
//
//  Synopsis:    Shows the application
//
//  Arguments:   None
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::Show ()
{
    DECLARE_SC(sc, _T("CMMCApplication::Show"));

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    CMainFrame *pMainFrame = pApp->GetMainFrame();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    sc = pMainFrame->ShowWindow(SW_SHOW);

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::Hide
//
//  Synopsis:    Hides the application.
//
//  Arguments:   None
//
//  Returns:     HRESULT
//
//  Note:        If the user is under control (UserControl property is set)
//               then Hide fails.
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::Hide ()
{
    DECLARE_SC(sc, _T("CMMCApplication::Hide"));

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    // Cant hide if app is under user control.
    if (pApp->IsUnderUserControl())
    {
        sc = E_FAIL;
        return sc.ToHr();
    }

    CMainFrame *pMainFrame = pApp->GetMainFrame();
    sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    sc = pMainFrame->ShowWindow(SW_HIDE);

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::get_UserControl
//
//  Synopsis:    Returns the UserControl property
//
//  Arguments:   PBOOL - out param.
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::get_UserControl (PBOOL pbUserControl)
{
    DECLARE_SC(sc, _T("CMMCApplication::get_UserControl"));
    sc = ScCheckPointers(pbUserControl);
    if (sc)
        return (sc.ToHr());

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    *pbUserControl = pApp->IsUnderUserControl();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:      CMMCApplication::put_UserControl
//
//  Synopsis:    Sets the UserControl property
//
//  Arguments:   BOOL
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
HRESULT CMMCApplication::put_UserControl (BOOL bUserControl)
{
    DECLARE_SC(sc, _T("CMMCApplication::put_UserControl"));

    // get the app
    CAMCApp *pApp = GetApp();
    sc = ScCheckPointers(pApp, E_UNEXPECTED);
    if (sc)
        return (sc.ToHr());

    pApp->SetUnderUserControl(bUserControl);

    return (sc.ToHr());
}


/***************************************************************************\
 *
 * METHOD:  CMMCApplication::ScOnDisconnectObjects
 *
 * PURPOSE: special disconnect implementation. For this object implementation
 *          provided by the base class is not enough, since connection point
 *          is an internal object which may also have strong references on it
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCApplication::ScOnDisconnectObjects()
{
    DECLARE_SC(sc, TEXT("CMMCApplication::ScOnDisconnectObjects"));

    // get the connection point container
    IConnectionPointContainerPtr spContainer(GetUnknown());
    sc = ScCheckPointers( spContainer, E_UNEXPECTED );
    if (sc)
        return sc;

    // get the connection point
    IConnectionPointPtr spConnectionPoint;
    sc = spContainer->FindConnectionPoint( DIID_AppEvents, &spConnectionPoint );
    if (sc)
        return sc;

    // cut connection point references
    sc = CoDisconnectObject( spConnectionPoint, 0/*dwReserved*/ );
    if (sc)
        return sc;

    // let the base class do the rest
    sc = CMMCIDispatchImplClass::ScOnDisconnectObjects();
    if (sc)
        return sc;

    return sc;
}

//############################################################################
//############################################################################
//
// ATL GLobal Object Map
//
//############################################################################
//############################################################################

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Application, CMMCApplication)
END_OBJECT_MAP()


/*+-------------------------------------------------------------------------*
 * CLockChildWindowUpdate
 *
 * Helper class whose constructor turns off redraw for all of the children
 * of the given window, and whose destructor turns redraw back on for all
 * of the windows for which it was turned off.
 *
 * This is used to prevent ugly transient drawing while opening console
 * files that take a long time to completely open (bug 150356).
 *--------------------------------------------------------------------------*/

class CLockChildWindowUpdate
{
public:
    CLockChildWindowUpdate (CWnd* pwndLock) : m_pwndLock(pwndLock)
    {
        if (m_pwndLock != NULL)
        {
            CWnd* pwndChild;

            /*
             * turn off redraw for each child, saving the HWND for later
             * so we can turn it back on (we save the HWND instead of the
             * CWnd* because MFC might have returned a temporary object).
             */
            for (pwndChild  = m_pwndLock->GetWindow (GW_CHILD);
                 pwndChild != NULL;
                 pwndChild  = pwndChild->GetNextWindow())
            {
                pwndChild->SetRedraw (false);
                m_vChildren.push_back (pwndChild->GetSafeHwnd());
            }
        }
    }

    ~CLockChildWindowUpdate()
    {
        std::vector<HWND>::iterator it;

        /*
         * for every window for which we turned off redraw, turn it back on
         */
        for (it = m_vChildren.begin(); it != m_vChildren.end(); ++it)
        {
            HWND hWndChild = *it;

            if ( (hWndChild != NULL) && ::IsWindow(hWndChild) )
            {
                CWnd *pwndChild = CWnd::FromHandle(hWndChild);
                pwndChild->SetRedraw (true);
                pwndChild->RedrawWindow (NULL, NULL,
                                         RDW_INVALIDATE | RDW_UPDATENOW |
                                         RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
            }
        }
    }

private:
    CWnd* const         m_pwndLock;
    std::vector<HWND>   m_vChildren;
};


//############################################################################
//############################################################################
//
//  Implementation of class CAMCMultiDocTemplate
//
//############################################################################
//############################################################################
class CAMCMultiDocTemplate : public CMultiDocTemplate
{
public:
    CAMCMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
                         CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass)
            : CMultiDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass)
        {
        }

    CDocument* OpenDocumentFile(LPCTSTR lpszPathName,
                                BOOL bMakeVisible)
        {
            DECLARE_SC(sc, TEXT("CAMCMultiDocTemplate::OpenDocumentFile"));

            CAMCDoc* const pDoc = CAMCDoc::GetDocument();
            if (pDoc && (!pDoc->SaveModified() || !CanCloseDoc() ))
                return NULL;        // leave the original one

            CLockChildWindowUpdate lock (AfxGetMainWnd());
            CAMCDoc* pDocument = (CAMCDoc*)CreateNewDocument();

            if (pDocument == NULL)
            {
                TRACE0("CDocTemplate::CreateNewDocument returned NULL.\n");
                AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC); // do not change to MMCMessageBox
                return NULL;
            }

            HRESULT hr;
            if ((hr = pDocument->InitNodeManager()) != S_OK)
            {
                TRACE1("CAMCDoc::InitNodeManager failed, 0x%08x\n", hr);
                CAMCApp* pApp = AMCGetApp();
                MMCErrorBox((pApp && pApp->IsWin9xPlatform())
                                    ? IDS_NODEMGR_FAILED_9x
                                    : IDS_NODEMGR_FAILED);
                delete pDocument;       // explicit delete on error
                return NULL;
            }

            ASSERT_VALID(pDocument);

            BOOL bAutoDelete = pDocument->m_bAutoDelete;
            pDocument->m_bAutoDelete = FALSE;   // don't destroy if something goes wrong
            CFrameWnd* pFrame = CreateNewFrame(pDocument, NULL);
            pDocument->m_bAutoDelete = bAutoDelete;
            if (pFrame == NULL)
            {
                AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);  // do not change to MMCMessageBox
                delete pDocument;       // explicit delete on error
                return NULL;
            }
            ASSERT_VALID(pFrame);

            if (lpszPathName == NULL)
            {
                // create a new document - with default document name
                SetDefaultTitle(pDocument);

                // avoid creating temporary compound file when starting up invisible
                if (!bMakeVisible)
                    pDocument->m_bEmbedded = TRUE;

                if (!pDocument->OnNewDocument())
                {
                    // user has be alerted to what failed in OnNewDocument
                    TRACE0("CDocument::OnNewDocument returned FALSE.\n");
                    AfxMessageBox (AFX_IDP_FAILED_TO_CREATE_DOC);  // do not change to MMCMessageBox
                    pFrame->DestroyWindow();
                    return NULL;
                }

                // it worked, now bump untitled count
                m_nUntitledCount++;

                InitialUpdateFrame(pFrame, pDocument, bMakeVisible);
            }
            else
            {
                // open an existing document
                CWaitCursor wait;
                if (!pDocument->OnOpenDocument(lpszPathName))
                {
                    // user has be alerted to what failed in OnOpenDocument
                    TRACE0("CDocument::OnOpenDocument returned FALSE.\n");
                    pFrame->DestroyWindow();
                    return NULL;
                }
#ifdef _MAC
                // if the document is dirty, we must have opened a stationery pad
                //  - don't change the pathname because we want to treat the document
                //  as untitled
                if (!pDocument->IsModified())
#endif
                    pDocument->SetPathName(lpszPathName);
                //REVIEW: dburg: InitialUpdateFrame(pFrame, pDocument, bMakeVisible);
                pFrame->DestroyWindow();
                pDocument->SetModifiedFlag      (false);
                pDocument->SetFrameModifiedFlag (false);
            }
            // fire script event
            CAMCApp* pApp = AMCGetApp();

            sc = ScCheckPointers(pApp, E_UNEXPECTED);
            if (sc)
                return pDocument;

            sc = pApp->ScOnNewDocument(pDocument, (lpszPathName != NULL));
            if (sc)
                sc.TraceAndClear();

            return pDocument;
        }
        // this method is overrided to catch application quit event
        virtual void CloseAllDocuments( BOOL bEndSession )
        {
            DECLARE_SC(sc, TEXT("CAMCMultiDocTemplate::CloseAllDocuments"));

            // invoke base class to perform required tasks
            CMultiDocTemplate::CloseAllDocuments( bEndSession );

            // no other way we can get here but exit app
            // so that's a good time for script to know it
            CAMCApp* pApp = AMCGetApp();
            sc = ScCheckPointers(pApp, E_UNEXPECTED);
            if (sc)
                return;

            // forward to application to emit the script event
            sc = pApp->ScOnQuitApp();
            if (sc)
                sc.TraceAndClear();

            // cut off all strong references now.
            // Quit was executed - nothing else matters
            sc = GetComObjectEventSource().ScFireEvent( CComObjectObserver::ScOnDisconnectObjects );
            if (sc)
                sc.TraceAndClear();
        }
};

// Declare debug infolevel for this component
DECLARE_INFOLEVEL(AMCConUI);

//############################################################################
//############################################################################
//
//  Implementation of class CAMCApp
//
//############################################################################
//############################################################################
IMPLEMENT_DYNAMIC(CAMCApp, CWinApp)

BEGIN_MESSAGE_MAP(CAMCApp, CWinApp)
    //{{AFX_MSG_MAP(CAMCApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP

    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)

    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)

    ON_COMMAND(ID_FILE_NEW_USER_MODE, OnFileNewInUserMode) // CTRL+N in user mode - do nothing

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAMCApp construction

CAMCApp::CAMCApp() :
    m_bOleInitialized(FALSE),
    m_bDefaultDirSet(FALSE),
    m_eMode(eMode_Error),
    m_fAuthorModeForced(false),
    m_fInitializing(true),
    m_fDelayCloseUntilIdle(false),
    m_fCloseCameFromMainPump(false),
    m_nMessagePumpNestingLevel(0),
    m_fIsWin9xPlatform(false),
    m_dwHelpCookie(0),
    m_bHelpInitialized(false),
    m_fUnderUserControl(true),
    m_fRunningAsOLEServer(false)
{
}


/////////////////////////////////////////////////////////////////////////////
// The one and only CAMCApp object

CAMCApp theApp;
const CRect g_rectEmpty (0, 0, 0, 0);

void DeleteDDEKeys()
{
    HKEY key;

    if (ERROR_SUCCESS == RegOpenKeyEx (HKEY_CLASSES_ROOT,
                                       _T("MSCFile\\shell\\open"),
                                       0, KEY_SET_VALUE, &key))
    {
        theApp.DelRegTree (key, _T("ddeexec"));
        RegCloseKey (key);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::GetMainFrame
 *
 * PURPOSE: Returns a pointer to the main frame.
 *
 * RETURNS:
 *    CMainFrame *
 *
 *+-------------------------------------------------------------------------*/
CMainFrame *
CAMCApp::GetMainFrame()
{
    return dynamic_cast<CMainFrame *>(m_pMainWnd);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScGet_Application
 *
 * PURPOSE: Returns a pointer to an _Application object.
 *
 * PARAMETERS:
 *    _Application ** pp_Application :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScGet_Application(_Application **pp_Application)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScGet_Application"));

    // parameter check
    sc = ScCheckPointers(pp_Application);
    if (sc)
        return sc;

    // init out param
    *pp_Application = NULL;

    // see if we have a chached one
    if (m_sp_Application != NULL)
    {
        *pp_Application = m_sp_Application;
        (*pp_Application)->AddRef(); // addref for the client.

        return sc;
    }

    // create an _Application object. This is needed if MMC was instantiated
    // by a user, not COM.

    sc = CMMCApplication::CreateInstance(pp_Application);
    if(sc)
        return sc;

    // The constructor of the CMMCApplication calls ScRegister_Application
    // which sets the m_sp_Application pointer. Do not set this pointer here.

    sc = ScCheckPointers(*pp_Application, E_UNEXPECTED);
    if (sc)
        return sc;

    // done
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScRegister_Application
 *
 * PURPOSE: called by a CMMCApplication object to enable the CAMCApp to store
 *          a pointer to it.
 *
 * PARAMETERS:
 *    _Application * p_Application :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScRegister_Application(_Application *p_Application)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScRegister_Application"));

    ASSERT(m_sp_Application == NULL); // only one _Application object should ever register.

    sc = ScCheckPointers(p_Application);
    if(sc)
        return sc;

    m_sp_Application = p_Application;
    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     RegisterShellFileTypes
//
//  Synopsis:   Register the file associations.
//
//  Note:       Also set all other relevant registry keys like
//              Open, Author, RunAs. Eventhough the setup has
//              done this it may have been deleted mistakenly.
//
//  History:
//              [AnandhaG] - Added the registry repair.
//  Returns:    None.
//
//--------------------------------------------------------------------
void CAMCApp::RegisterShellFileTypes(BOOL bCompat)
{
    CWinApp::RegisterShellFileTypes (bCompat);

    do
    {
        // Create the top level MSCFile key.
        CRegKey regKey;
        LONG lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile"), REG_NONE,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        /*
         * for platforms that support it (i.e. not Win9x), set the MUI-friendly
         * value for the MSCFile document type
         */
        if (!IsWin9xPlatform())
        {
            CString strMUIValue;
            strMUIValue.Format (_T("@%%SystemRoot%%\\system32\\mmcbase.dll,-%d"), IDR_MUIFRIENDLYNAME);
            lRet = RegSetValueEx (regKey, _T("FriendlyTypeName"), NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)(LPCTSTR) strMUIValue,
                                  sizeof(TCHAR) * (strMUIValue.GetLength()+1) );
            if (ERROR_SUCCESS != lRet)
                break;
        }

        // Set the EditFlags value.
        lRet = regKey.SetValue(0x100000, _T("EditFlags"));
        if (ERROR_SUCCESS != lRet)
            break;

        // Create the Author verb.
        lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\Author"), REG_NONE,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        // And set default value for author (this reflects in shell menu).
        CString strRegVal;
        LoadString(strRegVal, IDS_MENUAUTHOR);
        lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                              (CONST BYTE *)(LPCTSTR)strRegVal, sizeof(TCHAR) * (strRegVal.GetLength()+1) );
        if (ERROR_SUCCESS != lRet)
            break;

        /*
         * for platforms that support it (i.e. not Win9x), set the MUI-friendly
         * value for the menu item
         */
        if (!IsWin9xPlatform())
        {
            CString strMUIValue;
            strMUIValue.Format (_T("@%%SystemRoot%%\\system32\\mmcbase.dll,-%d"), IDS_MENUAUTHOR);
            lRet = RegSetValueEx (regKey, _T("MUIVerb"), NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)(LPCTSTR) strMUIValue,
                                  sizeof(TCHAR) * (strMUIValue.GetLength()+1) );
            if (ERROR_SUCCESS != lRet)
                break;
        }

        // Create the Author command.
        lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\Author\\command"), REG_NONE,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        //////////////////////////////////////////////////////////////
        // Win95 does not support REG_EXPAND_SZ for default values. //
        // So we set expand strings and set registry strings as     //
        // REG_SZ for Win9x.                                        //
        // The following declarations are for Win9x platform.       //
        //////////////////////////////////////////////////////////////
        TCHAR szRegValue[2 * MAX_PATH];
        TCHAR szWinDir[MAX_PATH];
        if (0 == ExpandEnvironmentStrings(_T("%WinDir%"), szWinDir, MAX_PATH) )
            break;

        DWORD dwCount = 0;
        LPTSTR lpszRegValue = NULL;

        // Set the default value for Author command.
        if (IsWin9xPlatform() == false)
        {
            lpszRegValue = _T("%SystemRoot%\\system32\\mmc.exe /a \"%1\" %*");
            dwCount = sizeof(TCHAR) * (1 + _tcslen(lpszRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)lpszRegValue, dwCount);
        }
        else // Win9x platform
        {
            lpszRegValue = _T("\\mmc.exe /a \"%1\" %2 %3 %4 %5 %6 %7 %8 %9");
            _tcscpy(szRegValue, szWinDir);
            _tcscat(szRegValue, lpszRegValue);
            dwCount = sizeof(TCHAR) * (1 + _tcslen(szRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                                  (CONST BYTE *)szRegValue, dwCount);
        }

        if (ERROR_SUCCESS != lRet)
            break;

        // Create the Open verb.
        lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\Open"),  REG_NONE,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        // Set default value for Open.
        LoadString(strRegVal, IDS_MENUOPEN);
        lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                              (CONST BYTE *)(LPCTSTR)strRegVal,sizeof(TCHAR) * (strRegVal.GetLength()+1) );
        if (ERROR_SUCCESS != lRet)
            break;

        /*
         * for platforms that support it (i.e. not Win9x), set the MUI-friendly
         * value for the menu item
         */
        if (!IsWin9xPlatform())
        {
            CString strMUIValue;
            strMUIValue.Format (_T("@%%SystemRoot%%\\system32\\mmcbase.dll,-%d"), IDS_MENUOPEN);
            lRet = RegSetValueEx (regKey, _T("MUIVerb"), NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)(LPCTSTR) strMUIValue,
                                  sizeof(TCHAR) * (strMUIValue.GetLength()+1) );
            if (ERROR_SUCCESS != lRet)
                break;
        }

        // Create the Open command.
        lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\Open\\command"),  REG_NONE,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (ERROR_SUCCESS != lRet)
            break;

        // Set the default value for Open command.
        if (IsWin9xPlatform() == false)
        {
            lpszRegValue = _T("%SystemRoot%\\system32\\mmc.exe \"%1\" %*");
            dwCount = sizeof(TCHAR) * (1 + _tcslen(lpszRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)lpszRegValue, dwCount);
        }
        else // Win9x platform
        {
            lpszRegValue = _T("\\mmc.exe \"%1\" %2 %3 %4 %5 %6 %7 %8 %9");
            _tcscpy(szRegValue, szWinDir);
            _tcscat(szRegValue, lpszRegValue);
            dwCount = sizeof(TCHAR) * (1 + _tcslen(szRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                                  (CONST BYTE *)szRegValue, dwCount);
        }

        if (ERROR_SUCCESS != lRet)
            break;

        // Create the RunAs verb (only on NT).
        if (IsWin9xPlatform() == false)
        {
            lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\RunAs"),  REG_NONE,
                                 REG_OPTION_NON_VOLATILE, KEY_WRITE);
            if (ERROR_SUCCESS != lRet)
                break;

            // Set default value for RunAs verb.
            LoadString(strRegVal, IDS_MENURUNAS);
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_SZ,
                                  (CONST BYTE *)(LPCTSTR)strRegVal,sizeof(TCHAR) * (strRegVal.GetLength()+1) );
            if (ERROR_SUCCESS != lRet)
                break;

            /*
             * for platforms that support it (i.e. not Win9x), set the MUI-friendly
             * value for the menu item
             */
            if (!IsWin9xPlatform())
            {
                CString strMUIValue;
                strMUIValue.Format (_T("@%%SystemRoot%%\\system32\\mmcbase.dll,-%d"), IDS_MENURUNAS);
                lRet = RegSetValueEx (regKey, _T("MUIVerb"), NULL, REG_EXPAND_SZ,
                                      (CONST BYTE *)(LPCTSTR) strMUIValue,
                                      sizeof(TCHAR) * (strMUIValue.GetLength()+1) );
                if (ERROR_SUCCESS != lRet)
                    break;
            }

            // Create the RunAs command.
            lRet = regKey.Create(HKEY_CLASSES_ROOT, _T("MSCFile\\shell\\RunAs\\command"),  REG_NONE,
                                 REG_OPTION_NON_VOLATILE, KEY_WRITE);
            if (ERROR_SUCCESS != lRet)
                break;

            // Set the default value for RunAs command. (Only on NT Unicode)
            lpszRegValue = _T("%SystemRoot%\\system32\\mmc.exe \"%1\" %*");
            dwCount = sizeof(TCHAR) * (1 + _tcslen(lpszRegValue));
            lRet = RegSetValueEx ((HKEY)regKey, (LPCTSTR)NULL, NULL, REG_EXPAND_SZ,
                                  (CONST BYTE *)lpszRegValue, dwCount);
        }

        if (ERROR_SUCCESS != lRet)
            break;

    } while ( FALSE );

    return;
}


/////////////////////////////////////////////////////////////////////////////
// CAMCApp initialization

#ifdef UNICODE
SC ScLaunchMMC (eArchitecture eArch, int nCmdShow);
#endif

#ifdef MMC_WIN64
    class CMMCCommandLineInfo;

    SC ScDetermineArchitecture (const CMMCCommandLineInfo& rCmdInfo, eArchitecture& eArch);
#else
    bool IsWin64();
#endif  // MMC_WIN64


class CMMCCommandLineInfo : public CCommandLineInfo
{
public:
	eArchitecture	m_eArch;
    bool    		m_fForceAuthorMode;
    bool    		m_fRegisterServer;
    CString 		m_strDumpFilename;

public:
    CMMCCommandLineInfo() :
		m_eArch (eArch_Any),
		m_fForceAuthorMode(false),
        m_fRegisterServer(false)
    {}

    virtual void ParseParam (LPCTSTR pszParam, BOOL bFlag, BOOL bLast)
    {
        bool fHandledHere = false;

        if (bFlag)
        {
            /*
             * ignore the following parameters:
             * -dde (await DDE command), -s (splash screen, obsolete).
             */
            if ((lstrcmpi (pszParam, _T("s"))   == 0) ||
                (lstrcmpi (pszParam, _T("dde")) == 0))
            {
                fHandledHere = true;
            }

            // force author mode
            else if (lstrcmpi (pszParam, _T("a")) == 0)
            {
                m_fForceAuthorMode = true;
                fHandledHere = true;
            }

            // register the server only
            else if (lstrcmpi (pszParam, _T("RegServer")) == 0)
            {
                m_fRegisterServer = true;
                fHandledHere = true;
            }

            // force 64-bit MMC to run
            else if (lstrcmp (pszParam, _T("64")) == 0)
            {
                m_eArch = eArch_64bit;
                fHandledHere = true;
            }

            // force 32-bit MMC to run
            else if (lstrcmp (pszParam, _T("32")) == 0)
            {
                m_eArch = eArch_32bit;
                fHandledHere = true;
            }

            else
            {
                static const TCHAR  szDumpParam[] = _T("dump:");
                const int           cchDumpParam  = countof (szDumpParam);
                TCHAR               szParam[cchDumpParam];

                lstrcpyn (szParam, pszParam, cchDumpParam);
                szParam[cchDumpParam-1] = _T('\0');

                // dump console file contents
                if (lstrcmpi (szParam, szDumpParam) == 0)
                {
                    m_strDumpFilename = pszParam + cchDumpParam - 1;
                    fHandledHere = true;
                }
            }
        }

        // if not handled, pass it on to base class
        // if just handled last parameter, call base class ParseLast
        // so it can do the final processing
        if (!fHandledHere)
            CCommandLineInfo::ParseParam (pszParam, bFlag, bLast);
        else if (bLast)
            CCommandLineInfo::ParseLast(bLast);

    }

}; // class CMMCCommandLineInfo



/*+-------------------------------------------------------------------------*
 * CWow64FilesystemRedirectionDisabler
 *
 * Disables Wow64 file system redirection for the file represented in the
 * given CMMCCommandLineInfo.  We do this so MMC32 can open consoles in
 * %windir%\system32 without having the path redirected to %windir%\syswow64.
 *--------------------------------------------------------------------------*/

class CWow64FilesystemRedirectionDisabler
{
public:
    CWow64FilesystemRedirectionDisabler (LPCTSTR pszFilename)
    {
#ifndef MMC_WIN64
		m_fDisabled = ((pszFilename != NULL) && IsWin64());

        if (m_fDisabled)
        {
            Trace (tag32BitTransfer, _T("Disabling Wow64 file system redirection for %s"), pszFilename);
            Wow64DisableFilesystemRedirector (pszFilename);
        }
#endif  // !MMC_WIN64
    }

    ~CWow64FilesystemRedirectionDisabler ()
    {
#ifndef MMC_WIN64
        if (m_fDisabled)
        {
            Trace (tag32BitTransfer, _T("Enabling Wow64 file system redirection"));
            Wow64EnableFilesystemRedirector();
        }
#endif  // !MMC_WIN64
    }

private:
#ifndef MMC_WIN64
    bool    m_fDisabled;
#endif  // !MMC_WIN64
};



/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScProcessAuthorModeRestrictions
 *
 * PURPOSE: Determines whether author mode restrictions are being enforced
 *          by system policy, and if author mode is not allowed,
 *          displays an error box and exits.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScProcessAuthorModeRestrictions()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScProcessAuthorModeRestrictions"));
    CRegKey regKey;

    // The mode is initialized to "author", if it is not in
    // initialized state just return.
    if (eMode_Author != m_eMode)
        return sc;

    // The console file mode is already read.
    // Check if user policy permits author mode.
    long lResult = regKey.Open(HKEY_CURRENT_USER, POLICY_KEY, KEY_READ);
    if (lResult != ERROR_SUCCESS)
        return sc;

    // get the value of RestrictAuthorMode.
    DWORD dwRestrictAuthorMode = 0;
    lResult = regKey.QueryValue(dwRestrictAuthorMode, g_szRestrictAuthorMode);
    if (lResult != ERROR_SUCCESS)
        return sc;

    if (dwRestrictAuthorMode == 0)    // Author mode is not restricted so return.
        return sc;

    /*
     * If called from script (running as embedded server) see if policy
     * restricts scripts from entering into author mode.
     *
     * If restricted then script will fail, thus restricting rogue scripts.
     *
     * Even if not restricted here cannot add snapins that are restricted.
     */
    if (IsMMCRunningAsOLEServer())
    {
        DWORD dwRestrictScriptsFromEnteringAuthorMode = 0;
        lResult = regKey.QueryValue(dwRestrictScriptsFromEnteringAuthorMode, g_szRestrictScriptsFromEnteringAuthorMode);
        if (lResult != ERROR_SUCCESS)
            return sc;

        if (dwRestrictScriptsFromEnteringAuthorMode == 0)  // Scripts can enter author mode so return
            return sc;

        sc = ScFromMMC(IDS_AUTHORMODE_NOTALLOWED_FORSCRIPTS);
    }
    else
        // If author mode is not allowed and
        // the user tried to force author mode
        // then display error message and exit.
        sc = ScFromMMC(IDS_AUTHORMODE_NOTALLOWED);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScCheckMMCPrerequisites
 *
 * PURPOSE: Checks all prerequisites. These are: (add to the list as appropriate)
 *          1) Internet Explorer 5.5 or greater must be installed
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScCheckMMCPrerequisites()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScCheckMMCPrerequisites"));

    // 1. Determine the installed version of Internet Explorer.
    const int CBDATA = 100;
    TCHAR szVersion[CBDATA];
    BOOL bIE55Found    = false;
    HKEY hkey          = NULL;
    DWORD dwType       =0;
    DWORD cbData       =CBDATA;
    DWORD dwMajor      =0;
    DWORD dwMinor      =0;
    DWORD dwRevision   =0;
    DWORD dwBuild      =0;
    lstrcpy(szVersion, TEXT(""));
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Internet Explorer"), 0, KEY_READ, &hkey))
    {
        cbData = 100;
        RegQueryValueEx(hkey, TEXT("Version"), 0, &dwType, (LPBYTE)szVersion, &cbData);
        RegCloseKey(hkey);
        if (lstrlen(szVersion) > 0)
        {
            _stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild);

            //Make sure IE 5.5 or greater is installed. To do this:
            // 1) Check if the major version is >= 6. If so we're done.
            // 2) If the major version is 5, the minor version should be >= 50
            if (dwMajor >= 6)
            {
                bIE55Found = true;
            }
            if (dwMajor == 5)
            {
                if(dwMinor >= 50)
                    bIE55Found = true;
            }
        }
    }
    if (!bIE55Found)
    {
        sc = ScFromMMC(MMC_E_INCORRECT_IE_VERSION); // NOTE: update the string when the version requirement changes
        return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::InitInstance
 *
 * PURPOSE: Initializes the document.
 *
 * NOTE: as an aside, if you need to break on, say,  the 269th allocation,
 *       add the following code:
 *
 *      #define ALLOCATION_NUM  269
 *      _CrtSetBreakAlloc(ALLOCATION_NUM);
 *      _crtBreakAlloc = ALLOCATION_NUM;
 *
 * RETURNS:
 *    BOOL
 *
 *+-------------------------------------------------------------------------*/
BOOL CAMCApp::InitInstance()
{
    DECLARE_SC(sc, TEXT("CAMCApp::InitInstance"));

	/*
	 * Initialize Fusion.
	 */
	SHFusionInitializeFromModuleID (NULL, static_cast<int>(reinterpret_cast<ULONG_PTR>(SXS_MANIFEST_RESOURCE_ID)));
   
#ifdef DBG
    if (tagForceMirror.FAny())
    {
        HINSTANCE hmodUser = GetModuleHandle (_T("user32.dll"));

        if (hmodUser != NULL)
        {
            BOOL (WINAPI* pfnSetProcessDefaultLayout)(DWORD);
            (FARPROC&)pfnSetProcessDefaultLayout = GetProcAddress (hmodUser, "SetProcessDefaultLayout");

            if (pfnSetProcessDefaultLayout != NULL)
                (*pfnSetProcessDefaultLayout)(LAYOUT_RTL);
        }
    }
#endif

    BOOL bRet = TRUE;

    // Initialize OLE libraries
    if (InitializeOLE() == FALSE)
        return FALSE;


    // Initialize the ATL Module
    _Module.Init(ObjectMap,m_hInstance);

#ifdef DBG
    if(tagGDIBatching.FAny())
    {
        // disable GDI batching so we'll see drawing as it happens
        GdiSetBatchLimit (1);
    }
#endif

    Unregister();

    Trace(tagAMCAppInit, TEXT("CAMCApp::InitInstance"));

    CMMCCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    /*
     * if we got a file on the command line, expand environment
     * variables in the filename so we can open files like
     * "%SystemRoot%\system32\compmgmt.msc"
     */
    if (!cmdInfo.m_strFileName.IsEmpty())
    {
        CWow64FilesystemRedirectionDisabler disabler (cmdInfo.m_strFileName);

        sc = ScExpandEnvironmentStrings (cmdInfo.m_strFileName);
        if (sc)
        {
            MMCErrorBox (sc);
            return (false);
        }
    }

    // Don't use an .ini file for the MRU or Settings
    // Note: This string does not need to be localizable.
    // HKEY_CURRENT_USER\\Software\\Microsoft\\Microsoft Management Console
    SetRegistryKey(_T("Microsoft"));

    // Find out OS version.
    OSVERSIONINFO versInfo;
    versInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    BOOL bStat = GetVersionEx(&versInfo);
    ASSERT(bStat);
    m_fIsWin9xPlatform = (versInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    // default to Author mode (loading a console may change this later)
    InitializeMode (eMode_Author);

    m_fAuthorModeForced = cmdInfo.m_fForceAuthorMode      ||
                          cmdInfo.m_strFileName.IsEmpty();


    /*
     * dump the snap-ins (and do nothing else) if we got "-dump:<filename>"
     */
    if (!cmdInfo.m_strDumpFilename.IsEmpty())
    {
        DumpConsoleFile (cmdInfo.m_strFileName, cmdInfo.m_strDumpFilename);
        return (false);
    }

#ifdef MMC_WIN64
    /*
     * We're currently running the MMC64.  See if we need to defer to MMC32.
     * If we do, try to launch MMC32.  If we were able to launch MMC32
     * successfully, abort MMC64.
     */
    eArchitecture eArch = eArch_64bit;
    sc = ScDetermineArchitecture (cmdInfo, eArch);
    if (sc)
    {
        DisplayFileOpenError (sc, cmdInfo.m_strFileName);
        return (false);
    }

    switch (eArch)
    {
        /*
         * MMC64 is fine, do nothing
         */
        case eArch_64bit:
            break;

        /*
         * User cancelled action, abort
         */
        case eArch_None:
            return (false);
            break;

        /*
         * We need MMC32, so try to launch it.  If we were able to launch MMC32
         * successfully, abort MMC64; if not, continue running MMC64.
         */
        case eArch_32bit:
            if (!ScLaunchMMC(eArch_32bit, m_nCmdShow).IsError())
            {
                Trace (tag32BitTransfer, _T("32-bit MMC launched successfully"));
                return (false);
            }

            Trace (tag32BitTransfer, _T("32-bit MMC failed to launch"));
            MMCErrorBox (MMC_E_UnableToLaunchMMC32);
            break;

        default:
            ASSERT (false && "Unexpected architecture returned from ScDetermineArchitecture");
            break;
    }
#elif defined(UNICODE)
    /*
     * We're currently running the MMC32.  If it's running on IA64 and 32-bit
     * wasn't specifically requested with a "-32" switch (this is what MMC64
     * will do when it defers to MMC32), defer to MMC64 so it can do snap-in
     * analysis and determine the appropriate "bitness" to run.
     */
    if ((cmdInfo.m_eArch != eArch_32bit) && IsWin64())
    {
        /*
         * We need MMC64, so try to launch it.  If we were able to launch MMC64
         * successfully, abort MMC32; if not, continue running MMC32.
         */
        if (!ScLaunchMMC(eArch_64bit, m_nCmdShow).IsError())
        {
            Trace (tag32BitTransfer, _T("64-bit MMC launched successfully"));
            return (false);
        }

        Trace (tag32BitTransfer, _T("64-bit MMC failed to launch"));
        MMCErrorBox (MMC_E_UnableToLaunchMMC64);
    }
#endif // MMC_WIN64

    AfxEnableControlContainer();

    // Standard initialization

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // create our own CDocManager derivative before adding any templates
    // (CWinApp::~CWinApp will delete it)
    m_pDocManager = new CAMCDocManager;

    // Register document templates
    CMultiDocTemplate* pDocTemplate;
    pDocTemplate = new CAMCMultiDocTemplate(
        IDR_AMCTYPE,
        RUNTIME_CLASS(CAMCDoc),
        RUNTIME_CLASS(CChildFrame), // custom MDI child frame
        RUNTIME_CLASS(CAMCView));
    AddDocTemplate(pDocTemplate);

    // Note: MDI applications register all server objects without regard
    //  to the /Embedding or /Automation on the command line.

    if (cmdInfo.m_fRegisterServer)
    {
        sc = _Module.RegisterServer(TRUE);// ATL Classes

        if (sc == TYPE_E_REGISTRYACCESS)
            sc.TraceAndClear();
    }

    if (sc)
    {
        MMCErrorBox (sc);
        return (false);
    }


    // create main MDI Frame window
    CMainFrame *pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // set the HWND to use as the parent for modal error dialogs.
    SC::SetHWnd(pMainFrame->GetSafeHwnd());

    // save this main thread's ID to check if snapins call MMC
    // interfaces from main thread.
    SC::SetMainThreadID(::GetCurrentThreadId());

    m_fRunningAsOLEServer = false;

    // Check to see if launched as OLE server
    if (RunEmbedded() || RunAutomated())
    {
        m_fRunningAsOLEServer = true;
        // Application was run with /Embedding or /Automation.  Don't show the
        //  main window in this case.
        //return TRUE;

        // Also set that script is controlling the application not the user
        // The script can modify the UserControl property on the application.
        SetUnderUserControl(false);

        // When a server application is launched stand-alone, it is a good idea to register all objects
        // ATL ones specifically register with REGCLS_MULTIPLEUSE
        // we register class objects only when run as an OLE server. This way, cannot connect to
        // an existing instance of MMC.
        sc = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE);
        if(sc)
            goto Error;
    }

    if (cmdInfo.m_fRegisterServer)
    {
        CString strTypeLib;
        strTypeLib.Format(TEXT("\\%d"), IDR_WEBSINK_TYPELIB); // this should evaluate to something like "\\4"

        sc = _Module.RegisterTypeLib((LPCTSTR)strTypeLib);

        if (sc == TYPE_E_REGISTRYACCESS)
            sc.TraceAndClear();

        if(sc)
            goto Error;
    }

    // Don't Enable drag/drop open
    // m_pMainWnd->DragAcceptFiles();

    // Enable DDE Execute open
    if (cmdInfo.m_fRegisterServer)
        RegisterShellFileTypes(FALSE);
    EnableShellOpen();
    if (cmdInfo.m_fRegisterServer)
        DeleteDDEKeys();

    /*
     * At this point, all of our registration is complete.  If we were invoked
     * with -RegServer, we can bail now.
     */
    if (cmdInfo.m_fRegisterServer)
        return (false);


    {   // limit scope of disabler
        CWow64FilesystemRedirectionDisabler disabler (cmdInfo.m_strFileName);

        // Dispatch commands specified on the command line.
        // This loads a console file if necessary.
        if (!ProcessShellCommand(cmdInfo))
            return (false); // user is already informed about errors
    }

    // Now the console file is loaded. Check if Author mode
    // is permitted.
    sc = ScProcessAuthorModeRestrictions(); // check if there are any restrictions set by policy
    if(sc)
        goto Error;

    // if proccessing the command line put MMC into author mode,
    // it has to stick with it forever.
    // see bug 102465 openning an author mode console file and then
    //                a user mode console switched MMC into user mode
    if (eMode_Author == m_eMode)
        m_fAuthorModeForced = true;

    // create a document automatically only if we're not instantiated as an
    // OLE server.
    if(! IsMMCRunningAsOLEServer ())
    {
        // if we don't have a document now (maybe because
        // the Node Manager wasn't registered), punt
        CAMCDoc* pDoc = CAMCDoc::GetDocument ();
        if (pDoc == NULL)
            return (FALSE);

        pDoc->SetFrameModifiedFlag (false);
        pDoc->UpdateFrameCounts ();

        CMainFrame *pMainFrame = GetMainFrame();
        if (pMainFrame)
        {
            pMainFrame->ShowWindow(m_nCmdShow);
            pMainFrame->UpdateWindow();
        }

        // showing will set the frame and "Modified" - reset it
        pDoc->SetFrameModifiedFlag (false);
    }

    // register itself as dispatcher able to dispatch com events
    sc = CConsoleEventDispatcherProvider::ScSetConsoleEventDispatcher( this );
    if (sc)
        goto Error;

    m_fInitializing = false;

    // check for all MMC prerequisites
    sc = ScCheckMMCPrerequisites();
    if (sc)
        goto Error;


// Comment out below line when script engines hosted in mmc are enabled.
//    sc = ScRunTestScript();

Cleanup:
    return bRet;

Error:
    MMCErrorBox(sc);
    bRet = FALSE;
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:      ScRunTestScript
//
//  Synopsis:    Test program to run a script. Once script input mechanisms
//               are defined this can be removed.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCApp::ScRunTestScript ()
{
    DECLARE_SC(sc, _T("CAMCApp::ScRunTestScript"));

    // The Running of scripts is enabled only in debug mode.
    bool bEnableScriptEngines = false;

#ifdef DBG
    if (tagEnableScriptEngines.FAny())
        bEnableScriptEngines = true;
#endif

    if (!bEnableScriptEngines)
        return sc;

    // Get the IDispatch from MMC object, the script engine needs
    // the IUnknown to top level object & the ITypeInfo ptr.
    CComPtr<_Application> spApplication;
    sc = ScGet_Application(&spApplication);
    if (sc)
        return sc;

    IDispatchPtr spDispatch = NULL;
    sc = spApplication->QueryInterface(IID_IDispatch, (LPVOID*)&spDispatch);
    if (sc)
        return sc;

    // The CScriptHostMgr should be instead created on the stack (as we have only
    // one per app) and destroyed with app. This change can be made once we decide
    // how & when the script host will be used to execute the scripts.
    CScriptHostMgr* pMgr = new CScriptHostMgr(spDispatch);
    if (NULL == pMgr)
        return (sc = E_OUTOFMEMORY);

    LPOLESTR pszScript = L"set WShShell=CreateObject(\"WScript.Shell\")\n\
                            WshShell.Popup(\"Anand\")\n\
                            Select Case WshShell.Popup(\"Anand\",5,\"Ganesan\", vbyesnocancel)\n\
                            End Select";

    tstring strExtn = _T(".vbs");
    sc = pMgr->ScExecuteScript(pszScript, strExtn);

    tstring strFile = _T("E:\\newnt\\admin\\mmcdev\\test\\script\\MMCStartupScript.vbs");

    sc = pMgr->ScExecuteScript(strFile);

    delete pMgr;

    return (sc);
}

// App command to run the dialog
void CAMCApp::OnAppAbout()
{
    /*
     * load the title of the about dialog
     */
    CString strTitle (MAKEINTRESOURCE (IDS_APP_NAME));

    CString strVersion (MAKEINTRESOURCE (IDS_APP_VERSION));
    strTitle += _T(" ");
    strTitle += strVersion;

    ShellAbout(*AfxGetMainWnd(), strTitle, NULL, LoadIcon(IDR_MAINFRAME));
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::OnFileNewInUserMode
 *
 * PURPOSE: Do nothing in user mode when CTRL+N is pressed.
 *          This handler prevents the hotkey from going to any WebBrowser controls
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCApp::OnFileNewInUserMode()
{
    MessageBeep(-1);
}


//+-------------------------------------------------------------------
//
//  Member:     ScShowHtmlHelp
//
//  Synopsis:   Initialize and then call Help control to display help topic.
//
//  Arguments:  [pszFile]    - File to display.
//              [dwData]     - Depends on uCommand for HH_DISPLAY_TOPIC it
//                             is help topic string.
//
//  Note:       The command is always HH_DISPLAY_TOPIC. HWND is NULL so that
//              Help can get behind MMC window.
//              See ScUnintializeHelpControl's Note for more info.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCApp::ScShowHtmlHelp(LPCTSTR pszFile, DWORD_PTR dwData)
{
    DECLARE_SC(sc, _T("CAMCApp::ScInitializeHelpControl"));

    /*
     * displaying HtmlHelp might take awhile, so show a wait cursor
     */
    CWaitCursor wait;

    if (! m_bHelpInitialized)
        HtmlHelp (NULL, NULL, HH_INITIALIZE, (DWORD_PTR)&m_dwHelpCookie);

    // No documented return value for HH_INITIALIZE so always assume
    // Initialize is successful.
    m_bHelpInitialized = true;

    HtmlHelp (NULL, pszFile, HH_DISPLAY_TOPIC, dwData);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScUninitializeHelpControl
//
//  Synopsis:   UnInitialize the help if it was initialized by MMC.
//
//  Note:       The help-control calls OleInitialize & OleUninitialize
//              in its DllMain. If a snapin creates any free threaded object
//              on main thread (STA), the OLE creates an MTA.
//              The last OleUninitialize does OLEProcessUninitialize in which
//              then OLE waits for the above MTA to cleanup and return.
//              By the time help-control does last OleUninitialize in its
//              DllMain the MTA is already terminated so OLE waits for this
//              MTA to signal which it never would.
//              We call HtmlHelp(.. HH_UNINITIALIZE..) to force help control
//              to uninit so that MMC does last OleUninit.
//              (This will not solve the problem of snapins calling help directly).
//
//  Arguments:
//
//  Returns:     SC, S_FALSE if already uninitialized else S_OK.
//
//--------------------------------------------------------------------
SC CAMCApp::ScUninitializeHelpControl()
{
    DECLARE_SC(sc, _T("CAMCApp::ScUninitializeHelpControl"));

    if (false == m_bHelpInitialized)
        return (sc = S_FALSE);

    HtmlHelp (NULL, NULL, HH_UNINITIALIZE, m_dwHelpCookie);
    m_bHelpInitialized = false;
    m_dwHelpCookie     = 0;

    return sc;
}


BOOL CAMCApp::InitializeOLE()
{
    if (FAILED(::OleInitialize(NULL)))
        return FALSE;

    return (m_bOleInitialized = TRUE);
}

void CAMCApp::DeinitializeOLE()
{
    // Uninit help, see ScUninitializeHelpControl note.
    SC sc = ScUninitializeHelpControl();
    if (sc)
    {
        TraceError(_T("Uninit Help control failed"), sc);
    }

    // Forced DllCanUnloadNow before mmc exits.
    ::CoFreeUnusedLibraries();

    if (m_bOleInitialized == TRUE)
    {
        ::OleUninitialize();
        m_bOleInitialized = FALSE;
    }
}


/////////////////////////////////////////////////////////////////////////////
// CAMCApp diagnostics

#ifdef _DEBUG
void CAMCApp::AssertValid() const
{
    CWinApp::AssertValid();
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAMCApp commands

int CAMCApp::ExitInstance()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ExitInstance"));

    // if the main window is not destroyed yet - do that now.
    // since we need to get rid of all the objects before denitializing OLE.
    // It is not requred in most cases, since usually quit starts from closing the mainframe,
    // but in cases like system shut down it will come here with a valid window
    // See WindowsBug(ntbug9) #178858
    if ( ::IsWindow( AfxGetMainWnd()->GetSafeHwnd() ) )
    {
        AfxGetMainWnd()->DestroyWindow();
    }

    // disconnect the pointers to event dispatcher
    sc = CConsoleEventDispatcherProvider::ScSetConsoleEventDispatcher( NULL );
    if (sc)
        sc.TraceAndClear();

    // release cached application object
    m_sp_Application = NULL;

    // MFC's class factories registration is automatically revoked by MFC itself
    if (RunEmbedded() || RunAutomated())
	    _Module.RevokeClassObjects(); // Revoke class factories for ATL

    _Module.Term();               // clanup ATL GLobal Module

    // Ask node manager to cleanup what's got cached
    CComPtr<IComCacheCleanup> spComCacheCleanup;
    HRESULT hr = spComCacheCleanup.CoCreateInstance(CLSID_ComCacheCleanup, NULL, MMC_CLSCTX_INPROC);
    if (hr == S_OK)
    {
        spComCacheCleanup->ReleaseCachedOleObjects();
        spComCacheCleanup.Release();
    }

    // by now EVERY reference should be released
    ASSERT(_Module.GetLockCount() == 0 && "Outstanding references still exist on exit");

    DeinitializeOLE();

	/*
	 * uninitialize Fusion
	 */
	SHFusionUninitialize();

    int iRet = CWinApp::ExitInstance();

    DEBUG_VERIFY_INSTANCE_COUNT(CAMCTreeView);
    DEBUG_VERIFY_INSTANCE_COUNT(CAMCListView);
    DEBUG_VERIFY_INSTANCE_COUNT(CCCListViewCtrl);

    return iRet;
}


BOOL CAMCApp::PreTranslateMessage(MSG* pMsg)
{
	// Give HTML help a chance to crack the message. (Bug# 119355 & 206909).
	if ( m_bHelpInitialized && HtmlHelp(NULL, NULL, HH_PRETRANSLATEMESSAGE, (DWORD_PTR)pMsg) )
		return TRUE;

    // let all of the hook windows have a crack at this message
    WindowListIterator it = m_TranslateMessageHookWindows.begin();

    while (it != m_TranslateMessageHookWindows.end())
    {
        HWND  hwndHook = *it;
        CWnd* pwndHook = CWnd::FromHandlePermanent (hwndHook);

        // if this window is no longer valid, or it's not a permanent
        // window, remove it from the list
        if (!IsWindow (hwndHook) || (pwndHook == NULL))
            it = m_TranslateMessageHookWindows.erase (it);

        else
        {
            // otherwise if the hook window handled the message, bail
            if (pwndHook->PreTranslateMessage (pMsg))
                return (TRUE);

            ++it;
        }
    }

    // give the MMC defined main window accelerators a crack at the message
    if (m_Accel.TranslateAccelerator (AfxGetMainWnd()->GetSafeHwnd(), pMsg))
        return TRUE;

    return CWinApp::PreTranslateMessage(pMsg);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::SaveUserDirectory
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCApp::SaveUserDirectory(LPCTSTR pszUserDir)
{
    // if we got an empty string, change the pointer to NULL so
    // the entry will be removed from the registry
    if ((pszUserDir != NULL) && (lstrlen(pszUserDir) == 0))
        pszUserDir = NULL;

    WriteProfileString (m_szSettingsSection, m_szUserDirectoryEntry,
                        pszUserDir);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::GetUserDirectory
 *
 *
 *--------------------------------------------------------------------------*/

CString CAMCApp::GetUserDirectory(void)
{
    return (GetProfileString (m_szSettingsSection, m_szUserDirectoryEntry));
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::GetDefaultDirectory
 *
 *
 *--------------------------------------------------------------------------*/

CString CAMCApp::GetDefaultDirectory(void)
{
    static CString strDefaultDir;

    if (strDefaultDir.IsEmpty())
    {
        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHGetSpecialFolderLocation(
                                AfxGetMainWnd()->GetSafeHwnd(),
                                CSIDL_ADMINTOOLS | CSIDL_FLAG_CREATE, &pidl)))
        {
            // Convert to path name
            SHGetPathFromIDList (pidl, strDefaultDir.GetBuffer (MAX_PATH));
            strDefaultDir.ReleaseBuffer ();

            // Free IDList
            LPMALLOC pMalloc;

            if (SUCCEEDED(SHGetMalloc (&pMalloc)))
            {
                pMalloc->Free(pidl);
                pMalloc->Release();
            }
        }
    }

    return (strDefaultDir);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::SetDefaultDirectory
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCApp::SetDefaultDirectory(void)
{
    // Only set default first time, so we don't override user selection
    if (m_bDefaultDirSet)
        return;

    // Set the current directory to the default directory
    CString strDirectory;
    BOOL    rc = FALSE;

    strDirectory = GetDefaultDirectory ();

    if (!strDirectory.IsEmpty())
        rc = SetCurrentDirectory (strDirectory);

    m_bDefaultDirSet = rc;
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::PumpMessage
 *
 *
 *--------------------------------------------------------------------------*/

BOOL CAMCApp::PumpMessage()
{
    m_nMessagePumpNestingLevel++;

    MSG msg;
    ::PeekMessage(&msg, NULL, NULL, NULL, PM_NOREMOVE);

    if (msg.message == WM_CLOSE)
        m_fCloseCameFromMainPump = true;

    BOOL rc = CWinApp::PumpMessage();

    if (m_fDelayCloseUntilIdle && (m_nMessagePumpNestingLevel == 1))
    {
        m_fCloseCameFromMainPump = true;
        CMainFrame *pMainFrame = GetMainFrame();
        if (pMainFrame)
            pMainFrame->SendMessage (WM_CLOSE);
        m_fDelayCloseUntilIdle = false;
    }

    m_fCloseCameFromMainPump = false;

    m_nMessagePumpNestingLevel--;
    ASSERT (m_nMessagePumpNestingLevel >= 0);
    return (rc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScHelp
 *
 * PURPOSE: Displays help for the application.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScHelp()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScHelp"));

    CMainFrame * pMainFrame = GetMainFrame();
    if(!pMainFrame)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    pMainFrame->OnHelpTopics();

    return sc;
}

/*+-------------------------------------------------------------------------*
 * CAMCApp::OnIdle
 *
 * WM_IDLE handler for CAMCApp.
 *--------------------------------------------------------------------------*/

BOOL CAMCApp::OnIdle(LONG lCount)
{
    SC               sc;
    CIdleTaskQueue * pQueue = GetIdleTaskQueue();
    BOOL             fMoreIdleWork   = TRUE;

    if(NULL == pQueue)
    {
        ASSERT(0 && "Should not come here.");
        goto Error;
    }

    fMoreIdleWork = CWinApp::OnIdle(lCount);

    if (!fMoreIdleWork)
    {
        CMainFrame *pMainFrame = GetMainFrame();
        if (pMainFrame)
            pMainFrame->OnIdle ();
    }

    /*
     * if MFC doesn't have any more idle work to do,
     * check our idle task queue (if we have one)
     */
    if (!fMoreIdleWork && (pQueue != NULL))
    {
        LONG_PTR cIdleTasks;
        pQueue->ScGetTaskCount (&cIdleTasks);
        if(sc)
            goto Error;

        /*
         * do we have any idle tasks?
         */
        if (cIdleTasks > 0)
        {
            SC sc = pQueue->ScPerformNextTask();
            if(sc)
                goto Error;

            /*
             * this idle task may have added others; refresh the count
             */
            sc = pQueue->ScGetTaskCount(&cIdleTasks);
            if(sc)
                goto Error;
        }

        /*
         * do we have any more idle work to do?
         */
        fMoreIdleWork = (cIdleTasks > 0);
    }

    if (!fMoreIdleWork)
    {
        // this code is to trigger MMC exit sequence when it
        // is under the script control and the last reference is released.
        // (we do not use MFC [which would simply delete the mainframe] to do that)
        if ( !IsUnderUserControl() && CMMCStrongReferences::LastRefReleased() )
        {
            // we are in script control mode and all references are released
            // a good time to say goodbye

            CMainFrame *pMainFrame = GetMainFrame();
            sc = ScCheckPointers(pMainFrame, E_UNEXPECTED);
            if (sc)
                goto Error;

            // disabled main window will probably mean we are under modal dialog
            // wait until it is dismissed ( and try again )
            if (pMainFrame->IsWindowEnabled())
            {
                // here is the deal: if MMC is shown - we will initiate the exit sequence,
                // but put into the user mode first, so if user chooses to cancel it - it will have
                // the control over the application. He will also have to handle save request if
                // something has changed in the console
                if ( pMainFrame->IsWindowVisible() )
                {
                    if ( !m_fUnderUserControl )
                        SetUnderUserControl();

                    pMainFrame->PostMessage(WM_CLOSE);
                }
                else
                {
                    // if the application is hidden it should wait until user closes all open property sheets.
                    // since it will come back here, waiting means just doing nothing at this point.
                    if ( !FArePropertySheetsOpen(NULL, false /*bBringToFrontAndAskToClose*/ ) )
                    {
                        // if there are not sheets open - we must die silently
                        CAMCDoc* const pDoc = CAMCDoc::GetDocument();
                        if(pDoc == NULL)
                        {
                            sc = E_POINTER;
                            //fall thru; (need to close anyway)
                        }
                        else
                        {
                            // discard document without asking to save
                            pDoc->OnCloseDocument();
                        }

                        // say goodbye
                        pMainFrame->PostMessage(WM_CLOSE);
                    }
                }
            }
        }
    }

Cleanup:
    return (fMoreIdleWork);
Error:
    TraceError(TEXT("CAMCApp::OnIdle"), sc);
    goto Cleanup;

}

//+-------------------------------------------------------------------
//
//  Member:     InitializeMode
//
//  Synopsis:   Set the mode and load the menus, accelerator tables.
//
//  Arguments:  [eMode] - New application mode.
//
//  Returns:    None.
//
//--------------------------------------------------------------------
void CAMCApp::InitializeMode (ProgramMode eMode)
{
    SetMode(eMode);
    UpdateFrameWindow(false);
}

//+-------------------------------------------------------------------
//
//  Member:     SetMode
//
//  Synopsis:   Set the mode.
//
//  Note:       Call UpdateFrameWindow some time soon to update
//              menus/toolbars for this mode.
//              Cannot do this in this method. This is called
//              from CAMCDoc::LoadAppMode. The CAMCDoc::LoadFrame
//              calls the UpdateFrameWindow.
//
//  Arguments:  [eMode] - New application mode.
//
//  Returns:    None.
//
//--------------------------------------------------------------------
void CAMCApp::SetMode (ProgramMode eMode)
{
    ASSERT (IsValidProgramMode (eMode));

    if (m_fAuthorModeForced)
    {
        ASSERT (m_eMode == eMode_Author);
        ASSERT (GetMainFrame()->IsMenuVisible ());
    }
    else
        m_eMode = eMode;
}

//+-------------------------------------------------------------------
//
//  Member:     UpdateFrameWindow
//
//  Synopsis:   Load the menu/accelerator tables and update
//              them if loaded from console file.
//
//  Note:       Call UpdateFrameWindow some time soon after
//              calling SetMode to update menus/toolbars for this mode.
//              This is called from CAMCDoc::LoadFrame.
//
//  Arguments:  [bUpdate] - BOOL
//                          We need to update the toolbar/menus only
//                          if loaded from console file
//
//  Returns:    None.
//
//--------------------------------------------------------------------
void CAMCApp::UpdateFrameWindow(bool bUpdate)
{
    static const struct ModeDisplayParams
    {
        int     nResourceID;
        bool    fShowToolbar;
    } aDisplayParams[eMode_Count] =
    {
        {   IDR_AMCTYPE,            true    },      // eMode_Author
        {   IDR_AMCTYPE_USER,       false   },      // eMode_User
        {   IDR_AMCTYPE_MDI_USER,   false   },      // eMode_User_MDI
        {   IDR_AMCTYPE_SDI_USER,   false   },      // eMode_User_SDI
    };

    if (m_fAuthorModeForced)
    {
        ASSERT (m_eMode == eMode_Author);
        ASSERT (GetMainFrame()->IsMenuVisible ());
        return;
    }

    m_Menu.DestroyMenu ();
    m_Accel.DestroyAcceleratorTable ();

    VERIFY (m_Menu.LoadMenu          (aDisplayParams[m_eMode].nResourceID));
    m_Accel.LoadAccelerators (aDisplayParams[m_eMode].nResourceID);

    if (bUpdate)
    {
        CMainFrame *pMainFrame = GetMainFrame();
        ASSERT (pMainFrame != NULL);
        ASSERT_VALID (pMainFrame);

        CMDIChildWnd* pwndActive = pMainFrame ? pMainFrame->MDIGetActive () : NULL;

        // bypass CMainFrame::OnUpdateFrameMenu so CMainFrame::NotifyMenuChanged
        // doesn't get called twice and remove the new menu entirely
        if (pwndActive != NULL)
            pwndActive->OnUpdateFrameMenu (TRUE, pwndActive, m_Menu);
        else if (pMainFrame)
            pMainFrame->OnUpdateFrameMenu (m_Menu);

        if (m_eMode == eMode_User_SDI)
        {
            if (pwndActive != NULL)
                pwndActive->MDIMaximize ();

            if (pMainFrame)
                AppendToSystemMenu (pMainFrame, eMode_User_SDI);
        }

        if (pMainFrame)
            pMainFrame->ShowMenu    (true /*Always show menu*/);
    }
}



/*+-------------------------------------------------------------------------*
 * IsInContainer
 *
 *
 *--------------------------------------------------------------------------*/

template<class InputIterator, class T>
bool Find (InputIterator itFirst, InputIterator itLast, const T& t)
{
    return (std::find (itFirst, itLast, t) != itLast);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::HookPreTranslateMessage
 *
 * Adds a window the the list of windows that get prioritized cracks at
 * PreTranslateMessage.  Hooks set later get priority over earlier hooks.
 *--------------------------------------------------------------------------*/

void CAMCApp::HookPreTranslateMessage (CWnd* pwndHook)
{
    HWND hwndHook = pwndHook->GetSafeHwnd();
    ASSERT (IsWindow (hwndHook));

    // this only makes sense for permanent windows
    ASSERT (CWnd::FromHandlePermanent(hwndHook) == pwndHook);

    /*
     * Put the hook window at the front of the hook list.  We're preserving
     * the HWND instead of the CWnd* so we don't have unnecessary list<>
     * code generated.  We already use a list<HWND> for m_DelayedUpdateWindows,
     * so using list<HWND> here doesn't cause any more code to be generated.
     */
    if (!Find (m_TranslateMessageHookWindows.begin(),
               m_TranslateMessageHookWindows.end(),
               hwndHook))
    {
        m_TranslateMessageHookWindows.push_front (hwndHook);
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::UnhookPreTranslateMessage
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCApp::UnhookPreTranslateMessage (CWnd* pwndUnhook)
{
    HWND hwndUnhook = pwndUnhook->GetSafeHwnd();
    ASSERT (IsWindow (hwndUnhook));

    WindowListIterator itEnd   = m_TranslateMessageHookWindows.end();
    WindowListIterator itFound = std::find (m_TranslateMessageHookWindows.begin(),
                                            itEnd, hwndUnhook);

    if (itFound != itEnd)
        m_TranslateMessageHookWindows.erase (itFound);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::GetIdleTaskQueue
 *
 * Returns the IIdleTaskQueue interface for the application, creating it
 * if necessary.
 *--------------------------------------------------------------------------*/

CIdleTaskQueue * CAMCApp::GetIdleTaskQueue ()
{
    return &m_IdleTaskQueue;
}



/*+-------------------------------------------------------------------------*
 * ScExpandEnvironmentStrings
 *
 * Expands the any environment string (e.g. %SystemRoot%) in the input
 * string, in place.
 *--------------------------------------------------------------------------*/

SC ScExpandEnvironmentStrings (CString& str)
{
    DECLARE_SC (sc, _T("ScExpandEnvironmentStrings"));

    if (str.Find(_T('%')) != -1)
    {
        TCHAR szBuffer[MAX_PATH];

        if (!ExpandEnvironmentStrings (str, szBuffer, countof(szBuffer)))
            return (sc.FromLastError());

        str = szBuffer;
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * ScCreateDumpSnapins
 *
 * Creates a CLSID_MMCDocConfig object, opens it on the supplied filename,
 * and returns a pointer to the IDumpSnapins interface on the object.
 *--------------------------------------------------------------------------*/

SC ScCreateDumpSnapins (
    CString&        strConsoleFile,     /* I/O:console file                 */
    IDumpSnapins**  ppDumpSnapins)      /* O:IDumpSnapins interface         */
{
    DECLARE_SC (sc, _T("ScCreateDumpSnapins"));

    /*
     * validate input
     */
    sc = ScCheckPointers (ppDumpSnapins);
    if (sc)
        return (sc);

    *ppDumpSnapins = NULL;

    /*
     * create a doc config object
     */
    IDocConfigPtr spDocConfig;
    sc = spDocConfig.CreateInstance (CLSID_MMCDocConfig);
    if (sc)
        return (sc);

    /*
     * expand any embedded environment strings in the console filename
     */
    sc = ScExpandEnvironmentStrings (strConsoleFile);
    if (sc)
        return (sc);

    /*
     * open the console file
     */
    sc = spDocConfig->OpenFile (::ATL::CComBSTR (strConsoleFile));
    if (sc)
        return (sc);

    /*
     * get the IDumpSnapins interface
     */
    sc = spDocConfig.QueryInterface (IID_IDumpSnapins, *ppDumpSnapins);
    if (sc)
        return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCApp::DumpConsoleFile
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT CAMCApp::DumpConsoleFile (CString strConsoleFile, CString strDumpFile)
{
    DECLARE_SC (sc, _T("CAMCApp::DumpConsoleFile"));
    const CString* pstrFileWithError = &strConsoleFile;

    /*
     * get an IDumpSnapins interface on this console file
     */
    IDumpSnapinsPtr spDumpSnapins;
    sc = ScCreateDumpSnapins (strConsoleFile, &spDumpSnapins);
    if (sc)
        goto Error;

    sc = ScCheckPointers (spDumpSnapins, E_UNEXPECTED);
    if (sc)
        goto Error;

    /*
     * expand the dump filename if necessary
     */
    sc = ScExpandEnvironmentStrings (strDumpFile);
    if (sc)
        goto Error;

    /*
     * If there's no directory specifier on the dump file, put a "current
     * directory" marker on it.  We do this to prevent WritePrivateProfile*
     * from putting the file in the Windows directory.
     */
    if (strDumpFile.FindOneOf(_T(":\\")) == -1)
        strDumpFile = _T(".\\") + strDumpFile;

    /*
     * future file-related errors will pertain to the dump file
     * (see Error handler)
     */
    pstrFileWithError = &strDumpFile;

    /*
     * wipe out the existing file, if any
     */
    if ((GetFileAttributes (strDumpFile) != 0xFFFFFFFF) && !DeleteFile (strDumpFile))
    {
        sc.FromLastError();
        goto Error;
    }

    /*
     * dump the contents of the console file
     */
    sc = spDumpSnapins->Dump (strDumpFile);
    if (sc)
        goto Error;

    return (sc.ToHr());

Error:
    MMCErrorBox (*pstrFileWithError, sc);
    return (sc.ToHr());
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnNewDocument
 *
 * PURPOSE: Emits script event for application object
 *
 * PARAMETERS:
 *    CAMCDoc *pDocument      [in] document being created/opened
 *    BOOL bLoadedFromConsole [in] if document is loaded from file
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnNewDocument(CAMCDoc *pDocument, BOOL bLoadedFromConsole)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnNewDocument"));

    // check if there are "listeners"
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks;
        return sc;

    // construct document com object
    DocumentPtr spComDoc;
    sc = pDocument->ScGetMMCDocument(&spComDoc);
    if (sc)
        return sc;

    // check pointer
    sc = ScCheckPointers(spComDoc, E_POINTER);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnDocumentOpen (spComDoc , bLoadedFromConsole == FALSE));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnQuitApp
 *
 * PURPOSE: Emits script event for application object
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnQuitApp()
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnQuitApp"));

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnQuit (m_sp_Application));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnCloseView
 *
 * PURPOSE: Script event firing helper. Invoked when the view is closed
 *
 * PARAMETERS:
 *    CAMCView *pView [in] - view being closed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnCloseView( CAMCView *pView )
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnCloseView"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // check if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct view com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnViewClose (spView));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnViewChange
 *
 * PURPOSE: Script event firing helper. Invoked when scope selection change
 *
 * PARAMETERS:
 *    CAMCView *pView [in] affected view
 *    HNODE hNode     [in] new selected scope node
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnViewChange( CAMCView *pView, HNODE hNode )
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnViewChange"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // check if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct view com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // construct Node com object
    NodePtr spNode;
    sc = pView->ScGetScopeNode( hNode, &spNode );
    if (sc)
        return sc;

    // fire script event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnViewChange(spView, spNode));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnResultSelectionChange
 *
 * PURPOSE: Script event firing helper. Invoked when result selection change
 *
 * PARAMETERS:
 *    CAMCView *pView [in] - affected view
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnResultSelectionChange( CAMCView *pView )
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnResultSelectionChange"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // check if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct view com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // construct Node com object
    NodesPtr spNodes;
    sc = pView->Scget_Selection( &spNodes );
    if (sc)
        return sc;

    // fire script event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnSelectionChange(spView, spNodes));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMMCApplication::ScOnContextMenuExecuted
 *
 * PURPOSE: called when the context menu is executed to fire the event to script
 *
 * PARAMETERS:
 *    PMENUITEM pMenuItem - menu item (note: it may be NULL if menu item is gone)
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnContextMenuExecuted( PMENUITEM pMenuItem )
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnContextMenuExecuted"));

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents, OnContextMenuExecuted( pMenuItem ) );
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCApp::ScOnListViewItemUpdated
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CAMCView * pView :
 *    int        nIndex :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCApp::ScOnListViewItemUpdated(CAMCView *pView , int nIndex)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnListViewItemUpdated"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // check if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct view com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // fire script event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnListUpdated(spView));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnSnapinAdded
 *
 * PURPOSE: Script event firing helper. Implements interface accessible from
 *          node manager
 *
 * PARAMETERS:
 *    PSNAPIN pSnapIn [in] - snapin added to the console
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnSnapinAdded(CAMCDoc *pAMCDoc, PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnSnapinAdded"));

    // parameter check
    sc = ScCheckPointers(pAMCDoc, pSnapIn);
    if (sc)
        return sc;

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    DocumentPtr spDocument;
    sc = pAMCDoc->ScGetMMCDocument(&spDocument);
    if (sc)
        return sc;

    // check
    sc = ScCheckPointers(spDocument, E_UNEXPECTED);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnSnapInAdded (spDocument, pSnapIn));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnSnapinRemoved
 *
 * PURPOSE: Script event firing helper. Implements interface accessible from
 *          node manager
 *
 * PARAMETERS:
 *    PSNAPIN pSnapIn [in] - snapin removed from console
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnSnapinRemoved(CAMCDoc *pAMCDoc, PSNAPIN pSnapIn)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnSnapinRemoved"));

    // parameter check
    sc = ScCheckPointers(pAMCDoc, pSnapIn);
    if (sc)
        return sc;

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    DocumentPtr spDocument;
    sc = pAMCDoc->ScGetMMCDocument(&spDocument);
    if (sc)
        return sc;

    // check
    sc = ScCheckPointers(spDocument, E_UNEXPECTED);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnSnapInRemoved (spDocument, pSnapIn));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnNewView
 *
 * PURPOSE: Script event firing helper
 *
 * PARAMETERS:
 *    CAMCView *pView [in] - created view
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnNewView(CAMCView *pView)
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnNewView"));

    // parameter check
    sc = ScCheckPointers(pView);
    if (sc)
        return sc;

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // construct View com object
    ViewPtr spView;
    sc = pView->ScGetMMCView(&spView);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnNewView(spView));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::OnCloseDocument
 *
 * PURPOSE: Helper for invoking com event
 *
 * PARAMETERS:
 *    CAMCDoc *pAMCDoc [in] - document being closed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnCloseDocument(CAMCDoc *pAMCDoc)
{
    DECLARE_SC(sc, TEXT("CAMCApp::OnCloseDocument"));

    // parameter check
    sc = ScCheckPointers(pAMCDoc);
    if (sc)
        return sc;

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    DocumentPtr spDocument;
    sc = pAMCDoc->ScGetMMCDocument(&spDocument);
    if (sc)
        return sc;

    // check
    sc = ScCheckPointers(spDocument, E_UNEXPECTED);
    if (sc)
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnDocumentClose (spDocument));
    if (sc)
        sc.TraceAndClear(); // failure to issue the com event is not critical to this action

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::ScOnToolbarButtonClicked
 *
 * PURPOSE: Observed toolbar event - used to fire com event
 *
 * PARAMETERS:
 *    CAMCView *pAMCView - [in] view which toobar is executed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCApp::ScOnToolbarButtonClicked( )
{
    DECLARE_SC(sc, TEXT("CAMCApp::ScOnToolbarButtonClicked"));

    // see if we have sinks connected
    sc = ScHasSinks(m_sp_Application, AppEvents);
    if (sc)
        return sc;

    if (sc == SC(S_FALSE)) // no sinks
        return sc;

    // fire the event
    sc = ScFireComEvent(m_sp_Application, AppEvents , OnToolbarButtonClicked ( ));
    if (sc)
        sc.TraceAndClear(); // ignore the error - should not affect main behavior

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCApp::SetUnderUserControl
 *
 * PURPOSE: puts application into user control/script control mode
 *          implements Application.UserControl property
 *
 * PARAMETERS:
 *    bool bUserControl [in] true == set user control
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CAMCApp::SetUnderUserControl(bool bUserControl /* = true */ )
{
    m_fUnderUserControl = bUserControl;

    AfxOleSetUserCtrl(bUserControl); // allow MFC to know that
    if (bUserControl)
    {
        // make sure application is visible if it's under user control

        CMainFrame *pMainFrame = GetMainFrame();
        if(pMainFrame && !pMainFrame->IsWindowVisible())
        {
            pMainFrame->ShowWindow(SW_SHOW);
        }
    }
}


#ifdef MMC_WIN64

/*+-------------------------------------------------------------------------*
 * CompareBasicSnapinInfo
 *
 * Implements a less-than comparison for CBasicSnapinInfo, based solely on
 * the CLSID.  Returns true if the CLSID for bsi1 is less than the CLSID
 * for bsi2, false otherwise.
 *--------------------------------------------------------------------------*/

bool CompareBasicSnapinInfo (const CBasicSnapinInfo& bsi1, const CBasicSnapinInfo& bsi2)
{
    return (bsi1.m_clsid < bsi2.m_clsid);
}


/*+-------------------------------------------------------------------------*
 * ScDetermineArchitecture
 *
 * Determines whether MMC64 (which is currently executing) should chain
 * to MMC32.  This will occur in one of three situations:
 *
 * 1.  The "-32" command line parameter was specified.
 *
 * 2.  A console file was specified on the command line, and it contains
 *     one or more snap-ins that were not registered in the 64-bit HKCR
 *     hive, but all snap-ins are registered in the 32-bit HKCR hive.
 *
 * 3.  A console file was specified on the command line, and it contained
 *     one or more snap-ins that were not registered in the 64-bit HKCR
 *     hive, and one or more snap-ins that are not registered in the 32-bit
 *     HKCR hive.  In this case we'll do one of three things:
 *
 *     a.   If the set of unavailable 64-bit snap-ins is a subset of the
 *          set of unavailable 32-bit snap-ins, the 64-bit console will be
 *          more functional than the 32-bit console, so we'll run MMC64.
 *
 *     b.   If the set of unavailable 32-bit snap-ins is a subset of the
 *          set of unavailable 64-bit snap-ins, the 32-bit console will be
 *          more functional than the 64-bit console, so we'll run MMC32.
 *
 *     c.   If neither a. or b. is true, we'll display UI asking which
 *          version of MMC to run.
 *
 * Returns:
 * eArch == eArch_64bit - 64-bit MMC is needed (or an error occurred)
 * eArch == eArch_32bit - 32-bit MMC is needed
 * eArch == eArch_None  - user cancelled the operation
 *--------------------------------------------------------------------------*/

SC ScDetermineArchitecture (const CMMCCommandLineInfo& rCmdInfo, eArchitecture& eArch)
{
    DECLARE_SC (sc, _T("ScDetermineArchitecture"));

    /*
     * default to 64-bit
     */
    eArch = eArch_64bit;

    /*
     * Case 0:  Was "-64" specified on the command line?  64-bit needed
     */
    if (rCmdInfo.m_eArch == eArch_64bit)
    {
        Trace (tag32BitTransfer, _T("\"-64\" parameter specified, 64-bit MMC needed"));
        return (sc);
    }

    /*
     * Case 1:  Was "-32" specified on the command line?  32-bit needed
     */
    if (rCmdInfo.m_eArch == eArch_32bit)
    {
        Trace (tag32BitTransfer, _T("\"-32\" parameter specified, 32-bit MMC needed"));
        eArch = eArch_32bit;
        return (sc);
    }

    /*
     * No file on the command line?  64-bit needed
     */
    if (rCmdInfo.m_nShellCommand != CCommandLineInfo::FileOpen)
    {
        Trace (tag32BitTransfer, _T("No console file specified, 64-bit MMC needed"));
        return (sc);
    }

    /*
     * Cases 2 and 3:  Analyze the specified console file
     */
    Trace (tag32BitTransfer, _T("Analyzing snap-ins in \"%s\""), (LPCTSTR) rCmdInfo.m_strFileName);

    /*
     * get an IDumpSnapins interface so we can analyze the console file
     */
    IDumpSnapinsPtr spDumpSnapins;
    CString strConsoleFile = rCmdInfo.m_strFileName;
    sc = ScCreateDumpSnapins (strConsoleFile, &spDumpSnapins);
    if (sc)
        return (sc);

    sc = ScCheckPointers (spDumpSnapins, E_UNEXPECTED);
    if (sc)
        return (sc);

    /*
     * analyze the 64-bit snap-ins in this console
     */
    CAvailableSnapinInfo asi64(false);
    sc = spDumpSnapins->CheckSnapinAvailability (asi64);
    if (sc)
        return (sc);

    /*
     * if no snap-ins are unavailable in 64-bit form, no need for MMC32
     */
    if (asi64.m_vAvailableSnapins.size() == asi64.m_cTotalSnapins)
    {
        Trace (tag32BitTransfer, _T("All snapins are available in 64-bit form, 64-bit MMC needed"));
        return (sc);
    }

    /*
     * analyze the 32-bit snap-ins in this console
     */
    CAvailableSnapinInfo asi32(true);
    sc = spDumpSnapins->CheckSnapinAvailability (asi32);
    if (sc)
        return (sc);

    /*
     * Case 2:  If no snap-ins are unavailable in 32-bit form, 32-bit needed
     */
    if (asi32.m_vAvailableSnapins.size() == asi32.m_cTotalSnapins)
    {
        Trace (tag32BitTransfer, _T("All snapins are available in 32-bit form, 32-bit MMC needed"));
        eArch = eArch_32bit;
        return (sc);
    }

    /*
     * std::includes depends on its ranges being sorted, so make sure
     * that's the case
     */
    std::sort (asi32.m_vAvailableSnapins.begin(), asi32.m_vAvailableSnapins.end(), CompareBasicSnapinInfo);
    std::sort (asi64.m_vAvailableSnapins.begin(), asi64.m_vAvailableSnapins.end(), CompareBasicSnapinInfo);

    /*
     * Case 3a:  If the set of available 64-bit snap-ins is a
     * superset of the set of available 32-bit snap-ins, run MMC64
     */
    if (std::includes (asi64.m_vAvailableSnapins.begin(), asi64.m_vAvailableSnapins.end(),
                       asi32.m_vAvailableSnapins.begin(), asi32.m_vAvailableSnapins.end(),
                       CompareBasicSnapinInfo))
    {
        Trace (tag32BitTransfer, _T("The set of available 64-bit snapins is a superset of..."));
        Trace (tag32BitTransfer, _T("...the set of available 32-bit snapins, 64-bit MMC needed"));
        return (sc);
    }

    /*
     * Case 3b:  If the set of available 32-bit snap-ins is a
     * superset of the set of available 64-bit snap-ins, run MMC32
     */
    if (std::includes (asi32.m_vAvailableSnapins.begin(), asi32.m_vAvailableSnapins.end(),
                       asi64.m_vAvailableSnapins.begin(), asi64.m_vAvailableSnapins.end(),
                       CompareBasicSnapinInfo))
    {
        Trace (tag32BitTransfer, _T("The set of available 32-bit snapins is a superset of..."));
        Trace (tag32BitTransfer, _T("...the set of available 64-bit snapins, 32-bit MMC needed"));
        eArch = eArch_32bit;
        return (sc);
    }

    /*
     * Case 3c:  Ask the user which to run
     */
    CArchitecturePicker dlg (rCmdInfo.m_strFileName, asi64, asi32);

    if (dlg.DoModal() == IDOK)
    {
        eArch = dlg.GetArchitecture();
        Trace (tag32BitTransfer, _T("User chose %d-bit, %d-bit MMC needed"), (eArch == eArch_32bit) ? 32 : 64, (eArch == eArch_32bit) ? 32 : 64);
    }
    else
    {
        Trace (tag32BitTransfer, _T("User chose to exit, terminating"));
        eArch = eArch_None;
    }

    return (sc);
}

#endif // MMC_WIN64


#ifdef UNICODE

/*+-------------------------------------------------------------------------*
 * ScLaunchMMC
 *
 * Launches a specific architecture of MMC (i.e. MMC32 from MMC64 or vice
 * versa) with the same command line used to launch this process.
 *
 * Returns S_OK if the given architecture of MMC was launched successfully,
 * or an error code if an error occurred.
 *--------------------------------------------------------------------------*/

SC ScLaunchMMC (
	eArchitecture	eArch,				/* I:desired architecture           */
	int				nCmdShow)			/* I:show state                     */
{
    DECLARE_SC (sc, _T("ScLaunchMMC"));

	CString strArgs;
	int nFolder;

	switch (eArch)
	{
		case eArch_64bit:
			nFolder = CSIDL_SYSTEM;
			break;

		case eArch_32bit:
			/*
			 * make sure we give MMC32 a "-32" argument so it won't defer
			 * to MMC64 again (see CAMCApp::InitInstance)
			 */
			strArgs = _T("-32 ");
			nFolder = CSIDL_SYSTEMX86;
            break;

		default:
			return (sc = E_INVALIDARG);
			break;
	}

    /*
     * Get the directory where MMC32 lives (%SystemRoot%\syswow64) and
     * append the executable name
     */
    CString strProgram;
    sc = SHGetFolderPath (NULL, nFolder, NULL, 0, strProgram.GetBuffer(MAX_PATH));
    if (sc)
        return (sc);

    strProgram.ReleaseBuffer();
    strProgram += _T("\\mmc.exe");

	/*
	 * disable file system redirection so MMC32 will be able to launch MMC64
	 */
	CWow64FilesystemRedirectionDisabler disabler (strProgram);

    /*
     * get the arguments for the original invocation of MMC, skipping
     * argv[0] (the executable name) and any "-32" or "-64" parameters
     */
    int argc;
    CAutoGlobalPtr<LPWSTR> argv (CommandLineToArgvW (GetCommandLine(), &argc));
    if (argv == NULL)
        return (sc.FromLastError());

    for (int i = 1; i < argc; i++)
    {
        CString strArg = argv[i];

        if ((strArg != _T("-32")) && (strArg != _T("/32")) &&
            (strArg != _T("-64")) && (strArg != _T("/64")))
        {
            strArgs += _T("\"") + strArg + _T("\" ");
        }
    }

	/*
	 * start the requested architecture of MMC
	 */
	Trace (tag32BitTransfer, _T("Attempting to run: %s %s"), (LPCTSTR) strProgram, (LPCTSTR) strArgs);

    SHELLEXECUTEINFO sei = {0};
    sei.cbSize       = sizeof (sei);
    sei.fMask        = SEE_MASK_FLAG_NO_UI;
    sei.lpFile       = strProgram;
    sei.lpParameters = strArgs;
    sei.nShow        = nCmdShow;

    if (!ShellExecuteEx (&sei))
        return (sc.FromLastError());

    return (sc);
}

#endif  // UNICODE


#ifndef MMC_WIN64

/*+-------------------------------------------------------------------------*
 * IsWin64
 *
 * Returns true if we're running on Win64, false otherwise.
 *--------------------------------------------------------------------------*/

bool IsWin64()
{
#ifdef UNICODE
    /*
     * get a pointer to kernel32!GetSystemWow64Directory
     */
    HMODULE hmod = GetModuleHandle (_T("kernel32.dll"));
    if (hmod == NULL)
        return (false);

    UINT (WINAPI* pfnGetSystemWow64Directory)(LPTSTR, UINT);
    (FARPROC&)pfnGetSystemWow64Directory = GetProcAddress (hmod, "GetSystemWow64DirectoryW");

    if (pfnGetSystemWow64Directory == NULL)
        return (false);

    /*
     * if GetSystemWow64Directory fails and sets the last error to
     * ERROR_CALL_NOT_IMPLEMENTED, we're on a 32-bit OS
     */
    TCHAR szWow64Dir[MAX_PATH];
    if (((pfnGetSystemWow64Directory)(szWow64Dir, countof(szWow64Dir)) == 0) &&
        (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED))
    {
        return (false);
    }

    /*
     * if we get here, we're on Win64
     */
    return (true);
#else
    /*
     * non-Unicode platforms cannot be Win64
     */
    return (false);
#endif  // UNICODE
}

#endif // !MMC_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amcnav.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcnav.h
//
//--------------------------------------------------------------------------

// amcnav.h : header file for class CAMCNavigator
//

#ifndef _AMCNAV_H_
#define _AMCNAV_H_
 
//
// Class for adding custom keyboard navigation to a view
// View should inherit from CView (or derived class)
// and CAMCNavigator.
// 
//

enum AMCNavDir
{
    AMCNAV_NEXT,
    AMCNAV_PREV
};

class CAMCNavigator 
{
public:
	virtual BOOL ChangePane(AMCNavDir eDir) = 0;
    virtual BOOL TakeFocus(AMCNavDir eDir) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amcdocmg.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      amcdocmg.cpp
 *
 *  Contents:  Implementation file for CAMCDocManager
 *
 *  History:   01-Jan-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/


#include "stdafx.h"
#include "amcdocmg.h"
#include "amc.h"        // for AMCGetApp
#include "filedlgex.h"


void AppendFilterSuffix(CString& filter, OPENFILENAME_NT4& ofn,
    CDocTemplate* pTemplate, CString* pstrDefaultExt);

/*--------------------------------------------------------------------------*
 * CAMCDocManager::DoPromptFileName
 *
 * We need to override this so we can set the default directory. The MFC
 * implementation lets the system choose the default, which due to a NT5.0
 * change, is not always the current directory. This implementation specifically
 * requests the current directory.
 *--------------------------------------------------------------------------*/

// This and the following method were copied from MFC sources because we needed
// to modify the internal handling of the file dialog options. The added code
// sections are commented (MMC change).

BOOL CAMCDocManager::DoPromptFileName(CString& fileName, UINT nIDSTitle, DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate)
{
    //
    // MMC change: Set the default directory (sets to admin tools the first time called)
    //
    CAMCApp* pApp = AMCGetApp();
    pApp->SetDefaultDirectory ();

    CFileDialogEx dlgFile(bOpenFileDialog);

    CString title;
    VERIFY(title.LoadString(nIDSTitle)); // this uses MFC's LoadString because that is where the string resides.

    dlgFile.m_ofn.Flags |= (lFlags | OFN_ENABLESIZING);

    CString strFilter;
    CString strDefault;
    if (pTemplate != NULL)
    {
        ASSERT_VALID(pTemplate);
        AppendFilterSuffix(strFilter, dlgFile.m_ofn, pTemplate, &strDefault);
    }
    else
    {
        // do for all doc template
        POSITION pos = m_templateList.GetHeadPosition();
        BOOL bFirst = TRUE;
        while (pos != NULL)
        {
            CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetNext(pos);
            AppendFilterSuffix(strFilter, dlgFile.m_ofn, pTemplate,
                bFirst ? &strDefault : NULL);
            bFirst = FALSE;
        }
    }

    // append the "*.*" all files filter
    CString allFilter;
    VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER)); // this uses MFC's LoadString because that is where the string resides.
    strFilter += allFilter;
    strFilter += (TCHAR)'\0';   // next string please
    strFilter += _T("*.*");
    strFilter += (TCHAR)'\0';   // last string
    dlgFile.m_ofn.nMaxCustFilter++;

    dlgFile.m_ofn.lpstrFilter = strFilter;
    dlgFile.m_ofn.lpstrTitle = title;
    dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);

    //
    // MMC change: Set the initial dir to the current dir
    //
    TCHAR szDir[_MAX_PATH];
    GetCurrentDirectory(_MAX_PATH, szDir);
    dlgFile.m_ofn.lpstrInitialDir = szDir;

    BOOL bResult = dlgFile.DoModal() == IDOK ? TRUE : FALSE;
    fileName.ReleaseBuffer();

    return bResult;
}



void AppendFilterSuffix(CString& filter, OPENFILENAME_NT4& ofn,
    CDocTemplate* pTemplate, CString* pstrDefaultExt)
{
    ASSERT_VALID(pTemplate);
    ASSERT_KINDOF(CDocTemplate, pTemplate);

    CString strFilterExt, strFilterName;
    if (pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt) &&
     !strFilterExt.IsEmpty() &&
     pTemplate->GetDocString(strFilterName, CDocTemplate::filterName) &&
     !strFilterName.IsEmpty())
    {
        // a file based document template - add to filter list
        ASSERT(strFilterExt[0] == '.');
        if (pstrDefaultExt != NULL)
        {
            // set the default extension
            *pstrDefaultExt = ((LPCTSTR)strFilterExt) + 1;  // skip the '.'
            ofn.lpstrDefExt = (LPTSTR)(LPCTSTR)(*pstrDefaultExt);
            ofn.nFilterIndex = ofn.nMaxCustFilter + 1;  // 1 based number
        }

        // add to filter
        filter += strFilterName;
        ASSERT(!filter.IsEmpty());  // must have a file type name
        filter += (TCHAR)'\0';  // next string please
        filter += (TCHAR)'*';
        filter += strFilterExt;
        filter += (TCHAR)'\0';  // next string please
        ofn.nMaxCustFilter++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amcdocmg.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      amcdocmg.h
 *
 *  Contents:  Interface file for CAMCDocManager
 *
 *  History:   01-Jan-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef AMCDOCMG_H
#define AMCDOCMG_H


class CAMCDocManager : public CDocManager
{
public:
    virtual BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
            DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);
};


#endif /* AMCDOCMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\conui\amcview.cpp ===
// AMCView.cpp : implementation of the CAMCView class
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      amcview.cpp
//
//  Contents:  Base view implementation for all console views
//             Also include splitter window implementation (Horizontal Splitter)
//
//  History:   01-Jan-96 TRomano    Created
//             16-Jul-96 WayneSc    Added code to switch views and split them
//
//--------------------------------------------------------------------------
// NOTE:
// MMC starting from version 1.1 had a code which allowed to copy the view
// settings from one view to another and thus the created view would look
// the same. AMCDoc was used as temporary storage for those settings.
// But the code was NEVER used; hence was not tested and not up-to-date.
// Switching to XML persistence would require essential changes to that code,
// and at this time we cannot afford using it.
// If in the future we decide to support the feature, someone needs to look at
// MMC 1.2 sources and bring the code back. Today the code is removed from
// active sources.
// audriusz. 3/29/2000
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "AMC.h"
#include "Mainfrm.h"
#include "HtmlHelp.h"

#include "websnk.h"
#include "WebCtrl.h"        // AMC Private implementation of the web view control
#include "CClvCtl.h"        // List view control
#include "ocxview.h"
#include "histlist.h"       // history list

#include "AMCDoc.h"         // AMC Console Document
#include "AMCView.h"
#include "childfrm.h"

#include "TreeCtrl.h"       // AMC Implementation of the Tree Control
#include "TaskHost.h"

#include "util.h"           // GUIDFromString, GUIDToString
#include "AMCPriv.h"
#include "guidhelp.h" // ExtractObjectTypeGUID
#include "amcmsgid.h"
#include "cclvctl.h"
#include "vwtrack.h"
#include "cmenuinfo.h"

#ifdef IMPLEMENT_LIST_SAVE  // See nodemgr.idl (t-dmarm)
#include "svfildlg.h"       // Save File Dialog
#endif

#include "macros.h"
#include <mapi.h>
#include <mbstring.h>       // for _mbslen

#include "favorite.h"
#include "favui.h"

#include "ftab.h"

#include "toolbar.h"
#include "menubtns.h"       // UpdateFavorites menu.
#include "stdbar.h"         // Standard toolbar.
#include "variant.h"
#include "rsltitem.h"
#include "scriptevents.h" // for IMenuItemEvents

extern "C" UINT dbg_count = 0;

enum
{
    ITEM_IS_PARENT_OF_ROOT,
    ITEM_NOT_IN_VIEW,
    ITEM_IS_IN_VIEW,
};

enum EIndex
{
    INDEX_INVALID        = -1,
    INDEX_BACKGROUND     = -2,
    INDEX_MULTISELECTION = -3,
    INDEX_OCXPANE        = -4,
    INDEX_WEBPANE        = -5,
};

enum ScopeFolderItems
{
    SFI_TREE_TAB         = 1,
    SFI_FAVORITES_TAB    = 2
};


const UINT CAMCView::m_nShowWebContextMenuMsg           = ::RegisterWindowMessage (_T("CAMCView::ShowWebContextMenu"));
const UINT CAMCView::m_nProcessMultiSelectionChangesMsg = ::RegisterWindowMessage (_T("CAMCView::OnProcessMultiSelectionChanges"));
const UINT CAMCView::m_nAddPageBreakAndNavigateMsg      = ::RegisterWindowMessage (_T("CAMCView::AddPageBreakAndNavigate"));
const UINT CAMCView::m_nJiggleListViewFocusMsg          = ::RegisterWindowMessage (_T("CAMCView::JiggleListViewFocus"));
const UINT CAMCView::m_nDeferRecalcLayoutMsg            = ::RegisterWindowMessage (_T("CAMCView::DeferRecalcLayout"));


void CALLBACK TrackerCallback(TRACKER_INFO& info, bool bAcceptChange, bool bSyncLayout);
void GetFullPath(CAMCTreeView &ctc, HTREEITEM hti, CString &strPath);
BOOL PtInWindow(CWnd* pWnd, CPoint pt);


#ifdef DBG
CTraceTag  tagLayout            (_T("CAMCView"),    _T("Layout"));
CTraceTag  tagSplitterTracking  (_T("CAMCView"),    _T("Splitter tracking"));
CTraceTag  tagListSelection     (_T("Result list"), _T("Selection"));
CTraceTag  tagViewActivation    (_T("View Activation"), _T("View Activation"));
#endif


/*+-------------------------------------------------------------------------*
 * CAMCView::ScNotifySelect
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::ScNotifySelect (
    INodeCallback*      pCallback,
    HNODE               hNode,
    bool                fMultiSelect,
    bool                fSelect,
    SELECTIONINFO*      pSelInfo)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScNotifySelect"));

    // parameter check
    sc = ScCheckPointers(pCallback);
    if (sc)
        return sc;

    // pSelInfo can be NULL only for multi-select.
    if (!pSelInfo && !fMultiSelect)
        return (sc = E_INVALIDARG);

#ifdef DBG
    Trace (tagListSelection, _T("%s (fSelect=%s, pwnd=0x%08x)"),
           (fMultiSelect) ? _T("NCLBK_MULTI_SELECT") : _T("NCLBK_SELECT"),
           (fSelect) ? _T("true") : _T("false"),
           static_cast<CWnd *>(this));
#endif

    // we want this error (not a failure to broadcast the event) to be returned,
    // so cache it and assign before return
    SC sc_notify = (pCallback->Notify (hNode, fMultiSelect ? NCLBK_MULTI_SELECT :NCLBK_SELECT,
                                     fSelect, reinterpret_cast<LPARAM>(pSelInfo)));

    // fire event whenever the selection changes, but not if
    //  its a background hit or loss of focus
    if(fMultiSelect ||
       (pSelInfo->m_bBackground == FALSE && (fSelect == TRUE || pSelInfo->m_bDueToFocusChange == FALSE)))
    {
        sc = ScFireEvent(CAMCViewObserver::ScOnResultSelectionChange, this);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
    }

    sc = sc_notify;
    return sc;
}


/*+-------------------------------------------------------------------------*
 * GetAMCView
 *
 * Returns the CAMCView window for any child of CChildFrame.
 *--------------------------------------------------------------------------*/

CAMCView* GetAMCView (CWnd* pwnd)
{
    /*
     * get the input window's parent frame window
     */
    CWnd* pFrame = pwnd->GetParentFrame();

    /*
     * if we couldn't find a parent frame, or that parent frame isn't
     * of type CChildFrame, fail
     */
    if ((pFrame == NULL) || !pFrame->IsKindOf (RUNTIME_CLASS (CChildFrame)))
        return (NULL);

    /*
     * get the first view of the frame window
     */
    CWnd* pView = pFrame->GetDlgItem (AFX_IDW_PANE_FIRST);

    /*
     * if we can't find a window with the right ID, or the one we find
     * isn't of type CAMCView, fail
     */
    if ((pView == NULL) || !pView->IsKindOf (RUNTIME_CLASS (CAMCView)))
        return (NULL);

    return (dynamic_cast<CAMCView*>(pView));
}


//############################################################################
//############################################################################
//
//  Implementation of class CMMCView
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CMMCView
 *
 *
 * PURPOSE: The COM 0bject that exposes the View interface.
 *
 *+-------------------------------------------------------------------------*/
class CMMCView :
    public CTiedComObject<CAMCView>,
    public CMMCIDispatchImpl<View>
{
    typedef CAMCView CMyTiedObject;

public:
    BEGIN_MMC_COM_MAP(CMMCView)
    END_MMC_COM_MAP()

public:
    //#######################################################################
    //#######################################################################
    //
    //  Item and item collection related methods
    //
    //#######################################################################
    //#######################################################################

    MMC_METHOD1(get_ActiveScopeNode,    PPNODE);
    MMC_METHOD1(put_ActiveScopeNode,    PNODE);
    MMC_METHOD1(get_Selection,          PPNODES);
    MMC_METHOD1(get_ListItems,          PPNODES);
    MMC_METHOD2(SnapinScopeObject,    VARIANT,    PPDISPATCH);
    MMC_METHOD1(SnapinSelectionObject,    PPDISPATCH);

    //#######################################################################
    //#######################################################################

    MMC_METHOD2(Is,                     PVIEW,  VARIANT_BOOL *);
    MMC_METHOD1(get_Document,           PPDOCUMENT);

    //#######################################################################
    //#######################################################################
    //
    //  Selection changing methods
    //
    //#######################################################################
    //#######################################################################
    MMC_METHOD0(SelectAll);
    MMC_METHOD1(Select,                 PNODE);
    MMC_METHOD1(Deselect,               PNODE);
    MMC_METHOD2(IsSelected,             PNODE,      PBOOL);

    //#######################################################################
    //#######################################################################
    //
    //  Verb and selection related methods
    //
    //#######################################################################
    //#######################################################################
    MMC_METHOD1(DisplayScopeNodePropertySheet,      VARIANT);
    MMC_METHOD0(DisplaySelectionPropertySheet);
    MMC_METHOD1(CopyScopeNode,          VARIANT);
    MMC_METHOD0(CopySelection);
    MMC_METHOD1(DeleteScopeNode,        VARIANT);
    MMC_METHOD0(DeleteSelection);
    MMC_METHOD2(RenameScopeNode,        BSTR,       VARIANT);
    MMC_METHOD1(RenameSelectedItem,     BSTR);
    MMC_METHOD2(get_ScopeNodeContextMenu,VARIANT,   PPCONTEXTMENU);
    MMC_METHOD1(get_SelectionContextMenu,PPCONTEXTMENU);
    MMC_METHOD1(RefreshScopeNode,        VARIANT);
    MMC_METHOD0(RefreshSelection);
    MMC_METHOD1(ExecuteSelectionMenuItem, BSTR /*MenuItemPath*/);
    MMC_METHOD2(ExecuteScopeNodeMenuItem, BSTR /*MenuItemPath*/, VARIANT /*varScopeNode  = ActiveScopeNode */);
    MMC_METHOD4(ExecuteShellCommand,      BSTR /*Command*/,      BSTR /*Directory*/, BSTR /*Parameters*/, BSTR /*WindowState*/);

    //#######################################################################
    //#######################################################################
    //
    //  Frame and view related methods
    //
    //#######################################################################
    //#######################################################################

    MMC_METHOD1(get_Frame,              PPFRAME);
    MMC_METHOD0(Close);
    MMC_METHOD1(get_ScopeTreeVisible,   PBOOL);
    MMC_METHOD1(put_ScopeTreeVisible,   BOOL);
    MMC_METHOD0(Back);
    MMC_METHOD0(Forward);
    MMC_METHOD1(put_StatusBarText,      BSTR);
    MMC_METHOD1(get_Memento,            PBSTR);
    MMC_METHOD1(ViewMemento,            BSTR);


    //#######################################################################
    //#######################################################################
    //
    //  List related methods
    //
    //#######################################################################
    //#######################################################################

    MMC_METHOD1(get_Columns,            PPCOLUMNS);
    MMC_METHOD3(get_CellContents,       PNODE,       long,           PBSTR);
    MMC_METHOD2(ExportList,             BSTR, ExportListOptions);
    MMC_METHOD1(get_ListViewMode,       PLISTVIEWMODE);
    MMC_METHOD1(put_ListViewMode,       ListViewMode);

    //#######################################################################
    //#######################################################################
    //
    //  ActiveX control related methods
    //
    //#######################################################################
    //#######################################################################
    MMC_METHOD1(get_ControlObject,      PPDISPATCH);

};


/*
 * WM_APPCOMMAND is only defined in winuser.h if _WIN32_WINNT >= 0x0500.
 * We need these definitions, but can't use _WIN32_WINNT==0x0500 (yet).
 */

#ifndef WM_APPCOMMAND
    #define WM_APPCOMMAND                   0x0319
    #define APPCOMMAND_BROWSER_BACKWARD       1
    #define APPCOMMAND_BROWSER_FORWARD        2
    #define APPCOMMAND_BROWSER_REFRESH        3

    #define FAPPCOMMAND_MOUSE 0x8000
    #define FAPPCOMMAND_KEY   0
    #define FAPPCOMMAND_OEM   0x1000
    #define FAPPCOMMAND_MASK  0xF000

    #define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
#endif  // WM_APPCOMMAND



//############################################################################
//############################################################################
//
//  Implementation of class CAMCView
//
//############################################################################
//############################################################################
IMPLEMENT_DYNCREATE(CAMCView, CView);

BEGIN_MESSAGE_MAP(CAMCView, CView)
    //{{AFX_MSG_MAP(CAMCView)
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_CREATE()
    ON_WM_SETFOCUS()
    ON_WM_CONTEXTMENU()
    ON_WM_DESTROY()
    ON_UPDATE_COMMAND_UI(ID_FILE_SNAPINMANAGER, OnUpdateFileSnapinmanager)
    ON_WM_SHOWWINDOW()
    ON_COMMAND(ID_MMC_NEXT_PANE, OnNextPane)
    ON_COMMAND(ID_MMC_PREV_PANE, OnPrevPane)
    ON_WM_SETCURSOR()
    ON_COMMAND(ID_MMC_CONTEXTHELP, OnContextHelp)
    ON_COMMAND(ID_HELP_SNAPINHELP, OnSnapInHelp)
    ON_COMMAND(ID_SNAPIN_ABOUT, OnSnapinAbout)
    ON_COMMAND(ID_HELP_HELPTOPICS, OnHelpTopics)
    ON_WM_SIZE()
    ON_WM_SYSKEYDOWN()
    ON_WM_PALETTECHANGED()
    ON_WM_QUERYNEWPALETTE()
    ON_WM_SYSCOLORCHANGE()
    ON_WM_DRAWCLIPBOARD()
    ON_WM_SETTINGCHANGE()
    ON_WM_MENUSELECT()
    //}}AFX_MSG_MAP

    // keep this outside the AFX_MSG_MAP markers so ClassWizard doesn't munge it
    ON_COMMAND_RANGE(ID_MMC_CUT, ID_MMC_PRINT, OnVerbAccelKey)

    // WARNING: If your message handler has void return use ON_MESSAGE_VOID !!
    ON_MESSAGE(MMC_MSG_CONNECT_TO_CIC, OnConnectToCIC)
    ON_MESSAGE(MMC_MSG_CONNECT_TO_TPLV, OnConnectToTPLV)
    ON_MESSAGE(MMC_MSG_GET_ICON_INFO, OnGetIconInfoForSelectedNode)
    ON_MESSAGE(WM_APPCOMMAND, OnAppCommand)

    ON_REGISTERED_MESSAGE (m_nShowWebContextMenuMsg,  OnShowWebContextMenu)
    ON_REGISTERED_MESSAGE (m_nProcessMultiSelectionChangesMsg,   OnProcessMultiSelectionChanges)
    ON_REGISTERED_MESSAGE (m_nAddPageBreakAndNavigateMsg, OnAddPageBreakAndNavigate)
    ON_REGISTERED_MESSAGE (m_nJiggleListViewFocusMsg, OnJiggleListViewFocus)
    ON_REGISTERED_MESSAGE (m_nDeferRecalcLayoutMsg,   OnDeferRecalcLayout)

    ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)

    ON_NOTIFY(FTN_TABCHANGED, IDC_ResultTabCtrl, OnChangedResultTab)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAMCView construction/destruction

const CSize CAMCView::m_sizEdge          (GetSystemMetrics (SM_CXEDGE),
                                          GetSystemMetrics (SM_CYEDGE));

const int   CAMCView::m_cxSplitter = 3;


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::OnMenuSelect
//
//  Synopsis:    Handles WM_MENUSELECT for Favorites menu.
//
//  Arguments:   [nItemID] - the resource id of menu item.
//               [nFlags]  - MF_* flags
//
//  Returns:     none
//
//--------------------------------------------------------------------
void CAMCView::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnMenuSelect"));

    CMainFrame* pFrame = AMCGetMainWnd();
    sc = ScCheckPointers(pFrame, E_UNEXPECTED);
    if (sc)
        return;

    // Pass onto the mainframe.
    return pFrame->OnMenuSelect(nItemID, nFlags, hSysMenu);
}


CAMCView::CAMCView() :
        m_pResultFolderTabView(new CFolderTabView(this))       // dynamically allocated for decoupling
{
    TRACE_CONSTRUCTOR(CAMCView);

    // Init pointer members to NULL
    m_nViewID                          = 0;
    m_pTreeCtrl                        = NULL;
    m_pListCtrl                        = NULL;
    m_pWebViewCtrl                     = NULL;
    m_pViewExtensionCtrl               = NULL;
    m_pOCXHostView                     = NULL;
    m_nSelectNestLevel                 = 0;

    // if the view is a listview, then this member define what the view
    // mode is for all snapins with that view.

    m_nViewMode                        = LVS_REPORT; // REVIEW: Must we persist this - ravi

    // REVIEW consider moving the above initialzation to the InitSplitter
    // CommonConstruct
    // NOTE moved code from InitSplitter into the contructor and deleted InitSplitter

    // Default values for view.  User can set these values with SetPaneInfo;
    m_PaneInfo[ePane_ScopeTree].pView   = NULL;
    m_PaneInfo[ePane_ScopeTree].cx      = -1;
    m_PaneInfo[ePane_ScopeTree].cxMin   = 50;

    m_PaneInfo[ePane_Results].pView     = NULL;
    m_PaneInfo[ePane_Results].cx        = -1;
    m_PaneInfo[ePane_Results].cxMin     = 50;

    m_pTracker                         = NULL;

    m_rectResultFrame                  = g_rectEmpty;
    m_rectVSplitter                    = g_rectEmpty;

//  m_fDontPersistOCX                  = FALSE;

    // root node for the view
    m_hMTNode                          = 0;

    // Bug 157408:  remove the "Type" column for static nodes
//  m_columnWidth[0]                   = 90;
//  m_columnWidth[1]                   = 50;
    m_columnWidth[0]                   = 200;
    m_columnWidth[1]                   = 0;

    m_iFocusedLV                       = -1;
    m_bLVItemSelected                  = FALSE;
    m_DefaultLVStyle                   = 0;

    m_bProcessMultiSelectionChanges    = false;

    m_htiCut                           = NULL;
    m_nReleaseViews                    = 0;
    m_htiStartingSelectedNode          = NULL;
    m_bLastSelWasMultiSel              = false;
    m_eCurrentActivePane               = eActivePaneNone;

    m_fRootedAtNonPersistedDynamicNode = false;
    m_fSnapinDisplayedHelp             = false;
    m_fActivatingSpecialResultPane     = false;
    m_bDirty                           = false;
    m_fViewExtended                    = false;

    m_pHistoryList                     = new CHistoryList (this);
    m_ListPadNode                      = NULL;

    /*
     * Bug 103604: Mark this as an author mode view if it was created in
     * author mode.  If we're loading a user mode console file, it will
     * have author mode views and possibly some views that were created
     * in user mode, but this code will mark all of the views as non-author
     * mode views.  CAMCView::Persist will fix that.
     */
    CAMCApp* pApp = AMCGetApp();
    if (pApp != NULL)
        m_bAuthorModeView = (pApp->GetMode() == eMode_Author);
    else
        m_bAuthorModeView = true;
}

CAMCView::~CAMCView()
{
    TRACE_DESTRUCTOR(CAMCView);

    // Delete all pointer members. (C++ checks to see if they are NULL before deleting)
    // The standard ~CWnd destructor will call DestroyWindow()

    // REVIEW set the pointers to NULL after deleting them
    // Note Done

    // CViews "delete this" in PostNcDestroy, no need to delete here
    //delete m_pTreeCtrl;
    m_pTreeCtrl = NULL;

    m_pListCtrl->Release();
    m_pListCtrl = NULL;

    /*
     * DONT_DELETE_VIEWS
     *
     * CViews "delete this" in PostNcDestroy, no need to delete
     * here if the web view control is derived from CView.  See
     * AttachWebViewAsResultPane (search for "DONT_DELETE_VIEWS")
     * for the ASSERTs that make sure this code is right.
     */
    //delete m_pWebViewCtrl;
    //m_pWebViewCtrl = NULL;

    /*
     * CViews "delete this" in PostNcDestroy, no need to delete here
     */
    m_pOCXHostView = NULL;
    m_pResultFolderTabView = NULL;

    if (m_ViewData.m_spNodeManager != NULL)
        m_ViewData.m_spNodeManager->CleanupViewData(
                                reinterpret_cast<LONG_PTR>(&m_ViewData));

    ASSERT (m_ViewData.m_pMultiSelection == NULL);

    delete m_pHistoryList;

    // First destroy the IControlbarsCache as snapins call CAMCViewToolbars
    // to cleanup toolbars before the CAMCViewToolbars itself gets destroyed.
    m_ViewData.m_spControlbarsCache = NULL;

    // (UI cleanup) release toolbars related to this view.
    m_spAMCViewToolbars = std::auto_ptr<CAMCViewToolbars>(NULL);
    m_spStandardToolbar = std::auto_ptr<CStandardToolbar>(NULL);

    //m_spStandardToolbar = NULL;
    //m_spAMCViewToolbars = NULL;
}



//############################################################################
//############################################################################
//
//  CAMCView: Object model methods - View Interface
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetOptionalScopeNodeParameter
 *
 * PURPOSE: Helper function - returns the scope node pointer, if supplied
 *          in the variant, or the Active Scope node pointer, if not
 *          supplied.
 *
 * PARAMETERS:
 *    VARIANT  varScopeNode : The parameter, which can be empty. NOTE: This is a
 *                  reference, so we don't need to call VariantClear on it.
 *    PPNODE   ppNode :
 *    bool& bMatchedGivenNode: If true the returned ppNode corresponds to the given node
 *                            applies only if given node is in bookmark format.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetOptionalScopeNodeParameter(VARIANT &varScopeNode, PPNODE ppNode, bool& bMatchedGivenNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetOptionalScopeNodeParameter"));

    sc = ScCheckPointers(ppNode);
    if(sc)
        return sc;

    // init the out parameter
    *ppNode = NULL;
    bMatchedGivenNode = true;

    // supply the optional parameter if it is missing
    if(IsOptionalParamMissing(varScopeNode))
    {
        sc = Scget_ActiveScopeNode(ppNode);
        return sc;
    }

    VARIANT* pvarTemp = ConvertByRefVariantToByValue(&varScopeNode);
    sc = ScCheckPointers(pvarTemp,E_UNEXPECTED);
    if(sc)
        return sc;

    bool bByReference = ( VT_BYREF == (V_VT(pvarTemp) & VT_BYREF) ); // value passed by reference
    UINT uiVarType = (V_VT(pvarTemp) & VT_TYPEMASK); // get variable type (strip flags)


    if(uiVarType == VT_DISPATCH) // do we have a dispatch interface.
    {
        IDispatchPtr spDispatch = NULL;

        if(bByReference)      // a reference, use ppDispVal
            spDispatch = *(pvarTemp->ppdispVal);
        else
            spDispatch = pvarTemp->pdispVal;  // passed by value, use pDispVal

        sc = ScCheckPointers(spDispatch.GetInterfacePtr());
        if(sc)
            return sc;

        // at this point spDispatch is correctly set. QI for Node from it.

        NodePtr spNode = spDispatch;
        if(spNode == NULL)
            return (sc = E_INVALIDARG);

        *ppNode = spNode.Detach(); // keep the reference.
    }
    else if(uiVarType == VT_BSTR)
    {
        // Name: get string properly ( see if it's a reference )
        LPOLESTR lpstrBookmark = bByReference ? *(pvarTemp->pbstrVal) : pvarTemp->bstrVal;

        // get the bookmark
        CBookmark bm;
        sc = bm.ScLoadFromString(lpstrBookmark);
        if(sc)
            return sc;

        if(!bm.IsValid())
            return (sc = E_UNEXPECTED);

        IScopeTree* const pScopeTree = GetScopeTreePtr();
        sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
        if(sc)
            return sc;

        NodePtr spNode;

        // Need a bool variable to find if exact match is found or not, cannot return
        // MMC specific error codes from nodemgr to conui.
        bMatchedGivenNode = false;
        sc = pScopeTree->GetNodeFromBookmark( bm, this, ppNode, bMatchedGivenNode);
        if(sc)
            return sc;
    }
    else
        return (sc = E_INVALIDARG);


    // we should have a valid node at this point.
    if(!ppNode)
        return (sc = E_UNEXPECTED);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_ActiveScopeNode
 *
 * PURPOSE: Implements get method for Wiew.ActiveScopeNode property
 *
 * PARAMETERS:
 *    PPNODE ppNode - resulting node
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_ActiveScopeNode( PPNODE ppNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ActiveScopeNode"));

    // checking parameters
    sc= ScCheckPointers(ppNode);
    if (sc)
        return sc;

    // get selected node
    HNODE hNode = GetSelectedNode();
    sc= ScCheckPointers((LPVOID)hNode, E_FAIL);
    if (sc)
        return sc;

    // get node callback
    INodeCallback* pNodeCallBack = GetNodeCallback();
    sc= ScCheckPointers(pNodeCallBack, E_FAIL);
    if (sc)
        return sc;

    // now get an HMTNODE
    HMTNODE hmtNode = NULL;
    sc = pNodeCallBack->GetMTNode(hNode, &hmtNode);
    if (sc)
        return sc;

    // geting pointer to scope tree
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc= ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    // map to PNODE
    sc = pScopeTree->GetMMCNode(hmtNode, ppNode);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CExpandSyncModeLock
 *
 * PURPOSE: constructing the object of this class locks MMC in syncronous
 *          expansion mode (node expansion will send MMCN_EXPANDSYNC to snapin)
 *          destructor of the class restores the previous mode
 *
\***************************************************************************/
class CExpandSyncModeLock
{
    IScopeTreePtr m_spScopeTree;
    bool          m_fSyncExpandWasRequired;
public:
    CExpandSyncModeLock( IScopeTree *pScopeTree ) : m_spScopeTree(pScopeTree),
                                                    m_fSyncExpandWasRequired(false)
    {
        ASSERT( m_spScopeTree != NULL );
        if ( m_spScopeTree )
        {
            m_fSyncExpandWasRequired = (m_spScopeTree->IsSynchronousExpansionRequired() == S_OK);
            m_spScopeTree->RequireSynchronousExpansion (true);
        }
    }

    ~CExpandSyncModeLock()
    {
        if ( m_spScopeTree )
        {
            m_spScopeTree->RequireSynchronousExpansion ( m_fSyncExpandWasRequired );
        }
    }
};

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scset_ActiveScopeNode
 *
 * PURPOSE: Implements set method for Wiew.ActiveScopeNode property
 *
 * PARAMETERS:
 *    PNODE pNode - node to activate
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scput_ActiveScopeNode( PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_ActiveScopeNode"));

    // checking parameters
    sc= ScCheckPointers(pNode);
    if (sc)
        return sc;

    // geting pointer to scope tree
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc= ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    // Converting PNODE to TNODEID
    MTNODEID ID = 0;
    sc = pScopeTree->GetNodeID(pNode, &ID);
    if (sc)
        return sc;

    // always require syncronous expansion for Object Model
    // see bug #154694
    CExpandSyncModeLock lock( pScopeTree );

    // selecting the node
    sc = ScSelectNode(ID);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_Selection
 *
 * PURPOSE: creates enumerator for Selected Nodes
 *
 * PARAMETERS:
 *    PPNODES ppNodes - resulting enumerator
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_Selection( PPNODES ppNodes )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_SelectedItems"));

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // get enumerator from list control
    sc = m_pListCtrl->Scget_SelectedItems(ppNodes);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_ListItems
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    PPNODES ppNodes - resulting enumerator
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_ListItems( PPNODES ppNodes )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ListItems"));

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // get enumerator from list control
    sc = m_pListCtrl->Scget_ListItems(ppNodes);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScSnapinScopeObject
//
//  Synopsis:    Get the IDispatch* from snapin for given ScopeNode object.
//
//  Arguments:   varScopeNode          - Given ScopeNode object.
//               ScopeNodeObject [out] - IDispatch for ScopeNode object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSnapinScopeObject (VARIANT& varScopeNode, /*[out]*/PPDISPATCH ScopeNodeObject)
{
    DECLARE_SC(sc, _T("CAMCView::ScSnapinScopeObject"));
    sc = ScCheckPointers(ScopeNodeObject);
    if (sc)
        return sc;

    *ScopeNodeObject = NULL;

    bool bMatchedGivenNode = false; // unused
    NodePtr spNode = NULL;
    sc = ScGetOptionalScopeNodeParameter(varScopeNode, &spNode, bMatchedGivenNode);
    if(sc)
        return sc;

    INodeCallback* pNC        = GetNodeCallback();

    sc = ScCheckPointers(spNode.GetInterfacePtr(), pNC, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = pNC->QueryCompDataDispatch(spNode, ScopeNodeObject);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScSnapinSelectionObject
//
//  Synopsis:    Get the IDispatch* from snapin for selected items in result pane.
//
//  Arguments:   SelectedObject [out] - IDispatch for Selected items object.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSnapinSelectionObject (PPDISPATCH SelectedObject)
{
    DECLARE_SC(sc, _T("CAMCView::ScSnapinSelectionObject"));
    sc = ScCheckPointers(SelectedObject);
    if (sc)
        return sc;

    *SelectedObject = NULL;

    if (!HasList()) // not a list. Return error
        return (sc = ScFromMMC(MMC_E_NOLIST));

    LPARAM lvData = LVDATA_ERROR;
    sc = ScGetSelectedLVItem(lvData);
    if (sc)
        return sc;

    HNODE  hNode   = GetSelectedNode();
    sc = ScCheckPointers(hNode, E_UNEXPECTED);
    if (sc)
        return sc;

    INodeCallback* pNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pNodeCallback->QueryComponentDispatch(hNode, lvData, SelectedObject);
    if (sc)
        return sc;

    return (sc);
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScIs
 *
 * PURPOSE: compares two views if they are the same
 *
 * PARAMETERS:
 *    PVIEW pView               - [in] another view
 *    VARIANT_BOOL * pbTheSame  - [out] comparison result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScIs (PVIEW pView, VARIANT_BOOL *pbTheSame)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScIs"));

    // parameter check
    sc = ScCheckPointers(pView, pbTheSame);
    if (sc)
        return sc;

    *pbTheSame = CComPtr<View>(pView).IsEqualObject(m_spView)
                 ? VARIANT_TRUE : VARIANT_FALSE;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScSelectAll
//
//  Synopsis:    Selects all items in the result pane
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSelectAll ()
{
    DECLARE_SC(sc, _T("CAMCView::ScSelectAll"));

    if (! (GetListOptions() & RVTI_LIST_OPTIONS_MULTISELECT) )
        return (sc = ScFromMMC(MMC_E_NO_MULTISELECT));

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward to list control
    sc = m_pListCtrl->ScSelectAll();
    if (sc)
        return sc;

    return (sc);
}


/***************************************************************************\
 *
 * METHOD:  CAMCView::ScSelect
 *
 * PURPOSE: selects item identified by node [implements View.Select()]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to select
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScSelect( PNODE pNode )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSelect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward to list control
    sc = m_pListCtrl->ScSelect( pNode );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScDeselect
 *
 * PURPOSE: deselects item identified by node [implements View.Deselect()]
 *
 * PARAMETERS:
 *    PNODE pNode   - node to deselect
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScDeselect( PNODE pNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScDeselect"));

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward to list control
    sc = m_pListCtrl->ScDeselect( pNode );
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScIsSelected
 *
 * PURPOSE: checks the status of item identified by node [implements View.IsSelected]
 *
 * PARAMETERS:
 *    PNODE pNode       - node to examine
 *    PBOOL pIsSelected - storage for result
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScIsSelected( PNODE pNode,  PBOOL pIsSelected )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScIsSelected"));

    // parameter check
    sc = ScCheckPointers(pNode, pIsSelected);
    if (sc)
        return sc;

    *pIsSelected = FALSE;

    // check for list view control
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward to list control
    sc = m_pListCtrl->ScIsSelected( pNode, pIsSelected );
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScExecuteScopeItemVerb
//
//  Synopsis:    Get the context and pass it on to nodemgr to execute
//               given verb.
//
//  Arguments:   [verb]         - Verb to execute
//               [varScopeNode] - Optional scope node (if not given,
//                                 currently selected item will be used.)
//               [bstrNewName]  - valid for Rename else NULL.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScExecuteScopeItemVerb (MMC_CONSOLE_VERB verb, VARIANT& varScopeNode, BSTR bstrNewName)
{
    DECLARE_SC(sc, _T("CAMCView::ScExecuteScopeItemVerb"));

    NodePtr spNode = NULL;
    bool bMatchedGivenNode = false;
    // We should navigate to exact node to execute the verb.
    sc = ScGetOptionalScopeNodeParameter(varScopeNode, &spNode, bMatchedGivenNode);
    if(sc)
        return sc;

    if (! bMatchedGivenNode)
        return (sc = ScFromMMC(IDS_ACTION_COULD_NOTBE_COMPLETED));

    HNODE hNode = NULL;
    sc = ScGetHNodeFromPNode(spNode, hNode);
    if (sc)
        return sc;

    INodeCallback* pNC        = GetNodeCallback();
    sc = ScCheckPointers(spNode.GetInterfacePtr(), pNC);
    if(sc)
        return sc;

    sc = pNC->ExecuteScopeItemVerb(verb, hNode, bstrNewName);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScExecuteResultItemVerb
//
//  Synopsis:    Get the currently selected context and pass it on to
//               nodemgr to execute given verb.
//
//  Arguments:   [verb]         - Verb to execute
//               [bstrNewName]  - valid for Rename else NULL.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScExecuteResultItemVerb (MMC_CONSOLE_VERB verb, BSTR bstrNewName)
{
    DECLARE_SC(sc, _T("CAMCView::ScExecuteResultItemVerb"));

    if (!HasList()) // not a list. Return error
        return (sc = ScFromMMC(MMC_E_NOLIST));

    LPARAM lvData = LVDATA_ERROR;
    sc = ScGetSelectedLVItem(lvData);
    if (sc)
        return sc;

    if (lvData == LVDATA_ERROR)
        return (sc = E_UNEXPECTED);

    HNODE  hNode   = GetSelectedNode();
    sc = ScCheckPointers(hNode, E_UNEXPECTED);
    if (sc)
        return sc;

    INodeCallback* pNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pNodeCallback->ExecuteResultItemVerb( verb, hNode, lvData, bstrNewName);
    if (sc)
        return sc;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScDisplayScopeNodePropertySheet
 *
 * PURPOSE: Displays the property sheet for a scope node.
 *
 * PARAMETERS:
 *    VARIANT  varScopeNode :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScDisplayScopeNodePropertySheet(VARIANT& varScopeNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScDisplayPropertySheet"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_PROPERTIES, varScopeNode, NULL);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDisplaySelectionPropertySheet
//
//  Synopsis:    Show the property sheet for selected result item(s).
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScDisplaySelectionPropertySheet ()
{
    DECLARE_SC(sc, _T("CAMCView::ScDisplaySelectionPropertySheet"));

    sc = ScExecuteResultItemVerb(MMC_VERB_PROPERTIES, NULL);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScCopyScopeNode
//
//  Synopsis:    Copy the specified scope node (if given) or currently
//               selected node to clipboard.
//
//  Arguments:   [varScopeNode] - given node.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScCopyScopeNode (VARIANT& varScopeNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScCopyScopeNode"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_COPY, varScopeNode, NULL);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScCopySelection
//
//  Synopsis:    Copy the selected result item(s) to clipboard.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScCopySelection ()
{
    DECLARE_SC(sc, _T("CAMCView::ScCopySelection"));

    sc = ScExecuteResultItemVerb(MMC_VERB_COPY, NULL);
    if (sc)
        return sc;

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDeleteScopeNode
//
//  Synopsis:    Deletes the specified scope node (if given) or currently
//               selected node.
//
//  Arguments:   [varScopeNode] - node to delete
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScDeleteScopeNode (VARIANT& varScopeNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScDeleteScopeNode"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_DELETE, varScopeNode, NULL);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDeleteSelection
//
//  Synopsis:    Deletes the selected item(s) in result pane.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScDeleteSelection ()
{
    DECLARE_SC(sc, _T("CAMCView::ScDeleteSelection"));

    sc = ScExecuteResultItemVerb(MMC_VERB_DELETE, NULL);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScRenameScopeNode
//
//  Synopsis:    Rename the specified scope node (if given) or currently
//               selected node with given new name.
//
//  Arguments:   [bstrNewName]  - the new name
//               [varScopeNode] - given node.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScRenameScopeNode (BSTR    bstrNewName, VARIANT& varScopeNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScRenameScopeNode"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_RENAME, varScopeNode, bstrNewName);
    if (sc)
        return sc;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScRenameSelectedItem
//
//  Synopsis:    Rename the selected result item with given new name.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScRenameSelectedItem (BSTR    bstrNewName)
{
    DECLARE_SC(sc, _T("CAMCView::ScRenameSelectedItem"));

    sc = ScExecuteResultItemVerb(MMC_VERB_RENAME, bstrNewName);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScRefreshScopeNode
//
//  Synopsis:    Refresh the specified scope node (if given) or currently
//               selected node.
//
//  Arguments:   [varScopeNode] - given node.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScRefreshScopeNode (VARIANT& varScopeNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScRefreshScopeNode"));

    sc = ScExecuteScopeItemVerb(MMC_VERB_REFRESH, varScopeNode, NULL);
    if (sc)
        return sc;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScRefreshSelection
//
//  Synopsis:    Refresh the selected result item(s).
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScRefreshSelection ()
{
    DECLARE_SC(sc, _T("CAMCView::ScRefreshSelection"));

    sc = ScExecuteResultItemVerb(MMC_VERB_REFRESH, NULL);
    if (sc)
        return sc;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_ScopeNodeContextMenu
 *
 * PURPOSE: Creates a context menu for a scope node and returns it.
 *
 * PARAMETERS:
 *    VARIANT        varScopeNode :
 *    PPCONTEXTMENU  ppContextMenu :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_ScopeNodeContextMenu(VARIANT& varScopeNode,  PPCONTEXTMENU ppContextMenu, bool bMatchGivenNode /* = false*/)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ContextMenu"));

    NodePtr spNode;
    // See if context menu for exactly the given node is asked for.
    bool bMatchedGivenNode = false;
    sc = ScGetOptionalScopeNodeParameter(varScopeNode, &spNode, bMatchedGivenNode);
    if (sc)
        return sc;

    if ( (bMatchGivenNode) && (!bMatchedGivenNode) )
        return ScFromMMC(IDS_NODE_NOT_FOUND);

    if(sc)
        return sc;

    INodeCallback* spNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(spNode, ppContextMenu, spNodeCallback, GetTreeCtrl());
    if(sc)
        return sc.ToHr();

    *ppContextMenu = NULL; // initialize output.

    HNODE hNode = NULL;
    sc = ScGetHNodeFromPNode(spNode, hNode);
    if (sc)
        return sc;

    // tell the node callback to add menu items for the scope node.
    sc = spNodeCallback->CreateContextMenu(spNode, hNode, ppContextMenu);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_SelectionContextMenu
 *
 * PURPOSE: Creates a context menu for the current selection and returns it.
 *
 * PARAMETERS:
 *    PPCONTEXTMENU  ppContextMenu : [OUT]: The context menu object
 *
 * RETURNS:
 *    SC : error if no list exists, or there is nothing selected.
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_SelectionContextMenu( PPCONTEXTMENU ppContextMenu)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_SelectionContextMenu"));

    sc = ScCheckPointers(ppContextMenu);
    if(sc)
        return sc;

    if (!HasListOrListPad()) // not a list. Return error
        return (sc = ScFromMMC(MMC_E_NOLIST));

    INodeCallback* pNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback);
    if(sc)
        return sc.ToHr();

    CContextMenuInfo contextInfo; // the structure to pass to nodemgr

    // common entries
    contextInfo.m_pConsoleView       = this;

    // always use the temp verbs - cannot depend on what the active pane is
    contextInfo.m_dwFlags = CMINFO_USE_TEMP_VERB;

    int iIndex = -1;

    HNODE hNode = GetSelectedNode();
    ASSERT(hNode != NULL);

    int cSel = m_pListCtrl->GetSelectedCount();
    if(0 == cSel)
    {
        // no items selected, bail
        return (sc = ScFromMMC(MMC_E_NO_SELECTED_ITEMS));
    }
    else if(1 == cSel)
    {
        // single selection
        LPARAM lvData = LVDATA_ERROR;
        iIndex = _GetLVSelectedItemData(&lvData);
        ASSERT(iIndex != -1);
        ASSERT(lvData != LVDATA_ERROR);

        if (IsVirtualList())
        {
            // virtual list item in the result pane
            contextInfo.m_eDataObjectType  = CCT_RESULT;
            contextInfo.m_eContextMenuType = MMC_CONTEXT_MENU_DEFAULT;
            contextInfo.m_bBackground      = false;
            contextInfo.m_bMultiSelect     = false;
            contextInfo.m_resultItemParam  = iIndex;
            contextInfo.m_iListItemIndex   = iIndex;
        }
        else
        {
            CResultItem* pri = CResultItem::FromHandle (lvData);
            if(!pri)
                return (sc = E_UNEXPECTED);

            if (pri->IsScopeItem())
            {
                // scope item in the result pane
                contextInfo.m_eDataObjectType       = CCT_SCOPE;
                contextInfo.m_eContextMenuType      = MMC_CONTEXT_MENU_DEFAULT;
                contextInfo.m_bBackground           = FALSE;
                contextInfo.m_hSelectedScopeNode    = GetSelectedNode();
                contextInfo.m_resultItemParam       = NULL;
                contextInfo.m_bMultiSelect          = FALSE;
                contextInfo.m_bScopeAllowed         = TRUE;

                // change the scope node on which the menu is to be displayed
                hNode = pri->GetScopeNode();
            }
            else
            {
                // single result item in the result pane
                contextInfo.m_eDataObjectType  = CCT_RESULT;
                contextInfo.m_eContextMenuType = MMC_CONTEXT_MENU_DEFAULT;
                contextInfo.m_bBackground      = false;
                contextInfo.m_bMultiSelect     = false;
                contextInfo.m_resultItemParam  = lvData;
                contextInfo.m_iListItemIndex   = iIndex;

            }
        }
    }
    else
    {
        // multiselection
        iIndex = INDEX_MULTISELECTION; // => MultiSelect

        contextInfo.m_eDataObjectType  = CCT_RESULT;
        contextInfo.m_eContextMenuType = MMC_CONTEXT_MENU_DEFAULT;
        contextInfo.m_bBackground      = false;
        contextInfo.m_bMultiSelect     = true;
        contextInfo.m_resultItemParam  = LVDATA_MULTISELECT;
        contextInfo.m_iListItemIndex   = iIndex;
    }

    sc = pNodeCallback->CreateSelectionContextMenu(hNode, &contextInfo, ppContextMenu);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExecuteMenuItem
 *
 * PURPOSE: Executes the specified context menu item on the specified context menu
 *
 * PARAMETERS:
 *    PCONTEXTMENU  pContextMenu :
 *    BSTR          MenuItemPath : Either the language-independent path or the
 *                                 language-dependent path.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScExecuteMenuItem(PCONTEXTMENU pContextMenu, BSTR MenuItemPath)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScExecuteMenuItem"));

    sc = ScCheckPointers(MenuItemPath);
    if(sc)
        return sc;

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc;

    // execute the menu item, if found.
    MenuItemPtr spMenuItem;
    sc = pContextMenu->get_Item(CComVariant(MenuItemPath), &spMenuItem);
    if(sc.IsError() || sc == SC(S_FALSE)) // error or no item
        return (sc = E_INVALIDARG); // did not find the menu item.

    // recheck the pointer
    sc = ScCheckPointers(spMenuItem, E_UNEXPECTED);
    if (sc)
        return sc;

    // found - execute it
    sc = spMenuItem->Execute();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExecuteSelectionMenuItem
 *
 * PURPOSE: Executes a context menu item on the selection.
 *
 * PARAMETERS:
 *    BSTR  MenuItemPath : Either the language-independent path or the
 *                                 language-dependent path of the menu item.

 *
 * NOTE: This is an aggregate or utility function - it only uses other
 *       object model functions
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScExecuteSelectionMenuItem(BSTR MenuItemPath)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScExecuteSelectionMenuItem"));

    // get the context menu object
    ContextMenuPtr spContextMenu;
    sc = Scget_SelectionContextMenu(&spContextMenu);
    if(sc)
        return sc;

    sc = ScExecuteMenuItem(spContextMenu, MenuItemPath);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExecuteScopeNodeMenuItem
 *
 * PURPOSE: Executes a context menu item on the specified scope node. The parameter
 *          is the language independent path of the menu item
 *
 * PARAMETERS:
 *    BSTR  MenuItemLanguageIndependentPath :
 *
 * NOTE: This is an aggregate or utility function - it only uses other
 *       object model functions
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScExecuteScopeNodeMenuItem(BSTR MenuItemPath, VARIANT &varScopeNode  /* = ActiveScopeNode */)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScExecuteScopeNodeMenuItem"));

    // get the context menu object for exactly the given node.
    ContextMenuPtr spContextMenu;
    sc = Scget_ScopeNodeContextMenu(varScopeNode, &spContextMenu, /*bMatchGivenNode = */ true);

    if (sc == ScFromMMC(IDS_NODE_NOT_FOUND))
    {
        sc = ScFromMMC(IDS_ACTION_COULD_NOTBE_COMPLETED);
        return sc;
    }

    if(sc)
        return sc;

    sc = ScExecuteMenuItem(spContextMenu, MenuItemPath);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExecuteShellCommand
 *
 * PURPOSE: Executes a shell command with the specified parameters in the
 *          specified directory with the correct window size
 *
 * PARAMETERS:
 *    BSTR  Command :
 *    BSTR  Directory :
 *    BSTR  Parameters :
 *    BSTR  WindowState :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScExecuteShellCommand(BSTR Command, BSTR Directory, BSTR Parameters, BSTR WindowState)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScExecuteShellCommand"));

    sc = ScCheckPointers(Command, Directory, Parameters, WindowState);
    if(sc)
        return sc;

    INodeCallback *pNodeCallback = GetNodeCallback();
    HNODE          hNodeSel      = GetSelectedNode();

    sc = ScCheckPointers(pNodeCallback, hNodeSel, E_UNEXPECTED);
    if(sc)
        return sc;

    sc = pNodeCallback->ExecuteShellCommand(hNodeSel, Command, Directory, Parameters, WindowState);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_ListViewMode
 *
 * PURPOSE: Returns the list view mode, if available.
 *
 * PARAMETERS:
 *    ListViewMode * pMode :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_ListViewMode(PLISTVIEWMODE pMode)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ListViewMode"));

    // check parameter
    if(!pMode)
    {
        sc = E_INVALIDARG;
        return sc;
    }

    if (!HasList())
        return (ScFromMMC(MMC_E_NOLIST));

    int mode = 0;

    // translate it into an automation friendly enum
    switch(GetViewMode())
    {
    default:
        ASSERT( 0 && "Should not come here");
        // fall thru.

    case LVS_LIST:
        *pMode = ListMode_List;
        break;

    case LVS_ICON:
        *pMode = ListMode_Large_Icons;
        break;

    case LVS_SMALLICON:
        *pMode = ListMode_Small_Icons;
        break;

    case LVS_REPORT:
        *pMode = ListMode_Detail;
        break;

    case MMCLV_VIEWSTYLE_FILTERED:
        *pMode = ListMode_Filtered;
        break;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_ListViewMode
 *
 * PURPOSE: Sets the list mode to the specified mode.
 *
 * PARAMETERS:
 *    ListViewMode  mode :
 *
 * RETURNS:
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scput_ListViewMode(ListViewMode mode)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_ListViewMode"));

    int nMode;

    if (!HasList())
        return (ScFromMMC(MMC_E_NOLIST));

    switch (mode)
    {
    default:
        sc = E_INVALIDARG;
        return sc;

    case ListMode_List:
        nMode = LVS_LIST;
        break;
    case ListMode_Detail:
        nMode = LVS_REPORT;
        break;
    case ListMode_Large_Icons:
        nMode = LVS_ICON;
        break;
    case ListMode_Small_Icons:
        nMode = LVS_SMALLICON;
        break;

    case ListMode_Filtered:
        nMode = MMCLV_VIEWSTYLE_FILTERED;
        break;
    }

    sc = ScChangeViewMode(nMode);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScBack
 *
 * PURPOSE: Invokes the Back command on the view.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScBack()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScBack"));

    sc = ScWebCommand(CConsoleView::eWeb_Back);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScForward
 *
 * PURPOSE: Invokes the Forward command on the view.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScForward()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScForward"));

    sc = ScWebCommand(CConsoleView::eWeb_Forward);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_StatusBarText
 *
 * PURPOSE: Sets the status bar text for the view
 *
 * PARAMETERS:
 *    BSTR  StatusBarText :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scput_StatusBarText(BSTR StatusBarText)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_StatusBarText"));

    // check the in parameter
    sc = ScCheckPointers(StatusBarText);
    if(sc)
        return sc;

    CConsoleStatusBar *pStatusBar = m_ViewData.GetStatusBar();
    sc = ScCheckPointers(pStatusBar, E_UNEXPECTED);
    if(sc)
        return sc;

    USES_CONVERSION;
    // set the status text
    sc = pStatusBar->ScSetStatusText(OLE2T(StatusBarText));

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_Memento
 *
 * PURPOSE: Returns the XML version of the memento for the current view.
 *
 * PARAMETERS:
 *    PBSTR  Memento : [out]: The memento
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_Memento(PBSTR Memento)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Memento"));

    sc = ScCheckPointers(Memento);
    if(sc)
       return sc;

    // initialize the out parameter
    *Memento = NULL;

    CMemento memento;
    sc = ScInitializeMemento(memento);
    if(sc)
        return sc;

    std::wstring xml_contents;
    sc = memento.ScSaveToString(&xml_contents);
    if(sc)
        return sc.ToHr();

    // store the result
    CComBSTR bstrBuff(xml_contents.c_str());
    *Memento = bstrBuff.Detach();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScViewMemento
 *
 * PURPOSE: Sets the view from the specified XML memento.
 *
 * PARAMETERS:
 *    BSTR  Memento :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScViewMemento(BSTR Memento)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScViewMemento"));

    sc = ScCheckPointers(Memento);
    if(sc)
        return sc;

    CMemento memento;
    sc = memento.ScLoadFromString(Memento);
    if(sc)
        return sc;

    sc = ScViewMemento(&memento);
    if (sc == ScFromMMC(IDS_NODE_NOT_FOUND))
        return (sc = ScFromMMC(IDS_ACTION_COULD_NOTBE_COMPLETED));

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::Scget_CellContents
//
//  Synopsis:    Given row & column, get the text.
//
//  Arguments:   Node:               - the row
//               [Column]            - 1 based column index
//               [pbstrCellContents] - return value, contents of cell.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::Scget_CellContents (PNODE Node,  long Column, PBSTR pbstrCellContents)
{
    DECLARE_SC(sc, _T("CAMCView::Scget_CellContents"));
    sc = ScCheckPointers(Node, pbstrCellContents);
    if (sc)
        return sc;

    *pbstrCellContents = NULL;

    if (!HasList())
        return (ScFromMMC(MMC_E_NOLIST));

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // No need to check if we are in REPORT mode as columns exist
    // even in other modes (small icon....).

    int iItem = -1;
    sc = m_pListCtrl->ScFindResultItem( Node, iItem );
    if (sc)
        return sc;

    // Script uses 1- based index for columns & rows.
    // ColCount are total # of cols.
    if (m_pListCtrl->GetColCount() < Column)
        return (sc = E_INVALIDARG);

    CListCtrl& ctlList = m_pListCtrl->GetListCtrl();

    CString strData = ctlList.GetItemText(iItem, Column-1 /*convert to zero-based*/);
    *pbstrCellContents = strData.AllocSysString();

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScExportList
//
//  Synopsis:    Export the list view data to given file with given options.
//
//  Arguments:   [bstrFile]       - File to save to.
//               [exportoptions]  - (Unicode, tab/comma delimited & selected rows only).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScExportList (BSTR bstrFile, ExportListOptions exportoptions)
{
    DECLARE_SC(sc, _T("CAMCView::ScExportList"));

    if (SysStringLen(bstrFile) < 1)
        return (sc = E_INVALIDARG);

    if (!HasList())
        return (ScFromMMC(MMC_E_NOLIST));

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    bool bUnicode          = (exportoptions & ExportListOptions_Unicode);
    bool bTabDelimited     = (exportoptions & ExportListOptions_TabDelimited);
    bool bSelectedRowsOnly = (exportoptions & ExportListOptions_SelectedItemsOnly);

    USES_CONVERSION;
    LPCTSTR lpszFileName = OLE2T(bstrFile);

    sc = ScWriteExportListData(lpszFileName, bUnicode,
                               bTabDelimited, bSelectedRowsOnly,
                               false /*bShowErrorDialogs*/);
    if (sc)
        return (sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScClose
 *
 * PURPOSE: Implements Wiew.Close method
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScClose()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScClose"));

    // get the frame and the document
    CChildFrame* pFrame = GetParentFrame();
    CAMCDoc* pDoc = CAMCDoc::GetDocument();
    sc= ScCheckPointers(pDoc, pFrame, E_FAIL);
    if (sc)
        return sc;

    // count the views
    int cViews = 0;
    CAMCViewPosition pos = pDoc->GetFirstAMCViewPosition();
    while (pos != NULL)
    {
        CAMCView* pView = pDoc->GetNextAMCView(pos);

        if ((pView != NULL) && ++cViews >= 2)
            break;
    }

    // prevent closing the document this way !!!
    if (cViews == 1)
    {
        sc.FromMMC(IDS_CloseDocNotLastView);
        return sc;
    }

    // if not closing last view, then give it
    // a chance to clean up first.
    // (if whole doc is closing CAMCDoc will handle
    //  closing all the views.)

    /*
     * Don't allow the user to close the last persisted view.
     */
    if (IsPersisted() && (pDoc->GetNumberOfPersistedViews() == 1))
    {
        sc.FromMMC(IDS_CantCloseLastPersistableView);
        return sc;
    }

    // checkings done, do close
    // do it indirectly so that it won't hurt the view extension it it
    // tries to close itself
    pFrame->PostMessage(WM_CLOSE);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scget_ScopeTreeVisible
 *
 * PURPOSE: Implements get method for Wiew.ScopeTreeVisible property
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scget_ScopeTreeVisible( PBOOL pbVisible )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_ScopeTreeVisible"));

    // parameter check...
    sc = ScCheckPointers(pbVisible);
    if (sc)
        return sc;

    *pbVisible = IsScopePaneVisible();

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Scput_ScopeTreeVisible
 *
 * PURPOSE: Implements set method for Wiew.ScopeTreeVisible property
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::Scput_ScopeTreeVisible( BOOL bVisible )
{
    DECLARE_SC(sc, TEXT("CAMCView::Scput_ScopeTreeVisible"));

    // show/hide the scope pane
    sc = ScShowScopePane (bVisible);
    if (sc)
        return (sc);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScFindResultItemForScopeNode
 *
 * PURPOSE: - Calculates result item representing the scope node in the list
 *
 * PARAMETERS:
 *    PNODE pNode       - node to search
 *    HRESULTITEM &itm  - resulting item
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScFindResultItemForScopeNode( PNODE pNode, HRESULTITEM &itm )
{
    DECLARE_SC(sc, TEXT("CAMCView::ScFindResultItemForScopeNode"));

    // initialization
    itm = NULL;

    // parameter check
    sc = ScCheckPointers(pNode);
    if (sc)
        return sc;

    // get/check for list view and tree controls and callback
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc = ScCheckPointers( pScopeTree, m_pTreeCtrl, m_spNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    // retrieve MTNode
    HMTNODE hMTNode = NULL;
    sc = pScopeTree->GetHMTNode(pNode, &hMTNode);
    if (sc)
        return sc;

    // get the pointer to the map
    CTreeViewMap *pTreeMap = m_pTreeCtrl->GetTreeViewMap();
    sc = ScCheckPointers(pTreeMap, E_UNEXPECTED);
    if (sc)
        return sc;

    // find the tree item for the node
    HTREEITEM htiNode = NULL;
    sc = pTreeMap->ScGetHTreeItemFromHMTNode(hMTNode, &htiNode);
    if (sc)
        return sc = ScFromMMC(MMC_E_RESULT_ITEM_NOT_FOUND);

    // try to match the node to the child of selected one
    HTREEITEM htiParent = m_pTreeCtrl->GetParentItem(htiNode);
    if (htiParent == NULL || htiParent != m_pTreeCtrl->GetSelectedItem())
        return sc = ScFromMMC(MMC_E_RESULT_ITEM_NOT_FOUND);

    // the node shold be in the ListView, lets find if!
    HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(htiNode);

    // get result item id
    sc = m_spNodeCallback->GetResultItem (hNode, &itm);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::ScGetScopeNodeForItem
 *
 * PURPOSE: Returns Node (Scope Node) for specified item index
 *
 * PARAMETERS:
 *    int  nItem        - node index to retrieve
 *    PPNODE ppNode     - result storage
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::ScGetScopeNode( HNODE hNode,  PPNODE ppNode )
{
    DECLARE_SC(sc, TEXT("CCCListViewCtrl::ScGetScopeNodeForItem"));

    // check the parameters
    sc = ScCheckPointers(ppNode);
    if (sc)
        return sc;
    // initialize the result
    *ppNode = NULL;


    // get/check required pointers
    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc = ScCheckPointers(pScopeTree, m_spNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    // find MTNode
    HMTNODE hmtNode;
    sc = m_spNodeCallback->GetMTNode(hNode, &hmtNode);
    if (sc)
        return sc;

    // request the object!
    sc = pScopeTree->GetMMCNode(hmtNode, ppNode);
    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CAMCView::Scget_Columns
 *
 * PURPOSE: create new or return pointer to existing Columns object
 *
 * PARAMETERS:
 *    PPCOLUMNS ppColumns - resulting (AddRef'ed) pointer
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CAMCView::Scget_Columns(PPCOLUMNS ppColumns)
{
    DECLARE_SC(sc, TEXT("CAMCView::Scget_Columns"));

    // Check received parameters
    sc = ScCheckPointers(ppColumns);
    if (sc)
        return sc;

    // initialize
    *ppColumns = NULL;

    // Check the pointer to LV
    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    // forward the request to LV
    sc = m_pListCtrl->Scget_Columns(ppColumns);
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetSelectedLVItem
//
//  Synopsis:    Return the LVItem cookie.
//
//  Arguments:   LPARAM     - the LVDATA retval.
//
//  Returns:     SC - Fails if no selected item in LV.
//
//--------------------------------------------------------------------
SC CAMCView::ScGetSelectedLVItem(LPARAM& lvData)
{
    DECLARE_SC(sc, _T("CAMCView::ScGetSelectedLVItem"));

    lvData = LVDATA_ERROR;
    int cSel = m_pListCtrl->GetSelectedCount();
    if(0 == cSel)
    {
        // no items selected, bail
        return (sc = ScFromMMC(MMC_E_NO_SELECTED_ITEMS));
    }
    else if(1 == cSel)
    {
        // single selection
        int iIndex = _GetLVSelectedItemData(&lvData);

        if (iIndex == -1 || lvData == LVDATA_ERROR)
            return (sc = E_UNEXPECTED);

        if (IsVirtualList())
        {
            // virtual list item in the result pane
            lvData = iIndex;
        }
    }
    else if (cSel > 1)
    {
        // multiselection
        lvData = LVDATA_MULTISELECT;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetHNodeFromPNode
//
//  Synopsis:    Takes in PNODE and returns corresponding hNode
//
//  Arguments:   [PNODE] - Given pnode.
//               [HNODE] - ret val.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScGetHNodeFromPNode (const PNODE& pNode, HNODE& hNode)
{
    DECLARE_SC(sc, _T("CAMCView::ScGetHNodeFromPNode"));
    hNode = NULL;

    CAMCTreeView* pAMCTreeView = GetTreeCtrl();
    sc = ScCheckPointers(pAMCTreeView, E_UNEXPECTED);
    if (sc)
        return sc;

    CTreeViewMap *pTreeMap   = pAMCTreeView->GetTreeViewMap();
    IScopeTree   *pScopeTree = GetScopeTree();
    sc = ScCheckPointers(pTreeMap, pScopeTree, E_UNEXPECTED);
    if(sc)
        return sc;

    HMTNODE hMTNode = NULL;
    sc = pScopeTree->GetHMTNode(pNode, &hMTNode);
    if(sc)
        return sc;

    sc = pTreeMap->ScGetHNodeFromHMTNode(hMTNode, &hNode);
    if(sc)
        return sc;

    return (sc);
}



/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetMMCView
 *
 * PURPOSE: Creates, AddRef's, and returns a pointer to the tied COM object.
 *
 * PARAMETERS:
 *    View ** ppView :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetMMCView(View **ppView)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetMMCView"));

    sc = ScCheckPointers(ppView);
    if (sc)
        return sc;

    // init out parameter
    *ppView = NULL;

    // create a CMMCView if needed.
    sc = CTiedComObjectCreator<CMMCView>::ScCreateAndConnect(*this, m_spView);
    if(sc)
        return sc;

    if(m_spView == NULL)
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    // addref the pointer for the client.
    m_spView->AddRef();
    *ppView = m_spView;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::IsDirty
 *
 * PURPOSE: Determines whether or not CAMCView is in a dirty state
 *
 * RETURNS:
 *    bool
 *
 *+-------------------------------------------------------------------------*/
bool CAMCView::IsDirty()
{
    bool bRet = m_bDirty;

    if (!m_bDirty && !m_fRootedAtNonPersistedDynamicNode)
       bRet = HasNodeSelChanged();

    TraceDirtyFlag(TEXT("CAMCView"), bRet);

    return (bRet);
}


/////////////////////////////////////////////////////////////////////////////
// CAMCView drawing

void CAMCView::OnDraw(CDC* pDC)
{
    if (IsScopePaneVisible())
    {
        pDC->FillRect (m_rectVSplitter, AMCGetSysColorBrush (COLOR_3DFACE));
    }
}

/////////////////////////////////////////////////////////////////////////////
// CAMCView printing

BOOL CAMCView::OnPreparePrinting(CPrintInfo* pInfo)
{
    TRACE_METHOD(CAMCView, OnPreparePrinting);

    // default preparation
    return DoPreparePrinting(pInfo);
}

void CAMCView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    TRACE_METHOD(CAMCView, OnBeginPrinting);

}

void CAMCView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    TRACE_METHOD(CAMCView, OnEndPrinting);

}


/////////////////////////////////////////////////////////////////////////////
// CAMCView diagnostics

#ifdef _DEBUG
void CAMCView::AssertValid() const
{
    CView::AssertValid();
}

void CAMCView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CAMCDoc* CAMCView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CAMCDoc)));
    return (CAMCDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAMCView message handlers

//+-------------------------------------------------------------------------
//
//  Function:   PreCreateWindow
//
//  Synopsis:   Create new window class (CAMCView) - WS_EX_CLIENTEDGE
//
//--------------------------------------------------------------------------

BOOL CAMCView::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style |=  WS_CLIPCHILDREN;
    cs.style &= ~WS_BORDER;

    // give base class a chance to do own job
    BOOL bOK = (CView::PreCreateWindow(cs));

    // register view class
    LPCTSTR pszViewClassName = g_szAMCViewWndClassName;

    // try to register window class which does not cause the repaint
    // on resizing (do it only once)
    static bool bClassRegistered = false;
    if ( !bClassRegistered )
    {
        WNDCLASS wc;
        if (::GetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wc))
        {
            // Clear the H and V REDRAW flags
            wc.style &= ~(CS_HREDRAW | CS_VREDRAW);
            wc.lpszClassName = pszViewClassName;
            // Register this new class;
            bClassRegistered = AfxRegisterClass(&wc);
        }
    }

    // change window class to one which does not cause the repaint
    // on resizing if we successfully registered such
    if ( bClassRegistered )
        cs.lpszClass = pszViewClassName;

    return bOK;
}


//+-------------------------------------------------------------------------
//
//  Function:   OnCreate
//
//  Synopsis:   Create Window, and Tree control / Default List control
//
//--------------------------------------------------------------------------

int CAMCView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    DECLARE_SC(sc, _T("CAMCView::OnCreate"));

    if (CView::OnCreate(lpCreateStruct) == -1)
    {
        sc = E_FAIL;
        return -1;
    }

    CChildFrame* pFrame = GetParentFrame();
    ASSERT(NULL != pFrame);
    if (pFrame)
        pFrame->SetAMCView(this);

    m_ViewData.SetStatusBar (dynamic_cast<CConsoleStatusBar*>(pFrame));
    m_ViewData.SetConsoleView (this);

    m_RightDescCtrl.Create (NULL, WS_CHILD, g_rectEmpty, this, IDC_RightDescBar);

    ASSERT (m_pDocument != NULL);
    ASSERT (m_pDocument == CAMCDoc::GetDocument());
    ASSERT_KINDOF (CAMCDoc, m_pDocument);
    CAMCDoc* pAMCDoc = reinterpret_cast<CAMCDoc *>(m_pDocument);

    CCreateContext* pContext = (CCreateContext*) lpCreateStruct->lpCreateParams;
    ASSERT (pContext != NULL);

    // Set window options
    m_ViewData.m_lWindowOptions = pAMCDoc->GetNewWindowOptions();

    /*
     * If the scope pane is suppressed, clear the scope-visible flag.
     * It's not necessary to call ScShowScopePane here because none of
     * the windows have been created yet.  We just need to keep our
     * interal accounting correct.
     */
    if (m_ViewData.m_lWindowOptions & MMC_NW_OPTION_NOSCOPEPANE)
        SetScopePaneVisible (false);

    // Create tree ctrl.
    if (!CreateView (IDC_TreeView) || (!m_pTreeCtrl) )
    {
        sc = E_FAIL;
        return -1;
    }

    SetPane(ePane_ScopeTree, m_pTreeCtrl, uiClientEdge);

    if (!AreStdToolbarsAllowed())
        m_ViewData.m_dwToolbarsDisplayed &= ~(STD_MENUS | STD_BUTTONS);

    // Create default list control
    if (!CreateListCtrl (IDC_ListView, pContext))
    {
        sc = E_FAIL;
        return -1;
    }

    // Create the folder tab control
    if (!CreateFolderCtrls ())
    {
        sc = E_FAIL;
        return -1;
    }

    // initialize the result pane to the list view
    {
        CResultViewType rvt;

        sc = ScSetResultPane(NULL /*HNODE*/, rvt, MMCLV_VIEWSTYLE_REPORT /*viewMode*/, false /*bUsingHistory*/);
        if(sc)
            return -1;
    }

    sc = ScCreateToolbarObjects();
    if (sc)
        return -1;

    //
    //  Set m_ViewData.
    //

    m_ViewData.m_nViewID = 0;// Set in OnInitialUpdate

    VERIFY ((m_ViewData.m_spNodeManager   = m_pTreeCtrl->m_spNodeManager)   != NULL);
    VERIFY ((m_ViewData.m_spResultData    = m_pTreeCtrl->m_spResultData)    != NULL);
    VERIFY ((m_ViewData.m_spRsltImageList = m_pTreeCtrl->m_spRsltImageList) != NULL);
    VERIFY ( m_ViewData.m_hwndView        = m_hWnd);
    VERIFY ( m_ViewData.m_hwndListCtrl    = m_pListCtrl->GetListViewHWND());
    VERIFY ( m_ViewData.m_pConsoleData    = GetDocument()->GetConsoleData());

    m_ViewData.m_pMultiSelection = NULL;

    if(pFrame)
    {
        // add the MDIClient window's taskbar as an observer
        CMDIFrameWnd * pFrameWnd = pFrame->GetMDIFrame();
        CWnd *pWnd = NULL;
        if(pFrameWnd)
            pWnd = pFrameWnd->GetWindow(GW_CHILD); // get the first child of the frame.
    }

    // add AMCDoc as an observer for this source (object)
    CAMCApp *pCAMCApp = AMCGetApp();
    if ( pCAMCApp )
         AddObserver(*static_cast<CAMCViewObserver *>(pCAMCApp));

    // fire the view creation event to all observers.
    sc = ScFireEvent(CAMCViewObserver::ScOnViewCreated, this);
    if(sc)
        sc.TraceAndClear();

    return 0;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::CreateFolderCtrls
 *
 * PURPOSE: Creates the tabbed folder controls for the scope and result panes.
 *
 * RETURNS:
 *    bool
 *
 *+-------------------------------------------------------------------------*/
bool
CAMCView::CreateFolderCtrls()
{
    if (!m_pResultFolderTabView->Create (WS_CHILD|WS_VISIBLE, g_rectEmpty, this, IDC_ResultTabCtrl))
        return false;

    // add the views to the framework
    GetDocument()->AddView(m_pResultFolderTabView);

    return true;
}

/*+-------------------------------------------------------------------------*
 * CAMCView::CreateView
 *
 * This was copied largely from CFrameWnd::CreateView.  We need to duplicate
 * it here so common control-based views are initially created with the
 * correct parent.  A common control caches its original parent, so
 * using CFrameWnd::CreateView (which will create the view with the frame
 * as its parent) then reparenting to CAMCView will result in the common
 * control caching the wrong parent.
 *--------------------------------------------------------------------------*/

CView* CAMCView::CreateView (CCreateContext* pContext, int nID, DWORD dwStyle)
{
    ASSERT(m_hWnd != NULL);
    ASSERT(::IsWindow(m_hWnd));
    ASSERT(pContext != NULL);
    ASSERT(pContext->m_pNewViewClass != NULL);

    CView* pView = (CView*)pContext->m_pNewViewClass->CreateObject();
    if (pView == NULL)
    {
        TRACE1("Warning: Dynamic create of view type %hs failed.\n",
            pContext->m_pNewViewClass->m_lpszClassName);
        return NULL;
    }
    ASSERT_KINDOF(CView, pView);

    // views are always created with a border!
    if (!pView->Create (NULL, NULL, AFX_WS_DEFAULT_VIEW | dwStyle,
                        g_rectEmpty, this, nID, pContext))
    {
        TRACE0("Warning: could not create view for frame.\n");
        return NULL;        // can't continue without a view
    }

    return pView;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CreateView
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCView::CreateView (int nID)
{
    struct CreateViewData
    {
        int             nID;
        CRuntimeClass*  pClass;
        CView**         ppView;
        DWORD           dwStyle;
    };

    CreateViewData rgCreateViewData[] =
    {
        { IDC_TreeView,
            RUNTIME_CLASS(CAMCTreeView),
            (CView**)&m_pTreeCtrl,
            0   },

        { IDC_OCXHostView,
            RUNTIME_CLASS(COCXHostView),
            (CView**)&m_pOCXHostView,
            0   },

        { IDC_WebViewCtrl,
            RUNTIME_CLASS(CAMCWebViewCtrl),
            (CView**)&m_pWebViewCtrl,
            CAMCWebViewCtrl::WS_HISTORY | CAMCWebViewCtrl::WS_SINKEVENTS},

        { IDC_ViewExtensionView,
            RUNTIME_CLASS(CAMCWebViewCtrl),
            (CView**)&m_pViewExtensionCtrl,
            WS_CLIPSIBLINGS },
    };

    for (int i = 0; i < countof (rgCreateViewData); i++)
    {
        if (rgCreateViewData[i].nID == nID)
        {
            CCreateContext ctxt;
            ZeroMemory (&ctxt, sizeof (ctxt));
            ctxt.m_pCurrentDoc   = GetDocument();
            ctxt.m_pNewViewClass = rgCreateViewData[i].pClass;

            CView*& pView = *rgCreateViewData[i].ppView;
            ASSERT (pView == NULL);
            pView = CreateView (&ctxt, nID, rgCreateViewData[i].dwStyle);
            ASSERT ((pView != NULL) && "Check the debug output window");

            // Add observers only to tree, ocx and web hosts. Do not add to view extension host
            // as we do not care about its activation/deactivations.
            switch (nID)
            {
            case IDC_TreeView:
                    // set the view and the description bar as observers of the tree view control
                    m_pTreeCtrl->AddObserver(static_cast<CTreeViewObserver &>(*this));
                    m_pTreeCtrl->AddObserver(static_cast<CTreeViewObserver &>(m_RightDescCtrl));
                break;

            case IDC_OCXHostView:
                m_pOCXHostView->AddObserver(static_cast<COCXHostActivationObserver &>(*this));
                break;

            case IDC_WebViewCtrl:
                m_pWebViewCtrl->AddObserver(static_cast<COCXHostActivationObserver &>(*this));
                break;
            }

            return (pView != NULL);
        }
    }

    ASSERT (false && "Missing an entry in rgCreateViewData");
    return (false);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::GetActiveView
 *
 *
 *--------------------------------------------------------------------------*/

CAMCView* CAMCView::GetActiveView()
{
    return NULL;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ScChangeViewMode
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::ScChangeViewMode (int nNewMode)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::OnViewModeChange"));

    // if switching from a custom view, force a reselect
    if (!HasListOrListPad())
    {
        NavState state = m_pHistoryList->GetNavigateState();
        m_pHistoryList->SetNavigateState (MMC_HISTORY_BUSY);
        PrivateChangeListViewMode(nNewMode);
        m_pHistoryList->SetNavigateState (state);
        sc = m_pTreeCtrl->ScReselect();
        if (sc)
            return sc;
    }
    else
    {
        int nCurMode = m_pListCtrl->GetViewMode();

        if ( (nNewMode == MMCLV_VIEWSTYLE_FILTERED) &&
             (!(GetListOptions() & RVTI_LIST_OPTIONS_FILTERED)) )
            return (sc = E_INVALIDARG);

        PrivateChangeListViewMode(nNewMode);

        // if filter state change, notify the snap-in
        if ( ((nCurMode == MMCLV_VIEWSTYLE_FILTERED) != (nNewMode == MMCLV_VIEWSTYLE_FILTERED))
             && (GetListOptions() & RVTI_LIST_OPTIONS_FILTERED))
        {
            HNODE hNodeSel = GetSelectedNode();
            ASSERT(hNodeSel != NULL);
            m_spNodeCallback->Notify(hNodeSel, NCLBK_FILTER_CHANGE,
                         (nNewMode == MMCLV_VIEWSTYLE_FILTERED) ? MFCC_ENABLE : MFCC_DISABLE, 0);
        }
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ViewMmento
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::ScViewMemento(CMemento* pMemento)
{
    DECLARE_SC (sc, TEXT("CAMCView::ScViewMemento"));
    sc = ScCheckPointers(pMemento);
    if (sc)
        return sc;

    AFX_MANAGE_STATE (AfxGetAppModuleState());

    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    MTNODEID NodeId = 0;

    CBookmark& bm = pMemento->GetBookmark();
    ASSERT(bm.IsValid());

    // We want to display message if exact favorite item cannot be selected.
    bool bExactMatchFound = false; // out value from GetNodeIDFromBookmark.
    sc = pScopeTree->GetNodeIDFromBookmark( bm, &NodeId, bExactMatchFound);
    if(sc)
        return sc;

    if (! bExactMatchFound)
        return ScFromMMC(IDS_NODE_NOT_FOUND); // do not trace

    INodeCallback *pNodeCallback = GetNodeCallback();
    sc = ScCheckPointers(pNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc;

    // set the persisted information to the saved settings.
    sc = pNodeCallback->SetViewSettings(GetViewID(),
                                        reinterpret_cast<HBOOKMARK>(&bm),
                                        reinterpret_cast<HVIEWSETTINGS>(&pMemento->GetViewSettings()));
    if (sc)
        return sc;

    sc = ScSelectNode(NodeId, /*bSelectExactNode*/ true);
    if (sc == ScFromMMC(IDS_NODE_NOT_FOUND))
    {
        SC scNoTrace = sc;
        sc.Clear();
        return scNoTrace;
    }

    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnSetFocus
 *
 * WM_SETFOCUS handler for CAMCView.
 *--------------------------------------------------------------------------*/

void CAMCView::OnSetFocus(CWnd* pOldWnd)
{
    /*
     * try to deflect the activation to a child view; if we couldn't just punt
     */
    if (!DeflectActivation (true, NULL))
        CView::OnSetFocus(pOldWnd);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnActivateView
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
    /*
     * try to deflect the activation to a child view; if we couldn't just punt
     */
    if (!DeflectActivation (bActivate, pDeactiveView))
        CView::OnActivateView (bActivate, pActivateView, pDeactiveView);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::DeflectActivation
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCView::DeflectActivation (BOOL fActivate, CView* pDeactivatingView)
{
    if (fActivate)
    {
        CFrameWnd* pFrame = GetParentFrame();
        if (pFrame == NULL)
            return (false);

        /*
         * first try to put the focus back on the deactivating view
         */
        if (pDeactivatingView == NULL)
            pDeactivatingView = pFrame->GetActiveView();

        if ((pDeactivatingView != NULL) && (pDeactivatingView != this))
        {
            pFrame->SetActiveView (pDeactivatingView);
            return true;
        }

        /*
         * otherwise, deflect the activation to the scope view, if it's there
         */
        CView* pScopeView = NULL;

        if (IsScopePaneVisible() && ((pScopeView = GetPaneView(ePane_ScopeTree)) != NULL))
        {
            if (IsWindow (pScopeView->GetSafeHwnd()))
            {
                pFrame->SetActiveView (pScopeView);
                return (true);
            }
        }

        /*
         * finally, no scope view, try the result view
         */
        CView* pResultView = GetResultView();

        if (pResultView  != NULL)
        {
            pFrame->SetActiveView(pResultView);
            return (true);
        }
    }

    return (false);
}

//+-------------------------------------------------------------------------
//
//  Function:   OnLButtonDown
//
//  Synopsis:   If mouse down in splitter area initiate view tracker to move
//              the splitter. (TrackerCallback function handles completion)
//--------------------------------------------------------------------------

void CAMCView::OnLButtonDown(UINT nFlags, CPoint pt)
{
    TRACE_METHOD(CAMCView, OnLButtonDown);

    // click in splitter bar?
    if (!m_rectVSplitter.PtInRect(pt))
        return;

    // setup tracker information
    TRACKER_INFO trkinfo;

    // range is client area
    GetClientRect(trkinfo.rectArea);

    // bound by min size of panes
    trkinfo.rectBounds = trkinfo.rectArea;
    trkinfo.rectBounds.left  += m_PaneInfo[ePane_ScopeTree].cxMin;
    trkinfo.rectBounds.right -= m_PaneInfo[ePane_Results].cxMin;

    // Current tracker is splitter rect
    trkinfo.rectTracker = trkinfo.rectArea;
    trkinfo.rectTracker.left = m_PaneInfo[ePane_ScopeTree].cx;
    trkinfo.rectTracker.right = trkinfo.rectTracker.left + m_cxSplitter;

    // Don't allow either pane to be hidden by dragging the splitter
    trkinfo.bAllowLeftHide  = FALSE;
    trkinfo.bAllowRightHide = FALSE;

    // back ptr and completion callback
    trkinfo.pView = this;
    trkinfo.pCallback = TrackerCallback;

    // initiate tracking
    CViewTracker::StartTracking (&trkinfo);
}


void CAMCView::AdjustTracker (int cx, int cy)
{   // if user resizes window so that splitter becomes hidden,
    // move it like Explorer does.

    if (!IsScopePaneVisible())
        return;

    // extra adjustment
    cx -= BORDERPADDING + 1;

    if (cx <= m_PaneInfo[ePane_ScopeTree].cx + m_cxSplitter)
    {
        int offset = m_PaneInfo[ePane_ScopeTree].cx + m_cxSplitter - cx;

        m_PaneInfo[ePane_ScopeTree].cx -= offset;
        m_PaneInfo[ePane_Results].cx -= offset;

        RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_UPDATENOW);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAddDefaultColumns
 *
 * PURPOSE:
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAddDefaultColumns()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAddDefaultColumns"));

    IHeaderCtrlPtr spHeaderCtrl = m_ViewData.m_spNodeManager;

    sc = ScCheckPointers(spHeaderCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    SetUsingDefColumns(TRUE);

    const int INDEX_MAX = 2;

    CString str[INDEX_MAX];

    LoadString(str[0], IDS_NAME);
    LoadString(str[1], IDS_TYPE);

    int iMax = 0;
    int nMax = str[0].GetLength();
    int nTemp = 0;

    for (int i=1; i < INDEX_MAX; i++)
    {
        nTemp = str[i].GetLength();

        if (nTemp > nMax)
        {
            nMax = nTemp;
            iMax = i;
        }
    }

    LPOLESTR psz = new OLECHAR[nMax + 1];

    int alWidths[INDEX_MAX] = {0, 0};
    GetDefaultColumnWidths(alWidths);

    for (i=0; i < INDEX_MAX; i++)
    {
        // Bug 157408:  remove the "Type" column for static nodes
        if (i == 1)
            continue;

        USES_CONVERSION;

        wcscpy(psz, T2COLE( (LPCTSTR) str[i] ));

        sc = spHeaderCtrl->InsertColumn(i, psz, LVCFMT_LEFT, alWidths[i]);
        if(sc)
            return sc;
    }

    delete [] psz;

    return sc;
}

SC
CAMCView::ScInitDefListView(LPUNKNOWN pUnkResultsPane)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScInitDefListView"));

    if (!HasList())
        return (sc = E_UNEXPECTED);

    sc = ScCheckPointers(pUnkResultsPane, m_ViewData.m_spResultData, E_UNEXPECTED);
    if(sc)
        return sc;

    m_ViewData.m_spResultData->ResetResultData();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnSelectNode
 *
 * Most of this code was moved out of CAMCTreeView::OnSelectNode, as it is
 * more appropriate that this is executed by CAMCView.
 *
 * PURPOSE: Called when an item in the tree is selected. Does the following:
 *          1) Sets up the result pane to either a list, and OCX, or a web page.
 *          2) Sets the view options
 *          3) Sends a selection notification to the node.
 *          3) Adds a history entry if needed.
 *
 * PARAMETERS:
 *    HNODE  hNode :          [IN]:  The node that got selected.
 *    BOOL & bAddSubFolders : [OUT]: Whether subfolders should be added to the list
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnSelectNode(HNODE hNode, BOOL &bAddSubFolders)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnSelectNode"));

    USES_CONVERSION;

    //
    //  Set the result pane
    //
    LPOLESTR pszResultPane  = NULL;
    GUID     guidTaskpad    = GUID_NULL;
    int      lViewMode      = MMCLV_VIEWSTYLE_REPORT; // the default view mode

    //long lViewOptions = MMC_VIEW_OPTIONS_NONE;

    bool bUsingHistory  = false;
    bool bRestoredView  = false;

    INodeCallback* spNodeCallBack = GetNodeCallback();
    sc = ScCheckPointers(spNodeCallBack, E_UNEXPECTED);
    if (sc)
        return sc;

    CHistoryList* pHistoryList = GetHistoryList();
    sc = ScCheckPointers(pHistoryList, E_UNEXPECTED);
    if (sc)
        return sc;

    CResultViewType rvt;

    if (pHistoryList->GetNavigateState() == MMC_HISTORY_NAVIGATING)
    {
        // we're going "back" or "forward":
        // get Result pane stuff from history

        bUsingHistory   = true;
        sc = pHistoryList->ScGetCurrentResultViewType(rvt, lViewMode, guidTaskpad);
        if (sc)
            return sc;

        sc = spNodeCallBack->RestoreResultView(hNode, rvt);
        if (sc)
        {
            TraceError(_T("Snapin failed on NCLBK_RESTORE_VIEW\n"), sc);
            sc.Clear();     // Compatible with 1.2 dont need this error.
        }

        if (sc.ToHr() == S_OK)
            bRestoredView = true;
        else
            rvt = CResultViewType(); // this restores rvt back to a nascent state. see Bug 176058.

    }

    // The view is not restored by history so ask snapin for view settings.
    if (! bRestoredView)
    {

        // get Result pane stuff from snapin
        GUID guid = GUID_NULL;
        sc = spNodeCallBack->GetResultPane(hNode, rvt, &guid);
        if (sc)
            return sc;

        // we cannot pass the guidTaskpad to GetResultPane directly, since
        // when it is navigation what causes the change, view settings are
        // not yet updated and thus the guid returned will not reflect the
        // current situation
        if (!bUsingHistory)
            guidTaskpad = guid;
    }

    // make sure we have a taskpad set (this will change the value of guidTaskpad if required)
    // This is required when pages referred from history are no longer available when returning
    // to the view (taskpad being deleted/default page being replaced/etc.)
    if (bUsingHistory)
        spNodeCallBack->SetTaskpad(hNode, &guidTaskpad);

    //SetViewOptions(lViewOptions);


    // at this stage, rvt contains all the result view information (excluding, as always the list view mode.)
    if (rvt.HasList())
    {
        SetListViewMultiSelect(
            (rvt.GetListOptions() & RVTI_LIST_OPTIONS_MULTISELECT) == RVTI_LIST_OPTIONS_MULTISELECT);
    }

    sc = ScSetResultPane(hNode, rvt, lViewMode, bUsingHistory);
    if(sc)
        return sc;

    ::CoTaskMemFree(pszResultPane);

    //
    //  Initialize default list view.
    //
    LPUNKNOWN pUnkResultsPane = GetPaneUnknown(CConsoleView::ePane_Results);
    if (rvt.HasList())
    {
        sc = ScInitDefListView(pUnkResultsPane);
        if(sc)
            return sc;

        sc = ScCheckPointers(m_ViewData.m_spResultData, E_UNEXPECTED);
        if (sc)
            return sc;

        // this turns off list view redrawing. Should have some sort of smart object that automatically
        // turns redrawing on in its destructor.
        m_ViewData.m_spResultData->SetLoadMode(TRUE); // SetLoadMode(FALSE) is called by the caller, CAMCTreeView::OnSelectNode
    }


    //
    //  Notify the new node that it is selected.
    //
    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));

    selInfo.m_bScope = TRUE;
    selInfo.m_pView  = pUnkResultsPane;

    if (rvt.HasWebBrowser())
    {
        selInfo.m_bResultPaneIsWeb = TRUE;
        selInfo.m_lCookie          = LVDATA_CUSTOMWEB;
    }
    else if (rvt.HasOCX())
    {
        selInfo.m_bResultPaneIsOCX = TRUE;
        selInfo.m_lCookie          = LVDATA_CUSTOMOCX;
    }

    // Increment and save local copy of nesting level counter. This counter serves
    // two purposes. First, it allows AMCView to inhibit inserting scope items in
    // the result pane during a select by checking the IsSelectingNode method.
    // Without this test the scope items would appear twice because all the scope
    // items are added to the result pane at the end of this method.
    // Second, during the following ScNotifySelect call the snap-in could do another
    // select which would re-enter this method. In that case, only the innermost
    // call to this method should do the post-notify processing. The outer calls
    // should just exit, returning S_FALSE instead of S_OK.

    int nMyNestLevel = ++m_nSelectNestLevel;

    // collect / manage view tabs
    sc = ScAddFolderTabs( hNode, guidTaskpad );
    if (sc)
        return sc;

    try
    {
        sc = ScNotifySelect ( spNodeCallBack, hNode, false /*fMultiSelect*/, true, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
    }
    catch(...)
    {
        // if first call to Select, reset level to zero before leaving
        if (nMyNestLevel == 1) m_nSelectNestLevel = 0;
        throw;
    }


    // if the local call level does not match the shared call level then this
    // method was reentered during the ScNotifySelect. In that case don't finish
    // the processing because the node and/or view may have changed.
    // Be sure to reset the call level to zero if this is the outermost call.

    ASSERT(nMyNestLevel <= m_nSelectNestLevel);
    BOOL bDoProcessing = (nMyNestLevel == m_nSelectNestLevel);
    if (nMyNestLevel == 1)
        m_nSelectNestLevel = 0;

    if (!bDoProcessing)
        return S_FALSE;


    //
    // If the result pane is the def-LV, ensure that there are headers.
    // If not add the default ones
    //

    if (rvt.HasList())
    {
        SetUsingDefColumns(FALSE);

        // Get ptr to ResultPane.
        IMMCListViewPtr pMMCLV = pUnkResultsPane;
        sc = ScCheckPointers(pMMCLV, E_UNEXPECTED);
        if (sc)
            return sc;

        int nCols = 0;
        sc = pMMCLV->GetColumnCount(&nCols);
        if (sc)
            return sc;

        if(0 == nCols)
        {
            sc = ScAddDefaultColumns();
            if(sc)
                return sc;

            IResultDataPrivatePtr& pResultDataPrivate = m_ViewData.m_spResultData;
            sc = ScCheckPointers(pResultDataPrivate, E_UNEXPECTED);
            if (sc)
                return sc;

            long lViewMode = GetViewMode();

            // If default mode is filtered and new node doesn't
            // support that, use report mode instead
            if (lViewMode == MMCLV_VIEWSTYLE_FILTERED &&
                !(rvt.GetListOptions() & RVTI_LIST_OPTIONS_FILTERED))
                lViewMode = LVS_REPORT;

            // you've got to change the mode before you change the
            // style:  style doesn't contain the "quickfilter" bit.
            pResultDataPrivate->SetViewMode (lViewMode);

            long style = GetDefaultListViewStyle();
            if (style != 0)
            {
                sc = pResultDataPrivate->SetListStyle(style);
                if (sc)
                    return sc;
            }
        }
    }


    //
    // Show the static scope items in the result pane,
    // but not for a virtual list view, or views specifically
    // marked that they don't want scope items in the result view
    //

    if (rvt.HasList() &&
        !(rvt.GetListOptions() & RVTI_LIST_OPTIONS_OWNERDATALIST) &&
        !(rvt.GetListOptions() & RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST))
    {
        bAddSubFolders = TRUE;
    }


    //  Update window title.
    sc = ScUpdateWindowTitle();
    if(sc)
        return sc;

    // fire event to script
    sc = ScFireEvent(CAMCViewObserver::ScOnViewChange, this, hNode);
    if (sc)
        return sc;

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScSetResultPane
 *
 * PURPOSE:   Sets the result pane to the specified configuration.
 *
 * PARAMETERS:
 *    HNODE            hNode :
 *    CResultViewType  rvt :
 *    long             lViewOptions :
 *    bool             bUsingHistory :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScSetResultPane(HNODE hNode, CResultViewType rvt, int viewMode, bool bUsingHistory)
{
    DECLARE_SC(sc, TEXT("CAMCView::SetResultPane"));

    m_ViewData.SetResultViewType(rvt);

    if(rvt.HasList())
    {
        sc = ScAttachListViewAsResultPane();
        if(sc)
            return sc;
    }

    else if(rvt.HasWebBrowser())
    {
        sc = ScAttachWebViewAsResultPane();
        if(sc)
            return sc;
    }

    else if(rvt.HasOCX())
    {
        sc = ScAttachOCXAsResultPane(hNode);
        if(sc)
            return sc;
    }
    else
    {
        ASSERT(0 && "Should not come here!!");
        return (sc = E_UNEXPECTED);
    }

    // show the toolbars
    if(GetStdToolbar() != NULL) // may be NULL at startup.
    {
        sc = GetStdToolbar()->ScShowStdBar(true);
        if(sc)
            return sc;
    }

    // if we haven't gotten here using history, add a history entry.
    if(!bUsingHistory)
    {
        GUID guidTaskpad = GUID_NULL;
        GetTaskpadID(guidTaskpad);
        sc = m_pHistoryList->ScAddEntry(rvt, m_nViewMode, guidTaskpad);
        if(sc)
            return sc;
    }


    // if we have a node manager, tell it what the result pane is.
    if(m_ViewData.m_spNodeManager)
    {
        LPUNKNOWN pUnkResultsPane = GetPaneUnknown(CConsoleView::ePane_Results);
        m_ViewData.m_spNodeManager->SetResultView(pUnkResultsPane);
    }

    return sc;
}



BOOL CAMCView::CreateListCtrl(int nID, CCreateContext* pContext)
{
    TRACE_METHOD(CAMCView, CreateListCtrl);

    ASSERT(m_pListCtrl == NULL);

    CComObject<CCCListViewCtrl> *pLV = NULL;
    CComObject<CCCListViewCtrl>::CreateInstance( &pLV );

    if (pLV == NULL)
    {
        ASSERT(0 && "Unable to create list control");
        return FALSE;
    }

    // we assign directly - implicit cast works, since we have a type derived from the one we need
    m_pListCtrl = pLV;
    // we intend to hold a reference, so do addref here (CreateInstance creates w/ 0 reffs)
    m_pListCtrl->AddRef();

    if (!m_pListCtrl->Create (WS_VISIBLE | WS_CHILD, g_rectEmpty, this, nID, pContext))
    {
        ASSERT(0 && "Unable to create list control");
        return FALSE;
    }

    m_pListCtrl->SetViewMode (m_nViewMode);

    SC SC = m_pListCtrl->ScInitialize(); // intialize the list control

    return TRUE;
}


void CAMCView::SetListViewOptions(DWORD dwListOptions)
{
    TRACE_METHOD(CAMCView, SetListViewOptions);

    bool bVirtual = (dwListOptions & RVTI_LIST_OPTIONS_OWNERDATALIST) ? true : false;

    ASSERT(m_pListCtrl != NULL);

    CDocument* pDoc = GetDocument();
    ASSERT(pDoc != NULL);

    // If change to/from virtual list, change list mode
    if (IsVirtualList() != bVirtual)
    {
        m_ViewData.SetVirtualList (bVirtual);
        pDoc->RemoveView(m_pListCtrl->GetListViewPtr());
        m_pListCtrl->SetVirtualMode(bVirtual);
        pDoc->AddView(m_pListCtrl->GetListViewPtr());
        m_ViewData.m_hwndListCtrl = m_pListCtrl->GetListViewHWND();
    }

    // if snapin doesn't support filtering make sure it's off
    if (!(GetListOptions() & RVTI_LIST_OPTIONS_FILTERED) &&
         m_pListCtrl->GetViewMode() == MMCLV_VIEWSTYLE_FILTERED)
    {
        m_pListCtrl->SetViewMode(LVS_REPORT);
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAttachListViewAsResultPane
 *
 * PURPOSE: Sets up the list view as the result pane.
 *
 * PARAMETERS: NONE
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAttachListViewAsResultPane()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAttachListViewAsResultPane"));

    bool bVirtual = (GetListOptions() & RVTI_LIST_OPTIONS_OWNERDATALIST) ? true : false;
    GUID guidTaskpad;
    GetTaskpadID(guidTaskpad);

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    CDocument* pDoc = GetDocument();
    ASSERT(pDoc != NULL);

    // If change to/from virtual list, change list mode
    if (IsVirtualList() != bVirtual)
    {
        m_ViewData.SetVirtualList (bVirtual);
        pDoc->RemoveView(m_pListCtrl->GetListViewPtr());
        m_pListCtrl->SetVirtualMode(bVirtual);
        pDoc->AddView(m_pListCtrl->GetListViewPtr());
        m_ViewData.m_hwndListCtrl = m_pListCtrl->GetListViewHWND();
    }

    // if snapin doesn't support filtering make sure it's off
    if (!(GetListOptions() & RVTI_LIST_OPTIONS_FILTERED) &&
         m_pListCtrl->GetViewMode() == MMCLV_VIEWSTYLE_FILTERED)
    {
        m_pListCtrl->SetViewMode(LVS_REPORT);
    }

    ShowResultPane(m_pListCtrl->GetListViewPtr(), uiClientEdge);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAttachWebViewAsResultPane
 *
 * PURPOSE:
 *
 * PARAMETERS: NONE
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAttachWebViewAsResultPane()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAttachWebViewAsResultPane"));

    // if we were in ListPad-mode, undo that.
    if (m_pListCtrl->IsListPad())
    {
        sc = m_pListCtrl->ScAttachToListPad (NULL, NULL);
        if(sc)
            return sc;
    }

    // The control is created on demand. This prevents IE from loading when unnecessary
    // and reduces startup time.
    if (m_pWebViewCtrl == NULL)
        CreateView (IDC_WebViewCtrl);

    sc = ScCheckPointers(m_pWebViewCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    // Force web control to update its palette
    SendMessage(WM_QUERYNEWPALETTE);

    ShowResultPane(m_pWebViewCtrl, uiNoClientEdge);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAttachOCXAsResultPane
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    LPCTSTR  pszResultPane :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAttachOCXAsResultPane(HNODE hNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAttachOCXAsResultPane"));
    USES_CONVERSION;

    ASSERT(m_pListCtrl != NULL);

    if (m_pOCXHostView == NULL)
        CreateView (IDC_OCXHostView);

    sc = ScCheckPointers(m_pOCXHostView);
    if(sc)
        return sc;

    sc = m_pOCXHostView->ScSetControl(hNode, m_ViewData.m_rvt, GetNodeCallback());
    if(sc)
        return sc;

    ShowResultPane(m_pOCXHostView, uiClientEdge);

    return sc;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ScApplyViewExtension
 *
 * Applies a view extension to the current view.  pszURL specifies the
 * URL of the HTML to load as the view extension.  If pszURL is NULL or
 * empty, the view extension is removed.
 *
 * This method will force a layout of the view if it is required.
 *--------------------------------------------------------------------------*/

SC CAMCView::ScApplyViewExtension (
    LPCTSTR pszURL)                     /* I:URL to use, NULL to remove     */
{
    DECLARE_SC (sc, _T("CAMCView::ScApplyViewExtension"));

    /*
     * assume no view extension
     */
    bool fViewWasExtended = m_fViewExtended;
    m_fViewExtended       = false;

    /*
     * if we're given a URL with which to extend the view, turn on the extension
     */
    if ((pszURL != NULL) && (*pszURL != 0))
    {
        /*
         * if we don't have a web control for the view extension yet, create one
         */
        if (m_pViewExtensionCtrl == NULL)
            CreateView (IDC_ViewExtensionView);

        sc = ScCheckPointers (m_pViewExtensionCtrl, E_FAIL);
        if (sc)
            return (sc);

        m_fViewExtended = true;

        // hide the hosted window initially
        CWnd *pwndHosted = GetPaneView(ePane_Results);
        sc = ScCheckPointers(pwndHosted);
        if(sc)
            return sc;

        pwndHosted->ShowWindow(SW_HIDE);

        RecalcLayout(); // do this BEFORE calling Navigate, which may resize the above rectangle via the mmcview behavior

        // navigate to the requested URL
        m_pViewExtensionCtrl->Navigate (pszURL, NULL);
    }
    else if (fViewWasExtended && (m_pViewExtensionCtrl != NULL))
    {
        /*
         * Bug 96948: If we've got an extension and we're currently extending
         * the view, navigate the view extension's web browser to an empty page
         * so the behavior that resizes the hosted result frame is disabled
         */
        CStr strEmptyPage;
        sc = ScGetPageBreakURL (strEmptyPage);
        if (sc)
            return (sc);

        m_pViewExtensionCtrl->Navigate (strEmptyPage, NULL);

        if(fViewWasExtended)
            DeferRecalcLayout();
    }


    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ShowResultPane
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CView*        pNewView :
 *    EUIStyleType  nStyle :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::ShowResultPane(CView* pNewView, EUIStyleType nStyle)
{
    TRACE_METHOD(CAMCView, ShowResultPane);
    ASSERT(pNewView != NULL);

    CView* pCurrentView = GetPaneView(ePane_Results);

    bool bActive = (GetParentFrame()->GetActiveView() == pCurrentView);

    // Check to see if we need to swap the CWnd control in the result pane
    if (pNewView != pCurrentView)
    {
        HWND hwndCurrentView = pCurrentView->GetSafeHwnd();

        if (IsWindow (hwndCurrentView))
        {
            pCurrentView->ShowWindow(SW_HIDE);

            // Note: We are directly hiding the window for cases that controls
            // don't hide during a DoVerb(OLEIVERB_HIDE).  Actually, this does a
            // hide on all windows.  It's too hard at this point to optimize the code
            // for doing this with an OLE control only.
            ::ShowWindow(hwndCurrentView, SW_HIDE);
        }

        SetPane(ePane_Results, pNewView, nStyle);
        RecalcLayout();

        // if other pane was active, make the new one active
        if ((pCurrentView != NULL) && bActive)
        {
            // make sure the new window is visible
            pNewView->ShowWindow(SW_SHOW);
            GetParentFrame()->SetActiveView(pNewView);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   GetPaneInfo
//
//  Synopsis:   Get information about a particular pane
//
//--------------------------------------------------------------------------

void CAMCView::GetPaneInfo(ViewPane ePane, int* pcxCur, int* pcxMin)
{
    TRACE_METHOD(CAMCView, GetPaneInfo);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::GetPaneInfo: Invalid pane specifier");
        return;
    }

    if ((pcxCur==NULL) || (pcxMin==NULL))
    {
        ASSERT(FALSE); // One or more of the args is wrong
        return;
    }

    // REVIEW fix enum
    *pcxCur   = m_PaneInfo[ePane].cx;
    *pcxMin   = m_PaneInfo[ePane].cxMin;


}

//+-------------------------------------------------------------------------
//
//  Function:   SetPaneInfo
//
//  Synopsis:   Set information about a particular pane
//
//--------------------------------------------------------------------------

void CAMCView::SetPaneInfo(ViewPane ePane, int cxCur, int cxMin)
{
    TRACE_METHOD(CAMCView, SetPaneInfo);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::SetPaneInfo: Invalid pane specifier");
        return;
    }

    if (cxCur < 0 || cxMin < 0)
    {
        ASSERT(FALSE); // One or more of the args is wrong
        return;
    }

    m_PaneInfo[ePane].cx      = cxCur;
    m_PaneInfo[ePane].cxMin   = cxMin;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetPaneView
//
//  Synopsis:   Returns a pointer to CView for a particular pane
//
//--------------------------------------------------------------------------

CView* CAMCView::GetPaneView(ViewPane ePane)
{
    TRACE_METHOD(CAMCView, GetPaneView);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::GetPaneView: Invalid pane specifier");
        return (NULL);
    }

    return (m_PaneInfo[ePane].pView);
}



/*+-------------------------------------------------------------------------*
 * CAMCView::GetResultView
 *
 *
 *--------------------------------------------------------------------------*/

CView* CAMCView::GetResultView() const
{
    CView* pView = NULL;

    // may need changes here - assumes the different types are independent.

    if(HasWebBrowser())
        pView = m_pWebViewCtrl;

    else if(HasList())
        pView = m_pListCtrl->GetListViewPtr();

    else if(HasOCX())
        pView = m_pOCXHostView;

    ASSERT (pView != NULL);
    return (pView);
}


//+-------------------------------------------------------------------------
//
//  Function:   GetPaneUnknown
//
//  Synopsis:   Returns a pointer to the Unknown
//
//--------------------------------------------------------------------------

LPUNKNOWN CAMCView::GetPaneUnknown(ViewPane ePane)
{
    TRACE_METHOD(CAMCView, GetPaneUnknown);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::GetPaneUnknown: Invalid pane specifier");
        return (NULL);
    }

    if (!IsWindow (GetPaneView(ePane)->GetSafeHwnd()))
    {
        ASSERT(FALSE); // Invalid pane element
        return NULL;
    }

    if (HasWebBrowser() && m_pWebViewCtrl != NULL)
    {
        return m_pWebViewCtrl->GetIUnknown();
    }
    else if( HasList() && m_pListCtrl != NULL )
    {
        IUnknownPtr spUnk = m_pListCtrl;
        LPUNKNOWN pUnk = spUnk;
        return pUnk;
    }
    else if (HasOCX() && m_pOCXHostView != NULL)
    {
        ASSERT(GetPaneView (ePane));
        return m_pOCXHostView->GetIUnknown();
    }
    else
    {
        // result pane not initialized yet. This is usually because we are in between a deselect and a
        // subsequent reselect.
        return NULL;
   }
}


//+-------------------------------------------------------------------------
//
//  Function:   SetPane
//
//  Synopsis:   Set a CWnd pointer for a particular pane and other information
//
//--------------------------------------------------------------------------

void CAMCView::SetPane(ViewPane ePane, CView* pView, EUIStyleType nStyle)
{
    TRACE_METHOD(CAMCView, SetPane);
    ASSERT_VALID(this);

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::SetPane: Invalid pane specifier");
        return;
    }

    if (pView==NULL || !IsWindow(*pView))
    {
        ASSERT(FALSE); // Invalid arg
        return;
    }

    m_PaneInfo[ePane].pView = pView;

    // Ensure that the window is visible & at the top of the Z-order.
    pView->SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOMOVE);

    // Note: We are directly showing the window for cases that controls
    // don't show during a DoVerb(OLEIVERB_SHOW).  Actually, this does a
    // show on all windows.  It's too hard at this point to optimize the code
    // for doing this with an OLE control only.
    ::ShowWindow(pView->m_hWnd, SW_SHOW);
}

//
// Other Methods
//


/*+-------------------------------------------------------------------------*
 * CAMCView::ScShowScopePane
 *
 * Shows or hides the scope pane in the current view.  If fForce is true,
 * we'll go through the motions of showing the scope pane even if we think
 * its visibility state wouldn't change.
 *--------------------------------------------------------------------------*/

SC CAMCView::ScShowScopePane (bool fShow, bool fForce /* =false */)
{
    DECLARE_SC (sc, _T("CAMCView::ScShowScopePane"));

    /*
     * if the current visibility state doesn't match the requested state,
     * change the current state to match the requested state
     */
    if (fForce || (IsScopePaneVisible() != fShow))
    {
        /*
         * If MMC_NW_OPTION_NOSCOPEPANE was specified when this view was
         * created, we can't display a scope pane.  If we're asked to, fail.
         */
        if (fShow && !IsScopePaneAllowed())
            return (sc = E_FAIL);

        /*
         * if the scope pane is being hidden and it contained the active
         * view, activate the result pane
         */
        if (!fShow && (GetFocusedPane() == ePane_ScopeTree))
            ScSetFocusToResultPane ();   // ignore errors here

        /*
         * remember the new state
         */
        SetScopePaneVisible (fShow);

        /*
         * Don't defer this layout.  This may be called by the Customize View
         * dialog which wants to see its updates in real time.  It will be
         * sitting in a modal message loop so we won't get a chance to precess
         * our idle task.
         */
        RecalcLayout();

        /*
         * the console has changed
         */
        SetDirty();
    }

    /*
     * put the scope pane toolbar button in the right state
     */
    CStandardToolbar* pStdToolbar = GetStdToolbar();
    sc = ScCheckPointers(pStdToolbar, E_UNEXPECTED);
    if (sc)
        return (sc);

    CAMCDoc *pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if (sc)
        return sc;

	bool bEnableScopePaneButton = (IsScopePaneAllowed() && pDoc->AllowViewCustomization());

    // IF view customization is not allowed then "Show/Hide Consolte tree" button should be hidden.
    if (bEnableScopePaneButton)
    {
        /*
         * the scope pane is permitted; show and check the toolbar
         * button if the scope pane is visible, show and uncheck the
         * toolbar button if the scope pane is hidden
         */
        sc = pStdToolbar->ScCheckScopePaneBtn (fShow);
        if (sc)
            return (sc);
    }
    else
    {
        /*
         * no scope pane permitted, hide the scope pane button
         */
        sc = pStdToolbar->ScEnableScopePaneBtn (bEnableScopePaneButton);
        if (sc)
            return (sc);
    }

    /*
     * if we get to this point, the current state should match the requested state
     */
    ASSERT (IsScopePaneVisible() == fShow);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::CDeferredLayout
 *
 * Constructs a CAMCView::CDeferredLayout::CDeferredLayout.  Note that if
 * an error occurs during construction, an SC exception will be thrown.
 *--------------------------------------------------------------------------*/

CAMCView::CDeferredLayout::CDeferredLayout (CAMCView* pAMCView)
    : m_atomTask (AddAtom (_T("CAMCView::CDeferredLayout")))
{
        DECLARE_SC (sc, _T("CAMCView::CDeferredLayout::CDeferredLayout"));

        if (!Attach (pAMCView))
                (sc = E_INVALIDARG).Throw();
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::~CDeferredLayout
 *
 *
 *--------------------------------------------------------------------------*/

CAMCView::CDeferredLayout::~CDeferredLayout()
{
    DeleteAtom (m_atomTask);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::ScDoWork
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::CDeferredLayout::ScDoWork()
{
    WindowCollection::iterator  it;
    WindowCollection::iterator  itEnd = m_WindowsToLayout.end();

    for (it = m_WindowsToLayout.begin(); it != itEnd; ++it)
    {
        CWnd* pwnd = CWnd::FromHandlePermanent (*it);
        CAMCView* pAMCView = dynamic_cast<CAMCView*>(pwnd);

        if (pAMCView != NULL)
        {
            pAMCView->RecalcLayout();
            pAMCView->Invalidate();
            pAMCView->UpdateWindow();
        }
    }

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::ScGetTaskID
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::CDeferredLayout::ScGetTaskID(ATOM* pID)
{
    *pID = m_atomTask;
    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::ScMerge
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::CDeferredLayout::ScMerge(CIdleTask* pitMergeFrom)
{
    CDeferredLayout* pdlMergeFrom = dynamic_cast<CDeferredLayout*>(pitMergeFrom);
    ASSERT (pdlMergeFrom != NULL);

    /*
     * copy the windows from the merge-from task into the merge-to task
     */
    WindowCollection::iterator  it;
    WindowCollection::iterator  itEnd = pdlMergeFrom->m_WindowsToLayout.end();

    for (it = pdlMergeFrom->m_WindowsToLayout.begin(); it != itEnd; ++it)
    {
        m_WindowsToLayout.insert (*it);
    }

    return (S_OK);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::CDeferredLayout::Attach
 *
 *
 *--------------------------------------------------------------------------*/

bool CAMCView::CDeferredLayout::Attach (CAMCView* pAMCView)
{
    ASSERT (pAMCView != NULL);

    HWND hwndAMCView = pAMCView->GetSafeHwnd();

    if (hwndAMCView != NULL)
        m_WindowsToLayout.insert (hwndAMCView);

    return (hwndAMCView != NULL);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::DeferRecalcLayout
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::DeferRecalcLayout (bool fUseIdleTaskQueue /* =true */, bool bArrangeIcons /* = false*/)
{
    DECLARE_SC (sc, _T("CAMCView::DeferRecalcLayout"));

    if (fUseIdleTaskQueue)
    {
        Trace (tagLayout, _T("CAMCView::DeferRecalcLayout (idle task)"));
        try
        {
            /*
             * get the idle task manager
             */
            CIdleTaskQueue* pIdleTaskQueue = AMCGetIdleTaskQueue();
            if (pIdleTaskQueue == NULL)
                (sc = E_UNEXPECTED).Throw();

            /*
             * create the deferred layout task
             */
            CAutoPtr<CDeferredLayout> spDeferredLayout (new CDeferredLayout (this));
            if (spDeferredLayout == NULL)
                (sc = E_OUTOFMEMORY).Throw();

            /*
             * put the task in the queue, which will take ownership of it
             */
            sc = pIdleTaskQueue->ScPushTask (spDeferredLayout, ePriority_Normal);
            if (sc)
                sc.Throw();

            /*
             * if we get here, the idle task queue owns the idle task, so
             * we can detach it from our smart pointer
             */
            spDeferredLayout.Detach();

            /*
             * jiggle the message pump so that it wakes up and checks idle tasks
             */
            PostMessage (WM_NULL);
        }
        catch (SC& scCaught)
        {
            /*
             * if we failed to enqueue our deferred layout task, do the layout now
             */
            RecalcLayout();
        }
    }

    /*
     * post a message instead of using the idle task queue
     */
    else
    {
        /*
         * we only need to post a message if there's not one in the queue
         * already
         */
        MSG msg;

        if (!PeekMessage (&msg, GetSafeHwnd(),
                          m_nDeferRecalcLayoutMsg,
                          m_nDeferRecalcLayoutMsg,
                          PM_NOREMOVE))
        {
            PostMessage (m_nDeferRecalcLayoutMsg, bArrangeIcons);
            Trace (tagLayout, _T("CAMCView::DeferRecalcLayout (posted message)"));
        }
        else
        {
            Trace (tagLayout, _T("CAMCView::DeferRecalcLayout (skipping redundant posted message)"));
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   RecalcLayout
//
//  Synopsis:   Calls methods to layout control and paint borders and splitters.
//
//--------------------------------------------------------------------------

void CAMCView::RecalcLayout(void)
{
    TRACE_METHOD(CAMCView, RecalcLayout);
    ASSERT_VALID(this);
        Trace (tagLayout, _T("CAMCView::RecalcLayout"));

    /*
     * short out if the client rect is empty
     */
    CRect rectClient;
    GetClientRect (rectClient);

    if (rectClient.IsRectEmpty())
        return;

    CDeferWindowPos dwp (10);

    LayoutScopePane  (dwp, rectClient);
    LayoutResultPane (dwp, rectClient);

    /*
     * CDeferWindowPos dtor will position the windows
     */
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutScopePane
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutScopePane (CDeferWindowPos& dwp, CRect& rectRemaining)
{
    int cxScope = 0;

    // If a scope pane is visible
    if (IsScopePaneVisible())
    {
        int cxTotal = rectRemaining.Width();

        // get the current width
        cxScope = m_PaneInfo[ePane_ScopeTree].cx;

        // if not determined yet, set scope pane width to 1/4 of window
        if (cxScope == -1)
            cxScope = cxTotal / 3;

        /*
         * Bug 86718:  Make sure we leave at least the minimum width
         * for the result pane, which is always visible
         */
        cxScope = std::_MIN (cxScope, cxTotal - m_PaneInfo[ePane_Results].cxMin - m_cxSplitter);

        /*
         * remember the scope pane width
         */
        m_PaneInfo[ePane_ScopeTree].cx = cxScope;
    }

    CRect rectScope = rectRemaining;
    rectScope.right = rectScope.left + cxScope;


    /*
     * remove space used by the scope pane
     * (and splitter) from the remaining area
     */
    if (IsScopePaneVisible())
    {
        m_rectVSplitter.left   = rectScope.right;
        m_rectVSplitter.top    = rectScope.top;
        m_rectVSplitter.right  = rectScope.right + m_cxSplitter;
        m_rectVSplitter.bottom = rectScope.bottom;

        rectRemaining.left     = m_rectVSplitter.right;

        /*
         * Inflate the splitter rect to give a little bigger hot area.
         * We need to do this logically instead of physically (i.e. instead
         * of increasing m_cxSplitter) to keep the visuals right.
         */
        m_rectVSplitter.InflateRect (GetSystemMetrics (SM_CXEDGE), 0);

    }
    else
        m_rectVSplitter = g_rectEmpty;


    /*
     * scope pane
     */
    dwp.AddWindow (GetPaneView(ePane_ScopeTree), rectScope,
                   SWP_NOZORDER | SWP_NOACTIVATE |
                        (IsScopePaneVisible() ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutResultPane
 *
 * Lays out the children of the result pane.
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutResultPane (CDeferWindowPos& dwp, CRect& rectRemaining)
{
    /*
     * Note:  the order of these calls to LayoutXxx is *critical*.
     */
    LayoutResultDescriptionBar (dwp, rectRemaining);
    LayoutResultFolderTabView  (dwp, rectRemaining);

    m_rectResultFrame = rectRemaining;

    LayoutResultView           (dwp, rectRemaining);

    /*
     * remember the final width of the result pane in m_PaneInfo[ePane_Results].cx
     */
    m_PaneInfo[ePane_Results].cx = m_rectResultFrame.Width();
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutResultFolderTabView
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutResultFolderTabView (CDeferWindowPos& dwp, CRect& rectRemaining)
{
    DECLARE_SC(sc, TEXT("CAMCView::LayoutResultFolderTabView"));

    sc = ScCheckPointers(m_pResultFolderTabView, E_UNEXPECTED);
    if (sc)
        return;

    // layout the folder tab control - always on top.
    bool bVisible = AreTaskpadTabsAllowed() && m_pResultFolderTabView->IsVisible();

    CRect rectFolder;

    if (bVisible)
        m_pResultFolderTabView->Layout(rectRemaining, rectFolder);
    else
        rectFolder = g_rectEmpty;

    DWORD dwPosFlags = SWP_NOZORDER | SWP_NOACTIVATE |
                            (bVisible ? SWP_SHOWWINDOW : SWP_HIDEWINDOW);
    dwp.AddWindow (m_pResultFolderTabView, rectFolder, dwPosFlags);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutResultDescriptionBar
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutResultDescriptionBar (CDeferWindowPos& dwp, CRect& rectRemaining)
{
    DWORD dwPosFlags = SWP_NOZORDER | SWP_NOACTIVATE;
    CRect rectT      = rectRemaining;

    if (IsDescBarVisible() && !rectT.IsRectEmpty())
    {
        rectT.bottom      = rectT.top + m_RightDescCtrl.GetHeight();
        rectRemaining.top = rectT.bottom;
        dwPosFlags |= SWP_SHOWWINDOW;
    }
    else
    {
        dwPosFlags |= SWP_HIDEWINDOW;
    }

    dwp.AddWindow (&m_RightDescCtrl, rectT, dwPosFlags);
}


/*+-------------------------------------------------------------------------*
 * CAMCView::LayoutResultView
 *
 *
 *--------------------------------------------------------------------------*/

void CAMCView::LayoutResultView (CDeferWindowPos& dwp, const CRect& rectRemaining)
{
    DECLARE_SC (sc, _T("CAMCView::LayoutResultView"));
    Trace (tagLayout, _T("CAMCView::LayoutResultView"));
    CWnd* pwndResult = GetPaneView(ePane_Results);

    /*
     * we should never think the view is extended if we don't also have
     * a view extension web host control
     */
    ASSERT (!(m_fViewExtended && (m_pViewExtensionCtrl == NULL)));

    /*
     * if it exists, the view extension control is always at the bottom of
     * the Z-order, and visible if the view is being extended
     */
    if(m_pViewExtensionCtrl != NULL)
    {
        /*
         * note no SWP_NOZORDER
         */
        DWORD dwPosFlags = SWP_NOACTIVATE | ((m_fViewExtended)
                                    ? SWP_SHOWWINDOW
                                    : SWP_HIDEWINDOW);

        dwp.AddWindow (m_pViewExtensionCtrl, rectRemaining,
                       dwPosFlags, &CWnd::wndBottom);
    }

    /*
     * If the view's not extended, show or hide the result window based on
     * whether there's any room left in the positioning rectangle.  (If the
     * view is extended, the result window will have been hidden when the
     * view extension was applied (in ScApplyViewExtension), and possibly
     * redisplayed by the extension in ScSetViewExtensionFrame.)
     */
    if (!m_fViewExtended)
    {
        DWORD dwFlags = SWP_NOZORDER | SWP_NOACTIVATE |
                        (rectRemaining.IsRectEmpty() ? SWP_HIDEWINDOW : SWP_SHOWWINDOW);

        dwp.AddWindow (pwndResult, rectRemaining, dwFlags);
    }

    /*
     * lists in extended views and listpads don't get a border, all others do
     */
    if (HasListOrListPad())
    {
        if (HasListPad())
        {
            sc = ScCheckPointers (m_pListCtrl, E_UNEXPECTED);
            if (sc)
                return;

            CWnd* pwndListCtrl = m_pListCtrl->GetListViewPtr();
            sc = ScCheckPointers (pwndListCtrl, E_UNEXPECTED);
            if (sc)
                return;

            pwndListCtrl->ModifyStyleEx (WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED);  // remove border
        }

        else if (m_fViewExtended)
            pwndResult->ModifyStyleEx (WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED);  // remove border
        else
            pwndResult->ModifyStyleEx (0, WS_EX_CLIENTEDGE, SWP_FRAMECHANGED);  // add border
    }
}

//
// Tracking and and hit testing methods
//


//+-------------------------------------------------------------------------
//
//  Function:   HitTestPane
//
//  Synopsis:   Test which pane contains the point arg, or ePane_None for
//              the splitter bar
//
//--------------------------------------------------------------------------

int CAMCView::HitTestPane(CPoint& point)
{
    TRACE_METHOD(CAMCView, HitTestPane);

    if (PtInWindow(m_pTreeCtrl, point))
        return ePane_ScopeTree;

    if (m_PaneInfo[ePane_Results].pView &&
        PtInWindow(m_PaneInfo[ePane_Results].pView, point))
        return ePane_Results;

    return ePane_None;
}


HNODE CAMCView::GetSelectedNode(void)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    TRACE_METHOD(CAMCView, GetSelectedNode);

    // When the tree is empty we don't want to AV
    HTREEITEM hti = m_pTreeCtrl->GetSelectedItem();
    if (hti == NULL)
        return NULL;

    HNODE hNode = m_pTreeCtrl->GetItemNode(hti);
    return hNode;
}


HNODE CAMCView::GetRootNode(void)
{
    TRACE_METHOD(CAMCView, GetSelectedNode);

    // When the tree is empty we don't want to AV
    HTREEITEM hti = m_pTreeCtrl->GetRootItem();
    if (hti == NULL)
        return NULL;

    HNODE hNode = m_pTreeCtrl->GetItemNode(hti);
    return hNode;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScUpdateWindowTitle
 *
 * PURPOSE: Updates the window title and informs observers about the change.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScUpdateWindowTitle()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScUpdateWindowTitle"));

    CChildFrame* pFrame = GetParentFrame();

    sc = ScCheckPointers(pFrame);
    if(sc)
        return sc;

    if (pFrame)
        pFrame->OnUpdateFrameTitle(TRUE);

    sc = ScFireEvent(CAMCViewObserver::ScOnViewTitleChanged, this);

    return sc;
}

BOOL CAMCView::RenameItem(HNODE hNode, BOOL bScopeItem, MMC_COOKIE lResultItemCookie,
                          LPWSTR pszText, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCView::RenameItem"));

    sc = S_FALSE;

    SELECTIONINFO selInfo;
    ZeroMemory(&selInfo, sizeof(selInfo));

    selInfo.m_bScope = bScopeItem;
    selInfo.m_lCookie = lResultItemCookie;

    if (pszText != NULL)
    {
        USES_CONVERSION;

        /*
         * Bug 322184:  The snap-in may throw up some UI on this notification.
         * The list or tree may have captured the mouse to look for a drag,
         * which will interfere with the snap-in's UI.  Release the capture
         * during the callback and put it back when we're done.
         */
        HWND hwndCapture = ::SetCapture (NULL);

        sc = m_spNodeCallback->Notify(hNode, NCLBK_RENAME,
                reinterpret_cast<LPARAM>(&selInfo), reinterpret_cast<LPARAM>(pszText));

        /*
         * put the capture back
         */
        ::SetCapture (hwndCapture);
    }

    *pResult = (sc == SC(S_OK));
    if (*pResult)
    {
        sc = ScUpdateWindowTitle();
        if(sc)
            sc.TraceAndClear();
    }

    return TRUE;
}

BOOL CAMCView::DispatchListCtrlNotificationMsg(LPARAM lParam, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCView::DispatchListCtrlNotificationMsg"));

    TRACE_METHOD(CAMCView, DispatchListCtrlNotificationMsg);

    NM_LISTVIEW *pNm = reinterpret_cast<NM_LISTVIEW*>(lParam);
    BOOL bReturn = TRUE;

    switch (pNm->hdr.code)
    {
    case NM_RCLICK:
        bReturn = FALSE;  // In case of right click send the select notification to the snapin
                          // but return FALSE so that message is further processed to display
                          // context menu.

        // Fall thro into NM_CLICK
    case NM_CLICK:
        {
            sc = ScOnLeftOrRightMouseClickInListView();
            if (sc)
                return bReturn;
        }
        break;

    case NM_DBLCLK:
        OnListCtrlItemDblClk();
        break;

    case NM_CUSTOMDRAW:
        *pResult = m_pListCtrl->OnCustomDraw (
                            reinterpret_cast<NMLVCUSTOMDRAW *>(lParam));
        break;

    case LVN_BEGINLABELEDITA:
    case LVN_BEGINLABELEDITW:
    {
        CMainFrame* pFrame = AMCGetMainWnd();

        if ((pFrame != NULL) && (IsVerbEnabled(MMC_VERB_RENAME) ||
                                 m_bRenameListPadItem == true))
        {
            pFrame->SetInRenameMode(true);
            return FALSE;
        }
        else
        {
            return TRUE;
        }

        break;
    }

    case LVN_ENDLABELEDITW:
    case LVN_ENDLABELEDITA:
    {
        CMainFrame* pFrame = AMCGetMainWnd();
        if (pFrame != NULL)
            pFrame->SetInRenameMode(false);

        LPARAM lResultParam = 0;
        long index = -1;
        LPWSTR pszText = NULL;

        if (pNm->hdr.code == LVN_ENDLABELEDITW)
        {
            LV_DISPINFOW* pdi = (LV_DISPINFOW*) lParam;
            index = pdi->item.iItem;
            pszText = pdi->item.pszText;
            lResultParam = pdi->item.lParam;
        }
        else // if (pNm->hdr.code == LVN_ENDLABELEDIT)
        {
            LV_DISPINFO* pdi = (LV_DISPINFO*) lParam;
            index = pdi->item.iItem;
            USES_CONVERSION;
            pszText = T2W(pdi->item.pszText);
            lResultParam = pdi->item.lParam;
        }

        if (IsVirtualList())
        {
            // for virtual list pass the item index rather than the lparam
            HNODE hNodeSel = GetSelectedNode();
            RenameItem(hNodeSel, FALSE, index, pszText, pResult);
        }
        else
        {
            CResultItem* pri = CResultItem::FromHandle (lResultParam);

            if (pri != NULL)
            {
                if (pri->IsScopeItem())
                    RenameItem(pri->GetScopeNode(), TRUE, 0, pszText, pResult);
                else
                    RenameItem(GetSelectedNode(), FALSE, pri->GetSnapinData(), pszText, pResult);
            }
        }

        break;
    }

    case LVN_GETDISPINFOW:
    {
        LV_DISPINFOW *pDispInfo = reinterpret_cast<LV_DISPINFOW*>(lParam);

        // If column is hidden do not forward the call to snapin.
        if (m_pListCtrl && m_pListCtrl->IsColumnHidden(pDispInfo->item.iSubItem))
            break;

        m_spNodeCallback->GetDispInfo (GetSelectedNode(), &pDispInfo->item);

        break;
    }

    case LVN_GETDISPINFOA:
    {
        LV_DISPINFOA *pDispInfo = reinterpret_cast<LV_DISPINFOA*>(lParam);
        ASSERT (pDispInfo != NULL);

        // If column is hidden do not forward the call to snapin.
        if (m_pListCtrl && m_pListCtrl->IsColumnHidden(pDispInfo->item.iSubItem))
            break;

        /*
         * put the data in the UNICODE structure for the query
         */
        LV_ITEMW lviW;
        lviW.mask       = pDispInfo->item.mask;
        lviW.iItem      = pDispInfo->item.iItem;
        lviW.iSubItem   = pDispInfo->item.iSubItem;
        lviW.state      = pDispInfo->item.state;
        lviW.stateMask  = pDispInfo->item.stateMask;
        lviW.cchTextMax = pDispInfo->item.cchTextMax;
        lviW.iImage     = pDispInfo->item.iImage;
        lviW.lParam     = pDispInfo->item.lParam;
        lviW.iIndent    = pDispInfo->item.iIndent;

        if (pDispInfo->item.mask & LVIF_TEXT)
            lviW.pszText = new WCHAR[pDispInfo->item.cchTextMax];

        /*
         * convert to ANSI
         */
        if  (SUCCEEDED (m_spNodeCallback->GetDispInfo (GetSelectedNode(), &lviW)) &&
            (pDispInfo->item.mask & LVIF_TEXT))
        {
            WideCharToMultiByte (CP_ACP, 0, lviW.pszText, -1,
                                 pDispInfo->item.pszText,
                                 pDispInfo->item.cchTextMax,
                                 NULL, NULL);
        }

        if (pDispInfo->item.mask & LVIF_TEXT)
            delete [] lviW.pszText;

        /*
         * copy the results back to the ANSI structure
         */
        pDispInfo->item.mask       = lviW.mask;
        pDispInfo->item.iItem      = lviW.iItem;
        pDispInfo->item.iSubItem   = lviW.iSubItem;
        pDispInfo->item.state      = lviW.state;
        pDispInfo->item.stateMask  = lviW.stateMask;
        pDispInfo->item.cchTextMax = lviW.cchTextMax;
        pDispInfo->item.iImage     = lviW.iImage;
        pDispInfo->item.lParam     = lviW.lParam;
        pDispInfo->item.iIndent    = lviW.iIndent;
        break;
    }

    case LVN_DELETEALLITEMS:
        // return TRUE to prevent notification for each item
        return TRUE;

    case LVN_ITEMCHANGED:
        bReturn = OnListItemChanged (pNm);
        break;

    case LVN_ODSTATECHANGED:
        // The state of an item or range of items has changed in virtual list.
        return OnVirtualListItemsStateChanged(reinterpret_cast<LPNMLVODSTATECHANGE>(lParam));
        break;

    case LVN_ODFINDITEMA:
    case LVN_ODFINDITEMW:
        {
            USES_CONVERSION;

            NM_FINDITEM *pNmFind = reinterpret_cast<NM_FINDITEM*>(lParam);
            ASSERT(IsVirtualList() && (pNmFind->lvfi.flags & LVFI_STRING));

            LPOLESTR polestr = NULL;
            if (pNm->hdr.code == LVN_ODFINDITEMW)
            {
                LVFINDINFOW* pfiw = reinterpret_cast<LVFINDINFOW*>(&pNmFind->lvfi);
                polestr = const_cast<LPOLESTR>(pfiw->psz);
            }
            else
            {
                LVFINDINFOA* pfi = reinterpret_cast<LVFINDINFOA*>(&pNmFind->lvfi);
                polestr = A2W(const_cast<LPSTR>(pfi->psz));
            }
            Dbg(DEB_USER1, _T("\n********************** polestr = %ws\n"), polestr);
            RESULTFINDINFO findInfo;
            findInfo.psz = polestr;
            findInfo.nStart = pNmFind->iStart;
            findInfo.dwOptions = 0;

            // Listview bug: LVFI_SUBSTRING is not defined in the SDK headers and the
            // listview sets it instead of LVFI_PARTIAL when it wants a
            // partial match. So for now, define it here and test for both.
            #define LVFI_SUBSTRING 0x0004

            if (pNmFind->lvfi.flags & (LVFI_PARTIAL | LVFI_SUBSTRING))
                findInfo.dwOptions |= RFI_PARTIAL;

            if (pNmFind->lvfi.flags & LVFI_WRAP)
                findInfo.dwOptions |= RFI_WRAP;

            HNODE hNodeSel = GetSelectedNode();
            INodeCallback* pNC = GetNodeCallback();
            ASSERT(pNC != NULL);

            pNC->Notify(hNodeSel, NCLBK_FINDITEM,
                        reinterpret_cast<LPARAM>(&findInfo),
                        reinterpret_cast<LPARAM>(pResult));
        }
        break;

    case LVN_ODCACHEHINT:
        {
            NM_CACHEHINT *pNmHint = reinterpret_cast<NM_CACHEHINT*>(lParam);

            ASSERT(IsVirtualList());

            HNODE hNodeSel = GetSelectedNode();
            INodeCallback* pNC = GetNodeCallback();
            ASSERT(pNC != NULL);

            pNC->Notify(hNodeSel, NCLBK_CACHEHINT, pNmHint->iFrom, pNmHint->iTo);
        }

        break;

    case LVN_KEYDOWN:
        {
            NMLVKEYDOWN *pNmKeyDown = reinterpret_cast<NMLVKEYDOWN*>(lParam);

            switch (pNmKeyDown->wVKey)
            {
                case VK_DELETE:
                {
                    if (!IsVerbEnabled(MMC_VERB_DELETE))
                        break;

                    INodeCallback* pCallback = GetNodeCallback();
                    ASSERT(pCallback != NULL);
                    if (pCallback == NULL)
                        break;

                    HNODE hNode = GetSelectedNode();
                    if (hNode == 0)
                        break;

                    int cSel = m_pListCtrl->GetSelectedCount();
                    ASSERT(cSel >= 0);

                    LPARAM lvData;
                    if (cSel == 0)
                    {
                        break;
                    }
                    else if (cSel == 1)
                    {
                        if (_GetLVSelectedItemData(&lvData) == -1)
                            break;
                    }
                    else if (cSel > 1)
                    {
                        lvData = LVDATA_MULTISELECT;
                    }
                    else
                    {
                        break;
                    }

                    pCallback->Notify(hNode, NCLBK_DELETE, FALSE, lvData);
                    break;
                }
                break;

                case VK_TAB:
                    GetParentFrame()->SetActiveView (m_pTreeCtrl);
                    break;

                case VK_BACK:
                    ScUpOneLevel();
                    break;

                case VK_RETURN:
                    if(GetKeyState(VK_MENU)<0) // has the ALT key been pressed?
                    {
                        // Process <ALT><ENTER>
                        if (! IsVerbEnabled(MMC_VERB_PROPERTIES))
                            break;

                        LPARAM lvData = 0;

                        if (HasList())
                        {
                            ASSERT (m_pListCtrl != NULL);
                            ASSERT (GetParentFrame()->GetActiveView() == m_pListCtrl->GetListViewPtr());

                            int cSel = m_pListCtrl->GetSelectedCount();
                            ASSERT(cSel >= 0);

                            lvData = LVDATA_ERROR;
                            if (cSel == 0)
                                lvData = LVDATA_BACKGROUND;
                            else if (cSel == 1)
                                _GetLVSelectedItemData(&lvData);
                            else if (cSel > 1)
                                lvData = LVDATA_MULTISELECT;

                            ASSERT(lvData != LVDATA_ERROR);
                            if (lvData == LVDATA_ERROR)
                                break;

                            if (lvData == LVDATA_BACKGROUND)
                                break;
                        }
                        else if (HasOCX())
                        {
                            lvData = LVDATA_CUSTOMOCX;
                        }
                        else
                        {
                            ASSERT(HasWebBrowser());
                            lvData = LVDATA_CUSTOMWEB;
                        }

                        INodeCallback* pNC = GetNodeCallback();
                        ASSERT(pNC != NULL);
                        if (pNC == NULL)
                            break;

                        HNODE hNodeSel = GetSelectedNode();
                        ASSERT(hNodeSel != NULL);
                        if (hNodeSel == NULL)
                            break;

                        pNC->Notify(hNodeSel, NCLBK_PROPERTIES, FALSE, lvData);
                        break;
                    }
                    else     // nope, the ALT key has not been pressed.
                    {
                        // do the default verb.
                        OnListCtrlItemDblClk();
                    }
                    break;

                default:
                    bReturn = OnSharedKeyDown(pNmKeyDown->wVKey);
                    break;
            }
        }
        break;

    default:
        bReturn = FALSE;
        break;
    }

    return bReturn;
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScOnLeftOrRightMouseClickInListView
//
//  Synopsis:    Left or right mouse button is clicked on the list view, see
//               if it is clicked on list-view background. If so send a select.
//
//               Click on list view background is treated as scope owner item selected.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScOnLeftOrRightMouseClickInListView()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnLeftOrRightMouseClickInListView"));

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    CAMCListView *pAMCListView = m_pListCtrl->GetListViewPtr();
    sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
    if (sc)
        return sc;

    CPoint pt;
    GetCursorPos(&pt);
    pAMCListView->ScreenToClient(&pt);

    UINT uFlags = 0;
    int iItem = pAMCListView->GetListCtrl().HitTest(pt, &uFlags);
    Dbg(DEB_USER1, _T("----- HitTest > %d \n"), iItem);

    // Make sure mouse click is in the ListView and there are
    // no items selected in the list view.
    if ( (iItem == -1) &&
         !(uFlags & (LVHT_ABOVE | LVHT_BELOW | LVHT_TOLEFT | LVHT_TORIGHT) ) &&
         (m_pListCtrl->GetSelectedCount() == 0) )
    {
        INodeCallback* pNC = GetNodeCallback();
        sc = ScCheckPointers(pNC, E_UNEXPECTED);
        if (sc)
            return sc;

        HNODE hNodeSel = GetSelectedNode();

        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));
        selInfo.m_bScope = TRUE;
        selInfo.m_bDueToFocusChange = TRUE;
        selInfo.m_bBackground = TRUE;
        selInfo.m_lCookie = LVDATA_BACKGROUND;

        sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, true, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
    }

    return (sc);
}

/*+-------------------------------------------------------------------------*
 * CAMCView::OnListItemChanged
 *
 * WM_NOTIFY (LVN_ITEMCHANGED) handler for CAMCView.
 *
 * return true as message is handled here.
 *--------------------------------------------------------------------------*/

bool CAMCView::OnListItemChanged (NM_LISTVIEW* pnmlv)
{
    DECLARE_SC (sc, _T("CAMCView::OnListItemChanged"));

    bool bOldState = (pnmlv->uOldState & LVIS_SELECTED);
    bool bNewState = (pnmlv->uNewState & LVIS_SELECTED);

    // is this a selection change?
    if ( (pnmlv->uChanged & LVIF_STATE) &&
         (bOldState != bNewState) )
    {
        const int cSelectedItems = m_pListCtrl->GetSelectedCount();

#ifdef DBG
        Trace (tagListSelection,
               _T("Item %d %sselected, %d total items selected"),
               pnmlv->iItem,
               (pnmlv->uOldState & LVIS_SELECTED) ? _T("de") : _T("  "),
               cSelectedItems);
#endif

        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));

        selInfo.m_bScope = FALSE;
        selInfo.m_pView = NULL;
        selInfo.m_lCookie = IsVirtualList() ? pnmlv->iItem : pnmlv->lParam;

        /*
         * If user is (de)selecting multiple items using control and/or shift keys
         * then defer the multi-select notification until we're quiescent
         * with the exception of only one item being (de)selected.
         */
        if ((IsKeyPressed(VK_SHIFT) || IsKeyPressed(VK_CONTROL)) &&
            (GetParentFrame()->GetActiveView() == m_pListCtrl->GetListViewPtr()) &&
            (cSelectedItems > 1) )
        {
            // See ScPostMultiSelectionChangesMessage (this handles both selection
            // and de-selection of multiple items).
            sc = ScPostMultiSelectionChangesMessage();
            if (sc)
                sc.TraceAndClear();

            return (true);
        }
        else
        {
            m_bProcessMultiSelectionChanges = false;
        }

        HNODE hNodeSel = GetSelectedNode();
        INodeCallback* pNC = GetNodeCallback();
        sc = ScCheckPointers(pNC, (void*) hNodeSel, E_UNEXPECTED);
        if (sc)
            return (true);

        // item = -1 is only expected for deselect in virtual list
        ASSERT( pnmlv->iItem != -1 || (IsVirtualList() && (pnmlv->uOldState & LVIS_SELECTED)));

        if (pnmlv->uOldState & LVIS_SELECTED)
        {
            if (cSelectedItems == 0)
            {
                if (!m_bLastSelWasMultiSel)
                {
                    sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, false, &selInfo);
                    if (sc)
                        sc.TraceAndClear(); // ignore & continue;
                }
                else
                {
                    m_bLastSelWasMultiSel = false;
                    sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
                    if (sc)
                        sc.TraceAndClear(); // ignore & continue;
                }
            }
            else if (m_bLastSelWasMultiSel)
            {
                // may need to cancel multiselect and send single select notify.
                // if another change comes in, it will cancel the delayed message
                // This fixes a problem that is caused by large icon mode not
                // sending as many noifications as the other modes.

                // See ScPostMultiSelectionChangesMessage (this handles both selection
                // and de-selection of multiple items).
                sc = ScPostMultiSelectionChangesMessage();
                if (sc)
                    sc.TraceAndClear();
            }
        }
        else if (pnmlv->uNewState & LVIS_SELECTED)
        {
            ASSERT(cSelectedItems >= 1);

            if (cSelectedItems == 1)
            {
                sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, true, &selInfo);
                if (sc)
                    sc.TraceAndClear(); // ignore & continue;
            }
            else
            {
                sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, true, 0);
                if (sc)
                    sc.TraceAndClear(); // ignore & continue;

                m_bLastSelWasMultiSel = true;
            }
        }
    }

    return (true);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::OnVirtualListItemsStateChanged
//
//  Synopsis:    The state of an item or range of items has changed in virtual list.
//
//  Arguments:   lpStateChange -
//
//  Returns:     should return 0 according to docs.
//
//--------------------------------------------------------------------
int CAMCView::OnVirtualListItemsStateChanged(LPNMLVODSTATECHANGE lpStateChange )
{
    DECLARE_SC(sc, TEXT("CAMCView::OnVirtualListItemsStateChanged"));
    sc = ScCheckPointers(lpStateChange);
    if (sc)
    {
        sc.TraceAndClear();
        return 0;
    }

    bool bOldState = (lpStateChange->uOldState & LVIS_SELECTED);
    bool bNewState = (lpStateChange->uNewState & LVIS_SELECTED);
    int  cItems    = (lpStateChange->iTo - lpStateChange->iFrom) + 1;

#ifdef DBG
        Trace (tagListSelection,
               _T("Items %d to %d were %sselected, %d total items selected"),
               lpStateChange->iFrom, lpStateChange->iTo,
               bOldState ? _T("de") : _T("  "),
               cItems );
#endif

    if (bOldState != bNewState)
    {
        sc = ScPostMultiSelectionChangesMessage();
        if (sc)
            sc.TraceAndClear();
    }

    return (0);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScPostMultiSelectionChangesMessage
//
//  Synopsis:    Post selection change message (need to post because multi-sel
//               may not be over, wait till it is quiet.)
//
//               This method posts message telling selection states of multiple
//               items are changed but not if they are selected or de-selected.
//               The m_bLastSelWasMultiSel is used to determine if it is
//               selection or de-selection.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScPostMultiSelectionChangesMessage ()
{
    DECLARE_SC(sc, _T("CAMCView::ScPostMultiSelectionChangesMessage"));

    /*
    * This is a multi-selection, defer notification until we're quiescent
    */
    m_bProcessMultiSelectionChanges = true;
    PostMessage (m_nProcessMultiSelectionChangesMsg);

    // We need to disable all the toolbars, menubuttons
    // during multiselect. Above PostMessage enables
    // stdbar and MMC menubuttons.
    CAMCViewToolbarsMgr* pAMCViewToolbarsMgr = m_ViewData.GetAMCViewToolbarsMgr();
    CMenuButtonsMgr* pMenuBtnsMgr = m_ViewData.GetMenuButtonsMgr();

    sc = ScCheckPointers(pAMCViewToolbarsMgr, pMenuBtnsMgr, E_UNEXPECTED);
    if (sc)
        return 0;

    pAMCViewToolbarsMgr->ScDisableToolbars();
    pMenuBtnsMgr->ScDisableMenuButtons();

    return (sc);
}

void CAMCView::OpenResultItem(HNODE hNode)
{
    /*
     * Bug 139695:  Make certain this function doesn't need to change the
     * active view.  We should only get here as a result of double- clicking
     * or pressing Enter on a scope node in the result pane, in which case
     * the result pane should already be the active view.  If it is, we don't
     * need to change the active view, which can cause the problems listed in
     * the bug.
     */
    ASSERT (m_pListCtrl != NULL);
    ASSERT (GetParentFrame() != NULL);
    ASSERT (GetParentFrame()->GetActiveView() == m_pListCtrl->GetListViewPtr());

    ASSERT(m_pTreeCtrl);
    HTREEITEM htiParent = m_pTreeCtrl->GetSelectedItem();
    ASSERT(htiParent != NULL);

    m_pTreeCtrl->ExpandNode(htiParent);
    m_pTreeCtrl->Expand(htiParent, TVE_EXPAND);

    HTREEITEM hti = m_pTreeCtrl->GetChildItem(htiParent);

    if (hti == NULL)
        return;

    while (hti)
    {
        if (m_pTreeCtrl->GetItemNode(hti) == hNode)
            break;

        hti = m_pTreeCtrl->GetNextItem(hti, TVGN_NEXT);
    }

    if (hti != 0)
    {
        m_pTreeCtrl->Expand(htiParent, TVE_EXPAND);
        m_pTreeCtrl->SelectItem(hti);
    }
}

BOOL CAMCView::OnListCtrlItemDblClk(void)
{
    TRACE_METHOD(CAMCView, OnListCtrlItemDblClk);

    LPARAM lvData = -1;
    if (_GetLVSelectedItemData(&lvData) == -1)
        lvData = LVDATA_BACKGROUND;

    HNODE hNodeSel = GetSelectedNode();
    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);
    if (!pNC)
        return FALSE;

    HRESULT hr = pNC->Notify(hNodeSel, NCLBK_DBLCLICK, lvData, 0);
    if (hr == S_FALSE)
    {
        ASSERT(lvData != LVDATA_BACKGROUND);
        if (!IsVirtualList())
        {
            CResultItem* pri = CResultItem::FromHandle (lvData);

            if ((pri != NULL) && pri->IsScopeItem())
                OpenResultItem (pri->GetScopeNode());
        }
    }

    return TRUE;
}


BOOL CAMCView::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnNotify"));

    NMHDR *pNmHdr = reinterpret_cast<NMHDR*>(lParam);

    sc = ScCheckPointers(pNmHdr, pResult);
    if (sc)
    {
        sc.TraceAndClear();
        return CView::OnNotify(wParam, lParam, pResult);
    }

    *pResult = TRUE; // init

    switch(pNmHdr->code)
    {
    case HDN_ENDTRACKA: // Save the column width changes.
    case HDN_ENDTRACKW: // HDN_BEGINTRACK handles dis-allowing hidden column dragging.
        {
            NMHEADER* nmh = (NMHEADER*)lParam;

            CAMCListView *pAMCListView = m_pListCtrl->GetListViewPtr();
            SC sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
            if (sc)
            {
                sc.TraceAndClear();
                return FALSE;
            }

            sc = pAMCListView->ScOnColumnsAttributeChanged(nmh, HDN_ENDTRACK);
            if (sc)
            {
                sc.TraceAndClear();
                return FALSE;
            }

            // S_FALSE : dont allow the change
            if (sc == SC(S_FALSE))
                return TRUE;

            return CView::OnNotify(wParam, lParam, pResult);
        }
        break;

    case HDN_ENDDRAG: // Column order changes.
        {
            NMHEADER* nmh = (NMHEADER*)lParam;
            if (nmh->pitem->mask & HDI_ORDER)
            {
                CAMCListView *pAMCListView = m_pListCtrl->GetListViewPtr();
                SC sc = ScCheckPointers(pAMCListView, E_UNEXPECTED);
                if (sc)
                {
                    sc.TraceAndClear();
                    return FALSE;
                }

                sc = pAMCListView->ScOnColumnsAttributeChanged(nmh, HDN_ENDDRAG);
                if (sc)
                {
                    sc.TraceAndClear();
                    return FALSE;
                }

                // S_FALSE : dont allow the change
                if (sc = SC(S_FALSE))
                    return TRUE;
            }

            return CView::OnNotify(wParam, lParam, pResult);
        }
        break;

    case TVN_BEGINLABELEDIT:
        {
            TV_DISPINFO* ptvdi = (TV_DISPINFO*)lParam;
            if ((ptvdi->item.lParam == CAMCTreeView::LParamFromNode (GetSelectedNode())) &&
                (IsVerbEnabled(MMC_VERB_RENAME) == FALSE))
            {
                return TRUE;
            }

            CMainFrame* pFrame = AMCGetMainWnd();
            if (pFrame != NULL)
                pFrame->SetInRenameMode(true);

            return FALSE;
        }

    case TVN_ENDLABELEDIT:
        {
            TV_DISPINFO* ptvdi = (TV_DISPINFO*)lParam;
            CMainFrame* pFrame = AMCGetMainWnd();
            if (pFrame != NULL)
                pFrame->SetInRenameMode(false);

            USES_CONVERSION;
            return RenameItem(CAMCTreeView::NodeFromLParam (ptvdi->item.lParam), TRUE, 0,
                              T2W(ptvdi->item.pszText), pResult);
        }

    case TVN_KEYDOWN:
        {
            TV_KEYDOWN* ptvkd = reinterpret_cast<TV_KEYDOWN*>(lParam);
            if (ptvkd->wVKey == VK_TAB)
            {
                ScSetFocusToResultPane();
                return TRUE;
            }
            else
            {
                return OnSharedKeyDown(ptvkd->wVKey);
            }
        }

    }

    if (UsingDefColumns() &&
        (pNmHdr->code == HDN_ENDTRACKA || pNmHdr->code == HDN_ENDTRACKW))
    {
        // WARNING: If HD_NOTIFY::pitem::pszText needs to be used you should cast
        // lParam to either HD_NOTIFYA or HD_NOTIFYW depending on the pNmHdr->code
        HD_NOTIFY* phdn = reinterpret_cast<HD_NOTIFY*>(lParam);
        ASSERT(phdn != NULL);

        if (phdn->pitem->mask & HDI_WIDTH)
        {
            int alWidths[2] = {0, 0};
            GetDefaultColumnWidths(alWidths);
            alWidths[phdn->iItem] = phdn->pitem->cxy;
            SetDefaultColumnWidths(alWidths, FALSE);
            return TRUE;
        }
    }

#ifdef DBG
    if (m_pTreeCtrl && m_pTreeCtrl->m_hWnd == pNmHdr->hwndFrom)
    {
        switch (pNmHdr->code)
        {
        case NM_CLICK:  Dbg(DEB_USER2, "\t Tree item clicked\n"); break;
        case NM_DBLCLK: Dbg(DEB_USER2, "\t Tree item dbl-clicked\n"); break;
        case NM_RCLICK: Dbg(DEB_USER2, "\t Tree item R-clicked\n"); break;
        default: break;
        }
    }
#endif

    // HasList() is added to prevent dispatching notifications, when AMCView thinks
    // it does not have a list. This lead to wrong assumptions about the list type
    // and as a result - AV handling messages like GetDisplayInfo
    // See BUG 451896
    if (m_pListCtrl && HasListOrListPad())
    {
        if (m_pListCtrl->GetListViewHWND() == pNmHdr->hwndFrom)
        {
            if (DispatchListCtrlNotificationMsg(lParam, pResult) == TRUE)
                return TRUE;
        }
        else if (m_pListCtrl->GetHeaderCtrl() && m_pListCtrl->GetHeaderCtrl()->m_hWnd == pNmHdr->hwndFrom)
        {
            switch(pNmHdr->code)
            {
                case HDN_ITEMCLICKA:
                case HDN_ITEMCLICKW:
                {
                    HNODE hNodeSel = GetSelectedNode();

                    HD_NOTIFY* phdn = reinterpret_cast<HD_NOTIFY*>(lParam);
                    ASSERT(phdn != NULL);
                    int nCol = phdn->iItem;

                    sc = m_spNodeCallback->Notify(hNodeSel, NCLBK_COLUMN_CLICKED, 0, nCol);
                    if (sc)
                        sc.TraceAndClear();

                    return TRUE;
                }

                // filter related code
                case HDN_FILTERCHANGE:
                {
                    HNODE hNodeSel = GetSelectedNode();
                    int nCol = ((NMHEADER*)lParam)->iItem;
                    sc = m_spNodeCallback->Notify(hNodeSel, NCLBK_FILTER_CHANGE, MFCC_VALUE_CHANGE, nCol);
                    if (sc)
                        sc.TraceAndClear();

                    return TRUE;
                }

                case HDN_FILTERBTNCLICK:
                {
                    HNODE hNodeSel = GetSelectedNode();
                    int nCol = ((NMHDFILTERBTNCLICK*)lParam)->iItem;
                    RECT rc = ((NMHDFILTERBTNCLICK*)lParam)->rc;

                    // rect is relative to owning list box, convert to screen
                    ::MapWindowPoints(m_pListCtrl->GetListViewHWND(), NULL, (LPPOINT)&rc, 2);

                    sc = m_spNodeCallback->Notify(hNodeSel, NCLBK_FILTERBTN_CLICK, nCol, (LPARAM)&rc);
                    *pResult = (sc == SC(S_OK));
                    if (sc)
                        sc.TraceAndClear();

                    return TRUE;
                }
            }
        }
    }

    return CView::OnNotify(wParam, lParam, pResult);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnMinimize
 *
 * PURPOSE: Send the NCLBK_MINIMIZED notification to the node manager.
 *
 * PARAMETERS:
 *    bool  fMinimized : TRUE if the window is being minimized, false if maximized.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnMinimize(bool fMinimized)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnMinimize"));

    HNODE hNode = GetSelectedNode();

    if (hNode == NULL)
        return (sc = E_FAIL);

    INodeCallback*  pNodeCallback = GetNodeCallback();

    if (pNodeCallback == NULL)
        return (sc = E_FAIL);

    sc =  pNodeCallback->Notify (hNode, NCLBK_MINIMIZED, fMinimized, 0);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnSize
 *
 * PURPOSE: Send the size notification to all
 *
 * PARAMETERS:
 *    UINT  nType :
 *    int   cx :
 *    int   cy :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnSize(UINT nType, int cx, int cy)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnSize"));

    if (IsPersisted() && GetDocument())
        GetDocument()->SetFrameModifiedFlag(true);

    sc = ScFireEvent(CAMCViewObserver::ScOnViewResized, this, nType, cx, cy);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScActivate
 *
 * PURPOSE: Sets the view as the active view.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScActivate()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScActivate"));

    // get the child frame.
    CChildFrame * pChildFrame = GetParentFrame();
    sc = ScCheckPointers(pChildFrame);
    if(sc)
        return sc;

    if (pChildFrame->IsIconic())
        pChildFrame->MDIRestore();
    else
        pChildFrame->MDIActivate(); // activate the child frame.

    return sc;
}


void CAMCView::OnContextMenu(CWnd* pWnd, CPoint point)
{
    TRACE_METHOD(CAMCView, OnContextMenu);

    /*
     * make sure this child frame is active
     */
    GetParentFrame()->MDIActivate();

    if (NULL == m_pTreeCtrl)
    {
        TRACE(_T("CAMCView::OnContextMenu: tree control not ready\n" ));
        return;
    }

    // (-1,-1) => came from context menu key or Shift-F10
    // Pop-up context for whatever has focus
    if (point.x == -1 && point.y == -1)
    {
        OnShiftF10();
        return;
    }


    switch (HitTestPane(point))
    {
    case ePane_Results:
    {
        CPoint      pointListCtrlCoord = point;
        CListView*  pListView          = m_pListCtrl->GetListViewPtr();
        pListView->ScreenToClient(&pointListCtrlCoord);

        CWnd* pwndHit = pListView->ChildWindowFromPoint (pointListCtrlCoord,
                                                         CWP_SKIPINVISIBLE);

        /*
         * if the hit window isn't the list view, it must be the list's
         * header window; ignore the context menu request
         */
        if (pwndHit != pListView)
        {
            TRACE (_T("CAMCView::OnContextMenu: ignore right-click on result pane header\n"));
            break;
        }

        if (NULL != m_pListCtrl && pWnd->m_hWnd == m_pListCtrl->GetListViewHWND())
            OnListContextMenu(point);
        else
            TRACE(_T("CAMCView::OnContextMenu: result control not ready\n"));

        // CODEWORK should do something here
        break;
    }
    case ePane_ScopeTree:
    {
        TRACE(_T("CAMCView::OnContextMenu: handle right-click on scope pane\n"));
        CPoint pointTreeCtrlCoord = point;
        m_pTreeCtrl->ScreenToClient(&pointTreeCtrlCoord);

        OnTreeContextMenu( point, pointTreeCtrlCoord, NULL );
        break;
    }
    case ePane_Tasks:
        // TO BE ADDED - put up taskpad context menu
        break;

    case ePane_None:
        TRACE(_T("CAMCView::OnContextMenu: ignore right-click on splitter\n"));
        break;

    default:
        TRACE(_T("CAMCView::OnContextMenu: unexpected return value from HitTestPane()\n"));
        ASSERT(FALSE);
    }
}

void CAMCView::OnTreeContextMenu(CPoint& point, CPoint& pointClientCoord, HTREEITEM htiRClicked)
{
    TRACE_METHOD(CAMCView, OnTreeContextMenu);

    if (NULL == m_pTreeCtrl)
    {
        TRACE(_T("CAMCTreeView::OnTreeContextMenu: IFrame not ready\n"));
        return;
    }

    UINT fHitTestFlags = TVHT_ONITEM;

    if (htiRClicked == NULL)
        htiRClicked = m_pTreeCtrl->HitTest(pointClientCoord, &fHitTestFlags);

    switch(fHitTestFlags)
    {
    case TVHT_ABOVE:
    case TVHT_BELOW:
    case TVHT_TOLEFT:
    case TVHT_TORIGHT:
        // Outside the tree view area so return without doing anything.
        return;

    default:
        break;
    }

    if (NULL == htiRClicked || !(fHitTestFlags & TVHT_ONITEM))
    {
        OnContextMenuForTreeBackground(point);
    }
    else
    {
        HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(htiRClicked);
        ASSERT(hNode != 0);

        OnContextMenuForTreeItem(INDEX_INVALID, hNode, point, CCT_SCOPE, htiRClicked);
    }
}

void CAMCView::OnContextMenuForTreeItem(int iIndex, HNODE hNode,
                       CPoint& point, DATA_OBJECT_TYPES type_of_pane,
                       HTREEITEM htiRClicked, MMC_CONTEXT_MENU_TYPES eMenuType,
                       LPCRECT prcExclude, bool bAllowDefaultItem)
{
    TRACE_METHOD(CAMCView, OnContextMenuForTreeItem);
    DECLARE_SC (sc, _T("CAMCView::OnContextMenuForTreeItem"));

    ASSERT(hNode != 0);
    CContextMenuInfo contextInfo;

    contextInfo.m_displayPoint.x     = point.x;
    contextInfo.m_displayPoint.y     = point.y;
    contextInfo.m_eContextMenuType   = eMenuType;
    contextInfo.m_eDataObjectType    = CCT_SCOPE;
    contextInfo.m_bBackground        = FALSE;
    contextInfo.m_bScopeAllowed      = IsScopePaneAllowed();
    contextInfo.m_hWnd               = m_hWnd;
    contextInfo.m_pConsoleView       = this;
    contextInfo.m_bAllowDefaultItem  = bAllowDefaultItem;

    contextInfo.m_hSelectedScopeNode = GetSelectedNode();
    contextInfo.m_htiRClicked        = htiRClicked;
    contextInfo.m_iListItemIndex     = iIndex;

    /*
     * if given, initialize the rectangle not to obscure
     */
    if (prcExclude != NULL)
        contextInfo.m_rectExclude = *prcExclude;


    // If selected scope node is same as node for which context menu is
    // needed, then add savelist, view menus
    if (contextInfo.m_hSelectedScopeNode == hNode)
    {
        // Show view owner items
        contextInfo.m_dwFlags |= CMINFO_SHOW_VIEWOWNER_ITEMS;

        // Don't need to remove temporary selection, since none was applied
        contextInfo.m_pConsoleTree = NULL;

        if (eMenuType == MMC_CONTEXT_MENU_DEFAULT)
            contextInfo.m_dwFlags |= CMINFO_SHOW_VIEW_ITEMS;

        if (HasListOrListPad())
            contextInfo.m_dwFlags |= CMINFO_SHOW_SAVE_LIST;
    }
    else if (htiRClicked) // htiRClicked is NULL for tree items in list view.
    {
        // TempNodeSelect == TRUE -> menu is not for the node that owns the result pane
        sc = m_pTreeCtrl->ScSetTempSelection (htiRClicked);
        if (sc)
            return;

        contextInfo.m_pConsoleTree = m_pTreeCtrl;
        contextInfo.m_dwFlags     |= CMINFO_USE_TEMP_VERB;
    }

    if (htiRClicked)
        contextInfo.m_dwFlags |= CMINFO_DO_SCOPEPANE_MENU;
    else
        contextInfo.m_dwFlags |= CMINFO_SCOPEITEM_IN_RES_PANE;

    if (HasListOrListPad())
        contextInfo.m_spListView = m_pListCtrl;

    INodeCallback* spNodeCallback = GetNodeCallback();
    ASSERT(spNodeCallback != NULL);

    HRESULT hr = spNodeCallback->Notify(hNode, NCLBK_CONTEXTMENU, 0,
        reinterpret_cast<LPARAM>(&contextInfo));
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::GetTaskpadID
 *
 * PURPOSE: returns the GUID id of the currently selected taskpad.
 *
 * RETURNS:
 *    GUID : the taskpad, if any, else GUID_NULL.
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::GetTaskpadID(GUID &guidID)
{
    ITaskCallback * pTaskCallback = m_ViewData.m_spTaskCallback;
    if(pTaskCallback != NULL)
    {
        pTaskCallback->GetTaskpadID(&guidID);
    }
    else
    {
        guidID = GUID_NULL;
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScInitializeMemento
 *
 * PURPOSE: Initializes the memento from the current view.
 *
 * PARAMETERS:
 *    CMemento & memento :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScInitializeMemento(CMemento &memento)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScInitializeMemento"));

    sc = GetSelectedNodePath(&memento.GetBookmark());
    if (sc)
        return sc;

    GUID guidTaskpad = GUID_NULL;

    HNODE hNode = GetSelectedNode();

    // get Result pane stuff from snapin
    CResultViewType rvt;
    sc = GetNodeCallback()->GetResultPane(hNode, rvt, &guidTaskpad /*this is not used*/);
    if (sc)
        return sc;

    CViewSettings& viewSettings = memento.GetViewSettings();

    // Initialize the CViewSettings.
    sc = viewSettings.ScSetResultViewType(rvt);
    if (sc)
        return sc;

    GUID guid;
    GetTaskpadID(guid); // we use this guid instead of guidTaskpad because
    // the memento should contain the taskpad that is currently being displayed.
    sc = viewSettings.ScSetTaskpadID(guid);

    return sc;

}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::OnAddToFavorites
 *
 * PURPOSE: Creates a memento from the currently configured view. Saves it into a
 *          shortcut.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void CAMCView::OnAddToFavorites()
{
    DECLARE_SC(sc , _T("CAMCView::OnAddToFavorites"));
    USES_CONVERSION;

    CAMCDoc* pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if (sc)
        return;

    IScopeTree* const pScopeTree = GetScopeTreePtr();
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return;

    CMemento memento;
    sc = ScInitializeMemento(memento); // init the memento with the current view settings.
    if(sc)
        return;

    HNODE hNode = GetSelectedNode();

      tstring strName;
    sc = GetNodeCallback()->GetDisplayName(hNode, strName);
    if (sc)
        return;

    HMTNODE hmtNode;
    sc = m_spNodeCallback->GetMTNode(hNode, &hmtNode);
    if (sc)
        return;

    CCoTaskMemPtr<WCHAR> spszPath;
    sc = pScopeTree->GetPathString(NULL, hmtNode, &spszPath);
    if (sc)
        return;

    sc = ScCheckPointers(pDoc->GetFavorites(), E_UNEXPECTED);
    if (sc)
        return;

    sc = pDoc->GetFavorites()->AddToFavorites(strName.data(), W2CT(spszPath), memento, this);
    if (sc)
        return;

    pDoc->SetModifiedFlag();
}


void CAMCView::OnContextMenuForTreeBackground(CPoint& point, LPCRECT prcExclude, bool bAllowDefaultItem)
{
    TRACE_METHOD(CAMCView, OnContextMenuForTreeBackground);

    HNODE hNode = NULL;

    CContextMenuInfo contextInfo;

    contextInfo.m_displayPoint.x    = point.x;
    contextInfo.m_displayPoint.y    = point.y;
    contextInfo.m_eDataObjectType   = CCT_SCOPE;
    contextInfo.m_bBackground       = TRUE;
    contextInfo.m_bScopeAllowed     = IsScopePaneAllowed();
    contextInfo.m_hWnd              = m_hWnd;
    contextInfo.m_pConsoleView      = this;
    contextInfo.m_bAllowDefaultItem = bAllowDefaultItem;

    /*
     * if given, initialize the rectangle not to obscure
     */
    if (prcExclude != NULL)
        contextInfo.m_rectExclude = *prcExclude;

    INodeCallback* spNodeCallback = GetNodeCallback();
    ASSERT(spNodeCallback != NULL);
    HRESULT hr = spNodeCallback->Notify(hNode, NCLBK_CONTEXTMENU, 0,
        reinterpret_cast<LPARAM>(&contextInfo));
}

SC CAMCView::ScWebCommand (WebCommand eCommand)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if (m_pWebViewCtrl == NULL)
    {
        ASSERT (m_pHistoryList);
        if (!m_pHistoryList)
            return FALSE;

        // this is the case when we don't have a web control yet....
        bool bHandled = false;

        switch (eCommand)
        {
            case eWeb_Back:
                m_pHistoryList->Back (bHandled);
                ASSERT(bHandled);
                break;

            case eWeb_Forward:
                m_pHistoryList->Forward (bHandled);
                ASSERT(bHandled);
                break;

            default:
                return FALSE;
        }

        return TRUE;
    }

    switch (eCommand)
    {
        case eWeb_Back:     m_pWebViewCtrl->Back();     break;
        case eWeb_Forward:  m_pWebViewCtrl->Forward();  break;
        case eWeb_Home:     ASSERT(0 && "Should not come here! - remove all code related to Web_Home"); break;
        case eWeb_Refresh:  m_pWebViewCtrl->Refresh();  break;
        case eWeb_Stop:     m_pWebViewCtrl->Stop();     break;
        default:            ASSERT(0);                  return FALSE;
    }

    return TRUE;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScCreateTaskpadHost
 *
 * PURPOSE: Creates a legacy (snapin taskpad) host interface pointer
 *
 * NOTE:    When a view containing a taskpad is navigated away from, the amcview
 *          forgets about the taskpad host pointer, but the html window does not.
 *          When the same view is re-navigated to using History, the amcview needs
 *          a taskpad host pointer, so a new instance is created. Thus at this point
 *          the amcview and the HTML have pointers to different taskpad host
 *          objects. This is OK, because both objects are initialized to the same
 *          amcview, and contain no other state
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScCreateTaskpadHost()
{
    DECLARE_SC(sc , _T("CAMCView::ScCreateTaskpadHost"));

    if(m_spTaskPadHost != NULL)
        return sc;

    CComObject<CTaskPadHost>* pTaskPadHost = NULL;
    sc = CComObject<CTaskPadHost>::CreateInstance(&pTaskPadHost);
    if (sc)
        return sc;

    sc = ScCheckPointers (pTaskPadHost, E_UNEXPECTED);
    if (sc)
        return sc;

    pTaskPadHost->Init (this);
    m_spTaskPadHost = pTaskPadHost;

    return sc;

}

LRESULT CAMCView::OnConnectToCIC (WPARAM wParam, LPARAM lParam)
{
        DECLARE_SC (sc, _T("CAMCView::OnConnectToCIC"));

    // fill out wparam, which is an IUnknown ** (alloc'd by CIC)
    ASSERT (wParam != NULL);
    IUnknown ** ppunk = (IUnknown **)wParam;
    ASSERT (!IsBadReadPtr  (ppunk, sizeof(IUnknown *)));
    ASSERT (!IsBadWritePtr (ppunk, sizeof(IUnknown *)));

        sc = ScCheckPointers (ppunk);
        if (sc)
                return (sc.ToHr());

    // lParam holds MMCCtrl's IUnknown:  we can hang onto this if we
    // need it. Presently not saved or used.

    sc = ScCreateTaskpadHost();
    if(sc)
        return sc.ToHr();

    sc = ScCheckPointers(m_spTaskPadHost, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();;

    sc = m_spTaskPadHost->QueryInterface(IID_IUnknown, (void **)ppunk);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::OnGetIconInfoForSelectedNode
//
//  Synopsis:    Icon control sends this message to get the small icon
//               for currently the selected node.
//
//  Arguments:   [wParam] - Out param, ptr to HICON handle.
//               [lParam] - Unused
//
//  Returns:     LRESULT
//
//--------------------------------------------------------------------
LRESULT CAMCView::OnGetIconInfoForSelectedNode(WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC(sc, _T("CAMCView::OnGetIconInfoForSelectedNode"));

    HICON *phIcon  = (HICON*)wParam;
    sc = ScCheckPointers(phIcon);
    if (sc)
        return sc.ToHr();

    *phIcon  = NULL;

    sc = ScCheckPointers(m_pTreeCtrl, m_spNodeCallback, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    sc = m_pTreeCtrl->ScGetTreeItemIconInfo(GetSelectedNode(), phIcon);

    return sc.ToHr();
}

HRESULT CAMCView::NotifyListPad (BOOL b)
{
    if (b == TRUE)                  // attaching: save current node
        m_ListPadNode = GetSelectedNode();
    else if (m_ListPadNode == NULL) // detaching, but no hnode
        return E_UNEXPECTED;

    // send notify to snapin
    INodeCallback* pNC = GetNodeCallback();
    HRESULT hr = pNC->Notify (m_ListPadNode, NCLBK_LISTPAD, (long)b, (long)0);

    if (b == FALSE)     // if detaching, ensure that we do this only once
        m_ListPadNode = NULL;

    return hr;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnConnectToTPLV
 *
 * PURPOSE: Connects the listpad to the HTML frame
 *
 * PARAMETERS:
 *    WPARAM  wParam :  parent window
 *    LPARAM  lParam :  [OUT]: pointer to window to be created and filled out
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnConnectToTPLV(WPARAM wParam, LPARAM lParam)
{
    DECLARE_SC(sc, _T("CAMCView::ScOnConnectToTPLV"));

    HWND  hwnd  = (HWND )wParam;
    if(!IsWindow (hwnd))
        return (sc = S_FALSE);

    if (lParam == NULL) // detaching
    {
        SC sc = m_pListCtrl->ScAttachToListPad (hwnd, NULL);
        if(sc)
            return sc;
    }
    else
    {   // attaching

        sc = ScCreateTaskpadHost();
        if(sc)
            return sc;

        HWND* phwnd = (HWND*)lParam;
        if (IsBadWritePtr (phwnd, sizeof(HWND *)))
            return (sc = E_UNEXPECTED);

        // Attach TaskPad's ListView to the NodeMgr
        sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
        if(sc)
            return sc;

        sc = m_pTreeCtrl->m_spNodeManager->SetTaskPadList(m_pListCtrl);
        if(sc)
            return sc;

        // Attach TaskPad's ListView to the curr selected node
        INodeCallback* pNC = GetNodeCallback();
        sc = ScCheckPointers(pNC, E_UNEXPECTED);
        if(sc)
            return sc;

        HNODE hNodeSel = GetSelectedNode();
        sc = pNC->SetTaskPadList(hNodeSel, m_pListCtrl);
        if(sc) // this test was commented out earlier. Uncommented it so we can figure out why.
            return sc;

        //
        // Attach the listctrl to the list pad.
        //

        // First set the list view options.
        SetListViewOptions(GetListOptions());

        sc = m_pListCtrl->ScAttachToListPad (hwnd, phwnd);
        if(sc)
            return sc;
    }

    RecalcLayout();
    return sc;
}


SC CAMCView::ScShowWebContextMenu ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    PostMessage (m_nShowWebContextMenuMsg);

    return (S_OK);
}

LRESULT CAMCView::OnShowWebContextMenu (WPARAM /*wParam*/, LPARAM /*lParam*/)
{
    INodeCallback* pNC = GetNodeCallback();
    ASSERT(pNC != NULL);

    if (pNC)
        pNC->Notify (GetSelectedNode(), NCLBK_WEBCONTEXTMENU, 0, 0);

    return (0);
}

SC CAMCView::ScSetDescriptionBarText (LPCTSTR pszDescriptionText)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    GetRightDescCtrl().SetSnapinText (pszDescriptionText);

    return (S_OK);
}


HWND CAMCView::CreateFavoriteObserver (HWND hwndParent, int nID)
{
    DECLARE_SC (sc, _T("CAMCView::CreateFavoriteObserver"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    CFavTreeCtrl* pFavCtrl = CFavTreeCtrl::CreateInstance();

    if (pFavCtrl != NULL)
    {
        pFavCtrl->Create (NULL, TEXT(""), WS_CHILD|WS_TABSTOP|WS_VISIBLE,
                          g_rectEmpty, CWnd::FromHandle(hwndParent), nID);
        pFavCtrl->ModifyStyleEx (0, WS_EX_CLIENTEDGE, 0);

        CAMCDoc* pDoc = GetDocument();
        ASSERT(pDoc != NULL && pDoc->GetFavorites() != NULL);

        sc = pFavCtrl->ScInitialize(pDoc->GetFavorites(), TOBSRV_HIDEROOT);
        if (sc)
        {
            pFavCtrl->DestroyWindow();      // CFavTreeCtrl::PostNcDestroy will "delete this"
            pFavCtrl = NULL;
        }
    }

    return (pFavCtrl->GetSafeHwnd());
}



int CAMCView::GetListSize ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    return (m_pListCtrl->GetItemCount() * m_pListCtrl->GetColCount());
}

long CAMCView::GetListViewStyle()
{
    DECLARE_SC(sc, _T("CAMCView::GetListViewStyle"));

    sc = ScCheckPointers(m_pTreeCtrl, m_pTreeCtrl->m_spResultData, E_UNEXPECTED);
    if (sc)
        return 0;

    if (HasList())
        return 0;

    long style = 0;

    // First findout if the result view is properly
    // set in the nodemgr by asking IFramePrivate.
    IFramePrivatePtr spFrame = m_pTreeCtrl->m_spResultData;
    sc = ScCheckPointers(spFrame, E_UNEXPECTED);
    if (sc)
        return 0;

    BOOL bIsResultViewSet = FALSE;
    sc = spFrame->IsResultViewSet(&bIsResultViewSet);

    // The result view is set, clean it up.
    if (bIsResultViewSet)
    {
        sc = m_pTreeCtrl->m_spResultData->GetListStyle(&style);
        if (sc)
            return 0;
    }

    return style;
}

void CAMCView::OnListContextMenu(CPoint& point)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnListContextMenu"));

    ASSERT(m_pTreeCtrl != NULL);
    ASSERT(m_pTreeCtrl->m_spResultData != NULL);

    // Determine which item is affected
    UINT fHitTestFlags = 0;
    HRESULTITEM hHitTestItem = 0;
    COMPONENTID componentID = 0;
    int iIndex = -1;

    do // not a loop
    {
        if (!HasList())
            break;

        int cSel = m_pListCtrl->GetSelectedCount();
        ASSERT(cSel >= 0);

        if (cSel == 0)
        {
            OnContextMenuForListItem(INDEX_BACKGROUND, NULL, point);
            return;
        }
        else if (cSel > 1)
        {
            if (IsKeyPressed(VK_SHIFT) || IsKeyPressed(VK_CONTROL))
            {
                HNODE hNodeSel = GetSelectedNode();
                ASSERT(hNodeSel != 0);

                INodeCallback* pNC = GetNodeCallback();
                ASSERT(pNC != NULL);

                if (pNC != NULL)
                {
                    sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, true, 0);
                    if (sc)
                        sc.TraceAndClear(); // ignore & continue;

                    m_bLastSelWasMultiSel = true;
                }
            }

            iIndex = INDEX_MULTISELECTION; // => MultiSelect
            break;
        }
        else
        {
            LPARAM lvData = LVDATA_ERROR;
            iIndex = _GetLVSelectedItemData(&lvData);
            ASSERT(iIndex != -1);
            ASSERT(lvData != LVDATA_ERROR);

            if (IsVirtualList())
            {
                // for virtual list pass the item index rather than the lparam
                OnContextMenuForListItem(iIndex, iIndex, point);
                return;
            }
            else
            {
                CResultItem* pri = CResultItem::FromHandle (lvData);

                if (pri != NULL)
                {
                    if (pri->IsScopeItem())
                        OnContextMenuForTreeItem(iIndex, pri->GetScopeNode(), point, CCT_SCOPE);
                    else
                        OnContextMenuForListItem(iIndex, lvData, point);
                }

                return;
            }
        }

    } while (0);

    OnContextMenuForListItem(iIndex, hHitTestItem, point);
}

void CAMCView::OnContextMenuForListItem(int iIndex, HRESULTITEM hHitTestItem,
                                    CPoint& point, MMC_CONTEXT_MENU_TYPES eMenuType,
                                    LPCRECT prcExclude, bool bAllowDefaultItem)
{
    CContextMenuInfo contextInfo;

    contextInfo.m_displayPoint.x    = point.x;
    contextInfo.m_displayPoint.y    = point.y;
    contextInfo.m_eContextMenuType  = eMenuType;
    contextInfo.m_eDataObjectType   = CCT_RESULT;
    contextInfo.m_bBackground       = (iIndex == INDEX_BACKGROUND);
    contextInfo.m_bMultiSelect      = (iIndex == INDEX_MULTISELECTION);
    contextInfo.m_bAllowDefaultItem = bAllowDefaultItem;

    if (iIndex >= 0)
        contextInfo.m_resultItemParam = IsVirtualList() ? iIndex : hHitTestItem;
    else if (contextInfo.m_bMultiSelect)
        contextInfo.m_resultItemParam = LVDATA_MULTISELECT;

    contextInfo.m_bScopeAllowed      = IsScopePaneAllowed();
    contextInfo.m_hWnd               = m_hWnd;
    contextInfo.m_pConsoleView       = this;

    contextInfo.m_hSelectedScopeNode = GetSelectedNode();
    contextInfo.m_iListItemIndex     = iIndex;

    if (HasListOrListPad())
        contextInfo.m_spListView = m_pListCtrl;

    if ((INDEX_OCXPANE == iIndex) && HasOCX())
    {
        contextInfo.m_resultItemParam = LVDATA_CUSTOMOCX;
    }
    else if ((INDEX_WEBPANE == iIndex) && HasWebBrowser())
    {
        contextInfo.m_resultItemParam = LVDATA_CUSTOMWEB;
    }

    /*
     * if given, initialize the rectangle not to obscure
     */
    if (prcExclude != NULL)
        contextInfo.m_rectExclude = *prcExclude;

    HNODE hNode = GetSelectedNode();
    ASSERT(hNode != NULL);

    INodeCallback* pNodeCallback = GetNodeCallback();
    ASSERT(pNodeCallback != NULL);

    HRESULT hr = pNodeCallback->Notify(hNode, NCLBK_CONTEXTMENU, 0,
        reinterpret_cast<LPARAM>(&contextInfo));
}

HTREEITEM CAMCView::FindChildNode(HTREEITEM hti, DWORD dwItemDataKey)
{
    hti = m_pTreeCtrl->GetChildItem(hti);

    while (hti && (dwItemDataKey != m_pTreeCtrl->GetItemData(hti)))
    {
        hti = m_pTreeCtrl->GetNextItem(hti, TVGN_NEXT);
    }

    return hti;
}


///////////////////////////////////////////////////////////////////////////////
/// Context Menu Handlers for Result View Item and Background

void CAMCView::ArrangeIcon(long style)
{
#ifdef OLD_STUFF
    ASSERT(m_pTreeCtrl && m_pTreeCtrl->m_pNodeInstCurr);
    if (!m_pTreeCtrl || !m_pTreeCtrl->m_pNodeInstCurr)
        return;

    IFrame* const pFrame = m_pTreeCtrl->m_pNodeInstCurr->GetIFrame();
    ASSERT(pFrame);
    if (!pFrame)
        return;

    IResultDataPrivatePtr pResult = pFrame;
    ASSERT(static_cast<bool>(pResult));
    if (pResult == NULL)
        return ;

    HRESULT hr = pResult->Arrange(style);
    ASSERT(SUCCEEDED(style));
#endif // OLD_STUFF
}

///////////////////////////////////////////////////////////////////////////////
/// Menu handlers

CAMCView::ViewPane CAMCView::GetFocusedPane ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    ASSERT_VALID (this);
    CView* pActiveView = GetParentFrame()->GetActiveView();

    for (ViewPane ePane = ePane_First; ePane <= ePane_Last; ePane = (ViewPane)(ePane+1))
    {
        if (GetPaneView (ePane) == pActiveView)
            return (ePane);
    }

    return (ePane_None);
}

/*+-------------------------------------------------------------------------*
 * CDeferredResultPaneActivation
 *
 *
 * PURPOSE: If the result pane has the focus before and after the node was
 *          selected, then the last event snapin receives is scope selected which
 *          is incorrect. So we first set scope pane as active view but do not
 *          send notifications. Then we set result pane as active view which
 *          sends scope de-select and result pane select.
 *          But when we try to set result pane as active view, the listview may
 *          not be visible yet (if there is view extension, the behavior hides
 *          and then shows the listview).
 *          So we need to wait till listview is setup. We cannot use PostMessage
 *          as the resizing of listview happens using PostMessage which is sent
 *          later (race condition). Therefore we use the idle timer as shown below
 *          so that activation will occur after resizing occurs.
 *
 *+-------------------------------------------------------------------------*/
class CDeferredResultPaneActivation : public CIdleTask
{
public:
    CDeferredResultPaneActivation(HWND hWndAMCView) :
        m_atomTask (AddAtom (_T("CDeferredResultPaneActivation"))),
        m_hWndAMCView(hWndAMCView)
    {
    }

   ~CDeferredResultPaneActivation() {}

    // IIdleTask methods
    SC ScDoWork()
    {
        DECLARE_SC (sc, TEXT("CDeferredResultPaneActivation::ScDoWork"));

        sc = ScCheckPointers((void*)m_hWndAMCView, E_UNEXPECTED);
        if (sc)
           return (sc);

        CWnd *pWnd = CWnd::FromHandle(m_hWndAMCView);
        sc = ScCheckPointers(pWnd, E_UNEXPECTED);
        if (sc)
            return sc;

        CAMCView *pAMCView = dynamic_cast<CAMCView*>(pWnd);

        // Since this method is called by IdleQueue, the target
        // CAMCView may have gone by now, if it does not exist
        // it is not an error (see bug 175737 related to SQL).
        if (! pAMCView)
            return sc;

        sc = pAMCView->ScSetFocusToResultPane();
        if (sc)
            return sc;

        return sc;
    }

    SC ScGetTaskID(ATOM* pID)
    {
        DECLARE_SC (sc, TEXT("CDeferredResultPaneActivation::ScGetTaskID"));
        sc = ScCheckPointers(pID);
        if(sc)
            return sc;

        *pID = m_atomTask;
        return sc;
    }

    SC ScMerge(CIdleTask* pitMergeFrom) {return S_FALSE /*do not merge*/;}

private:
    const ATOM    m_atomTask;
    HWND          m_hWndAMCView;
};


/*+-------------------------------------------------------------------------*
 * CAMCView::ScDeferSettingFocusToResultPane
 *
 * Synopsis: If the result pane has the focus before and after the node was
 *           selected, then the last event snapin receives is scope selected which
 *           is incorrect. So we first set scope pane as active view but do not
 *           send notifications. Then we set result pane as active view which
 *           sends scope de-select and result pane select.
 *           But when we try to set result pane as active view, the listview may
 *           not be visible yet (if there is view extension, the behavior hides
 *           and then shows the listview).
 *           So we need to wait till listview is setup. We cannot use PostMessage
 *           as the resizing of listview happens using PostMessage which is sent
 *           later (race condition). Therefore we use the idle timer as shown below
 *           so that activation will occur after resizing occurs.
 *
 * Returns:  SC
 *
 *--------------------------------------------------------------------------*/
SC CAMCView::ScDeferSettingFocusToResultPane ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState()); // not sure if we need this, but doesn't hurt to have it in here.

    DECLARE_SC (sc, TEXT("CAMCView::ScDeferSettingFocusToResultPane"));

    CIdleTaskQueue* pIdleTaskQueue = AMCGetIdleTaskQueue();
    sc = ScCheckPointers(pIdleTaskQueue, E_UNEXPECTED);
    if(sc)
        return sc;

    /*
     * create the deferred page break task
     */
    CAutoPtr<CDeferredResultPaneActivation> spDeferredResultPaneActivation(new CDeferredResultPaneActivation (GetSafeHwnd()));
    sc = ScCheckPointers(spDeferredResultPaneActivation, E_OUTOFMEMORY);
    if(sc)
        return sc;

    /*
     * put the task in the queue, which will take ownership of it
     * Activation should happen at lower priority than layout.
     */
    sc = pIdleTaskQueue->ScPushTask (spDeferredResultPaneActivation, ePriority_Low);
    if (sc)
        return sc;

    /*
     * if we get here, the idle task queue owns the idle task, so
     * we can detach it from our smart pointer
     */
    spDeferredResultPaneActivation.Detach();

    /*
     * jiggle the message pump so that it wakes up and checks idle tasks
     */
    PostMessage (WM_NULL);

    return (S_OK);
}


//+-------------------------------------------------------------------
//
//  Member:      ScSetFocusToResultPane
//
//  Synopsis:    Set focus to result pane (list or ocx or web). If result
//               is hidden then set to folder tab else set to tasks pane.
//
//  Arguments:
//
//  Returns:      SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSetFocusToResultPane ()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetFocusToResultPane"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if (GetFocusedPane() == ePane_Results)
        return (sc);

    // Make active
    // 1. ListView/OCX/Web if it exists else
    // 2. Folder tab if it exists.
    // 3. Tasks in console taskpad.

    CView* rgActivationOrderEntry[] =
    {
        GetPaneView(ePane_Results),     // results
        m_pResultFolderTabView,         // result tab control
        m_pViewExtensionCtrl,           // view extension web page
    };

    const int INDEX_RESULTS_PANE = 0;
    ASSERT (rgActivationOrderEntry[INDEX_RESULTS_PANE] == GetPaneView(ePane_Results));

    int cEntries = (sizeof(rgActivationOrderEntry) / sizeof(rgActivationOrderEntry[0]));

    // get the currently active entry.
    for(int i = 0; i< cEntries; i++)
    {
        CView *pView = rgActivationOrderEntry[i];
        sc = ScCheckPointers(pView, E_UNEXPECTED);
        if (sc)
            continue;

        if (IsWindow (pView->GetSafeHwnd()) &&
            pView->IsWindowVisible() &&
            pView->IsWindowEnabled())
        {
            GetParentFrame()->SetActiveView (pView);
            return (sc);
        }
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      ScSetFocusToPane
//
//  Synopsis:    Call this member to set focus to any pane.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------
SC CAMCView::ScSetFocusToPane (ViewPane ePane)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSetFocusToPane"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    if (!IsValidPane (ePane))
    {
        ASSERT (false && "CAMCView::ScSetFocusToPane: Invalid pane specifier");
        return (sc = E_FAIL);
    }

    if (GetFocusedPane() == ePane)
        return (sc);

    if (ePane == ePane_Results)
        return (sc = ScSetFocusToResultPane());

    CView* pView = GetPaneView(ePane);

    if (!IsWindow (pView->GetSafeHwnd()) ||
        !pView->IsWindowVisible() ||
        !pView->IsWindowEnabled())
    {
        return (sc = E_FAIL);
    }

    GetParentFrame()->SetActiveView (pView);

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScGetFocusedItem
//
//  Synopsis:    Get the currently selected item's context.
//
//  Arguments:   [hNode]   - [out] The owner of result pane.
//               [lCookie] - [out] If result pane selected the LVDATA.
//               [fScope]  - [out] scope or result
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScGetFocusedItem (HNODE& hNode, LPARAM& lCookie, bool& fScope)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetFocusedItem"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    ASSERT_VALID (this);

    lCookie = LVDATA_ERROR;
    hNode   = GetSelectedNode();
    if (hNode == NULL)
        return (sc = E_UNEXPECTED);

    switch (m_eCurrentActivePane)
    {
    case eActivePaneScope:
            fScope = true;
        break;

    case eActivePaneResult:
        {
            fScope = false;

            // Calculate the LPARAM for result item.
            if (HasOCX())
                lCookie = LVDATA_CUSTOMOCX;

            else if (HasWebBrowser())
                lCookie = LVDATA_CUSTOMWEB;

            else if (HasListOrListPad())
            {
                int cSel = m_pListCtrl->GetSelectedCount();
                ASSERT(cSel >= 0);

                if (cSel == 0)
                    lCookie = LVDATA_BACKGROUND;
                else if (cSel == 1)
                    _GetLVSelectedItemData (&lCookie);
                else if (cSel > 1)
                    lCookie = LVDATA_MULTISELECT;
            }
            else
            {
                return (sc = E_FAIL); // dont know who has the focus???
            }
        }
        break;

    case eActivePaneNone:
    default:
        sc = E_UNEXPECTED;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CAMCView::PrivateChangeListViewMode
//
//  Synopsis:    Private function to change view mode. Consider using
//               ScChangeViewMode instead of this function.
//
//  Arguments:   [nMode] - view mode to be set.
//
//--------------------------------------------------------------------
void CAMCView::PrivateChangeListViewMode(int nMode)
{
    DECLARE_SC(sc, TEXT("CAMCView::PrivateChangeListViewMode"));

    if ((nMode < 0) || (nMode > MMCLV_VIEWSTYLE_FILTERED) )
    {
        sc = E_INVALIDARG;
        return;
    }

    // Add a history entry which will be same as current
    // one except for view mode change.

    sc = ScCheckPointers(m_pHistoryList, m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return;

    // change the current history list entry's view mode
    sc = m_pHistoryList->ScChangeViewMode(nMode);
    if(sc)
        return;

    // set the list control's view mode
    sc = m_pListCtrl->SetViewMode(nMode);
    if (!sc)
    {
        m_nViewMode = nMode;
        SetDirty();

        SetDefaultListViewStyle(GetListViewStyle());
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::OnProcessMultiSelectionChanges
//
//  Synopsis:    message handler for m_nProcessMultiSelectionChangesMsg
//               messages that are posted.
//
//               Handles multi-item de-selection for list view and then
//               send selection for list view items.
//
//               This method knows that selection states of multiple items
//               are changed but not if they are selected or de-selected.
//               The m_bLastSelWasMultiSel is used to determine if it is
//               selection or de-selection.
//
//  Arguments:   none used.
//
//  Returns:     LRESULT
//
//--------------------------------------------------------------------
LRESULT CAMCView::OnProcessMultiSelectionChanges (WPARAM, LPARAM)
{
    DECLARE_SC(sc, _T("CAMCView::OnProcessMultiSelectionChanges"));

    // Selection change so appropriately enable std-toolbar buttons
    // back, forward, export-list, up-one-level, show/hide-scope, help
    sc = ScUpdateStandardbarMMCButtons();
    if (sc)
        return (0);

    if (! m_bProcessMultiSelectionChanges)
        return (0);

    m_bProcessMultiSelectionChanges = false;

    INodeCallback* pNC = GetNodeCallback();
    HNODE hNodeSel = GetSelectedNode();
    sc = ScCheckPointers((void*) hNodeSel, pNC, m_pListCtrl, E_UNEXPECTED);
    if (sc)
        return (0);

    // If some thing was selected previously send a deselection
    // message before sending a selection message (single item de-select
    // is already handled in OnListItemChanged so just handle multi item
    // deselect here).
    if (m_bLastSelWasMultiSel)
    {
        sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, false, 0);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
        m_bLastSelWasMultiSel = false;
    }

    // Now send a selection message
    UINT cSel = m_pListCtrl->GetSelectedCount ();
    if (cSel == 1)
    {
        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));
        selInfo.m_bScope = FALSE;

        int iItem = _GetLVSelectedItemData(&selInfo.m_lCookie);
        ASSERT(iItem != -1);

        sc = ScNotifySelect (pNC, hNodeSel, false /*fMultiSelect*/, true, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;
    }
    else if (cSel > 1)
    {
        Dbg(DEB_USER1, _T("    5. LVN_SELCHANGE <MS> <0, 1>\n"));
        sc = ScNotifySelect (pNC, hNodeSel, true /*fMultiSelect*/, true, 0);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;

        m_bLastSelWasMultiSel = true;
    }

    return (0);
}

SC CAMCView::ScRenameListPadItem() // obsolete?
{
    DECLARE_SC (sc, _T("CAMCView::ScRenameListPadItem"));
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    ASSERT(m_pListCtrl != NULL);
    ASSERT(m_pListCtrl->GetListViewPtr() != NULL);

    int cSel = m_pListCtrl->GetSelectedCount();
    if (cSel != 1)
        return (sc = E_FAIL);

    LPARAM lParam;
    int iItem = _GetLVSelectedItemData(&lParam);
    ASSERT(iItem >= 0);
    if (iItem >= 0)
    {
        m_bRenameListPadItem = true;
        m_pListCtrl->GetListViewPtr()->SetFocus();
        m_pListCtrl->GetListViewPtr()->GetListCtrl().EditLabel(iItem);
        m_bRenameListPadItem = false;
    }

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOrganizeFavorites
 *
 * PURPOSE: Display the "organize favorites" dialog.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOrganizeFavorites()
{
    DECLARE_SC (sc, TEXT("CAMCView::ScOrganizeFavorites"));

    CAMCDoc* pDoc = GetDocument();
    sc = ScCheckPointers(pDoc, E_UNEXPECTED);
    if(sc)
        return sc;

    CFavorites *pFavorites = pDoc->GetFavorites();
    sc = ScCheckPointers(pFavorites);
    if(sc)
        return sc;

    pFavorites->OrganizeFavorites(this);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScLineUpIcons
 *
 * PURPOSE: line up the icons in the list
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScLineUpIcons()
{
    DECLARE_SC (sc, TEXT("CAMCView::ScLineUpIcons"));

    ArrangeIcon(LVA_SNAPTOGRID);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScAutoArrangeIcons
 *
 * PURPOSE: auto arrange the icons in the list
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScAutoArrangeIcons()
{
    DECLARE_SC(sc, TEXT("CAMCView::ScAutoArrangeIcons"));

    sc = ScCheckPointers(m_pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    m_pListCtrl->SetListStyle(m_pListCtrl->GetListStyle() ^ LVS_AUTOARRANGE);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnRefresh
 *
 * PURPOSE: Refreshes the view.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnRefresh(HNODE hNode, bool bScope, LPARAM lResultItemParam)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnRefresh"));
    sc = ScCheckPointers((void*)hNode);
    if (sc)
        return sc;

    HWND hwnd = ::GetFocus();

    sc = ScProcessConsoleVerb(hNode, bScope, lResultItemParam, evRefresh);
    ::SetFocus(hwnd);

    if (sc)
        return sc;

    return sc;
}

/***************************************************************************\
 *
 * CLASS:  CDeferredRenameListItem
 *
 * PURPOSE: This class encapsulates means to put a list control in the rename mode
 *          asynchronously. This is needed to assure all mesages are processed before
 *          and no-one will steel the focus ending unexpectidly the edit mode.
 *
 * USAGE:
 *          use CDeferredRenameListItem::ScDoRenameAsIdleTask() to invoke the operation
 *          asyncronously
 *
\***************************************************************************/
class CDeferredRenameListItem : public CIdleTask
{
    // constructor - used internally only
    CDeferredRenameListItem( HWND hwndListCtrl, int iItemIndex ) :
      m_atomTask (AddAtom (_T("CDeferredRenameListItem"))),
      m_hwndListCtrl(hwndListCtrl), m_iItemIndex(iItemIndex)
    {
    }

protected:

    // IIdleTask methods
    SC ScDoWork()
    {
        DECLARE_SC (sc, TEXT("CDeferredRenameListItem::ScDoWork"));

        // get the ListCtrl pointer
        CListCtrl *pListCtrl = (CListCtrl *)CWnd::FromHandlePermanent(m_hwndListCtrl);
        sc = ScCheckPointers( pListCtrl );
        if (sc)
            return sc;

        // do what you are asked for - put LV in the rename mode
        pListCtrl->SetFocus(); // set the focus first. Don't need to do a SetActiveView here, I believe (vivekj)
        pListCtrl->EditLabel( m_iItemIndex );

        return sc;
    }

    SC ScGetTaskID(ATOM* pID)
    {
        DECLARE_SC (sc, TEXT("CDeferredPageBreak::ScGetTaskID"));
        sc = ScCheckPointers(pID);
        if(sc)
            return sc;

        *pID = m_atomTask;
        return sc;
    }

    SC ScMerge(CIdleTask* pitMergeFrom) { return S_FALSE /*do not merge*/; }

public:

    // this method is called to invoke rename asyncronously.
    // it constructs the idle task and puts it into the queue
    static SC ScDoRenameAsIdleTask( HWND hwndListCtrl, int iItemIndex )
    {
        DECLARE_SC(sc, TEXT("CDeferredPageBreak::ScDoRenameAsIdleTask"));

        CIdleTaskQueue* pIdleTaskQueue = AMCGetIdleTaskQueue();
        sc = ScCheckPointers(pIdleTaskQueue, E_UNEXPECTED);
        if(sc)
            return sc;

        // create the deferred task
        CAutoPtr<CDeferredRenameListItem> spTask(new CDeferredRenameListItem (hwndListCtrl, iItemIndex));
        sc = ScCheckPointers( spTask, E_OUTOFMEMORY);
        if(sc)
            return sc;

        // put the task in the queue, which will take ownership of it
        sc = pIdleTaskQueue->ScPushTask (spTask, ePriority_Normal);
        if (sc)
            return sc;

        // ownership tranfered to the queue, get rid of control over the pointer
        spTask.Detach();

        return sc;
    }

private:
    const ATOM      m_atomTask;
    HWND            m_hwndListCtrl;
    int             m_iItemIndex;
};

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScOnRename
 *
 * PURPOSE: Allows the user to renames the scope or result item specified by pContextInfo
 *
 * PARAMETERS:
 *    CContextMenuInfo * pContextInfo :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScOnRename(CContextMenuInfo *pContextInfo)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScOnRename"));

    sc = ScCheckPointers(pContextInfo, m_pTreeCtrl, m_pListCtrl);
    if(sc)
        return sc;

    if (pContextInfo->m_htiRClicked != NULL)
    {
        m_pTreeCtrl->EditLabel(pContextInfo->m_htiRClicked);
    }
    else
    {
        ASSERT(pContextInfo->m_iListItemIndex >= 0);

        sc = ScCheckPointers(m_pListCtrl->GetListCtrl());
        if(sc)
            return sc;

        // Do this on idle - or else we'll suffer from someone steeling focus
        // Syncronous operation fails in console task case.
        sc = CDeferredRenameListItem::ScDoRenameAsIdleTask( m_pListCtrl->GetListCtrl().m_hWnd, pContextInfo->m_iListItemIndex );
        if(sc)
            return sc;
    }

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScRenameScopeNode
 *
 * PURPOSE:  put the specified scope node into rename mode.
 *
 * PARAMETERS:
 *    HMTNODE  hMTNode : The scope node
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScRenameScopeNode(HMTNODE hMTNode)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScRenameScopeNode"));

    sc = ScCheckPointers(m_pTreeCtrl, E_FAIL);
    if(sc)
        return sc;

    sc = m_pTreeCtrl->ScRenameScopeNode(hMTNode);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetStatusBar
 *
 * PURPOSE: Returns the status bar
 *
 * PARAMETERS:
 *    CConsoleStatusBar ** ppStatusBar :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetStatusBar(CConsoleStatusBar **ppStatusBar)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetStatusBar"));

    sc = ScCheckPointers(ppStatusBar);
    if(sc)
        return sc;

    *ppStatusBar = m_ViewData.GetStatusBar();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetProperty
 *
 * PURPOSE: Gets the property for a result item
 *
 * PARAMETERS:
 *    int    m_iIndex :  The index of the item in the list.
 *    BSTR   bstrPropertyName :
 *    PBSTR  pbstrPropertyValue :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetProperty(int iIndex, BSTR bstrPropertyName, PBSTR pbstrPropertyValue)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetProperty"));

    sc = ScCheckPointers(GetNodeCallback(), m_pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    LPARAM resultItemParam  = iIndex; // the virtual list case
    bool   bScopeItem       = false;  // the virtual list case

    if(!IsVirtualList())
    {
        CResultItem *pri = NULL;
        sc = m_pListCtrl->GetLParam(iIndex, pri);
        if(sc)
            return sc;

        resultItemParam = CResultItem::ToHandle(pri);

        sc = ScCheckPointers(pri);
        if(sc)
            return sc;

        bScopeItem      = pri->IsScopeItem();
    }

    sc = GetNodeCallback()->GetProperty(GetSelectedNode(), bScopeItem, resultItemParam, bstrPropertyName, pbstrPropertyValue);

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScGetNodetype
 *
 * PURPOSE: Returns the nodetype for a list item
 *
 * PARAMETERS:
 *    int    iIndex :
 *    PBSTR  Nodetype :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CAMCView::ScGetNodetype(int iIndex, PBSTR Nodetype)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScGetProperty"));

    sc = ScCheckPointers(GetNodeCallback(), m_pListCtrl, E_UNEXPECTED);
    if(sc)
        return sc;

    LPARAM resultItemParam  = iIndex; // the virtual list case
    bool   bScopeItem       = false;  // the virtual list case

    if(!IsVirtualList())
    {
        CResultItem *pri = NULL;
        sc = m_pListCtrl->GetLParam(iIndex, pri);
        if(sc)
            return sc;

        resultItemParam = CResultItem::ToHandle(pri);

        sc = ScCheckPointers(pri);
        if(sc)
            return sc;

        bScopeItem      = pri->IsScopeItem();
    }

    sc = GetNodeCallback()->GetNodetypeForListItem(GetSelectedNode(), bScopeItem, resultItemParam, Nodetype);

    return sc;
}



/*+-------------------------------------------------------------------------*
 * CAMCView::ScAddViewExtension
 *
 *
 *--------------------------------------------------------------------------*/

SC CAMCView::ScAddViewExtension (const CViewExtensionData& ved)
{
    DECLARE_SC (sc, _T("CAMCView::ScAddViewExtension"));

    return (sc);
}


void
CAMCView::OnChangedResultTab(NMHDR *nmhdr, LRESULT *pRes)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnChangedResultTab"));

    NMFOLDERTAB* nmtab = static_cast<NMFOLDERTAB*>(nmhdr);
    int iTab = nmtab->iItem;
    CFolderTab &tab = m_pResultFolderTabView->GetItem(iTab);

    GUID guidTaskpad = tab.GetClsid();

    // check if we're moving to the same taskpad.
    GUID guidCurrentTaskpad;
    GetTaskpadID(guidCurrentTaskpad);
    if(guidTaskpad == guidCurrentTaskpad)
        return;

    // lookup view extension URL
    CViewExtensionURLs::iterator itVE = m_ViewExtensionURLs.find(guidTaskpad);
    LPCTSTR url = (itVE != m_ViewExtensionURLs.end()) ? itVE->second.c_str() : NULL;

    // apply URL
    sc = ScApplyViewExtension(url);
    if (sc)
        sc.TraceAndClear();

    GetNodeCallback()->SetTaskpad(GetSelectedNode(), &guidTaskpad); // if not found, guidTaskpad is set to GUID_NULL.

    // After setting the taskpad enable/disable save list button
    CStandardToolbar* pStdToolbar = GetStdToolbar();
    ASSERT(NULL != pStdToolbar);
    if (NULL != pStdToolbar)
    {
        pStdToolbar->ScEnableExportList(GetListSize() > 0 /*Enable only if LV has items*/);
    }

    // the taskpad changed. Create a new entry in the history list.
    sc = m_pHistoryList->ScModifyViewTab( guidTaskpad );
    if(sc)
        sc.TraceAndClear();
}


HRESULT
CAMCView::GetRootNodePath(
    CBookmark* pbm)
{
    HTREEITEM htiRoot = m_pTreeCtrl->GetRootItem();
    return GetNodePath(htiRoot, htiRoot, pbm);
}

HRESULT
CAMCView::GetSelectedNodePath(
    CBookmark* pbm)
{
    return GetNodePath(m_pTreeCtrl->GetSelectedItem(),
                       m_pTreeCtrl->GetRootItem(),
                       pbm);
}

HRESULT
CAMCView::GetNodePath(
    HTREEITEM hti,
    HTREEITEM htiRoot,
    CBookmark* pbm)
{
    TRACE_METHOD(CAMCView, GetRootNodeID);

    if (hti == NULL)
        return E_FAIL;

    if (htiRoot == NULL)
        return E_FAIL;

    ASSERT(hti     != NULL);
    ASSERT(htiRoot != NULL);

    HNODE hNode     = (HNODE)m_pTreeCtrl->GetItemData(hti);
    HNODE hRootNode = (HNODE)m_pTreeCtrl->GetItemData(htiRoot);

    HRESULT hr = m_spNodeCallback->GetPath(hNode, hRootNode, (LPBYTE) pbm);

    return hr;
}


inline HMTNODE CAMCView::GetHMTNode(HTREEITEM hti)
{
    TRACE_METHOD(CAMCView, GetHMTNode);

    HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(hti);

    HMTNODE hMTNodeTemp;
    HRESULT hr = m_spNodeCallback->GetMTNode(hNode, &hMTNodeTemp);
    CHECK_HRESULT(hr);

    return hMTNodeTemp;
}

HTREEITEM CAMCView::FindHTreeItem(HMTNODE hMTNode, HTREEITEM hti)
{
    TRACE_METHOD(CAMCView, FindHTreeItem);

    while (hti)
    {
        if (hMTNode == GetHMTNode(hti))
            break;

        hti = m_pTreeCtrl->GetNextItem(hti, TVGN_NEXT);
    }

    return hti;
}

UINT CAMCView::ClipPath(CHMTNODEList* pNodeList, POSITION& rpos, HNODE hNode)
{
    TRACE_METHOD(CAMCView, ClipPath);

    UINT uiReturn = ITEM_IS_IN_VIEW;
    CCoTaskMemPtr<HMTNODE> sphMTNode;
    long lLength = 0;

    HRESULT hr = m_spNodeCallback->GetMTNodePath(hNode, &sphMTNode, &lLength);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return hr;

    ASSERT(lLength == 0 || sphMTNode != NULL);

    for (long i=0; rpos != 0 && i < lLength; i++)
    {
        HMTNODE hMTNode = pNodeList->GetNext(rpos);
        if (hMTNode != sphMTNode[i])
        {
            uiReturn = ITEM_NOT_IN_VIEW;
            break;
        }
    }

    if (uiReturn == ITEM_NOT_IN_VIEW)
        return ITEM_NOT_IN_VIEW;
    return (rpos == 0 && lLength >= i) ? ITEM_IS_PARENT_OF_ROOT : ITEM_IS_IN_VIEW;
}

//
//  GetTreeItem returns TRUE if it can find the htreeitem of the item
//  whose HMTNode is equal to the last element in pNodeList. It returns
//  FALSE if the node does not appear in the view name space or if the
//  the node has not yet been created.
//
//  "pNodeList" is a list of HMTNODEs such that pNodeList[n] is the parent
//  of pNodeList[n+1].
//
UINT CAMCView::GetTreeItem(CHMTNODEList* pNodeList, HTREEITEM* phItem)
{
    TRACE_METHOD(CAMCView, GetTreeItem);

    ASSERT(pNodeList->IsEmpty() == FALSE);

    HTREEITEM   hti = NULL;
    HMTNODE     hMTNodeTemp = 0;

    hti = m_pTreeCtrl->GetRootItem();
    if (hti == NULL)
        return ITEM_NOT_IN_VIEW;

    HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(hti);
    POSITION pos = pNodeList->GetHeadPosition();

    UINT uiReturn = ClipPath(pNodeList, pos, hNode);
    if (uiReturn != ITEM_IS_IN_VIEW)
        return uiReturn;


    HTREEITEM htiTemp = NULL;
    while (pos && hti)
    {
        hMTNodeTemp = (HMTNODE)pNodeList->GetNext(pos);

        hti = FindHTreeItem(hMTNodeTemp, hti);
        ASSERT(hti == NULL || hMTNodeTemp == GetHMTNode(hti));

        htiTemp = hti;

        if (hti != NULL)
            hti = m_pTreeCtrl->GetChildItem(hti);
    }

    if (pos == 0 && htiTemp != NULL)
    {
        // Found the node.
        ASSERT(hMTNodeTemp == pNodeList->GetTail());
        ASSERT(hMTNodeTemp == GetHMTNode(htiTemp));

        *phItem = htiTemp;
        return ITEM_IS_IN_VIEW;
    }
    else
    {
        // The node has not yet been created.
        *phItem = NULL;
        return ITEM_NOT_IN_VIEW;
    }

    return ITEM_IS_IN_VIEW;
}


#define HMTNODE_FIRST   reinterpret_cast<HMTNODE>(TVI_FIRST)
#define HMTNODE_LAST    reinterpret_cast<HMTNODE>(TVI_LAST)

void CAMCView::OnAdd(SViewUpdateInfo *pvui)
{
    TRACE_METHOD(CAMCView, OnAdd);

    ASSERT(pvui->path.IsEmpty() == FALSE);

    HTREEITEM htiParent;
    if (GetTreeItem(&pvui->path, &htiParent) != ITEM_IS_IN_VIEW || htiParent == NULL)
        return;

    bool bFirstChild = (m_pTreeCtrl->GetChildItem(htiParent) == NULL);

    HNODE hNodeParent = (HNODE)m_pTreeCtrl->GetItemData(htiParent);
    if (m_spNodeCallback->Notify(hNodeParent, NCLBK_EXPAND, 0, 0) == S_FALSE)
    {
        m_pTreeCtrl->SetCountOfChildren(htiParent, 1);
        return; // Don't add if it is not expanded.
    }

    // If the hNode was already expanded add the item.
    IScopeTree* const pScopeTree = GetScopeTree();
    ASSERT(pScopeTree != NULL);
    HNODE hNodeNew = 0;
    HRESULT hr = pScopeTree->CreateNode(pvui->newNode,
                                    reinterpret_cast<LONG_PTR>(GetViewData()),
                                    FALSE, &hNodeNew);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
        return;

    HTREEITEM hInsertAfter = TVI_LAST;
    int iInsertIndex = -1;

    if (pvui->insertAfter != NULL)
    {
        hInsertAfter = reinterpret_cast<HTREEITEM>(pvui->insertAfter);

        if (pvui->insertAfter == HMTNODE_LAST)
        {
        }
        else if (pvui->insertAfter == HMTNODE_FIRST)
        {
            iInsertIndex = 0;
        }
        else
        {
            HTREEITEM hti = m_pTreeCtrl->GetChildItem(htiParent);
            ASSERT(hti != NULL);

            iInsertIndex = 1;
            while (hti != NULL)
            {
                if (GetHMTNode(hti) == pvui->insertAfter)
                    break;

                hti = m_pTreeCtrl->GetNextSiblingItem(hti);
                iInsertIndex++;
            }

            if (hti)
            {
               hInsertAfter = hti;
            }
            else
            {
                hInsertAfter = TVI_LAST;
                iInsertIndex = -1;
            }
        }
    }

    if (m_pTreeCtrl->InsertNode(htiParent, hNodeNew, hInsertAfter) == NULL)
        return;

    // if parent of the inserted item currently owns a non-virtual result list,
    // add the item to result list too. Don't add the item if a node select is in
    // progress because the tree control will automatically add all scope items
    // as part of the select procedure.
    if (OwnsResultList(htiParent) && CanInsertScopeItemInResultPane() )
    {
        // Ensure the node is enumerated
        m_pTreeCtrl->ExpandNode(htiParent);

        // Add to result pane.
        RESULTDATAITEM tRDI;
        ::ZeroMemory(&tRDI, sizeof(tRDI));
        tRDI.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        tRDI.nCol = 0;
        tRDI.str = MMC_TEXTCALLBACK;
        tRDI.nIndex = iInsertIndex;

        int nImage;
        int nSelectedImage;

        hr = m_spNodeCallback->GetImages(hNodeNew, &nImage, &nSelectedImage);
        ASSERT(hr == S_OK || nImage == 0);

        tRDI.nImage = nImage;
        tRDI.lParam = CAMCTreeView::LParamFromNode (hNodeNew);

        LPRESULTDATA pResultData = m_pTreeCtrl->GetResultData();
        ASSERT(pResultData != NULL);
        hr = pResultData->InsertItem(&tRDI);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
            hr = m_spNodeCallback->SetResultItem(hNodeNew, tRDI.itemID);
    }

    if ((m_pTreeCtrl->GetRootItem() == htiParent) ||
        ((bFirstChild == true) &&
         (m_spNodeCallback->Notify(hNodeParent, NCLBK_GETEXPANDEDVISUALLY, 0, 0) == S_OK)))
    {
        m_pTreeCtrl->Expand(htiParent, TVE_EXPAND);
    }
}

void CAMCView::OnDeleteEmptyView()
{
    if (m_pTreeCtrl->GetRootItem() == NULL)
    {
        ++m_nReleaseViews;
        if (m_nReleaseViews == 3)
        {
            // Ensure that there is at least one *persistable* view
            CAMCDoc* pDoc = dynamic_cast<CAMCDoc*>(GetDocument());
            ASSERT(pDoc != NULL);
            int cViews = pDoc->GetNumberOfPersistedViews();
            ASSERT(cViews >= 1);
            if ((cViews == 1) && IsPersisted())
            {
                CMainFrame* pMain = dynamic_cast<CMainFrame*>(AfxGetMainWnd());
                ASSERT(pMain != NULL);
				if ( pMain != NULL )
					pMain->SendMessage(WM_COMMAND, ID_WINDOW_NEW, 0);
            }

            DeleteView();
        }
    }
}

void CAMCView::OnDelete(SViewUpdateInfo *pvui)
{
    TRACE_METHOD(CAMCView, OnDelete);

    ASSERT(pvui->path.IsEmpty() == FALSE);

    HTREEITEM hti;
    UINT uiReturn = GetTreeItem(&pvui->path, &hti);

    if (uiReturn == ITEM_NOT_IN_VIEW)
        return;

    ASSERT(uiReturn != ITEM_IS_IN_VIEW || pvui->path.GetTail() == GetHMTNode(hti));

    HTREEITEM htiSel = m_pTreeCtrl->GetSelectedItem();
    BOOL fDeleteThis = (pvui->flag & VUI_DELETE_THIS) ? TRUE : FALSE;
    BOOL fExpandable = (pvui->flag & VUI_DELETE_SETAS_EXPANDABLE) ? TRUE : FALSE;

    if (uiReturn == ITEM_IS_PARENT_OF_ROOT ||
        NULL == hti)
    {
        hti = m_pTreeCtrl->GetRootItem();
        fDeleteThis = TRUE;
        fExpandable = FALSE;
    }

    ASSERT(hti != NULL);

    // If deleted scope item is also shown in the result pane
    // delete it there too. Can't happen with a virtual list.
    // Don't try deleting item if selection is in progress because
    // the scope items haven't been added yet.

    if (fDeleteThis == TRUE &&
        OwnsResultList(m_pTreeCtrl->GetParentItem(hti)) &&
        CanInsertScopeItemInResultPane())
    {
        INodeCallback* pNC = GetNodeCallback();
        HRESULTITEM itemID;
        HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(hti);
        HRESULT hr = pNC->GetResultItem(hNode, &itemID);
        if (SUCCEEDED(hr) && itemID != 0)
        {
            IResultData* pIRD = m_pTreeCtrl->GetResultData();
            pIRD->DeleteItem(itemID, 0);
        }
    }

    m_pTreeCtrl->DeleteNode(hti, fDeleteThis);

    if (fDeleteThis == FALSE && fExpandable == TRUE)
        m_pTreeCtrl->SetItemState(hti, 0, TVIS_EXPANDEDONCE | TVIS_EXPANDED);
}


/*+-------------------------------------------------------------------------*
 *
 * CAMCView::OnUpdateSelectionForDelete
 *
 * PURPOSE: Called when a scope node is deleted. If the node is an ancestor
 *          of the currently selected node, the selection is changed to the closest
 *          node of the deleted node. This is either the next sibling of the node that is being deleted,
 *          or, if there is no next sibling, the previous sibling, or, if there is none,
 *          the parent.
 *
 * PARAMETERS:
 *    SViewUpdateInfo* pvui :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::OnUpdateSelectionForDelete(SViewUpdateInfo* pvui)
{
    DECLARE_SC(sc, TEXT("CAMCView::OnUpdateSelectionForDelete"));

    // make sure we have a path to the deleted node.
    if(pvui->path.IsEmpty())
    {
        sc = E_UNEXPECTED;
        return;
    }

    HTREEITEM htiToDelete;
    UINT uiReturn = GetTreeItem(&pvui->path, &htiToDelete);

    if (uiReturn == ITEM_IS_IN_VIEW && NULL != htiToDelete)
    {
        HTREEITEM htiSel = m_pTreeCtrl->GetSelectedItem();
        BOOL fDeleteThis = (pvui->flag & VUI_DELETE_THIS);

        // Determine whether the selected node is a descendant of the
        // node bring deleted.
        HTREEITEM htiTemp = htiSel;
        while (htiTemp != NULL && htiTemp != htiToDelete)
        {
            htiTemp = m_pTreeCtrl->GetParentItem(htiTemp);
        }

        if (htiToDelete == htiTemp)
        {
            // The selected node is a descendant of the
            // node being deleted.

            if (fDeleteThis == TRUE)
                htiTemp = m_pTreeCtrl->GetParentItem(htiToDelete);

            if (!htiTemp)
                htiTemp = htiToDelete;

            if (htiTemp != htiSel)
            {
                HNODE hNode = m_pTreeCtrl->GetItemNode(htiSel);
                m_pTreeCtrl->OnDeSelectNode(hNode);

                ASSERT(htiTemp != NULL);
                if (htiTemp != NULL)
                    m_pTreeCtrl->SelectItem(htiTemp);
            }
        }
    }
}


/*+-------------------------------------------------------------------------*
 * CAMCView::OnUpdateTaskpadNavigation
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      SViewUpdateInfo *  pvui:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
void CAMCView::OnUpdateTaskpadNavigation(SViewUpdateInfo *pvui)
{
    TRACE_METHOD(CAMCView, OnupdateTaskpadNavigation);

    ASSERT(pvui->newNode != NULL);

    //m_spNodeCallback->UpdateTaskpadNavigation(GetSelectedNode(), pvui->newNode);
}

/*+-------------------------------------------------------------------------*
 * CAMCView::OnModify
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      SViewUpdateInfo *  pvui:
 *
 * RETURNS:
 *      void
/*+-------------------------------------------------------------------------*/
void CAMCView::OnModify(SViewUpdateInfo *pvui)
{
    TRACE_METHOD(CAMCView, OnModify);

    ASSERT(pvui->path.IsEmpty() == FALSE);

    HNODE hNode = 0;
    HTREEITEM hti;

    if (GetTreeItem(&pvui->path, &hti) == ITEM_IS_IN_VIEW && hti != NULL)
    {
        ASSERT(m_pTreeCtrl != NULL);
        m_pTreeCtrl->ResetNode(hti);

        /*
         * The name of the selected node and all of its ancestors are
         * displayed in the frame title.  If the modified item is an
         * ancestor of the selected node, we need to update the frame title.
         */
        HTREEITEM htiAncesctor;

        for (htiAncesctor  = m_pTreeCtrl->GetSelectedItem();
             htiAncesctor != NULL;
             htiAncesctor  = m_pTreeCtrl->GetParentItem (htiAncesctor))
        {
            if (htiAncesctor == hti)
            {
                CChildFrame* pFrame = GetParentFrame();
                if (pFrame)
                    pFrame->OnUpdateFrameTitle(TRUE);
                break;
            }
        }

        ASSERT(hti != NULL);

        if (hti != NULL &&
            OwnsResultList(m_pTreeCtrl->GetParentItem(hti)) &&
            !IsVirtualList())
        {
            // Continue only if the currently selected item is the parent
            // of the modified node. In this case we need to update the
            // result view. Can't happen with a virtual list.

            if (hNode == 0)
                hNode = (HNODE)m_pTreeCtrl->GetItemData(hti);

            ASSERT(hNode != NULL);

            HRESULTITEM hri;
            HRESULT hr = m_spNodeCallback->GetResultItem(hNode, &hri);
            CHECK_HRESULT(hr);

            // NOTE: the test for itemID != NULL below is related to bug 372242:
            // MMC asserts on index server root node.
            // What happens is that the snapin adds scope nodes on a SHOW event.
            // These items have not yet been added to the result pane and so itemID
            // comes back NULL.
            if (SUCCEEDED(hr) && hri != NULL)
                m_pListCtrl->OnModifyItem(CResultItem::FromHandle(hri));
        }
    }
}




void CAMCView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    Dbg(DEB_USER1, _T("CAMCView::OnUpdate<0x%08x, 0x%08x, 0x%08x>\n"),
                                            pSender, lHint, pHint);
    SViewUpdateInfo *pvui = reinterpret_cast<SViewUpdateInfo*>(pHint);
    switch (lHint)
    {
    case 0:
        // Sent by CView::OnInitialUpdate()
        break;

    case VIEW_UPDATE_ADD:
        OnAdd(pvui);
        break;

    case VIEW_UPDATE_SELFORDELETE:
        OnUpdateSelectionForDelete(pvui);
        break;

    case VIEW_UPDATE_DELETE:
        OnDelete(pvui);
        break;

    case VIEW_UPDATE_DELETE_EMPTY_VIEW:
        OnDeleteEmptyView();
        break;

    case VIEW_UPDATE_MODIFY:
        OnModify(pvui);
        break;

    case VIEW_RESELECT:
        if (m_ViewData.m_spControlbarsCache != NULL)
            m_ViewData.m_spControlbarsCache->DetachControlbars();
        m_pTreeCtrl->ScReselect();
        break;

    case VIEW_UPDATE_TASKPAD_NAVIGATION:
        OnUpdateTaskpadNavigation(pvui);
        break;

    default:
        ASSERT(0);
    }
}

static int static_nViewID = 1;

UINT CAMCView::GetViewID(void)
{
    if (m_nViewID)
        return m_nViewID;
    SetViewID(static_nViewID);
    ++static_nViewID;
    return m_nViewID;
    //UINT const id = m_nViewID ? m_nViewID : m_nViewID = static_nViewID++;
    //return id;
}


/*+-------------------------------------------------------------------------*
 * CAMCView::ScCompleteInitialization
 *
 * This function completes the initialization process for CAMCView.  It
 * is called from OnInitialUpdate.
 *--------------------------------------------------------------------------*/

SC CAMCView::ScCompleteInitialization()
{
    DECLARE_SC (sc, _T("CAMCView::ScCompleteInitialization"));

    IScopeTree* const pScopeTree = GetScopeTree();
    sc = ScCheckPointers (pScopeTree, E_UNEXPECTED);
    if (sc)
        return (sc);

    pScopeTree->QueryIterator(&m_spScopeTreeIter);
    pScopeTree->QueryNodeCallback(&m_spNodeCallback);

    m_ViewData.m_spNodeCallback = GetNodeCallback();
    sc = ScCheckPointers (m_ViewData.m_spNodeCallback, E_UNEXPECTED);
    if (sc)
        return (sc);

    CAMCDoc* const pDoc = GetDocument();
    sc = ScCheckPointers (pDoc, E_UNEXPECTED);
    if (sc)
        return (sc);

    if (m_hMTNode == NULL)
    {
        MTNODEID const nodeID = pDoc->GetMTNodeIDForNewView();
        HRESULT hr = pScopeTree->Find(nodeID, &m_hMTNode);

        if (FAILED(hr) || m_hMTNode == 0)
        {
            sc.FromMMC (IDS_ExploredWindowFailed);
            return (sc);
        }
    }

    sc = m_spStandardToolbar->ScInitializeStdToolbar(this);
    if (sc)
        return (sc);

    // Set the iterator to the correct node
    m_spScopeTreeIter->SetCurrent(m_hMTNode);

    bool fShowScopePane            = IsScopePaneAllowed();

    // Intialize the iterator and the callback interface

    SetViewID(pDoc->GetViewIDForNewView());
    GetViewID(); // initialized the view id if GetViewIDForNewView returned 0

    // Insert the root node for this view
    HNODE hNode = 0;
    sc = pScopeTree->CreateNode (m_hMTNode, reinterpret_cast<LONG_PTR>(GetViewData()),
                                 TRUE, &hNode);
    if (sc)
        return (sc);

    sc = ScCheckPointers (hNode, E_UNEXPECTED);
    if (sc)
        return (sc);

    HTREEITEM hti = m_pTreeCtrl->InsertNode(TVI_ROOT, hNode);
    m_htiStartingSelectedNode = hti;

    // If the persisted state is expanded, call INodeCallback::Expand
    m_pTreeCtrl->Expand(hti, TVE_EXPAND);

    /*
     * If a scope pane is permitted in this window, set the scope
     * pane visible, and modify the scope pane & favorites toolbar
     * buttons to the proper checked state.
     */
    sc = ScShowScopePane (fShowScopePane, true);
    if (sc)
        return (sc);

    LPUNKNOWN pUnkResultsPane = NULL;
    pUnkResultsPane = GetPaneUnknown(ePane_Results);
    m_pTreeCtrl->m_spNodeManager->SetResultView(pUnkResultsPane);

    DeferRecalcLayout();

    m_pHistoryList->Clear();
    IdentifyRootNode ();

    // Select the root item
    hti = m_pTreeCtrl->GetRootItem();
    m_pTreeCtrl->SelectItem(hti);

    /*
     * if the document has a custom icon, use it on this window
     */
    if (pDoc->HasCustomIcon())
    {
        GetParentFrame()->SetIcon (pDoc->GetCustomIcon(true),  true);
        GetParentFrame()->SetIcon (pDoc->GetCustomIcon(false), false);
    }

    /*
     * we just initialized, so the view isn't dirty
     */
    SetDirty (false);

    return (sc);
}

void CAMCView::OnInitialUpdate()
{
    DECLARE_SC (sc, _T("CAMCView::OnInitialUpdate"));
    CView::OnInitialUpdate();

    sc = ScCompleteInitialization ();
    if (sc)
        return;
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScDocumentLoadCompleted
//
//  Synopsis:    The document is completely loaded so all the objects
//               that initialize themself from document are in valid
//               state. Any initialization performed earlier using invalid
//               data can be now re-initialized with proper data.
//
//               The above CAMCView::ScCompleteInitialization is called
//               during the loading of views, thus the document is not
//               completely loaded yet.
//
//  Arguments:   [pDoc] - [in] the CAMCDoc object
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScDocumentLoadCompleted (CAMCDoc *pDoc)
{
    DECLARE_SC(sc, _T("CAMCView::ScDocumentLoadCompleted"));
    sc = ScCheckPointers(pDoc);
    if (sc)
        return sc;

    // 1. Need to hide toolbutton "Show/Hide scopetree".
    // The FrameState is loaded after views when CAMCDoc loads document. And it contains
    // whether the "View Customization" is enabled or not. If "View customization" is
    // disabled then we need to disable "Show ScopeTree" button.
    if (! pDoc->AllowViewCustomization())
    {
        CStandardToolbar* pStdToolbar = GetStdToolbar();
        sc = ScCheckPointers(pStdToolbar, E_UNEXPECTED);
        if (sc)
            return (sc);

        sc = pStdToolbar->ScEnableScopePaneBtn (false);
        if (sc)
            return (sc);
    }

    return (sc);
}



/*--------------------------------------------------------------------------*
 * CAMCView::IdentifyRootNode
 *
 * This functions determines if this view is rooted at a non-persistent
 * dynamic node.  If so, we won't persist this view at save time.
 *--------------------------------------------------------------------------*/

void CAMCView::IdentifyRootNode ()
{
    // In order to get results from GetRootNodePath that are meaningful
    // in this context, there needs to be a root item in the tree.
    ASSERT (m_pTreeCtrl->GetRootItem() != NULL);

    CBookmark bm;
    HRESULT   hr = GetRootNodePath (&bm);
    ASSERT (SUCCEEDED (hr) == bm.IsValid());

    m_fRootedAtNonPersistedDynamicNode = (hr != S_OK);
}


void GetFullPath(CAMCTreeView &ctc, HTREEITEM hti, CString &strPath)
{
    TRACE_FUNCTION(GetFullPath);

    if (hti == NULL)
    {
        strPath = _T("");
        return;
    }

    GetFullPath(ctc, ctc.GetParentItem(hti), strPath);

    if (strPath.GetLength() > 0)
        strPath += _T('\\');

    HNODE hNode = ctc.GetItemNode(hti);

    INodeCallback* spCallback = ctc.GetNodeCallback();
    ASSERT(spCallback != NULL);

    tstring strName;
    HRESULT const hr = spCallback->GetDisplayName(hNode, strName);

    strPath += strName.data();
}

LPCTSTR CAMCView::GetWindowTitle(void)
{
    TRACE_METHOD(CAMCView, GetWindowTitle);

    if (HasCustomTitle() && (m_spNodeCallback != NULL))
    {
        HNODE hNode = GetSelectedNode();

        if (hNode != NULL)
        {
            tstring strWindowTitle;

            if (SUCCEEDED(m_spNodeCallback->GetWindowTitle(hNode, strWindowTitle)))
            {
                m_strWindowTitle = strWindowTitle.data();
                return m_strWindowTitle;
            }
        }
    }


    if (m_pTreeCtrl == NULL)
    {
        m_strWindowTitle.Empty();
    }
    else
    {
        GetFullPath(*m_pTreeCtrl,
                    m_pTreeCtrl->GetSelectedItem(),
                    m_strWindowTitle);
    }

    return m_strWindowTitle;
}


void CAMCView::SelectNode(MTNODEID ID, GUID &guidTaskpad)
{
    ScSelectNode(ID);

    // After setting the taskpad enable/disable save list button
    CStandardToolbar* pStdToolbar = GetStdToolbar();
    ASSERT(NULL != pStdToolbar);
    if (NULL != pStdToolbar)
    {
        pStdToolbar->ScEnableExportList(GetListSize() > 0 /*Enable only if LV has items*/);
    }
}

//+-------------------------------------------------------------------
//
//  Member:      CAMCView::ScSelectNode
//
//  Synopsis:    Select the given node. Normally if the node is not available
//               then we select nearest parent or child. But if bSelectExactNode
//               is true then have to select the exact node else do not select any node.
//
//  Arguments:   [ID]               - [in] node that needs to be selected.
//               [bSelectExactNode] - [in] select exact node or not?
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSelectNode (MTNODEID ID, bool bSelectExactNode)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScSelectNode"));

    IScopeTree* pIST = GetScopeTreePtr();
    sc = ScCheckPointers(pIST, m_pTreeCtrl, E_UNEXPECTED);
    if (sc)
        return sc;

    long length = 0;
    CCoTaskMemPtr<MTNODEID> spIDs;

    sc = pIST->GetIDPath(ID, &spIDs, &length);
    if (sc)
        return (sc);

    if ( (length < 1) || (spIDs == NULL) )
        return (sc = E_FAIL);


    sc = m_pTreeCtrl->ScSelectNode(spIDs, length, bSelectExactNode);

    // If select exact node is specified and the node could not be
    // selected then return error without tracing it.
    if (bSelectExactNode && (sc == ScFromMMC(IDS_NODE_NOT_FOUND)) )
    {
        SC scNoTrace = sc;
        sc.Clear();
        return scNoTrace;
    }

    if (sc)
        return sc;

    SetDirty();

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::ScExpandNode
 *
 * PURPOSE: Expands the tree up to the specified node. The expansion can occur
 *          either visually, where the user sees the expansion, or nonvisually,
 *          where all the child items are added but there is no visual effect.
 *
 * PARAMETERS:
 *    MTNODEID id : id of node to expand
 *    bool     bExpand : true to expand the node, false to collapse
 *    bool     bExpandVisually : true to show the changes, else false.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC CAMCView::ScExpandNode (
    MTNODEID    id,
    bool        fExpand,
    bool        fExpandVisually)
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScExpandNode"));

    IScopeTree* pIST = GetScopeTreePtr();
    ASSERT(pIST != NULL);
    if (!pIST)
        return (sc = E_NOINTERFACE);

    long length = 0;
    CCoTaskMemPtr<MTNODEID> spIDs;
    sc = pIST->GetIDPath(id, &spIDs, &length);
    if (sc)
        return (sc);

    ASSERT(length);
    ASSERT(spIDs);

    ASSERT(m_pTreeCtrl != NULL);
    if (m_pTreeCtrl)
        m_pTreeCtrl->ExpandNode(spIDs, length, fExpand, fExpandVisually);

    return (sc);
}

ViewSettings::ViewSettings(CAMCView* v)
    : m_nViewID(v->m_nViewID), m_bDescriptionbarVisible(v->IsDescBarVisible()),
    m_nViewMode(v->m_nViewMode), m_nListViewStyle(v->GetDefaultListViewStyle()),
    m_DefaultLVStyle(v->m_DefaultLVStyle), m_bScopePaneVisible(v->IsScopePaneVisible())
{

    ASSERT(v != NULL);
    v->GetPaneInfo (CConsoleView::ePane_ScopeTree, &m_Scope.cxWidth, &m_Scope.cxMin);
    v->GetDefaultColumnWidths(m_DefaultColumnWidths);
}

/*
 * The location and hidden fields of the scope structure were redundant and are
 * no longer used. Both fields were used to indicate when the scope pane was
 * hidden, which is also determined by the FLAG1_SCOPE_VISIBLE flag. The space
 * has been retained to avoid changing the persisted structure.
 */

struct PersistedViewData
{
    WINDOWPLACEMENT windowPlacement;

    struct
    {
        int location;     // not used, but kept for compatibility
        int min;
        int ideal;
        BOOL hidden;      // not used, but kept for compatibility
    } scope;

    int     viewMode;
    long    listViewStyle;
    ULONG   ulFlag1;
    int     viewID;
    BOOL    descriptionBarVisible;
    int     defaultColumnWidth[2];
};


/*
 * The sense of the FLAG1_NO_xxx flags is negative.  That is, when a
 * FLAG1_NO_xxx flag is set, its corresponding UI element is *not*
 * displayed.  This is to maintain compatibility with console files
 * created before the existence of the FLAG1_NO_xxx flags.  These
 * consoles always had all UI elements displayed, and the then-unused
 * bits in their flags field were defaulted to 0.  To maintain
 * compatibility, we have to maintain that (0 == on).
 */

#define FLAG1_SCOPE_PANE_VISIBLE    0x00000001
#define FLAG1_NO_STD_MENUS          0x00000002
#define FLAG1_NO_STD_BUTTONS        0x00000004
#define FLAG1_NO_SNAPIN_MENUS       0x00000008
#define FLAG1_NO_SNAPIN_BUTTONS     0x00000010
#define FLAG1_DISABLE_SCOPEPANE     0x00000020
#define FLAG1_DISABLE_STD_TOOLBARS  0x00000040
#define FLAG1_CUSTOM_TITLE          0x00000080
#define FLAG1_NO_STATUS_BAR         0x00000100
#define FLAG1_CREATED_IN_USER_MODE  0x00000200  // used to be named FLAG1_NO_AUTHOR_MODE
//#define FLAG1_FAVORITES_SELECTED  0x00000400  // unused, but don't recycle (for compatibility)
#define FLAG1_NO_TREE_ALLOWED     0x00000800    // used for compatibility with MMC1.2 in CAMCView::Load.
                                                // Do not use for any other purposes.
#define FLAG1_NO_TASKPAD_TABS       0x00001000

/***************************************************************************\
 *
 * ARRAY:  mappedViewModes
 *
 * PURPOSE: provides map to be used when persisting ViewMode enumeration
 *
\***************************************************************************/
static const EnumLiteral mappedViewModes[] =
{
    { MMCLV_VIEWSTYLE_ICON,             XML_ENUM_LV_STYLE_ICON },
    { MMCLV_VIEWSTYLE_REPORT,           XML_ENUM_LV_STYLE_REPORT },
    { MMCLV_VIEWSTYLE_SMALLICON,        XML_ENUM_LV_STYLE_SMALLICON },
    { MMCLV_VIEWSTYLE_LIST,             XML_ENUM_LV_STYLE_LIST },
    { MMCLV_VIEWSTYLE_FILTERED,         XML_ENUM_LV_STYLE_FILTERED},
};

/***************************************************************************\
 *
 * ARRAY:  mappedListStyles
 *
 * PURPOSE: provides map to be used when persisting ListView style flag
 *
\***************************************************************************/
static const EnumLiteral mappedListStyles[] =
{
    { LVS_SINGLESEL,            XML_BITFLAG_LV_STYLE_SINGLESEL },
    { LVS_SHOWSELALWAYS,        XML_BITFLAG_LV_STYLE_SHOWSELALWAYS },
    { LVS_SORTASCENDING,        XML_BITFLAG_LV_STYLE_SORTASCENDING },
    { LVS_SORTDESCENDING,       XML_BITFLAG_LV_STYLE_SORTDESCENDING },
    { LVS_SHAREIMAGELISTS,      XML_BITFLAG_LV_STYLE_SHAREIMAGELISTS },
    { LVS_NOLABELWRAP,          XML_BITFLAG_LV_STYLE_NOLABELWRAP },
    { LVS_AUTOARRANGE,          XML_BITFLAG_LV_STYLE_AUTOARRANGE },
    { LVS_EDITLABELS,           XML_BITFLAG_LV_STYLE_EDITLABELS },
    { LVS_OWNERDATA,            XML_BITFLAG_LV_STYLE_OWNERDATA },
    { LVS_NOSCROLL,             XML_BITFLAG_LV_STYLE_NOSCROLL },
    { LVS_ALIGNLEFT,            XML_BITFLAG_LV_STYLE_ALIGNLEFT },
    { LVS_OWNERDRAWFIXED,       XML_BITFLAG_LV_STYLE_OWNERDRAWFIXED },
    { LVS_NOCOLUMNHEADER,       XML_BITFLAG_LV_STYLE_NOCOLUMNHEADER },
    { LVS_NOSORTHEADER,         XML_BITFLAG_LV_STYLE_NOSORTHEADER },
};

/***************************************************************************\
 *
 * ARRAY:  mappedViewFlags
 *
 * PURPOSE: provides map to be used when persisting View flags
 *
\***************************************************************************/
static const EnumLiteral mappedViewFlags[] =
{
    { FLAG1_SCOPE_PANE_VISIBLE,      XML_BITFLAG_VIEW_SCOPE_PANE_VISIBLE },
    { FLAG1_NO_STD_MENUS,            XML_BITFLAG_VIEW_NO_STD_MENUS },
    { FLAG1_NO_STD_BUTTONS,          XML_BITFLAG_VIEW_NO_STD_BUTTONS },
    { FLAG1_NO_SNAPIN_MENUS,         XML_BITFLAG_VIEW_NO_SNAPIN_MENUS },
    { FLAG1_NO_SNAPIN_BUTTONS,       XML_BITFLAG_VIEW_NO_SNAPIN_BUTTONS },
    { FLAG1_DISABLE_SCOPEPANE,       XML_BITFLAG_VIEW_DISABLE_SCOPEPANE },
    { FLAG1_DISABLE_STD_TOOLBARS,    XML_BITFLAG_VIEW_DISABLE_STD_TOOLBARS },
    { FLAG1_CUSTOM_TITLE,            XML_BITFLAG_VIEW_CUSTOM_TITLE },
    { FLAG1_NO_STATUS_BAR,           XML_BITFLAG_VIEW_NO_STATUS_BAR },
    { FLAG1_CREATED_IN_USER_MODE,    XML_BITFLAG_VIEW_CREATED_IN_USER_MODE },
    { FLAG1_NO_TASKPAD_TABS,         XML_BITFLAG_VIEW_NO_TASKPAD_TABS },
};

/***************************************************************************\
 *
 * ARRAY:  mappedSWCommands
 *
 * PURPOSE: provides mapping to persist show commands as literals
 *
\***************************************************************************/
static const EnumLiteral mappedSWCommands[] =
{
    { SW_HIDE,              XML_ENUM_SHOW_CMD_HIDE },
    { SW_SHOWNORMAL,        XML_ENUM_SHOW_CMD_SHOWNORMAL },
    { SW_SHOWMINIMIZED,     XML_ENUM_SHOW_CMD_SHOWMINIMIZED },
    { SW_SHOWMAXIMIZED,     XML_ENUM_SHOW_CMD_SHOWMAXIMIZED },
    { SW_SHOWNOACTIVATE,    XML_ENUM_SHOW_CMD_SHOWNOACTIVATE },
    { SW_SHOW,              XML_ENUM_SHOW_CMD_SHOW },
    { SW_MINIMIZE,          XML_ENUM_SHOW_CMD_MINIMIZE },
    { SW_SHOWMINNOACTIVE,   XML_ENUM_SHOW_CMD_SHOWMINNOACTIVE },
    { SW_SHOWNA,            XML_ENUM_SHOW_CMD_SHOWNA },
    { SW_RESTORE,           XML_ENUM_SHOW_CMD_RESTORE },
    { SW_SHOWDEFAULT,       XML_ENUM_SHOW_CMD_SHOWDEFAULT },
    { SW_FORCEMINIMIZE,     XML_ENUM_SHOW_CMD_FORCEMINIMIZE },
};

/***************************************************************************\
 *
 * ARRAY:  mappedWPFlags
 *
 * PURPOSE: provides mapping to persist WP flags
 *
\***************************************************************************/

static const EnumLiteral mappedWPFlags[] =
{
    { WPF_SETMINPOSITION,       XML_ENUM_WIN_PLACE_SETMINPOSITION },
    { WPF_RESTORETOMAXIMIZED,   XML_ENUM_WIN_PLACE_RESTORETOMAXIMIZED },
#ifdef WPF_ASYNCWINDOWPLACEMENT
    { WPF_ASYNCWINDOWPLACEMENT, XML_ENUM_WIN_PLACE_ASYNCWINDOWPLACEMENT },
#else
    { 4,                        XML_ENUM_WIN_PLACE_ASYNCWINDOWPLACEMENT },
#endif
};


/*+-------------------------------------------------------------------------*
 * PersistViewData(CPersistor &persistor, PersistedViewData viewData)
 *
 *
 * PURPOSE: Persists a PersistedViewData object to the specified persistor.
 *
 *+-------------------------------------------------------------------------*/
void PersistViewData(CPersistor &persistor, PersistedViewData& viewData)
{
    persistor.PersistAttribute(XML_ATTR_VIEW_ID, viewData.viewID);

    // write out the windowPlacement structure.
    persistor.Persist(CXMLWindowPlacement(viewData.windowPlacement));

    // write out the scope structure
    persistor.PersistAttribute(XML_ATTR_VIEW_SCOPE_WIDTH, viewData.scope.ideal);

    if (persistor.IsLoading())
    {
        // initialize for compatibility;
        viewData.scope.hidden = true;
        viewData.scope.location = 0;
        viewData.scope.min = 50;
    }

    // write out the remaining fields
    CPersistor persistorSettings(persistor, XML_TAG_VIEW_SETTINGS_2);

    // create wrapper to persist enumeration values as strings
    CXMLEnumeration viewModePersistor(viewData.viewMode, mappedViewModes, countof(mappedViewModes));
    // persist the wrapper
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_VIEW_MODE,  viewModePersistor);

    // create wrapper to persist flag values as strings
    CXMLBitFlags viewStylePersistor(viewData.listViewStyle, mappedListStyles, countof(mappedListStyles));
    // persist the wrapper
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_LIST_STYLE, viewStylePersistor);

    // create wrapper to persist flag values as strings
    CXMLBitFlags flagPersistor(viewData.ulFlag1, mappedViewFlags, countof(mappedViewFlags));
    // persist the wrapper
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_FLAG, flagPersistor);

    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_DB_VISIBLE, CXMLBoolean(viewData.descriptionBarVisible));
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_DEF_COL_W0, viewData.defaultColumnWidth[0]);
    persistorSettings.PersistAttribute(XML_ATTR_VIEW_SETNGS_DEF_COL_W1, viewData.defaultColumnWidth[1]);
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::Persist
 *
 * PURPOSE: Persists the CAMCView object to the specified persistor. Based
 *          on CAMCView::Save.
 *
 * PARAMETERS:
 *    CPersistor& persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::Persist(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CAMCView::Persist"));

    HRESULT hr;

    CBookmark bmr;
    CBookmark bms;
    if (persistor.IsStoring())
    {
        sc = GetRootNodePath(&bmr);
        if (sc)
            sc.Throw();
        persistor.Persist(bmr, XML_NAME_ROOT_NODE);  // ... its too late for root node when loading

        sc = GetSelectedNodePath(&bms);
        if (sc)
            sc.Throw();
    }
    persistor.Persist(bms, XML_NAME_SELECTED_NODE);

    // mostly copied from CAMCView::Save

    // Get the parent frame
    CWnd* const pParent = GetParent();
    sc = ScCheckPointers(pParent,E_POINTER);
    if (sc)
        sc.Throw();

    // Get the frames state data
    PersistedViewData vd;
    vd.windowPlacement.length = sizeof(vd.windowPlacement);
    const BOOL bGotPlacement = pParent->GetWindowPlacement(&vd.windowPlacement);
    if (!bGotPlacement)
        sc.Throw(E_FAIL);

    if (persistor.IsStoring())
    {
        /*
         * If this window is minimized, make sure we set things up so the
         * WINDOWPLACEMENT.ptMinPosition will be restored by SetWindowPlacement
         * when we load.  If we don't do this, it'll get some random min
         * position, likely not what we want.
         */
        if (vd.windowPlacement.showCmd == SW_SHOWMINIMIZED)
            vd.windowPlacement.flags |= WPF_SETMINPOSITION;


        GetPaneInfo(ePane_ScopeTree, &vd.scope.ideal, &vd.scope.min);
        vd.viewMode = m_nViewMode;
        vd.listViewStyle = GetDefaultListViewStyle();

        vd.ulFlag1 = 0;

        if (IsScopePaneVisible())
            vd.ulFlag1 |= FLAG1_SCOPE_PANE_VISIBLE;

        if (!IsAuthorModeView())
            vd.ulFlag1 |= FLAG1_CREATED_IN_USER_MODE;

        if (!(m_ViewData.m_dwToolbarsDisplayed & STD_MENUS))
            vd.ulFlag1 |= FLAG1_NO_STD_MENUS;

        if (!(m_ViewData.m_dwToolbarsDisplayed & STD_BUTTONS))
            vd.ulFlag1 |= FLAG1_NO_STD_BUTTONS;

        if (!(m_ViewData.m_dwToolbarsDisplayed & SNAPIN_MENUS))
            vd.ulFlag1 |= FLAG1_NO_SNAPIN_MENUS;

        if (!(m_ViewData.m_dwToolbarsDisplayed & SNAPIN_BUTTONS))
            vd.ulFlag1 |= FLAG1_NO_SNAPIN_BUTTONS;

        if (!(m_ViewData.m_dwToolbarsDisplayed & STATUS_BAR))
            vd.ulFlag1 |= FLAG1_NO_STATUS_BAR;

        if (!AreStdToolbarsAllowed ())
            vd.ulFlag1 |= FLAG1_DISABLE_STD_TOOLBARS;

        if (!IsScopePaneAllowed ())
            vd.ulFlag1 |= FLAG1_DISABLE_SCOPEPANE;

        if (HasCustomTitle ())
            vd.ulFlag1 |= FLAG1_CUSTOM_TITLE;

        if (!AreTaskpadTabsAllowed())
            (vd.ulFlag1 |= FLAG1_NO_TASKPAD_TABS);

        vd.viewID = GetViewID();
        vd.descriptionBarVisible = IsDescBarVisible();

        GetDefaultColumnWidths(vd.defaultColumnWidth);
    }

    PersistViewData(persistor,vd);

    if (persistor.IsLoading())
    {
        ASSERT(int(m_nViewID) == vd.viewID);
        m_ViewData.m_nViewID = m_nViewID = vd.viewID;
        if (int(m_nViewID) >= static_nViewID)
            static_nViewID = m_nViewID + 1;

        //SetDefaultColumnWidths(vd.defaultColumnWidth);
        SetDescBarVisible(vd.descriptionBarVisible);

        // we shouldn't restore maximized window position
        // since it may not be proper one for the current resolution
        // related to bug #404118
        WINDOWPLACEMENT orgPlacement;
        ZeroMemory(&orgPlacement,sizeof(orgPlacement));
        orgPlacement.length = sizeof(orgPlacement);
        if (pParent->GetWindowPlacement(&orgPlacement))
        {
          vd.windowPlacement.ptMaxPosition = orgPlacement.ptMaxPosition;
        }

        m_ViewData.SetScopePaneVisible( 0 != (vd.ulFlag1 & FLAG1_SCOPE_PANE_VISIBLE) );

        // Set the location and size of the frame
        const BOOL bPlaced = pParent->SetWindowPlacement(&vd.windowPlacement);
        if (!bPlaced)
            sc.Throw(E_FAIL);

        // Restore window settings
        if (vd.ulFlag1 & FLAG1_DISABLE_SCOPEPANE)
            m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_NOSCOPEPANE;

        if (vd.ulFlag1 & FLAG1_DISABLE_STD_TOOLBARS)
            m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_NOTOOLBARS;

        if (vd.ulFlag1 & FLAG1_CUSTOM_TITLE)
            m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_CUSTOMTITLE;

        SetAuthorModeView (!(vd.ulFlag1 & FLAG1_CREATED_IN_USER_MODE));

        if ((vd.ulFlag1 & FLAG1_NO_TASKPAD_TABS))
            SetTaskpadTabsAllowed(FALSE);

        // Apply run time restrictions
        // if at least one type of scope pane allowed then if the selected
        // one is not allowed, switch to the other. If neither is allowed
        // then keep the selection and hide the scope pane.
        if (IsScopePaneAllowed())
        {
            // Restore scope pane settings
            SetPaneInfo(ePane_ScopeTree, vd.scope.ideal, vd.scope.min);

            sc = ScShowScopePane ( m_ViewData.IsScopePaneVisible() );
        }
        else
            sc = ScShowScopePane (false);

        if (sc)
            sc.Throw();

        // Force layout re-calculation
        DeferRecalcLayout();

        // Restore view style & view mode if persisted will be set by nodemgr.
        SetDefaultListViewStyle(vd.listViewStyle);

        DWORD dwToolbars = 0;
        if (!(vd.ulFlag1 & FLAG1_NO_STD_MENUS))
            dwToolbars |= STD_MENUS;
        if (!(vd.ulFlag1 & FLAG1_NO_STD_BUTTONS))
            dwToolbars |= STD_BUTTONS;
        if (!(vd.ulFlag1 & FLAG1_NO_SNAPIN_MENUS))
            dwToolbars |= SNAPIN_MENUS;
        if (!(vd.ulFlag1 & FLAG1_NO_SNAPIN_BUTTONS))
            dwToolbars |= SNAPIN_BUTTONS;
        if (!(vd.ulFlag1 & FLAG1_NO_STATUS_BAR))
            dwToolbars |= STATUS_BAR;

        // display the status bar appropriately
        if (StatusBarOf (m_ViewData.m_dwToolbarsDisplayed) != StatusBarOf (dwToolbars))
        {
            CChildFrame* pFrame = GetParentFrame ();
            if (pFrame != NULL)
            {
                pFrame->ToggleStatusBar();
                SetStatusBarVisible(!IsStatusBarVisible());

                ASSERT (StatusBarOf (m_ViewData.m_dwToolbarsDisplayed) ==
                                    StatusBarOf (dwToolbars));
            }
        }

        // display the appropriate toolbars
        if (ToolbarsOf (m_ViewData.m_dwToolbarsDisplayed) != ToolbarsOf (dwToolbars))
        {
            m_spNodeCallback->UpdateWindowLayout(
                    reinterpret_cast<LONG_PTR>(&m_ViewData), dwToolbars);
            ASSERT (ToolbarsOf (m_ViewData.m_dwToolbarsDisplayed) ==
                    ToolbarsOf (dwToolbars));
        }

        // Update the status of MMC menus.
        sc = ScUpdateMMCMenus();
        if (sc)
            sc.Throw();

        SetDirty (false);
        m_pHistoryList->Clear();
    }

    SaveStartingSelectedNode();

    if (persistor.IsLoading())
    {
        SC sc;

        IScopeTree* const pScopeTree = GetScopeTreePtr();
        if(!pScopeTree)
        {
            sc = E_UNEXPECTED;
            return;
        }

        MTNODEID idTemp = 0;
        bool bExactMatchFound = false; // out value from GetNodeIDFromBookmark, unused
        sc = pScopeTree->GetNodeIDFromBookmark(bms, &idTemp, bExactMatchFound);
        if(sc)
            return;

        sc = ScSelectNode(idTemp);
        if(sc)
            return;
    }

    // if we've stored everything -we're clean
    if (persistor.IsStoring())
        SetDirty (false);
}


bool CAMCView::Load(IStream& stream)
// Caller is responsible for notifying user if false is returned
{
    TRACE_METHOD(CAMCView, Load);

    SetDirty (false);

    // Read the view data from the stream.
    ASSERT(&stream);
    if (!&stream)
        return false;
    PersistedViewData pvd;
    unsigned long bytesRead;
    HRESULT hr = stream.Read(&pvd, sizeof(pvd), &bytesRead);
    ASSERT(SUCCEEDED(hr) && bytesRead == sizeof(pvd));
    if (FAILED(hr))
        return false;

    ASSERT(int(m_nViewID) == pvd.viewID);
    m_ViewData.m_nViewID = m_nViewID = pvd.viewID;
    if (int(m_nViewID) >= static_nViewID)
        static_nViewID = m_nViewID + 1;

    //SetDefaultColumnWidths(pvd.defaultColumnWidth);
    SetDescBarVisible(pvd.descriptionBarVisible);

    // Get the parent frame
    CWnd* const pParent = GetParent();
    ASSERT(pParent != NULL);
    if (pParent == NULL)
        return false;

    // we shouldn't restore maximized window position
    // since it may not be proper one for the current resolution
    // related to bug #404118
    WINDOWPLACEMENT orgPlacement;
    ZeroMemory(&orgPlacement,sizeof(orgPlacement));
    orgPlacement.length = sizeof(orgPlacement);
    if (pParent->GetWindowPlacement(&orgPlacement))
    {
      pvd.windowPlacement.ptMaxPosition = orgPlacement.ptMaxPosition;
    }

    // Set the location and size of the frame
    const BOOL bPlaced = pParent->SetWindowPlacement(&pvd.windowPlacement);
    ASSERT(bPlaced != FALSE);
    if (bPlaced == FALSE)
        return false;

    // Restore window settings
    if (pvd.ulFlag1 & FLAG1_DISABLE_SCOPEPANE)
        m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_NOSCOPEPANE;

    if (pvd.ulFlag1 & FLAG1_DISABLE_STD_TOOLBARS)
        m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_NOTOOLBARS;

    if (pvd.ulFlag1 & FLAG1_CUSTOM_TITLE)
        m_ViewData.m_lWindowOptions |= MMC_NW_OPTION_CUSTOMTITLE;

    SetAuthorModeView (!(pvd.ulFlag1 & FLAG1_CREATED_IN_USER_MODE));

    if ((pvd.ulFlag1 & FLAG1_NO_TASKPAD_TABS))
        SetTaskpadTabsAllowed(FALSE);

    // Restore scope pane settings
    SetPaneInfo(ePane_ScopeTree, pvd.scope.ideal, pvd.scope.min);

    // The FLAG1_NO_TREE_ALLOWED is used only for compatibility with MMC1.2 console files
    // It is a relic from old console files that does not exist in MMC2.0 console files.
    bool bScopeTreeNotAllowed = (pvd.ulFlag1 & FLAG1_NO_TREE_ALLOWED);

    SC sc;

    if ( (IsScopePaneAllowed()) && (! bScopeTreeNotAllowed) )
        sc = ScShowScopePane ((pvd.ulFlag1 & FLAG1_SCOPE_PANE_VISIBLE) != 0);
    else
        sc = ScShowScopePane (false);

    if (sc)
        return (false);

    // Force layout re-calculation
    DeferRecalcLayout();

    // Restore view style & view mode if persisted will be set by nodemgr.
    SetDefaultListViewStyle(pvd.listViewStyle);

    DWORD dwToolbars = 0;
    if (!(pvd.ulFlag1 & FLAG1_NO_STD_MENUS))
        dwToolbars |= STD_MENUS;
    if (!(pvd.ulFlag1 & FLAG1_NO_STD_BUTTONS))
        dwToolbars |= STD_BUTTONS;
    if (!(pvd.ulFlag1 & FLAG1_NO_SNAPIN_MENUS))
        dwToolbars |= SNAPIN_MENUS;
    if (!(pvd.ulFlag1 & FLAG1_NO_SNAPIN_BUTTONS))
        dwToolbars |= SNAPIN_BUTTONS;
    if (!(pvd.ulFlag1 & FLAG1_NO_STATUS_BAR))
        dwToolbars |= STATUS_BAR;

    // display the status bar appropriately
    if (StatusBarOf (m_ViewData.m_dwToolbarsDisplayed) != StatusBarOf (dwToolbars))
    {
        CChildFrame* pFrame = GetParentFrame ();
        if (pFrame != NULL)
        {
            pFrame->ToggleStatusBar();
            SetStatusBarVisible(!IsStatusBarVisible());

            ASSERT (StatusBarOf (m_ViewData.m_dwToolbarsDisplayed) ==
                            StatusBarOf (dwToolbars));
        }
    }

    // display the appropriate toolbars
    if (ToolbarsOf (m_ViewData.m_dwToolbarsDisplayed) != ToolbarsOf (dwToolbars))
    {
        m_spNodeCallback->UpdateWindowLayout(
                reinterpret_cast<LONG_PTR>(&m_ViewData), dwToolbars);
        ASSERT (ToolbarsOf (m_ViewData.m_dwToolbarsDisplayed) ==
                ToolbarsOf (dwToolbars));
    }

    // Update the status of MMC menus.
    sc = ScUpdateMMCMenus();
    if (sc)
        return false;

    SetDirty (false);
    m_pHistoryList->Clear();

    return true;
}


//+-------------------------------------------------------------------
//
//  Member:     ScSpecialResultpaneSelectionActivate
//
//  Synopsis:    Only the list(/Web/OCX) or the tree can be "active" from the point
//               of view of selected items and MMCN_SELECT. This is not
//               the same as the MFC concept of "active view". There are a couple
//               of views that cannot be active in this sense, such as the taskpad
//               and tab views.
//               When the active view (according to this definition) changes, this
//               function is called. Thus, ScTreeViewSelectionActivate and
//               ScListViewSelectionActivate/ScSpecialResultpaneSelectionActivate
//               are always called in pairs when the activation changes, one to handle
//               deactivation, and one to handle activation.
//
//               Consider the following scenario
//               1) The tree view has (MFC/windows style) focus.
//               2) The user clicks on the taskpad view
//                   Result - selection activation does not change from the tree. All verbs
//                   still correspond to the selected tree item.
//               3) The user clicks on the folder view
//                   Result - once again, selection activation does not chang
//               4) The user clicks on one of the result views eg the list
//                   Result - ScTreeViewSelectionActivate(false) and ScListViewSelectionActivate(true)
//                   Thus verbs and the toolbar now correspond to the selected list item(s).
//               5) The user clicks on the taskpad view.
//                   Result - as in step 2, nothing happens
//               6) The user clicks on the result view
//                   Result - because the active view has not changed, nothing happens.
//
//  Arguments:  [bActivate] - special result pane is selected/de-selected.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CAMCView::ScSpecialResultpaneSelectionActivate(bool bActivate)
{
    DECLARE_SC(sc, TEXT("CAMCView::ScSpecialResultpaneSelectionActivate"));

    /*
     * Bug 331904: prevent recursion
     */
    if (m_fActivatingSpecialResultPane)
    {
        TRACE (_T("CAMCView:ScSpecialResultpaneSelectionActivate: shorting out of recursion\n"));
        return sc;
    }

    do
    {
        m_fActivatingSpecialResultPane = true;

        HNODE hNode = GetSelectedNode();

        SELECTIONINFO selInfo;
        ZeroMemory(&selInfo, sizeof(selInfo));
        selInfo.m_bScope = FALSE;
        selInfo.m_bDueToFocusChange = TRUE;
        selInfo.m_bBackground = FALSE;

        INodeCallback* pNodeCallBack = GetNodeCallback();

        if (HasOCX())
        {
            selInfo.m_bResultPaneIsOCX = TRUE;
            selInfo.m_lCookie = LVDATA_CUSTOMOCX;
        }
        else if (HasWebBrowser())
        {
            selInfo.m_bResultPaneIsWeb = TRUE;
            selInfo.m_lCookie = LVDATA_CUSTOMWEB;
        }
        else
        {
            // Dont do anything. Just return.
            m_fActivatingSpecialResultPane = false;
            return sc;
        }

        sc = ScNotifySelect (pNodeCallBack, hNode, false /*fMultiSelect*/, bActivate, &selInfo);
        if (sc)
            sc.TraceAndClear(); // ignore & continue;

    } while ( FALSE );

    m_fActivatingSpecialResultPane = false;

    return sc;
}

void CAMCView::CloseView()
{
    DECLARE_SC(sc, TEXT("CAMCView::CloseView"));

    TRACE_METHOD(CAMCView, CloseView);

    // fire event to script
    // this needs to be done while view is still 'alive'
    sc = ScFireEvent(CAMCViewObserver::ScOnCloseView, this);
    if (sc)
        sc.TraceAndClear();

    IScopeTree* const pScopeTree = GetScopeTreePtr();
    ASSERT(pScopeTree != NULL);
    if (pScopeTree != NULL)
    {
        HRESULT hr = pScopeTree->CloseView(m_nViewID);
        ASSERT(hr == S_OK);
    }
}


void CAMCView::OnDestroy()
{
    TRACE_METHOD(CAMCView, OnDestroy);

    // send the view destroy notification to all observers.
    SC sc;
    sc = ScFireEvent(CAMCViewObserver::ScOnViewDestroyed, this);
    if(sc)
        sc.TraceAndClear();

    if (IsPersisted())
    {
        if(m_pDocument != NULL)
            m_pDocument->SetModifiedFlag(TRUE);
        SetDirty();
    }

    CDocument* pDoc = GetDocument();
    ASSERT(pDoc != NULL);

    // if we were in ListPad-mode....
    // this must be detached before destroying the Scopetree,
    // because we need to send a notify to the snapin,
    // which we get from the hnode.
    if (m_pListCtrl->IsListPad())
    {
        sc = m_pListCtrl->ScAttachToListPad (NULL, NULL);
        if(sc)
            sc.TraceAndClear();
    }

    // make sure to stop running scripts if we have a web browser
    if( HasWebBrowser() )
    {
        ASSERT( m_pWebViewCtrl != NULL );
        if ( m_pWebViewCtrl != NULL )
        {
            m_pWebViewCtrl->DestroyWindow();
            m_pWebViewCtrl = NULL;
        }
    }

    // make sure to stop running scripts if we have a view extension
    if ( m_fViewExtended )
    {
        ASSERT( m_pViewExtensionCtrl != NULL );
        if ( m_pViewExtensionCtrl != NULL )
        {
            m_pViewExtensionCtrl->DestroyWindow();
            m_pViewExtensionCtrl = NULL;
        }
    }

    if (m_pTreeCtrl != NULL)
    {
        HNODE hNode = GetSelectedNode();
        if (hNode)
            m_pTreeCtrl->OnDeSelectNode(hNode);

        m_pTreeCtrl->DeleteScopeTree();
    }

    IScopeTree* const pScopeTree = GetScopeTreePtr();
    ASSERT(pScopeTree != NULL);
    if (pScopeTree != NULL)
    {
        HRESULT hr = pScopeTree->DeleteView(m_nViewID);
        ASSERT(hr == S_OK);
    }

    CView::OnDestroy();
}

void CAMCView::OnUpdateFileSnapinmanager(CCmdUI* pCmdUI)
{
    pCmdUI->Enable ();
}

void CAMCView::OnSize(UINT nType, int cx, int cy)
{
    TRACE_METHOD(CAMCView, OnSize);

    CView::OnSize(nType, cx, cy);

    if (nType != SIZE_MINIMIZED)
        RecalcLayout();
}

SC CAMCView::ScToggleDescriptionBar()
{
    TRACE_METHOD(CAMCView, ScToggleDescriptionBar);
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    SetDescBarVisible (!IsDescBarVisible());
    SetDirty();

    /*
     * Don't defer this layout.  This may be called by the Customize View
     * dialog which wants to see its updates in real time.  It will be
     * sitting in a modal message loop so we won't get a chance to precess
     * our idle task.
     */
    RecalcLayout();

    return (S_OK);
}

SC CAMCView::ScToggleStatusBar()
{
    TRACE_METHOD(CAMCView, ScToggleStatusBar);
    AFX_MANAGE_STATE (AfxGetAppModuleState());
        DECLARE_SC (sc, _T("CAMCView::ScToggleStatusBar"));

    CChildFrame* pFrame = GetParentFrame();
        sc = ScCheckPointers (pFrame, E_UNEXPECTED);
        if (sc)
                return (sc);

    pFrame->ToggleStatusBar();

    SetStatusBarVisible (!IsStatusBarVisible());
    SetDirty();

    return (sc);
}

SC CAMCView::ScToggleTaskpadTabs()
{
    TRACE_METHOD(CAMCView, ScToggleTaskpadTabs);
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    SetTaskpadTabsAllowed (!AreTaskpadTabsAllowed());
    SetDirty();

    /*
     * Don't defer this layout.  This message will be sent by the
     * Customize View dialog which wants to see its updates in
     * real time.  It will be sitting in a modal message loop so
     * we won't get a chance to precess our idle task.
     */
    RecalcLayout();

    return (S_OK);
}

SC CAMCView::ScToggleScopePane()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    DECLARE_SC (sc, _T("CAMCView::ScToggleScopePane"));

    sc = ScShowScopePane (!IsScopePaneVisible());
    if (sc)
        return (sc);

    return (sc);
}

void CAMCView::OnActionMenu(CPoint point, LPCRECT prcExclude)
{
    TRACE_METHOD(CAMCView, OnActionMenu);

    UINT fHitTestFlags = 0;
    HTREEITEM hTreeItem = m_pTreeCtrl->GetSelectedItem( );

    ASSERT_VALID (this);

    /*
     * BUG: 99643
     * Right now there is inconsistency between what you get by action menu & right click
     * on a location in taskpad. The action menu always assumes it is tree or if result
     * pane it is list or ocx or web or background. So if a taskpad is selected it assumes
     * the corresponding list item is selected or tree item is selected or background.
     * But right click on taskpad calls CAMCView::OnContextMenu which determines nothing
     * is selected and does nothing. This needs to be addressed.
     */

    ASSERT(eActivePaneNone != m_eCurrentActivePane);

    if (eActivePaneScope == m_eCurrentActivePane)
    {
        if (hTreeItem != NULL)
        {
            HNODE hNode = (HNODE)m_pTreeCtrl->GetItemData(hTreeItem);
            OnContextMenuForTreeItem(INDEX_INVALID, hNode, point, CCT_SCOPE, hTreeItem, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
        }
        else
        {
            OnContextMenuForTreeBackground(point, prcExclude, false/*bAllowDefaultItem*/);
        }
    }
    else
    {
        if (HasListOrListPad())
        {
            int cSel = m_pListCtrl->GetSelectedCount();
            int nIndex = -1;

            LPARAM lvData = LVDATA_ERROR;
            if (cSel == 0)
                lvData = LVDATA_BACKGROUND;
            else if (cSel == 1)
                nIndex = _GetLVSelectedItemData(&lvData);
            else if (cSel > 1)
                lvData = LVDATA_MULTISELECT;


            ASSERT(lvData != LVDATA_ERROR);
            if (lvData == LVDATA_ERROR)
                return;

            if (lvData == LVDATA_BACKGROUND)
            {
                // Find out which pane has focus to set the CMINFO_DO_SCOPEPANE_MENU flag.
                HNODE hNode = GetSelectedNode();
                DATA_OBJECT_TYPES ePaneType = (GetParentFrame()->GetActiveView() == m_pTreeCtrl) ? CCT_SCOPE : CCT_RESULT;

                OnContextMenuForTreeItem(INDEX_BACKGROUND, hNode, point, ePaneType, hTreeItem, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
                return;
            }
            else if (lvData == LVDATA_MULTISELECT)
            {
                OnContextMenuForListItem(INDEX_MULTISELECTION, NULL, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
            }
            else
            {
                if (IsVirtualList())
                {
                    OnContextMenuForListItem(nIndex, (HRESULTITEM)NULL, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
                }
                else
                {
                    CResultItem* pri = CResultItem::FromHandle (lvData);

                    if (pri != NULL)
                    {
                        if (pri->IsScopeItem())
                            OnContextMenuForTreeItem(nIndex, pri->GetScopeNode(), point, CCT_RESULT, NULL, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
                        else
                            OnContextMenuForListItem(nIndex, lvData, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
                    }
                }
            }
        }
        else
        {
            // The active window may be a web page or task pad or ocx.

            LPARAM lvData = LVDATA_ERROR;

            if (HasOCX())
            {
                lvData = LVDATA_CUSTOMOCX;
                OnContextMenuForListItem(INDEX_OCXPANE, (HRESULTITEM)lvData, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
            }
            else if (HasWebBrowser())
            {
                lvData = LVDATA_CUSTOMWEB;
                OnContextMenuForListItem(INDEX_WEBPANE, (HRESULTITEM)lvData, point, MMC_CONTEXT_MENU_ACTION, prcExclude, false/*bAllowDefaultItem*/);
            }
            else
            {
                // Some unknown window has the focus.
                ASSERT(FALSE && "Unknown window has the focus");
            }
        }
    }
}


SC CAMCView::ScUpOneLevel()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());
    TRACE_METHOD(CAMCView, ScUpOneLevel);

    DECLARE_SC (sc, _T("CAMCView::ScUpOneLevel"));
    sc = E_FAIL;

    if (m_pTreeCtrl)
    {
        HTREEITEM htiParent = m_pTreeCtrl->GetParentItem (m_pTreeCtrl->GetSelectedItem());

        if (htiParent)
        {
            m_pTreeCtrl->SelectItem(htiParent);
            m_pTreeCtrl->EnsureVisible(htiParent);
            sc = S_OK;
        }
    }

    return (sc);
}


void CAMCView::OnViewMenu(CPoint point, LPCRECT prcExclude)
{
    TRACE_METHOD(CAMCView, OnViewMenu);

    OnContextMenuForListItem (INDEX_BACKGROUND, NULL, point,
                              MMC_CONTEXT_MENU_VIEW, prcExclude,
                              false /*bAllowDefaultItem*/);
}

void CAMCView::OnDrawClipboard()
{
    if (m_htiCut)
    {
        m_pTreeCtrl->SetItemState(m_htiCut, 0, TVIS_CUT);
    }
    else
    {
        m_pListCtrl->CutSelectedItems(FALSE);
    }
}

/*+-------------------------------------------------------------------------*
 *
 * CAMCView::OnSettingChange
 *
 * PURPOSE: Handles WM_SETTINGCHANGE. Recalculates the layout. The
 *          result folder tab control needs this, for instance.
 *
 * PARAMETERS:
 *    UINT     uFlags :
 *    LPCTSTR  lpszSection :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CAMCView::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
    DeferRecalcLayout();
}

void CAMCView::OnUpdatePasteBtn()
{
    DECLARE_SC(sc, TEXT("CAMCView::OnUpdatePasteBtn"));

    HNODE  hNode  = NULL;
    LPARAM lvData = NULL;
    bool   bScope = FALSE;

    sc = ScGetFocusedItem(hNode, lvData, bScope);
    if (sc)
        return;

    INodeCallback* pNC = GetNodeCallback();
    sc = ScCheckPointers(hNode, pNC, E_UNEXPECTED);
    if (sc)
        return;

    sc = pNC->UpdatePasteButton(hNode, bScope, lvData);
    if (sc)
        return;

    return;
}


void CAMCView::OnContextHelp()
{
    ScContextHelp();
}


SC CAMCView::ScContextHelp ()
{
    AFX_MANAGE_STATE (AfxGetAppModuleState());

    m_fSnapinDisplayedHelp = false;
    SC sc = SendGenericNotify(NCLBK_CONTEXTHELP);

    // if snap-in hasn't called us to display a topic
    // and it has not handled the notification then
    // display MMC topic by default
    if (!m_fSnap