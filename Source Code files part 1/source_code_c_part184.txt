    IN      PCTSTR UserProfilePath
    );

PCURRENT_USER_DATA
GetCurrentUserData (
    VOID
    );

VOID
FreeCurrentUserData (
    IN      PCURRENT_USER_DATA CurrentUserData
    );

BOOL
ExecuteDelayedOperations (
    IN      BOOL CleanupOnly
    );

//
// modules.c
//

BOOL
InitializeVcmModules (
    IN      PVOID Reserved
    );

BOOL
InitializeModules (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PVOID Reserved
    );

BOOL
BroadcastUserCreation (
    IN      PTEMPORARYPROFILE UserProfile
    );


VOID
TerminateModules (
    VOID
    );

VOID
TerminateProcessWideModules (
    VOID
    );


BOOL
ExecutePhysicalAcquireCallbacks (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT Content,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit,
    OUT     PMIG_CONTENT *NewContent
    );

BOOL
FreeViaAcquirePhysicalCallback (
    IN      PMIG_CONTENT Content
    );


BOOL
ExecutePhysicalEnumCheckCallbacks (
    IN      PMIG_TYPEOBJECTENUM ObjectEnum
    );

BOOL
ExecutePhysicalEnumAddCallbacks (
    IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN OUT  PUINT CurrentCallback
    );

VOID
AbortPhysicalEnumCallback (
    IN      PMIG_TYPEOBJECTENUM ObjectEnum,         ZEROED
    IN      UINT CurrentCallback
    );

#ifdef PRERELEASE
VOID
LoadCrashHooks (
    VOID
    );
#endif

//
// ANSI/UNICODE Macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\initype.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    inifiles.c

Abstract:

    <abstract>

Author:

    Calin Negreanu (calinn) 23 Sep 2001

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_INITYPE     "IniFiles"
#define MAXINISIZE      65536

//
// Strings
//

// none

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    BOOL AlreadyAdvanced;
    MIG_OBJECTSTRINGHANDLE IniPattern;
    PFILETREE_ENUM FileEnum;
    PCTSTR IniFile;
    PTSTR SectionMultiSz;
    PCTSTR SectionCurrent;
    PCTSTR SectionPattern;
    PTSTR KeyMultiSz;
    PCTSTR KeyCurrent;
    PCTSTR KeyPattern;
} INI_ENUM, *PINI_ENUM;

//
// Globals
//

MIG_OBJECTTYPEID g_IniTypeId = 0;
GROWBUFFER g_IniConversionBuff = INIT_GROWBUFFER;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPhysicalIniKey;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextPhysicalIniKey;
//TYPE_ABORTENUMCURRENTPHYSICALNODE AbortEnumCurrentIniFile;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumPhysicalIniKey;
TYPE_CONVERTOBJECTTOMULTISZ ConvertIniKeyToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToIniKey;
TYPE_GETNATIVEOBJECTNAME GetNativeIniKeyName;
TYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalIniKey;
TYPE_RELEASEPHYSICALOBJECT ReleasePhysicalIniKey;
TYPE_DOESPHYSICALOBJECTEXIST DoesPhysicalIniKeyExist;
TYPE_REMOVEPHYSICALOBJECT RemovePhysicalIniKey;
TYPE_CREATEPHYSICALOBJECT CreatePhysicalIniKey;
TYPE_REPLACEPHYSICALOBJECT ReplacePhysicalIniKey;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertIniKeyContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertIniKeyContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedIniKeyContent;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pEnumIniFileKeyWorker (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PINI_ENUM IniFilesEnum
    )
{
    PCTSTR sectKey = NULL;
    PCTSTR leaf = NULL;

    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }

    do {
        // normally here we should be positioned with a proper section
        // and key so all we have to do is verify that the fit the patterns

        if (IniFilesEnum->AlreadyAdvanced &&
            IniFilesEnum->SectionPattern &&
            IniFilesEnum->SectionCurrent &&
            IsPatternMatchEx (IniFilesEnum->SectionPattern, IniFilesEnum->SectionCurrent) &&
            IniFilesEnum->KeyPattern &&
            IniFilesEnum->KeyCurrent &&
            IsPatternMatchEx (IniFilesEnum->KeyPattern, IniFilesEnum->KeyCurrent)
            ) {
            // great, we found a match
            sectKey = JoinTextEx (g_IsmPool, IniFilesEnum->SectionCurrent, IniFilesEnum->KeyCurrent, TEXT("="), 0, NULL);
            if (!sectKey) {
                // something went wrong, let's get out of here
                AbortEnumPhysicalIniKey (EnumPtr);
                return FALSE;
            }
            leaf = JoinPathsInPoolEx ((g_IsmPool, IniFilesEnum->FileEnum->Name, sectKey, NULL));
            if (!leaf) {
                // something went wrong, let's get out of here
                IsmReleaseMemory (sectKey);
                sectKey = NULL;
                AbortEnumPhysicalIniKey (EnumPtr);
                return FALSE;
            }

            EnumPtr->ObjectName = IsmCreateObjectHandle (IniFilesEnum->FileEnum->Location, leaf);
            EnumPtr->NativeObjectName = JoinPathsInPoolEx ((g_IsmPool, IniFilesEnum->FileEnum->Location, leaf, NULL));
            IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
            GetNodePatternMinMaxLevels (EnumPtr->ObjectNode, NULL, &EnumPtr->Level, NULL);
            EnumPtr->SubLevel = 0;
            EnumPtr->IsLeaf = TRUE;
            EnumPtr->IsNode = TRUE;
            EnumPtr->Details.DetailsSize = 0;
            EnumPtr->Details.DetailsData = NULL;
            IsmReleaseMemory (leaf);
            leaf = NULL;
            IsmReleaseMemory (sectKey);
            sectKey = NULL;
            return TRUE;
        }

        IniFilesEnum->AlreadyAdvanced = TRUE;

        // The key or section did not match the pattern. Let's advance
        // the key and see what happens
        if (IniFilesEnum->KeyCurrent != NULL) {
            IniFilesEnum->KeyCurrent = GetEndOfString (IniFilesEnum->KeyCurrent);
            if (IniFilesEnum->KeyCurrent == NULL) {
                // no more keys, we need to go to the next section
                continue;
            }
            IniFilesEnum->KeyCurrent ++; // just hop over the 0 termination
            if (IniFilesEnum->KeyCurrent [0] == 0) {
                // no more keys, we need to go to the next section
                IniFilesEnum->KeyCurrent = NULL;
                continue;
            }
        } else if (IniFilesEnum->SectionCurrent != NULL) {
            // There were no more keys. Let's advance the section
            IniFilesEnum->SectionCurrent = GetEndOfString (IniFilesEnum->SectionCurrent);
            if (IniFilesEnum->SectionCurrent == NULL) {
                // no more sections, we need to go to the next file
                continue;
            }
            IniFilesEnum->SectionCurrent ++; // just hop over the 0 termination
            if (IniFilesEnum->SectionCurrent [0] == 0) {
                // no more sections, we need to go to the next file
                IniFilesEnum->SectionCurrent = NULL;
                continue;
            }
            GetPrivateProfileString (
                IniFilesEnum->SectionCurrent,
                NULL,
                TEXT(""),
                IniFilesEnum->KeyMultiSz,
                MAXINISIZE - 2,
                IniFilesEnum->IniFile
                );
            IniFilesEnum->KeyCurrent = IniFilesEnum->KeyMultiSz;
        } else {
            // There were no more sections. Let's advance to the next file

            IniFilesEnum->SectionCurrent = NULL;
            IniFilesEnum->KeyCurrent = NULL;

            if (!EnumNextFileInTree (IniFilesEnum->FileEnum)) {
                // we are done
                AbortEnumPhysicalIniKey (EnumPtr);
                return FALSE;
            }
            IniFilesEnum->IniFile = IniFilesEnum->FileEnum->NativeFullName;
            // let's get the section multisz
            if (GetPrivateProfileString (
                    NULL,
                    NULL,
                    TEXT(""),
                    IniFilesEnum->SectionMultiSz,
                    MAXINISIZE - 2,
                    IniFilesEnum->IniFile
                    )) {
                IniFilesEnum->SectionCurrent = IniFilesEnum->SectionMultiSz;
                if (IniFilesEnum->SectionCurrent [0] == 0) {
                    IniFilesEnum->SectionCurrent = NULL;
                } else {
                    if (GetPrivateProfileString (
                            IniFilesEnum->SectionCurrent,
                            NULL,
                            TEXT(""),
                            IniFilesEnum->KeyMultiSz,
                            MAXINISIZE - 2,
                            IniFilesEnum->IniFile
                            )) {
                        IniFilesEnum->KeyCurrent = IniFilesEnum->KeyMultiSz;
                        if (IniFilesEnum->KeyCurrent [0] == 0) {
                            IniFilesEnum->KeyCurrent = NULL;
                        }
                    }
                }
            }
        }
    } while (TRUE);
}

BOOL
EnumFirstPhysicalIniKey (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PINI_ENUM iniFilesEnum = NULL;
    PCTSTR node = NULL, leaf = NULL;
    PTSTR sectPtr = NULL;
    PTSTR keyPtr = NULL;
    MIG_SEGMENTS nodePat[1];
    MIG_SEGMENTS leafPat[1];
    UINT nrSegNode = 0;
    UINT nrSegLeaf = 0;
    BOOL result = FALSE;

    iniFilesEnum = (PINI_ENUM) IsmGetMemory (sizeof (INI_ENUM));
    ZeroMemory (iniFilesEnum, sizeof (INI_ENUM));
    IsmCreateObjectStringsFromHandle (Pattern, &node, &leaf);
    if (node) {

        // prepare the INI leaf pattern
        if (leaf) {
            sectPtr = _tcschr (leaf, TEXT('\\'));
            if (sectPtr) {
                *sectPtr = 0;
                sectPtr++;
            }
        }

        // prepare the section pattern and the key pattern
        if (sectPtr) {
            keyPtr = _tcsrchr (sectPtr, TEXT('='));
            if (keyPtr) {
                *keyPtr = 0;
                keyPtr ++;
                iniFilesEnum->SectionPattern = IsmDuplicateString (sectPtr);
                iniFilesEnum->KeyPattern = IsmDuplicateString (keyPtr);
            } else {
                iniFilesEnum->SectionPattern = IsmDuplicateString (sectPtr);
                iniFilesEnum->KeyPattern = IsmDuplicateString (TEXT("*"));
            }
        } else {
            iniFilesEnum->SectionPattern = IsmDuplicateString (TEXT("*"));
            iniFilesEnum->KeyPattern = IsmDuplicateString (TEXT("*"));
        }

        nodePat [0].Segment = node;
        nodePat [0].IsPattern = TRUE;
        nrSegNode ++;
        if (leaf) {
            leafPat [0].Segment = leaf;
            leafPat [0].IsPattern = TRUE;
            nrSegLeaf ++;
        }
        iniFilesEnum->IniPattern = IsmCreateObjectPattern (nodePat, nrSegNode, nrSegLeaf?leafPat:NULL, nrSegLeaf);
        if (!iniFilesEnum->IniPattern) {
            // out of memory?
            IsmDestroyObjectString (leaf);
            leaf = NULL;
            IsmDestroyObjectString (node);
            node = NULL;
            AbortEnumPhysicalIniKey (EnumPtr);
            return FALSE;
        }

        IsmDestroyObjectString (leaf);
        leaf = NULL;

        IsmDestroyObjectString (node);
        node = NULL;

        iniFilesEnum->FileEnum = IsmGetMemory (sizeof (FILETREE_ENUM));
        if (!iniFilesEnum->FileEnum) {
            // out of memory?
            AbortEnumPhysicalIniKey (EnumPtr);
            return FALSE;
        }
        ZeroMemory (iniFilesEnum->FileEnum, sizeof (FILETREE_ENUM));

        // let's get the first INI file
        if (!EnumFirstFileInTreeEx (
            iniFilesEnum->FileEnum,
            iniFilesEnum->IniPattern,
            DRIVEENUM_ALLVALID,
            FALSE,
            FALSE,
            TRUE,
            TRUE,
            FILEENUM_ALL_SUBLEVELS,
            FALSE,
            NULL
            )) {
            // no such INI file
            AbortEnumPhysicalIniKey (EnumPtr);
            return FALSE;
        }
        iniFilesEnum->IniFile = iniFilesEnum->FileEnum->NativeFullName;

        // let's allocate the section and key multisz
        iniFilesEnum->SectionMultiSz = IsmGetMemory (MAXINISIZE * sizeof (TCHAR));
        iniFilesEnum->KeyMultiSz = IsmGetMemory (MAXINISIZE * sizeof (TCHAR));
        if ((!iniFilesEnum->SectionMultiSz) || (!iniFilesEnum->KeyMultiSz)) {
            // out of memory?
            AbortEnumPhysicalIniKey (EnumPtr);
            return FALSE;
        }

        // let's get the section multisz
        if (GetPrivateProfileString (
                NULL,
                NULL,
                TEXT(""),
                iniFilesEnum->SectionMultiSz,
                MAXINISIZE - 2,
                iniFilesEnum->IniFile
                )) {
            iniFilesEnum->SectionCurrent = iniFilesEnum->SectionMultiSz;
            if (iniFilesEnum->SectionCurrent [0] != 0) {
                if (GetPrivateProfileString (
                        iniFilesEnum->SectionCurrent,
                        NULL,
                        TEXT(""),
                        iniFilesEnum->KeyMultiSz,
                        MAXINISIZE - 2,
                        iniFilesEnum->IniFile
                        )) {
                    iniFilesEnum->KeyCurrent = iniFilesEnum->KeyMultiSz;
                    if (iniFilesEnum->KeyCurrent [0] != 0) {
                        iniFilesEnum->AlreadyAdvanced = TRUE;
                    }
                }
            }
        }

        EnumPtr->EtmHandle = (LONG_PTR) iniFilesEnum;

        return pEnumIniFileKeyWorker (EnumPtr, iniFilesEnum);
    }
    if (leaf) {
        IsmDestroyObjectString (leaf);
    }
    return FALSE;
}

BOOL
EnumNextPhysicalIniKey (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PINI_ENUM iniFilesEnum = NULL;

    if (EnumPtr->NativeObjectName) {
        IsmReleaseMemory (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    iniFilesEnum = (PINI_ENUM)(EnumPtr->EtmHandle);
    if (!iniFilesEnum) {
        return FALSE;
    }

    iniFilesEnum->AlreadyAdvanced = FALSE;

    return pEnumIniFileKeyWorker (EnumPtr, iniFilesEnum);
}

VOID
AbortEnumPhysicalIniKey (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PINI_ENUM iniFilesEnum = NULL;

    if (EnumPtr->NativeObjectName) {
        FreePathString (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    iniFilesEnum = (PINI_ENUM)(EnumPtr->EtmHandle);
    if (!iniFilesEnum) {
        return;
    }
    if (iniFilesEnum->SectionMultiSz) {
        IsmReleaseMemory (iniFilesEnum->SectionMultiSz);
    }
    if (iniFilesEnum->KeyMultiSz) {
        IsmReleaseMemory (iniFilesEnum->KeyMultiSz);
    }
    if (iniFilesEnum->FileEnum) {
        AbortEnumFileInTree (iniFilesEnum->FileEnum);
        IsmReleaseMemory (iniFilesEnum->FileEnum);
    }
    if (iniFilesEnum->IniPattern) {
        IsmDestroyObjectHandle (iniFilesEnum->IniPattern);
        iniFilesEnum->IniPattern = NULL;
    }
    IsmReleaseMemory (iniFilesEnum->KeyPattern);
    IsmReleaseMemory (iniFilesEnum->SectionPattern);
    IsmReleaseMemory (iniFilesEnum);
    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

BOOL
AcquirePhysicalIniKey (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,                 CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PTSTR sectPtr = NULL;
    PTSTR keyPtr = NULL;
    PCTSTR iniFile = NULL;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        MYASSERT (FALSE);
        return FALSE;
    }

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        if (node && leaf) {
            sectPtr = _tcschr (leaf, TEXT('\\'));
            if (sectPtr) {
                *sectPtr = 0;
                sectPtr ++;
                keyPtr = _tcsrchr (sectPtr, TEXT('='));
                if (keyPtr) {
                    *keyPtr = 0;
                    keyPtr ++;
                    iniFile = JoinPaths (node, leaf);
                    if (iniFile) {
                        ObjectContent->MemoryContent.ContentSize = MAXINISIZE * sizeof (TCHAR);
                        ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
                        if (ObjectContent->MemoryContent.ContentBytes) {
                            if (GetPrivateProfileString (
                                    sectPtr,
                                    keyPtr,
                                    TEXT(""),
                                    (PTSTR)ObjectContent->MemoryContent.ContentBytes,
                                    ObjectContent->MemoryContent.ContentSize / sizeof (TCHAR) - 1,
                                    iniFile
                                    )) {
                                ObjectContent->MemoryContent.ContentSize = SizeOfString ((PCTSTR)ObjectContent->MemoryContent.ContentBytes);
                                result = TRUE;
                            }
                            if (!result) {
                                IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
                                ObjectContent->MemoryContent.ContentBytes = NULL;
                                ObjectContent->MemoryContent.ContentSize = 0;
                            }
                        }
                        FreePathString (iniFile);
                    }
                }
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
ReleasePhysicalIniKey (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    if (ObjectContent) {
        if (ObjectContent->MemoryContent.ContentBytes) {
            IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return TRUE;
}

BOOL
DoesPhysicalIniKeyExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PTSTR sectPtr = NULL;
    PTSTR keyPtr = NULL;
    PCTSTR iniFile = NULL;
    TCHAR buffer [MAXINISIZE * sizeof (TCHAR)] = TEXT("");
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        if (node && leaf) {
            sectPtr = _tcschr (leaf, TEXT('\\'));
            if (sectPtr) {
                *sectPtr = 0;
                sectPtr ++;
                keyPtr = _tcsrchr (sectPtr, TEXT('='));
                if (keyPtr) {
                    *keyPtr = 0;
                    keyPtr ++;
                    iniFile = JoinPaths (node, leaf);
                    if (iniFile) {
                        if (GetPrivateProfileString (
                                sectPtr,
                                keyPtr,
                                TEXT(""),
                                buffer,
                                MAXINISIZE - 1,
                                iniFile
                                )) {
                            if (buffer [0] != 0) {
                                result = TRUE;
                            }
                        }
                        FreePathString (iniFile);
                    }
                }
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
RemovePhysicalIniKey (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PTSTR sectPtr = NULL;
    PTSTR keyPtr = NULL;
    PCTSTR iniFile = NULL;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        if (node && leaf) {
            sectPtr = _tcschr (leaf, TEXT('\\'));
            if (sectPtr) {
                *sectPtr = 0;
                sectPtr ++;
                keyPtr = _tcsrchr (sectPtr, TEXT('='));
                if (keyPtr) {
                    *keyPtr = 0;
                    keyPtr ++;
                    iniFile = JoinPaths (node, leaf);
                    if (iniFile) {
                        // record ini key deletion
                        IsmRecordOperation (
                            JRNOP_DELETE,
                            g_IniTypeId,
                            ObjectName
                            );
                        if (WritePrivateProfileString (
                                sectPtr,
                                keyPtr,
                                NULL,
                                iniFile
                                )) {
                            result = TRUE;
                        }
                        FreePathString (iniFile);
                    }
                }
            }
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
pIniTrackedCreateDirectory (
    IN      PCTSTR DirName
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR pathCopy;
    PTSTR p;
    BOOL result = TRUE;

    pathCopy = DuplicatePathString (DirName, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == TEXT(':') && pathCopy[2] == TEXT('\\')) {
        //
        // <drive>:\ case
        //

        p = _tcschr (&pathCopy[3], TEXT('\\'));

    } else if (pathCopy[0] == TEXT('\\') && pathCopy[1] == TEXT('\\')) {

        //
        // UNC case
        //

        p = _tcschr (pathCopy + 2, TEXT('\\'));
        if (p) {
            p = _tcschr (p + 1, TEXT('\\'));
        }

    } else {

        //
        // Relative dir case
        //

        p = _tcschr (pathCopy, TEXT('\\'));
    }

    //
    // Make all directories along the path except for the last segment
    //

    while (p) {

        *p = 0;

        if (!DoesFileExist (pathCopy)) {

            // record directory creation
            objectName = IsmCreateObjectHandle (pathCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                MIG_FILE_TYPE,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            result = CreateDirectory (pathCopy, NULL);
            if (!result) {
                break;
            }
        }

        *p = TEXT('\\');
        p = _tcschr (p + 1, TEXT('\\'));
    }

    // Now we got to the end, this is the actual INI file
    // so don't create this directory

    FreePathString (pathCopy);

    return result;
}

BOOL
CreatePhysicalIniKey (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PTSTR sectPtr = NULL;
    PTSTR keyPtr = NULL;
    PCTSTR iniFile = NULL;
    BOOL result = FALSE;

    if (!ObjectContent->ContentInFile) {
        if (ObjectContent->MemoryContent.ContentBytes && ObjectContent->MemoryContent.ContentSize) {
            if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

                if (node && leaf) {
                    sectPtr = _tcschr (leaf, TEXT('\\'));
                    if (sectPtr) {
                        *sectPtr = 0;
                        sectPtr ++;
                        keyPtr = _tcsrchr (sectPtr, TEXT('='));
                        if (keyPtr) {
                            *keyPtr = 0;
                            keyPtr ++;
                            iniFile = JoinPaths (node, leaf);
                            if (iniFile) {
                                // let's make sure that the directory where this INI files is
                                // supposed to be exists

                                pIniTrackedCreateDirectory (iniFile);

                                // record file creation
                                IsmRecordOperation (
                                    JRNOP_CREATE,
                                    g_IniTypeId,
                                    ObjectName
                                    );

                                if (WritePrivateProfileString (
                                        sectPtr,
                                        keyPtr,
                                        (PCTSTR)ObjectContent->MemoryContent.ContentBytes,
                                        iniFile
                                        )) {
                                    result = TRUE;
                                }
                                FreePathString (iniFile);
                            }
                        }
                    }
                }
                IsmDestroyObjectString (node);
                IsmDestroyObjectString (leaf);
            }
        }
    }
    return result;
}

BOOL
ReplacePhysicalIniKey (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    BOOL result = TRUE;

    // we are going to delete any existing INI file key with this name,
    // and create a new one
    if (DoesPhysicalIniKeyExist (ObjectName)) {
        result = RemovePhysicalIniKey (ObjectName);
    }
    if (result) {
        result = CreatePhysicalIniKey (ObjectName, ObjectContent);
    }
    return result;
}

PCTSTR
ConvertIniKeyToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PTSTR sectPtr = NULL;
    PTSTR keyPtr = NULL;
    TCHAR buffer [MAXINISIZE * sizeof (TCHAR)] = TEXT("");
    PTSTR result = NULL;
    BOOL bresult = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        if (node && leaf) {

            sectPtr = _tcschr (leaf, TEXT('\\'));
            if (sectPtr) {
                *sectPtr = 0;
                sectPtr ++;
                keyPtr = _tcsrchr (sectPtr, TEXT('='));
                if (keyPtr) {
                    *keyPtr = 0;
                    keyPtr ++;
                    g_IniConversionBuff.End = 0;
                    GbCopyQuotedString (&g_IniConversionBuff, node);
                    GbCopyQuotedString (&g_IniConversionBuff, leaf);
                    GbCopyQuotedString (&g_IniConversionBuff, sectPtr);
                    GbCopyQuotedString (&g_IniConversionBuff, keyPtr);
                    if (ObjectContent && (!ObjectContent->ContentInFile) && ObjectContent->MemoryContent.ContentBytes) {
                        GbCopyQuotedString (&g_IniConversionBuff, (PCTSTR)ObjectContent->MemoryContent.ContentBytes);
                    }
                    bresult = TRUE;
                }
            }
            if (bresult) {
                GbCopyString (&g_IniConversionBuff, TEXT(""));
                result = IsmGetMemory (g_IniConversionBuff.End);
                CopyMemory (result, g_IniConversionBuff.Buf, g_IniConversionBuff.End);
            }

            g_IniConversionBuff.End = 0;
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToIniKey (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
    MULTISZ_ENUM multiSzEnum;
    PCTSTR iniDir = NULL;
    PCTSTR iniFile = NULL;
    PCTSTR section = NULL;
    PCTSTR key = NULL;
    PCTSTR value = NULL;
    PCTSTR sectKey = NULL;
    PCTSTR leaf = NULL;
    UINT index;
    BOOL result = FALSE;

    g_IniConversionBuff.End = 0;

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == 0) {
                iniDir = multiSzEnum.CurrentString;
            }
            if (index == 1) {
                iniFile = multiSzEnum.CurrentString;
            }
            if (index == 2) {
                section = multiSzEnum.CurrentString;
            }
            if (index == 3) {
                key = multiSzEnum.CurrentString;
            }
            if (index == 4) {
                value = multiSzEnum.CurrentString;
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if ((!iniDir) && (!iniFile)) {
        return FALSE;
    }

    __try {

        if (ObjectContent) {

            ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
            ObjectContent->ContentInFile = FALSE;
            ObjectContent->MemoryContent.ContentSize = SizeOfString (value);
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            if (!ObjectContent->MemoryContent.ContentBytes) {
                // something is wrong, let's get out of here
                __leave;
            }
            CopyMemory (
                (PBYTE)ObjectContent->MemoryContent.ContentBytes,
                value,
                ObjectContent->MemoryContent.ContentSize
                );

            ObjectContent->Details.DetailsSize = 0;
            ObjectContent->Details.DetailsData = NULL;
        }

        sectKey = JoinTextEx (g_IsmPool, section, key, TEXT("="), 0, NULL);
        if (!sectKey) {
            __leave;
        }
        leaf = JoinPaths (iniFile, sectKey);
        if (!leaf) {
            __leave;
        }
        if (ObjectName) {
            *ObjectName = IsmCreateObjectHandle (iniDir, leaf);
        }
        result = TRUE;
    }
    __finally {
        if (leaf) {
            FreePathString (leaf);
            leaf = NULL;
        }

        if (sectKey) {
            IsmReleaseMemory (sectKey);
            sectKey = NULL;
        }
        if (!result) {
            if (ObjectContent) {
                if (ObjectContent->MemoryContent.ContentBytes) {
                    IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
                }
                ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
            }
        }
    }
    return result;
}

PCTSTR
GetNativeIniKeyName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL;
    PCTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        if (node && leaf) {
            result = JoinPathsInPoolEx ((g_IsmPool, node, leaf, NULL));
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

PMIG_CONTENT
ConvertIniKeyContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // Convert INI file key to UNICODE
            DirectDbcsToUnicodeN (
                (PWSTR)result->MemoryContent.ContentBytes,
                (PSTR)ObjectContent->MemoryContent.ContentBytes,
                ObjectContent->MemoryContent.ContentSize
                );
            result->MemoryContent.ContentSize = SizeOfMultiSzW ((PWSTR)result->MemoryContent.ContentBytes);
        }
    }

    return result;
}

PMIG_CONTENT
ConvertIniKeyContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    result = IsmGetMemory (sizeof (MIG_CONTENT));

    if (result) {

        CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));

        if ((ObjectContent->MemoryContent.ContentSize != 0) &&
            (ObjectContent->MemoryContent.ContentBytes != NULL)
            ) {
            // convert INI file key to ANSI
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            if (result->MemoryContent.ContentBytes) {
                DirectUnicodeToDbcsN (
                    (PSTR)result->MemoryContent.ContentBytes,
                    (PWSTR)ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
                result->MemoryContent.ContentSize = SizeOfMultiSzA ((PSTR)result->MemoryContent.ContentBytes);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedIniKeyContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}

VOID
InitIniType (
    VOID
    )
{
    TYPE_REGISTER iniFilesTypeData;

    ZeroMemory (&iniFilesTypeData, sizeof (TYPE_REGISTER));
    iniFilesTypeData.Priority = PRIORITY_INI;
    iniFilesTypeData.EnumFirstPhysicalObject = EnumFirstPhysicalIniKey;
    iniFilesTypeData.EnumNextPhysicalObject = EnumNextPhysicalIniKey;
    iniFilesTypeData.AbortEnumPhysicalObject = AbortEnumPhysicalIniKey;
    iniFilesTypeData.ConvertObjectToMultiSz = ConvertIniKeyToMultiSz;
    iniFilesTypeData.ConvertMultiSzToObject = ConvertMultiSzToIniKey;
    iniFilesTypeData.GetNativeObjectName = GetNativeIniKeyName;
    iniFilesTypeData.AcquirePhysicalObject = AcquirePhysicalIniKey;
    iniFilesTypeData.ReleasePhysicalObject = ReleasePhysicalIniKey;
    iniFilesTypeData.DoesPhysicalObjectExist = DoesPhysicalIniKeyExist;
    iniFilesTypeData.RemovePhysicalObject = RemovePhysicalIniKey;
    iniFilesTypeData.CreatePhysicalObject = CreatePhysicalIniKey;
    iniFilesTypeData.ReplacePhysicalObject = ReplacePhysicalIniKey;
    iniFilesTypeData.ConvertObjectContentToUnicode = ConvertIniKeyContentToUnicode;
    iniFilesTypeData.ConvertObjectContentToAnsi = ConvertIniKeyContentToAnsi;
    iniFilesTypeData.FreeConvertedObjectContent = FreeConvertedIniKeyContent;

    g_IniTypeId = IsmRegisterObjectType (
                        S_INITYPE,
                        TRUE,
                        FALSE,
                        &iniFilesTypeData
                        );
    MYASSERT (g_IniTypeId);
}

VOID
DoneIniType (
    VOID
    )
{
    GbFree (&g_IniConversionBuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\modules.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    modules.c

Abstract:

    Implements routines that are common to the entire ISM.

Author:

    Jim Schmidt (jimschm) 21-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_ISM     "Ism"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    UINT RefCount;
    HMODULE Handle;
} MODULEDATA, *PMODULEDATA;

//
// Globals
//

HASHTABLE g_ModuleTable;
HASHTABLE g_EtmTable;
HASHTABLE g_VcmTable;
HASHTABLE g_SgmTable;
HASHTABLE g_SamTable;
HASHTABLE g_DgmTable;
HASHTABLE g_DamTable;
HASHTABLE g_CsmTable;
HASHTABLE g_OpmTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pFreeEtmTable (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
pFindModule (
    IN      PCTSTR ModulePath,
    OUT     PTSTR FullModulePath
    )
{
    HANDLE result = NULL;
    TCHAR relativePath[MAX_PATH] = TEXT("");
    PCTSTR fileName;
    PTSTR p;

    fileName = GetFileNameFromPath (ModulePath);

    if (fileName) {
        if (GetModuleFileName (g_hInst, relativePath, ARRAYSIZE(relativePath))) {
            p = _tcsrchr (relativePath, TEXT('\\'));
            if (p) {
                p++;
                StringCopyByteCount (
                    p,
                    fileName,
                    sizeof (relativePath) - (HALF_PTR) ((PBYTE) p - (PBYTE) relativePath)
                    );
            }

            if (DoesFileExist (relativePath)) {
                StringCopy (FullModulePath, relativePath);
                return;
            }
        }
    }

    GetFullPathName (ModulePath, ARRAYSIZE(relativePath), relativePath, (PTSTR *) &fileName);

    if (DoesFileExist (relativePath)) {
        StringCopy (FullModulePath, relativePath);
        return;
    }

    if (SearchPath (NULL, fileName, NULL, MAX_PATH, FullModulePath, &p)) {
        return;
    }

    StringCopy (FullModulePath, ModulePath);
}

PMODULEDATA
pGetModuleData (
    IN      PCTSTR ModulePath
    )
{
    HASHITEM rc;
    PMODULEDATA moduleData;

    rc = HtFindStringEx (
            g_ModuleTable,
            ModulePath,
            &moduleData,
            FALSE
            );

    if (!rc) {
        return NULL;
    }

    return moduleData;
}

BOOL
pRegisterModule (
    IN      PCTSTR ModulePath,
    IN      HMODULE ModuleHandle
    )
{
    PMODULEDATA moduleData;
    PMODULEINITIALIZE moduleInitialize = NULL;
    BOOL result = TRUE;

    moduleData = pGetModuleData (ModulePath);
    if (moduleData) {
        if (moduleData->RefCount == 0) {
            moduleData->Handle = ModuleHandle;
            // time to call the initialization routine
            moduleInitialize = (PMODULEINITIALIZE) GetProcAddress (moduleData->Handle, "ModuleInitialize");
            if (moduleInitialize) {
                result = moduleInitialize ();
            }
        }
        MYASSERT (moduleData->Handle == ModuleHandle);
        moduleData->RefCount ++;
    } else {
        moduleData = (PMODULEDATA) PmGetMemory (g_IsmUntrackedPool, sizeof (MODULEDATA));
        ZeroMemory (moduleData, sizeof (MODULEDATA));
        moduleData->RefCount = 1;
        moduleData->Handle = ModuleHandle;
        // time to call the initialization routine
        moduleInitialize = (PMODULEINITIALIZE) GetProcAddress (moduleData->Handle, "ModuleInitialize");
        if (moduleInitialize) {
            result = moduleInitialize ();
        }
        HtAddStringEx (g_ModuleTable, ModulePath, &moduleData, FALSE);
    }
    return TRUE;
}

BOOL
pUnregisterModule (
    IN      PCTSTR ModulePath
    )
{
    PMODULEDATA moduleData;
    PMODULETERMINATE moduleTerminate = NULL;

    moduleData = pGetModuleData (ModulePath);
    if (moduleData) {
        if (moduleData->RefCount) {
            moduleData->RefCount --;
            if (moduleData->RefCount == 0) {
                // time to call the termination routine
                moduleTerminate = (PMODULETERMINATE) GetProcAddress (moduleData->Handle, "ModuleTerminate");
                if (moduleTerminate) {
                    moduleTerminate ();
                }
                FreeLibrary (moduleData->Handle);
                moduleData->Handle = NULL;
            }
        } else {
            DEBUGMSG ((DBG_WHOOPS, "Too many UnregisterModule called for %s", ModulePath));
        }
    }
    return TRUE;
}

VOID
pFreeRegisteredModules (
    VOID
    )
{
    PMODULEDATA moduleData;
    PMODULETERMINATE moduleTerminate = NULL;
    HASHTABLE_ENUM e;

    if (g_ModuleTable) {
        if (EnumFirstHashTableString (&e, g_ModuleTable)) {
            do {
                moduleData = *((PMODULEDATA *) e.ExtraData);
                if (moduleData) {
                    if (moduleData->RefCount) {
                        DEBUGMSG ((DBG_WHOOPS, "Registered module was not unregistered."));
                        moduleData->RefCount = 0;
                        moduleTerminate = (PMODULETERMINATE) GetProcAddress (moduleData->Handle, "ModuleTerminate");
                        if (moduleTerminate) {
                            moduleTerminate ();
                        }
                        FreeLibrary (moduleData->Handle);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_ModuleTable);
        g_ModuleTable = NULL;
    }
}

BOOL
pRegisterEtm (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PETMDATA etmData;
    HASHITEM rc;
    PTYPEMODULE queryTypeModule;
    TYPE_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    rc = HtFindString (g_EtmTable, ModuleId);

    if (rc) {
        return FALSE;
    }

    etmData = (PETMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (ETMDATA));
    ZeroMemory (etmData, sizeof (ETMDATA));

    pFindModule (ModulePath, fullModulePath);
    etmData->EtmPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    etmData->LibHandle = LoadLibrary (fullModulePath);

    if (etmData->LibHandle) {

        queryTypeModule = (PTYPEMODULE) GetProcAddress (etmData->LibHandle, "TypeModule");

        if (queryTypeModule) {

            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryTypeModule (ModuleId, &entryPoints)) {

                etmData->EtmInitialize = entryPoints.EtmInitialize;
                etmData->EtmParse = entryPoints.EtmParse;
                etmData->EtmTerminate = entryPoints.EtmTerminate;
                etmData->EtmNewUserCreated = entryPoints.EtmNewUserCreated;

                if (etmData->EtmInitialize) {
                    etmData->ShouldBeCalled = TRUE;
                }
            } else {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_DLL_DOES_NOT_SUPPORT_TAG, fullModulePath, ModuleId));
            }
        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_ETM_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (etmData->ShouldBeCalled) {

        etmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_EtmTable, ModuleId, &etmData, FALSE);

        if (pRegisterModule (fullModulePath, etmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!etmData->EtmInitialize (Platform, g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                etmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            etmData->Initialized = TRUE;

        } else {

            etmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return etmData->ShouldBeCalled;
}


BOOL
pRegisterVcm (
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PVCMDATA vcmData;
    HASHITEM rc;
    PVIRTUALCOMPUTERMODULE queryEntryPoints;
    VIRTUAL_COMPUTER_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    pFindModule (ModulePath, fullModulePath);

    rc = HtFindString (g_VcmTable, ModuleId);

    if (rc) {
        return FALSE;
    }

    vcmData = (PVCMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (VCMDATA));
    ZeroMemory (vcmData, sizeof (VCMDATA));

    vcmData->VcmPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    vcmData->LibHandle = LoadLibrary (fullModulePath);

    if (vcmData->LibHandle) {

        queryEntryPoints = (PVIRTUALCOMPUTERMODULE) GetProcAddress (
                                                        vcmData->LibHandle,
                                                        "VirtualComputerModule"
                                                        );

        if (queryEntryPoints) {
            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryEntryPoints (ModuleId, &entryPoints)) {

                vcmData->VcmInitialize = entryPoints.VcmInitialize;
                vcmData->VcmParse = entryPoints.VcmParse;
                vcmData->VcmQueueEnumeration = entryPoints.VcmQueueEnumeration;
                vcmData->VcmQueueHighPriorityEnumeration = entryPoints.VcmQueueHighPriorityEnumeration;
                vcmData->VcmTerminate = entryPoints.VcmTerminate;

                if (vcmData->VcmInitialize && vcmData->VcmQueueEnumeration) {
                    vcmData->ShouldBeCalled = TRUE;
                }
            } else {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_DLL_DOES_NOT_SUPPORT_TAG, fullModulePath, ModuleId));
            }
        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_VCM_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (vcmData->ShouldBeCalled) {

        vcmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_VcmTable, ModuleId, &vcmData, FALSE);

        if (pRegisterModule (fullModulePath, vcmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!vcmData->VcmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                vcmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            vcmData->Initialized = TRUE;

        } else {

            vcmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return vcmData->ShouldBeCalled;
}


BOOL
pRegisterSm (
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PSGMDATA sgmData;
    PSAMDATA samData;
    HASHITEM rc;
    PSOURCEMODULE queryEntryPoints;
    SOURCE_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    pFindModule (ModulePath, fullModulePath);

    rc = HtFindString (g_SgmTable, ModuleId);

    if (!rc) {
        rc = HtFindString (g_SamTable, ModuleId);
    }

    if (rc) {
        return FALSE;
    }

    sgmData = (PSGMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (SGMDATA));
    ZeroMemory (sgmData, sizeof (SGMDATA));

    samData = (PSAMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (SAMDATA));
    ZeroMemory (samData, sizeof (SAMDATA));

    sgmData->SgmPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    sgmData->LibHandle = LoadLibrary (fullModulePath);

    samData->SamPath = sgmData->SgmPath;
    samData->LibHandle = sgmData->LibHandle;

    if (sgmData->LibHandle) {

        queryEntryPoints = (PSOURCEMODULE) GetProcAddress (sgmData->LibHandle, "SourceModule");

        if (queryEntryPoints) {

            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryEntryPoints (ModuleId, &entryPoints)) {

                sgmData->SgmInitialize = entryPoints.SgmInitialize;
                sgmData->SgmParse = entryPoints.SgmParse;
                sgmData->SgmQueueEnumeration = entryPoints.SgmQueueEnumeration;
                sgmData->SgmQueueHighPriorityEnumeration = entryPoints.SgmQueueHighPriorityEnumeration;
                sgmData->SgmTerminate = entryPoints.SgmTerminate;

                if (sgmData->SgmInitialize && sgmData->SgmQueueEnumeration) {
                    sgmData->ShouldBeCalled = TRUE;
                }

                samData->SamInitialize = entryPoints.SamInitialize;
                samData->SamExecute = entryPoints.SamExecute;
                samData->SamEstimateProgressBar = entryPoints.SamEstimateProgressBar;
                samData->SamTerminate = entryPoints.SamTerminate;

                if (samData->SamInitialize && samData->SamExecute) {
                    samData->ShouldBeCalled = TRUE;
                }
            } else {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_DLL_DOES_NOT_SUPPORT_TAG, fullModulePath, ModuleId));
            }
        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_SOURCE_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (sgmData->ShouldBeCalled) {

        sgmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_SgmTable, ModuleId, &sgmData, FALSE);

        if (pRegisterModule (fullModulePath, sgmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!sgmData->SgmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                sgmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            sgmData->Initialized = TRUE;

        } else {

            sgmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    if (samData->ShouldBeCalled) {

        samData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_SamTable, ModuleId, &samData, FALSE);

        if (pRegisterModule (fullModulePath, samData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!samData->SamInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                samData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            samData->Initialized = TRUE;

        } else {

            samData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return sgmData->ShouldBeCalled || samData->ShouldBeCalled;
}


BOOL
pRegisterDm (
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PDAMDATA damData;
    PDGMDATA dgmData;
    PCSMDATA csmData;
    POPMDATA opmData;
    HASHITEM rc;
    PDESTINATIONMODULE queryEntryPoints;
    DESTINATION_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    pFindModule (ModulePath, fullModulePath);

    rc = HtFindString (g_DgmTable, ModuleId);

    if (!rc) {
        rc = HtFindString (g_DamTable, ModuleId);
    }

    if (!rc) {
        rc = HtFindString (g_CsmTable, ModuleId);
    }

    if (!rc) {
        rc = HtFindString (g_OpmTable, ModuleId);
    }

    if (rc) {
        return FALSE;
    }

    dgmData = (PDGMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (DGMDATA));
    ZeroMemory (dgmData, sizeof (DGMDATA));

    dgmData->DgmPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    dgmData->LibHandle = LoadLibrary (fullModulePath);

    damData = (PDAMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (DAMDATA));
    ZeroMemory (damData, sizeof (DAMDATA));

    damData->DamPath = dgmData->DgmPath;
    damData->LibHandle = dgmData->LibHandle;

    csmData = (PCSMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (CSMDATA));
    ZeroMemory (csmData, sizeof (CSMDATA));

    csmData->CsmPath = dgmData->DgmPath;
    csmData->LibHandle = dgmData->LibHandle;

    opmData = (POPMDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (OPMDATA));
    ZeroMemory (opmData, sizeof (OPMDATA));

    opmData->OpmPath = dgmData->DgmPath;
    opmData->LibHandle = dgmData->LibHandle;

    if (dgmData->LibHandle) {

        queryEntryPoints = (PDESTINATIONMODULE) GetProcAddress (dgmData->LibHandle, "DestinationModule");

        if (queryEntryPoints) {

            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryEntryPoints (ModuleId, &entryPoints)) {

                dgmData->DgmInitialize = entryPoints.DgmInitialize;
                dgmData->DgmQueueEnumeration = entryPoints.DgmQueueEnumeration;
                dgmData->DgmQueueHighPriorityEnumeration = entryPoints.DgmQueueHighPriorityEnumeration;
                dgmData->DgmTerminate = entryPoints.DgmTerminate;

                if (dgmData->DgmInitialize && dgmData->DgmQueueEnumeration) {
                    dgmData->ShouldBeCalled = TRUE;
                }

                damData->DamInitialize = entryPoints.DamInitialize;
                damData->DamExecute = entryPoints.DamExecute;
                damData->DamEstimateProgressBar = entryPoints.DamEstimateProgressBar;
                damData->DamTerminate = entryPoints.DamTerminate;

                if (damData->DamInitialize && damData->DamExecute) {
                    damData->ShouldBeCalled = TRUE;
                }

                csmData->CsmInitialize = entryPoints.CsmInitialize;
                csmData->CsmExecute = entryPoints.CsmExecute;
                csmData->CsmEstimateProgressBar = entryPoints.CsmEstimateProgressBar;
                csmData->CsmTerminate = entryPoints.CsmTerminate;

                if (csmData->CsmInitialize && csmData->CsmExecute) {
                    csmData->ShouldBeCalled = TRUE;
                }

                opmData->OpmInitialize = entryPoints.OpmInitialize;
                opmData->OpmTerminate = entryPoints.OpmTerminate;

                if (opmData->OpmInitialize) {
                    opmData->ShouldBeCalled = TRUE;
                }
            }
        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_DEST_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (dgmData->ShouldBeCalled) {

        dgmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_DgmTable, ModuleId, &dgmData, FALSE);

        if (pRegisterModule (fullModulePath, dgmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!dgmData->DgmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                dgmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            dgmData->Initialized = TRUE;

        } else {

            dgmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    if (damData->ShouldBeCalled) {

        damData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_DamTable, ModuleId, &damData, FALSE);

        if (pRegisterModule (fullModulePath, damData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!damData->DamInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                damData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            damData->Initialized = TRUE;

        } else {

            damData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    if (csmData->ShouldBeCalled) {

        csmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_CsmTable, ModuleId, &csmData, FALSE);

        if (pRegisterModule (fullModulePath, csmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!csmData->CsmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                csmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            csmData->Initialized = TRUE;

        } else {

            csmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    if (opmData->ShouldBeCalled) {

        opmData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_OpmTable, ModuleId, &opmData, FALSE);

        if (pRegisterModule (fullModulePath, opmData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!opmData->OpmInitialize (g_LogCallback, Reserved)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                opmData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            opmData->Initialized = TRUE;

        } else {

            opmData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return dgmData->ShouldBeCalled ||
           damData->ShouldBeCalled ||
           csmData->ShouldBeCalled ||
           opmData->ShouldBeCalled;
}


BOOL
pRegisterTransport (
    IN      PCTSTR ModuleId,
    IN      PCTSTR ModulePath,
    IN      PVOID Reserved
    )
{
    PTRANSPORTDATA transportData;
    HASHITEM rc;
    PTRANSPORTMODULE queryEntryPoints;
    TRANSPORT_ENTRYPOINTS entryPoints;
    TCHAR fullModulePath[MAX_TCHAR_PATH];

    pFindModule (ModulePath, fullModulePath);

    rc = HtFindString (g_TransportTable, ModuleId);

    if (rc) {
        return FALSE;
    }

    transportData = (PTRANSPORTDATA) PmGetAlignedMemory (g_IsmUntrackedPool, sizeof (TRANSPORTDATA));
    ZeroMemory (transportData, sizeof (TRANSPORTDATA));

    transportData->TransportPath = PmDuplicateString (g_IsmUntrackedPool, fullModulePath);
    transportData->LibHandle = LoadLibrary (fullModulePath);

    if (transportData->LibHandle) {

        queryEntryPoints = (PTRANSPORTMODULE) GetProcAddress (transportData->LibHandle, "TransportModule");

        if (queryEntryPoints) {

            ZeroMemory (&entryPoints, sizeof (entryPoints));
            entryPoints.Version = ISM_VERSION;

            if (queryEntryPoints (ModuleId, &entryPoints)) {

                transportData->TransportInitialize = entryPoints.TransportInitialize;
                transportData->TransportTerminate = entryPoints.TransportTerminate;
                transportData->TransportQueryCapabilities = entryPoints.TransportQueryCapabilities;
                transportData->TransportSetStorage = entryPoints.TransportSetStorage;
                transportData->TransportResetStorage = entryPoints.TransportResetStorage;
                transportData->TransportSaveState = entryPoints.TransportSaveState;
                transportData->TransportResumeSaveState = entryPoints.TransportResumeSaveState;
                transportData->TransportBeginApply = entryPoints.TransportBeginApply;
                transportData->TransportResumeApply = entryPoints.TransportResumeApply;
                transportData->TransportAcquireObject = entryPoints.TransportAcquireObject;
                transportData->TransportReleaseObject = entryPoints.TransportReleaseObject;
                transportData->TransportEndApply = entryPoints.TransportEndApply;
                transportData->TransportEstimateProgressBar = entryPoints.TransportEstimateProgressBar;

                if (transportData->TransportInitialize &&
                    transportData->TransportTerminate &&
                    transportData->TransportQueryCapabilities &&
                    transportData->TransportSetStorage &&
                    transportData->TransportSaveState &&
                    transportData->TransportBeginApply &&
                    transportData->TransportAcquireObject &&
                    transportData->TransportReleaseObject &&
                    transportData->TransportEndApply
                    ) {
                    transportData->ShouldBeCalled = TRUE;
                }
            }

        } else {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_TRANS_ENTRYPOINT_MISSING, fullModulePath));
        }

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_LOADLIBRARY_FAILURE, ModuleId));
    }

    if (transportData->ShouldBeCalled) {

        transportData->Group = PmDuplicateString (g_IsmUntrackedPool, ModuleId);
        HtAddStringEx (g_TransportTable, ModuleId, &transportData, FALSE);

        if (pRegisterModule (fullModulePath, transportData->LibHandle)) {

            MYASSERT (!g_CurrentGroup);
            g_CurrentGroup = ModuleId;

            if (!transportData->TransportInitialize (g_LogCallback)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, ModuleId));
                transportData->ShouldBeCalled = FALSE;
            }

            g_CurrentGroup = NULL;

            transportData->Initialized = TRUE;

        } else {

            transportData->ShouldBeCalled = FALSE;
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULEINIT_FAILURE, ModuleId));

        }
    }

    return transportData->ShouldBeCalled;
}

VOID
pAllocModuleTables (
    VOID
    )
{
    if (!g_VcmTable) {
        g_VcmTable = HtAllocWithData (sizeof (PVCMDATA));
    }

    if (!g_SgmTable) {
        g_SgmTable = HtAllocWithData (sizeof (PSGMDATA));
    }

    if (!g_SamTable) {
        g_SamTable = HtAllocWithData (sizeof (PSAMDATA));
    }

    if (!g_DgmTable) {
        g_DgmTable = HtAllocWithData (sizeof (PDGMDATA));
    }

    if (!g_DamTable) {
        g_DamTable = HtAllocWithData (sizeof (PDAMDATA));
    }

    if (!g_CsmTable) {
        g_CsmTable = HtAllocWithData (sizeof (PCSMDATA));
    }

    if (!g_OpmTable) {
        g_OpmTable = HtAllocWithData (sizeof (POPMDATA));
    }
}

VOID
pFreeModuleTables (
    VOID
    )
{
    HASHTABLE_ENUM e;
    POPMDATA opmData;
    PCSMDATA csmData;
    PDAMDATA damData;
    PDGMDATA dgmData;
    PSAMDATA samData;
    PSGMDATA sgmData;
    PVCMDATA vcmData;

    if (g_OpmTable) {
        if (EnumFirstHashTableString (&e, g_OpmTable)) {
            do {
                opmData = *((POPMDATA *) e.ExtraData);
                if (opmData) {
                    if (opmData->Initialized && opmData->OpmTerminate) {
                        opmData->OpmTerminate ();
                    }
                    if (opmData->OpmPath) {
                        pUnregisterModule (opmData->OpmPath);
                        // opmData->OpmPath is owned by DGM
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_OpmTable);
        g_OpmTable = NULL;
    }
    if (g_CsmTable) {
        if (EnumFirstHashTableString (&e, g_CsmTable)) {
            do {
                csmData = *((PCSMDATA *) e.ExtraData);
                if (csmData) {
                    if (csmData->Initialized && csmData->CsmTerminate) {
                        csmData->CsmTerminate ();
                    }
                    if (csmData->CsmPath) {
                        pUnregisterModule (csmData->CsmPath);
                        // csmData->CsmPath is owned by DGM
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_CsmTable);
        g_CsmTable = NULL;
    }
    if (g_DamTable) {
        if (EnumFirstHashTableString (&e, g_DamTable)) {
            do {
                damData = *((PDAMDATA *) e.ExtraData);
                if (damData) {
                    if (damData->Initialized && damData->DamTerminate) {
                        damData->DamTerminate ();
                    }
                    if (damData->DamPath) {
                        pUnregisterModule (damData->DamPath);
                        // damData->DamPath is owned by DGM
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_DamTable);
        g_DamTable = NULL;
    }
    if (g_DgmTable) {
        if (EnumFirstHashTableString (&e, g_DgmTable)) {
            do {
                dgmData = *((PDGMDATA *) e.ExtraData);
                if (dgmData) {
                    if (dgmData->Initialized && dgmData->DgmTerminate) {
                        dgmData->DgmTerminate ();
                    }
                    if (dgmData->DgmPath) {
                        pUnregisterModule (dgmData->DgmPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_DgmTable);
        g_DgmTable = NULL;
    }
    if (g_SamTable) {
        if (EnumFirstHashTableString (&e, g_SamTable)) {
            do {
                samData = *((PSAMDATA *) e.ExtraData);
                if (samData) {
                    if (samData->Initialized && samData->SamTerminate) {
                        samData->SamTerminate ();
                    }
                    if (samData->SamPath) {
                        pUnregisterModule (samData->SamPath);
                        // samData->SamPath is owned by SGM
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_SamTable);
        g_SamTable = NULL;
    }
    if (g_SgmTable) {
        if (EnumFirstHashTableString (&e, g_SgmTable)) {
            do {
                sgmData = *((PSGMDATA *) e.ExtraData);
                if (sgmData) {
                    if (sgmData->Initialized && sgmData->SgmTerminate) {
                        sgmData->SgmTerminate ();
                    }
                    if (sgmData->SgmPath) {
                        pUnregisterModule (sgmData->SgmPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_SgmTable);
        g_SgmTable = NULL;
    }
    if (g_VcmTable) {
        if (EnumFirstHashTableString (&e, g_VcmTable)) {
            do {
                vcmData = *((PVCMDATA *) e.ExtraData);
                if (vcmData) {
                    if (vcmData->Initialized && vcmData->VcmTerminate) {
                        vcmData->VcmTerminate ();
                    }
                    if (vcmData->VcmPath) {
                        pUnregisterModule (vcmData->VcmPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_VcmTable);
        g_VcmTable = NULL;
    }
}

VOID
pFreeTransportTable (
    VOID
    )
{
    PTRANSPORTDATA transportData;
    HASHTABLE_ENUM e;

    if (g_TransportTable) {
        if (EnumFirstHashTableString (&e, g_TransportTable)) {
            do {
                transportData = *((PTRANSPORTDATA *) e.ExtraData);
                if (transportData) {
                    if (transportData->Initialized && transportData->TransportTerminate) {
                        transportData->TransportTerminate ();
                    }
                    if (transportData->TransportPath) {
                        pUnregisterModule (transportData->TransportPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_TransportTable);
        g_TransportTable = NULL;
    }
}


BOOL
ValidateModuleName (
    IN      PCTSTR ModuleName
    )
{
    if (StringIMatch (ModuleName, S_COMMON)) {
        return FALSE;
    }

    if (!IsValidCName (ModuleName)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
InitializeVcmModules (
    IN      PVOID Reserved
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR modulePath;
    PCTSTR moduleId;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PCTSTR sectionName;

    //
    // Initialize external modules
    //

    pAllocModuleTables();

    sectionName = TEXT("Virtual Computer Modules");

    if (InfFindFirstLine (g_IsmInf, sectionName, NULL, &is)) {

        do {

            //
            // A source gather module has an ID and module path
            //

            moduleId = InfGetStringField (&is, 0);
            modulePath = InfGetStringField (&is, 1);

            if (!ValidateModuleName (moduleId)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                continue;
            }

            if (moduleId && modulePath) {

                //
                // Register the VCM in an internal database
                //

                b = pRegisterVcm (moduleId, modulePath, Reserved);

                cancelled = CheckCancel();

                if (!b) {
                    if (cancelled) {
                        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                        break;
                    } else {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                    }
                }
            }

        } while (InfFindNextLine (&is));
    }

    if (cancelled) {
        return FALSE;
    }

    InfCleanUpInfStruct (&is);

    if (!b) {
        pFreeModuleTables();
    }

    return b;
}


BOOL
InitializeModules (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PVOID Reserved
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR modulePath;
    PCTSTR moduleId;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;

    __try {
        //
        // Initialize external modules
        //

        pAllocModuleTables();

        if (Platform == PLATFORM_SOURCE) {

            if (InfFindFirstLine (g_IsmInf, TEXT("Source Modules"), NULL, &is)) {

                do {

                    //
                    // A source gather module has an ID and module path
                    //

                    moduleId = InfGetStringField (&is, 0);
                    modulePath = InfGetStringField (&is, 1);

                    if (!ValidateModuleName (moduleId)) {
                        LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                        continue;
                    }

                    if (moduleId && modulePath) {

                        //
                        // Register the source module in an internal database
                        //

                        b = pRegisterSm (moduleId, modulePath, Reserved);

                        cancelled = CheckCancel();

                        if (!b) {
                            if (cancelled) {
                                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                                break;
                            } else {
                                LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                            }
                        }
                    }

                } while (InfFindNextLine (&is));
            }

            if (cancelled) {
                __leave;
            }

        } else if (g_IsmCurrentPlatform == PLATFORM_DESTINATION) {

            if (InfFindFirstLine (g_IsmInf, TEXT("Destination Modules"), NULL, &is)) {

                do {

                    //
                    // A destination module has an ID and module path
                    //

                    moduleId = InfGetStringField (&is, 0);
                    modulePath = InfGetStringField (&is, 1);

                    if (!ValidateModuleName (moduleId)) {
                        LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                        continue;
                    }

                    if (moduleId && modulePath) {

                        //
                        // Register the destination module in an internal database
                        //

                        b = pRegisterDm (moduleId, modulePath, Reserved);

                        cancelled = CheckCancel();

                        if (!b) {
                            if (cancelled) {
                                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                                break;
                            } else {
                                LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                            }
                        }
                    }

                } while (InfFindNextLine (&is));
            }

            if (cancelled) {
                __leave;
            }

        } else {
            DEBUGMSG ((DBG_ERROR, "InitializeModules: Unknown ISM current platform %d", g_IsmCurrentPlatform));
            cancelled = TRUE;
        }
    }
    __finally {
        if (cancelled) {
            pFreeModuleTables();
        }

        InfCleanUpInfStruct (&is);
    }

    return !cancelled;
}


VOID
TerminateModules (
    VOID
    )
{
    pFreeModuleTables();
}


BOOL
pStartEtmModules (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR modulePath;
    PCTSTR moduleId;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;

    MYASSERT (g_IsmInf != INVALID_HANDLE_VALUE);

    if (InfFindFirstLine (g_IsmInf, TEXT("Type Modules"), NULL, &is)) {

        do {
            //
            // An ETM has an ID and module path
            //

            moduleId = InfGetStringField (&is, 0);
            modulePath = InfGetStringField (&is, 1);

            if (!ValidateModuleName (moduleId)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                continue;
            }

            if (moduleId && modulePath) {

                //
                // Register the ETM in an internal database
                //

                b = pRegisterEtm (Platform, moduleId, modulePath, NULL);

                cancelled = CheckCancel();

                if (!b) {
                    if (cancelled) {
                        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                        break;
                    } else {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                    }
                }
            }
        } while (InfFindNextLine (&is));
    }

    if (cancelled) {
        return FALSE;
    }

#ifdef PRERELEASE
    //
    // If pre-release, read in the exclusions from exclude.inf
    //
    {
        TCHAR path[MAX_PATH];
        PTSTR p;
        HINF inf;
        MIG_OBJECTSTRINGHANDLE handle;
        MIG_OBJECTTYPEID typeId;
        PCTSTR data;
        PCTSTR leaf;

        GetWindowsDirectory (path, MAX_PATH);

        p = _tcschr (path, TEXT('\\'));
        StringCopy (_tcsinc (p), TEXT("exclude.inf"));

        inf = InfOpenInfFile (path);
        if (inf && inf != INVALID_HANDLE_VALUE) {

            if (InfFindFirstLine (inf, TEXT("Objects"), NULL, &is)) {
                do {
                    data = InfGetStringField (&is, 1);
                    if (!data) {
                        continue;
                    }

                    typeId = IsmGetObjectTypeId (data);
                    if (!typeId) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Invalid object exclusion type: %s", data));
                        continue;
                    }

                    data = InfGetStringField (&is, 2);
                    if (!data) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Missing node object in field 2"));
                        continue;
                    }

                    leaf = InfGetStringField (&is, 3);
                    if (!leaf) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Missing leaf object in field 3"));
                        continue;
                    }

                    handle = IsmCreateObjectHandle (data, leaf);
                    if (handle) {
                        IsmRegisterStaticExclusion (typeId, handle);
                        IsmDestroyObjectHandle (handle);
                    }

                } while (InfFindNextLine (&is));
            }

            if (InfFindFirstLine (inf, TEXT("Nodes"), NULL, &is)) {
                do {
                    data = InfGetStringField (&is, 1);
                    if (!data) {
                        continue;
                    }

                    typeId = IsmGetObjectTypeId (data);
                    if (!typeId) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Invalid node exclusion type: %s", data));
                        continue;
                    }

                    data = InfGetStringField (&is, 2);
                    if (!data) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Missing node object in field 2"));
                        continue;
                    }

                    handle = IsmCreateObjectHandle (data, NULL);
                    if (handle) {
                        IsmRegisterStaticExclusion (typeId, handle);
                        IsmDestroyObjectHandle (handle);
                    }

                } while (InfFindNextLine (&is));
            }

            if (InfFindFirstLine (inf, TEXT("Leaves"), NULL, &is)) {
                do {
                    data = InfGetStringField (&is, 1);
                    if (!data) {
                        continue;
                    }

                    typeId = IsmGetObjectTypeId (data);
                    if (!typeId) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Invalid leaf exclusion type: %s", data));
                        continue;
                    }

                    data = InfGetStringField (&is, 2);
                    if (!data) {
                        LOG ((LOG_ERROR, "EXCLUDE.INF: Missing leaf object in field 2"));
                        continue;
                    }

                    handle = IsmCreateObjectHandle (NULL, data);
                    if (handle) {
                        IsmRegisterStaticExclusion (typeId, handle);
                        IsmDestroyObjectHandle (handle);
                    }

                } while (InfFindNextLine (&is));
            }

            InfCleanUpInfStruct (&is);
            InfCloseInfFile (inf);
        }

    }

#endif

    InfCleanUpInfStruct (&is);

    if (!b) {
        pFreeEtmTable ();
    }

    return b;
}


VOID
pFreeEtmTable (
    VOID
    )
{
    PETMDATA etmData;
    HASHTABLE_ENUM e;

    if (g_EtmTable) {
        if (EnumFirstHashTableString (&e, g_EtmTable)) {
            do {
                etmData = *((PETMDATA *) e.ExtraData);
                if (etmData) {
                    if (etmData->Initialized && etmData->EtmTerminate) {
                        etmData->EtmTerminate ();
                    }
                    if (etmData->EtmPath) {
                        pUnregisterModule (etmData->EtmPath);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_EtmTable);
        g_EtmTable = NULL;
    }
}


BOOL
IsmStartEtmModules (
    VOID
    )
{
    BOOL result;

    if (CheckCancel ()) {
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    if (!g_ModuleTable) {
        g_ModuleTable = HtAllocWithData (sizeof (PMODULEDATA));
    }

    if (!g_EtmTable) {
        g_EtmTable = HtAllocWithData (sizeof (PETMDATA));
    }

    result = pStartEtmModules (g_IsmCurrentPlatform);

#ifdef PRERELEASE
    LoadCrashHooks ();
#endif

    g_ExecutionInProgress = FALSE;

    return result;
}


BOOL
BroadcastUserCreation (
    IN      PTEMPORARYPROFILE UserProfile
    )
{
    PETMDATA etmData;
    HASHTABLE_ENUM e;

    if (g_EtmTable) {
        if (EnumFirstHashTableString (&e, g_EtmTable)) {
            do {
                etmData = *((PETMDATA *) e.ExtraData);
                if (etmData) {
                    if (etmData->Initialized && etmData->EtmNewUserCreated) {
                        etmData->EtmNewUserCreated (
                            UserProfile->UserName,
                            UserProfile->DomainName,
                            UserProfile->UserProfileRoot,
                            UserProfile->UserSid
                            );
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
    }
    return TRUE;
}


VOID
TerminateProcessWideModules (
    VOID
    )
{
    //
    // Terminate the phase-specific modules
    //

    TerminateModules();

    //
    // Terminate the process-wide modules: ETMs, transports

    //
    // Terminate Etm modules table
    //
    pFreeEtmTable ();

    //
    // Terminate all transport modules
    //
    pFreeTransportTable ();

    //
    // Enumerate all registered modules and verify that RefCount is 0
    //
    pFreeRegisteredModules ();
}


BOOL
IsmStartTransport (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR modulePath;
    PCTSTR moduleId;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;

    if (CheckCancel ()) {
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    MYASSERT (g_IsmInf != INVALID_HANDLE_VALUE);

    if (InfFindFirstLine (g_IsmInf, TEXT("Transport Modules"), NULL, &is)) {

        do {

            //
            // A transport module has an ID and module path
            //

            moduleId = InfGetStringField (&is, 0);
            modulePath = InfGetStringField (&is, 1);

            if (!ValidateModuleName (moduleId)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_INVALID_ID, moduleId));
                continue;
            }

            if (moduleId && modulePath) {

                //
                // Register the transport in an internal database
                //

                b = pRegisterTransport (moduleId, modulePath, NULL);

                cancelled = CheckCancel();

                if (!b) {
                    if (cancelled) {
                        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_MODULE_RETURNED_FAILURE, moduleId));
                        break;
                    } else {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_IGNORE_MODULE, moduleId));
                    }
                }
            }

        } while (InfFindNextLine (&is));
    }

    if (!cancelled) {

        InfCleanUpInfStruct (&is);

        if (!b) {
            pFreeTransportTable ();
        }

    } else {
        b = FALSE;
    }

    g_ExecutionInProgress = FALSE;

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\ops.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ops.c

Abstract:

    Implements the operation interface for the ISM.  Operations are used to
    track changes to state.  An object can have any number of operations
    applied to it, as long as the combinations are legal. Each operation
    has an optional source and destination property per object.

Author:

    Jim Schmidt (jimschm) 01-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_OPS         "Ops"

//
// Strings
//

// None

//
// Constants
//

#define OP_HASH_BUCKETS         503

//
// Macros
//

// None

//
// Types
//

typedef struct {
    MIG_OPERATIONID OperationId;
    LONGLONG SrcData;
    LONGLONG DestData;
} OPERATION_PROPERTY_LINKAGE, *POPERATION_PROPERTY_LINKAGE;

typedef struct {
    PUINT LinkageList;
    UINT Count;
    UINT Index;
    POPERATION_PROPERTY_LINKAGE OpPropLinkList;
    UINT OpPropCount;
    GROWBUFFER SrcPropBuf;
    GROWBUFFER DestPropBuf;
    MIG_BLOB SrcData;
    MIG_BLOB DestData;
    BOOL ReturnAllPrivateOps;
} OBJECTOPERATION_HANDLE, *POBJECTOPERATION_HANDLE;

typedef struct {
    PUINT LinkageList;
    UINT Count;
    UINT Index;
    PCTSTR ObjectFromMemdb;
} OBJECTWITHOPERATION_HANDLE, *POBJECTWITHOPERATION_HANDLE;

typedef struct {
    POPMFILTERCALLBACK FilterCallbackHp;
    POPMFILTERCALLBACK FilterCallback;
    BOOL TreeFilterHp;
    BOOL TreeFilter;
    BOOL NoRestoreFilterHp;
    BOOL NoRestoreFilter;
    POPMAPPLYCALLBACK ApplyCallbackHp;
    POPMAPPLYCALLBACK ApplyCallback;
    UINT CombinationsCount;
    BOOL IgnoreCollision;
    MIG_OPERATIONID *Combinations;
} OPERATION_DATA, *POPERATION_DATA;

typedef struct TAG_OPERATION_DATA_ITEM {
    struct TAG_OPERATION_DATA_ITEM *NextBucketItem;
    MIG_OPERATIONID OperationId;
    POPERATION_DATA Data;
} OPERATION_DATA_ITEM, *POPERATION_DATA_ITEM;

typedef struct {
    MIG_OBJECTID ObjectId;
    PCMIG_BLOB SourceData;
    PCMIG_BLOB DestinationData;
    LONGLONG SourceDataOffset;
    LONGLONG DestinationDataOffset;
} SETOPERATIONARG, *PSETOPERATIONARG;

typedef struct {
    MIG_OBJECTID ObjectId;
    LONGLONG SourceDataOffset;
    LONGLONG DestinationDataOffset;
} SETOPERATIONARG2, *PSETOPERATIONARG2;

typedef struct TAG_GLOBALFILTER {

    struct TAG_GLOBALFILTER *Next, *Prev;
    UINT Priority;

    MIG_PLATFORMTYPEID Platform;
    MIG_OPERATIONID OperationId;
    POPMFILTERCALLBACK Callback;
    BOOL TreeFilter;
    BOOL NoRestoreFilter;

} GLOBALFILTER, *PGLOBALFILTER;

typedef struct TAG_GLOBALEDIT {

    struct TAG_GLOBALEDIT *Next, *Prev;
    UINT Priority;

    MIG_PLATFORMTYPEID Platform;
    MIG_OPERATIONID OperationId;
    POPMAPPLYCALLBACK Callback;

} GLOBALEDIT, *PGLOBALEDIT;

typedef struct TAG_GLOBALFILTERINDEX {
    struct TAG_GLOBALFILTERINDEX *Next;
    MIG_OBJECTTYPEID ObjectTypeId;

    // normal priority
    PGLOBALFILTER FilterFirstHead;
    PGLOBALFILTER FilterLastHead;
    PGLOBALEDIT EditFirstHead;
    PGLOBALEDIT EditLastHead;

    // high priority
    PGLOBALFILTER FilterFirstHeadHp;
    PGLOBALFILTER FilterLastHeadHp;
    PGLOBALEDIT EditFirstHeadHp;
    PGLOBALEDIT EditLastHeadHp;
} GLOBALFILTERINDEX, *PGLOBALFILTERINDEX;

//
// Globals
//

PMHANDLE g_OpPool;
OPERATION_DATA_ITEM g_OpHashTable[OP_HASH_BUCKETS];
PGLOBALFILTERINDEX g_FirstGlobalOperation;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

MIG_OPERATIONID
pRegisterOperation (
    IN      PCTSTR OperationName,
    IN      BOOL Private,
    IN      PCTSTR CurrentGroup
    );

//
// Macro expansion definition
//

// None

//
// Code
//

PCTSTR
pGetOpNameForDebug (
    IN      MIG_OPERATIONID OperationId
    )
{
    static TCHAR Name[256];

    if (!IsmGetOperationName (OperationId, Name, ARRAYSIZE(Name), NULL, NULL, NULL)) {
        StringCopy (Name, TEXT("<invalid operation>"));
    }

    return Name;
}


PCTSTR
pGetOpNameForDebug2 (
    IN      MIG_OPERATIONID OperationId
    )
{
    static TCHAR Name[256];

    if (!IsmGetOperationName (OperationId, Name, ARRAYSIZE(Name), NULL, NULL, NULL)) {
        StringCopy (Name, TEXT("<invalid operation>"));
    }

    return Name;
}


UINT
pComputeOperationHash (
    IN      MIG_OPERATIONID OperationId
    )
{
    return (UINT) OperationId % OP_HASH_BUCKETS;
}


POPERATION_DATA_ITEM
pFindOperationBucketItem (
    IN      MIG_OPERATIONID OperationId
    )
{
    UINT hash;
    POPERATION_DATA_ITEM item;

    hash = pComputeOperationHash (OperationId);

    item = &g_OpHashTable[hash];

    do {
        if (item->OperationId == OperationId) {
            return item;
        }

        item = item->NextBucketItem;

    } while (item);

    return NULL;
}


POPERATION_DATA_ITEM
pGetOperationBucketItem (
    IN      MIG_OPERATIONID OperationId
    )
{
    POPERATION_DATA_ITEM item;
    POPERATION_DATA_ITEM newItem;
    UINT hash;

    hash = pComputeOperationHash (OperationId);

    item = &g_OpHashTable[hash];

    if (item->OperationId) {
        //
        // Find the last bucket item, then allocate a new bucket item
        //

        while (item->NextBucketItem) {
            item = item->NextBucketItem;
        }

        newItem = (POPERATION_DATA_ITEM) PmGetMemory (g_OpPool, sizeof (OPERATION_DATA_ITEM));
        ZeroMemory (newItem, sizeof (OPERATION_DATA_ITEM));

        item->NextBucketItem = newItem;
        item = newItem;
    }

    item->OperationId = OperationId;
    item->Data = NULL;

    return item;
}


VOID
pUpdateOperationData (
    IN      MIG_OPERATIONID OperationId,
    IN      POPERATION_DATA Data
    )
{
    POPERATION_DATA_ITEM item;

    item = pFindOperationBucketItem (OperationId);
    MYASSERT (item);
    MYASSERT (item->Data);

    CopyMemory (item->Data, Data, sizeof (OPERATION_DATA));
}


BOOL
pGetOperationData (
    IN      MIG_OPERATIONID OperationId,
    OUT     POPERATION_DATA Data
    )
{
    POPERATION_DATA_ITEM item;

    item = pFindOperationBucketItem (OperationId);

    if (!item) {
        ZeroMemory (Data, sizeof (OPERATION_DATA));

        item = pGetOperationBucketItem (OperationId);
        MYASSERT (item);
        MYASSERT (!item->Data);

        item->Data = (POPERATION_DATA) PmDuplicateMemory (
                                            g_OpPool,
                                            (PBYTE) Data,
                                            sizeof (OPERATION_DATA)
                                            );
        return TRUE;
    }

    CopyMemory (Data, item->Data, sizeof (OPERATION_DATA));

    return TRUE;
}


VOID
pAddCombinationPair (
    IN      MIG_OPERATIONID OperationIdToChange,
    IN      MIG_OPERATIONID OperationIdForTheComboList
    )
{
    OPERATION_DATA data;

    //
    // If a data struct does not exist, create one
    //

    if (!pGetOperationData (OperationIdToChange, &data)) {
        return;
    }

    if (!data.Combinations) {

        data.Combinations = (MIG_OPERATIONID *) PmGetMemory (
                                                    g_OpPool,
                                                    sizeof (MIG_OPERATIONID)
                                                    );
        data.CombinationsCount = 0;

    } else {

        data.Combinations = (MIG_OPERATIONID *) PmGetMemory (
                                                    g_OpPool,
                                                    (data.CombinationsCount + 1) * sizeof (MIG_OPERATIONID)
                                                    );
    }

    MYASSERT (data.Combinations);

    data.Combinations[data.CombinationsCount] = OperationIdForTheComboList;
    data.CombinationsCount++;

    pUpdateOperationData (OperationIdToChange, &data);
}


BOOL
pTestOperationCombination (
    IN      MIG_OPERATIONID OperationId1,
    IN      MIG_OPERATIONID OperationId2,
    OUT     PBOOL IgnoreCollision
    )

/*++

Routine Description:

  pTestOperationCombination tests if two operations can be combined. The
  return result indicates if the combination is prohibited.

Arguments:

  OperationId1 - Specifies the first operation to test.  The ID must be
                 valid.

  OperationId2 - Specifies the second operation to test. This ID must also be
                 valid.

  IgnoreCollision - Receives that the collision is ignored

Return Value:

  TRUE if the combination is prohibited, or FALSE if it is allowed.

--*/

{
    POPERATION_DATA_ITEM item;
    POPERATION_DATA data;
    UINT u;

    item = pFindOperationBucketItem (OperationId1);
    if (!item) {
        return FALSE;
    }

    data = item->Data;
    if (!data) {
        return FALSE;
    }

    for (u = 0 ; u < data->CombinationsCount ; u++) {
        if (data->Combinations[u] == OperationId2) {
            if (IgnoreCollision) {
                *IgnoreCollision = data->IgnoreCollision;
            }
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
pIsOperationProhibitedOnObject (
    IN      MIG_OPERATIONID OperationIdToTest,
    IN      MIG_OBJECTID ObjectId,
    IN      BOOL NoDebugOutput
    )
{
    UINT count;
    UINT u;
    KEYHANDLE *list = NULL;
    BOOL result = TRUE;
    BOOL ignoreCollision;
    POPERATION_DATA_ITEM item;

    __try {

        //
        // First check if this operation is prohibited to be combined with another operation
        //

        item = pFindOperationBucketItem (OperationIdToTest);
        if (!item || !item->Data || !item->Data->CombinationsCount) {
            //
            // No prohibited pairs exist; return now
            //

            result = FALSE;
            __leave;
        }

        //
        // Now check each operation set on ObjectId against the prohibited ID list
        //

        list = MemDbGetDoubleLinkageArrayByKeyHandle (ObjectId, OPERATION_INDEX, &count);

        if (list) {
            count /= sizeof (KEYHANDLE);

            for (u = 0 ; u < count ; u++) {

                if ((MIG_OPERATIONID) list[u] == OperationIdToTest) {
                    DEBUGMSG ((
                        DBG_VERBOSE,
                        "Operation %s already set on object %s; ignoring subsequent set",
                        pGetOpNameForDebug (OperationIdToTest),
                        GetObjectNameForDebugMsg (ObjectId)
                        ));
                    __leave;
                }

                if (pTestOperationCombination (OperationIdToTest, (MIG_OPERATIONID) list[u], &ignoreCollision)) {
                    if (!ignoreCollision &&
                        !NoDebugOutput) {
                        DEBUGMSG ((
                            DBG_ERROR,
                            "Can't set operation %s because it conflicts with %s",
                            pGetOpNameForDebug (OperationIdToTest),
                            pGetOpNameForDebug2 ((MIG_OPERATIONID) list[u])
                            ));
                    }
                    __leave;
                }
            }
        }

        //
        // All operations set on ObjectId are allowed to be combined with OperationIdToTest
        //

        result = FALSE;
    }
    __finally {
        if (list) {
            MemDbReleaseMemory (list);
            INVALID_POINTER (list);
        }
    }

    return result;
}


PCTSTR
pOperationPathFromId (
    IN      MIG_OPERATIONID OperationId
    )
{
    return MemDbGetKeyFromHandle ((UINT) OperationId, 0);
}


VOID
pOperationPathFromName (
    IN      PCTSTR OperationName,
    OUT     PTSTR Path
    )
{
    wsprintf (Path, TEXT("Op\\%s"), OperationName);
}


LONGLONG
pGetOffsetFromDataHandle (
    IN      MIG_DATAHANDLE DataHandle
    )
{
    if (!DataHandle) {
        return 0;
    }

    return OffsetFromPropertyDataId ((MIG_PROPERTYDATAID) DataHandle);
}


BOOL
pAddProhibitedCombinations (
    IN      PCTSTR InfSection
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    BOOL b = FALSE;
    PCTSTR mainOp;
    PCTSTR mainOpModule;
    PCTSTR combinationOp;
    PCTSTR combinationOpModule;
    UINT u;
    MIG_OPERATIONID mainOpId;
    MIG_OPERATIONID combinationOpId;
    PTSTR p;

    //
    // The INF tells us about prohibited operation combinations.  Given a
    // specific operation ID, we need to be able to tell if it can be
    // combined with another id.
    //

    __try {
        if (InfFindFirstLine (g_IsmInf, InfSection, NULL, &is)) {
            do {

                mainOp = InfGetStringField (&is, 1);

                if (!mainOp) {
                    continue;
                }

                p = _tcschr (mainOp, TEXT(':'));

                if (p) {
                    mainOpModule = mainOp;
                    *p = 0;
                    mainOp = p + 1;

                    if (!ValidateModuleName (mainOpModule)) {
                        LOG ((
                            LOG_WARNING,
                            (PCSTR) MSG_INVALID_ID_OPS,
                            mainOpModule,
                            InfSection,
                            is.Context.Line + 1
                            ));
                        continue;
                    }

                } else {
                    mainOpModule = NULL;
                }

                mainOpId = pRegisterOperation (mainOp, mainOpModule != NULL, mainOpModule);

                if (!mainOpId) {
                    LOG ((
                        LOG_WARNING,
                        (PCSTR) MSG_ISM_INF_SYNTAX_ERROR,
                        InfSection,
                        is.Context.Line + 1
                        ));
                    continue;
                }

                u = 2;
                for (;; u++) {
                    combinationOp = InfGetStringField (&is, u);
                    if (!combinationOp) {
                        break;
                    }

                    p = _tcschr (combinationOp, TEXT(':'));

                    if (p) {
                        combinationOpModule = combinationOp;
                        *p = 0;
                        combinationOp = p + 1;

                        if (!ValidateModuleName (combinationOpModule)) {
                            LOG ((
                                LOG_WARNING,
                                (PCSTR) MSG_INVALID_ID_OPS,
                                combinationOpModule,
                                InfSection,
                                is.Context.Line + 1
                                ));
                            continue;
                        }

                    } else {
                        combinationOpModule = NULL;
                    }

                    combinationOpId = pRegisterOperation (
                                            combinationOp,
                                            combinationOpModule != NULL,
                                            combinationOpModule
                                            );

                    if (!combinationOpId) {
                        LOG ((
                            LOG_WARNING,
                            (PCSTR) MSG_ISM_INF_SYNTAX_ERROR,
                            InfSection,
                            is.Context.Line + 1
                            ));
                        continue;
                    }

                    pAddCombinationPair (mainOpId, combinationOpId);
                    pAddCombinationPair (combinationOpId, mainOpId);
                }

            } while (InfFindNextLine (&is));
        }

        b = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (&is);
    }

    return b;
}


VOID
pAddIgnoredCollision (
    IN      MIG_OPERATIONID OperationIdToChange
    )
{
    OPERATION_DATA data;

    //
    // If a data struct does not exist, create one
    //

    if (!pGetOperationData (OperationIdToChange, &data)) {
        return;
    }

    data.IgnoreCollision = TRUE;

    pUpdateOperationData (OperationIdToChange, &data);
}


BOOL
pAddIgnoredCollisions (
    IN      PCTSTR InfSection
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    BOOL b = FALSE;
    PCTSTR mainOp;
    PCTSTR mainOpModule;
    MIG_OPERATIONID mainOpId;
    PTSTR p;

    //
    // The INF tells us about ignored operation collisions.
    //

    __try {
        if (InfFindFirstLine (g_IsmInf, InfSection, NULL, &is)) {
            do {

                mainOp = InfGetStringField (&is, 1);

                if (!mainOp) {
                    continue;
                }

                p = _tcschr (mainOp, TEXT(':'));

                if (p) {
                    mainOpModule = mainOp;
                    *p = 0;
                    mainOp = p + 1;

                    if (!ValidateModuleName (mainOpModule)) {
                        LOG ((
                            LOG_WARNING,
                            (PCSTR) MSG_INVALID_ID_OPS,
                            mainOpModule,
                            InfSection,
                            is.Context.Line + 1
                            ));
                        continue;
                    }

                } else {
                    mainOpModule = NULL;
                }

                mainOpId = pRegisterOperation (mainOp, mainOpModule != NULL, mainOpModule);

                if (!mainOpId) {
                    LOG ((
                        LOG_WARNING,
                        (PCSTR) MSG_ISM_INF_SYNTAX_ERROR,
                        InfSection,
                        is.Context.Line + 1
                        ));
                    continue;
                }

                pAddIgnoredCollision (mainOpId);

            } while (InfFindNextLine (&is));
        }

        b = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (&is);
    }

    return b;
}


BOOL
InitializeOperations (
    VOID
    )
{
    //
    // The INF tells us about prohibited operation combinations.  Given a
    // specific operation ID, we need to be able to tell if it can be
    // combined with another id.
    //

    g_OpPool = PmCreateNamedPool ("Operation Data");

    if (!pAddIgnoredCollisions (S_IGNORED_COLLISIONS)) {
        return FALSE;
    }

    return pAddProhibitedCombinations (S_PROHIBITED_COMBINATIONS);
}


VOID
TerminateOperations (
    VOID
    )
{
    if (g_OpPool) {
        PmEmptyPool (g_OpPool);
        PmDestroyPool (g_OpPool);
        g_OpPool = NULL;
    }
    ZeroMemory (&g_OpHashTable, sizeof (g_OpHashTable));
}


MIG_OPERATIONID
pRegisterOperation (
    IN      PCTSTR OperationName,
    IN      BOOL Private,
    IN      PCTSTR CurrentGroup
    )

{
    TCHAR operationPath[MEMDB_MAX];
    TCHAR decoratedName[MEMDB_MAX];
    UINT offset;

    if (!IsValidCNameWithDots (OperationName)) {
        DEBUGMSG ((DBG_ERROR, "operation name \"%s\" is illegal", OperationName));
        return FALSE;
    }

#ifdef DEBUG
    if (Private && !IsValidCName (CurrentGroup)) {
        DEBUGMSG ((DBG_ERROR, "group name \"%s\" is illegal", CurrentGroup));
        return FALSE;
    }
#endif

    if (Private) {
        wsprintf (decoratedName, TEXT("%s:%s"), CurrentGroup, OperationName);
    } else {
        wsprintf (decoratedName, S_COMMON TEXT(":%s"), OperationName);
    }

    pOperationPathFromName (decoratedName, operationPath);

    if (!MarkGroupIds (operationPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered operation",
            operationPath
            ));
        return FALSE;
    }

    offset = MemDbSetKey (operationPath);

    if (!offset) {
        EngineError ();
        return 0;
    }

    return (MIG_OPERATIONID) offset;
}


MIG_OPERATIONID
IsmRegisterOperation (
    IN      PCTSTR OperationName,
    IN      BOOL Private
    )

/*++

Routine Description:

  IsmRegisterOperation creates a public or private Operation and returns the
  ID to the caller. If the Operation already exists, then the existing ID is
  returned to the caller.

Arguments:

  OperationName - Specifies the operation name to register.
  Private       - Specifies TRUE if the operation is owned by the calling module
                  only, or FALSE if it is shared by all modules. If TRUE is
                  specified, the caller must be in an ISM callback function.

Return Value:

  The ID of the operation, or 0 if the registration failed.

--*/

{
    if (!g_CurrentGroup && Private) {
        DEBUGMSG ((DBG_ERROR, "IsmRegisterOperation called for private operation outside of ISM-managed context"));
        return 0;
    }

    return pRegisterOperation (OperationName, Private, g_CurrentGroup);
}


MIG_OPERATIONID
IsmGetOperationGroup (
    IN      MIG_OPERATIONID OperationId
    )
{
    return (MIG_OPERATIONID) GetGroupOfId ((KEYHANDLE) OperationId);
}


PGLOBALFILTERINDEX
pGetGlobalIndex (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      BOOL Create
    )
{
    PGLOBALFILTERINDEX index;

    ObjectTypeId &= (~PLATFORM_MASK);

    index = g_FirstGlobalOperation;
    while (index) {
        if (index->ObjectTypeId == ObjectTypeId) {
            break;
        }

        index = index->Next;
    }

    if (!index && Create) {
        index = (PGLOBALFILTERINDEX) PmGetMemory (g_IsmUntrackedPool, sizeof (GLOBALFILTERINDEX));

        ZeroMemory (index, sizeof (GLOBALFILTERINDEX));

        index->Next = g_FirstGlobalOperation;
        index->ObjectTypeId = ObjectTypeId;

        g_FirstGlobalOperation = index;
    }

    return index;
}


BOOL
IsmRegisterGlobalFilterCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR FunctionId,
    IN      POPMFILTERCALLBACK Callback,
    IN      BOOL TreeFilter,
    IN      BOOL CanHandleNoRestore
    )

/*++

Routine Description:

  IsmRegisterGlobalFilterCallback adds a filter to the "global" filter list.
  Functions are prioritized by the ism.inf section [Global Filters]. If a
  function is not listed, or if no name is given, it has the lowest priority.
  In addition, global filters can be prohibited from being processed with
  another non-global filter through the [Prohibit Operation Combination]
  section of ism.inf.

Arguments:

  ObjectTypeId - Specifies the type of the object

  FunctionId - Specifies the text name of the callback function, for purposes
               of prioritizing and combination management

  Callback - Specifies the function address to call

  TreeFilter - Specifies TRUE if the callback potentially modifies a portion
               of an object's node, or FALSE if it modifies the node completely
               or doesn't modify the node at all

Return Value:

  TRUE on success, FALSE on failure

--*/

{
    PGLOBALFILTERINDEX index;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PGLOBALFILTER filter;
    PGLOBALFILTER *head;
    PGLOBALFILTER insertAt;

    if (!FunctionId) {
        DEBUGMSG ((DBG_ERROR, "All global filters must have a text function ID"));
        return FALSE;
    }

    //
    // Locate the index for our type
    //

    index = pGetGlobalIndex (ObjectTypeId, TRUE);

    //
    // Allocate a new filter node
    //

    filter = (PGLOBALFILTER) PmGetMemory (g_IsmUntrackedPool, sizeof (GLOBALFILTER));
    filter->Platform = ObjectTypeId & PLATFORM_MASK;
    filter->OperationId = IsmRegisterOperation (FunctionId, FALSE);
    filter->TreeFilter = TreeFilter;
    filter->Callback = Callback;
    filter->NoRestoreFilter = CanHandleNoRestore;

    //
    // Insert the node into the list by priority
    //

    if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Filter First"), FunctionId, &is)) {

        filter->Priority = is.Context.Line;
        head = &index->FilterFirstHead;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Filter Last"), FunctionId, &is)) {

        filter->Priority = is.Context.Line;
        head = &index->FilterLastHead;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Filter First.High Priority"), FunctionId, &is)) {

        filter->Priority = is.Context.Line;
        head = &index->FilterFirstHeadHp;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Filter Last.High Priority"), FunctionId, &is)) {

        filter->Priority = is.Context.Line;
        head = &index->FilterLastHead;

    } else {

        filter->Priority = 0xFFFFFFFF;
        head = &index->FilterLastHead;
    }

    insertAt = *head;

    while (insertAt) {
        if (insertAt->Priority >= filter->Priority) {
            insertAt = insertAt->Prev;
            break;
        }

        insertAt = insertAt->Next;
    }

    if (insertAt) {
        filter->Next = insertAt->Next;
        insertAt->Next = filter;

        if (filter->Next) {
            filter->Next->Prev = filter;
        }
    } else {
        *head = filter;
        filter->Next = NULL;
    }

    filter->Prev = insertAt;

    InfCleanUpInfStruct (&is);

    return TRUE;
}


BOOL
IsmRegisterOperationFilterCallback (
    IN      MIG_OPERATIONID OperationId,
    IN      POPMFILTERCALLBACK Callback,
    IN      BOOL TreeFilter,
    IN      BOOL HighPriority,
    IN      BOOL CanHandleNoRestore
    )
{
    OPERATION_DATA data;

    //
    // If a data struct does not exist, create one
    //

    if (!pGetOperationData (OperationId, &data)) {
        return FALSE;
    }

    if (HighPriority) {

        if (data.FilterCallbackHp) {
            DEBUGMSG ((DBG_ERROR, "High Priority Filter Callback for operation 0x%08X already registered", OperationId));
            return FALSE;
        }

        data.FilterCallbackHp = Callback;
        data.TreeFilterHp = TreeFilter;
        data.NoRestoreFilterHp = CanHandleNoRestore;

    } else {

        if (data.FilterCallback) {
            DEBUGMSG ((DBG_ERROR, "Filter Callback for operation 0x%08X already registered", OperationId));
            return FALSE;
        }

        data.FilterCallback = Callback;
        data.TreeFilter = TreeFilter;
        data.NoRestoreFilter = CanHandleNoRestore;

    }

    pUpdateOperationData (OperationId, &data);

    return TRUE;
}


BOOL
WINAPI
IsmRegisterGlobalApplyCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR FunctionId,
    IN      POPMAPPLYCALLBACK Callback
    )
{
    PGLOBALFILTERINDEX index;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PGLOBALEDIT editFn;
    PGLOBALEDIT *head;
    PGLOBALEDIT insertAt;

    if (!FunctionId) {
        DEBUGMSG ((DBG_ERROR, "All global content editor callbacks must have a text function ID"));
        return FALSE;
    }

    //
    // Locate the index for our type
    //

    index = pGetGlobalIndex (ObjectTypeId, TRUE);

    //
    // Allocate a new content edit node
    //

    editFn = (PGLOBALEDIT) PmGetMemory (g_IsmUntrackedPool, sizeof (GLOBALEDIT));
    editFn->Platform = ObjectTypeId & PLATFORM_MASK;
    editFn->OperationId = IsmRegisterOperation (FunctionId, FALSE);
    editFn->Callback = Callback;

    //
    // Insert the node into the list by priority
    //

    if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Apply First"), FunctionId, &is)) {

        editFn->Priority = is.Context.Line;
        head = &index->EditFirstHead;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Apply Last"), FunctionId, &is)) {

        editFn->Priority = is.Context.Line;
        head = &index->EditLastHead;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Apply First.High Priority"), FunctionId, &is)) {

        editFn->Priority = is.Context.Line;
        head = &index->EditFirstHeadHp;

    } else if (InfFindFirstLine (g_IsmInf, TEXT("Global Operations.Apply Last.High Priority"), FunctionId, &is)) {

        editFn->Priority = is.Context.Line;
        head = &index->EditLastHead;

    } else {

        editFn->Priority = 0xFFFFFFFF;
        head = &index->EditLastHead;
    }

    insertAt = *head;

    while (insertAt) {
        if (insertAt->Priority >= editFn->Priority) {
            insertAt = insertAt->Prev;
            break;
        }

        insertAt = insertAt->Next;
    }

    if (insertAt) {
        editFn->Next = insertAt->Next;
        insertAt->Next = editFn;

        if (editFn->Next) {
            editFn->Next->Prev = editFn;
        }
    } else {
        *head = editFn;
        editFn->Next = NULL;
    }

    editFn->Prev = insertAt;

    InfCleanUpInfStruct (&is);

    return TRUE;
}


BOOL
IsmRegisterOperationApplyCallback (
    IN      MIG_OPERATIONID OperationId,
    IN      POPMAPPLYCALLBACK Callback,
    IN      BOOL HighPriority
    )
{
    OPERATION_DATA data;

    //
    // If a data struct does not exist, create one
    //

    if (!pGetOperationData (OperationId, &data)) {
        return FALSE;
    }

    if (HighPriority) {
        if (data.ApplyCallbackHp) {
            DEBUGMSG ((
                DBG_ERROR,
                "High Priority Apply Callback for operation %s already registered",
                pGetOpNameForDebug (OperationId)
                ));
            return FALSE;
        }

        data.ApplyCallbackHp = Callback;

    } else {
        if (data.ApplyCallback) {
            DEBUGMSG ((
                DBG_ERROR,
                "Apply Callback for operation %s already registered",
                pGetOpNameForDebug (OperationId)
                ));
            return FALSE;
        }

        data.ApplyCallback = Callback;
    }

    pUpdateOperationData (OperationId, &data);

    return TRUE;
}

BOOL
pGetOperationName (
    IN      MIG_OPERATIONID OperationId,
    OUT     PTSTR OperationName,            OPTIONAL
    IN      UINT OperationNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences,         OPTIONAL
    IN      BOOL ReturnAllPrivateOps
    )

/*++

Routine Description:

  pGetOperationName obtains the operation text name from a numeric ID. It
  also identifies private and owned operations.

Arguments:

  OperationId           - Specifies the operation ID to look up.
  OperationName         - Receives the operation name. The name is filled for
                          all valid OperationId values, even when the return
                          value is FALSE.
  OperationNameBufChars - Specifies the number of TCHARs that OperationName
                          can hold, including the nul terminator.
  Private               - Receives TRUE if the operation is private, or FALSE
                          if it is public.
  BelongsToMe           - Receives TRUE if the operation is private and
                          belongs to the caller, FALSE otherwise.
  ObjectReferences      - Receives the number of objects that reference the
                          operation

Return Value:

  TRUE if the operation is public, or if the operation is private and belongs to
  the caller.

  FALSE if the operation is private and belongs to someone else. OperationName,
  Private and BelongsToMe are valid in this case.

  FALSE if OperationId is not valid. Operationname, Private and BelongsToMe are
  not modified in this case.  Do not use this function to test if OperationId
  is valid or not.

--*/


  {
    PCTSTR operationPath = NULL;
    PCTSTR start;
    PTSTR p, q;
    BOOL privateOperation = FALSE;
    BOOL groupMatch = FALSE;
    BOOL result = FALSE;
    UINT references;
    PUINT linkageList;

    __try {
        //
        // Did caller specify an item id?
        //

        if (!IsItemId ((KEYHANDLE) OperationId)) {
            DEBUGMSG ((
                DBG_ERROR,
                "IsmGetOperationName: must specify item id, not group id"
                ));
            __leave;
        }

        //
        // Get the operation path from memdb, then parse it for group and name
        //

        operationPath = pOperationPathFromId (OperationId);
        if (!operationPath) {
            __leave;
        }

        p = _tcschr (operationPath, TEXT('\\'));
        if (!p) {
            __leave;
        }

        start = _tcsinc (p);
        p = _tcschr (start, TEXT(':'));

        if (!p) {
            __leave;
        }

        q = _tcsinc (p);
        *p = 0;

        if (StringIMatch (start, S_COMMON)) {

            //
            // This operation is a global operation.
            //

            privateOperation = FALSE;
            groupMatch = TRUE;

        } else if (g_CurrentGroup || ReturnAllPrivateOps) {

            //
            // This operation is private. Check if it is ours.
            //

            privateOperation = TRUE;

            if (g_CurrentGroup && StringIMatch (start, g_CurrentGroup)) {
                groupMatch = TRUE;
            } else {
                groupMatch = ReturnAllPrivateOps;
            }
        } else {

            //
            // This is a private operation, but the caller is not
            // a module that can own operations.
            //

            DEBUGMSG ((DBG_WARNING, "IsmGetOperationName: Caller cannot own private operations"));
        }

        //
        // Copy the name to the buffer, update outbound BOOLs, set result
        //

        if (OperationName && OperationNameBufChars >= sizeof (TCHAR)) {
            StringCopyByteCount (OperationName, q, OperationNameBufChars * sizeof (TCHAR));
        }

        if (Private) {
            *Private = privateOperation;
        }

        if (BelongsToMe) {
            *BelongsToMe = privateOperation && groupMatch;
        }

        if (ObjectReferences) {
            linkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                OperationId,
                                OPERATION_INDEX,
                                &references
                                );

            references /= SIZEOF(KEYHANDLE);

            if (linkageList) {
                MemDbReleaseMemory (linkageList);
                INVALID_POINTER (linkageList);
            } else {
                references = 0;
            }

            *ObjectReferences = references;
        }

        if (groupMatch) {
            result = TRUE;
        }
    }
    __finally {
        if (operationPath) {       //lint !e774
            MemDbReleaseMemory (operationPath);
            operationPath = NULL;
        }
    }
    return result;
}


BOOL
IsmGetOperationName (
    IN      MIG_OPERATIONID OperationId,
    OUT     PTSTR OperationName,            OPTIONAL
    IN      UINT OperationNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    )
{
    return pGetOperationName (
                OperationId,
                OperationName,
                OperationNameBufChars,
                Private,
                BelongsToMe,
                ObjectReferences,
                FALSE
                );
}

POPERATION_PROPERTY_LINKAGE
pFindOperationPropertyLinkage (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationIdToFind,
    OUT     PBYTE *BlockToFree,
    OUT     PUINT BlockSize
    )
{
    POPERATION_PROPERTY_LINKAGE linkage;
    UINT linkageCount;
    POPERATION_PROPERTY_LINKAGE result = NULL;
    UINT u;

    __try {
        linkage = (POPERATION_PROPERTY_LINKAGE) MemDbGetUnorderedBlobByKeyHandle (
                                                    ObjectId,
                                                    OPERATION_INDEX,
                                                    BlockSize
                                                    );

        linkageCount = *BlockSize / sizeof (OPERATION_PROPERTY_LINKAGE);

        if (!linkage || !linkageCount) {
            __leave;
        }

        for (u = 0 ; u < linkageCount ; u++) {

            if (linkage[u].OperationId == OperationIdToFind) {
                result = linkage + u;
                break;
            }

        }
    }
    __finally {
        if (!result && linkage) {
            MemDbReleaseMemory (linkage);
            INVALID_POINTER (linkage);
        } else {
            *BlockToFree = (PBYTE) linkage;
        }
    }

    return result;
}


BOOL
pSetOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData,     OPTIONAL
    IN      BOOL QueryOnly,
    IN OUT  PLONGLONG SourceDataOffset,         OPTIONAL
    IN OUT  PLONGLONG DestinationDataOffset     OPTIONAL
    )
{
    BOOL result = FALSE;
    OPERATION_PROPERTY_LINKAGE linkage;
    POPERATION_PROPERTY_LINKAGE reuseLinkage;
    PBYTE freeMe;
    UINT linkageSize;
    KEYHANDLE *list = NULL;

    __try {
        //
        // Is the operation or object locked?
        //

        if (TestLock (ObjectId, (KEYHANDLE) OperationId)) {
            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't set operation %s on %s because of lock",
                pGetOpNameForDebug (OperationId),
                GetObjectNameForDebugMsg (ObjectId)
                ));
            __leave;
        }

        //
        // Does this operation conflict with itself or another operation?
        //

        if (pIsOperationProhibitedOnObject (OperationId, ObjectId, FALSE)) {
            __leave;
        }

        //
        // If query only, return success
        //

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        //
        // Add the operaiton.  First, store the properties in property.dat
        //

        ZeroMemory (&linkage, sizeof (linkage));

        if (SourceData || SourceDataOffset) {

            if (SourceDataOffset && *SourceDataOffset) {
                linkage.SrcData = *SourceDataOffset;
            } else {
                linkage.SrcData = AppendProperty (SourceData);

                if (!linkage.SrcData) {
                    DEBUGMSG ((DBG_ERROR, "Can't append src property"));
                    __leave;
                }

                if (SourceDataOffset) {
                    *SourceDataOffset = linkage.SrcData;
                }
            }
        }

        if (DestinationData || DestinationDataOffset) {

            if (DestinationDataOffset && *DestinationDataOffset) {
                linkage.DestData = *DestinationDataOffset;
            } else {
                linkage.DestData = AppendProperty (DestinationData);

                if (!linkage.DestData) {
                    DEBUGMSG ((DBG_ERROR, "Can't append dest property"));
                    __leave;
                }

                if (DestinationDataOffset) {
                    *DestinationDataOffset = linkage.DestData;
                }
            }
        }

        //
        // Establish linkage between the object, operation and properties
        //

        if (SourceData || SourceDataOffset ||
            DestinationData || DestinationDataOffset
            ) {

            linkage.OperationId = OperationId;

            reuseLinkage = pFindOperationPropertyLinkage (
                                ObjectId,
                                0,
                                &freeMe,
                                &linkageSize
                                );

            if (reuseLinkage) {
                //
                // Recovery case -- reuse an empty spot in the blob
                //

                CopyMemory (reuseLinkage, &linkage, sizeof (linkage));

                if (!MemDbSetUnorderedBlobByKeyHandle (
                        ObjectId,
                        OPERATION_INDEX,
                        freeMe,
                        linkageSize
                        )) {
                    DEBUGMSG ((DBG_ERROR, "Can't update unordered operation blob"));
                    __leave;
                }

                MemDbReleaseMemory (freeMe);
                INVALID_POINTER (freeMe);

            } else {
                //
                // New case -- add the struct to the end of the blob
                //

                if (!MemDbGrowUnorderedBlobByKeyHandle (
                            ObjectId,
                            OPERATION_INDEX,
                            (PBYTE) &linkage,
                            sizeof (linkage)
                            )) {

                    DEBUGMSG ((DBG_ERROR, "Can't grow operation property linkage"));
                    __leave;

                }
            }
        }

        if (!MemDbAddDoubleLinkageByKeyHandle (ObjectId, OperationId, OPERATION_INDEX)) {
            DEBUGMSG ((DBG_ERROR, "Can't link object to operation"));
            EngineError ();
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (list) {
            MemDbReleaseMemory (list);
            INVALID_POINTER (list);
        }
    }

    return result;
}


BOOL
pSetOperationGroup (
    IN      KEYHANDLE OperationId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    PSETOPERATIONARG myArg = (PSETOPERATIONARG) Arg;

    return pSetOperationOnObjectId (
                myArg->ObjectId,
                (MIG_OPERATIONID) OperationId,
                myArg->SourceData,
                myArg->DestinationData,
                FirstPass,
                &myArg->SourceDataOffset,
                &myArg->DestinationDataOffset
                );
}


BOOL
pSetOperationGroup2 (
    IN      KEYHANDLE OperationId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    PSETOPERATIONARG2 myArg = (PSETOPERATIONARG2) Arg;

    return pSetOperationOnObjectId (
                myArg->ObjectId,
                (MIG_OPERATIONID) OperationId,
                NULL,
                NULL,
                FirstPass,
                myArg->SourceDataOffset ? &myArg->SourceDataOffset : NULL,
                myArg->DestinationDataOffset ? &myArg->DestinationDataOffset : NULL
                );
}


BOOL
IsmSetOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData      OPTIONAL
    )
{
    RECURSERETURN rc;
    SETOPERATIONARG myArg;

    myArg.ObjectId = ObjectId;
    myArg.SourceData = SourceData;
    myArg.DestinationData = DestinationData;
    myArg.SourceDataOffset = 0;
    myArg.DestinationDataOffset = 0;

    rc = RecurseForGroupItems (
                OperationId,
                pSetOperationGroup,
                (ULONG_PTR) &myArg,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pSetOperationOnObjectId (
                ObjectId,
                OperationId,
                SourceData,
                DestinationData,
                FALSE,
                NULL,
                NULL
                );
}


BOOL
IsmSetOperationOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData      OPTIONAL
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmSetOperationOnObjectId (
                        objectId,
                        OperationId,
                        SourceData,
                        DestinationData
                        );
    }

    return result;
}


MIG_DATAHANDLE
IsmRegisterOperationData (
    IN      PCMIG_BLOB Data
    )
{
    return (MIG_DATAHANDLE) IsmRegisterPropertyData (Data);
}


BOOL
IsmSetOperationOnObjectId2 (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      MIG_DATAHANDLE SourceData,      OPTIONAL
    IN      MIG_DATAHANDLE DestinationData  OPTIONAL
    )
{
    RECURSERETURN rc;
    SETOPERATIONARG2 myArg;

    myArg.ObjectId = ObjectId;
    if (SourceData) {
        myArg.SourceDataOffset = pGetOffsetFromDataHandle (SourceData);
        if (!myArg.SourceDataOffset) {
            return FALSE;
        }
    } else {
        myArg.SourceDataOffset = 0;
    }

    if (DestinationData) {
        myArg.DestinationDataOffset = pGetOffsetFromDataHandle (DestinationData);
        if (!myArg.DestinationDataOffset) {
            return FALSE;
        }
    } else {
        myArg.DestinationDataOffset = 0;
    }

    rc = RecurseForGroupItems (
                OperationId,
                pSetOperationGroup2,
                (ULONG_PTR) &myArg,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pSetOperationOnObjectId (
                ObjectId,
                OperationId,
                NULL,
                NULL,
                FALSE,
                SourceData ? &myArg.SourceDataOffset : NULL,
                DestinationData ? &myArg.DestinationDataOffset : NULL
                );
}


BOOL
IsmSetOperationOnObject2 (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId,
    IN      MIG_DATAHANDLE SourceData,      OPTIONAL
    IN      MIG_DATAHANDLE DestinationData  OPTIONAL
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmSetOperationOnObjectId2 (
                        objectId,
                        OperationId,
                        SourceData,
                        DestinationData
                        );
    }

    return result;
}


VOID
IsmLockOperation (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    )
{
    LockHandle (ObjectId, (KEYHANDLE) OperationId);
}


BOOL
pClearOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      BOOL QueryOnly
    )
{
    BOOL result = FALSE;
    POPERATION_PROPERTY_LINKAGE linkage;
    PBYTE freeMe;
    UINT linkageSize;

    __try {
        //
        // Is the operation or object locked?
        //

        if (TestLock (ObjectId, (KEYHANDLE) OperationId)) {
            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't remove operation %s on %s because of lock",
                pGetOpNameForDebug (OperationId),
                GetObjectNameForDebugMsg (ObjectId)
                ));
            __leave;
        }

        //
        // If query only, return success
        //

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        //
        // Find the reference to this operation within the object's unordered blob
        //

        linkage = pFindOperationPropertyLinkage (
                        ObjectId,
                        OperationId,
                        &freeMe,
                        &linkageSize
                        );

        if (linkage) {
            ZeroMemory (linkage, sizeof (OPERATION_PROPERTY_LINKAGE));

            if (!MemDbSetUnorderedBlobByKeyHandle (
                    ObjectId,
                    OPERATION_INDEX,
                    freeMe,
                    linkageSize
                    )) {
                DEBUGMSG ((DBG_ERROR, "Can't reset unordered operation blob"));
                __leave;
            }

            MemDbReleaseMemory (freeMe);
            INVALID_POINTER (freeMe);
        }

        //
        // Remove object-to-operation linkage
        //

        result = MemDbDeleteDoubleLinkageByKeyHandle (
                    ObjectId,
                    OperationId,
                    OPERATION_INDEX
                    );
    }
    __finally {
    }

    return result;
}


BOOL
pClearOperationGroup (
    IN      KEYHANDLE OperationId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pClearOperationOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_OPERATIONID) OperationId,
                FirstPass
                );
}


BOOL
IsmClearOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    )
{
    RECURSERETURN rc;

    //
    // If OperationId is a group, remove all operations in the group
    //

    rc = RecurseForGroupItems (
                OperationId,
                pClearOperationGroup,
                (ULONG_PTR) ObjectId,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pClearOperationOnObjectId (ObjectId, OperationId, FALSE);
}


BOOL
IsmClearOperationOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearOperationOnObjectId (objectId, OperationId);
    }

    return result;
}


BOOL
pIsOperationSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    )
{
    PCTSTR groupKey;
    PCTSTR enumKey = NULL;
    BOOL result = FALSE;
    BOOL done = FALSE;
    MEMDB_ENUM e;

    __try {
        //
        // Did caller specify an item id?
        //

        if (!IsItemId ((KEYHANDLE) OperationId)) {
            if (IsGroupId ((KEYHANDLE) OperationId)) {

                groupKey = MemDbGetKeyFromHandle (OperationId, 0);
                enumKey = JoinText (groupKey, TEXT(".*"));
                MemDbReleaseMemory (groupKey);

                //
                // Enumerate all operations (skip operation subgroups)
                //

                if (MemDbEnumFirst (
                        &e,
                        enumKey,
                        ENUMFLAG_NORMAL,
                        ENUMLEVEL_ALLLEVELS,
                        ENUMLEVEL_ALLLEVELS
                        )) {

                    do {
                        if (IsItemId (e.KeyHandle)) {
                            //
                            // Check if at least one operation is set
                            //

                            if (IsmIsOperationSetOnObjectId (
                                    ObjectId,
                                    (MIG_OPERATIONID) e.KeyHandle
                                    )) {
                                MemDbAbortEnum (&e);
                                result = TRUE;
                                done = TRUE;
                                __leave;
                            }
                        }

                    } while (MemDbEnumNext (&e));
                    MemDbAbortEnum (&e);
                }

                done = TRUE;
                __leave;

            } else {
                DEBUGMSG ((
                    DBG_ERROR,
                    "IsmIsOperationSetOnObjectId: operation id is invalid"
                    ));
                __leave;
            }
        }
    }
    __finally {
        if (enumKey) {
            FreeText (enumKey);
            INVALID_POINTER (enumKey);
        }
    }

    if (done) {
        return result;
    }

    return MemDbTestDoubleLinkageByKeyHandle (
                ObjectId,
                OperationId,
                OPERATION_INDEX
                );
}


BOOL
pQueryOperationGroup (
    IN      KEYHANDLE OperationId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pIsOperationSetOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_OPERATIONID) OperationId
                );
}


BOOL
IsmIsOperationSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    )
{
    RECURSERETURN rc;

    //
    // If OperationId is a group, query all operations in the group
    //

    rc = RecurseForGroupItems (
                OperationId,
                pQueryOperationGroup,
                (ULONG_PTR) ObjectId,
                TRUE,
                TRUE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pIsOperationSetOnObjectId (ObjectId, OperationId);
}


BOOL
IsmIsOperationSetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsOperationSetOnObjectId (objectId, OperationId);
    }

    return FALSE;
}


BOOL
IsmGetObjectOperationDataById (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    OUT     PBYTE Buffer,                   OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT BufferSizeNeeded,         OPTIONAL
    OUT     PMIG_BLOBTYPE Type,             OPTIONAL
    IN      BOOL DestinationData
    )
{
    POPERATION_PROPERTY_LINKAGE linkage = NULL;
    UINT dataCount;
    BOOL result = FALSE;
    GROWBUFFER tempBuffer = INIT_GROWBUFFER;
    LONGLONG offset;
    UINT size;
    DWORD error = ERROR_SUCCESS;
    PBYTE freeMe = NULL;

    __try {
        //
        // Obtain the linkage between the operation and its data
        //

        linkage = pFindOperationPropertyLinkage (
                        ObjectId,
                        OperationId,
                        &freeMe,
                        &dataCount
                        );

        if (!linkage) {
            //
            // No data
            //

            __leave;
        }

        offset = DestinationData ? linkage->DestData : linkage->SrcData;

        if (!offset) {
            //
            // No data
            //

            __leave;
        }

        if (!GetProperty (offset, NULL, NULL, &size, Type)) {
            DEBUGMSG ((DBG_ERROR, "Error getting property instance header from dat file"));
            error = ERROR_INVALID_PARAMETER;
            __leave;
        }

        if (BufferSizeNeeded) {
            *BufferSizeNeeded = size;
        }

        //
        // If a buffer was specified, check its size and fill it if possible
        //

        if (Buffer) {
            if (BufferSize >= size) {
                if (!GetProperty (offset, NULL, Buffer, NULL, NULL)) {
                    DEBUGMSG ((DBG_ERROR, "Error reading property data from dat file"));

                    //
                    // error code is one of the file api error codes
                    //

                    error = GetLastError();
                    __leave;
                }
            } else {
                error = ERROR_MORE_DATA;
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {
        MemDbReleaseMemory (freeMe);
        INVALID_POINTER (freeMe);

        GbFree (&tempBuffer);
    }

    SetLastError (error);
    return result;
}


BOOL
IsmGetObjectOperationData (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_OPERATIONID OperationId,
    OUT     PBYTE Buffer,                   OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT BufferSizeNeeded,         OPTIONAL
    OUT     PMIG_BLOBTYPE Type,             OPTIONAL
    IN      BOOL DestinationData
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmGetObjectOperationDataById (
                    objectId,
                    OperationId,
                    Buffer,
                    BufferSize,
                    BufferSizeNeeded,
                    Type,
                    DestinationData
                    );
    }

    return FALSE;
}


BOOL
pEnumFirstObjectOperationById (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId,
    IN      BOOL ReturnAllPrivateOps
    )
{
    POBJECTOPERATION_HANDLE handle;
    BOOL b = TRUE;

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTOPERATION_ENUM));

    EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTOPERATION_HANDLE));
    handle = (POBJECTOPERATION_HANDLE) EnumPtr->Handle;
    handle->ReturnAllPrivateOps = ReturnAllPrivateOps;

    //
    // Obtain the linkage up front
    //

    handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                ObjectId,
                                OPERATION_INDEX,
                                &handle->Count
                                );

    handle->Count /= sizeof(KEYHANDLE);

    if (!handle->LinkageList || !handle->Count) {
        IsmAbortObjectOperationEnum (EnumPtr);
        return FALSE;
    }

    handle->OpPropLinkList = (POPERATION_PROPERTY_LINKAGE) MemDbGetUnorderedBlobByKeyHandle (
                                                                ObjectId,
                                                                OPERATION_INDEX,
                                                                &handle->OpPropCount
                                                                );

    handle->OpPropCount /= sizeof (OPERATION_PROPERTY_LINKAGE);

    if (!handle->OpPropLinkList) {
        handle->OpPropCount = 0;
    }

    //
    // Continue enumeration in "next" function
    //

    return IsmEnumNextObjectOperation (EnumPtr);
}


BOOL
IsmEnumFirstObjectOperationById (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId
    )
{
    return pEnumFirstObjectOperationById (EnumPtr, ObjectId, FALSE);
}


BOOL
pEnumFirstObjectOperation (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      BOOL ReturnAllPrivateOps
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return pEnumFirstObjectOperationById (EnumPtr, objectId, ReturnAllPrivateOps);
    }

    return FALSE;
}


BOOL
IsmEnumFirstObjectOperation (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    )
{
    return pEnumFirstObjectOperation (EnumPtr, ObjectTypeId, EncodedObjectName, FALSE);
}


BOOL
IsmEnumNextObjectOperation (
    IN OUT  PMIG_OBJECTOPERATION_ENUM EnumPtr
    )
{
    POBJECTOPERATION_HANDLE handle;
    BOOL b = FALSE;
    BOOL mine;
    UINT u;
    POPERATION_PROPERTY_LINKAGE linkage;

    handle = (POBJECTOPERATION_HANDLE) EnumPtr->Handle;
    if (!handle) {
        return FALSE;
    }

    do {

        MYASSERT (!b);

        //
        // Check if we hit the end
        //

        if (handle->Index >= handle->Count) {
            break;
        }

        //
        // Return the next operation
        //

        EnumPtr->OperationId = (MIG_OPERATIONID) handle->LinkageList[handle->Index];
        handle->Index++;

        b = pGetOperationName (
                EnumPtr->OperationId,
                NULL,
                0,
                &EnumPtr->Private,
                &mine,
                NULL,
                handle->ReturnAllPrivateOps
                );

        //
        // Continue when the operation is not owned by the caller
        //

        if (b && EnumPtr->Private && !mine) {
            b = FALSE;
        }

    } while (!b);

    if (!b) {
        IsmAbortObjectOperationEnum (EnumPtr);
    } else {
        //
        // Before returning match, fill enum structure with property info
        //

        linkage = handle->OpPropLinkList;

        for (u = 0 ; u < handle->OpPropCount ; u++) {
            if (linkage->OperationId == EnumPtr->OperationId) {
                break;
            }

            linkage++;
        }

        if (u < handle->OpPropCount) {
            //
            // This operation has src property, dest property, or both.
            // Get the data from property.dat and put it in the enum
            // struct.
            //

            if (linkage->SrcData) {

                EnumPtr->SourceData = &handle->SrcData;
                CreatePropertyStruct (
                    &handle->SrcPropBuf,
                    &handle->SrcData,
                    linkage->SrcData
                    );

            } else {
                EnumPtr->SourceData = NULL;
            }

            if (linkage->DestData) {

                EnumPtr->DestinationData = &handle->DestData;
                CreatePropertyStruct (
                    &handle->DestPropBuf,
                    &handle->DestData,
                    linkage->DestData
                    );

            } else {
                EnumPtr->DestinationData = NULL;
            }

        } else {
            //
            // No src or dest properties
            //

            EnumPtr->SourceData = NULL;
            EnumPtr->DestinationData = NULL;
        }
    }

    return b;
}


VOID
IsmAbortObjectOperationEnum (
    IN OUT  PMIG_OBJECTOPERATION_ENUM EnumPtr
    )
{
    POBJECTOPERATION_HANDLE handle;

    if (EnumPtr->Handle) {

        handle = (POBJECTOPERATION_HANDLE) EnumPtr->Handle;

        GbFree (&handle->SrcPropBuf);
        GbFree (&handle->DestPropBuf);

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        if (handle->OpPropLinkList) {
            MemDbReleaseMemory (handle->OpPropLinkList);
            INVALID_POINTER (handle->OpPropLinkList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTOPERATION_ENUM));
}


BOOL
IsmEnumFirstObjectWithOperation (
    OUT     PMIG_OBJECTWITHOPERATION_ENUM EnumPtr,
    IN      MIG_OPERATIONID OperationId
    )
{
    POBJECTWITHOPERATION_HANDLE handle;
    BOOL b = FALSE;

    __try {
        //
        // Did caller specify an item id?
        //

        if (!IsItemId ((KEYHANDLE) OperationId)) {
            DEBUGMSG ((
                DBG_ERROR,
                "IsmEnumFirstObjectWithOperation: operation id is invalid"
                ));
            __leave;
        }

        ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHOPERATION_ENUM));

        EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTWITHOPERATION_HANDLE));
        handle = (POBJECTWITHOPERATION_HANDLE) EnumPtr->Handle;

        handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                    OperationId,
                                    OPERATION_INDEX,
                                    &handle->Count
                                    );

        handle->Count = handle->Count / SIZEOF(KEYHANDLE);

        if (!handle->LinkageList || !handle->Count) {
            IsmAbortObjectWithOperationEnum (EnumPtr);
            __leave;
        } else {
            b = IsmEnumNextObjectWithOperation (EnumPtr);
        }
    }
    __finally {
    }

    return b;
}


BOOL
IsmEnumNextObjectWithOperation (
    IN OUT  PMIG_OBJECTWITHOPERATION_ENUM EnumPtr
    )
{
    POBJECTWITHOPERATION_HANDLE handle;
    PCTSTR objectPath = NULL;
    BOOL b = FALSE;
    PTSTR p;

    __try {
        handle = (POBJECTWITHOPERATION_HANDLE) EnumPtr->Handle;
        if (!handle) {
            __leave;
        }

        while (!b) {

            //
            // Check if enum is done
            //

            if (handle->Index >= handle->Count) {
                break;
            }

            //
            // Get the next object id from the linkage list
            //

            EnumPtr->ObjectId = handle->LinkageList[handle->Index];
            handle->Index++;

            if (handle->ObjectFromMemdb) {
                MemDbReleaseMemory (handle->ObjectFromMemdb);
                INVALID_POINTER (handle->ObjectFromMemdb);
            }

            handle->ObjectFromMemdb = MemDbGetKeyFromHandle ((KEYHANDLE) EnumPtr->ObjectId, 0);

            if (!handle->ObjectFromMemdb) {
                MYASSERT (FALSE);   // this error shouldn't happen -- but don't give up
                continue;
            }

            //
            // Turn the object id into a name
            //

            p = _tcschr (handle->ObjectFromMemdb, TEXT('\\'));

            if (p) {
                b = TRUE;
                EnumPtr->ObjectName = _tcsinc (p);
                *p = 0;
                EnumPtr->ObjectTypeId = GetObjectTypeId (handle->ObjectFromMemdb);
            }
        }
    }
    __finally {
    }

    if (!b) {
        IsmAbortObjectWithOperationEnum (EnumPtr);
    }

    return b;
}


VOID
IsmAbortObjectWithOperationEnum (
    IN      PMIG_OBJECTWITHOPERATION_ENUM EnumPtr
    )
{
    POBJECTWITHOPERATION_HANDLE handle;

    if (EnumPtr->Handle) {
        handle = (POBJECTWITHOPERATION_HANDLE) EnumPtr->Handle;

        if (handle->ObjectFromMemdb) {
            MemDbReleaseMemory (handle->ObjectFromMemdb);
            INVALID_POINTER (handle->ObjectFromMemdb);
        }

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHOPERATION_ENUM));
}

MIG_OBJECTSTRINGHANDLE
pBuildHandleFromNativeFileName (
    IN      PCTSTR NativeFileName,
    IN      BOOL HadLeaf
    )
{
    PTSTR nativeNameCopy = NULL;
    PTSTR leafPtr1 = NULL;
    PTSTR leafPtr2 = NULL;
    MIG_OBJECTSTRINGHANDLE result = NULL;

    if (HadLeaf) {
        nativeNameCopy = DuplicatePathString (NativeFileName, 0);
        if (nativeNameCopy) {
            leafPtr1 = _tcsrchr (nativeNameCopy, TEXT('\\'));
            if (leafPtr1) {
                leafPtr2 = _tcsinc (leafPtr1);
                *leafPtr1 = 0;
                if (leafPtr2) {
                    result = IsmCreateObjectHandle (nativeNameCopy, leafPtr2);
                }
            }
            FreePathString (nativeNameCopy);
        }
    } else {
        result = IsmCreateObjectHandle (NativeFileName, NULL);
    }
    return result;
}

MIG_OBJECTSTRINGHANDLE
TrackedIsmGetLongName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
            TRACKING_DEF
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    UINT resultType = FILENAME_UNDECIDED;
    BOOL hadLeaf = FALSE;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PTSTR nativeName = NULL;
    PTSTR nativeNamePtr;
    PTSTR beginSegPtr;
    PTSTR endSegPtr;
    PCTSTR lastSeg;
    UINT savedEnd;
    UINT beginBuffIdx;
    TCHAR savedChar;
    KEYHANDLE kh1, kh2;
    DWORD value;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    MIG_PLATFORMTYPEID platform;
    MIG_PLATFORMTYPEID realPlatform;
    PCTSTR nativeFileName;
    PCTSTR longNativeFileName;

    TRACK_ENTER();

    if ((ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) {

        //
        // fire up the short-long algorithm
        //
        if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

            // If this is for the source platform and we are on the source platform,
            // or it is for the destination platform and we are on the destination platform
            // then just call BfGetLongFileName and be done with it
            platform = ObjectTypeId & PLATFORM_MASK;
            realPlatform = IsmGetRealPlatform ();

            if (platform == realPlatform) {
                nativeFileName = IsmGetNativeObjectName (ObjectTypeId, ObjectName);
                if (nativeFileName) {
                    longNativeFileName = BfGetLongFileName (nativeFileName);
                    if (!longNativeFileName) {
                        longNativeFileName = nativeFileName;
                    }
                    result = pBuildHandleFromNativeFileName (longNativeFileName, (leaf != NULL));
                    if (longNativeFileName != nativeFileName) {
                        FreePathString (longNativeFileName);
                    }
                    IsmReleaseMemory (nativeFileName);
                }
            } else {

                MYASSERT (node);
                if (node) {
                    if (leaf) {
                        nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node) + SizeOfString (leaf));
                        hadLeaf = TRUE;
                    } else {
                        nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node));
                        hadLeaf = FALSE;
                    }
                    nativeNamePtr = AppendWack (nativeName);
                    StringCopy (nativeNamePtr, node);
                    if (leaf) {
                        StringCopy (AppendWack (nativeNamePtr), leaf);
                    }
                    GbAppendString (&growBuf, S_SHORTLONG_TREE);
                    GbAppendString (&growBuf, TEXT("\\"));
                    beginBuffIdx = growBuf.End - (1 * sizeof (TCHAR));
                    beginSegPtr = GetFirstSeg (nativeNamePtr);

                    if (beginSegPtr) {

                        beginSegPtr = _tcsinc (beginSegPtr);

                        GbAppendStringAB (&growBuf, nativeNamePtr, beginSegPtr);

                        while (beginSegPtr) {
                            endSegPtr = _tcschr (beginSegPtr, TEXT('\\'));
                            if (!endSegPtr) {
                                endSegPtr = GetEndOfString (beginSegPtr);
                                MYASSERT (endSegPtr);
                            }

                            savedChar = *endSegPtr;
                            *endSegPtr = 0;

                            savedEnd = growBuf.End - (1 * sizeof (TCHAR));
                            GbAppendStringAB (&growBuf, beginSegPtr, endSegPtr);

                            kh1 = MemDbGetHandleFromKey ((PCTSTR) growBuf.Buf);
                            if (kh1) {
                                MemDbGetValueByHandle (kh1, &value);
                                if (value == FILENAME_LONG) {
                                    resultType = FILENAME_LONG;
                                } else {
                                    if (resultType != FILENAME_LONG) {
                                        resultType = FILENAME_SHORT;
                                    }
                                    kh2 = MemDbGetDoubleLinkageByKeyHandle (kh1, 0, 0);
                                    MYASSERT (kh2);
                                    if (kh2) {
                                        growBuf.End = savedEnd;
                                        lastSeg = MemDbGetKeyFromHandle (kh2, MEMDB_LAST_LEVEL);
                                        GbAppendString (&growBuf, lastSeg);
                                        MemDbReleaseMemory (lastSeg);
                                    }
                                }
                            }

                            *endSegPtr = savedChar;
                            if (savedChar) {
                                beginSegPtr = _tcsinc (endSegPtr);
                                GbAppendStringAB (&growBuf, endSegPtr, beginSegPtr);
                            } else {
                                beginSegPtr = NULL;
                            }
                        }
                    } else {
                        GbAppendString (&growBuf, nativeNamePtr);
                    }
                    FreePathString (nativeName);
                    if (node) {
                        IsmDestroyObjectString (node);
                    }
                    if (leaf) {
                        IsmDestroyObjectString (leaf);
                    }
                    if (hadLeaf) {
                        beginSegPtr = _tcsrchr ((PTSTR) growBuf.Buf, TEXT('\\'));
                        endSegPtr = _tcsinc (beginSegPtr);
                        *beginSegPtr = 0;
                    } else {
                        endSegPtr = NULL;
                    }
                    result = IsmCreateObjectHandle ((PTSTR) (growBuf.Buf + beginBuffIdx), endSegPtr);
                }
            }
        }
        GbFree (&growBuf);
    }

    TRACK_LEAVE();

    return result;
}

MIG_OBJECTSTRINGHANDLE
IsmFilterObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     MIG_OBJECTTYPEID *NewObjectTypeId,          OPTIONAL
    OUT     PBOOL ObjectDeleted,                        OPTIONAL
    OUT     PBOOL ObjectReplaced                        OPTIONAL
    )
{
    MIG_OBJECTSTRINGHANDLE objectName = ObjectName;
    ENCODEDSTRHANDLE result = NULL;
    MIG_FILTEROUTPUT filterOutput;
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    UINT resultType = FILENAME_UNDECIDED;
    BOOL hadLeaf = FALSE;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PTSTR nativeName = NULL;
    PTSTR nativeNamePtr;
    PTSTR beginSegPtr;
    PTSTR endSegPtr;
    PCTSTR lastSeg;
    UINT savedEnd;
    UINT beginBuffIdx;
    TCHAR savedChar;
    KEYHANDLE kh1, kh2;
    DWORD value;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    __try {

        if ((ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) {
            //
            // fire up the short-long algorithm
            //
            if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

                if (node) {
                    if (leaf) {
                        nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node) + SizeOfString (leaf));
                        hadLeaf = TRUE;
                    } else {
                        nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node));
                        hadLeaf = FALSE;
                    }
                    nativeNamePtr = AppendWack (nativeName);
                    StringCopy (nativeNamePtr, node);
                    if (leaf) {
                        StringCopy (AppendWack (nativeNamePtr), leaf);
                    }
                    GbAppendString (&growBuf, S_SHORTLONG_TREE);
                    GbAppendString (&growBuf, TEXT("\\"));
                    beginBuffIdx = growBuf.End - (1 * sizeof (TCHAR));
                    beginSegPtr = GetFirstSeg (nativeNamePtr);

                    if (beginSegPtr) {

                        beginSegPtr = _tcsinc (beginSegPtr);

                        GbAppendStringAB (&growBuf, nativeNamePtr, beginSegPtr);

                        while (beginSegPtr) {
                            endSegPtr = _tcschr (beginSegPtr, TEXT('\\'));
                            if (!endSegPtr) {
                                endSegPtr = GetEndOfString (beginSegPtr);
                                MYASSERT (endSegPtr);
                            }

                            savedChar = *endSegPtr;
                            *endSegPtr = 0;

                            savedEnd = growBuf.End - (1 * sizeof (TCHAR));
                            GbAppendStringAB (&growBuf, beginSegPtr, endSegPtr);

                            kh1 = MemDbGetHandleFromKey ((PCTSTR) growBuf.Buf);
                            if (kh1) {
                                MemDbGetValueByHandle (kh1, &value);
                                if (value == FILENAME_LONG) {
                                    resultType = FILENAME_LONG;
                                } else {
                                    if (resultType != FILENAME_LONG) {
                                        resultType = FILENAME_SHORT;
                                    }
                                    kh2 = MemDbGetDoubleLinkageByKeyHandle (kh1, 0, 0);
                                    MYASSERT (kh2);
                                    if (kh2) {
                                        growBuf.End = savedEnd;
                                        lastSeg = MemDbGetKeyFromHandle (kh2, MEMDB_LAST_LEVEL);
                                        GbAppendString (&growBuf, lastSeg);
                                        MemDbReleaseMemory (lastSeg);
                                    }
                                }
                            }

                            *endSegPtr = savedChar;
                            if (savedChar) {
                                beginSegPtr = _tcsinc (endSegPtr);
                                GbAppendStringAB (&growBuf, endSegPtr, beginSegPtr);
                            } else {
                                beginSegPtr = NULL;
                            }
                        }
                    } else {
                        GbAppendString (&growBuf, nativeNamePtr);
                    }
                    FreePathString (nativeName);
                    if (node) {
                        IsmDestroyObjectString (node);
                    }
                    if (leaf) {
                        IsmDestroyObjectString (leaf);
                    }
                    if (hadLeaf) {
                        beginSegPtr = _tcsrchr ((PTSTR) growBuf.Buf, TEXT('\\'));
                        endSegPtr = _tcsinc (beginSegPtr);
                        *beginSegPtr = 0;
                    } else {
                        endSegPtr = NULL;
                    }
                    objectName = IsmCreateObjectHandle ((PTSTR) (growBuf.Buf + beginBuffIdx), endSegPtr);
                }
            }
        }

        if (!ApplyOperationsOnObject (
                    ObjectTypeId,
                    objectName,
                    FALSE,
                    !ShouldObjectBeRestored (
                        ObjectTypeId,
                        IsmGetObjectIdFromName (ObjectTypeId, objectName, TRUE),
                        objectName
                        ),
                    OP_ALL_PRIORITY,
                    NULL,
                    &filterOutput,
                    NULL
                    )) {
            __leave;
        }

        if (ObjectDeleted) {
            *ObjectDeleted = filterOutput.Deleted;
        }

        if (ObjectReplaced) {
            *ObjectReplaced = filterOutput.Replaced;
        }

        if (NewObjectTypeId) {
            *NewObjectTypeId = filterOutput.NewObject.ObjectTypeId;
        }

        if (filterOutput.NewObject.ObjectName == objectName) {
            __leave;
        }

        if (resultType == FILENAME_SHORT) {
            // NTRAID#NTBUG9-153258-2000/08/01-jimschm Create dummy file (if does not exist) to reserve and get the short file name
        }

        result = filterOutput.NewObject.ObjectName;
    }
    __finally {
        if (objectName != ObjectName) {
            //
            // free the object name allocated by the short-long algorithm
            //
            IsmDestroyObjectHandle (objectName);
        }
    }
    GbFree (&growBuf);

    return result;
}


VOID
pFreeMigObjectStruct (
    IN      PMIG_OBJECT Object,
    IN      PMIG_OBJECT OriginalObject,         OPTIONAL
    IN      PMIG_OBJECT NewObject               OPTIONAL
    )
{
    BOOL free = TRUE;

    if (OriginalObject) {
        if (Object->ObjectName == OriginalObject->ObjectName) {
            free = FALSE;
        }
    }

    if (NewObject) {
        if (Object->ObjectName == NewObject->ObjectName) {
            free = FALSE;
        }
    }

    if (free) {
        IsmDestroyObjectHandle (Object->ObjectName);
    }

    ZeroMemory (Object, sizeof (MIG_OBJECT));
}


VOID
pFreeMigContentStruct (
    IN      PMIG_CONTENT Content,
    IN      PCMIG_CONTENT OriginalContent,      OPTIONAL
    IN      PCMIG_CONTENT NewContent            OPTIONAL
    )
{
    BOOL free;

    if (Content->ContentInFile) {

        free = TRUE;

        if (OriginalContent &&
            Content->FileContent.ContentPath == OriginalContent->FileContent.ContentPath
            ) {

            free = FALSE;

        } else if (NewContent &&
                   Content->FileContent.ContentPath == NewContent->FileContent.ContentPath
                   ) {

            free = FALSE;

        }

        if (free) {
            if (Content->FileContent.ContentPath) {
                IsmReleaseMemory (Content->FileContent.ContentPath);
                Content->FileContent.ContentPath = NULL;
            }
        }

    } else {

        free = TRUE;

        if (OriginalContent &&
            Content->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes
            ) {

            free = FALSE;

        } else if (NewContent &&
                   Content->MemoryContent.ContentBytes == NewContent->MemoryContent.ContentBytes
                   ) {

            free = FALSE;
        }

        if (free) {
            if (Content->MemoryContent.ContentBytes) {
                IsmReleaseMemory (Content->MemoryContent.ContentBytes);
                Content->MemoryContent.ContentBytes = NULL;
            }
        }
    }

    free = TRUE;

    if (OriginalContent &&
        OriginalContent->Details.DetailsData == Content->Details.DetailsData
        ) {

        free = FALSE;
    }

    if (NewContent &&
        NewContent->Details.DetailsData == Content->Details.DetailsData
        ) {

        free = FALSE;
    }

    if (free && Content->Details.DetailsData) {
        IsmReleaseMemory (Content->Details.DetailsData);
        Content->Details.DetailsData = NULL;;
    }

    ZeroMemory (Content, sizeof (MIG_CONTENT));
}


BOOL
ApplyOperationsOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      BOOL TreeFiltersOnly,
    IN      BOOL NoRestoreObject,
    IN      DWORD OperationPriority,
    IN      PMIG_CONTENT ApplyInput,            OPTIONAL
    OUT     PMIG_FILTEROUTPUT FilterOutput,
    OUT     PMIG_CONTENT ApplyOutput            OPTIONAL
    )
{
    MIG_FILTERINPUT filterInput;
    MIG_OBJECTOPERATION_ENUM Enum;
    BOOL result = FALSE;
    MIG_CONTENT currentContent;
    OPERATION_DATA operationData;
    POPMFILTERCALLBACK filterCallback;
    POPMAPPLYCALLBACK applyCallback;
    PGLOBALFILTERINDEX globalFilterIndex;
    PGLOBALFILTER globalFilter;
    PGLOBALEDIT globalEdit;
    BOOL needObjectId;
    MIG_OBJECTID objectId = 0;

    if (NoRestoreObject) {
        MYASSERT (!ApplyInput);
        MYASSERT (!ApplyOutput);
        if (ApplyInput || ApplyOutput) {
            return FALSE;
        }
    }

    __try {

        //
        // Save original values
        //

        ZeroMemory (&filterInput, sizeof (filterInput));

        filterInput.OriginalObject.ObjectTypeId = ObjectTypeId;
        filterInput.OriginalObject.ObjectName = ObjectName;
        filterInput.CurrentObject = filterInput.OriginalObject;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            filterInput.Deleted = NoRestoreObject;
        }

        filterInput.FilterTreeChangesOnly = TreeFiltersOnly;

        ZeroMemory (&currentContent, sizeof (MIG_CONTENT));

        if (ApplyInput) {
            CopyMemory (&currentContent, ApplyInput, sizeof (MIG_CONTENT));
        }

        //
        // Set defaults for output
        //

        FilterOutput->NewObject = filterInput.CurrentObject;
        FilterOutput->Deleted = filterInput.Deleted;
        FilterOutput->Replaced = filterInput.Replaced;

        if (ApplyInput) {
            MYASSERT (ApplyOutput);
            CopyMemory (ApplyOutput, ApplyInput, sizeof (MIG_CONTENT));
        }

        //
        // Find type in filter index and process first pass global filters and editors
        //

        globalFilterIndex = pGetGlobalIndex (ObjectTypeId, FALSE);

        if (globalFilterIndex) {

            //
            // Get object ID
            //

            needObjectId = FALSE;

            if (OperationPriority & OP_HIGH_PRIORITY) {
                if (globalFilterIndex->FilterFirstHeadHp ||
                    globalFilterIndex->FilterLastHeadHp ||
                    globalFilterIndex->EditFirstHeadHp ||
                    globalFilterIndex->EditLastHeadHp
                    ) {
                    needObjectId = TRUE;
                }
            }

            if (OperationPriority & OP_LOW_PRIORITY) {
                if (globalFilterIndex->FilterFirstHead ||
                    globalFilterIndex->FilterLastHead ||
                    globalFilterIndex->EditFirstHead ||
                    globalFilterIndex->EditLastHead
                    ) {
                    needObjectId = TRUE;
                }
            }

            if (needObjectId) {
                objectId = IsmGetObjectIdFromName (ObjectTypeId, ObjectName, TRUE);
            }

            //
            // Perform first pass global filter
            //

            if (OperationPriority & OP_HIGH_PRIORITY) {

                globalFilter = globalFilterIndex->FilterFirstHeadHp;

                while (globalFilter) {

                    if ((!globalFilter->Platform || (globalFilter->Platform & ObjectTypeId)) &&
                        (!TreeFiltersOnly || globalFilter->TreeFilter) &&
                        (!NoRestoreObject || globalFilter->NoRestoreFilter)
                        ) {

                        if (!objectId ||
                            !pIsOperationProhibitedOnObject (globalFilter->OperationId, objectId, TRUE)
                            ) {

                            if (!globalFilter->Callback (
                                    &filterInput,
                                    FilterOutput,
                                    NoRestoreObject,
                                    NULL,
                                    NULL
                                    )) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "ApplyOperationsOnObject: first pass global filter failed for %s",
                                    pGetOpNameForDebug (globalFilter->OperationId)
                                    ));
                                __leave;
                            }

                            //
                            // Free input allocations if they are different from
                            // both the original and new pointer values
                            //

                            pFreeMigObjectStruct (
                                &filterInput.CurrentObject,
                                &filterInput.OriginalObject,
                                &FilterOutput->NewObject
                                );

                            //
                            // Filter outputs now become the inputs
                            //

                            filterInput.CurrentObject = FilterOutput->NewObject;
                            filterInput.Deleted = FilterOutput->Deleted;
                            filterInput.Replaced = FilterOutput->Replaced;
                        }
                    }

                    globalFilter = globalFilter->Next;
                }
            }

            if (OperationPriority & OP_LOW_PRIORITY) {

                globalFilter = globalFilterIndex->FilterFirstHead;

                while (globalFilter) {

                    if ((!globalFilter->Platform || (globalFilter->Platform & ObjectTypeId)) &&
                        (!TreeFiltersOnly || globalFilter->TreeFilter) &&
                        (!NoRestoreObject || globalFilter->NoRestoreFilter)
                        ) {

                        if (!objectId ||
                            !pIsOperationProhibitedOnObject (globalFilter->OperationId, objectId, TRUE)
                            ) {

                            if (!globalFilter->Callback (
                                    &filterInput,
                                    FilterOutput,
                                    NoRestoreObject,
                                    NULL,
                                    NULL
                                    )) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "ApplyOperationsOnObject: first pass global filter failed for %s",
                                    pGetOpNameForDebug (globalFilter->OperationId)
                                    ));
                                __leave;
                            }

                            //
                            // Free input allocations if they are different from
                            // both the original and new pointer values
                            //

                            pFreeMigObjectStruct (
                                &filterInput.CurrentObject,
                                &filterInput.OriginalObject,
                                &FilterOutput->NewObject
                                );

                            //
                            // Filter outputs now become the inputs
                            //

                            filterInput.CurrentObject = FilterOutput->NewObject;
                            filterInput.Deleted = FilterOutput->Deleted;
                            filterInput.Replaced = FilterOutput->Replaced;
                        }
                    }

                    globalFilter = globalFilter->Next;
                }
            }

            //
            // Perform first pass apply
            //

            if (ApplyInput) {

                if (OperationPriority & OP_HIGH_PRIORITY) {

                    globalEdit = globalFilterIndex->EditFirstHeadHp;

                    while (globalEdit) {

                        if (!globalEdit->Platform || (globalEdit->Platform & ObjectTypeId)) {

                            if (!objectId ||
                                !pIsOperationProhibitedOnObject (globalEdit->OperationId, objectId, TRUE)
                                ) {

                                //
                                // Call the apply function associated with this operation
                                //

                                if (!globalEdit->Callback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        NULL,
                                        NULL
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: first pass global callback failed for %s",
                                        pGetOpNameForDebug (globalEdit->OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                        globalEdit = globalEdit->Next;
                    }
                }

                if (OperationPriority & OP_LOW_PRIORITY) {

                    globalEdit = globalFilterIndex->EditFirstHead;

                    while (globalEdit) {

                        if (!globalEdit->Platform || (globalEdit->Platform & ObjectTypeId)) {

                            if (!objectId ||
                                !pIsOperationProhibitedOnObject (globalEdit->OperationId, objectId, TRUE)
                                ) {

                                //
                                // Call the apply function associated with this operation
                                //

                                if (!globalEdit->Callback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        NULL,
                                        NULL
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: first pass global callback failed for %s",
                                        pGetOpNameForDebug (globalEdit->OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                        globalEdit = globalEdit->Next;
                    }
                }
            }
        }

        //
        // Enumerate all operations on the object, then call filter and apply
        // callbacks.
        //

        if (pEnumFirstObjectOperation (&Enum, ObjectTypeId, ObjectName, TRUE)) {

            do {

                if (pGetOperationData (Enum.OperationId, &operationData)) {

                    if (OperationPriority & OP_HIGH_PRIORITY) {

                        //
                        // Screen the non-tree filters if necessary
                        //

                        if ((!TreeFiltersOnly || operationData.TreeFilterHp) &&
                            (!NoRestoreObject || operationData.NoRestoreFilterHp)
                            ) {

                            //
                            // NOTE: This loop calls the filter for an operation, then the
                            //       apply for the operation, then the filter for the next
                            //       operation, the apply for the next operation, and so on.
                            //
                            //       A content-edit of something that points to itself
                            //       might not be processed correctly.  That is, its
                            //       own path is not completely filtered, and
                            //       therefore it might not be correct.  To fix this,
                            //       all filters should run first, and then all apply
                            //       callbacks should run.  But because this would
                            //       cause double-enumeration of operations (costing
                            //       operation data retrieval), the loop is left
                            //       as-is.  Also, the theoretical case is rare enough
                            //       that we aren't concerned, and there is a
                            //       workaround via the operation priorities.
                            //

                            //
                            // Call the filter associated with this operation
                            //

                            filterCallback = operationData.FilterCallbackHp;
                            if (filterCallback) {

                                if (!filterCallback (
                                        &filterInput,
                                        FilterOutput,
                                        NoRestoreObject,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: filter failed for %s",
                                        pGetOpNameForDebug (Enum.OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from
                                // both the original and new pointer values
                                //

                                pFreeMigObjectStruct (
                                    &filterInput.CurrentObject,
                                    &filterInput.OriginalObject,
                                    &FilterOutput->NewObject
                                    );

                                //
                                // Filter outputs now become the inputs
                                //

                                filterInput.CurrentObject = FilterOutput->NewObject;
                                filterInput.Deleted = FilterOutput->Deleted;
                                filterInput.Replaced = FilterOutput->Replaced;

                            }

                            //
                            // Call the apply function associated with this operation
                            //

                            if (ApplyInput) {
                                applyCallback = operationData.ApplyCallbackHp;
                            } else {
                                applyCallback = NULL;
                            }

                            if (applyCallback) {

                                if (!applyCallback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: Operation apply callback failed for %s",
                                        pGetOpNameForDebug (Enum.OperationId)
                                        ));
                                    IsmAbortObjectOperationEnum (&Enum);
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                    }

                    if (OperationPriority & OP_LOW_PRIORITY) {

                        //
                        // Screen the non-tree filters if necessary
                        //

                        if ((!TreeFiltersOnly || operationData.TreeFilter) &&
                            (!NoRestoreObject || operationData.NoRestoreFilter)
                            ) {

                            //
                            // NOTE: This loop calls the filter for an operation, then the
                            //       apply for the operation, then the filter for the next
                            //       operation, the apply for the next operation, and so on.
                            //
                            //       A content-edit of something that points to itself
                            //       might not be processed correctly.  That is, its
                            //       own path is not completely filtered, and
                            //       therefore it might not be correct.  To fix this,
                            //       all filters should run first, and then all apply
                            //       callbacks should run.  But because this would
                            //       cause double-enumeration of operations (costing
                            //       operation data retrieval), the loop is left
                            //       as-is.  Also, the theoretical case is rare enough
                            //       that we aren't concerned, and there is a
                            //       workaround via the operation priorities.
                            //

                            //
                            // Call the filter associated with this operation
                            //

                            filterCallback = operationData.FilterCallback;
                            if (filterCallback) {

                                if (!filterCallback (
                                        &filterInput,
                                        FilterOutput,
                                        NoRestoreObject,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: filter failed for %s",
                                        pGetOpNameForDebug (Enum.OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from
                                // both the original and new pointer values
                                //

                                pFreeMigObjectStruct (
                                    &filterInput.CurrentObject,
                                    &filterInput.OriginalObject,
                                    &FilterOutput->NewObject
                                    );

                                //
                                // Filter outputs now become the inputs
                                //

                                filterInput.CurrentObject = FilterOutput->NewObject;
                                filterInput.Deleted = FilterOutput->Deleted;
                                filterInput.Replaced = FilterOutput->Replaced;

                            }

                            //
                            // Call the apply function associated with this operation
                            //

                            if (ApplyInput) {
                                applyCallback = operationData.ApplyCallback;
                            } else {
                                applyCallback = NULL;
                            }

                            if (applyCallback) {

                                if (!applyCallback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: Operation apply callback failed for %s",
                                        pGetOpNameForDebug (Enum.OperationId)
                                        ));
                                    IsmAbortObjectOperationEnum (&Enum);
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                    }
                }

            } while (IsmEnumNextObjectOperation (&Enum));
        }

        //
        // Execute last pass global filters and content editors
        //

        if (globalFilterIndex) {

            //
            // Preform last pass global filter
            //

            if (OperationPriority & OP_HIGH_PRIORITY) {

                globalFilter = globalFilterIndex->FilterLastHeadHp;

                while (globalFilter) {

                    if ((!globalFilter->Platform || (globalFilter->Platform & ObjectTypeId)) &&
                        (!TreeFiltersOnly || globalFilter->TreeFilter) &&
                        (!NoRestoreObject || globalFilter->NoRestoreFilter)
                        ) {

                        if (!objectId ||
                            !pIsOperationProhibitedOnObject (globalFilter->OperationId, objectId, TRUE)
                            ) {

                            if (!globalFilter->Callback (
                                    &filterInput,
                                    FilterOutput,
                                    NoRestoreObject,
                                    NULL,
                                    NULL
                                    )) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "ApplyOperationsOnObject: last pass global filter failed for %s",
                                    pGetOpNameForDebug (globalFilter->OperationId)
                                    ));
                                __leave;
                            }

                            //
                            // Free input allocations if they are different from
                            // both the original and new pointer values
                            //

                            pFreeMigObjectStruct (
                                &filterInput.CurrentObject,
                                &filterInput.OriginalObject,
                                &FilterOutput->NewObject
                                );

                            //
                            // Filter outputs now become the inputs
                            //

                            filterInput.CurrentObject = FilterOutput->NewObject;
                            filterInput.Deleted = FilterOutput->Deleted;
                            filterInput.Replaced = FilterOutput->Replaced;
                        }
                    }

                    globalFilter = globalFilter->Next;
                }
            }

            if (OperationPriority & OP_LOW_PRIORITY) {

                globalFilter = globalFilterIndex->FilterLastHead;

                while (globalFilter) {

                    if ((!globalFilter->Platform || (globalFilter->Platform & ObjectTypeId)) &&
                        (!TreeFiltersOnly || globalFilter->TreeFilter) &&
                        (!NoRestoreObject || globalFilter->NoRestoreFilter)
                        ) {

                        if (!objectId ||
                            !pIsOperationProhibitedOnObject (globalFilter->OperationId, objectId, TRUE)
                            ) {

                            if (!globalFilter->Callback (
                                    &filterInput,
                                    FilterOutput,
                                    NoRestoreObject,
                                    NULL,
                                    NULL
                                    )) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "ApplyOperationsOnObject: last pass global filter failed for %s",
                                    pGetOpNameForDebug (globalFilter->OperationId)
                                    ));
                                __leave;
                            }

                            //
                            // Free input allocations if they are different from
                            // both the original and new pointer values
                            //

                            pFreeMigObjectStruct (
                                &filterInput.CurrentObject,
                                &filterInput.OriginalObject,
                                &FilterOutput->NewObject
                                );

                            //
                            // Filter outputs now become the inputs
                            //

                            filterInput.CurrentObject = FilterOutput->NewObject;
                            filterInput.Deleted = FilterOutput->Deleted;
                            filterInput.Replaced = FilterOutput->Replaced;
                        }
                    }

                    globalFilter = globalFilter->Next;
                }
            }

            if (ApplyInput) {

                if (OperationPriority & OP_HIGH_PRIORITY) {

                    globalEdit = globalFilterIndex->EditLastHeadHp;

                    while (globalEdit) {

                        if (!globalEdit->Platform || (globalEdit->Platform & ObjectTypeId)) {

                            if (!objectId ||
                                !pIsOperationProhibitedOnObject (globalEdit->OperationId, objectId, TRUE)
                                ) {

                                //
                                // Call the apply function associated with this operation
                                //

                                if (!globalEdit->Callback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: last pass global callback failed for %s",
                                        pGetOpNameForDebug (globalEdit->OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                        globalEdit = globalEdit->Next;
                    }
                }

                if (OperationPriority & OP_LOW_PRIORITY) {

                    globalEdit = globalFilterIndex->EditLastHead;

                    while (globalEdit) {

                        if (!globalEdit->Platform || (globalEdit->Platform & ObjectTypeId)) {

                            if (!objectId ||
                                !pIsOperationProhibitedOnObject (globalEdit->OperationId, objectId, TRUE)
                                ) {

                                //
                                // Call the apply function associated with this operation
                                //

                                if (!globalEdit->Callback (
                                        ObjectTypeId,
                                        ObjectName,
                                        ApplyInput,
                                        &currentContent,
                                        ApplyOutput,
                                        Enum.SourceData,
                                        Enum.DestinationData
                                        )) {
                                    DEBUGMSG ((
                                        DBG_ERROR,
                                        "ApplyOperationsOnObject: last pass global callback failed for %s",
                                        pGetOpNameForDebug (globalEdit->OperationId)
                                        ));
                                    __leave;
                                }

                                //
                                // Free input allocations if they are different from both
                                // the original and new pointer values
                                //

                                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);

                                //
                                // Apply outputs now become the current content
                                //

                                CopyMemory (&currentContent, ApplyOutput, sizeof (MIG_CONTENT));
                            }
                        }
                        globalEdit = globalEdit->Next;
                    }
                }
            }
        }

        result = TRUE;
    }
    __finally {
        if (!result) {
            //
            // Free all allocations except for the original (made by
            // the caller)
            //

            pFreeMigObjectStruct (
                &filterInput.CurrentObject,
                &filterInput.OriginalObject,
                &FilterOutput->NewObject
                );
            pFreeMigObjectStruct (
                &FilterOutput->NewObject,
                &filterInput.OriginalObject,
                NULL
                );

            if (ApplyInput) {
                pFreeMigContentStruct (&currentContent, ApplyInput, ApplyOutput);
                pFreeMigContentStruct (ApplyOutput, ApplyInput, NULL);
            }
        }
    }

    return result;
}


VOID
FreeFilterOutput (
    IN      MIG_OBJECTSTRINGHANDLE OriginalString,
    IN      PMIG_FILTEROUTPUT FilterOutput
    )
{
    MIG_OBJECT object;

    object.ObjectName = OriginalString;
    pFreeMigObjectStruct (&FilterOutput->NewObject, &object, NULL);
}


VOID
FreeApplyOutput (
    IN      PCMIG_CONTENT OriginalContent,
    IN      PMIG_CONTENT FinalContent
    )
{
    pFreeMigContentStruct (FinalContent, OriginalContent, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\ism.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ism.c

Abstract:

    Implements routines that are common to the entire ISM.

Author:

    Jim Schmidt (jimschm) 21-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"
#include "modules.h"

#define DBG_ISM     "Ism"

//
// Strings
//

#define S_LOCK_KEY          TEXT("Locks\\%X")
#define S_TRANSPORT_TYPES   TEXT("TransportTypes")
#define S_DATABASEFILE_LITE TEXT("|MainDatabaseFile\\LITE")   // pipe is to decorate for uniqueness
#define S_DATABASEFILE_FULL TEXT("|MainDatabaseFile\\Full")   // pipe is to decorate for uniqueness

#define S_VER_OSTYPE        TEXT("OsVersionType")
#define S_VER_OSMAJOR       TEXT("OsVersionMajor")
#define S_VER_OSMINOR       TEXT("OsVersionMinor")
#define S_VER_OSBUILD       TEXT("OsVersionBuild")

//
// Constants
//

#define ISM_TMP_SIGNATURE       0x544D5355

#define OBJECT_LOCKED           0x00000001
#define GROUP_ID                0x00000001
#define ITEM_ID                 0x00000002

//
// Macros
//

// None

//
// Types
//

typedef struct {
    MEMDB_ENUM MemDbEnum;
    DBENUM_ARGS ParsedPatterns;
} OBJECTENUM_HANDLE, *POBJECTENUM_HANDLE;

typedef enum {
    TESTATE_BEGINTRANSPORT,
    TESTATE_GETCAPS,
    TESTATE_RETURN,
    TESTATE_NEXTTRANSPORTTYPE,
    TESTATE_NEXTTRANSPORT,
    TESTATE_DONE
} TRANSPORTENUMSTATE;

typedef struct {
    HASHTABLE_ENUM TableEnum;
    MEMDB_ENUM MemDbEnum;
    TRANSPORTENUMSTATE State;
    MIG_TRANSPORTSTORAGEID DesiredStorageId;
} TRANSPORTENUMHANDLE, *PTRANSPORTENUMHANDLE;

typedef struct {
    UINT SliceSize;
    UINT CurrentPosition;
    UINT SliceSizeInSeconds;
} PROGSLICE, *PPROGSLICE;

//
// Globals
//

MIG_OBJECTCOUNT g_TotalObjects;
MIG_OBJECTCOUNT g_SourceObjects;
MIG_OBJECTCOUNT g_DestinationObjects;
HANDLE g_CancelEvent;
HANDLE g_ActivityEvent;
HASHTABLE g_TransportTable;
HASHTABLE g_ControlFileTable;
PMHANDLE g_IsmPool;
PMHANDLE g_IsmUntrackedPool;
HINF g_IsmInf = INVALID_HANDLE_VALUE;
PCTSTR g_CurrentGroup = NULL;
UINT g_IsmCurrentPlatform = PLATFORM_CURRENT;
UINT g_IsmModulePlatformContext = PLATFORM_CURRENT;
PRESTORE_STRUCT g_RestoreCallbacks = NULL;
PCOMPARE_STRUCT g_CompareCallbacks = NULL;
PMESSAGECALLBACK g_MessageCallback;
PTRANSPORTDATA g_SelectedTransport;
MIG_TRANSPORTSTORAGEID g_SelectedTransportId;
GROWBUFFER g_SliceBuffer;
MIG_PROGRESSPHASE g_CurrentPhase;
PPROGRESSBARFN g_ProgressBarFn;
ULONG_PTR g_ProgressBarArg;
MIG_TRANSPORTTYPE g_TransportType = 0;
PTEMPORARYPROFILE g_TempProfile;
PMIG_LOGCALLBACK g_LogCallback;
PCTSTR g_JournalDirectory = NULL;
BOOL g_PreserveJournal = FALSE;
HANDLE g_JournalHandle = NULL;
BOOL g_RollbackMode = FALSE;
BOOL g_JournalUsed = FALSE;
BOOL g_ExecutionInProgress = FALSE;
PCTSTR g_DelayedOperationsCommand = NULL;
BOOL g_EngineInitialized;
BOOL g_EngineTerminated;
BOOL g_MakeProfilePermanent = FALSE;

// temporary storage
TCHAR g_GlobalTempDir [MAX_PATH] = TEXT("");
UINT g_TempDirIndex = 0;
UINT g_TempFileIndex = 0;

// execute
HASHTABLE g_PreProcessTable = NULL;
HASHTABLE g_RefreshTable = NULL;
HASHTABLE g_PostProcessTable = NULL;
BOOL g_PreProcessDone = FALSE;

#ifdef PRERELEASE
// crash hooks
MIG_OBJECTTYPEID g_CrashCountTypeId = 0;
DWORD g_CrashCountType = 0;
DWORD g_CrashCountObjects = 0;
MIG_OBJECTTYPEID g_CrashNameTypeId = 0;
PCTSTR g_CrashNameObject = NULL;
#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pCallProgressBar (
    IN      MIG_PROGRESSSTATE State
    );

BOOL
pEnumFirstTransportType (
    OUT     PMEMDB_ENUM EnumPtr
    );

BOOL
pEnumNextTransportType (
    IN OUT  PMEMDB_ENUM EnumPtr
    );

VOID
pAbortTransportTypeEnum (
    IN OUT  PMEMDB_ENUM EnumPtr
    );

BOOL
pEnumFirstVirtualObject (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    );

BOOL
pEnumNextVirtualObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    );

VOID
pAbortVirtualObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    );

BOOL
pEnablePrivilege (
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    );

VOID
pFreeRestoreCallbacks (
    VOID
    );

VOID
pFreeCompareCallbacks (
    VOID
    );

VOID
pRecordUserData (
    IN      PCTSTR UserName,
    IN      PCTSTR UserDomain,
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath,
    IN      BOOL ProfileCreated
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }
    return TRUE;
}


BOOL
CheckCancel (
    VOID
    )
{
    BOOL cancelled;

    if (g_EngineTerminated) {
        SetLastError (ERROR_REQUEST_ABORTED);
        DEBUGMSG ((DBG_ERROR, "CheckCancel called after engine was terminated"));
        return TRUE;
    }

    if (!g_EngineInitialized) {
        SetLastError (ERROR_REQUEST_ABORTED);
        DEBUGMSG ((DBG_WARNING, "Engine is not initialized"));
        return TRUE;
    }

    cancelled = (WaitForSingleObject (g_CancelEvent, 0) == WAIT_OBJECT_0);

    if (cancelled) {
        SetLastError (ERROR_CANCELLED);
        DEBUGMSG ((DBG_ISM, "Cancel signaled"));
    }

    return cancelled;
}

MIG_OBJECTTYPEID
FixObjectTypeId (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_CURRENT) {
        return (ObjectTypeId | g_IsmCurrentPlatform);
    }
    return ObjectTypeId;
}


MIG_OBJECTTYPEID
FixEnumerationObjectTypeId (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_CURRENT) {
        if (g_IsmModulePlatformContext == PLATFORM_CURRENT) {
            return (ObjectTypeId | g_IsmCurrentPlatform);
        } else {
            return (ObjectTypeId | g_IsmModulePlatformContext);
        }
    }
    return ObjectTypeId;
}


BOOL
pEnablePrivilege (
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    )
{
    HANDLE token;
    BOOL b;
    TOKEN_PRIVILEGES newPrivileges;
    LUID luid;

    if (ISWIN9X ()) {
        return TRUE;
    }

    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) {
        return FALSE;
    }

    if (!LookupPrivilegeValue (NULL, PrivilegeName, &luid)) {
        CloseHandle (token);
        return FALSE;
    }

    newPrivileges.PrivilegeCount = 1;
    newPrivileges.Privileges[0].Luid = luid;
    newPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            token,
            FALSE,
            &newPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle (token);

    return b;
}

#ifdef PRERELEASE
VOID
LoadCrashHooks (
    VOID
    )
{
    HINF crashInf;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR typeName;
    PCTSTR objectName;

    crashInf = InfOpenInfFile (TEXT("c:\\crash.inf"));

    if (crashInf == INVALID_HANDLE_VALUE) {
        return;
    }

    if (InfFindFirstLine (crashInf, TEXT("TotalNumber"), NULL, &is)) {
        InfGetIntField (&is, 1, &g_CrashCountObjects);
    }
    if (InfFindFirstLine (crashInf, TEXT("TypeNumber"), NULL, &is)) {
        typeName = InfGetStringField (&is, 1);
        if (typeName) {
            g_CrashCountTypeId = IsmGetObjectTypeId (typeName);
            InfGetIntField (&is, 2, &g_CrashCountType);
        }
    }
    if (InfFindFirstLine (crashInf, TEXT("TypeObject"), NULL, &is)) {
        typeName = InfGetStringField (&is, 1);
        objectName = InfGetStringField (&is, 2);
        if (typeName && objectName) {
            g_CrashNameTypeId = IsmGetObjectTypeId (typeName);
            g_CrashNameObject = IsmGetMemory (SizeOfString (objectName));
            StringCopy ((PTSTR)g_CrashNameObject, objectName);
        }
    }
    InfCleanUpInfStruct (&is);

    InfCloseInfFile (crashInf);
}
#endif

BOOL
pWriteIsmSig (
    IN      PCTSTR DirName
    )
{
    TCHAR tempName [MAX_PATH];
    HANDLE tempHandle;
    DWORD tempSig = ISM_TMP_SIGNATURE;

    StringCopy (tempName, DirName);
    StringCopy (AppendWack (tempName), TEXT("USMT.TMP"));
    tempHandle = BfCreateFile (tempName);
    if (!tempHandle) {
        return FALSE;
    }
    if (!BfWriteFile (tempHandle, (PCBYTE)(&tempSig), sizeof (DWORD))) {
        CloseHandle (tempHandle);
        DeleteFile (tempName);
        return FALSE;
    }
    CloseHandle (tempHandle);
    return TRUE;
}

BOOL
pReadIsmSig (
    IN      PCTSTR DirName
    )
{
    TCHAR tempName [MAX_PATH];
    HANDLE tempHandle;
    DWORD tempSig;

    StringCopy (tempName, DirName);
    StringCopy (AppendWack (tempName), TEXT("USMT.TMP"));
    tempHandle = BfOpenReadFile (tempName);
    if (!tempHandle) {
        return FALSE;
    }
    if (!BfReadFile (tempHandle, (PBYTE)(&tempSig), sizeof (DWORD))) {
        CloseHandle (tempHandle);
        DeleteFile (tempName);
        return FALSE;
    }
    if (tempSig != ISM_TMP_SIGNATURE) {
        CloseHandle (tempHandle);
        DeleteFile (tempName);
        return FALSE;
    }
    CloseHandle (tempHandle);
    return TRUE;
}

BOOL
pCreateTempStorage (
    VOID
    )
{
    DRIVE_ENUM driveEnum;
    GROWBUFFER excludedDrv = INIT_GROWBUFFER;
    TCHAR driveName [4] = TEXT("");
    DWORD sectPerClust;
    DWORD bytesPerSect;
    DWORD freeClusters;
    DWORD totalClusters;
    ULONGLONG maxFreeDiskSpace = 0;
    ULONGLONG freeDiskSpace = 0;
    UINT index = 0;
    PTSTR endStr = NULL;
    BOOL found = FALSE;
    BOOL hideDir = FALSE;

    // we are going to walk the fixed drives picking up the one
    // with the most available space. In the root we are going
    // to create a directory and mark it as ours by creating a
    // special file called USMT.TMP that will have a signature in it.
    // The directory name is normally USMT.TMP. If the directory
    // already exists and does not have our special file in it
    // we are going to pick another name (USMT%04d.TMP), otherwise
    // we are going to overwrite it.

    while (!found) {

        *driveName = 0;
        maxFreeDiskSpace = 0;

        if (EnumFirstDrive (&driveEnum, DRIVEENUM_FIXED)) {
            do {
                if (IsStrInMultiSz (driveEnum.DriveName, (PCTSTR)excludedDrv.Buf)) {
                    continue;
                }
                freeDiskSpace = 0;
                if (GetDiskFreeSpace (driveEnum.DriveName, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                    freeDiskSpace = Int32x32To64 ((sectPerClust * bytesPerSect), freeClusters);
                }
                if (freeDiskSpace > maxFreeDiskSpace) {
                    StringCopyTcharCount (driveName, driveEnum.DriveName, 4);
                    maxFreeDiskSpace = freeDiskSpace;
                }
            } while (EnumNextDrive (&driveEnum));
        }

        while (index < 0xFFFF) {
            if (*driveName) {
                StringCopy (g_GlobalTempDir, driveName);
                hideDir = TRUE;
            } else {
                GetTempPath (ARRAYSIZE(g_GlobalTempDir), g_GlobalTempDir);
                hideDir = FALSE;
            }
            if (index) {
                endStr = GetEndOfString (g_GlobalTempDir);
                wsprintf (endStr, TEXT("USMT%04X.TMP"), index);
            } else {
                StringCat (g_GlobalTempDir, TEXT("USMT.TMP"));
            }
            if (!DoesFileExist (g_GlobalTempDir)) {
                if (BfCreateDirectory (g_GlobalTempDir)) {
                    if (pWriteIsmSig (g_GlobalTempDir)) {
                        found = TRUE;
                        if (hideDir) {
                            SetFileAttributes (g_GlobalTempDir, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
                        }
                        break;
                    }
                }
                // If we are here, we failed to create the temp dir
                // on this drive. This should have succeeded so this
                // means that the drive is locked down somehow.
                if (*driveName) {
                    // Let's bail out and add the drive to the exclude list.
                    GbMultiSzAppend (&excludedDrv, driveName);
                }
                break;
            }
            if (pReadIsmSig (g_GlobalTempDir)) {
                if (FiRemoveAllFilesInTree (g_GlobalTempDir)) {
                    if (BfCreateDirectory (g_GlobalTempDir)) {
                        if (pWriteIsmSig (g_GlobalTempDir)) {
                            found = TRUE;
                            if (hideDir) {
                                SetFileAttributes (g_GlobalTempDir, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
                            }
                            break;
                        }
                    }
                    // If we are here, we failed to create the temp dir
                    // on this drive. This should have succeeded so this
                    // means that the drive is locked down somehow.
                    if (*driveName) {
                        // Let's bail out and add the drive to the exclude list.
                        GbMultiSzAppend (&excludedDrv, driveName);
                    }
                    break;
                }
            }
            index ++;
        }
        if (!(*driveName)) {
            break;
        }
    }

    GbFree (&excludedDrv);

    return found;
}

BOOL
IsmGetTempStorage (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    )
{
    MYASSERT (*g_GlobalTempDir);
    if (*g_GlobalTempDir) {
        StringCopyTcharCount (Path, g_GlobalTempDir, PathTchars);
        return TRUE;
    }
    return FALSE;
}

BOOL
IsmGetTempDirectory (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    )
{
    PTSTR endStr = NULL;

    if (!IsmGetTempStorage (Path, PathTchars)) {
        return FALSE;
    }

    endStr = GetEndOfString (Path);
    while (g_TempDirIndex < 0xFFFFFFFF) {
        wsprintf (endStr, TEXT("\\DIR%04X.TMP"), g_TempDirIndex);
        if (!DoesFileExist (Path)) {
            if (BfCreateDirectory (Path)) {
                g_TempDirIndex ++;
                return TRUE;
            }
        }
        g_TempDirIndex ++;
    }
    return FALSE;
}

BOOL
IsmGetTempFile (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    )
{
    PTSTR endStr = NULL;

    if (!IsmGetTempStorage (Path, PathTchars)) {
        return FALSE;
    }

    endStr = GetEndOfString (Path);
    while (g_TempFileIndex < 0xFFFFFFFF) {
        wsprintf (endStr, TEXT("\\FILE%04X.TMP"), g_TempFileIndex);
        if (!DoesFileExist (Path)) {
            g_TempFileIndex ++;
            return TRUE;
        }
        g_TempFileIndex ++;
    }
    return FALSE;
}

BOOL
IsmInitialize (
    IN      PCTSTR InfPath,
    IN      PMESSAGECALLBACK MessageCallback,       OPTIONAL
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    BOOL result = FALSE;
    BOOL logInitError = FALSE;
    TCHAR memdbDir[MAX_TCHAR_PATH];

    g_ExecutionInProgress = TRUE;

    __try {

        SetErrorMode (SEM_FAILCRITICALERRORS);

        //
        // Initialize utilities. They produce their own debug messages.
        //

        UtInitialize (NULL);

        LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

        if (!FileEnumInitialize ()) {
            logInitError = TRUE;
            __leave;
        }

        // Initialize the temporary storage
        if (!pCreateTempStorage ()) {
            logInitError = TRUE;
            __leave;
        }

        if (!IsmGetTempDirectory (memdbDir, ARRAYSIZE (memdbDir))) {
            logInitError = TRUE;
            __leave;
        }

        if (!MemDbInitializeEx (memdbDir)) {
            logInitError = TRUE;
            __leave;
        }

        if (!RegInitialize ()) {
            logInitError = TRUE;
            __leave;
        }

        RegInitializeCache (8);

        InfGlobalInit (FALSE);

        //
        // Turn on privileges
        //

        if (!pEnablePrivilege (SE_BACKUP_NAME, TRUE)) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_BACKUP_PRIVLEDGE));
            __leave;
        }

        if (!pEnablePrivilege (SE_RESTORE_NAME, TRUE)) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_RESTORE_PRIVLEDGE));
            __leave;
        }

        //
        // Initialize ISM globals
        //

        g_CancelEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
        if (!g_CancelEvent) {
            DEBUGMSG ((DBG_ERROR, "Can't create cancel event"));
            __leave;
        }

        g_ActivityEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
        if (!g_ActivityEvent) {
            DEBUGMSG ((DBG_ERROR, "Can't create activity event"));
            CloseHandle (g_CancelEvent);
            __leave;
        }

        g_TransportTable = HtAllocWithData (sizeof (PTRANSPORTDATA));
        g_ControlFileTable = HtAlloc ();

        g_IsmInf = InfOpenInfFile (InfPath);

        if (g_IsmInf == INVALID_HANDLE_VALUE) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INVALID_ISM_INF, InfPath));
            SetLastError (ERROR_FILE_NOT_FOUND);
            __leave;
        }

        if (!g_IsmPool) {
            g_IsmPool = PmCreateNamedPool ("ISM Pool");
        }

        if (!g_IsmUntrackedPool) {
            g_IsmUntrackedPool = PmCreatePool ();
            PmDisableTracking (g_IsmUntrackedPool);
        }

        //
        // Initialize internal modules
        //

        if (!InitializeEnv ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 1));
            __leave;
        }

        if (!InitializeFlowControl ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 3));
            __leave;
        }

        PrepareEnumerationEnvironment (TRUE);

        if (!InitializeTypeMgr ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 2));
            __leave;
        }

        if (!InitializeOperations ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 4));
            __leave;
        }

        g_MessageCallback = MessageCallback;

        //
        // Set the journal location
        //
        IsmSetRollbackJournalType (TRUE);

        g_PreProcessTable = HtAllocWithData (sizeof (PCTSTR));
        g_RefreshTable = HtAllocWithData (sizeof (PCTSTR));
        g_PostProcessTable = HtAllocWithData (sizeof (PCTSTR));

        g_EngineInitialized = TRUE;
        result = TRUE;
    }
    __finally {
        g_ExecutionInProgress = FALSE;

        if (!result) {
            IsmTerminate();
        }
    }

    if (logInitError) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_ENGINE_INIT_FAILURE));
    }

    return result;
}

BOOL
IsmSetPlatform (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    OSVERSIONINFO versionInfo;
    MIG_OSVERSIONINFO migVerInfo;
    TCHAR tempStr [sizeof (UINT) * 2 + 3];
    MIG_OBJECTSTRINGHANDLE tempHandle = NULL;

    if (Platform == PLATFORM_SOURCE) {

        if (!RegisterInternalAttributes ()) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 5));
            return FALSE;
        }

    }

    //
    // write the source or the destination machine version information
    // in the environment
    //

    ZeroMemory (&versionInfo, sizeof (OSVERSIONINFO));
    versionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    ZeroMemory (&migVerInfo, sizeof (MIG_OSVERSIONINFO));

    if (GetVersionEx (&versionInfo)) {
        if (versionInfo.dwPlatformId == 1) {
            migVerInfo.OsType = OSTYPE_WINDOWS9X;
            migVerInfo.OsTypeName = OSTYPE_WINDOWS9X_STR;
            if (versionInfo.dwMajorVersion == 4) {
                if (versionInfo.dwMinorVersion == 0) {
                    migVerInfo.OsMajorVersion = OSMAJOR_WIN95;
                    migVerInfo.OsMajorVersionName = OSMAJOR_WIN95_STR;
                    migVerInfo.OsMinorVersion = OSMINOR_GOLD;
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                    if (LOWORD (versionInfo.dwBuildNumber) >= 1111) {
                        migVerInfo.OsMajorVersion = OSMAJOR_WIN95OSR2;
                        migVerInfo.OsMajorVersionName = OSMAJOR_WIN95OSR2_STR;
                    }
                } else if (versionInfo.dwMinorVersion == 10) {
                    migVerInfo.OsMajorVersion = OSMAJOR_WIN98;
                    migVerInfo.OsMajorVersionName = OSMAJOR_WIN98_STR;
                    migVerInfo.OsMinorVersion = OSMINOR_GOLD;
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                    if (LOWORD (versionInfo.dwBuildNumber) >= 2222) {
                        migVerInfo.OsMinorVersion = OSMINOR_WIN98SE;
                        migVerInfo.OsMinorVersionName = OSMINOR_WIN98SE_STR;
                    }
                } else if (versionInfo.dwMinorVersion == 90) {
                    migVerInfo.OsMajorVersion = OSMAJOR_WINME;
                    migVerInfo.OsMajorVersionName = OSMAJOR_WINME_STR;
                    migVerInfo.OsMinorVersion = OSMINOR_GOLD;
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                }
            }
        }
        if (versionInfo.dwPlatformId == 2) {
            migVerInfo.OsType = OSTYPE_WINDOWSNT;
            migVerInfo.OsTypeName = OSTYPE_WINDOWSNT_STR;
            if (versionInfo.dwMajorVersion == 4) {
                migVerInfo.OsMajorVersion = OSMAJOR_WINNT4;
                migVerInfo.OsMajorVersionName = OSMAJOR_WINNT4_STR;
                migVerInfo.OsMinorVersion = versionInfo.dwMinorVersion;
                if (migVerInfo.OsMinorVersion == OSMINOR_GOLD) {
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                }
            }
            if (versionInfo.dwMajorVersion == 5) {
                migVerInfo.OsMajorVersion = OSMAJOR_WINNT5;
                migVerInfo.OsMajorVersionName = OSMAJOR_WINNT5_STR;
                migVerInfo.OsMinorVersion = versionInfo.dwMinorVersion;
                if (migVerInfo.OsMinorVersion == OSMINOR_GOLD) {
                    migVerInfo.OsMinorVersionName = OSMINOR_GOLD_STR;
                } else if (migVerInfo.OsMinorVersion == OSMINOR_WINNT51) {
                    migVerInfo.OsMinorVersionName = OSMINOR_WINNT51_STR;
                }
            }
        }
        wsprintf (tempStr, TEXT("0x%08X"), migVerInfo.OsType);
        IsmSetEnvironmentString (Platform, NULL, S_VER_OSTYPE, tempStr);
        wsprintf (tempStr, TEXT("0x%08X"), migVerInfo.OsMajorVersion);
        IsmSetEnvironmentString (Platform, NULL, S_VER_OSMAJOR, tempStr);
        wsprintf (tempStr, TEXT("0x%08X"), migVerInfo.OsMinorVersion);
        IsmSetEnvironmentString (Platform, NULL, S_VER_OSMINOR, tempStr);
        wsprintf (tempStr, TEXT("0x%08X"), versionInfo.dwBuildNumber);
        IsmSetEnvironmentString (Platform, NULL, S_VER_OSBUILD, tempStr);
    }

    if (Platform == PLATFORM_SOURCE) {
        // let's exclude our temporary directory
        tempHandle = IsmCreateObjectHandle (g_GlobalTempDir, NULL);
        if (tempHandle) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, tempHandle);
            IsmDestroyObjectHandle (tempHandle);
            tempHandle = NULL;
        }
    }

    g_IsmCurrentPlatform = Platform;
    return TRUE;
}

BOOL
pPrepareUserJournal (
    IN OUT  PTEMPORARYPROFILE UserProfile
    )
{
    BOOL result = FALSE;
    DWORD tempField;
    PCTSTR journalFile = NULL;

    if (UserProfile && UserProfile->UserProfileRoot) {
        __try {
            UserProfile->DelayedOpJrn = JoinPaths (UserProfile->UserProfileRoot, TEXT("usrusmt2.tmp"));
            FiRemoveAllFilesInTree (UserProfile->DelayedOpJrn);
            if (!BfCreateDirectory (UserProfile->DelayedOpJrn)) {
                __leave;
            }
            journalFile = JoinPaths (UserProfile->DelayedOpJrn, TEXT("JOURNAL.DAT"));
            UserProfile->DelayedOpJrnHandle = BfCreateFile (journalFile);
            if (UserProfile->DelayedOpJrnHandle == INVALID_HANDLE_VALUE) {
                __leave;
            }
            tempField = JRN_USR_SIGNATURE;
            BfWriteFile (UserProfile->DelayedOpJrnHandle, (PBYTE)(&tempField), sizeof (DWORD));
            tempField = JRN_USR_VERSION;
            BfWriteFile (UserProfile->DelayedOpJrnHandle, (PBYTE)(&tempField), sizeof (DWORD));
            tempField = JRN_USR_DIRTY;
            BfWriteFile (UserProfile->DelayedOpJrnHandle, (PBYTE)(&tempField), sizeof (DWORD));
            FlushFileBuffers (UserProfile->DelayedOpJrnHandle);
            FreePathString (journalFile);
            result = TRUE;
        }
        __finally {
            if (!result) {
                if (UserProfile->DelayedOpJrn) {
                    FreePathString (UserProfile->DelayedOpJrn);
                    UserProfile->DelayedOpJrn = NULL;
                }
                if (!UserProfile->DelayedOpJrnHandle || (UserProfile->DelayedOpJrnHandle == INVALID_HANDLE_VALUE)) {
                    CloseHandle (UserProfile->DelayedOpJrnHandle);
                    UserProfile->DelayedOpJrnHandle = NULL;
                }
            }
        }
    }
    return result;
}

BOOL
pValidateUserJournal (
    IN      PTEMPORARYPROFILE UserProfile,
    IN      BOOL RunKeyAdded
    )
{
    BOOL result = FALSE;
    DWORD tempField;

    __try {
        if (UserProfile->DelayedOpJrn) {
            if (RunKeyAdded) {
                if (UserProfile->DelayedOpJrnHandle && (UserProfile->DelayedOpJrnHandle != INVALID_HANDLE_VALUE)) {
                    if (!BfSetFilePointer (UserProfile->DelayedOpJrnHandle, 2 * sizeof (DWORD))) {
                        __leave;
                    }
                    tempField = JRN_USR_COMPLETE;
                    BfWriteFile (UserProfile->DelayedOpJrnHandle, (PBYTE)(&tempField), sizeof (DWORD));
                    FlushFileBuffers (UserProfile->DelayedOpJrnHandle);
                    result = TRUE;
                }
            } else {
                // Run key command was not added, no point to
                // keep this journal here
                FiRemoveAllFilesInTree (UserProfile->DelayedOpJrn);
                result = TRUE;
            }
        }
    }
    __finally {
        if (UserProfile->DelayedOpJrnHandle && (UserProfile->DelayedOpJrnHandle != INVALID_HANDLE_VALUE)) {
            CloseHandle (UserProfile->DelayedOpJrnHandle);
            UserProfile->DelayedOpJrnHandle = NULL;
        }
        if (UserProfile->DelayedOpJrn) {
            FreePathString (UserProfile->DelayedOpJrn);
            UserProfile->DelayedOpJrn = NULL;
        }
    }
    return result;
}

BOOL
pWriteDelayedOperationsCommand (
    IN      PTEMPORARYPROFILE UserProfile
    )
{
    HKEY runKeyHandle = NULL;
    PCTSTR runKeyStr = NULL;
    LONG rc;
    BOOL result = FALSE;

    __try {
        if (!UserProfile->MapKey) {
            LOG ((LOG_ERROR, (PCSTR) MSG_NO_MAPPED_USER));
            __leave;
        }
        runKeyStr = JoinPathsInPoolEx ((
                        NULL,
                        TEXT("HKEY_USERS"),
                        UserProfile->MapKey,
                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"),
                        NULL
                        ));
        runKeyHandle = CreateRegKeyStr (runKeyStr);
        if (!runKeyHandle) {
            LOG ((LOG_ERROR, (PCSTR) MSG_RUN_KEY_CREATE_FAILURE));
            __leave;
        }
        rc = RegSetValueEx (
                runKeyHandle,
                TEXT("USMT2RUN"),
                0,
                REG_EXPAND_SZ,
                (PBYTE) g_DelayedOperationsCommand,
                SizeOfString (g_DelayedOperationsCommand)
                );
        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, (PCSTR) MSG_RUN_KEY_CREATE_FAILURE));
            __leave;
        }
        result = TRUE;
    }
    __finally {
        if (runKeyHandle) {
            CloseRegKey (runKeyHandle);
            runKeyHandle = NULL;
        }
        if (runKeyStr) {
            FreePathString (runKeyStr);
            runKeyStr = NULL;
        }
    }
    return result;
}

BOOL
pDeleteDelayedOperationsCommand (
    VOID
    )
{
    HKEY runKeyHandle = NULL;
    LONG rc;
    BOOL result = FALSE;

    __try {
        runKeyHandle = OpenRegKeyStr (TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"));
        if (!runKeyHandle) {
            LOG ((LOG_ERROR, (PCSTR) MSG_RUN_KEY_DELETE_FAILURE));
            __leave;
        }
        rc = RegDeleteValue (
                runKeyHandle,
                TEXT("USMT2RUN")
                );
        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, (PCSTR) MSG_RUN_KEY_DELETE_FAILURE));
            __leave;
        }
        result = TRUE;
    }
    __finally {
        if (runKeyHandle) {
            CloseRegKey (runKeyHandle);
            runKeyHandle = NULL;
        }
    }
    return result;
}

VOID
IsmTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    BOOL runKeyAdded = FALSE;

    if (g_EngineTerminated) {
        g_EngineInitialized = FALSE;
        return;
    }

    // We need to try and terminate properties. In some cases the property file
    // remains opened.
    TerminateProperties (g_IsmCurrentPlatform);

    if (g_PreProcessTable) {
        if (EnumFirstHashTableString (&e, g_PreProcessTable)) {
            do {
                IsmReleaseMemory (*((PCTSTR *)e.ExtraData));
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_PreProcessTable);
        g_PreProcessTable = NULL;
    }

    if (g_RefreshTable) {
        if (EnumFirstHashTableString (&e, g_RefreshTable)) {
            do {
                if (!CheckCancel () && g_PreProcessDone) {
                    IsmSendMessageToApp (ISMMESSAGE_EXECUTE_REFRESH, (ULONG_PTR) *((PCTSTR *)e.ExtraData));
                }
                IsmReleaseMemory (*((PCTSTR *)e.ExtraData));
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_RefreshTable);
        g_RefreshTable = NULL;
    }

    if (g_PostProcessTable) {
        if (EnumFirstHashTableString (&e, g_PostProcessTable)) {
            do {
                if (g_PreProcessDone) {
                    IsmSendMessageToApp (ISMMESSAGE_EXECUTE_POSTPROCESS, (ULONG_PTR) *((PCTSTR *)e.ExtraData));
                }
                IsmReleaseMemory (*((PCTSTR *)e.ExtraData));
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_PostProcessTable);
        g_PostProcessTable = NULL;
    }
    g_PreProcessDone = FALSE;

    g_EngineInitialized = FALSE;

    g_ExecutionInProgress = TRUE;

    //
    // Terminate plug-in modules
    //

    TerminateProcessWideModules();

    //
    // Clean up journal
    //

    if (g_JournalDirectory && !g_PreserveJournal) {
        if (DoesFileExist (g_JournalDirectory)) {
            if (!FiRemoveAllFilesInTree (g_JournalDirectory)) {
                DEBUGMSG ((DBG_ERROR, "Cannot remove journal directory: %s", g_JournalDirectory));
            }
        }
        FreePathString (g_JournalDirectory);
        g_JournalDirectory = NULL;
        g_JournalUsed = FALSE;
    }

    if (g_TempProfile) {

        // let's write the Run key command line and set runKeyAdded to TRUE
        runKeyAdded = pWriteDelayedOperationsCommand (g_TempProfile);
        pValidateUserJournal (g_TempProfile, runKeyAdded);
        if (!CloseTemporaryProfile (g_TempProfile, g_MakeProfilePermanent)) {
            LOG ((
                LOG_MODULE_ERROR,
                (PCSTR) MSG_CANT_SAVE_PROFILE,
                g_TempProfile->UserName,
                GetLastError()
                ));
            CloseTemporaryProfile (g_TempProfile, FALSE);
        }
        g_TempProfile = NULL;
    }

    if (g_DelayedOperationsCommand) {
        FreePathString (g_DelayedOperationsCommand);
        g_DelayedOperationsCommand = NULL;
    }

    //
    // Terminate all control files
    //
    if (g_ControlFileTable) {
        if (EnumFirstHashTableString (&e, g_ControlFileTable)) {
            do {
                DeleteFile (e.String);
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_ControlFileTable);
        g_ControlFileTable = NULL;
    }

    //
    // Terminate internal modules
    //

    ClearEnumerationEnvironment (TRUE);

    TerminateEnv ();
    TerminateTypeMgr ();
    TerminateFlowControl ();
    TerminateOperations ();

    //
    // Destroy globals
    //

    pFreeRestoreCallbacks ();

    pFreeCompareCallbacks ();

    if (g_CancelEvent) {
        CloseHandle (g_CancelEvent);
        g_CancelEvent = NULL;
    }

    if (g_ActivityEvent) {
        CloseHandle (g_ActivityEvent);
        g_ActivityEvent = NULL;
    }

    GbFree (&g_SliceBuffer);

    if (g_TransportTable) {
        HtFree (g_TransportTable);
        g_TransportTable = NULL;
    }

    if (g_IsmPool) {
        PmDestroyPool (g_IsmPool);
        g_IsmPool = NULL;
    }

    if (g_IsmUntrackedPool) {
        PmDestroyPool (g_IsmUntrackedPool);
        g_IsmUntrackedPool = NULL;
    }

    if (g_IsmInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_IsmInf);
        g_IsmInf = INVALID_HANDLE_VALUE;
    }

    InfGlobalInit (TRUE);

    MemDbTerminateEx (TRUE);        // relies on fileenum

    // let's remove the temporary storage, it's here because uses fileenum
    if (*g_GlobalTempDir) {
        if (!FiRemoveAllFilesInTree (g_GlobalTempDir)) {
            DEBUGMSG ((DBG_ERROR, "Cannot remove temporary storage: %s", g_GlobalTempDir));
        }
        *g_GlobalTempDir = 0;
    }

    FileEnumTerminate ();

    RegTerminate ();

    UtTerminate ();

    g_EngineTerminated = TRUE;
    g_ExecutionInProgress = FALSE;
}

BOOL
IsmPreserveJournal (
    IN      BOOL Preserve
    )
{
    BOOL result = g_PreserveJournal;
    g_PreserveJournal = Preserve;
    return result;
}

BOOL
pEtmParse (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    PETMDATA etmData;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Call the parse entry point
    //

    if (EnumFirstHashTableString (&e, g_EtmTable)) {
        do {

            etmData = *((PETMDATA *) e.ExtraData);

            if (etmData->ShouldBeCalled && etmData->EtmParse) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = etmData->Group;

                b = etmData->EtmParse (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }
    ClearEnumerationEnvironment (FALSE);

    return b;
}

BOOL
pCreateComputerParse (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    PVCMDATA vcmData;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Call the parse entry point
    //

    if (EnumFirstHashTableString (&e, g_VcmTable)) {
        do {

            vcmData = *((PVCMDATA *) e.ExtraData);

            if (vcmData->ShouldBeCalled && vcmData->VcmParse) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = vcmData->Group;

                b = vcmData->VcmParse (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }
    ClearEnumerationEnvironment (FALSE);

    return b;
}

BOOL
pCreateComputerGather (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PVCMDATA vcmData;
    UINT containers;
    MIG_PROGRESSSLICEID sliceId;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Queue high priority enumerations
    //

    if (b && EnumFirstHashTableString (&e, g_VcmTable)) {
        do {

            vcmData = *((PVCMDATA *) e.ExtraData);

            if (vcmData->ShouldBeCalled && vcmData->VcmQueueHighPriorityEnumeration) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = vcmData->Group;

                b = vcmData->VcmQueueHighPriorityEnumeration (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    g_CurrentPhase = MIG_HIGHPRIORITYGATHER_PHASE;
    g_SliceBuffer.End = 0;
    containers = EstimateAllObjectEnumerations (0, FALSE);

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    //
    // Run high priority enumeration queue
    //

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during high priority object enumeration."));
            b = FALSE;
        }
    }

    pCallProgressBar (MIG_END_PHASE);
    ClearEnumerationEnvironment (FALSE);

    PrepareEnumerationEnvironment (FALSE);

    //
    // Queue normal priority enumerations
    //

    if (b && EnumFirstHashTableString (&e, g_VcmTable)) {
        do {

            vcmData = *((PVCMDATA *) e.ExtraData);

            if (vcmData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = vcmData->Group;

                b = vcmData->VcmQueueEnumeration (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    g_CurrentPhase = MIG_GATHER_PHASE;
    g_SliceBuffer.End = 0;
    containers = EstimateAllObjectEnumerations (0, FALSE);

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    //
    // Run normal priority enumeration queue
    //

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during object enumeration."));
            b = FALSE;
        }
    }

    ClearEnumerationEnvironment (FALSE);
    pCallProgressBar (MIG_END_PHASE);

    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    return b;
}

BOOL
pSourceParse (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    PSGMDATA sgmData;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Call the parse entry point
    //

    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled && sgmData->SgmParse) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = sgmData->Group;

                b = sgmData->SgmParse (Reserved);

                g_CurrentGroup = NULL;
            }

        } while (b && EnumNextHashTableString (&e));
    }
    ClearEnumerationEnvironment (FALSE);

    return b;
}

BOOL
pSourceGather (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PSGMDATA sgmData;
    UINT containers;
    MIG_PROGRESSSLICEID sliceId;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Estimate the queue high priority enumerations
    //

    containers = 0;
    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled && sgmData->SgmQueueHighPriorityEnumeration) {

                containers ++;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Queue high priority enumerations
    //

    g_CurrentPhase = MIG_HIGHPRIORITYQUEUE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled && sgmData->SgmQueueHighPriorityEnumeration) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = sgmData->Group;

                b = sgmData->SgmQueueHighPriorityEnumeration (Reserved);

                g_CurrentGroup = NULL;

                // Call progress bar
                IsmTickProgressBar (sliceId, 1);
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);

    //
    // Estimate the high priority enumerations estimate
    //

    containers = EstimateAllObjectEnumerations (0, TRUE);

    //
    // Estimate the high priority enumerations
    //

    g_CurrentPhase = MIG_HIGHPRIORITYESTIMATE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    containers = EstimateAllObjectEnumerations (sliceId, FALSE);

    pCallProgressBar (MIG_END_PHASE);

    //
    // Run high priority enumeration queue
    //

    g_CurrentPhase = MIG_HIGHPRIORITYGATHER_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during high priority object enumeration."));
            b = FALSE;
        }
    }

    pCallProgressBar (MIG_END_PHASE);

    ClearEnumerationEnvironment (FALSE);

    PrepareEnumerationEnvironment (FALSE);

    //
    // Estimate the queue normal priority enumerations
    //

    containers = 0;
    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled) {

                containers ++;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Queue normal priority enumerations
    //

    g_CurrentPhase = MIG_GATHERQUEUE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b && EnumFirstHashTableString (&e, g_SgmTable)) {
        do {

            sgmData = *((PSGMDATA *) e.ExtraData);

            if (sgmData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = sgmData->Group;

                b = sgmData->SgmQueueEnumeration (Reserved);

                g_CurrentGroup = NULL;

                // Call progress bar
                IsmTickProgressBar (sliceId, 1);
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);

    //
    // Estimate the normal priority enumerations estimate
    //

    containers = EstimateAllObjectEnumerations (0, TRUE);

    //
    // Estimate the normal priority enumerations
    //

    g_CurrentPhase = MIG_GATHERESTIMATE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    containers = EstimateAllObjectEnumerations (sliceId, FALSE);

    pCallProgressBar (MIG_END_PHASE);

    //
    // Run normal priority enumeration queue
    //

    g_CurrentPhase = MIG_GATHER_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during object enumeration."));
            b = FALSE;
        }
    }

    ClearEnumerationEnvironment (FALSE);
    pCallProgressBar (MIG_END_PHASE);

    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    return b;
}


BOOL
pSourceAnalyze (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PSAMDATA samData;
    UINT modulesNeedingProgress = 0;
    MIG_PROGRESSSLICEID sliceId = 0;

    //
    // Prepare a progress bar
    //

    g_CurrentPhase = MIG_ANALYSIS_PHASE;
    g_SliceBuffer.End = 0;

    if (b && EnumFirstHashTableString (&e, g_SamTable)) {
        do {

            samData = *((PSAMDATA *) e.ExtraData);

            if (samData->ShouldBeCalled) {
                if (samData->SamEstimateProgressBar) {
                    samData->SamEstimateProgressBar();
                } else {
                    modulesNeedingProgress++;
                }
            }

        } while (b && EnumNextHashTableString (&e));
    }

    if (modulesNeedingProgress) {
        sliceId = IsmRegisterProgressSlice (
                        modulesNeedingProgress,
                        modulesNeedingProgress * 10
                        );
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    //
    // Run all the registered SAMs
    //

    if (b && EnumFirstHashTableString (&e, g_SamTable)) {
        do {

            samData = *((PSAMDATA *) e.ExtraData);

            if (samData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = samData->Group;

                b = samData->SamExecute();

                g_CurrentGroup = NULL;

                if (!samData->SamEstimateProgressBar) {
                    if (!IsmTickProgressBar (sliceId, 1)) {
                        b = FALSE;
                    }
                }
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);
    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    return b;
}


BOOL
pDestinationGather (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PDGMDATA dgmData;
    UINT containers;
    MIG_PROGRESSSLICEID sliceId;

    PrepareEnumerationEnvironment (FALSE);

    //
    // Estimate the queue high priority enumerations
    //

    containers = 0;
    if (b && EnumFirstHashTableString (&e, g_DgmTable)) {
        do {

            dgmData = *((PDGMDATA *) e.ExtraData);

            if (dgmData->ShouldBeCalled && dgmData->DgmQueueHighPriorityEnumeration) {

                containers ++;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Queue high priority enumerations
    //

    g_CurrentPhase = MIG_HIGHPRIORITYQUEUE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b && EnumFirstHashTableString (&e, g_DgmTable)) {
        do {

            dgmData = *((PDGMDATA *) e.ExtraData);

            if (dgmData->ShouldBeCalled && dgmData->DgmQueueHighPriorityEnumeration) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = dgmData->Group;

                b = dgmData->DgmQueueHighPriorityEnumeration (Reserved);

                g_CurrentGroup = NULL;

                // Call progress bar
                IsmTickProgressBar (sliceId, 1);
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);

    //
    // Estimate the high priority enumerations estimate
    //

    containers = EstimateAllObjectEnumerations (0, TRUE);

    //
    // Estimate the high priority enumerations
    //

    g_CurrentPhase = MIG_HIGHPRIORITYESTIMATE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    containers = EstimateAllObjectEnumerations (sliceId, FALSE);

    pCallProgressBar (MIG_END_PHASE);

    //
    // Run high priority enumeration queue
    //

    g_CurrentPhase = MIG_HIGHPRIORITYGATHER_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during high priority object enumeration."));
            b = FALSE;
        }
    }

    pCallProgressBar (MIG_END_PHASE);

    ClearEnumerationEnvironment (FALSE);

    PrepareEnumerationEnvironment (FALSE);

    //
    // Estimate the queue normal priority enumerations
    //

    containers = 0;
    if (b && EnumFirstHashTableString (&e, g_DgmTable)) {
        do {

            dgmData = *((PDGMDATA *) e.ExtraData);

            if (dgmData->ShouldBeCalled) {

                containers ++;
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Queue normal priority enumerations
    //

    g_CurrentPhase = MIG_GATHERQUEUE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b && EnumFirstHashTableString (&e, g_DgmTable)) {
        do {

            dgmData = *((PDGMDATA *) e.ExtraData);

            if (dgmData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = dgmData->Group;

                b = dgmData->DgmQueueEnumeration (Reserved);

                g_CurrentGroup = NULL;

                // Call progress bar
                IsmTickProgressBar (sliceId, 1);
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);

    //
    // Estimate the normal priority enumerations estimate
    //

    containers = EstimateAllObjectEnumerations (0, TRUE);

    //
    // Estimate the normal priority enumerations
    //

    g_CurrentPhase = MIG_GATHERESTIMATE_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    containers = EstimateAllObjectEnumerations (sliceId, FALSE);

    pCallProgressBar (MIG_END_PHASE);

    //
    // Run normal priority enumeration queue
    //

    g_CurrentPhase = MIG_GATHER_PHASE;
    g_SliceBuffer.End = 0;

    if (containers) {
        sliceId = IsmRegisterProgressSlice (containers, containers * 5);
    } else {
        sliceId = 0;
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    if (b) {

        if (!DoAllObjectEnumerations (sliceId)) {
            DEBUGMSG ((DBG_ERROR, "Internal ISM Error during object enumeration."));
            b = FALSE;
        }
    }

    ClearEnumerationEnvironment (FALSE);
    pCallProgressBar (MIG_END_PHASE);

    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    return b;
}


BOOL
ShouldObjectBeRestored (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )

/*++

Routine Description:

  ShouldObjectBeRestored determines if a specific object should be restored
  at all.  It first checks if the object is marked for apply, and then checks
  all restore callbacks to allow them to deny the restore.

Arguments:

  ObjectTypeId - Specifies the object type
  ObjectId     - Specifies the numeric ID of the object
  ObjectName   - Specifies the encoded node and leaf of the object

Return Value:

  TRUE if the object should be restored, FALSE otherwise

--*/

{
    BOOL result = TRUE;
    MIG_RESTORECALLBACK_ENUM restoreEnum;

    //
    // Is object marked for apply?
    //

    if (!IsmIsApplyObjectId (ObjectId)) {
        return FALSE;
    }

    //
    // Call callbacks to allow them to deny restore
    //

    if (EnumFirstRestoreCallback (&restoreEnum)) {
        do {
            if (!restoreEnum.RestoreCallback (ObjectTypeId, ObjectId, ObjectName)) {
                result = FALSE;
                break;
            }
        } while (EnumNextRestoreCallback (&restoreEnum));
    }

    return result;
}


BOOL
pDestinationAnalyze (
    IN      PVOID Reserved
    )
{
    HASHTABLE_ENUM e;
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    PDAMDATA damData;
    PCSMDATA csmData;
    UINT modulesNeedingProgress = 0;
    MIG_PROGRESSSLICEID sliceId = 0;

    //
    // Prepare a progress bar
    //

    g_CurrentPhase = MIG_ANALYSIS_PHASE;
    g_SliceBuffer.End = 0;

    if (EnumFirstHashTableString (&e, g_DamTable)) {
        do {

            damData = *((PDAMDATA *) e.ExtraData);

            if (damData->ShouldBeCalled) {
                if (damData->DamEstimateProgressBar) {
                    damData->DamEstimateProgressBar();
                } else {
                    modulesNeedingProgress++;
                }
            }

        } while (EnumNextHashTableString (&e));
    }
    if (EnumFirstHashTableString (&e, g_CsmTable)) {
        do {

            csmData = *((PCSMDATA *) e.ExtraData);

            if (csmData->ShouldBeCalled) {
                if (csmData->CsmEstimateProgressBar) {
                    csmData->CsmEstimateProgressBar();
                } else {
                    modulesNeedingProgress++;
                }
            }

        } while (EnumNextHashTableString (&e));
    }

    if (modulesNeedingProgress) {
        sliceId = IsmRegisterProgressSlice (
                        modulesNeedingProgress,
                        modulesNeedingProgress * 10
                        );
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    //
    // Run all the registered DAMs
    //

    if (EnumFirstHashTableString (&e, g_DamTable)) {
        do {

            damData = *((PDAMDATA *) e.ExtraData);

            if (damData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = damData->Group;

                b = damData->DamExecute();

                g_CurrentGroup = NULL;

                if (!damData->DamEstimateProgressBar) {
                    if (!IsmTickProgressBar (sliceId, 1)) {
                        b = FALSE;
                    }
                }
            }

        } while (b && EnumNextHashTableString (&e));
    }

    //
    // Run all the registered CSMs
    //

    if (EnumFirstHashTableString (&e, g_CsmTable)) {
        do {

            csmData = *((PCSMDATA *) e.ExtraData);

            if (csmData->ShouldBeCalled) {
                MYASSERT (!g_CurrentGroup);
                g_CurrentGroup = csmData->Group;

                b = csmData->CsmExecute();

                g_CurrentGroup = NULL;

                if (!csmData->CsmEstimateProgressBar) {
                    if (!IsmTickProgressBar (sliceId, 1)) {
                        b = FALSE;
                    }
                }
            }

        } while (b && EnumNextHashTableString (&e));
    }

    pCallProgressBar (MIG_END_PHASE);
    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;
    return b;
}

BOOL
pTestShortFileName (
    IN      PCTSTR FileName,
    IN      PCTSTR TempDir
    )
{
    PCTSTR testFileName;
    HANDLE fileHandle;
    WIN32_FIND_DATA fileInfo;
    BOOL result = FALSE;

    testFileName = JoinPaths (TempDir, FileName);
    fileHandle = BfCreateFile (testFileName);
    if (fileHandle) {
        CloseHandle (fileHandle);
        if (DoesFileExistEx (testFileName, &fileInfo)) {
            result = (fileInfo.cAlternateFileName [0] == 0) ||
                     StringIMatch (fileInfo.cFileName, fileInfo.cAlternateFileName);
        }
        DeleteFile (testFileName);
    }
    FreePathString (testFileName);
    return result;
}

BOOL
pIsShortFileName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR TempDir,
    IN      PCTSTR FullKeyName,
    IN OUT  KEYHANDLE *KeyHandle
    )
{
    PCTSTR node, leaf;
    PTSTR nodePtr;
    PTSTR fullKeyName;
    MEMDB_ENUM memDbEnum;
    BOOL result = FALSE;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (leaf) {
            result = pTestShortFileName (leaf, TempDir);
        } else {
            fullKeyName = DuplicatePathString (FullKeyName, 0);
            nodePtr = _tcsrchr (fullKeyName, TEXT('\\'));
            if (nodePtr) {
                *nodePtr = 0;
                nodePtr = _tcsrchr (fullKeyName, TEXT('\\'));
                if (nodePtr) {
                    result = pTestShortFileName (nodePtr, TempDir);
                    if (!result && MemDbEnumFirst (&memDbEnum, fullKeyName, ENUMFLAG_ALL, ENUMLEVEL_LASTLEVEL, ENUMLEVEL_ALLLEVELS)) {
                        *KeyHandle = memDbEnum.KeyHandle;
                        MemDbAbortEnum (&memDbEnum);
                    } else {
                        result = TRUE;
                    }
                }
            }
            FreePathString (fullKeyName);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
pFixFileEnumerationOrder (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR TempDir
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    PCTSTR decoratedPath;
    MEMDB_ENUM memDbEnum;
    GROWBUFFER moveHandles = INIT_GROWBUFFER;
    KEYHANDLE keyHandle;
    PDWORD moveHandle = NULL;
    BOOL result = FALSE;

    objectTypeId = MIG_FILE_TYPE | Platform;
    decoratedPath = GetDecoratedObjectPathFromName (objectTypeId, TEXT("*"), TRUE);
    if (decoratedPath) {
        if (MemDbEnumFirst (&memDbEnum, decoratedPath, ENUMFLAG_NORMAL, 1, ENUMLEVEL_ALLLEVELS)) {
            do {
                if (IsmCheckCancel()) {
                    return FALSE;
                }
                keyHandle = memDbEnum.KeyHandle;
                if (!pIsShortFileName (objectTypeId, memDbEnum.KeyName, TempDir, memDbEnum.FullKeyName, &keyHandle)) {
                    GbAppendDword (&moveHandles, keyHandle);
                }
            } while (MemDbEnumNext (&memDbEnum));
        }
        GbAppendDword (&moveHandles, 0);
        moveHandle = (PDWORD)moveHandles.Buf;
        while (*moveHandle) {
            if (IsmCheckCancel()) {
                return FALSE;
            }
            MemDbMoveKeyHandleToEnd (*moveHandle);
            moveHandle ++;
        }
        FreePathString (decoratedPath);
    }

    GbFree (&moveHandles);

    return result;
}

BOOL
pDestinationApply (
    IN      PVOID Reserved
    )
{
    BOOL b = TRUE;
    BOOL cancelled = FALSE;
    MIG_OBJECTTYPEID objTypeId;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE objPattern = NULL;
    BOOL toProcess = FALSE;
    MIG_PROGRESSSLICEID sliceId = 0;
    UINT ticks;
    LONG failCode;
    BOOL runKeyAdded = FALSE;
    MIG_OBJECTTYPEID fileTypeId;
    TCHAR tempDir [MAX_PATH] = TEXT("");
    BOOL deleteFailed = FALSE;
    TCHAR delayedDeleteKey [] = TEXT("DelayedDelete");
    KEYHANDLE delayedDeleteHandle;
    MIG_OBJECTID delayedDeleteId;
    PUINT delayedDeleteList;
    UINT delayedDeleteListNo;
    UINT delayedDeleteIndex;
    MIG_OBJECTSTRINGHANDLE delayedObjectName = NULL;
    MIG_OBJECTTYPEID delayedObjectTypeId;
    HASHTABLE_ENUM e;
    ERRUSER_EXTRADATA extraData;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;

    g_CurrentPhase = MIG_APPLY_PHASE;
    g_SliceBuffer.End = 0;

    ticks = g_DestinationObjects.TotalObjects +
            g_SourceObjects.TotalObjects +
            g_DestinationObjects.TotalObjects;

    if (ticks) {
        sliceId = IsmRegisterProgressSlice (ticks, max (1, ticks / 10));
    } else {
        sliceId = IsmRegisterProgressSlice (1, 30);
    }

    pCallProgressBar (MIG_BEGIN_PHASE);

    // let's execute PreProcess functions
    if (g_PreProcessTable) {
        if (EnumFirstHashTableString (&e, g_PreProcessTable)) {
            do {
                IsmSendMessageToApp (ISMMESSAGE_EXECUTE_PREPROCESS, (ULONG_PTR) *((PCTSTR *)e.ExtraData));
            } while (EnumNextHashTableString (&e));
        }
    }
    g_PreProcessDone = TRUE;

    IsmGetTempDirectory (tempDir, ARRAYSIZE(tempDir));
    fileTypeId = MIG_FILE_TYPE;

    //
    // Special code for file type (short/long issue)
    //
    pFixFileEnumerationOrder (PLATFORM_SOURCE, tempDir);
    pFixFileEnumerationOrder (PLATFORM_DESTINATION, tempDir);

    //
    // Now we are going to execute an ISM driven restore
    //

    objPattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);

    //
    // Enumerate and process high priority operations for all objects on the
    // right side of the tree
    //

    failCode = ERROR_SUCCESS;

    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
        do {
            objTypeId = objTypeIdEnum.ObjectTypeId;

            objTypeId |= PLATFORM_DESTINATION;

            if (CanObjectTypeBeRestored (objTypeId)) {

                delayedDeleteHandle = MemDbAddKey (delayedDeleteKey);

                if (pEnumFirstVirtualObject (&objectEnum, objTypeId, objPattern)) {
                    do {
                        toProcess = ShouldObjectBeRestored (
                                        objTypeId,
                                        objectEnum.ObjectId,
                                        objectEnum.ObjectName
                                        );

                        if (toProcess) {
                            if (!RestoreObject (
                                    objTypeId,
                                    objectEnum.ObjectName,
                                    NULL,
                                    OP_HIGH_PRIORITY,
                                    &deleteFailed
                                    )) {
                                failCode = GetLastError();
                                if (failCode != ERROR_SUCCESS) {
                                    LOG ((
                                        IsmIsNonCriticalObjectId (objectEnum.ObjectId)?LOG_WARNING:LOG_ERROR,
                                        (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                        IsmGetObjectTypeName (objTypeId),
                                        IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                        ));
                                    failCode = ERROR_SUCCESS;
                                }
                            }

                            if (deleteFailed && delayedDeleteHandle) {
                                delayedDeleteId = IsmGetObjectIdFromName (objTypeId, objectEnum.ObjectName, TRUE);
                                if (delayedDeleteId) {
                                    MemDbAddSingleLinkageByKeyHandle (
                                        delayedDeleteHandle,
                                        delayedDeleteId,
                                        0
                                        );
                                }
                            }
                        }

                        if (ticks) {
                            if (!IsmTickProgressBar (sliceId, 1)) {
                                failCode = ERROR_CANCELLED;
                                break;
                            }
                            ticks--;
                        } else if (CheckCancel()) {
                            failCode = ERROR_CANCELLED;
                            break;
                        }
                    } while (pEnumNextVirtualObject (&objectEnum));
                }
                if (delayedDeleteHandle) {
                    // OK, now let's see if we have some delayed delete here
                    delayedDeleteList = MemDbGetSingleLinkageArrayByKeyHandle (
                                            delayedDeleteHandle,
                                            0,
                                            &delayedDeleteListNo
                                            );
                    delayedDeleteListNo /= SIZEOF(KEYHANDLE);

                    if ((delayedDeleteList) &&
                        (delayedDeleteListNo > 0)) {
                        delayedDeleteIndex = delayedDeleteListNo;
                        do {
                            delayedDeleteIndex --;
                            delayedDeleteId = *(delayedDeleteList + delayedDeleteIndex);
                            delayedObjectName = MemDbGetKeyFromHandle ((KEYHANDLE) delayedDeleteId, 1);
                            if (delayedObjectName) {
                                if (MemDbGetValueByHandle ((KEYHANDLE) delayedDeleteId, &delayedObjectTypeId)) {
                                    // now we have everything to retry the delete
                                    if (!RestoreObject (
                                            delayedObjectTypeId,
                                            delayedObjectName,
                                            NULL,
                                            OP_HIGH_PRIORITY,
                                            NULL
                                            )) {
                                        failCode = GetLastError();
                                        if (failCode != ERROR_SUCCESS) {
                                            LOG ((
                                                IsmIsNonCriticalObject (delayedObjectTypeId, delayedObjectName)?LOG_WARNING:LOG_ERROR,
                                                (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                                IsmGetObjectTypeName (objTypeId),
                                                IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                                ));
                                            failCode = ERROR_SUCCESS;
                                        }
                                    }
                                }
                                MemDbReleaseMemory (delayedObjectName);
                            }
                        } while (delayedDeleteIndex > 0);
                        MemDbReleaseMemory (delayedDeleteList);
                    }
                }
                MemDbDeleteKey (delayedDeleteKey);
            }

            if (failCode != ERROR_SUCCESS) {
                IsmAbortObjectEnum (&objectEnum);
                SetLastError (failCode);
                if (tempDir [0]) {
                    FiRemoveAllFilesInTree (tempDir);
                }
                IsmAbortObjectTypeIdEnum (&objTypeIdEnum);
                return FALSE;
            }

        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }

    //
    // Enumerate and process high priority and low priority operations for all objects on the
    // left side of the tree
    //

    failCode = ERROR_SUCCESS;

    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {

        do {
            objTypeId = objTypeIdEnum.ObjectTypeId;

            objTypeId |= PLATFORM_SOURCE;

            if (CanObjectTypeBeRestored (objTypeId)) {

                if (pEnumFirstVirtualObject (&objectEnum, objTypeId, objPattern)) {
                    do {
                        toProcess = ShouldObjectBeRestored (
                                        objTypeId,
                                        objectEnum.ObjectId,
                                        objectEnum.ObjectName
                                        );

                        if (toProcess) {
                            if (!RestoreObject (
                                    objTypeId,
                                    objectEnum.ObjectName,
                                    NULL,
                                    OP_ALL_PRIORITY,
                                    NULL
                                    )) {
                                failCode = GetLastError();
                                if (failCode != ERROR_SUCCESS) {
                                    LOG ((
                                        IsmIsNonCriticalObjectId (objectEnum.ObjectId)?LOG_WARNING:LOG_ERROR,
                                        (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                        IsmGetObjectTypeName (objTypeId),
                                        IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                        ));
                                    failCode = ERROR_SUCCESS;
                                    extraData.Error = ERRUSER_ERROR_CANTRESTOREOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_RESTORE;
                                    extraData.ObjectTypeId = objTypeId;
                                    extraData.ObjectName = objectEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                }
                            }
                        }

                        if (ticks) {
                            if (!IsmTickProgressBar (sliceId, 1)) {
                                failCode = ERROR_CANCELLED;
                                break;
                            }
                            ticks--;
                        } else if (CheckCancel()) {
                            failCode = ERROR_CANCELLED;
                            break;
                        }
                    } while (pEnumNextVirtualObject (&objectEnum));
                }
            }

            if (failCode != ERROR_SUCCESS) {
                IsmAbortObjectEnum (&objectEnum);
                SetLastError (failCode);
                if (tempDir [0]) {
                    FiRemoveAllFilesInTree (tempDir);
                }
                IsmAbortObjectTypeIdEnum (&objTypeIdEnum);
                return FALSE;
            }

        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }

    //
    // Enumerate and process low priority operation for all objects on the
    // right side of the tree
    //

    failCode = ERROR_SUCCESS;

    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {

        do {
            objTypeId = objTypeIdEnum.ObjectTypeId;

            objTypeId |= PLATFORM_DESTINATION;

            if (CanObjectTypeBeRestored (objTypeId)) {

                delayedDeleteHandle = MemDbAddKey (delayedDeleteKey);

                if (pEnumFirstVirtualObject (&objectEnum, objTypeId, objPattern)) {
                    do {
                        toProcess = ShouldObjectBeRestored (
                                        objTypeId,
                                        objectEnum.ObjectId,
                                        objectEnum.ObjectName
                                        );

                        if (toProcess) {
                            if (!RestoreObject (
                                    objTypeId,
                                    objectEnum.ObjectName,
                                    NULL,
                                    OP_LOW_PRIORITY,
                                    &deleteFailed
                                    )) {
                                failCode = GetLastError();
                                if (failCode != ERROR_SUCCESS) {
                                    LOG ((
                                        IsmIsNonCriticalObjectId (objectEnum.ObjectId)?LOG_WARNING:LOG_ERROR,
                                        (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                        IsmGetObjectTypeName (objTypeId),
                                        IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                        ));
                                    failCode = ERROR_SUCCESS;
                                }
                            }
                            if (deleteFailed && delayedDeleteHandle) {
                                delayedDeleteId = IsmGetObjectIdFromName (objTypeId, objectEnum.ObjectName, TRUE);
                                if (delayedDeleteId) {
                                    MemDbAddSingleLinkageByKeyHandle (
                                        delayedDeleteHandle,
                                        delayedDeleteId,
                                        0
                                        );
                                }
                            }
                        }

                        if (ticks) {
                            if (!IsmTickProgressBar (sliceId, 1)) {
                                failCode = ERROR_CANCELLED;
                                break;
                            }
                            ticks--;
                        } else if (CheckCancel()) {
                            failCode = ERROR_CANCELLED;
                            break;
                        }
                    } while (pEnumNextVirtualObject (&objectEnum));
                }
                if (delayedDeleteHandle) {
                    // OK, now let's see if we have some delayed delete here
                    delayedDeleteList = MemDbGetSingleLinkageArrayByKeyHandle (
                                            delayedDeleteHandle,
                                            0,
                                            &delayedDeleteListNo
                                            );
                    delayedDeleteListNo /= SIZEOF(KEYHANDLE);

                    if ((delayedDeleteList) &&
                        (delayedDeleteListNo > 0)) {
                        delayedDeleteIndex = delayedDeleteListNo;
                        do {
                            delayedDeleteIndex --;
                            delayedDeleteId = *(delayedDeleteList + delayedDeleteIndex);
                            delayedObjectName = MemDbGetKeyFromHandle ((KEYHANDLE) delayedDeleteId, 1);
                            if (delayedObjectName) {
                                if (MemDbGetValueByHandle ((KEYHANDLE) delayedDeleteId, &delayedObjectTypeId)) {
                                    // now we have everything to retry the delete
                                    if (!RestoreObject (
                                            delayedObjectTypeId,
                                            delayedObjectName,
                                            NULL,
                                            OP_LOW_PRIORITY,
                                            NULL
                                            )) {
                                        failCode = GetLastError();
                                        if (failCode != ERROR_SUCCESS) {
                                            LOG ((
                                                IsmIsNonCriticalObject (delayedObjectTypeId, delayedObjectName)?LOG_WARNING:LOG_ERROR,
                                                (PCSTR) MSG_CANT_RESTORE_SOURCE_OBJECT,
                                                IsmGetObjectTypeName (objTypeId),
                                                IsmGetNativeObjectName (objTypeId, objectEnum.ObjectName)
                                                ));
                                            failCode = ERROR_SUCCESS;
                                        }
                                    }
                                }
                                MemDbReleaseMemory (delayedObjectName);
                            }
                        } while (delayedDeleteIndex > 0);
                        MemDbReleaseMemory (delayedDeleteList);
                    }
                }
                MemDbDeleteKey (delayedDeleteKey);
            }

            if (failCode != ERROR_SUCCESS) {
                IsmAbortObjectEnum (&objectEnum);
                SetLastError (failCode);
                if (tempDir [0]) {
                    FiRemoveAllFilesInTree (tempDir);
                }
                return FALSE;
            }

        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }

    g_MakeProfilePermanent = TRUE;

    IsmDestroyObjectHandle (objPattern);

    pCallProgressBar (MIG_END_PHASE);

    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    if (tempDir [0]) {
        FiRemoveAllFilesInTree (tempDir);
    }

    return b;
}


MIG_TRANSPORTSTORAGEID
IsmRegisterTransport (
    IN      PCTSTR TypeString
    )
{
    MIG_TRANSPORTSTORAGEID transportStorageId;
    PCTSTR memdbKey;

    memdbKey = JoinPaths (S_TRANSPORT_TYPES, TypeString);
    transportStorageId = (MIG_TRANSPORTSTORAGEID) MemDbSetKey (memdbKey);
    FreePathString (memdbKey);

    if (!transportStorageId) {
        DEBUGMSG ((DBG_ISM, "Unable to set memdb key in IsmRegisterTransport"));
        EngineError ();
    }

    return transportStorageId;
}


BOOL
pEnumFirstTransportType (
    OUT     PMEMDB_ENUM EnumPtr
    )
{
    PCTSTR memdbPattern;
    BOOL b;

    memdbPattern = JoinPaths (S_TRANSPORT_TYPES, TEXT("*"));
    b = MemDbEnumFirst (
            EnumPtr,
            memdbPattern,
            ENUMFLAG_NORMAL,
            ENUMLEVEL_ALLLEVELS,
            ENUMLEVEL_ALLLEVELS
            );
    FreePathString (memdbPattern);

    return b;
}


BOOL
pEnumNextTransportType (
    IN OUT  PMEMDB_ENUM EnumPtr
    )
{
    return MemDbEnumNext (EnumPtr);
}


VOID
pAbortTransportTypeEnum (
    IN      PMEMDB_ENUM EnumPtr
    )
{
    MemDbAbortEnum (EnumPtr);
}


BOOL
IsmEnumFirstTransport (
    OUT     PMIG_TRANSPORTENUM Enum,
    IN      MIG_TRANSPORTSTORAGEID DesiredStorageId     OPTIONAL
    )
{
    PTRANSPORTENUMHANDLE handle;
    BOOL b;

    ZeroMemory (Enum, sizeof (MIG_TRANSPORTENUM));

    Enum->Handle = MemAllocZeroed (sizeof (TRANSPORTENUMHANDLE));
    handle = (PTRANSPORTENUMHANDLE) Enum->Handle;

    handle->DesiredStorageId = DesiredStorageId;

    b = EnumFirstHashTableString (&handle->TableEnum, g_TransportTable);

    if (!b) {
        IsmAbortTransportEnum (Enum);
        return FALSE;
    }

    handle->State = TESTATE_BEGINTRANSPORT;

    return IsmEnumNextTransport (Enum);
}


BOOL
IsmEnumNextTransport (
    IN OUT  PMIG_TRANSPORTENUM Enum
    )
{
    PTRANSPORTENUMHANDLE handle;
    PTRANSPORTDATA transportData;

    handle = (PTRANSPORTENUMHANDLE) Enum->Handle;
    if (!handle) {
        return FALSE;
    }

    for (;;) {
        switch (handle->State) {

        case TESTATE_BEGINTRANSPORT:
            //
            // Begin enumeration of all registered types
            //

            if (!pEnumFirstTransportType (&handle->MemDbEnum)) {
                handle->State = TESTATE_NEXTTRANSPORT;
            } else {
                handle->State = TESTATE_GETCAPS;
            }

            break;

        case TESTATE_GETCAPS:
            transportData = *((PTRANSPORTDATA *) handle->TableEnum.ExtraData);

            if (!transportData) {
                handle->State = TESTATE_NEXTTRANSPORT;
            } else {
                MYASSERT (transportData->TransportQueryCapabilities);

                if (handle->DesiredStorageId &&
                    handle->DesiredStorageId != (MIG_TRANSPORTSTORAGEID) handle->MemDbEnum.KeyHandle
                    ) {
                    handle->State = TESTATE_NEXTTRANSPORTTYPE;
                } else {

                    if (!transportData->TransportQueryCapabilities (
                                            (MIG_TRANSPORTSTORAGEID) handle->MemDbEnum.KeyHandle,
                                            &Enum->TransportType,
                                            &Enum->Capabilities,
                                            &Enum->FriendlyDescription
                                            )) {

                        handle->State = TESTATE_NEXTTRANSPORTTYPE;
                    } else {
                        handle->State = TESTATE_RETURN;
                    }
                }
            }

            break;

        case TESTATE_RETURN:
            Enum->TransportId = (MIG_TRANSPORTID) handle->TableEnum.Index;
            Enum->SupportedStorageId = (MIG_TRANSPORTSTORAGEID) handle->MemDbEnum.KeyHandle;

            handle->State = TESTATE_NEXTTRANSPORTTYPE;
            return TRUE;


        case TESTATE_NEXTTRANSPORTTYPE:
            if (!pEnumNextTransportType (&handle->MemDbEnum)) {
                pAbortTransportTypeEnum (&handle->MemDbEnum);
                handle->State = TESTATE_NEXTTRANSPORT;
            } else {
                handle->State = TESTATE_GETCAPS;
            }
            break;

        case TESTATE_NEXTTRANSPORT:
            if (!EnumNextHashTableString (&handle->TableEnum)) {
                handle->State = TESTATE_DONE;
            } else {
                handle->State = TESTATE_BEGINTRANSPORT;
            }
            break;

        case TESTATE_DONE:
            IsmAbortTransportEnum (Enum);
            return FALSE;
        }
    }
}


VOID
IsmAbortTransportEnum (
    IN      PMIG_TRANSPORTENUM Enum
    )
{
    PTRANSPORTENUMHANDLE handle = (PTRANSPORTENUMHANDLE) Enum->Handle;

    if (handle) {
        pAbortTransportTypeEnum (&handle->MemDbEnum);

        FreeAlloc (handle);
        INVALID_POINTER (handle);
    }

    ZeroMemory (Enum, sizeof (MIG_TRANSPORTENUM));
}


MIG_TRANSPORTID
IsmSelectTransport (
    IN      MIG_TRANSPORTSTORAGEID DesiredStorageId,
    IN      MIG_TRANSPORTTYPE TransportType,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities
    )
{
    MIG_TRANSPORTENUM e;
    MIG_TRANSPORTID result = 0;

    if (!DesiredStorageId) {
        return 0;
    }

    if (IsmEnumFirstTransport (&e, DesiredStorageId)) {
        do {
            if (e.TransportType != TransportType) {
                continue;
            }
            if ((e.Capabilities & RequiredCapabilities) == RequiredCapabilities) {
                result = e.TransportId;
                IsmAbortTransportEnum (&e);
                g_TransportType = TransportType;
                return result;
            }

        } while (IsmEnumNextTransport (&e));
    }

    DEBUGMSG ((DBG_ISM, "IsmSelectTransport: Requested transport type does not exist"));

    return result;
}


BOOL
IsmSetTransportStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTID TransportId,
    IN      MIG_TRANSPORTSTORAGEID DesiredStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL StoragePathIsValid,                       OPTIONAL
    OUT     PBOOL ImageExistsInStorage                      OPTIONAL
    )
{
    PTRANSPORTDATA *ptrToTransportData;
    PTRANSPORTDATA transportData;
    BOOL b;
    BOOL valid;
    BOOL exists;
    PCTSTR sanitizedPath = NULL;

    if (!TransportId) {
        return FALSE;
    }

    if (!HtGetExtraData (g_TransportTable, (HASHITEM) TransportId, (PVOID *) &ptrToTransportData)) {
        return FALSE;
    }

    transportData = *ptrToTransportData;

    if (!transportData || !transportData->ShouldBeCalled) {
        return FALSE;
    }

    MYASSERT (transportData->TransportSetStorage);

    if (Platform == PLATFORM_CURRENT) {
        Platform = g_IsmCurrentPlatform;
    }

    if (g_SelectedTransport) {
        if (g_SelectedTransport->TransportResetStorage) {
            g_SelectedTransport->TransportResetStorage (g_SelectedTransportId);
        }

        g_SelectedTransport = NULL;
        g_SelectedTransportId = 0;
    }

    if (StoragePath) {
        sanitizedPath = SanitizePath (StoragePath);
    }

    b = transportData->TransportSetStorage (
                            Platform,
                            DesiredStorageId,
                            RequiredCapabilities,
                            sanitizedPath,
                            &valid,
                            &exists
                            );
    if (sanitizedPath) {
        FreePathString (sanitizedPath);
    }

    if (b) {
        if (StoragePathIsValid) {
            *StoragePathIsValid = valid;
        }

        if (ImageExistsInStorage) {
            *ImageExistsInStorage = exists;
        }

        g_SelectedTransport = transportData;
        g_SelectedTransportId = DesiredStorageId;
    }

    return b;
}


BOOL
IsmExecute (
    MIG_EXECUTETYPEID ExecuteType
    )
{
    static BOOL srcInitCompleted = FALSE;
    static BOOL destInitCompleted = FALSE;
    static BOOL vcmInitCompleted = FALSE;
    static BOOL srcModuleInitCompleted = FALSE;
    static BOOL destModuleInitCompleted = FALSE;
    static BOOL rollbackInitCompleted = FALSE;
    static BOOL vcmMode = FALSE;
    static BOOL normalMode = FALSE;
    static BOOL parsingDone = FALSE;
    static BOOL srcExecuteDone = FALSE;
    static BOOL destExecuteDone = FALSE;
    static BOOL delayedOperationsDone = FALSE;
    BOOL needVcmInit = FALSE;
    BOOL needSrcModuleInit = FALSE;
    BOOL needDestModuleInit = FALSE;
    BOOL needRollbackInit = FALSE;
    BOOL needTerminate = FALSE;
    BOOL needTransportTermination = FALSE;
    BOOL needDelayedOperationsTerminate = FALSE;
    BOOL parseEtm = FALSE;
    BOOL parseVcm = FALSE;
    BOOL processVcm = FALSE;
    BOOL parseSource = FALSE;
    BOOL processSource = FALSE;
    BOOL processDestination = FALSE;
    BOOL processDelayedOperations = FALSE;
    MIG_PLATFORMTYPEID platform = PLATFORM_SOURCE;
    PCTSTR journalFile;
    DWORD tempField;
    PCURRENT_USER_DATA currentUserData;
    BOOL cleanupOnly = FALSE;
    BOOL b = TRUE;

    if (CheckCancel ()) {
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    switch (ExecuteType) {

    case EXECUTETYPE_VIRTUALCOMPUTER_PARSING:
        if (parsingDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_VIRTUALCOMPUTER_PARSING denied, parsing already executed"));
            b = FALSE;
            break;
        }

        if (normalMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_VIRTUALCOMPUTER_PARSING denied, not in virtual computer mode"));
            b = FALSE;
            break;
        }

        needVcmInit = TRUE;
        parseEtm = TRUE;
        parseVcm = TRUE;

        parsingDone = TRUE;
        vcmMode = TRUE;
        break;

    case EXECUTETYPE_VIRTUALCOMPUTER:
        if (srcExecuteDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_VIRTUALCOMPUTER denied, virtual computer already built"));
            b = FALSE;
            break;
        }

        if (normalMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_VIRTUALCOMPUTER denied, not in virtual computer mode"));
            b = FALSE;
            break;
        }

        needVcmInit = TRUE;
        processVcm = TRUE;
        needTerminate = TRUE;

        parsingDone = TRUE;
        vcmMode = TRUE;
        srcExecuteDone = TRUE;
        break;

    case EXECUTETYPE_EXECUTESOURCE_PARSING:
        if (vcmMode) {
            DEBUGMSG ((DBG_ERROR, "PARSING denied, in virtual computer mode"));
            b = FALSE;
            break;
        }

        if (parsingDone) {
            DEBUGMSG ((DBG_ERROR, "PARSING denied, it was already done"));
            b = FALSE;
            break;
        }

        needSrcModuleInit = TRUE;
        parseEtm = TRUE;
        parseSource = TRUE;

        parsingDone = TRUE;
        normalMode = TRUE;
        break;

    case EXECUTETYPE_EXECUTESOURCE:
        if (vcmMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTESOURCE denied, in virtual computer mode"));
            b = FALSE;
            break;
        }

        if (srcExecuteDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTESOURCE denied, source computer already processed"));
            b = FALSE;
            break;
        }

        if (destExecuteDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTESOURCE denied, destination computer already processed"));
            b = FALSE;
            break;
        }

        needSrcModuleInit = TRUE;
        processSource = TRUE;
        needTerminate = TRUE;

        parsingDone = TRUE;
        normalMode = TRUE;
        srcExecuteDone = TRUE;
        break;

    case EXECUTETYPE_EXECUTEDESTINATION:
        if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
            b = FALSE;
            break;
        }

        if (vcmMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTEDESTINATION denied, in virtual computer mode"));
            b = FALSE;
            break;
        }

        if (destExecuteDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_EXECUTEDESTINATION denied, destination computer already processed"));
            b = FALSE;
            break;
        }

        platform = PLATFORM_DESTINATION;
        needDestModuleInit = TRUE;
        needRollbackInit = TRUE;
        processDestination = TRUE;
        needTransportTermination = TRUE;
        needTerminate = TRUE;

        parsingDone = TRUE;
        normalMode = TRUE;
        destExecuteDone = TRUE;

        break;

    case EXECUTETYPE_DELAYEDOPERATIONS:
    case EXECUTETYPE_DELAYEDOPERATIONSCLEANUP:
        if (vcmMode) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_DELAYEDOPERATIONS denied, in virtual computer mode"));
            b = FALSE;
            break;
        }

        if (delayedOperationsDone) {
            DEBUGMSG ((DBG_ERROR, "EXECUTETYPE_DELAYEDOPERATIONS denied, delayed operations already processed"));
            b = FALSE;
            break;
        }

        platform = PLATFORM_DESTINATION;
        destInitCompleted = TRUE;
        needRollbackInit = TRUE;
        needDelayedOperationsTerminate = TRUE;
        processDelayedOperations = TRUE;

        delayedOperationsDone = TRUE;
        cleanupOnly = (ExecuteType == EXECUTETYPE_DELAYEDOPERATIONSCLEANUP);
    }

    if (b) {
        g_IsmModulePlatformContext = platform;

        if (platform == PLATFORM_SOURCE) {
            if (!srcInitCompleted) {
                //
                // Complete initialization of all ISM components
                //

                b = InitializeProperties (platform, vcmMode);
                srcInitCompleted = TRUE;

                DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: src property init failed"));
            }
        } else {
            if (!destInitCompleted) {
                //
                // Complete initialization of all ISM components
                //

                b = InitializeProperties (platform, vcmMode);
                destInitCompleted = TRUE;

                DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: dest property init failed"));
            }
        }

        if (needVcmInit && !vcmInitCompleted) {
            //
            // Initialize the modules
            //

            b = InitializeVcmModules (NULL);
            vcmInitCompleted = TRUE;

            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: VCM init failed"));
        }

        if (needSrcModuleInit && !srcModuleInitCompleted) {
            //
            // Initialize the modules
            //

            b = InitializeModules (platform, NULL);
            srcModuleInitCompleted = TRUE;

            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: src module init failed"));
        }

        if (needRollbackInit && !rollbackInitCompleted) {

            //
            // remove all journal entries, prepare for a new apply
            //
            if (g_JournalDirectory) {
                FiRemoveAllFilesInTree (g_JournalDirectory);
                BfCreateDirectory (g_JournalDirectory);
                journalFile = JoinPaths (g_JournalDirectory, TEXT("JOURNAL.DAT"));
                g_JournalHandle = BfCreateFile (journalFile);
                if (g_JournalHandle) {
                    tempField = JRN_SIGNATURE;
                    BfWriteFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD));
                    tempField = JRN_VERSION;
                    BfWriteFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD));
                    FreePathString (journalFile);
                    currentUserData = GetCurrentUserData ();
                    if (currentUserData) {
                        pRecordUserData (
                            currentUserData->UserName,
                            currentUserData->UserDomain,
                            currentUserData->UserStringSid,
                            currentUserData->UserProfilePath,
                            FALSE
                            );
                        FreeCurrentUserData (currentUserData);
                    } else {
                        pRecordUserData (
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            FALSE
                            );
                    }
                }
            }
            ELSE_DEBUGMSG ((DBG_WHOOPS, "Journal directory does not exist."));

            rollbackInitCompleted = TRUE;
        }

        if (needDestModuleInit && !destModuleInitCompleted) {
            //
            // Initialize the modules
            //

            b = InitializeModules (platform, NULL);
            destModuleInitCompleted = TRUE;

            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: dest module init failed"));
        }
    }

    if (b && parseEtm) {
        //
        // Execute the appropriate ETM parse functions
        //

        b = pEtmParse (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: ETM parse failed"));

        b = b && !CheckCancel();
    }

    if (b && parseVcm) {
        //
        // Execute the appropriate virtual computer parse functions
        //

        b = pCreateComputerParse (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: VCM parse failed"));

        b = b && !CheckCancel();
    }

    if (b && processVcm) {
        //
        // Execute the appropriate virtual computer gather functions
        //

        b = pCreateComputerGather (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: VCM queue enumeration or gather callback failed"));

        b = b && !CheckCancel();
    }

    if (b && parseSource) {
        //
        // Execute the appropriate virtual computer parse functions
        //

        b = pSourceParse (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: SGM parse failed"));

        b = b && !CheckCancel();
    }


    if (b && processSource) {
        //
        // Execute the appropriate source gather functions
        //

        b = pSourceGather (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: SGM queue enumeration or gather callback failed"));

        b = b && !CheckCancel();

        if (b) {
            b = pSourceAnalyze (NULL);
            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: SAM failed"));

            b = b && !CheckCancel();
        }
    }


    if (b && processDestination) {
        //
        // Execute the appropriate destination functions
        //

        b = pDestinationGather (NULL);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: DGM queue enumeration or gather callback failed"));

        b = b && !CheckCancel();

        if (b) {
            b = pDestinationAnalyze (NULL);
            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: DAM failed"));

            b = b && !CheckCancel();
        }

        if (b) {
            b = pDestinationApply (NULL);
            DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: dest apply failed"));

            b = b && !CheckCancel();
        }
    }

    if (b && processDelayedOperations) {
        //
        // Execute the appropriate delayed operations
        //

        b = ExecuteDelayedOperations (cleanupOnly);
        DEBUGMSG_IF ((!b, DBG_ISM, "IsmExecute: delayed operations failed"));

    }

    if (needTransportTermination) {

        MYASSERT (g_SelectedTransport);
        MYASSERT (g_SelectedTransport->TransportEndApply);

        g_SelectedTransport->TransportEndApply ();
    }

    if (needTerminate) {
        //
        // Done -- terminate the modules
        //

        TerminateModules ();
        TerminateProperties (platform);
    }

    if (needDelayedOperationsTerminate) {
        pDeleteDelayedOperationsCommand ();
    }

    g_IsmModulePlatformContext = PLATFORM_CURRENT;

    if (g_JournalHandle) {
        CloseHandle (g_JournalHandle);
        g_JournalHandle = NULL;
    }

    g_ExecutionInProgress = FALSE;

    return b;
}


BOOL
IsmRegisterProgressBarCallback (
    IN      PPROGRESSBARFN ProgressBarFn,
    IN      ULONG_PTR Arg
    )
{
    if (CheckCancel ()) {
        return FALSE;
    }

    if (!ProgressBarFn) {
        g_ProgressBarFn = NULL;
        return TRUE;
    }

    if (g_ProgressBarFn) {
        DEBUGMSG ((DBG_ERROR, "Progress bar callback is already set"));
        return FALSE;
    }

    g_ProgressBarFn = ProgressBarFn;
    g_ProgressBarArg = Arg;

    return TRUE;
}


BOOL
pSaveStatistics (
    VOID
    )
{
    MIG_OBJECTCOUNT objectCount [3];

    MYASSERT (
        g_TotalObjects.TotalObjects ==
            g_SourceObjects.TotalObjects +
            g_DestinationObjects.TotalObjects
        );
    MYASSERT (
        g_TotalObjects.PersistentObjects ==
            g_SourceObjects.PersistentObjects +
            g_DestinationObjects.PersistentObjects
        );
    MYASSERT (
        g_TotalObjects.ApplyObjects ==
            g_SourceObjects.ApplyObjects +
            g_DestinationObjects.ApplyObjects
        );

    CopyMemory (&(objectCount [0]), &g_TotalObjects, sizeof (MIG_OBJECTCOUNT));
    CopyMemory (&(objectCount [1]), &g_SourceObjects, sizeof (MIG_OBJECTCOUNT));
    CopyMemory (&(objectCount [2]), &g_DestinationObjects, sizeof (MIG_OBJECTCOUNT));
    if (!MemDbSetUnorderedBlob (S_OBJECTCOUNT, 0, (PCBYTE)objectCount, 3 * sizeof (MIG_OBJECTCOUNT))) {
        return FALSE;
    }
    return SavePerObjectStatistics ();
}

BOOL
pLoadStatistics (
    VOID
    )
{
    PMIG_OBJECTCOUNT objectCount;
    DWORD size;

    objectCount = (PMIG_OBJECTCOUNT) MemDbGetUnorderedBlob (S_OBJECTCOUNT, 0, &size);
    if ((!objectCount) || (size != 3 * sizeof (MIG_OBJECTCOUNT))) {
        if (objectCount) {
            MemDbReleaseMemory (objectCount);
        }
        MYASSERT (FALSE);
        return FALSE;
    }
    CopyMemory (&g_TotalObjects, objectCount, sizeof (MIG_OBJECTCOUNT));
    CopyMemory (&g_SourceObjects, objectCount + 1, sizeof (MIG_OBJECTCOUNT));
    CopyMemory (&g_DestinationObjects, objectCount + 2, sizeof (MIG_OBJECTCOUNT));
    MemDbReleaseMemory (objectCount);

    MYASSERT (
        g_TotalObjects.TotalObjects ==
            g_SourceObjects.TotalObjects +
            g_DestinationObjects.TotalObjects
        );
    MYASSERT (
        g_TotalObjects.PersistentObjects ==
            g_SourceObjects.PersistentObjects +
            g_DestinationObjects.PersistentObjects
        );
    MYASSERT (
        g_TotalObjects.ApplyObjects ==
            g_SourceObjects.ApplyObjects +
            g_DestinationObjects.ApplyObjects
        );

    return LoadPerObjectStatistics ();
}

BOOL
pLoadLightDatabase (
    IN      PCTSTR FileName
    )
{
    HINF infHandle;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    INFSTRUCT is2 = INITINFSTRUCT_PMHANDLE;
    MIG_OBJECTTYPEID objectTypeId;
    GROWBUFFER buff = INIT_GROWBUFFER;
    PCTSTR field;
    MIG_OBJECTSTRINGHANDLE objectName;
    UINT index;
    PCTSTR scope;
    PCTSTR name;
    PCTSTR key;
    PCTSTR keyData;
    UINT envType;
    DWORD dummy;
    PCTSTR savedGroup;
    ENVENTRY_STRUCT envStruct;
    PTSTR decodedString = NULL;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;
    PCTSTR priorityStr;
    UINT priority;
    TYPE_REGISTER typeRegisterData;

    infHandle = InfOpenInfFile (FileName);

    if (infHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // let's load transport variables
    if (InfFindFirstLine (infHandle, TEXT("Data Sections"), NULL, &is)) {
        do {
            name = InfGetStringField (&is, 1);

            if (name && InfFindFirstLine (infHandle, name, NULL, &is2)) {
                do {

                    key = InfGetStringField (&is2, 0);
                    keyData = InfGetStringField (&is2, 1);

                    if (key && keyData) {
                        IsmSetTransportVariable (PLATFORM_SOURCE, name, key, keyData);
                    }

                } while (InfFindNextLine (&is2));
            }

        } while (InfFindNextLine (&is));
    }

    // let's load source environment variables
    if (InfFindFirstLine (infHandle, TEXT("Environment"), NULL, &is)) {
        do {
            name = InfGetStringField (&is, 1);
            scope = InfGetStringField (&is, 2);
            field = InfGetStringField (&is, 3);
            if (scope && name && field) {

                _stscanf (field, TEXT("%lx"), &envType);
                buff.End = 0;

                switch (envType) {
                case ENVENTRY_STRING:
                    field = InfGetStringField (&is, 4);
                    if (field) {
                        GbCopyString (&buff, field);
                    }
                    break;
                case ENVENTRY_MULTISZ:
                    index = 4;
                    for (;;) {
                        field = InfGetStringField (&is, index);
                        if (!field) {
                            break;
                        }
                        GbCopyString (&buff, field);
                        index ++;
                    }
                    if (buff.End) {
                        GbCopyString (&buff, TEXT(""));
                    }
                    break;
                case ENVENTRY_BINARY:
                    index = 4;
                    for (;;) {
                        field = InfGetStringField (&is, index);
                        if (!field) {
                            break;
                        }
                        _stscanf (field, TEXT("%lx"), &dummy);
                        *((PBYTE)GbGrow (&buff, sizeof (BYTE))) = (BYTE)dummy;
                        index ++;
                    }
                    break;
                default:
                    // don't know what to write, it's just a flag
                    break;
                }

                // now let's add the environment variable
                envStruct.Type = envType;
                if (buff.End) {
                    envStruct.EnvBinaryData = buff.Buf;
                    envStruct.EnvBinaryDataSize = buff.End;
                } else {
                    envStruct.EnvBinaryData = NULL;
                    envStruct.EnvBinaryDataSize = 0;
                }
                savedGroup = g_CurrentGroup;
                g_CurrentGroup = scope;
                IsmSetEnvironmentValue (
                    PLATFORM_SOURCE,
                    (scope && *scope)?scope:NULL,
                    name,
                    &envStruct
                    );
                g_CurrentGroup = savedGroup;
            }
        } while (InfFindNextLine (&is));
    }

    // let's load object types
    if (InfFindFirstLine (infHandle, TEXT("Object Types"), NULL, &is)) {
        do {
            field = InfGetStringField (&is, 1);
            priorityStr = InfGetStringField (&is, 2);
            if (field && priorityStr) {
                MYASSERT (IsmGetObjectTypeId (field) != 0);
                if (IsmGetObjectTypeId (field) == 0) {
                    // we need to preregister this type
                    ZeroMemory (&typeRegisterData, sizeof (TYPE_REGISTER));
                    _stscanf (priorityStr, TEXT("%lx"), &priority);
                    typeRegisterData.Priority = priority;
                    IsmRegisterObjectType (
                        field,
                        TRUE,
                        FALSE,
                        &typeRegisterData
                        );
                }
            }
        } while (InfFindNextLine (&is));
    }
    InfCleanUpInfStruct (&is);

    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {

        do {

            objectTypeId = objTypeIdEnum.ObjectTypeId;

            if (InfFindFirstLine (infHandle, IsmGetObjectTypeName (objectTypeId), NULL, &is)) {
                do {
                    index = 1;
                    buff.End = 0;
                    for (;;) {
                        field = InfGetStringField (&is, index);
                        if (!field) {
                            break;
                        }
                        if (*field) {
                            decodedString = DuplicatePathString (field, 0);
                            if (DecodeRuleChars (decodedString, field) != NULL) {
                                GbCopyString (&buff, decodedString);
                            } else {
                                GbCopyString (&buff, field);
                            }
                            FreePathString (decodedString);
                        } else {
                            GbCopyString (&buff, TEXT("<empty>"));
                        }
                        index ++;
                    }
                    if (buff.End) {
                        GbCopyString (&buff, TEXT(""));
                        if (IsmConvertMultiSzToObject (
                                objectTypeId,
                                (PCTSTR)buff.Buf,
                                &objectName,
                                NULL
                                )) {
                            // now save the object data into our database
                            // for future reference

                            IsmMakePersistentObject (objectTypeId | PLATFORM_SOURCE, objectName);

                            IsmDestroyObjectHandle (objectName);
                        }
                    }

                } while (InfFindNextLine (&is));
            }
        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }

    InfCleanUpInfStruct (&is);
    InfCleanUpInfStruct (&is2);
    InfCloseInfFile (infHandle);
    GbFree (&buff);

    pSaveStatistics ();

    return TRUE;
}

BOOL
pFinishLoad (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE memDbObjectName;
    MIG_CONTENT memDbContent;
    BOOL result = FALSE;
    GROWLIST growList = INIT_GROWLIST;

    __try {

        switch (g_TransportType) {
        case TRANSPORTTYPE_LIGHT:

            if (!RegisterInternalAttributes ()) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 6));
                __leave;
            }

            memDbObjectName = IsmCreateObjectHandle (S_DATABASEFILE_LITE, NULL);
            if (!IsmAcquireObjectEx (MIG_DATA_TYPE | PLATFORM_SOURCE, memDbObjectName, &memDbContent, CONTENTTYPE_FILE, 0)) {
                IsmDestroyObjectHandle (memDbObjectName);
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to acquire VCM database"));
                __leave;
            }

            if (!pLoadLightDatabase (memDbContent.FileContent.ContentPath)) {
                IsmDestroyObjectHandle (memDbObjectName);
                IsmReleaseObject (&memDbContent);
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to load VCM database"));
                __leave;
            }
            IsmDestroyObjectHandle (memDbObjectName);
            IsmReleaseObject (&memDbContent);
            break;

        case TRANSPORTTYPE_FULL:

            //
            // Save environment into a grow list, because memdb is going to be reloaded
            //

            EnvSaveEnvironment (&growList);

            memDbObjectName = IsmCreateObjectHandle (S_DATABASEFILE_FULL, NULL);
            if (!IsmAcquireObjectEx (MIG_DATA_TYPE | PLATFORM_SOURCE, memDbObjectName, &memDbContent, CONTENTTYPE_FILE, 0)) {
                IsmDestroyObjectHandle (memDbObjectName);
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to acquire database"));
                __leave;
            }

            if (!MemDbLoad (memDbContent.FileContent.ContentPath)) {
                IsmDestroyObjectHandle (memDbObjectName);
                IsmReleaseObject (&memDbContent);
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to load database"));
                __leave;
            }
            IsmDestroyObjectHandle (memDbObjectName);
            IsmReleaseObject (&memDbContent);

            //
            // Rebuild all the things we lost because of the memdb refresh
            //

            if (!RegisterInternalAttributes ()) {
                DEBUGMSG ((DBG_ISM, "pFinishLoad: Failed to register persistent attrib"));
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_INIT_FAILURE, 7));
                __leave;
            }

            EnvRestoreEnvironment (&growList);

            break;
        default:
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_UNKNOWN_TRANSPORT_TYPE, g_TransportType));
            __leave;
        }

        pLoadStatistics ();

        GlFree (&growList);

        EnvInvalidateCallbacks ();

        result = TRUE;
    }
    __finally {
    }

    return result;
}

BOOL
IsmLoad (
    VOID
    )
{
    BOOL result = FALSE;
    GROWLIST growList = INIT_GROWLIST;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    //
    // We need to invalidate operation combinations created so far
    // because we might load a new memdb where all operations could
    // be registered already
    //
    TerminateOperations ();

    g_CurrentPhase = MIG_TRANSPORT_PHASE;
    g_SliceBuffer.End = 0;

    __try {

        if (g_SelectedTransport->TransportEstimateProgressBar) {
            g_SelectedTransport->TransportEstimateProgressBar (g_IsmCurrentPlatform);
        }
        pCallProgressBar (MIG_BEGIN_PHASE);

        MYASSERT (g_SelectedTransport->TransportBeginApply);

        if (!g_SelectedTransport->TransportBeginApply ()) {
            DEBUGMSG ((DBG_ISM, "IsmLoad: Begin apply failed"));
            __leave;
        }

        result = pFinishLoad ();
    }
    __finally {
        PushError ();
        pCallProgressBar (MIG_END_PHASE);
        g_CurrentPhase = 0;
        g_SliceBuffer.End = 0;
        PopError ();
    }

    if (!result) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_LOAD_FAILURE));
    } else {
        InitializeOperations ();
    }

    g_ExecutionInProgress = FALSE;

    return result;
}

BOOL
IsmResumeLoad (
    VOID
    )
{
    BOOL result = FALSE;
    GROWLIST growList = INIT_GROWLIST;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    //
    // We need to invalidate operation combinations created so far
    // because we might load a new memdb where all operations could
    // be registered already
    //
    TerminateOperations ();

    g_CurrentPhase = MIG_TRANSPORT_PHASE;
    g_SliceBuffer.End = 0;

    __try {

        if (g_SelectedTransport->TransportEstimateProgressBar) {
            g_SelectedTransport->TransportEstimateProgressBar (g_IsmCurrentPlatform);
        }
        pCallProgressBar (MIG_BEGIN_PHASE);

        if (!g_SelectedTransport->TransportResumeApply) {
            __leave;
        }

        if (!g_SelectedTransport->TransportResumeApply ()) {
            __leave;
        }

        result = pFinishLoad ();
    }
    __finally {
        PushError ();
        pCallProgressBar (MIG_END_PHASE);
        g_CurrentPhase = 0;
        g_SliceBuffer.End = 0;
        PopError ();
    }

    if (result) {
        InitializeOperations ();
    }

    g_ExecutionInProgress = FALSE;

    return result;
}

BOOL
pSaveLightDatabase (
    IN      PCTSTR FileName
    )
{
    HANDLE fileHandle = NULL;
    MIG_OBJECTTYPEID objectTypeId;
    ENV_ENTRY_ENUM envEntryEnum;
    MULTISZ_ENUM multiSzEnum;
    UINT size;
    TCHAR buffer[sizeof (DWORD) * 2 + 3];
    PCTSTR start;
    PCTSTR end;
    TCHAR section[256];
    TCHAR sectionLookahead[256];
    UINT pass;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;

    fileHandle = BfCreateFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    WriteFileString (fileHandle, TEXT("[Version]\r\n"));
    WriteFileString (fileHandle, TEXT("signature=\"$CHICAGO$\"\r\n"));
    WriteFileString (fileHandle, TEXT("Class=Upgrade\r\n\r\n\r\n"));

    //
    // Write sections for lite transport
    //

    for (pass = 0 ; pass < 2 ; pass++) {
        if (EnvEnumerateFirstEntry (
                &envEntryEnum,
                PLATFORM_SOURCE,
                TEXT("*\\") S_TRANSPORT_PREFIX TEXT("\\*")
                )) {

            if (pass == 0) {
                WriteFileString (fileHandle, TEXT("[Data Sections]\r\n"));
            }

            *section = 0;

            do {
                if (envEntryEnum.EnvEntryType != ENVENTRY_STRING) {
                    continue;
                }

                if (!envEntryEnum.EnvEntryDataSize || !envEntryEnum.EnvEntryData) {
                    continue;
                }

                if (envEntryEnum.EnvEntryName) {
                    //
                    // Find start and end of section name
                    //

                    start = envEntryEnum.EnvEntryName;
                    end = _tcschr (start, TEXT('\\'));
                    if (!end) {
                        continue;
                    }

                    start = end + 1;
                    end = _tcschr (start, TEXT('\\'));

                    if (end && (end - start) < (ARRAYSIZE (sectionLookahead) - 2)) {
                        //
                        // Copy section name into lookahead buffer
                        //

                        StringCopyAB (sectionLookahead, start, end);

                        //
                        // Ignore if no keys exist
                        //

                        start = _tcsinc (end);
                        if (*start == 0) {
                            continue;
                        }

                        //
                        // If lookahead buffer != last section, write section name
                        //

                        if (StringICompare (section, sectionLookahead)) {
                            if (pass == 1 && *section) {
                                WriteFileString (fileHandle, TEXT("\r\n"));
                            }

                            StringCopy (section, sectionLookahead);

                            if (pass == 1) {
                                WriteFileString (fileHandle, TEXT("["));
                            }

                            WriteFileString (fileHandle, section);

                            if (pass == 1) {
                                WriteFileString (fileHandle, TEXT("]\r\n"));
                            } else {
                                WriteFileString (fileHandle, TEXT("\r\n"));
                            }
                        }

                        //
                        // If pass 1, write the key=value text
                        //

                        if (pass == 1) {
                            WriteFileString (fileHandle, start);
                            WriteFileString (fileHandle, TEXT(" = "));
                            WriteFileString (fileHandle, (PCTSTR)envEntryEnum.EnvEntryData);
                            WriteFileString (fileHandle, TEXT("\r\n"));
                        }
                    }
                }

            } while (EnvEnumerateNextEntry (&envEntryEnum));
            AbortEnvEnumerateEntry (&envEntryEnum);

            if (*section == 0) {
                WriteFileString (fileHandle, TEXT("; empty\r\n\r\n"));
            } else {
                WriteFileString (fileHandle, TEXT("\r\n"));
            }
        }
    }

    WriteFileString (fileHandle, TEXT("[Environment]\r\n"));
    if (EnvEnumerateFirstEntry (&envEntryEnum, PLATFORM_SOURCE, TEXT("*"))) {
        do {
            // skip v1 hack variables
            if (envEntryEnum.EnvEntryName) {

                if (StringIMatchCharCount (
                        S_TRANSPORT_PREFIX TEXT("\\"),
                        envEntryEnum.EnvEntryName,
                        ARRAYSIZE (S_TRANSPORT_PREFIX)
                        )) {
                    continue;
                }
            }

            // write the group and the name
            WriteFileString (fileHandle, TEXT("\""));
            if (envEntryEnum.EnvEntryName) {
                WriteFileString (fileHandle, envEntryEnum.EnvEntryName);
            }
            WriteFileString (fileHandle, TEXT("\",\""));
            if (envEntryEnum.EnvEntryGroup) {
                WriteFileString (fileHandle, envEntryEnum.EnvEntryGroup);
            }
            WriteFileString (fileHandle, TEXT("\","));
            // now write the entry type
            wsprintf (buffer, TEXT("0x%08X"), envEntryEnum.EnvEntryType);
            WriteFileString (fileHandle, buffer);

            switch (envEntryEnum.EnvEntryType) {
            case ENVENTRY_STRING:
                if (envEntryEnum.EnvEntryDataSize && envEntryEnum.EnvEntryData) {
                    WriteFileString (fileHandle, TEXT(",\""));
                    WriteFileString (fileHandle, (PCTSTR)envEntryEnum.EnvEntryData);
                    WriteFileString (fileHandle, TEXT("\""));
                }
                break;
            case ENVENTRY_MULTISZ:
                if (envEntryEnum.EnvEntryDataSize && envEntryEnum.EnvEntryData) {
                    if (EnumFirstMultiSz (&multiSzEnum, (PCTSTR)envEntryEnum.EnvEntryData)) {
                        do {
                            WriteFileString (fileHandle, TEXT(",\""));
                            WriteFileString (fileHandle, multiSzEnum.CurrentString);
                            WriteFileString (fileHandle, TEXT("\""));
                        } while (EnumNextMultiSz (&multiSzEnum));
                    }
                }
                break;
            case ENVENTRY_BINARY:
                if (envEntryEnum.EnvEntryDataSize && envEntryEnum.EnvEntryData) {
                    // write it in binary format
                    size = 0;
                    while (size < envEntryEnum.EnvEntryDataSize) {
                        wsprintf (
                            buffer,
                            TEXT("%02X"),
                            envEntryEnum.EnvEntryData [size]
                            );
                        WriteFileString (fileHandle, TEXT(","));
                        WriteFileString (fileHandle, buffer);
                        size ++;
                    }
                }
                break;
            default:
                // don't know what to write, it's just a flag
                break;
            }
            WriteFileString (fileHandle, TEXT("\r\n"));
        } while (EnvEnumerateNextEntry (&envEntryEnum));
        AbortEnvEnumerateEntry (&envEntryEnum);
    }
    WriteFileString (fileHandle, TEXT("\r\n\r\n"));

    WriteFileString (fileHandle, TEXT("[Object Types]\r\n"));

    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
        do {
            objectTypeId = objTypeIdEnum.ObjectTypeId;
            WriteFileString (fileHandle, IsmGetObjectTypeName (objectTypeId));
            WriteFileString (fileHandle, TEXT(", "));
            wsprintf (buffer, TEXT("0x%08X"), IsmGetObjectTypePriority (objectTypeId));
            WriteFileString (fileHandle, buffer);
            WriteFileString (fileHandle, TEXT("\r\n"));
        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }
    WriteFileString (fileHandle, TEXT("\r\n\r\n"));

    CloseHandle (fileHandle);

    return TRUE;
}

BOOL
IsmSave (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE memDbObjectName;
    TCHAR tempPath [MAX_PATH];
    BOOL result = FALSE;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
        return FALSE;
    }

    __try {
        g_ExecutionInProgress = TRUE;

        if (!IsmGetTempFile (tempPath, ARRAYSIZE(tempPath))) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_SAVE_MEMDB));
            __leave;
        }

        switch (g_TransportType) {

        case TRANSPORTTYPE_LIGHT:
            memDbObjectName = IsmCreateObjectHandle (S_DATABASEFILE_LITE, NULL);
            DataTypeAddObject (memDbObjectName, tempPath, TRUE);
            IsmDestroyObjectHandle (memDbObjectName);
            if (!pSaveLightDatabase (tempPath)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_SAVE_MEMDB));
                __leave;
            }
            break;

        case TRANSPORTTYPE_FULL:
            memDbObjectName = IsmCreateObjectHandle (S_DATABASEFILE_FULL, NULL);
            DataTypeAddObject (memDbObjectName, tempPath, TRUE);
            IsmDestroyObjectHandle (memDbObjectName);
            pSaveStatistics ();
            if (!MemDbSave (tempPath)) {
                LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_SAVE_MEMDB));
                __leave;
            }
            break;

        default:
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_UNKNOWN_TRANSPORT_TYPE, g_TransportType));
            __leave;
        }

        EnvInvalidateCallbacks ();

        g_CurrentPhase = MIG_TRANSPORT_PHASE;
        g_SliceBuffer.End = 0;

        if (g_SelectedTransport->TransportEstimateProgressBar) {
            g_SelectedTransport->TransportEstimateProgressBar (g_IsmCurrentPlatform);
        }
        pCallProgressBar (MIG_BEGIN_PHASE);

        result = g_SelectedTransport->TransportSaveState ();

        if (result) {
            DeleteFile (tempPath);
        } else {
            DEBUGMSG ((DBG_ISM, "TransportSaveState failed"));
            // NTRAID#NTBUG9-168115-2000/08/23-jimschm Temp file is not cleaned up here or in resume below
        }

        pCallProgressBar (MIG_END_PHASE);
        g_CurrentPhase = 0;
        g_SliceBuffer.End = 0;

    }
    __finally {
        g_ExecutionInProgress = FALSE;
    }

    if (!result) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_SAVE_FAILURE));
    }

    return result;
}

BOOL
IsmResumeSave (
    VOID
    )
{
    BOOL result;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (!g_SelectedTransport || !g_SelectedTransport->ShouldBeCalled) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NO_TRANSPORT_SELECTED));
        return FALSE;
    }

    if (!g_SelectedTransport->TransportResumeSaveState) {
        return FALSE;
    }

    g_ExecutionInProgress = TRUE;

    EnvInvalidateCallbacks ();

    g_CurrentPhase = MIG_TRANSPORT_PHASE;
    g_SliceBuffer.End = 0;

    if (g_SelectedTransport->TransportEstimateProgressBar) {
        g_SelectedTransport->TransportEstimateProgressBar (g_IsmCurrentPlatform);
    }
    pCallProgressBar (MIG_BEGIN_PHASE);

    result = g_SelectedTransport->TransportResumeSaveState ();

    DEBUGMSG_IF ((!result, DBG_ISM, "TransportResumeSaveState failed"));

    pCallProgressBar (MIG_END_PHASE);
    g_CurrentPhase = 0;
    g_SliceBuffer.End = 0;

    g_ExecutionInProgress = FALSE;

    return result;
}

PVOID
TrackedIsmGetMemory (
    IN      UINT Size
            TRACKING_DEF
    )
{
    PVOID result;

    TRACK_ENTER();

    if (!g_IsmPool) {
        g_IsmPool = PmCreateNamedPool ("ISM Pool");
    }

    result = PmGetMemory (g_IsmPool, Size);

    TRACK_LEAVE();
    return result;
}


PCTSTR
TrackedIsmDuplicateString (
    IN      PCTSTR String
            TRACKING_DEF
    )
{
    PCTSTR result;

    TRACK_ENTER();

    if (!g_IsmPool) {
        g_IsmPool = PmCreateNamedPool ("ISM Pool");
    }

    result = PmDuplicateString (g_IsmPool, String);

    TRACK_LEAVE();
    return result;
}


BOOL
IsmReleaseMemory (
    IN      PCVOID Memory
    )
{
    if (g_IsmPool && Memory) {
        PmReleaseMemory (g_IsmPool, Memory);
        return TRUE;
    } else {
        return FALSE;
    }
}


MIG_OBJECTSTRINGHANDLE
TrackedIsmCreateObjectHandle (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
            TRACKING_DEF
    )
{
    MIG_OBJECTSTRINGHANDLE result;

    TRACK_ENTER();

    result = ObsBuildEncodedObjectStringEx (Node, Leaf, TRUE);

    TRACK_LEAVE();

    return result;
}


BOOL
WINAPI
TrackedIsmCreateObjectStringsFromHandleEx (
    IN      MIG_OBJECTSTRINGHANDLE Handle,
    OUT     PCTSTR *Node,               OPTIONAL
    OUT     PCTSTR *Leaf,               OPTIONAL
    IN      BOOL DoNotDecode
            TRACKING_DEF
    )
{
    BOOL result;

    TRACK_ENTER();
    result = ObsSplitObjectStringEx (
                Handle,
                Node,
                Leaf,
                NULL,
                !DoNotDecode
                );

    if (!result) {
        if (Node) {
            *Node = NULL;
        }

        if (Leaf) {
            *Leaf = NULL;
        }
    }

    TRACK_LEAVE();

    return result;
}

VOID
IsmDestroyObjectString (
    IN      PCTSTR String
    )
{
    ObsFree (String);
}

VOID
IsmDestroyObjectHandle (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    )
{
    ObsFree (Handle);
}


BOOL
IsmIsObjectHandleNodeOnly (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    )
{
    return ObsGetLeafPortionOfEncodedString (Handle) == NULL;
}


BOOL
IsmIsObjectHandleLeafOnly (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    )
{
    return !ObsHasNode (Handle);
}


PCTSTR
pCreatePatternStr (
    IN      PMIG_SEGMENTS Segments,                 OPTIONAL
    IN      UINT Count
    )
{
    PTSTR result;
    UINT size;
    UINT u;
    PTSTR p;

    if (Segments == ALL_PATTERN) {

        result = DuplicatePathString (TEXT("*"), 0);

    } else if (Segments && Count) {
        //
        // Compute the buffer size needed: logchars * DBCS * escaping + nul
        //

        size = 1;

        for (u = 0; u < Count ; u++) {

            if (!Segments[u].IsPattern) {
                size += TcharCount (Segments[u].Segment) * 2;
            } else {
                size += TcharCount (Segments[u].Segment);
            }
        }

#ifndef UNICODE
        size *= 2;      // account for dbcs expansion
#endif

        result = AllocPathString (size);
        p = result;

        //
        // Build the pattern
        //

        *p = 0;
        for (u = 0; u < Count ; u ++) {

            if (!Segments[u].IsPattern) {
                ObsEncodeString (p, Segments[u].Segment);
                p = GetEndOfString (p);
            } else {
                p = StringCat (p, Segments[u].Segment);
            }
        }

    } else {
        result = DuplicatePathString (TEXT(""), 0);
    }

    return result;
}


MIG_OBJECTSTRINGHANDLE
TrackedIsmCreateObjectPattern (
    IN      PMIG_SEGMENTS NodeSegments,             OPTIONAL
    IN      UINT NodeSegmentsNr,
    IN      PMIG_SEGMENTS LeafSegments,             OPTIONAL
    IN      UINT LeafSegmentsNr
            TRACKING_DEF
    )
{
    PCTSTR node;
    PCTSTR leaf;
    ENCODEDSTRHANDLE result;

    TRACK_ENTER();

    if (NodeSegments == ALL_PATTERN) {
        NodeSegmentsNr = 1;
    }

    if (LeafSegments == ALL_PATTERN) {
        LeafSegmentsNr = 1;
    }

    node = pCreatePatternStr (NodeSegments, NodeSegmentsNr);
    leaf = pCreatePatternStr (LeafSegments, LeafSegmentsNr);

    result = ObsBuildEncodedObjectStringEx (NodeSegmentsNr ? node : NULL, LeafSegmentsNr ? leaf : NULL, FALSE);

    FreePathString (node);
    FreePathString (leaf);

    TRACK_LEAVE();

    return result;
}


MIG_OBJECTSTRINGHANDLE
TrackedIsmCreateSimpleObjectPattern (
    IN      PCTSTR BaseNode,                    OPTIONAL
    IN      BOOL EnumTree,
    IN      PCTSTR Leaf,                        OPTIONAL
    IN      BOOL LeafIsPattern
            TRACKING_DEF
    )
{
    MIG_SEGMENTS nodePat[2];
    MIG_SEGMENTS leafPat[1];
    UINT nrSegNode = 0;
    UINT nrSegLeaf = 0;
    PCTSTR p;
    MIG_OBJECTSTRINGHANDLE result;

    TRACK_ENTER();

    if (BaseNode) {
        nodePat [0].Segment = BaseNode;
        nodePat [0].IsPattern = FALSE;
        nrSegNode ++;
    }

    if (EnumTree) {
        if (nrSegNode) {
            p = _tcsdec2 (BaseNode, GetEndOfString (BaseNode));
            if (p && _tcsnextc (p) == TEXT('\\')) {
                nodePat [nrSegNode].Segment = TEXT("*");
            } else {
                nodePat [nrSegNode].Segment = TEXT("\\*");
            }
        } else {
            nodePat [nrSegNode].Segment = TEXT("*");
        }

        nodePat [nrSegNode].IsPattern = TRUE;
        nrSegNode ++;
    }

    if (Leaf) {
        leafPat [0].Segment = Leaf;
        leafPat [0].IsPattern = LeafIsPattern;
        nrSegLeaf ++;
    } else {
        if (LeafIsPattern) {
            leafPat [0].Segment = TEXT("*");
            leafPat [0].IsPattern = TRUE;
            nrSegLeaf ++;
        }
    }

    result = IsmCreateObjectPattern (nrSegNode?nodePat:NULL, nrSegNode, nrSegLeaf?leafPat:NULL, nrSegLeaf);

    TRACK_LEAVE();

    return result;
}

PTSTR
GetFirstSeg (
    IN      PCTSTR SrcFileName
    )
{
    if (_tcsnextc (SrcFileName) == TEXT('\\')) {
        SrcFileName = _tcsinc (SrcFileName);
        if (_tcsnextc (SrcFileName) == TEXT('\\')) {
            SrcFileName = _tcsinc (SrcFileName);
        }
        return (_tcschr (SrcFileName, TEXT('\\')));
    } else {
        return (_tcschr (SrcFileName, TEXT('\\')));
    }
}


BOOL
pAddShortLongInfo (
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PTSTR nativeName = NULL;
    PTSTR nativeNamePtr;
    PTSTR beginSegPtr;
    PTSTR endSegPtr;
    TCHAR savedChar;
    WIN32_FIND_DATA findData;
    UINT savedEnd;
    UINT beginBuffIdx;
    BOOL result = FALSE;
    KEYHANDLE kh1, kh2;
    BOOL b;

    if (IsmCreateObjectStringsFromHandle (EncodedObjectName, &node, &leaf)) {
        MYASSERT (node);
        if (node) {
            if (leaf) {
                nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node) + SizeOfString (leaf));
            } else {
                nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node));
            }
            nativeNamePtr = AppendWack (nativeName);
            StringCopy (nativeNamePtr, node);
            if (leaf) {
                StringCopy (AppendWack (nativeNamePtr), leaf);
            }

            GbAppendString (&growBuf, S_SHORTLONG_TREE);
            GbAppendString (&growBuf, TEXT("\\"));
            beginBuffIdx = growBuf.End - 1;

            beginSegPtr = GetFirstSeg (nativeNamePtr);

            if (beginSegPtr) {

                beginSegPtr = _tcsinc (beginSegPtr);

                GbAppendStringAB (&growBuf, nativeNamePtr, beginSegPtr);

                while (beginSegPtr) {
                    endSegPtr = _tcschr (beginSegPtr, TEXT('\\'));
                    if (!endSegPtr) {
                        endSegPtr = GetEndOfString (beginSegPtr);
                        MYASSERT (endSegPtr);
                    }

                    savedChar = *endSegPtr;
                    *endSegPtr = 0;

                    if (DoesFileExistEx (nativeNamePtr, &findData)) {
                        if (*findData.cAlternateFileName) {
                            savedEnd = growBuf.End - 1;
                            GbAppendString (&growBuf, findData.cAlternateFileName);
                            kh1 = MemDbAddKey (nativeName);
                            if (kh1) {
                                kh2 = MemDbAddKey ((PCTSTR) growBuf.Buf);
                                if (kh2) {
                                    b = MemDbSetValueByHandle (kh1, FILENAME_LONG);
                                    b = b && MemDbSetValueByHandle (kh2, FILENAME_SHORT);
                                    b = b && MemDbAddDoubleLinkageByKeyHandle (kh1, kh2, 0);
                                } else {
                                    b = FALSE;
                                }

                                if (!b) {
                                    MemDbDeleteKey (nativeName);
                                }
                            }

                            growBuf.End = savedEnd;
                        }
                        GbAppendString (&growBuf, findData.cFileName);
                    } else {
                        GbAppendStringAB (&growBuf, beginSegPtr, endSegPtr);
                    }
                    *endSegPtr = savedChar;
                    if (savedChar) {
                        beginSegPtr = _tcsinc (endSegPtr);
                        GbAppendStringAB (&growBuf, endSegPtr, beginSegPtr);
                    } else {
                        beginSegPtr = NULL;
                    }
                }
            }
            FreePathString (nativeName);
        }
        if (node) {
            IsmDestroyObjectString (node);
        }
        if (leaf) {
            IsmDestroyObjectString (leaf);
        }
    }
    GbFree (&growBuf);
    return result;
}


BOOL
pGetShortName (
    IN      PCTSTR Segment,
    OUT     WIN32_FIND_DATA *FindData
    )
{
    static TCHAR tempDir [MAX_PATH] = TEXT("");
    PCTSTR testFileName;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (tempDir [0] == 0) {
        IsmGetTempDirectory (tempDir, ARRAYSIZE(tempDir));
    }

    testFileName = JoinPaths (tempDir, Segment);
    fileHandle = BfCreateFile (testFileName);
    if (fileHandle) {
        CloseHandle (fileHandle);
        if (DoesFileExistEx (testFileName, FindData)) {
            result = TRUE;
        }
        DeleteFile (testFileName);
    }
    FreePathString (testFileName);
    return result;
}

BOOL
pGetFullSpecShortName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName,
    OUT     PWIN32_FIND_DATA FindData
    )
{
    MIG_CONTENT objectContent;
    BOOL result = FALSE;

    if (IsmAcquireObject (
            ObjectTypeId,
            ObjectName,
            &objectContent
            )) {
        if ((objectContent.Details.DetailsSize == sizeof (WIN32_FIND_DATA)) &&
            (objectContent.Details.DetailsData)
            ) {
            CopyMemory (FindData, objectContent.Details.DetailsData, sizeof (WIN32_FIND_DATA));
            result = TRUE;
        }
        IsmReleaseObject (&objectContent);
    }
    return result;
}

BOOL
pGetStoredShortName (
    IN      PCTSTR ShortLongBase,
    IN      PCTSTR ShortLongSegment,
    OUT     PWIN32_FIND_DATA FindData
    )
{
    KEYHANDLE kh1, kh2;
    DWORD value;
    PCTSTR shortLongSpec;
    PCTSTR lastSeg;
    PCTSTR lastSegPtr;
    DWORD segSize;
    BOOL result = FALSE;

    ZeroMemory (FindData, sizeof (WIN32_FIND_DATA));
    shortLongSpec = JoinPaths (ShortLongBase, ShortLongSegment);
    if (shortLongSpec) {
        kh1 = MemDbGetHandleFromKey (shortLongSpec);
        if (kh1) {
            MemDbGetValueByHandle (kh1, &value);
            if (value == FILENAME_SHORT) {
                // just copy the last segment into FindData->cAlternateFileName
                lastSegPtr = _tcsrchr (shortLongSpec, TEXT('\\'));
                if (lastSegPtr) {
                    lastSegPtr = _tcsinc (lastSegPtr);
                    if (lastSegPtr) {
                        StringCopyTcharCount (
                            FindData->cAlternateFileName,
                            lastSegPtr,
                            ARRAYSIZE(FindData->cAlternateFileName)
                            );
                    }
                }
                // get the long name information
                kh2 = MemDbGetDoubleLinkageByKeyHandle (kh1, 0, 0);
                MYASSERT (kh2);
                if (kh2) {
                    lastSeg = MemDbGetKeyFromHandle (kh2, MEMDB_LAST_LEVEL);
                    // copy lastSeg into FindData->cFileName
                    StringCopyTcharCount (
                        FindData->cFileName,
                        lastSeg,
                        ARRAYSIZE(FindData->cFileName)
                        );
                    MemDbReleaseMemory (lastSeg);
                    result = TRUE;
                }
            } else {
                // just copy the last segment into FindData->cFileName
                lastSegPtr = _tcsrchr (shortLongSpec, TEXT('\\'));
                if (lastSegPtr) {
                    lastSegPtr = _tcsinc (lastSegPtr);
                    if (lastSegPtr) {
                        StringCopyTcharCount (
                            FindData->cFileName,
                            lastSegPtr,
                            ARRAYSIZE(FindData->cFileName)
                            );
                    }
                }
                // get the short name information
                kh2 = MemDbGetDoubleLinkageByKeyHandle (kh1, 0, 0);
                MYASSERT (kh2);
                if (kh2) {
                    if (kh2 != kh1) {
                        lastSeg = MemDbGetKeyFromHandle (kh2, MEMDB_LAST_LEVEL);
                        // copy lastSeg into FindData->cAlternateFileName
                        segSize = TcharCount (lastSeg);
                        if (segSize < ARRAYSIZE(FindData->cAlternateFileName)) {
                            StringCopyTcharCount (
                                FindData->cAlternateFileName,
                                lastSeg,
                                ARRAYSIZE(FindData->cAlternateFileName)
                                );
                        }
                        MemDbReleaseMemory (lastSeg);
                    }
                    result = TRUE;
                }
            }
        }
        FreePathString (shortLongSpec);
    }

    return result;
}

BOOL
pAddShortLongInfoOnDest (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    GROWBUFFER growBuf = INIT_GROWBUFFER;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PTSTR nativeName = NULL;
    PTSTR nativeNamePtr;
    PTSTR beginSegPtr;
    PTSTR endSegPtr;
    PCTSTR shortSeg = NULL;
    TCHAR savedChar;
    WIN32_FIND_DATA findData;
    UINT savedEnd;
    UINT beginBuffIdx;
    BOOL fullSpec;
    BOOL result = FALSE;
    KEYHANDLE kh1, kh2;
    BOOL goOn;

    if (IsmCreateObjectStringsFromHandle (EncodedObjectName, &node, &leaf)) {
        MYASSERT (node);
        if (leaf) {
            nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node) + SizeOfString (leaf));
        } else {
            nativeName = DuplicatePathString (S_SHORTLONG_TREE, SizeOfString (node));
        }
        nativeNamePtr = AppendWack (nativeName);
        StringCopy (nativeNamePtr, node);
        if (leaf) {
            StringCopy (AppendWack (nativeNamePtr), leaf);
        }

        GbAppendString (&growBuf, S_SHORTLONG_TREE);
        GbAppendString (&growBuf, TEXT("\\"));
        beginBuffIdx = growBuf.End - sizeof (TCHAR);

        beginSegPtr = GetFirstSeg (nativeNamePtr);

        if (beginSegPtr) {

            beginSegPtr = _tcsinc (beginSegPtr);

            GbAppendStringAB (&growBuf, nativeNamePtr, beginSegPtr);

            while (beginSegPtr) {
                fullSpec = FALSE;
                endSegPtr = _tcschr (beginSegPtr, TEXT('\\'));
                if (!endSegPtr) {
                    endSegPtr = GetEndOfString (beginSegPtr);
                    MYASSERT (endSegPtr);
                    fullSpec = TRUE;
                }

                savedChar = *endSegPtr;
                *endSegPtr = 0;

                goOn = FALSE;
                goOn = pGetStoredShortName ((PCTSTR) growBuf.Buf, beginSegPtr, &findData);
                if (!goOn && fullSpec) {
                    goOn = pGetFullSpecShortName (ObjectTypeId, EncodedObjectName, &findData);
                }
                if (!goOn) {
                    goOn = pGetShortName (beginSegPtr, &findData);
                }

                if (goOn) {
                    // Special case for when findData.cFileName = "."
                    if (StringIMatch (findData.cFileName, TEXT("."))) {
                        StringCopyTcharCount (
                            findData.cFileName,
                            beginSegPtr,
                            ARRAYSIZE(findData.cFileName)
                            );
                    }
                    if (*findData.cAlternateFileName) {
                        // there is a difference between short and long file name
                        // for the last segment
                        savedEnd = growBuf.End - sizeof (TCHAR);
                        GbAppendString (&growBuf, findData.cAlternateFileName);
                        kh1 = MemDbAddKey (nativeName);
                        if (kh1) {
                            kh2 = MemDbAddKey ((PCTSTR) growBuf.Buf);
                            if (kh2) {
                                goOn = MemDbSetValueByHandle (kh1, FILENAME_LONG);
                                goOn = goOn && MemDbSetValueByHandle (kh2, FILENAME_SHORT);
                                goOn = goOn && MemDbAddDoubleLinkageByKeyHandle (kh1, kh2, 0);
                            } else {
                                goOn = FALSE;
                            }

                            if (!goOn) {
                                MemDbDeleteKey (nativeName);
                            }
                        }
                        growBuf.End = savedEnd;
                    } else {
                        // there is no difference between short and long file name
                        // for the last segment. Let's add it to the tree though,
                        // as a circular reference
                        savedEnd = growBuf.End - sizeof (TCHAR);
                        GbAppendString (&growBuf, findData.cFileName);
                        kh1 = MemDbAddKey (nativeName);
                        if (kh1) {
                            if (StringIMatch (nativeName, (PCTSTR) growBuf.Buf)) {
                                // this is a circular reference
                                kh2 = kh1;
                            } else {
                                kh2 = MemDbAddKey ((PCTSTR) growBuf.Buf);
                            }
                            if (kh2) {
                                goOn = MemDbSetValueByHandle (kh1, FILENAME_LONG);
                                if (kh2 != kh1) {
                                    goOn = goOn && MemDbSetValueByHandle (kh2, FILENAME_SHORT);
                                }
                                goOn = goOn && MemDbAddDoubleLinkageByKeyHandle (kh1, kh2, 0);
                            } else {
                                goOn = FALSE;
                            }

                            if (!goOn) {
                                MemDbDeleteKey (nativeName);
                            }
                        }
                        growBuf.End = savedEnd;
                    }
                    GbAppendString (&growBuf, findData.cFileName);
                } else {
                    GbAppendStringAB (&growBuf, beginSegPtr, endSegPtr);
                }
                *endSegPtr = savedChar;
                if (savedChar) {
                    beginSegPtr = _tcsinc (endSegPtr);
                    GbAppendStringAB (&growBuf, endSegPtr, beginSegPtr);
                } else {
                    beginSegPtr = NULL;
                }
            }
        }
        FreePathString (nativeName);
        if (node) {
            IsmDestroyObjectString (node);
        }
        if (leaf) {
            IsmDestroyObjectString (leaf);
        }
    }
    GbFree (&growBuf);
    return result;
}


MIG_OBJECTID
IsmGetObjectIdFromName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      BOOL MustExist
    )
{
    MIG_OBJECTID result = 0;
    KEYHANDLE objectId;
    PCTSTR decoratedPath;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    __try {
        decoratedPath = GetDecoratedObjectPathFromName (ObjectTypeId, EncodedObjectName, FALSE);

        if (!decoratedPath) {
            __leave;
        }

        if (MustExist) {

            objectId = MemDbGetHandleFromKey (decoratedPath);

        } else {

            objectId = MemDbSetKey (decoratedPath);

            // if GetLastError = ERROR_ALREADY_EXISTS we don't have to do
            // anything, the object is already in our database
            if (GetLastError () == ERROR_SUCCESS) {

                if (MemDbSetValueByHandle (objectId, ObjectTypeId)) {

                    g_TotalObjects.TotalObjects ++;

                    if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                        g_SourceObjects.TotalObjects ++;
                    } else {
                        g_DestinationObjects.TotalObjects ++;
                    }

                    IncrementTotalObjectCount (ObjectTypeId);

                    if (ObjectTypeId == (MIG_FILE_TYPE|PLATFORM_SOURCE)) {
                        //
                        // fire up the short-long algorithm
                        //
                        if (g_IsmCurrentPlatform == PLATFORM_SOURCE) {
                            pAddShortLongInfo (EncodedObjectName);
                        } else {
                            pAddShortLongInfoOnDest (ObjectTypeId, EncodedObjectName);
                        }
                    }

                } else {
                    objectId = 0;
                }
            }

            if (!objectId) {
                EngineError ();
                __leave;
            }
        }

        result = (MIG_OBJECTID) objectId;
    }
    __finally {
        FreePathString (decoratedPath);
        INVALID_POINTER (decoratedPath);
    }

    return result;

}


MIG_OBJECTID
GetObjectIdForModification (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    )
{
    if (!CanObjectTypeBeModified (ObjectTypeId)) {
        return 0;
    }
    return IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);
}


BOOL
pEnumFirstVirtualObject (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    )
{
    PCTSTR decoratedPath = NULL;
    BOOL result = FALSE;
    POBJECTENUM_HANDLE handle;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    ZeroMemory (ObjectEnum, sizeof (MIG_OBJECT_ENUM));
    ObjectEnum->ObjectTypeId = ObjectTypeId;
    ObjectEnum->Handle = MemAllocZeroed (sizeof (OBJECTENUM_HANDLE));

    handle = ObjectEnum->Handle;

    __try {

        if (!ObsHasNode (ObjectPattern)) {
            DEBUGMSG ((DBG_ERROR, "Pattern %s has nul node", ObjectPattern));
            __leave;
        }

        decoratedPath = GetDecoratedObjectPathFromName (ObjectTypeId, ObjectPattern, TRUE);

        if (!decoratedPath) {
            __leave;
        }

        if (DbEnumFirst (
                ObjectTypeId,
                &handle->MemDbEnum,
                decoratedPath,
                &handle->ParsedPatterns
                )) {

            ObjectEnum->ObjectName = handle->MemDbEnum.KeyName;
            ObjectEnum->ObjectId = (MIG_OBJECTID) handle->MemDbEnum.KeyHandle;
            result = TRUE;
        }
    }
    __finally {
        FreePathString (decoratedPath);
        INVALID_POINTER (decoratedPath);

        if (!result) {
            pAbortVirtualObjectEnum (ObjectEnum);
        }
    }

    return result;
}


BOOL
pEnumNextVirtualObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    )
{
    BOOL result = FALSE;
    POBJECTENUM_HANDLE handle;

    handle = ObjectEnum->Handle;

    if (MemDbEnumNext (&handle->MemDbEnum)) {
        ObjectEnum->ObjectName = handle->MemDbEnum.KeyName;
        ObjectEnum->ObjectId = (MIG_OBJECTID) handle->MemDbEnum.KeyHandle;
        result = TRUE;
    } else {
        pAbortVirtualObjectEnum (ObjectEnum);
    }

    return result;
}


VOID
pAbortVirtualObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    )
{
    POBJECTENUM_HANDLE handle;

    handle = ObjectEnum->Handle;

    if (handle) {

        DbEnumFreeStruct (&handle->ParsedPatterns);
        MemDbAbortEnum (&handle->MemDbEnum);

        FreeAlloc (handle);
        INVALID_POINTER (ObjectEnum->Handle);
    }

    ZeroMemory (ObjectEnum, sizeof (MIG_OBJECT_ENUM));
}


BOOL
IsmEnumFirstSourceObjectEx (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      BOOL EnumerateVirtualObjects
    )
{
    //
    // First fix ObjectTypeId
    //
    ObjectTypeId &= (~PLATFORM_MASK);
    ObjectTypeId |= PLATFORM_SOURCE;

    //
    // If this is the destination or we are forced, then we enumerate virtual objects
    //

    if (EnumerateVirtualObjects ||
        (g_IsmModulePlatformContext == PLATFORM_CURRENT && g_IsmCurrentPlatform == PLATFORM_DESTINATION) ||
        g_IsmModulePlatformContext == PLATFORM_DESTINATION
        ) {
        return pEnumFirstVirtualObject (ObjectEnum, ObjectTypeId, ObjectPattern);
    }
    return EnumFirstPhysicalObject (ObjectEnum, ObjectTypeId, ObjectPattern);
}


BOOL
IsmEnumNextObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    )
{
    //
    // Verify enumeration has not completed
    //

    if (!ObjectEnum->Handle) {
        return FALSE;
    }

    //
    // If ObjectId is specified, we are enumerating the ISM
    //

    if (ObjectEnum->ObjectId) {
        return pEnumNextVirtualObject (ObjectEnum);
    }

    //
    // Otherwise we are enumerating physical objects
    //

    return EnumNextPhysicalObject (ObjectEnum);
}


VOID
IsmAbortObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    )
{
    //
    // Verify enumeration has not completed
    //

    if (!ObjectEnum->Handle) {
        return;
    }

    //
    // If ObjectId is specified, we are enumerating the ISM, otherwise we are
    // enumerating physical objects
    //

    if (ObjectEnum->ObjectId) {
        pAbortVirtualObjectEnum (ObjectEnum);
    } else {
        AbortPhysicalObjectEnum (ObjectEnum);
    }

    return;
}


BOOL
IsmEnumFirstDestinationObjectEx (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      BOOL EnumerateVirtualObjects
    )
{
    //
    // First fix ObjectTypeId
    //
    ObjectTypeId &= (~PLATFORM_MASK);
    ObjectTypeId |= PLATFORM_SOURCE;

    //
    // If this is the source, it's illegal
    //
    if (g_IsmCurrentPlatform == PLATFORM_SOURCE) {
        return FALSE;
    }

    if (EnumerateVirtualObjects) {
        return pEnumFirstVirtualObject (ObjectEnum, ObjectTypeId, ObjectPattern);
    }

    return EnumFirstPhysicalObject (ObjectEnum, ObjectTypeId, ObjectPattern);
}


BOOL
IsObjectLocked (
    IN      MIG_OBJECTID ObjectId
    )
{
    UINT flags;

    if (!MemDbGetFlagsByHandle ((KEYHANDLE) ObjectId, &flags)) {
        return FALSE;
    }

    return flags & OBJECT_LOCKED;
}


BOOL
IsHandleLocked (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    )
{
    TCHAR lockKey[256];

    wsprintf (lockKey, S_LOCK_KEY, ObjectId);

    return MemDbTestSingleLinkageValue (lockKey, 0, Handle);
}


BOOL
TestLock (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    )
{
    return IsObjectLocked (ObjectId) || IsHandleLocked (ObjectId, Handle);
}


VOID
pLockHandle (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    )
{
    TCHAR lockKey[256];

    wsprintf (lockKey, S_LOCK_KEY, ObjectId);

    if (!MemDbAddSingleLinkageValue (lockKey, 0, Handle, FALSE)) {
        EngineError ();
    }
}


BOOL
pLockGroup (
    IN      KEYHANDLE ItemId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    pLockHandle ((MIG_OBJECTID) Arg, (KEYHANDLE) ItemId);

    return TRUE;
}


VOID
LockHandle (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    )
{
    RECURSERETURN rc;

    rc = RecurseForGroupItems (
                Handle,
                pLockGroup,
                (ULONG_PTR) ObjectId,
                TRUE,
                FALSE
                );

    if (rc == RECURSE_FAIL || rc == RECURSE_SUCCESS) {
        return;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    pLockHandle (ObjectId, Handle);
}


VOID
IsmLockObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    if (!MemDbSetFlagsByHandle (ObjectId, OBJECT_LOCKED, 0)) {
        EngineError ();
    }
}


VOID
IsmLockObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        IsmLockObjectId (objectId);
    }
}


PCTSTR
GetObjectNameForDebugMsg (
    IN      MIG_OBJECTID ObjectId
    )
{
    static TCHAR buffer[256];
    PCTSTR name;

    name = MemDbGetKeyFromHandle ((KEYHANDLE) ObjectId, 1);

    if (name) {
        StackStringCopy (buffer, name);
        MemDbReleaseMemory (name);
    } else {
        StringCopy (buffer, TEXT("<invalid object>"));
    }

    return name;
}


PCTSTR
pIsValidCName (
    IN      PCTSTR Name
    )
{
    UINT u;

    if (!Name) {
        return NULL;
    }

    if (!__iscsymf (_tcsnextc (Name))) {
        return NULL;
    }

    Name = _tcsinc (Name);
    u = 1;

    while (*Name) {
        if (!__iscsym (_tcsnextc (Name))) {
            return Name;
        }

        Name = _tcsinc (Name);
        u++;
    }

    if (u > 64) {
        return NULL;
    }

    return Name;
}


BOOL
IsValidCName (
    IN      PCTSTR Name
    )
{
    PCTSTR p;
    BOOL result = FALSE;

    p = pIsValidCName (Name);
    if (p && (!*p)) {
        result = TRUE;
    } else {
        SetLastError (ERROR_INVALID_NAME);
    }

    return TRUE;
}


BOOL
IsValidCNameWithDots (
    IN      PCTSTR Name
    )
{
    PCTSTR p;

    p = pIsValidCName (Name);

    while (p && _tcsnextc (p) == TEXT('.')) {
        p = _tcsinc (p);
        p = pIsValidCName (p);
    }

    return p && (*p == 0);
}


BOOL
MarkGroupIds (
    IN      PCTSTR MemDbKey
    )
{
    UINT flags;
    PTSTR keyCopy;
    PTSTR p;
    PTSTR start;
    BOOL b = FALSE;

    keyCopy = DuplicateText (MemDbKey);

    __try {

        p = (PTSTR) FindLastWack (keyCopy);
        if (!p) {
            __leave;
        }

        start = _tcschr (p + 1, TEXT('.'));

        //
        // Make sure all groups in the string are legal
        //

        p = start;

        while (p) {
            *p = 0;

            if (MemDbGetFlags (keyCopy, &flags)) {
                if (flags & ITEM_ID) {
                    DEBUGMSG ((DBG_ERROR, "Group already used as item. Key=%s", keyCopy));
                    __leave;
                }
            }

            *p = TEXT('.');
            p = _tcschr (p + 1, TEXT('.'));
        }

        if (MemDbGetFlags (keyCopy, &flags)) {
            if (flags & GROUP_ID) {
                DEBUGMSG ((DBG_ERROR, "Item already used as group. Key=%s", keyCopy));
                __leave;
            }
        }

        //
        // Mark all groups
        //

        p = start;

        while (p) {
            *p = 0;

            if (!MemDbSetFlags (keyCopy, GROUP_ID, 0)) {
                EngineError ();
                __leave;
            }

            *p = TEXT('.');
            p = _tcschr (p + 1, TEXT('.'));
        }

        //
        // Mark the item
        //

        b = MemDbSetFlags (keyCopy, ITEM_ID, 0);

        if (!b) {
            EngineError ();
        }
    }
    __finally {
        FreeText (keyCopy);
    }

    return b;
}


BOOL
IsGroupId (
    IN      KEYHANDLE Id
    )
{
    UINT flags;

    if (!MemDbGetFlagsByHandle (Id, &flags)) {
        return FALSE;
    }

    return flags & GROUP_ID;
}


BOOL
IsItemId (
    IN      KEYHANDLE Id
    )
{
    UINT flags;

    if (!MemDbGetFlagsByHandle (Id, &flags)) {
        return FALSE;
    }

    return flags & ITEM_ID;
}


KEYHANDLE
GetGroupOfId (
    IN      KEYHANDLE GroupOrItemId
    )
{
    PTSTR key;
    PTSTR p;
    PTSTR lastDot;
    KEYHANDLE result = 0;

    key = (PTSTR) MemDbGetKeyFromHandle (GroupOrItemId, 0);
    if (!key) {
        return 0;
    }

    __try {
        p = (PTSTR) FindLastWack (key);
        if (!p) {
            __leave;
        }

        lastDot = NULL;

        do {
            p = _tcschr (p + 1, TEXT('.'));
            if (p) {
                lastDot = p;
            }
        } while (p);

        if (!lastDot) {
            __leave;
        }

        *lastDot = 0;

        result = MemDbGetHandleFromKey (key);

        MYASSERT (!result || IsGroupId (result));
    }
    __finally {
        MemDbReleaseMemory (key);
    }

    return result;
}


BOOL
pGroupRegistrationWorker (
    IN OUT  PGROUPREGISTRATION_ENUM EnumPtr
    )
{
    EnumPtr->GroupOrItemId = EnumPtr->EnumStruct.KeyHandle;
    MYASSERT (EnumPtr->EnumStruct.Flags & (GROUP_ID|ITEM_ID));
    EnumPtr->ItemId = (EnumPtr->EnumStruct.Flags & ITEM_ID) != 0;

    return TRUE;
}


BOOL
EnumFirstGroupRegistration (
    OUT     PGROUPREGISTRATION_ENUM EnumPtr,
    IN      KEYHANDLE GroupId
    )
{
    BOOL b;
    PCTSTR key;
    PCTSTR pattern;

    if (!IsGroupId (GroupId)) {
        DEBUGMSG ((DBG_ERROR, "EnumFirstGroupRegistration: GroupId is invalid"));
        return FALSE;
    }

    key = MemDbGetKeyFromHandle (GroupId, 0);
    if (!key) {
        return 0;
    }

    pattern = JoinText (key, TEXT(".*"));

    MemDbReleaseMemory (key);
    INVALID_POINTER (key);

    b = MemDbEnumFirst (
            &EnumPtr->EnumStruct,
            pattern,
            ENUMFLAG_NORMAL,
            ENUMLEVEL_ALLLEVELS,
            ENUMLEVEL_ALLLEVELS
            );

    FreeText (pattern);
    INVALID_POINTER (pattern);

    if (!b) {
        return FALSE;
    }

    return pGroupRegistrationWorker (EnumPtr);
}


BOOL
EnumNextGroupRegistration (
    IN OUT  PGROUPREGISTRATION_ENUM EnumPtr
    )
{
    if (!MemDbEnumNext (&EnumPtr->EnumStruct)) {
        return FALSE;
    }

    return pGroupRegistrationWorker (EnumPtr);
}


VOID
AbortGroupRegistrationEnum (
    IN      PGROUPREGISTRATION_ENUM EnumPtr
    )
{
    MemDbAbortEnum (&EnumPtr->EnumStruct);
    ZeroMemory (EnumPtr, sizeof (GROUPREGISTRATION_ENUM));
}


RECURSERETURN
RecurseForGroupItems (
    IN      KEYHANDLE GroupId,
    IN      GROUPITEM_CALLBACK Callback,
    IN      ULONG_PTR Arg,
    IN      BOOL ExecuteOnly,
    IN      BOOL LogicalOrOnResults
    )
{
    PCTSTR groupKey = NULL;
    PCTSTR enumKey = NULL;
    MEMDB_ENUM e;
    UINT pass;
    RECURSERETURN result = RECURSE_FAIL;
    BOOL b;
    BOOL oneSuccess = FALSE;

    if (!IsGroupId (GroupId)) {
        return RECURSE_NOT_NEEDED;
    }

    groupKey = MemDbGetKeyFromHandle (GroupId, 0);
    enumKey = JoinText (groupKey, TEXT(".*"));
    MemDbReleaseMemory (groupKey);

    __try {

        for (pass = ExecuteOnly ? 1 : 0 ; pass < 2 ; pass++) {

            //
            // Enumerate all attributes (skip attribute subgroups)
            //

            if (MemDbEnumFirst (
                    &e,
                    enumKey,
                    ENUMFLAG_NORMAL,
                    ENUMLEVEL_ALLLEVELS,
                    ENUMLEVEL_ALLLEVELS
                    )) {

                do {

                    if (IsItemId (e.KeyHandle)) {
                        //
                        // Pass 0 is for query, pass 1 is for execute
                        //

                        b = Callback (e.KeyHandle, pass == 0, Arg);

                        if (LogicalOrOnResults) {
                            oneSuccess |= b;
                        } else if (!b) {
                            MemDbAbortEnum (&e);
                            __leave;
                        }
                    }

                } while (MemDbEnumNext (&e));
                MemDbAbortEnum (&e);
            }
        }

        if (LogicalOrOnResults) {
            if (!oneSuccess) {
                __leave;
            }
        }

        result = RECURSE_SUCCESS;
    }
    __finally {

        FreeText (enumKey);
        INVALID_POINTER (enumKey);

    }

    return result;
}


BOOL
DbEnumFillStruct (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR Pattern,
    OUT     PDBENUM_ARGS Args
    )
{
    PWSTR p, q;
    PWSTR plainPatternEnd = NULL;
    PWSTR patternCopy;
    PCWSTR node;
    PCWSTR leaf;
    BOOL freeNode = TRUE;

    Args->ObjectTypeId = ObjectTypeId;

    //
    // Split the pattern into a node and leaf pattern
    //

    patternCopy = (PWSTR) CreateUnicode (Pattern);
    ObsSplitObjectStringW (patternCopy, &node, &leaf);

    if (!node) {
        node = L"*";
        freeNode = FALSE;
    }

    DestroyUnicode (patternCopy);
    INVALID_POINTER (patternCopy);

    //
    // Find the first level in node that has a pattern.  Then
    // truncate the node and parse it as a "plain" pattern.
    // This makes sure a node pattern such as c:\foo\* will
    // match c:\foo itself.
    //

    patternCopy = DuplicateTextW (node);
    p = patternCopy;
    plainPatternEnd = patternCopy;

    while (p && *p) {

        MYASSERT (*plainPatternEnd);

        q = (PWSTR) ObsFindNonEncodedCharInEncodedStringW (p, L'\\');

        if (!q) {
            p = GetEndOfStringW (p);
        } else {
            p = q;
            *p = 0;
        }

        if (ObsFindNonEncodedCharInEncodedStringW (plainPatternEnd, L'*') ||
            ObsFindNonEncodedCharInEncodedStringW (plainPatternEnd, L'?')
            ) {
            *plainPatternEnd = 0;
            break;
        }

        plainPatternEnd = p;

        if (q) {
            *p = L'\\';
            p++;
        }
    }

    if (plainPatternEnd && *plainPatternEnd == 0 && *patternCopy) {

        Args->PlainNodeParsedPattern = CreateParsedPatternW (patternCopy);

    } else {

        Args->PlainNodeParsedPattern = NULL;

    }

    //
    // Fill the rest of the struct, clean up and exit
    //

    Args->NodeParsedPattern = CreateParsedPatternW (node);
    if (leaf) {
        Args->LeafParsedPattern = CreateParsedPatternW (leaf);
    } else {
        Args->LeafParsedPattern = NULL;
    }

    if (freeNode) {
        ObsFreeW (node);
        INVALID_POINTER (node);
    }

    ObsFreeW (leaf);
    INVALID_POINTER (leaf);

    FreeTextW (patternCopy);
    INVALID_POINTER (patternCopy);

    return TRUE;
}


VOID
DbEnumFreeStruct (
    IN      PDBENUM_ARGS Args
    )
{
    if (Args->PlainNodeParsedPattern) {
        DestroyParsedPatternW (Args->PlainNodeParsedPattern);
        INVALID_POINTER (Args->PlainNodeParsedPattern);
    }

    if (Args->NodeParsedPattern) {
        DestroyParsedPatternW (Args->NodeParsedPattern);
        INVALID_POINTER (Args->NodeParsedPattern);
    }

    if (Args->LeafParsedPattern) {
        DestroyParsedPatternW (Args->LeafParsedPattern);
        INVALID_POINTER (Args->LeafParsedPattern);
    }

    ZeroMemory (Args, sizeof (DBENUM_ARGS));
}


BOOL
DbEnumFind (
    IN      PCWSTR KeySegment
    )
{
    //
    // Does KeySegment have a pattern?
    //

    if (ObsFindNonEncodedCharInEncodedStringW (KeySegment, L'*') ||
        ObsFindNonEncodedCharInEncodedStringW (KeySegment, L'?')
        ) {
        return TRUE;
    }

    return FALSE;
}


BOOL
DbEnumMatch (
    IN      PCVOID InboundArgs,
    IN      PCWSTR CurrentKey
    )
{
    PDBENUM_ARGS args;
    PCWSTR node;
    PCWSTR leaf;
    PCWSTR newLeaf;
    BOOL result = FALSE;
    WCHAR dummy[] = L"";

    args = (PDBENUM_ARGS) InboundArgs;

    CurrentKey = wcschr (CurrentKey, L'\\');
    MYASSERT (CurrentKey);

    if (!CurrentKey) {
        return FALSE;
    }

    CurrentKey++;

    //
    // Split current key into node and leaf
    //

    ObsSplitObjectStringW (CurrentKey, &node, &leaf);

    MYASSERT (args->NodeParsedPattern);

    if (node) {

        //
        // Test node against parsed pattern
        //

        if (args->NodeParsedPattern) {
            result = TestParsedPatternW (args->NodeParsedPattern, node);
            if (!result && args->PlainNodeParsedPattern) {
                result = TestParsedPatternW (args->PlainNodeParsedPattern, node);
            }

            if (result) {
                if (leaf) {
                    result = FALSE;
                    if (args->LeafParsedPattern) {
                        result = TestParsedPatternW (args->LeafParsedPattern, leaf);
                        if (!result &&
                            ((args->ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) &&
                            (wcschr (leaf, L'.') == NULL)
                            ) {
                            newLeaf = JoinTextW (leaf, L".");
                            result = TestParsedPatternW (args->LeafParsedPattern, newLeaf);
                            FreeTextW (newLeaf);
                        }
                    }
                } else {
                    if (args->LeafParsedPattern &&
                        args->PlainNodeParsedPattern &&
                        TestParsedPatternW (args->PlainNodeParsedPattern, node)
                        ) {
                        result = FALSE;
                    }
                }
            }
        }
    } else {

        //
        // Test empty node against parsed pattern
        //

        if (args->NodeParsedPattern) {
            result = TestParsedPatternW (args->NodeParsedPattern, dummy);
            if (!result && args->PlainNodeParsedPattern) {
                result = TestParsedPatternW (args->PlainNodeParsedPattern, dummy);
            }

            if (result) {
                if (leaf) {
                    result = FALSE;
                    if (args->LeafParsedPattern) {
                        result = TestParsedPatternW (args->LeafParsedPattern, leaf);
                    }
                }
            }
        }
    }

    ObsFreeW (node);
    INVALID_POINTER (node);

    ObsFreeW (leaf);
    INVALID_POINTER (leaf);

    return result;
}


BOOL
DbEnumFirst (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    OUT     PMEMDB_ENUM EnumPtr,
    IN      PCTSTR PatternString,
    OUT     PDBENUM_ARGS ArgsStruct
    )
{
    MEMDB_PATTERNSTRUCTW callbacks;
    PCTSTR objectPattern;

    objectPattern = _tcschr (PatternString, TEXT('\\'));
    if (!objectPattern) {
        MYASSERT (FALSE);
        return FALSE;
    }

    objectPattern++;

#ifdef DEBUG
    {
        PCTSTR p;

        //
        // Verify pattern string base is not a pattern.  This is
        // required, because we assume the first level will not
        // use enumeration, but will use direct lookup.
        //

        p = _tcschr (PatternString, TEXT('*'));
        MYASSERT (!p || p >= objectPattern);

        p = _tcschr (PatternString, TEXT('?'));
        MYASSERT (!p || p >= objectPattern);
    }

#endif

    DbEnumFillStruct (ObjectTypeId, objectPattern, ArgsStruct);

    callbacks.PatternFind = DbEnumFind;
    callbacks.PatternMatch = DbEnumMatch;
    callbacks.Data = ArgsStruct;

    return MemDbEnumFirstEx (
                EnumPtr,
                PatternString,
                ENUMFLAG_NORMAL,
                1,
                ENUMLEVEL_ALLLEVELS,
                &callbacks
                );

}

BOOL
IsmRegisterRestoreCallback (
    IN      PMIG_RESTORECALLBACK RestoreCallback
    )
{
    PRESTORE_STRUCT restoreStruct;

    restoreStruct = (PRESTORE_STRUCT) PmGetMemory (g_IsmPool, sizeof (RESTORE_STRUCT));
    restoreStruct->RestoreCallback = RestoreCallback;
    restoreStruct->Next = g_RestoreCallbacks;
    g_RestoreCallbacks = restoreStruct;
    return TRUE;
}

BOOL
EnumFirstRestoreCallback (
    OUT     PMIG_RESTORECALLBACK_ENUM RestoreCallbackEnum
    )
{
    RestoreCallbackEnum->RestoreStruct = g_RestoreCallbacks;
    if (RestoreCallbackEnum->RestoreStruct) {
        RestoreCallbackEnum->RestoreCallback = RestoreCallbackEnum->RestoreStruct->RestoreCallback;
        return TRUE;
    }
    return FALSE;
}

BOOL
EnumNextRestoreCallback (
    IN OUT  PMIG_RESTORECALLBACK_ENUM RestoreCallbackEnum
    )
{
    if (!RestoreCallbackEnum->RestoreStruct) {
        return FALSE;
    }
    RestoreCallbackEnum->RestoreStruct = RestoreCallbackEnum->RestoreStruct->Next;
    if (RestoreCallbackEnum->RestoreStruct) {
        RestoreCallbackEnum->RestoreCallback = RestoreCallbackEnum->RestoreStruct->RestoreCallback;
        return TRUE;
    }
    return FALSE;
}

VOID
pFreeRestoreCallbacks (
    VOID
    )
{
    PRESTORE_STRUCT restoreStruct, oldStruct;

    restoreStruct = g_RestoreCallbacks;
    while (restoreStruct) {
        oldStruct = restoreStruct;
        restoreStruct = restoreStruct->Next;
        PmReleaseMemory (g_IsmPool, oldStruct);
    }
    g_RestoreCallbacks = NULL;
}


BOOL
IsmRegisterCompareCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_COMPARECALLBACK CompareCallback
    )
{
    PCOMPARE_STRUCT compareStruct;

    compareStruct = (PCOMPARE_STRUCT) PmGetMemory (g_IsmPool, sizeof (COMPARE_STRUCT));
    compareStruct->ObjectTypeId = ObjectTypeId;
    compareStruct->CompareCallback = CompareCallback;
    compareStruct->Next = g_CompareCallbacks;
    g_CompareCallbacks = compareStruct;
    return TRUE;
}

BOOL
EnumFirstCompareCallback (
    OUT     PMIG_COMPARECALLBACK_ENUM CompareCallbackEnum
    )
{
    CompareCallbackEnum->CompareStruct = g_CompareCallbacks;
    if (CompareCallbackEnum->CompareStruct) {
        CompareCallbackEnum->CompareCallback = CompareCallbackEnum->CompareStruct->CompareCallback;
        return TRUE;
    }
    return FALSE;
}

BOOL
EnumNextCompareCallback (
    IN OUT  PMIG_COMPARECALLBACK_ENUM CompareCallbackEnum
    )
{
    if (!CompareCallbackEnum->CompareStruct) {
        return FALSE;
    }
    CompareCallbackEnum->CompareStruct = CompareCallbackEnum->CompareStruct->Next;
    if (CompareCallbackEnum->CompareStruct) {
        CompareCallbackEnum->CompareCallback = CompareCallbackEnum->CompareStruct->CompareCallback;
        return TRUE;
    }
    return FALSE;
}

VOID
pFreeCompareCallbacks (
    VOID
    )
{
    PCOMPARE_STRUCT compareStruct, oldStruct;

    compareStruct = g_CompareCallbacks;
    while (compareStruct) {
        oldStruct = compareStruct;
        compareStruct = compareStruct->Next;
        PmReleaseMemory (g_IsmPool, oldStruct);
    }
    g_CompareCallbacks = NULL;
}

BOOL
pCompareFileContent (
    IN      PCTSTR File1,
    IN      PCTSTR File2
    )
{
    HANDLE fileHandle1 = NULL;
    HANDLE fileHandle2 = NULL;
#define BUFFER_SIZE 4096
    BYTE buffer1[BUFFER_SIZE], buffer2[BUFFER_SIZE];
    BOOL result = FALSE;
    BOOL res1, res2;
    DWORD read1, read2;

    __try {
        fileHandle1 = BfOpenReadFile (File1);
        fileHandle2 = BfOpenReadFile (File2);

        if (fileHandle1 && fileHandle2) {
            while (TRUE) {
                if (IsmCheckCancel ()) {
                    result = FALSE;
                    break;
                }
                res1 = ReadFile (fileHandle1, buffer1, BUFFER_SIZE, &read1, NULL);
                res2 = ReadFile (fileHandle2, buffer2, BUFFER_SIZE, &read2, NULL);
                if (!res1 && !res2) {
                    result = TRUE;
                    break;
                }
                if (res1 && res2) {
                    if (read1 != read2) {
                        break;
                    }
                    if (read1 == 0) {
                        result = TRUE;
                        break;
                    }
                    if (!TestBuffer (buffer1, buffer2, read1)) {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
    }
    __finally {
        if (fileHandle1) {
            CloseHandle (fileHandle1);
            fileHandle1 = NULL;
        }
        if (fileHandle2) {
            CloseHandle (fileHandle2);
            fileHandle2 = NULL;
        }
    }
    return result;
}

BOOL
pDefaultCompare (
    IN      PMIG_CONTENT Object1,
    IN      PMIG_CONTENT Object2,
    OUT     PBOOL DifferentDetailsOnly  OPTIONAL
    )
{
    UINT index;
    PWIN32_FIND_DATAW find1, find2;
    PUBINT src;
    PUBINT dest;
    UINT remainder;
    UINT count;
    DWORD allAttribs;
    DWORD extendedAttribs;
    BOOL result = TRUE;

    *DifferentDetailsOnly = FALSE;

    if (Object1->ContentInFile != Object2->ContentInFile) {
        result = FALSE;
    } else {
        if (Object1->ContentInFile) {
            if (Object1->FileContent.ContentPath && Object2->FileContent.ContentPath) {
                result = pCompareFileContent (Object1->FileContent.ContentPath, Object2->FileContent.ContentPath);
            } else {
                result = FALSE;
            }
        } else {
            if (Object1->MemoryContent.ContentSize == Object2->MemoryContent.ContentSize) {
                if (Object1->MemoryContent.ContentBytes && Object2->MemoryContent.ContentBytes) {
                    result = TestBuffer (
                                Object1->MemoryContent.ContentBytes,
                                Object2->MemoryContent.ContentBytes,
                                Object1->MemoryContent.ContentSize
                                );
                } else {
                    result = FALSE;
                }
            } else {
                result = FALSE;
            }
        }
    }

    if (result) {

        if (Object1->Details.DetailsSize == Object2->Details.DetailsSize) {
            if (Object1->Details.DetailsData && Object2->Details.DetailsData) {
                result = TestBuffer (
                            Object1->Details.DetailsData,
                            Object2->Details.DetailsData,
                            Object1->Details.DetailsSize
                            );
            } else {
                result = FALSE;
            }
        } else {
            result = FALSE;
        }

        if (!result) {
            if (DifferentDetailsOnly) {
                *DifferentDetailsOnly = TRUE;
            }
        }
    }

    return result;
}

BOOL
IsmAreObjectsIdentical (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PMIG_CONTENT SrcContent,
    IN      MIG_OBJECTTYPEID DestObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE DestObjectName,
    IN      PMIG_CONTENT DestContent,
    OUT     PBOOL DifferentDetailsOnly  OPTIONAL
    )

/*++

Routine Description:

  IsmAreObjectsIdentical determines if two objects are identical or not.
  If they are of a different type they are automatically different.
  The compare callbacks are all called passing them the information
  that if previous callbacks already gave a resolution. If no
  compare callback is found valid, a default compare (binary compare) will
  be performed.

Arguments:

  SrcObjectTypeId   - Specifies the first object type ID
  SrcObjectName     - Specifies the first object name
  SrcContent        - Specifies the first object content
  DestObjectTypeId  - Specifies the second object type ID
  DestObjectName    - Specifies the second object name
  DestContent       - Specifies the second object content
  DifferentDetailsOnly - If the objects are different, tells the caller
                         that only the details (not the actual content)
                         were different

Return Value:

  TRUE if the objects are identical, FALSE otherwise

--*/

{
    BOOL identical = FALSE;
    BOOL detailsOnly = FALSE;
    MIG_COMPARECALLBACK_ENUM compareEnum;
    BOOL alreadyProcessed = FALSE;

    //
    // verify the parameters
    //
    if ((SrcContent == NULL) || (DestContent == NULL)) {
        if (DifferentDetailsOnly) {
            *DifferentDetailsOnly = FALSE;
        }
        return (SrcContent == DestContent);
    }

    //
    // Are object type IDs different?
    //
    SrcObjectTypeId &= (~PLATFORM_MASK);
    DestObjectTypeId &= (~PLATFORM_MASK);
    if (SrcObjectTypeId != DestObjectTypeId) {
        return FALSE;
    }

    //
    // Call compare callbacks
    //

    if (EnumFirstCompareCallback (&compareEnum)) {
        do {
            if (compareEnum.CompareCallback (
                    alreadyProcessed,
                    SrcObjectTypeId,
                    SrcObjectName,
                    SrcContent,
                    DestObjectTypeId,
                    DestObjectName,
                    DestContent,
                    &identical,
                    &detailsOnly
                    )) {
                // this callback worked
                alreadyProcessed = TRUE;
            }
        } while (EnumNextCompareCallback (&compareEnum));
    }

    if (!alreadyProcessed) {
        return pDefaultCompare (SrcContent, DestContent, DifferentDetailsOnly);
    }

    if (DifferentDetailsOnly) {
        *DifferentDetailsOnly = detailsOnly;
    }
    return identical;
}


ULONG_PTR
IsmSendMessageToApp (
    UINT Message,
    ULONG_PTR Arg
    )
{
    if (g_MessageCallback) {
        return g_MessageCallback (Message, Arg);
    }

    return 0;
}


MIG_PROGRESSSLICEID
IsmRegisterProgressSlice (
    IN      UINT Ticks,
    IN      UINT TimeEstimateInSeconds
    )
{
    PPROGSLICE slice;
    MIG_PROGRESSSLICEID sliceId;

    if (!TimeEstimateInSeconds || !Ticks) {
        DEBUGMSG ((DBG_WARNING, "Ticks/TimeEstimateInSeconds must not be zero"));
        return 0;
    }

    sliceId = (MIG_PROGRESSSLICEID) (g_SliceBuffer.End / sizeof (PROGSLICE) + 1);
    slice = (PPROGSLICE) GbGrow (&g_SliceBuffer, sizeof (PROGSLICE));

    slice->SliceSize = Ticks;
    slice->CurrentPosition = 0;
    slice->SliceSizeInSeconds = TimeEstimateInSeconds;

    return sliceId;
}


VOID
pCallProgressBar (
    IN      MIG_PROGRESSSTATE State
    )
{
    ULONGLONG temp;
    UINT u;
    PPROGSLICE slice;
    UINT totalTicks = 0;
    UINT currentPos = 0;
    MIG_APPINFO appInfo;

    if (g_ProgressBarFn) {

        for (u = 0 ; u < g_SliceBuffer.End ; u += sizeof (PROGSLICE)) {

            slice = (PPROGSLICE) (g_SliceBuffer.Buf + u);

            temp = (ULONGLONG) slice->CurrentPosition * (ULONGLONG) slice->SliceSizeInSeconds;
            temp *= 10;
            temp /= (ULONGLONG) slice->SliceSize;
            currentPos += (UINT) temp;

            temp = (ULONGLONG) slice->SliceSizeInSeconds * 10;
            totalTicks += (UINT) temp;

        }

        if (State == MIG_END_PHASE) {
            currentPos = totalTicks;
        } else if (State == MIG_BEGIN_PHASE) {
            currentPos = 0;
        }

        g_ProgressBarFn (
            g_CurrentPhase,
            State,
            currentPos,
            totalTicks,
            g_ProgressBarArg
            );
    }
    if (State == MIG_BEGIN_PHASE) {
        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = g_CurrentPhase;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO_NOW, (ULONG_PTR)(&appInfo));
    }
    if (State == MIG_END_PHASE) {
        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));
    }
}


BOOL
IsmTickProgressBar (
    IN      MIG_PROGRESSSLICEID SliceId,
    IN      UINT TickDelta                  OPTIONAL
    )
{
    PPROGSLICE slice;

    if (!g_CurrentPhase || !g_ProgressBarFn) {
        SliceId = 0;
    }

    if (!TickDelta) {
        TickDelta = 1;
    }

    if (SliceId) {
        //
        // Update the slice ID
        //

        SliceId--;

        if (SliceId >= (MIG_PROGRESSSLICEID) (g_SliceBuffer.End / sizeof (PROGSLICE))) {
            DEBUGMSG ((DBG_ERROR, "Invalid slice ID passed to IsmTickProgressBar"));
            return FALSE;
        }

        slice = (PPROGSLICE) g_SliceBuffer.Buf + SliceId;

        if (slice->CurrentPosition < slice->SliceSize) {
            slice->CurrentPosition += TickDelta;
            if (slice->CurrentPosition > slice->SliceSize) {
                slice->CurrentPosition = slice->SliceSize;
            }

            //
            // Call the application's progress callback
            //

            pCallProgressBar (MIG_IN_PHASE);

        } else {
            DEBUGMSG ((DBG_WARNING, "IsmTickProgressBar: Slice already completed"));
        }
    }

    return !CheckCancel();
}


VOID
IsmSetCancel (
    VOID
    )
{
    if (g_CancelEvent) {
        SetEvent (g_CancelEvent);
    }
}

MIG_PLATFORMTYPEID
IsmGetRealPlatform (
    VOID
    )
{
    return g_IsmCurrentPlatform;
}

BOOL
IsmCurrentlyExecuting (
    VOID
    )
{
    return g_ExecutionInProgress;
}


BOOL
IsmCreateUser (
    IN      PCTSTR UserName,
    IN      PCTSTR Domain
    )
{
    if (g_TempProfile) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot call IsmCreateUser more than once"));
        return FALSE;
    }

    // record that we attempted to create the user
    pRecordUserData (
        UserName,
        Domain,
        NULL,
        NULL,
        TRUE
        );

    g_TempProfile = OpenTemporaryProfile (UserName, Domain);

    if (g_TempProfile) {
        // record that we created the user
        pRecordUserData (
            UserName,
            Domain,
            g_TempProfile->UserStringSid,
            g_TempProfile->UserProfileRoot,
            TRUE
            );
        // prepare the user journal
        pPrepareUserJournal (g_TempProfile);
        // let ETM module know this
        BroadcastUserCreation (g_TempProfile);
    }

    return g_TempProfile != NULL;
}

MIG_PARSEDPATTERN
IsmCreateParsedPattern (
    IN      MIG_OBJECTSTRINGHANDLE EncodedObject
    )
{
    return (MIG_PARSEDPATTERN)ObsCreateParsedPattern (EncodedObject);
}

VOID
IsmDestroyParsedPattern (
    IN      MIG_PARSEDPATTERN ParsedPattern
    )
{
    ObsDestroyParsedPattern ((POBSPARSEDPATTERN)ParsedPattern);
}

BOOL
IsmParsedPatternMatchEx (
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      MIG_OBJECTTYPEID ObjectTypeId,      OPTIONAL
    IN      PCTSTR Node,                        OPTIONAL
    IN      PCTSTR Leaf                         OPTIONAL
    )
{
    BOOL result = TRUE;
    PTSTR newLeaf;
    PTSTR tempString;
    POBSPARSEDPATTERN obsParsedPattern = (POBSPARSEDPATTERN) ParsedPattern;

    MYASSERT (Node && obsParsedPattern->NodePattern);
    if (!(Node && obsParsedPattern->NodePattern)) {
       return FALSE;
    }

    if (((obsParsedPattern->Flags & OBSPF_NOLEAF) && Leaf) ||
        ((obsParsedPattern->Flags & OBSPF_EXACTLEAF) && !Leaf)
        ) {
        return FALSE;
    }

    if (!TestParsedPattern (obsParsedPattern->NodePattern, Node)) {
        //
        // let's try one more time with a wack at the end
        //
        tempString = JoinText (Node, TEXT("\\"));
        result = TestParsedPattern (obsParsedPattern->NodePattern, tempString);
        FreeText (tempString);
        if (!result) {
            return FALSE;
        }
    }

    if (Leaf) {
        if (!obsParsedPattern->LeafPattern) {
            return FALSE;
        }
        result = TestParsedPattern (obsParsedPattern->LeafPattern, Leaf);
        if (!result &&
            ((ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) &&
            (_tcschr (Leaf, TEXT('.')) == NULL)
            ) {
            newLeaf = JoinText (Leaf, TEXT("."));
            if (newLeaf) {
                result = TestParsedPattern (obsParsedPattern->LeafPattern, newLeaf);
                FreeText (newLeaf);
            } else {
                result = FALSE;
            }
        }
    } else {
        if (!obsParsedPattern->ExactRoot) {
            result = FALSE;
        }
    }
    return result;
}

BOOL
IsmParsedPatternMatch (
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      MIG_OBJECTTYPEID ObjectTypeId,      OPTIONAL
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTSTR decodedNode;
    PTSTR decodedLeaf;
    BOOL b;

    if (!IsmCreateObjectStringsFromHandle (ObjectName, &decodedNode, &decodedLeaf)) {
        return FALSE;
    }

    b = IsmParsedPatternMatchEx (ParsedPattern, ObjectTypeId, decodedNode, decodedLeaf);

    IsmDestroyObjectString (decodedNode);
    IsmDestroyObjectString (decodedLeaf);

    return b;
}

BOOL
IsmGetMappedUserData (
    OUT     PMIG_USERDATA UserData
    )
{
    if (UserData && g_TempProfile) {
        ZeroMemory (UserData, sizeof (MIG_USERDATA));
        UserData->UserName = g_TempProfile->UserName;
        UserData->DomainName = g_TempProfile->DomainName;
        UserData->AccountName = g_TempProfile->AccountName;
        UserData->UserProfileRoot = g_TempProfile->UserProfileRoot;
        UserData->UserSid = g_TempProfile->UserSid;
    }
    return (g_TempProfile != NULL);
}

BOOL
IsmAddControlFile (
    IN      PCTSTR ObjectName,
    IN      PCTSTR NativePath
    )
{
    MIG_OBJECTSTRINGHANDLE memDbObjectName;
    TCHAR tempFile[MAX_TCHAR_PATH];

    if (g_IsmCurrentPlatform == PLATFORM_CURRENT) {
        DEBUGMSG ((DBG_WHOOPS, "IsmSetPlatform must be called before IsmAddControlFile"));
        return FALSE;
    }

    // Do not start with a | special character
    if (*ObjectName == TEXT('|')) {
        return FALSE;
    }

    // INF file paths are limited to MAX_PATH in size
    if (SizeOfString (NativePath) > ARRAYSIZE(tempFile)) {
        return FALSE;
    }

    IsmGetTempFile (tempFile, ARRAYSIZE (tempFile));

    if (!CopyFile (NativePath, tempFile, FALSE)) {
        return FALSE;
    }

    // Add filename to hashtable for cleanup
    HtAddString (g_ControlFileTable, tempFile);

    memDbObjectName = IsmCreateObjectHandle (TEXT("External"), ObjectName);
    DataTypeAddObject (memDbObjectName, tempFile, TRUE);
    IsmDestroyObjectHandle (memDbObjectName);

    return TRUE;
}

BOOL
IsmGetControlFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      PTSTR Buffer      // Required to be MAX_PATH_PLUS_NUL in size
    )
{
    MIG_CONTENT content;
    TCHAR tempFile[MAX_TCHAR_PATH];
    BOOL result = FALSE;

    if (IsmAcquireObject (ObjectTypeId, ObjectName, &content)) {
        MYASSERT (content.ContentInFile);

        if ((content.ContentInFile) &&
            (SizeOfString (content.FileContent.ContentPath) < ARRAYSIZE(tempFile))) {
            IsmGetTempFile (tempFile, ARRAYSIZE (tempFile));

            if (CopyFile (content.FileContent.ContentPath, tempFile, FALSE)) {
                // Return a copy of the filename
                StringCopy (Buffer, tempFile);

                // Add filename to hashtable for cleanup
                HtAddString (g_ControlFileTable, tempFile);

                result = TRUE;
            }
        }
    }
    return result;
}

BOOL
IsmSetRollbackJournalType (
    IN      BOOL Common
    )
{
    TCHAR winDir [MAX_PATH];
    PCURRENT_USER_DATA currentUserData;
    BOOL result = FALSE;

    if (g_JournalUsed) {
        return FALSE;
    }
    if (g_JournalDirectory) {
        FreePathString (g_JournalDirectory);
    }
    if (Common) {
        if (GetWindowsDirectory (winDir, ARRAYSIZE (winDir))) {
            g_JournalDirectory = JoinPaths (winDir, TEXT("usmt2.tmp"));
            result = TRUE;
        }
    } else {
        currentUserData = GetCurrentUserData ();
        if (currentUserData) {
            g_JournalDirectory = JoinPaths (currentUserData->UserProfilePath, TEXT("usmt2.tmp"));
            FreeCurrentUserData (currentUserData);
        }
    }
    return TRUE;
}

BOOL
IsmCanWriteRollbackJournal (
    VOID
    )
{
    BOOL result = TRUE;
    DWORD err;

    if (DoesFileExist (g_JournalDirectory)) {
        FiRemoveAllFilesInTree (g_JournalDirectory);
    }

    if (!BfCreateDirectory (g_JournalDirectory)) {
        err = GetLastError ();
        if ((err == ERROR_ALREADY_EXISTS) ||
            (err == ERROR_ACCESS_DENIED)
            ) {
            result = FALSE;
        }
    }

    if (result) {
        FiRemoveAllFilesInTree (g_JournalDirectory);
    }

    return result;
}

VOID
pRecordUserData (
    IN      PCTSTR UserName,
    IN      PCTSTR UserDomain,
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath,
    IN      BOOL ProfileCreated
    )
{
    LONGLONG lastPos;
    TCHAR userName [MAX_TCHAR_PATH];
    TCHAR userDomain [MAX_TCHAR_PATH];
    TCHAR userStringSid [MAX_TCHAR_PATH];
    TCHAR userProfilePath [MAX_TCHAR_PATH];
    DWORD dontCare;

    if (g_RollbackMode) {
        return;
    }

    if (!g_JournalDirectory) {
        DEBUGMSG ((DBG_WHOOPS, "Journal directory does not exist."));
        return;
    }

    if (!g_JournalHandle) {
        DEBUGMSG ((DBG_WHOOPS, "Journal file is not opened."));
        return;
    }

    // If the file position is just after the journal header we'll just write
    // the info, otherwise we are going to save the current position,
    // write our data and restore the file position.

    if (!BfGetFilePointer (g_JournalHandle, &lastPos)) {
        DEBUGMSG ((DBG_WHOOPS, "Something wrong with the Journal file."));
        return;
    }

    if (lastPos != JOURNAL_HEADER_SIZE) {
        if (!BfSetFilePointer (g_JournalHandle, JOURNAL_HEADER_SIZE)) {
            DEBUGMSG ((DBG_WHOOPS, "Something wrong with the Journal file."));
            return;
        }
    }

    // now write the info
    ZeroMemory (userName, MAX_TCHAR_PATH);
    ZeroMemory (userDomain, MAX_TCHAR_PATH);
    ZeroMemory (userStringSid, MAX_TCHAR_PATH);
    ZeroMemory (userProfilePath, MAX_TCHAR_PATH);
    if (UserName) {
        StringCopyTcharCount (userName, UserName, MAX_TCHAR_PATH);
    }
    if (UserDomain) {
        StringCopyTcharCount (userDomain, UserDomain, MAX_TCHAR_PATH);
    }
    if (UserStringSid) {
        StringCopyTcharCount (userStringSid, UserStringSid, MAX_TCHAR_PATH);
    }
    if (UserProfilePath) {
        StringCopyTcharCount (userProfilePath, UserProfilePath, MAX_TCHAR_PATH);
    }
    WriteFile (
        g_JournalHandle,
        userName,
        MAX_TCHAR_PATH,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        userDomain,
        MAX_TCHAR_PATH,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        userStringSid,
        MAX_TCHAR_PATH,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        userProfilePath,
        MAX_TCHAR_PATH,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        &ProfileCreated,
        sizeof (BOOL),
        &dontCare,
        NULL
        );
    if (lastPos != JOURNAL_HEADER_SIZE) {
        BfSetFilePointer (g_JournalHandle, lastPos);
    }
}

VOID
IsmRecordOperation (
    IN      DWORD OperationType,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
#ifdef PRERELEASE
    // crash hooks
#define MAX_OBJECTTYPES 20
    static DWORD totalObjects = 0;
    static DWORD typeObjects[MAX_OBJECTTYPES] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    MIG_OBJECTTYPEID objTypeId;
    PCTSTR nativeName = NULL;
    BOOL doCrash = FALSE;
#endif
    static GROWBUFFER buffer = INIT_GROWBUFFER;
    static DWORD backupIdx = 0;

    TCHAR destFile [13];
    PCTSTR destFullPath;
    DWORD entrySize = 0;
    WIN32_FIND_DATA findData;
    MIG_CONTENT objectContent;
    DWORD dontCare;

    if (g_RollbackMode) {
        return;
    }

    if (!g_JournalDirectory) {
        DEBUGMSG ((DBG_WHOOPS, "Journal directory does not exist."));
        return;
    }

    if (!g_JournalHandle) {
        DEBUGMSG ((DBG_WHOOPS, "Journal file is not opened."));
        return;
    }

    ObjectTypeId &= (~PLATFORM_MASK);

    buffer.End = 0;

    switch (OperationType) {
    case JRNOP_CREATE:

#ifdef PRERELEASE
        // crash hooks
        totalObjects ++;
        if (g_CrashCountObjects == totalObjects) {
            doCrash = TRUE;
        }
        objTypeId = ObjectTypeId & (~PLATFORM_MASK);
        if (objTypeId && (objTypeId <= MAX_OBJECTTYPES)) {
            typeObjects [objTypeId - 1]++;
            if ((g_CrashCountTypeId == objTypeId) &&
                (g_CrashCountType == typeObjects [objTypeId - 1])
                ) {
                doCrash = TRUE;
            }
        }
        if (g_CrashNameTypeId == objTypeId) {
            nativeName = IsmGetNativeObjectName (objTypeId, ObjectName);
            if (StringIMatch (nativeName, g_CrashNameObject)) {
                doCrash = TRUE;
            }
            IsmReleaseMemory (nativeName);
        }
#endif

        GbAppendDword (&buffer, OperationType);
        CopyMemory (GbGrow (&buffer, sizeof (MIG_OBJECTTYPEID)), &ObjectTypeId, sizeof (MIG_OBJECTTYPEID));
        GbAppendDword (&buffer, SizeOfString (ObjectName));
        GbCopyString (&buffer, ObjectName);
        entrySize = buffer.End;
        break;
    case JRNOP_DELETE:
        if (!IsmAcquireObject (
                ObjectTypeId | PLATFORM_DESTINATION,
                ObjectName,
                &objectContent
                )) {
            return;
        }
        GbAppendDword (&buffer, OperationType);
        CopyMemory (GbGrow (&buffer, sizeof (MIG_OBJECTTYPEID)), &ObjectTypeId, sizeof (MIG_OBJECTTYPEID));
        GbAppendDword (&buffer, SizeOfString (ObjectName));
        GbCopyString (&buffer, ObjectName);
        GbAppendDword (&buffer, sizeof (MIG_CONTENT));
        CopyMemory (GbGrow (&buffer, sizeof (MIG_CONTENT)), &objectContent, sizeof (MIG_CONTENT));
        if (objectContent.Details.DetailsSize && objectContent.Details.DetailsData) {
            GbAppendDword (&buffer, objectContent.Details.DetailsSize);
            CopyMemory (
                GbGrow (&buffer, objectContent.Details.DetailsSize),
                objectContent.Details.DetailsData,
                objectContent.Details.DetailsSize
                );
        } else {
            GbAppendDword (&buffer, 0);
        }
        if (objectContent.ContentInFile) {
            if (DoesFileExistEx (objectContent.FileContent.ContentPath, &findData) &&
                ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                ) {
                // extra data is the relative path to the backup copy of this file
                backupIdx ++;
                wsprintf (destFile, TEXT("%08d.BAK"), backupIdx);
                destFullPath = JoinPaths (g_JournalDirectory, destFile);
                BfCopyAndFlushFile (objectContent.FileContent.ContentPath, destFullPath, FALSE);
                FreePathString (destFullPath);
                GbAppendDword (&buffer, SizeOfString (destFile));
                GbCopyString (&buffer, destFile);
            } else {
                GbAppendDword (&buffer, 0);
            }
        } else {
            // extra data is the actual content
            GbAppendDword (&buffer, objectContent.MemoryContent.ContentSize);
            if (objectContent.MemoryContent.ContentSize) {
                CopyMemory (
                    GbGrow (&buffer, objectContent.MemoryContent.ContentSize),
                    objectContent.MemoryContent.ContentBytes,
                    objectContent.MemoryContent.ContentSize
                    );
            }
        }
        entrySize = buffer.End;
        IsmReleaseObject (&objectContent);
        break;
    default:
        DEBUGMSG ((DBG_WHOOPS, "Wrong operation type in pRecordOperation: %d", OperationType));
        return;
    }
    WriteFile (
        g_JournalHandle,
        &entrySize,
        sizeof (DWORD),
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        buffer.Buf,
        buffer.End,
        &dontCare,
        NULL
        );
    WriteFile (
        g_JournalHandle,
        &entrySize,
        sizeof (DWORD),
        &dontCare,
        NULL
        );
    FlushFileBuffers (g_JournalHandle);

#ifdef PRERELEASE
    if (doCrash) {
        DebugBreak ();
    }
#endif

    g_JournalUsed = TRUE;
}

BOOL
IsmSetDelayedOperationsCommand (
    IN      PCTSTR DelayedOperationsCommand
    )
{
    if (g_DelayedOperationsCommand) {
        FreePathString (g_DelayedOperationsCommand);
    }
    g_DelayedOperationsCommand = DuplicatePathString (DelayedOperationsCommand, 0);

    return TRUE;
}

VOID
IsmRecordDelayedOperation (
    IN      DWORD OperationType,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    static GROWBUFFER buffer = INIT_GROWBUFFER;
    static DWORD backupIdx = 0;

    TCHAR destFile [13];
    PCTSTR destFullPath;
    DWORD entrySize = 0;
    WIN32_FIND_DATA findData;
    DWORD dontCare;

    if (!g_TempProfile ||
        !g_TempProfile->DelayedOpJrn ||
        !g_TempProfile->DelayedOpJrnHandle ||
        (g_TempProfile->DelayedOpJrnHandle == INVALID_HANDLE_VALUE)
        ) {
        DEBUGMSG ((DBG_WHOOPS, "Delayed operations Journal does not exist."));
        return;
    }

    ObjectTypeId &= (~PLATFORM_MASK);

    buffer.End = 0;

    switch (OperationType) {
    case JRNOP_DELETE:

        GbAppendDword (&buffer, OperationType);
        CopyMemory (GbGrow (&buffer, sizeof (MIG_OBJECTTYPEID)), &ObjectTypeId, sizeof (MIG_OBJECTTYPEID));
        GbAppendDword (&buffer, SizeOfString (ObjectName));
        GbCopyString (&buffer, ObjectName);
        entrySize = buffer.End;
        break;
    case JRNOP_CREATE:
    case JRNOP_REPLACE:
        GbAppendDword (&buffer, OperationType);
        CopyMemory (GbGrow (&buffer, sizeof (MIG_OBJECTTYPEID)), &ObjectTypeId, sizeof (MIG_OBJECTTYPEID));
        GbAppendDword (&buffer, SizeOfString (ObjectName));
        GbCopyString (&buffer, ObjectName);
        GbAppendDword (&buffer, sizeof (MIG_CONTENT));
        CopyMemory (GbGrow (&buffer, sizeof (MIG_CONTENT)), ObjectContent, sizeof (MIG_CONTENT));
        if (ObjectContent->Details.DetailsSize && ObjectContent->Details.DetailsData) {
            GbAppendDword (&buffer, ObjectContent->Details.DetailsSize);
            CopyMemory (
                GbGrow (&buffer, ObjectContent->Details.DetailsSize),
                ObjectContent->Details.DetailsData,
                ObjectContent->Details.DetailsSize
                );
        } else {
            GbAppendDword (&buffer, 0);
        }
        if (ObjectContent->ContentInFile) {
            if (DoesFileExistEx (ObjectContent->FileContent.ContentPath, &findData) &&
                ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                ) {
                // extra data is the relative path to the backup copy of this file
                backupIdx ++;
                wsprintf (destFile, TEXT("%08d.BAK"), backupIdx);
                destFullPath = JoinPaths (g_TempProfile->DelayedOpJrn, destFile);
                BfCopyAndFlushFile (ObjectContent->FileContent.ContentPath, destFullPath, FALSE);
                FreePathString (destFullPath);
                GbAppendDword (&buffer, SizeOfString (destFile));
                GbCopyString (&buffer, destFile);
            } else {
                GbAppendDword (&buffer, 0);
            }
        } else {
            // extra data is the actual content
            GbAppendDword (&buffer, ObjectContent->MemoryContent.ContentSize);
            if (ObjectContent->MemoryContent.ContentSize) {
                CopyMemory (
                    GbGrow (&buffer, ObjectContent->MemoryContent.ContentSize),
                    ObjectContent->MemoryContent.ContentBytes,
                    ObjectContent->MemoryContent.ContentSize
                    );
            }
        }
        entrySize = buffer.End;
        break;
    default:
        DEBUGMSG ((DBG_WHOOPS, "Wrong operation type in IsmRecordDelayedOperation: %d", OperationType));
        return;
    }
    WriteFile (
        g_TempProfile->DelayedOpJrnHandle,
        &entrySize,
        sizeof (DWORD),
        &dontCare,
        NULL
        );
    WriteFile (
        g_TempProfile->DelayedOpJrnHandle,
        buffer.Buf,
        buffer.End,
        &dontCare,
        NULL
        );
    WriteFile (
        g_TempProfile->DelayedOpJrnHandle,
        &entrySize,
        sizeof (DWORD),
        &dontCare,
        NULL
        );
    FlushFileBuffers (g_TempProfile->DelayedOpJrnHandle);
}

PMIG_OBJECTCOUNT
IsmGetObjectsStatistics (
    IN      MIG_OBJECTTYPEID ObjectTypeId   OPTIONAL
    )
{
    if ((ObjectTypeId & (~PLATFORM_MASK)) == 0) {
        if (ObjectTypeId & PLATFORM_SOURCE) {
            return &g_SourceObjects;
        } else if (ObjectTypeId & PLATFORM_DESTINATION) {
            return &g_DestinationObjects;
        } else {
            return &g_TotalObjects;
        }
    } else {
        return GetTypeObjectsStatistics (ObjectTypeId);
    }
}


VOID
EngineError (
    VOID
    )
{
    LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_ENGINE_FAILURE));
    IsmSetCancel();
}

BOOL
IsmGetOsVersionInfo (
    IN      MIG_PLATFORMTYPEID Platform,
    OUT     PMIG_OSVERSIONINFO VersionInfo
    )
{
    TCHAR tempStr [sizeof (UINT) * 2 + 3];

    if (!VersionInfo) {
        return FALSE;
    }

    ZeroMemory (VersionInfo, sizeof (MIG_OSVERSIONINFO));

    if (Platform == PLATFORM_CURRENT) {
        Platform = g_IsmCurrentPlatform;
    }

    if (!IsmGetEnvironmentString (
            Platform,
            NULL,
            S_VER_OSTYPE,
            tempStr,
            sizeof(tempStr),
            NULL
            )) {
        return FALSE;
    }
    _stscanf (tempStr, TEXT("%lx"), &(VersionInfo->OsType));

    if (!IsmGetEnvironmentString (
            Platform,
            NULL,
            S_VER_OSMAJOR,
            tempStr,
            sizeof(tempStr),
            NULL
            )) {
        return FALSE;
    }
    _stscanf (tempStr, TEXT("%lx"), &(VersionInfo->OsMajorVersion));

    if (!IsmGetEnvironmentString (
            Platform,
            NULL,
            S_VER_OSMINOR,
            tempStr,
            sizeof(tempStr),
            NULL
            )) {
        return FALSE;
    }
    _stscanf (tempStr, TEXT("%lx"), &(VersionInfo->OsMinorVersion));

    if (!IsmGetEnvironmentString (
            Platform,
            NULL,
            S_VER_OSBUILD,
            tempStr,
            sizeof(tempStr),
            NULL
            )) {
        return FALSE;
    }
    _stscanf (tempStr, TEXT("%lx"), &(VersionInfo->OsBuildNumber));

    if (VersionInfo->OsType == OSTYPE_WINDOWS9X) {
        VersionInfo->OsTypeName = OSTYPE_WINDOWS9X_STR;
        if (VersionInfo->OsMajorVersion == OSMAJOR_WIN95) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WIN95_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersion = OSMINOR_GOLD;
            }
        }
        if (VersionInfo->OsMajorVersion == OSMAJOR_WIN95OSR2) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WIN95OSR2_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersion = OSMINOR_GOLD;
            }
        }
        if (VersionInfo->OsMajorVersion == OSMAJOR_WIN98) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WIN98_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersion = OSMINOR_GOLD;
            }
            if (VersionInfo->OsMinorVersion == OSMINOR_WIN98SE) {
                VersionInfo->OsMinorVersionName = OSMINOR_WIN98SE_STR;
            }
        }
        if (VersionInfo->OsMajorVersion == OSMAJOR_WINME) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WINME_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersion = OSMINOR_GOLD;
            }
        }
    }
    if (VersionInfo->OsType == OSTYPE_WINDOWSNT) {
        VersionInfo->OsTypeName = OSTYPE_WINDOWSNT_STR;
        if (VersionInfo->OsMajorVersion == OSMAJOR_WINNT4) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WINNT4_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersionName = OSMINOR_GOLD_STR;
            }
        }
        if (VersionInfo->OsMajorVersion == OSMAJOR_WINNT5) {
            VersionInfo->OsMajorVersionName = OSMAJOR_WINNT5_STR;
            if (VersionInfo->OsMinorVersion == OSMINOR_GOLD) {
                VersionInfo->OsMinorVersionName = OSMINOR_GOLD_STR;
            }
            if (VersionInfo->OsMinorVersion == OSMINOR_WINNT51) {
                VersionInfo->OsMinorVersionName = OSMINOR_WINNT51_STR;
            }
        }
    }

    return TRUE;
}

BOOL
pGetFunctionData (
    IN      PCTSTR FunctionMultiSz,
    OUT     PCTSTR *FunctionId,
    OUT     PCTSTR *MultiSzCopy
    )
{
    GROWBUFFER buf = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    BOOL result = TRUE;

    if (!FunctionMultiSz) {
        return FALSE;
    }
    if (!FunctionId) {
        return FALSE;
    }
    if (!MultiSzCopy) {
        return FALSE;
    }
    *FunctionId = NULL;
    *MultiSzCopy = NULL;
    buf.End = 0;
    if (result && EnumFirstMultiSz (&e, FunctionMultiSz)) {
        do {
            GbMultiSzAppend (&buf, e.CurrentString);
        } while (EnumNextMultiSz (&e));
    }
    if (buf.End) {
        *MultiSzCopy = IsmGetMemory (buf.End);
        CopyMemory ((PTSTR)(*MultiSzCopy), buf.Buf, buf.End);
    } else {
        result = FALSE;
    }
    buf.End = 0;
    if (result && EnumFirstMultiSz (&e, FunctionMultiSz)) {
        do {
            GbAppendString (&buf, e.CurrentString);
            GbAppendString (&buf, TEXT(";"));
        } while (EnumNextMultiSz (&e));
    }
    if (buf.End) {
        *FunctionId = IsmGetMemory (buf.End);
        CopyMemory ((PTSTR)(*FunctionId), buf.Buf, buf.End);
    } else {
        result = FALSE;
    }
    if (!result) {
        if (*MultiSzCopy) {
            IsmReleaseMemory (*MultiSzCopy);
            *MultiSzCopy = NULL;
        }
        if (*FunctionId) {
            IsmReleaseMemory (*FunctionId);
            *FunctionId = NULL;
        }
    }
    return result;
}

BOOL
IsmExecuteFunction (
    IN      UINT ExecutionPhase,
    IN      PCTSTR FunctionMultiSz
    )
{
    PCTSTR functionId;
    PCTSTR functionMultiSz;
    BOOL result = FALSE;

    switch (ExecutionPhase) {
    case MIG_EXECUTE_PREPROCESS:
        if (g_PreProcessTable) {
            if (pGetFunctionData (FunctionMultiSz, &functionId, &functionMultiSz)) {
                HtAddStringEx (g_PreProcessTable, functionId, &functionMultiSz, FALSE);
                IsmReleaseMemory (functionId);
            }
        }
        result = TRUE;
        break;
    case MIG_EXECUTE_REFRESH:
        if (g_RefreshTable) {
            if (pGetFunctionData (FunctionMultiSz, &functionId, &functionMultiSz)) {
                HtAddStringEx (g_RefreshTable, functionId, &functionMultiSz, FALSE);
                IsmReleaseMemory (functionId);
            }
        }
        result = TRUE;
        break;
    case MIG_EXECUTE_POSTPROCESS:
        if (g_PostProcessTable) {
            if (pGetFunctionData (FunctionMultiSz, &functionId, &functionMultiSz)) {
                HtAddStringEx (g_PostProcessTable, functionId, &functionMultiSz, FALSE);
                IsmReleaseMemory (functionId);
            }
        }
        result = TRUE;
        break;
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ism.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\property.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    property.c

Abstract:

    Implements the property interface of the ISM. Properties are used to
    associate data with objects.  They are identified by name, and a single
    object can have multiple instances of the same property.

Author:

    Jim Schmidt (jimschm) 01-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_PROPERTY    "Property"

//
// Strings
//

#define S_PROPINST          TEXT("PropInst")
#define S_PROPINST_FORMAT   S_PROPINST TEXT("\\%u")
#define S_PROPERTYFILE      TEXT("|PropertyFile")     // pipe is to decorate for uniqueness

//
// Constants
//

#define PROPERTY_FILE_SIGNATURE         0xF062298F
#define PROPERTY_FILE_VERSION           0x00010000

//
// Macros
//

// None

//
// Types
//

typedef enum {
    PROPENUM_GET_NEXT_LINKAGE,
    PROPENUM_GET_NEXT_INSTANCE,
    PROPENUM_RETURN_VALUE,
    PROPENUM_DONE
} PROPENUM_STATE;

typedef struct {
    MIG_PROPERTYID PropertyId;
    LONGLONG DatFileOffset;
} PROPERTY_DATA_REFERENCE, *PPROPERTY_DATA_REFERENCE;

#pragma pack(push,1)

typedef struct {
    DWORD Size;
    WORD PropertyDataType;
    // data follows in the file
} PROPERTY_ITEM_HEADER, *PPROPERTY_ITEM_HEADER;

typedef struct {
    DWORD Signature;
    DWORD Version;
} PROPERTY_FILE_HEADER, *PPROPERTY_FILE_HEADER;

#pragma pack(pop)

typedef struct {

    MIG_PROPERTYID FilterPropertyId;

    MIG_OBJECTID ObjectId;

    PUINT LinkageList;
    UINT LinkageCount;
    UINT LinkageEnumPosition;

    PPROPERTY_DATA_REFERENCE InstanceArray;
    UINT InstanceCount;
    UINT InstancePosition;

    PROPENUM_STATE State;

} OBJECTPROPERTY_HANDLE, *POBJECTPROPERTY_HANDLE;

typedef struct {

    MIG_PROPERTYID PropertyId;

    PUINT LinkageList;
    UINT LinkageCount;
    UINT LinkagePos;

    ENCODEDSTRHANDLE ObjectPath;

} OBJECTWITHPROPERTY_HANDLE, *POBJECTWITHPROPERTY_HANDLE;

typedef struct {
    MIG_OBJECTID ObjectId;
    PCMIG_BLOB Property;
    LONGLONG PreExistingProperty;
} ADDPROPERTYARG, *PADDPROPERTYARG;

//
// Globals
//

PCTSTR g_PropertyDatName;
HANDLE g_PropertyDatHandle;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
InitializeProperties (
    MIG_PLATFORMTYPEID Platform,
    BOOL VcmMode
    )
{
    PROPERTY_FILE_HEADER header;
    TCHAR tempFile [MAX_PATH];
    MIG_OBJECTSTRINGHANDLE propertyObjectName;
    MIG_CONTENT propertyContent;

    //
    // In gather mode, create property.dat in a temp dir.
    // In restore mode, get property.dat from the transport, then
    //      open it.
    //

    if (Platform == PLATFORM_SOURCE) {

        IsmGetTempFile (tempFile, ARRAYSIZE (tempFile));
        g_PropertyDatName = DuplicatePathString (tempFile, 0);

        g_PropertyDatHandle = BfCreateFile (g_PropertyDatName);
        if (g_PropertyDatHandle) {
            header.Signature = PROPERTY_FILE_SIGNATURE;
            header.Version   = PROPERTY_FILE_VERSION;

            if (!BfWriteFile (g_PropertyDatHandle, (PBYTE) &header, sizeof (header))) {
                return FALSE;
            }
            propertyObjectName = IsmCreateObjectHandle (S_PROPERTYFILE, NULL);
            DataTypeAddObject (propertyObjectName, g_PropertyDatName, !VcmMode);
            IsmDestroyObjectHandle (propertyObjectName);
        }
    } else {
        propertyObjectName = IsmCreateObjectHandle (S_PROPERTYFILE, NULL);
        if (IsmAcquireObjectEx (MIG_DATA_TYPE | PLATFORM_SOURCE, propertyObjectName, &propertyContent, CONTENTTYPE_FILE, 0)) {

            BfGetTempFileName (tempFile, ARRAYSIZE (tempFile));
            g_PropertyDatName = DuplicatePathString (tempFile, 0);

            if (CopyFile (propertyContent.FileContent.ContentPath, g_PropertyDatName, FALSE)) {
                g_PropertyDatHandle = BfOpenFile (g_PropertyDatName);
            }
            IsmReleaseObject (&propertyContent);
        } else if (IsmAcquireObjectEx (MIG_DATA_TYPE | PLATFORM_DESTINATION, propertyObjectName, &propertyContent, CONTENTTYPE_FILE, 0)) {
            g_PropertyDatName = DuplicatePathString (propertyContent.FileContent.ContentPath, 0);
            g_PropertyDatHandle = BfOpenFile (g_PropertyDatName);
            IsmReleaseObject (&propertyContent);
        }
        IsmDestroyObjectHandle (propertyObjectName);
    }

    return g_PropertyDatHandle != NULL;
}


VOID
TerminateProperties (
    MIG_PLATFORMTYPEID Platform
    )
{
    if (g_PropertyDatHandle) {
        CloseHandle (g_PropertyDatHandle);
        g_PropertyDatHandle = NULL;
    }
    if (g_PropertyDatName) {
        if (Platform == PLATFORM_DESTINATION) {
            DeleteFile (g_PropertyDatName);
        }
        FreePathString (g_PropertyDatName);
        g_PropertyDatName = NULL;
    }
}


PCTSTR
pGetPropertyNameForDebugMsg (
    IN      MIG_PROPERTYID PropertyId
    )
{
    static TCHAR name[256];

    if (!IsmGetPropertyName (PropertyId, name, ARRAYSIZE(name), NULL, NULL, NULL)) {
        StringCopy (name, TEXT("<invalid property>"));
    }

    return name;
}


PCTSTR
pPropertyPathFromId (
    IN      MIG_PROPERTYID PropertyId
    )
{
    return MemDbGetKeyFromHandle ((UINT) PropertyId, 0);
}


VOID
pPropertyPathFromName (
    IN      PCTSTR PropertyName,
    OUT     PTSTR Path
    )
{
    wsprintf (Path, TEXT("Property\\%s"), PropertyName);
}


LONGLONG
OffsetFromPropertyDataId (
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    PCTSTR p;
    LONGLONG offset;

    p = MemDbGetKeyFromHandle (
            (KEYHANDLE) PropertyDataId,
            MEMDB_LAST_LEVEL
            );

    if (!p) {
        DEBUGMSG ((DBG_ERROR, "Can't get offset from invalid property instance"));
        return 0;
    }

    offset = (LONGLONG) TToU64 (p);

    MemDbReleaseMemory (p);

    return offset;
}


MIG_PROPERTYDATAID
pPropertyDataIdFromOffset (
    IN      LONGLONG DataOffset
    )
{
    TCHAR instanceKey[256];
    KEYHANDLE handle;

    wsprintf (instanceKey, S_PROPINST_FORMAT, DataOffset);

    handle = MemDbGetHandleFromKey (instanceKey);

    if (!handle) {
        return 0;
    }

    return (MIG_PROPERTYDATAID) handle;
}


#if 0

//
// This function is not valid because the assumption it was initially
// implemented with has changed.  It used to be that a property instance
// was associated with a specific property id.  Now the instance is
// just the data, which can be associated with any property!
//

MIG_PROPERTYID
pPropertyIdFromInstance (
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    MIG_PROPERTYID result = 0;
    KEYHANDLE *linkage;
    UINT count;
    PPROPERTY_DATA_REFERENCE dataRef = NULL;
    UINT dataRefSize;
    UINT u;
    LONGLONG offset;

    linkage = (KEYHANDLE *) MemDbGetSingleLinkageArrayByKeyHandle (
                                PropertyDataId,
                                PROPERTY_INDEX,
                                &count
                                );

    count /= sizeof (KEYHANDLE);

    __try {

        if (!linkage || !count) {
            __leave;
        }

        offset = OffsetFromPropertyDataId (PropertyData);
        if (!offset) {
            __leave;
        }

        dataRef = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                    (MIG_OBJECTID) linkage[0],
                                                    PROPERTY_INDEX,
                                                    &dataRefSize
                                                    );

        dataRefSize /= sizeof (PROPERTY_DATA_REFERENCE);

        if (!dataRef || !dataRefSize) {
            __leave;
        }

        for (u = 0 ; u < dataRefSize ; u++) {
            if (dataRef[u].DatFileOffset == offset) {
                result = dataRef[u].PropertyId;
                break;
            }
        }
    }
    __finally {
        MemDbReleaseMemory (linkage);
        INVALID_POINTER (linkage);

        MemDbReleaseMemory (dataRef);
        INVALID_POINTER (dataRef);
    }

    return result;
}

#endif

MIG_PROPERTYID
IsmRegisterProperty (
    IN      PCTSTR Name,
    IN      BOOL Private
    )

/*++

Routine Description:

  IsmRegisterProperty creates a public or private property and returns the
  ID to the caller. If the property already exists, then the existing ID is
  returned to the caller.

Arguments:

  Name    - Specifies the property name to register.
  Private - Specifies TRUE if the property is owned by the calling module
            only, or FALSE if it is shared by all modules. If TRUE is
            specified, the caller must be in an ISM callback function.

Return Value:

  The ID of the property, or 0 if the registration failed.

--*/

{
    TCHAR propertyPath[MEMDB_MAX];
    TCHAR decoratedName[MEMDB_MAX];
    UINT offset;

    if (!g_CurrentGroup && Private) {
        DEBUGMSG ((DBG_ERROR, "IsmRegisterProperty called for private property outside of ISM-managed context"));
        return 0;
    }

    if (!IsValidCNameWithDots (Name)) {
        DEBUGMSG ((DBG_ERROR, "property name \"%s\" is illegal", Name));
        return FALSE;
    }

#ifdef DEBUG
    if (Private && !IsValidCName (g_CurrentGroup)) {
        DEBUGMSG ((DBG_ERROR, "group name \"%s\" is illegal", g_CurrentGroup));
        return FALSE;
    }
#endif

    if (Private) {
        wsprintf (decoratedName, TEXT("%s:%s"), g_CurrentGroup, Name);
    } else {
        wsprintf (decoratedName, S_COMMON TEXT(":%s"), Name);
    }

    pPropertyPathFromName (decoratedName, propertyPath);

    if (!MarkGroupIds (propertyPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered property",
            propertyPath
            ));
        return FALSE;
    }

    offset = MemDbSetKey (propertyPath);

    if (!offset) {
        EngineError ();
        return 0;
    }

    MYASSERT (offset);

    return (MIG_PROPERTYID) offset;
}


BOOL
IsmGetPropertyName (
    IN      MIG_PROPERTYID PropertyId,
    OUT     PTSTR PropertyName,             OPTIONAL
    IN      UINT PropertyNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    )

/*++

Routine Description:

  IsmGetPropertyName obtains the property text name from a numeric ID. It
  also identifies private and owned properties.

Arguments:

  PropertyId            - Specifies the property ID to look up.
  PropertyName          - Receives the property name. The name is filled for
                          all valid PropertyId values, even when the return
                          value is FALSE.
  PropertyNameBufChars  - Specifies the number of TCHARs that PropertyName
                          can hold, including the nul terminator.
  Private               - Receives TRUE if the property is private, or FALSE
                          if it is public.
  BelongsToMe           - Receives TRUE if the property is private and
                          belongs to the caller, FALSE otherwise.
  ObjectReferences      - Receives the number of objects that reference the
                          property

Return Value:

  TRUE if the property is public, or if the property is private and belongs to
  the caller.

  FALSE if the property is private and belongs to someone else. PropertyName,
  Private and BelongsToMe are valid in this case.

  FALSE if PropertyId is not valid. Propertyname, Private and BelongsToMe are
  not modified in this case.  Do not use this function to test if PropertyId
  is valid or not.

--*/


{
    PCTSTR propertyPath = NULL;
    PCTSTR start;
    PTSTR p, q;
    BOOL privateProperty = FALSE;
    BOOL groupMatch = FALSE;
    BOOL result = FALSE;
    UINT references;
    PUINT linkageList;

    __try {
        //
        // Get the property path from memdb, then parse it for group and name
        //

        propertyPath = pPropertyPathFromId (PropertyId);
        if (!propertyPath) {
            __leave;
        }

        p = _tcschr (propertyPath, TEXT('\\'));
        if (!p) {
            __leave;
        }

        start = _tcsinc (p);
        p = _tcschr (start, TEXT(':'));

        if (!p) {
            __leave;
        }

        q = _tcsinc (p);
        *p = 0;

        if (StringIMatch (start, S_COMMON)) {

            //
            // This property is a global property.
            //

            groupMatch = TRUE;

        } else if (g_CurrentGroup) {

            //
            // This property is private. Check if it is ours.
            //

            privateProperty = TRUE;
            groupMatch = StringIMatch (start, g_CurrentGroup);

        } else {

            //
            // This is a private property, but the caller is not
            // a module that can own properties.
            //

            DEBUGMSG ((DBG_WARNING, "IsmGetPropertyName: Caller cannot own private properties"));
        }

        //
        // Copy the name to the buffer, update outbound BOOLs, set result
        //

        if (PropertyName && PropertyNameBufChars >= sizeof (TCHAR)) {
            StringCopyByteCount (PropertyName, q, PropertyNameBufChars * sizeof (TCHAR));
        }

        if (Private) {
            *Private = privateProperty;
        }

        if (ObjectReferences) {
            linkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                PropertyId,
                                PROPERTY_INDEX,
                                &references
                                );

            references /= SIZEOF(KEYHANDLE);

            if (linkageList) {
                MemDbReleaseMemory (linkageList);
                INVALID_POINTER (linkageList);
            } else {
                references = 0;
            }

            *ObjectReferences = references;
        }

        if (BelongsToMe) {
            *BelongsToMe = privateProperty && groupMatch;
        }

        result = groupMatch;
    }
    __finally {
        if (propertyPath) {       //lint !e774
            MemDbReleaseMemory (propertyPath);
            INVALID_POINTER (propertyPath);
        }
    }

    return result;
}


MIG_PROPERTYID
IsmGetPropertyGroup (
    IN      MIG_PROPERTYID PropertyId
    )
{
    return (MIG_PROPERTYID) GetGroupOfId ((KEYHANDLE) PropertyId);
}


LONGLONG
AppendProperty (
    PCMIG_BLOB Property
    )
{
    LONGLONG offset;
    PROPERTY_ITEM_HEADER item;
#ifndef UNICODE
    PCWSTR convStr = NULL;
#endif
    PCBYTE data = NULL;

    if (!g_PropertyDatHandle) {
        MYASSERT (FALSE);
        return 0;
    }

    if (!BfGoToEndOfFile (g_PropertyDatHandle, &offset)) {
        DEBUGMSG ((DBG_ERROR, "Can't seek to end of property.dat"));
        return 0;
    }

    __try {
        switch (Property->Type) {

        case BLOBTYPE_STRING:
#ifndef UNICODE
            convStr = ConvertAtoW (Property->String);
            if (convStr) {
                item.Size = (DWORD) SizeOfStringW (convStr);
                data = (PCBYTE) convStr;
            } else {
                DEBUGMSG ((DBG_ERROR, "Error writing to property.dat"));
                offset = 0;
                __leave;
            }
#else
            item.Size = (DWORD) SizeOfString (Property->String);
            data = (PCBYTE) Property->String;
#endif
            break;

        case BLOBTYPE_BINARY:
            item.Size = (DWORD) Property->BinarySize;
            data = Property->BinaryData;
            break;

        default:
            MYASSERT(FALSE);
            offset = 0;
            __leave;
        }

        item.PropertyDataType = (WORD) Property->Type;

        if (!BfWriteFile (g_PropertyDatHandle, (PCBYTE) &item, sizeof (item)) ||
            !BfWriteFile (g_PropertyDatHandle, data, item.Size)
            ) {

            DEBUGMSG ((DBG_ERROR, "Can't write to property.dat"));
            offset = 0;
            __leave;
        }
    }
    __finally {
    }

#ifndef UNICODE
    if (convStr) {
        FreeConvertedStr (convStr);
        convStr = NULL;
    }
#endif

    return offset;
}


MIG_PROPERTYDATAID
IsmRegisterPropertyData (
    IN      PCMIG_BLOB Property
    )
{
    LONGLONG offset;
    TCHAR offsetString[256];
    KEYHANDLE offsetHandle;

    offset = AppendProperty (Property);
    if (!offset) {
        return 0;
    }

    wsprintf (offsetString, S_PROPINST_FORMAT, offset);
    offsetHandle = MemDbSetKey (offsetString);

    if (!offsetHandle) {
        EngineError ();
    }

    return (MIG_PROPERTYDATAID) offsetHandle;
}


BOOL
GetProperty (
    IN      LONGLONG Offset,
    IN OUT  PGROWBUFFER Buffer,                 OPTIONAL
    OUT     PBYTE PreAllocatedBuffer,           OPTIONAL
    OUT     PUINT Size,                         OPTIONAL
    OUT     PMIG_BLOBTYPE PropertyDataType      OPTIONAL
    )
{
    PBYTE data;
    PROPERTY_ITEM_HEADER item;
#ifndef UNICODE
    PCSTR ansiStr = NULL;
    DWORD ansiSize = 0;
    PBYTE ansiData = NULL;
#endif

    if (!g_PropertyDatHandle) {
        MYASSERT (FALSE);
        return FALSE;
    }

    if (!BfSetFilePointer (g_PropertyDatHandle, Offset)) {
        DEBUGMSG ((DBG_ERROR, "Can't seek to %I64Xh in property.dat", Offset));
        return FALSE;
    }

    if (!BfReadFile (g_PropertyDatHandle, (PBYTE) &item, sizeof (item))) {
        DEBUGMSG ((DBG_ERROR, "Can't read property item header"));
        return FALSE;
    }

#ifndef UNICODE
    if (item.PropertyDataType == BLOBTYPE_STRING) {
        // we have some work to do
        if (PropertyDataType) {
            *PropertyDataType = (MIG_BLOBTYPE) item.PropertyDataType;
        }
        data = IsmGetMemory (item.Size);
        if (!data) {
            return FALSE;
        }
        ZeroMemory (data, item.Size);
        if (!BfReadFile (g_PropertyDatHandle, data, item.Size)) {
            DEBUGMSG ((DBG_ERROR, "Can't read property item"));
            IsmReleaseMemory (data);
            return FALSE;
        }
        ansiStr = ConvertWtoA ((PCWSTR) data);
        if (!ansiStr) {
            DEBUGMSG ((DBG_ERROR, "Can't read property item"));
            IsmReleaseMemory (data);
            return FALSE;
        }
        ansiSize = SizeOfStringA (ansiStr);
        if (Size) {
            *Size = ansiSize;
        }
        if (Buffer || PreAllocatedBuffer) {

            if (PreAllocatedBuffer) {
                CopyMemory (PreAllocatedBuffer, ansiStr, ansiSize);
            } else {
                ansiData = GbGrow (Buffer, ansiSize);
                if (!ansiData) {
                    DEBUGMSG ((DBG_ERROR, "Can't allocate %u bytes", ansiSize));
                    FreeConvertedStr (ansiStr);
                    IsmReleaseMemory (data);
                    return FALSE;
                }
                CopyMemory (ansiData, ansiStr, ansiSize);
            }
        }
        FreeConvertedStr (ansiStr);
        IsmReleaseMemory (data);
    } else {
#endif
        if (Size) {
            *Size = item.Size;
        }

        if (PropertyDataType) {
            *PropertyDataType = (MIG_BLOBTYPE) item.PropertyDataType;
        }

        if (Buffer || PreAllocatedBuffer) {

            if (PreAllocatedBuffer) {
                data = PreAllocatedBuffer;
            } else {
                data = GbGrow (Buffer, item.Size);

                if (!data) {
                    DEBUGMSG ((DBG_ERROR, "Can't allocate %u bytes", item.Size));
                    return FALSE;
                }
            }

            if (!BfReadFile (g_PropertyDatHandle, data, item.Size)) {
                DEBUGMSG ((DBG_ERROR, "Can't read property item"));
                return FALSE;
            }
        }
#ifndef UNICODE
    }
#endif

    return TRUE;
}


BOOL
CreatePropertyStruct (
    IN OUT  PGROWBUFFER Buffer,
    OUT     PMIG_BLOB PropertyStruct,
    IN      LONGLONG Offset
    )
{
    UINT size;
    MIG_BLOBTYPE type;

    //
    // Obtain property size, data and type
    //

    Buffer->End = 0;

    if (!GetProperty (Offset, Buffer, NULL, &size, &type)) {
        DEBUGMSG ((DBG_ERROR, "Error getting op property instance header from dat file"));
        return FALSE;
    }

    //
    // Fill in the property struct
    //

    PropertyStruct->Type = type;

    switch (type) {

    case BLOBTYPE_STRING:
        PropertyStruct->String = (PCTSTR) Buffer->Buf;
        break;

    case BLOBTYPE_BINARY:
        PropertyStruct->BinaryData = Buffer->Buf;
        PropertyStruct->BinarySize = size;
        break;

    default:
        ZeroMemory (PropertyStruct, sizeof (MIG_BLOB));
        break;

    }

    return TRUE;
}


MIG_PROPERTYDATAID
pAddPropertyToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property,
    IN      BOOL QueryOnly,
    IN      PLONGLONG PreExistingProperty       OPTIONAL
    )
{
    PROPERTY_DATA_REFERENCE propertyRef;
    MIG_PROPERTYDATAID result = 0;
    GROWBUFFER buffer = INIT_GROWBUFFER;
    TCHAR offsetString[256];
    KEYHANDLE offsetHandle;
    UINT u;
    PPROPERTY_DATA_REFERENCE dataRef;
    UINT dataRefSize;

    __try {
        //
        // Is the property id locked?
        //

        if (TestLock (ObjectId, (KEYHANDLE) PropertyId)) {
            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't set property %s on %s because of lock",
                pGetPropertyNameForDebugMsg (PropertyId),
                GetObjectNameForDebugMsg (ObjectId)
                ));
            __leave;
        }

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        //
        // Store the property in the dat file
        //

        propertyRef.PropertyId = PropertyId;

        if (PreExistingProperty) {
            propertyRef.DatFileOffset = *PreExistingProperty;
        } else {
            propertyRef.DatFileOffset = AppendProperty (Property);

            if (!propertyRef.DatFileOffset) {
                __leave;
            }

            if (PreExistingProperty) {
                *PreExistingProperty = propertyRef.DatFileOffset;
            }
        }

        //
        // Link the object to the property, and the object to the property
        // instance and data
        //

        if (!MemDbAddDoubleLinkageByKeyHandle (PropertyId, ObjectId, PROPERTY_INDEX)) {
            DEBUGMSG ((DBG_ERROR, "Can't link object to property"));
            EngineError ();
            __leave;
        }


        dataRef = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                    ObjectId,
                                                    PROPERTY_INDEX,
                                                    &dataRefSize
                                                    );

        dataRefSize /= sizeof (PROPERTY_DATA_REFERENCE);

        if (dataRef && dataRefSize) {
            //
            // Scan the unorderd blob for a zero property id (means "deleted")
            //

            for (u = 0 ; u < dataRefSize ; u++) {
                if (!dataRef[u].PropertyId) {
                    break;
                }
            }

            //
            // If a zero property id was found, use it and update the array
            //

            if (u < dataRefSize) {
                CopyMemory (&dataRef[u], &propertyRef, sizeof (PROPERTY_DATA_REFERENCE));
            } else {
                MemDbReleaseMemory (dataRef);
                dataRef = NULL;
            }
        }

        if (!dataRef) {
            //
            // If the array was initially empty, or if no deleted space was found,
            // then grow the blob by putting the new property reference at the end
            //

            if (!MemDbGrowUnorderedBlobByKeyHandle (
                    ObjectId,
                    PROPERTY_INDEX,
                    (PBYTE) &propertyRef,
                    sizeof (propertyRef)
                    )) {
                DEBUGMSG ((DBG_ERROR, "Can't link property data to property"));
                __leave;
            }
        } else {
            //
            // If the array was not freed, then it has been updated, and it needs
            // to be saved back to memdb.  Do that, then release the memory.
            //

            if (!MemDbSetUnorderedBlobByKeyHandle (
                    ObjectId,
                    PROPERTY_INDEX,
                    (PBYTE) dataRef,
                    dataRefSize * sizeof (PROPERTY_DATA_REFERENCE)
                    )) {
                DEBUGMSG ((DBG_ERROR, "Can't link property data to property (2)"));
                __leave;
            }

            MemDbReleaseMemory (dataRef);
            INVALID_POINTER (dataRef);
        }


        //
        // Link the offset to the object
        //

        wsprintf (offsetString, S_PROPINST_FORMAT, propertyRef.DatFileOffset);
        offsetHandle = MemDbSetKey (offsetString);

        if (!offsetHandle) {
            EngineError ();
            __leave;
        }

        if (!MemDbAddSingleLinkageByKeyHandle (offsetHandle, ObjectId, PROPERTY_INDEX)) {
            DEBUGMSG ((DBG_ERROR, "Can't link dat file offset to object"));
            EngineError ();
            __leave;
        }

        result = (MIG_PROPERTYDATAID) offsetHandle;

    }
    __finally {
        GbFree (&buffer);
    }

    return result;
}


BOOL
pAddPropertyGroup (
    IN      KEYHANDLE PropertyId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    PADDPROPERTYARG myArg = (PADDPROPERTYARG) Arg;

    MYASSERT (IsItemId (PropertyId));

    return pAddPropertyToObjectId (
                myArg->ObjectId,
                (MIG_PROPERTYID) PropertyId,
                myArg->Property,
                FirstPass,
                &myArg->PreExistingProperty
                );
}


MIG_PROPERTYDATAID
IsmAddPropertyToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property
    )
{
    RECURSERETURN rc;
    ADDPROPERTYARG myArg;

    //
    // If PropertyId is a group, set all properties in the group
    //

    myArg.ObjectId = ObjectId;
    myArg.Property = Property;
    myArg.PreExistingProperty = 0;

    rc = RecurseForGroupItems (
                PropertyId,
                pAddPropertyGroup,
                (ULONG_PTR) &myArg,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pAddPropertyToObjectId (ObjectId, PropertyId, Property, FALSE, NULL);
}


MIG_PROPERTYDATAID
IsmAddPropertyToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmAddPropertyToObjectId (objectId, PropertyId, Property);
    }

    return result;
}


BOOL
IsmAddPropertyDataToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    LONGLONG offset;
    MIG_PROPERTYDATAID instance;

    offset = OffsetFromPropertyDataId (PropertyDataId);
    if (!offset) {
        DEBUGMSG ((DBG_ERROR, "Invalid property instance passed to IsmAddPropertyDataToObjectId (2)"));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    instance = pAddPropertyToObjectId (
                    ObjectId,
                    PropertyId,
                    NULL,
                    FALSE,
                    &offset
                    );

    return instance != 0;
}


BOOL
IsmAddPropertyDataToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId,
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmAddPropertyDataToObjectId (objectId, PropertyId, PropertyDataId);
    }

    return result;
}


VOID
IsmLockProperty (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    )
{
    LockHandle (ObjectId, (KEYHANDLE) PropertyId);
}


BOOL
IsmGetPropertyData (
    IN      MIG_PROPERTYDATAID PropertyDataId,
    OUT     PBYTE Buffer,                               OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT PropertyDataSize,                     OPTIONAL
    OUT     PMIG_BLOBTYPE PropertyDataType              OPTIONAL
    )
{
    LONGLONG offset;
    UINT size;

    //
    // Convert the property instance to the property.dat offset
    //

    offset = OffsetFromPropertyDataId (PropertyDataId);
    if (!offset) {
        DEBUGMSG ((DBG_ERROR, "Invalid property instance passed to IsmGetPropertyData"));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Obtain the property data size
    //

    if (!GetProperty (offset, NULL, NULL, &size, PropertyDataType)) {
        DEBUGMSG ((DBG_ERROR, "Error getting property instance header from dat file"));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (PropertyDataSize) {
        *PropertyDataSize = size;
    }

    //
    // If a buffer was specified, check its size and fill it if possible
    //

    if (Buffer) {
        if (BufferSize >= size) {
            if (!GetProperty (offset, NULL, Buffer, NULL, NULL)) {
                DEBUGMSG ((DBG_ERROR, "Error reading property data from dat file"));
                // error code is one of the file api error codes
                return FALSE;
            }
        } else {
            SetLastError (ERROR_MORE_DATA);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
IsmRemovePropertyData (
    IN      MIG_PROPERTYDATAID PropertyDataId
    )
{
    BOOL result = FALSE;
    KEYHANDLE *linkageArray;
    UINT linkageCount;
    UINT u;
    UINT v;
    UINT propertySearch;
    PPROPERTY_DATA_REFERENCE dataRef;
    UINT dataRefSize;
    LONGLONG offset;
    TCHAR instanceKey[256];
    KEYHANDLE lockId = 0;
    BOOL noMoreLeft;
    BOOL b;

    __try {
        //
        // Determine the offset for the property instance
        //

        offset = OffsetFromPropertyDataId (PropertyDataId);
        if (!offset) {
            __leave;
        }

        //
        // Get single linkage list from property instance.  The links point
        // to objects.
        //

        linkageArray = (KEYHANDLE *) MemDbGetSingleLinkageArrayByKeyHandle (
                                            PropertyDataId,                     // handle
                                            PROPERTY_INDEX,
                                            &linkageCount
                                            );

        if (!linkageArray) {
            //
            // Doesn't exist!
            //

            DEBUGMSG ((DBG_ERROR, "Tried to remove invalid property instance"));
            __leave;
        }

        linkageCount /= sizeof (KEYHANDLE);

        if (!linkageCount) {
            DEBUGMSG ((DBG_WHOOPS, "Empty linkage list for property instances"));
            __leave;
        }

        //
        // For all entries in the linkage list, remove the blob entry
        //

        for (u = 0 ; u < linkageCount ; u++) {
            //
            // Check if the object is locked
            //

            if (IsObjectLocked (linkageArray[u])) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "Can't remove property from %s because of object lock",
                    GetObjectNameForDebugMsg (linkageArray[u])
                    ));
                continue;
            }

            if (lockId) {
                //
                // For the first pass, the lockId is unknown. On additional
                // passes, the per-object property lock is checked here.
                //

                if (IsHandleLocked ((MIG_OBJECTID) linkageArray[u], lockId)) {
                    DEBUGMSG ((
                        DBG_WARNING,
                        "Can't remove property from %s because of object lock",
                        GetObjectNameForDebugMsg (linkageArray[u])
                        ));
                    continue;
                }
            }

            //
            // Get the unordered blob for the object
            //

            dataRef = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                        linkageArray[u],
                                                        PROPERTY_INDEX,
                                                        &dataRefSize
                                                        );

            dataRefSize /= sizeof (PROPERTY_DATA_REFERENCE);

            if (!dataRef || !dataRefSize) {
                DEBUGMSG ((DBG_WHOOPS, "Empty propid/offset blob for property instance"));
                continue;
            }

#ifdef DEBUG
            //
            // Assert that the blob has a reference to the offset we are removing
            //

            for (v = 0 ; v < dataRefSize ; v++) {
                if (dataRef[v].DatFileOffset == offset) {
                    break;
                }
            }

            MYASSERT (v < dataRefSize);
#endif

            //
            // Scan the blob for all references to this property instance, then
            // reset the PropertyId member. If removing the property instance
            // causes the property not to be referenced by the object, then
            // also remove the property name linkage.
            //

            noMoreLeft = FALSE;

            for (v = 0 ; v < dataRefSize && !noMoreLeft ; v++) {
                if (dataRef[v].DatFileOffset == offset) {

                    MYASSERT (!lockId || dataRef[v].PropertyId == lockId);

                    //
                    // Check if the per-object property is locked (on the first pass only)
                    //

                    if (!lockId) {
                        lockId = (KEYHANDLE) dataRef[v].PropertyId;

                        if (IsHandleLocked ((MIG_OBJECTID) linkageArray[u], lockId)) {
                            DEBUGMSG ((
                                DBG_WARNING,
                                "Can't remove property from %s because of object lock (2)",
                                GetObjectNameForDebugMsg (linkageArray[u])
                                ));

                            //
                            // noMoreLeft is used to detect this case outside the loop
                            //

                            MYASSERT (!noMoreLeft);
                            break;
                        }
                    }

                    //
                    // Are there more references in this blob to the current property ID?
                    //

                    for (propertySearch = 0 ; propertySearch < dataRefSize ; propertySearch++) {

                        if (propertySearch == v) {
                            continue;
                        }

                        if (dataRef[propertySearch].PropertyId == dataRef[v].PropertyId) {
                            break;
                        }

                    }

                    //
                    // If no other references to property, remove the property name linkage
                    //

                    if (propertySearch >= dataRefSize) {
                        MemDbDeleteDoubleLinkageByKeyHandle (
                            linkageArray[u],
                            dataRef[v].PropertyId,
                            PROPERTY_INDEX
                            );

                        noMoreLeft = TRUE;

                    }

                    //
                    // Reset the current property id (to "deleted" status)
                    //

                    dataRef[v].PropertyId = 0;
                }
            }

            if (v >= dataRefSize || noMoreLeft) {
                //
                // The loop did not terminated early because of a lock,
                // so reapply the change
                //

                b = MemDbSetUnorderedBlobByKeyHandle (
                        linkageArray[u],
                        PROPERTY_INDEX,
                        (PBYTE) dataRef,
                        dataRefSize * sizeof (PROPERTY_DATA_REFERENCE)
                        );
            } else {
                b = TRUE;
            }

            MemDbReleaseMemory (dataRef);

            if (!b) {
                DEBUGMSG ((DBG_ERROR, "Can't re-apply property linkage blob during instance remove"));
                EngineError ();
                __leave;
            }
        }

        //
        // Remove the property instance
        //

        wsprintf (instanceKey, S_PROPINST_FORMAT, offset);
        MemDbDeleteKey (instanceKey);

        result = TRUE;
    }
    __finally {
    }

    return result;
}


BOOL
pRemovePropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      BOOL QueryOnly
    )
{
    BOOL result = FALSE;
    UINT u;
    PPROPERTY_DATA_REFERENCE dataRef = NULL;
    UINT dataRefSize;
    TCHAR instanceKey[256];
    KEYHANDLE propertyData;
    BOOL b;

    __try {
        //
        // Test for locks
        //

        if (TestLock (ObjectId, (KEYHANDLE) PropertyId)) {
            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't remove property %s on %s because of lock",
                pGetPropertyNameForDebugMsg (PropertyId),
                GetObjectNameForDebugMsg (ObjectId)
                ));
            __leave;
        }

        if (QueryOnly) {
            result =  TRUE;
            __leave;
        }

        //
        // Get the unordered blob
        //

        dataRef = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                    ObjectId,
                                                    PROPERTY_INDEX,
                                                    &dataRefSize
                                                    );

        dataRefSize /= sizeof (PROPERTY_DATA_REFERENCE);

        if (!dataRef || !dataRefSize) {
            DEBUGMSG ((DBG_WHOOPS, "Empty propid/offset blob for property removal"));
            __leave;
        }

        //
        // Scan the blob for references to this property
        //

        b = FALSE;

        for (u = 0 ; u < dataRefSize ; u++) {

            if (dataRef[u].PropertyId == PropertyId) {

                //
                // Remove the single linkage from offset to object
                //

                wsprintf (instanceKey, S_PROPINST_FORMAT, dataRef[u].DatFileOffset);
                propertyData = MemDbGetHandleFromKey (instanceKey);

                if (!propertyData) {
                    DEBUGMSG ((DBG_WHOOPS, "Property references non-existent offset"));
                    continue;
                }

                MemDbDeleteSingleLinkageByKeyHandle (propertyData, ObjectId, PROPERTY_INDEX);

                //
                // IMPORTANT: The operation above might have made the property instance
                // key point to nothing (because the last remaining linkage was removed).
                // However, it is critical not to remove the abandoned propertyData key,
                // becase the caller might still have handle to the property instance, and
                // this handle can be applied to a new object later.
                //

                //
                // Now reset the property id ("deleted" state)
                //

                dataRef[u].PropertyId = 0;
                b = TRUE;
            }
        }

        //
        // Reapply the changed blob
        //

        if (b) {
            if (!MemDbSetUnorderedBlobByKeyHandle (
                    ObjectId,
                    PROPERTY_INDEX,
                    (PBYTE) dataRef,
                    dataRefSize * sizeof (PROPERTY_DATA_REFERENCE)
                    )) {
                __leave;
            }
        }

        //
        // Remove the object-to-property name linkage. If this fails and b is FALSE,
        // then the object doesn't have a reference to the property.
        //

        if (!MemDbDeleteDoubleLinkageByKeyHandle (ObjectId, PropertyId, PROPERTY_INDEX)) {
            DEBUGMSG_IF ((b, DBG_WHOOPS, "Can't delete object<->property linkage"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (dataRef) {
            MemDbReleaseMemory (dataRef);
            INVALID_POINTER (dataRef);
        }
    }

    return result;
}


BOOL
pRemovePropertyGroup (
    IN      KEYHANDLE PropertyId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pRemovePropertyFromObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_PROPERTYID) PropertyId,
                FirstPass
                );
}


BOOL
IsmRemovePropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    )
{
    RECURSERETURN rc;

    //
    // If PropertyId is a group, set all attribs in the group
    //

    rc = RecurseForGroupItems (
                PropertyId,
                pRemovePropertyGroup,
                (ULONG_PTR) ObjectId,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pRemovePropertyFromObjectId (ObjectId, PropertyId, FALSE);
}


BOOL
IsmRemovePropertyFromObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmRemovePropertyFromObjectId (objectId, PropertyId);
    }

    return result;
}


BOOL
pIsPropertySetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    )
{
    return MemDbTestDoubleLinkageByKeyHandle (
                ObjectId,
                PropertyId,
                PROPERTY_INDEX
                );
}


BOOL
pQueryPropertyGroup (
    IN      KEYHANDLE PropertyId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pIsPropertySetOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_PROPERTYID) PropertyId
                );
}


BOOL
IsmIsPropertySetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    )
{
    RECURSERETURN rc;

    //
    // If PropertyId is a group, query all properties in the group
    //

    rc = RecurseForGroupItems (
                PropertyId,
                pQueryPropertyGroup,
                (ULONG_PTR) ObjectId,
                TRUE,
                TRUE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pIsPropertySetOnObjectId (ObjectId, PropertyId);
}


BOOL
IsmIsPropertySetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmIsPropertySetOnObjectId (objectId, PropertyId);
    }

    return result;
}


BOOL
IsmEnumFirstObjectPropertyById (
    OUT     PMIG_OBJECTPROPERTY_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID FilterProperty           OPTIONAL
    )
{
    POBJECTPROPERTY_HANDLE handle;
    BOOL b = TRUE;
    UINT size;

    //
    // Initialize the enum structure and alloc an internal data struct
    //

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTPROPERTY_ENUM));

    EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTPROPERTY_HANDLE));
    handle = (POBJECTPROPERTY_HANDLE) EnumPtr->Handle;

    handle->ObjectId = ObjectId;
    handle->FilterPropertyId = FilterProperty;

    if (!handle->ObjectId) {
        IsmAbortObjectPropertyEnum (EnumPtr);
        return FALSE;
    }

    //
    // Property enumeration occurs in the following states
    //
    // 1. Get linkage list of all properties
    // 2. Take first linkage from the list
    // 3. Find the property name
    // 4. Find the first instance of the property in the unordered blob
    // 5. Return the property name and property data to the caller
    // 6. Find the next instance of the property in the undorderd blob
    //      - go back to state 5 if another instance is found
    //      - go to state 7 if no more instances are found
    // 7. Take the next linkage from the list
    //      - go back to state 3 if another linkage exists
    //      - terminate otherwise
    //

    //
    // Get linkage list of all properties
    //

    handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                handle->ObjectId,
                                PROPERTY_INDEX,
                                &handle->LinkageCount
                                );

    handle->LinkageCount /= sizeof (KEYHANDLE);

    if (!handle->LinkageList || !handle->LinkageCount) {
        IsmAbortObjectPropertyEnum (EnumPtr);
        return FALSE;
    }

    handle->LinkageEnumPosition = 0;

    //
    // Get unordered blob that points us into property.dat
    //

    handle->InstanceArray = (PPROPERTY_DATA_REFERENCE) MemDbGetUnorderedBlobByKeyHandle (
                                                            handle->ObjectId,
                                                            PROPERTY_INDEX,
                                                            &size
                                                            );

    if (!handle->InstanceArray || !size) {
        DEBUGMSG ((DBG_WHOOPS, "Object<->Property Instance linkage is broken in enum"));
        IsmAbortObjectPropertyEnum (EnumPtr);
    }

    handle->InstanceCount = size / sizeof (PROPERTY_DATA_REFERENCE);

    //
    // Call next enum routine to continue with state machine
    //

    handle->State = PROPENUM_GET_NEXT_LINKAGE;

    return IsmEnumNextObjectProperty (EnumPtr);
}


BOOL
IsmEnumFirstObjectProperty (
    OUT     PMIG_OBJECTPROPERTY_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID FilterProperty               OPTIONAL
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmEnumFirstObjectPropertyById (EnumPtr, objectId, FilterProperty);
    }

    return result;
}

BOOL
IsmEnumNextObjectProperty (
    IN OUT  PMIG_OBJECTPROPERTY_ENUM EnumPtr
    )
{
    POBJECTPROPERTY_HANDLE handle;
    PPROPERTY_DATA_REFERENCE propData;

    handle = (POBJECTPROPERTY_HANDLE) EnumPtr->Handle;
    if (!handle) {
        return FALSE;
    }

    while (handle->State != PROPENUM_RETURN_VALUE &&
           handle->State != PROPENUM_DONE
           ) {

        switch (handle->State) {

        case PROPENUM_GET_NEXT_LINKAGE:

            if (handle->LinkageEnumPosition >= handle->LinkageCount) {
                handle->State = PROPENUM_DONE;
                break;
            }

            EnumPtr->PropertyId = (MIG_PROPERTYID) handle->LinkageList[handle->LinkageEnumPosition];
            handle->LinkageEnumPosition++;

            //
            // If there is a property id filter, make sure we ignore all properties
            // except for the one specified
            //

            if (handle->FilterPropertyId) {
                if (handle->FilterPropertyId != EnumPtr->PropertyId) {
                    //
                    // This property is not interesting -- skip it
                    //

                    handle->State = PROPENUM_GET_NEXT_LINKAGE;
                    break;
                }
            }

            //
            // Now make sure the property is not owned by someone else
            //

            if (!IsmGetPropertyName (
                    EnumPtr->PropertyId,
                    NULL,
                    0,
                    &EnumPtr->Private,
                    NULL,
                    NULL
                    )) {
                //
                // This property is not owned by the caller -- skip it
                //

                handle->State = PROPENUM_GET_NEXT_LINKAGE;
                break;
            }

            //
            // The current property is either common or is owned by the caller;
            // now enumerate the property instances.
            //

            handle->InstancePosition = 0;

#ifdef DEBUG
            //
            // Assert that there is at least one instance of the property
            // in the current unordered blob
            //

            {
                UINT u;

                for (u = 0 ; u < handle->InstanceCount ; u++) {
                    propData = &handle->InstanceArray[u];
                    if (propData->PropertyId == EnumPtr->PropertyId) {
                        break;
                    }
                }

                MYASSERT (u < handle->InstanceCount);
            }
#endif

            handle->State = PROPENUM_GET_NEXT_INSTANCE;
            break;

        case PROPENUM_GET_NEXT_INSTANCE:

            //
            // Sequentially search the unordered blob for the current property,
            // continuing from the last match (if any)
            //

            handle->State = PROPENUM_GET_NEXT_LINKAGE;

            while (handle->InstancePosition < handle->InstanceCount) {

                propData = &handle->InstanceArray[handle->InstancePosition];
                handle->InstancePosition++;

                if (propData->PropertyId == EnumPtr->PropertyId) {
                    EnumPtr->PropertyDataId = pPropertyDataIdFromOffset (propData->DatFileOffset);
                    handle->State = PROPENUM_RETURN_VALUE;
                    break;
                }
            }

            break;

        }
    }

    if (handle->State == PROPENUM_DONE) {
        IsmAbortObjectPropertyEnum (EnumPtr);
        return FALSE;
    }

    MYASSERT (handle->State == PROPENUM_RETURN_VALUE);

    handle->State = PROPENUM_GET_NEXT_INSTANCE;

    return TRUE;
}


VOID
IsmAbortObjectPropertyEnum (
    IN OUT  PMIG_OBJECTPROPERTY_ENUM EnumPtr
    )
{
    POBJECTPROPERTY_HANDLE handle;

    if (EnumPtr->Handle) {

        handle = (POBJECTPROPERTY_HANDLE) EnumPtr->Handle;

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTPROPERTY_ENUM));
}


MIG_PROPERTYDATAID
IsmGetPropertyFromObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_PROPERTYID ObjectProperty
    )
{
    MIG_OBJECTPROPERTY_ENUM propEnum;
    MIG_PROPERTYDATAID result = 0;

    if (IsmEnumFirstObjectProperty (&propEnum, ObjectTypeId, ObjectName, ObjectProperty)) {
        result = propEnum.PropertyDataId;
        IsmAbortObjectPropertyEnum (&propEnum);
    }
    return result;
}


MIG_PROPERTYDATAID
IsmGetPropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID ObjectProperty
    )
{
    MIG_OBJECTPROPERTY_ENUM propEnum;
    MIG_PROPERTYDATAID result = 0;

    if (IsmEnumFirstObjectPropertyById (&propEnum, ObjectId, ObjectProperty)) {
        result = propEnum.PropertyDataId;
        IsmAbortObjectPropertyEnum (&propEnum);
    }
    return result;
}


BOOL
IsmEnumFirstObjectWithProperty (
    OUT     PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr,
    IN      MIG_PROPERTYID PropertyId
    )
{
    POBJECTWITHPROPERTY_HANDLE handle;
    BOOL result = FALSE;

    __try {
        if (!IsItemId ((KEYHANDLE) PropertyId)) {
            DEBUGMSG ((DBG_ERROR, "IsmEnumFirstObjectWithProperty: invalid property id"));
            __leave;
        }

        //
        // Initialize the enum struct and alloc a data struct
        //

        ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHPROPERTY_ENUM));

        EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTWITHPROPERTY_HANDLE));
        handle = (POBJECTWITHPROPERTY_HANDLE) EnumPtr->Handle;

        //
        // Obtain the object<->property linkage list from the property ID
        //

        handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                    PropertyId,
                                    PROPERTY_INDEX,
                                    &handle->LinkageCount
                                    );

        handle->LinkageCount /= SIZEOF(KEYHANDLE);

        if (!handle->LinkageList || !handle->LinkageCount) {
            IsmAbortObjectWithPropertyEnum (EnumPtr);
            __leave;
        }

        handle->LinkagePos = 0;
        handle->PropertyId = PropertyId;

        //
        // Call the enum next routine to continue
        //

        result = IsmEnumNextObjectWithProperty (EnumPtr);

    }
    __finally {
    }

    return result;
}


BOOL
IsmEnumNextObjectWithProperty (
    IN OUT  PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr
    )
{
    POBJECTWITHPROPERTY_HANDLE handle;
    BOOL result = FALSE;
    PTSTR p;

    __try {
        handle = (POBJECTWITHPROPERTY_HANDLE) EnumPtr->Handle;
        if (!handle) {
            __leave;
        }

        if (handle->LinkagePos >= handle->LinkageCount) {
            IsmAbortObjectWithPropertyEnum (EnumPtr);
            __leave;
        }

        EnumPtr->ObjectId = handle->LinkageList[handle->LinkagePos];
        handle->LinkagePos++;

        if (handle->ObjectPath) {
            MemDbReleaseMemory (handle->ObjectPath);
            INVALID_POINTER (handle->ObjectPath);
        }

        handle->ObjectPath = MemDbGetKeyFromHandle ((UINT) EnumPtr->ObjectId, 0);
        if (!handle->ObjectPath) {
            __leave;
        }

        p = _tcschr (handle->ObjectPath, TEXT('\\'));
        if (!p) {
            __leave;
        }

        EnumPtr->ObjectName = _tcsinc (p);
        *p = 0;
        EnumPtr->ObjectTypeId = GetObjectTypeId (handle->ObjectPath);

        result = TRUE;
    }
    __finally {
    }

    return result;
}


VOID
IsmAbortObjectWithPropertyEnum (
    IN OUT  PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr
    )
{
    POBJECTWITHPROPERTY_HANDLE handle;

    if (EnumPtr->Handle) {
        handle = (POBJECTWITHPROPERTY_HANDLE) EnumPtr->Handle;

        if (handle->ObjectPath) {
            MemDbReleaseMemory (handle->ObjectPath);
            INVALID_POINTER (handle->ObjectPath);
        }

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHPROPERTY_ENUM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\sources.inc ===
!include ..\..\engine.mk

MINORCOMP=ism
SYNCHRONIZE_BLOCK=1

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\ism.c            \
    ..\typemgr.c        \
    ..\filetype.c       \
    ..\regtype.c        \
    ..\initype.c        \
    ..\datatype.c       \
    ..\flowctrl.c       \
    ..\attrib.c         \
    ..\property.c       \
    ..\ism.rc           \
    ..\env.c            \
    ..\ops.c            \
    ..\users.c          \
    ..\components.c     \
    ..\modules.c        \
    ..\logmsg.mc        \


DLLENTRY=_DllMainCRTStartup
DLLBASE=0x01E000000
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\lib\$(O)\utils.lib        \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\reg.lib          \

PRECOMPILED_INCLUDE=..\pch.h

DLLDEF=..\ism.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\regtype.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    regtype.c

Abstract:

    Implements all callbacks for registry type

Author:

    Calin Negreanu (calinn) 09-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_REGTYPE        "RegType"

//
// Strings
//

// none

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
} REGACQUIREHANDLE, *PREGACQUIREHANDLE;

//
// Globals
//

MIG_OBJECTTYPEID g_RegistryTypeId = 0;
GROWBUFFER g_RegConversionBuff = INIT_GROWBUFFER;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPhysicalRegistry;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextPhysicalRegistry;
TYPE_ABORTENUMCURRENTPHYSICALNODE AbortEnumCurrentKey;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumPhysicalRegistry;
TYPE_CONVERTOBJECTTOMULTISZ ConvertRegistryToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToRegistry;
TYPE_GETNATIVEOBJECTNAME GetNativeRegistryName;
TYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalRegistry;
TYPE_RELEASEPHYSICALOBJECT ReleasePhysicalRegistry;
TYPE_DOESPHYSICALOBJECTEXIST DoesPhysicalRegistryExist;
TYPE_REMOVEPHYSICALOBJECT RemovePhysicalRegistry;
TYPE_CREATEPHYSICALOBJECT CreatePhysicalRegistry;
TYPE_REPLACEPHYSICALOBJECT ReplacePhysicalRegistry;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertRegContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertRegContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedRegContent;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pRegTypeEnumWorker (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PREGTREE_ENUM handle;

    handle = (PREGTREE_ENUM) EnumPtr->EtmHandle;

    EnumPtr->ObjectName = handle->EncodedFullName;
    EnumPtr->NativeObjectName = handle->NativeFullName;
    EnumPtr->Level = handle->CurrentLevel;
    EnumPtr->SubLevel = handle->CurrentLevel - handle->RegEnumInfo.RootLevel;
    EnumPtr->IsNode = ((handle->Attributes & REG_ATTRIBUTE_KEY) != 0);
    EnumPtr->IsLeaf = !EnumPtr->IsNode;
    if (EnumPtr->IsNode) {
        EnumPtr->ObjectNode = EnumPtr->NativeObjectName;
        EnumPtr->ObjectLeaf = NULL;
    } else {
        EnumPtr->ObjectNode = handle->Location;
        EnumPtr->ObjectLeaf = handle->Name;
    }
    MYASSERT ((EnumPtr->ObjectTypeId & ~PLATFORM_MASK) == g_RegistryTypeId);
    EnumPtr->Details.DetailsData = &handle->CurrentValueType;

    return TRUE;
}

BOOL
EnumFirstPhysicalRegistry (
    PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    MIG_OBJECTSTRINGHANDLE Pattern,
    UINT MaxLevel
    )
{
    PREGTREE_ENUM handle;
    BOOL result;

    if (!Pattern) {
        return FALSE;
    }

    handle = (PREGTREE_ENUM) IsmGetMemory (sizeof (REGTREE_ENUM));
    EnumPtr->EtmHandle = (LONG_PTR) handle;

    EnumPtr->Details.DetailsSize = sizeof (DWORD);

    result = EnumFirstRegObjectInTreeEx (
                handle,
                Pattern,
                TRUE,
                TRUE,
                TRUE,
                TRUE,
                MaxLevel == NODE_LEVEL_MAX ? REGENUM_ALL_SUBLEVELS : MaxLevel,
                FALSE,
                FALSE,
                RegEnumDefaultCallback
                );

    if (result) {
        result = pRegTypeEnumWorker (EnumPtr);
    } else {
        AbortEnumPhysicalRegistry (EnumPtr);
    }

    return result;
}

BOOL
EnumNextPhysicalRegistry (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PREGTREE_ENUM handle;
    BOOL result;

    handle = (PREGTREE_ENUM) EnumPtr->EtmHandle;

    result = EnumNextRegObjectInTree (handle);

    if (result) {
        result = pRegTypeEnumWorker (EnumPtr);
    } else {
        AbortEnumPhysicalRegistry (EnumPtr);
    }

    return result;
}

VOID
AbortEnumCurrentKey (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PREGTREE_ENUM handle;

    handle = (PREGTREE_ENUM) EnumPtr->EtmHandle;

    if (handle) {
        handle->ControlFlags |= RECF_SKIPSUBKEYS|RECF_SKIPVALUES;
    }
}

VOID
AbortEnumPhysicalRegistry (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PREGTREE_ENUM handle;

    handle = (PREGTREE_ENUM) EnumPtr->EtmHandle;

    if (handle) {
        AbortRegObjectInTreeEnum (handle);
        IsmReleaseMemory (handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

PVOID
pIsmAlloc (
    IN      DWORD Size
    )
{
    return IsmGetMemory (Size);
}

VOID
pIsmDealloc (
    IN      PCVOID Mem
    )
{
    IsmReleaseMemory (Mem);
}

BOOL
AcquirePhysicalRegistry (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PREGACQUIREHANDLE handle;
    REGSAM prevMode;
    PDWORD dataType;
    DWORD contentSize;
    HANDLE fileHandle;
    PCBYTE content;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    HKEY keyHandle = NULL;
    BOOL result = FALSE;

    handle = IsmGetMemory (sizeof (REGACQUIREHANDLE));
    ZeroMemory (handle, sizeof (REGACQUIREHANDLE));
    ObjectContent->EtmHandle = handle;

    dataType = IsmGetMemory (sizeof (DWORD));
    ZeroMemory (dataType, sizeof (DWORD));
    ObjectContent->Details.DetailsSize = sizeof (DWORD);
    ObjectContent->Details.DetailsData = dataType;

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (leaf) {

        prevMode = SetRegOpenAccessMode (KEY_READ);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {

            if (GetRegValueTypeAndSize (
                    keyHandle,
                    leaf,
                    dataType,
                    &contentSize
                    )) {

                switch (ContentType) {
                    case CONTENTTYPE_DETAILS_ONLY:
                        MYASSERT (ObjectContent->ContentInFile == FALSE);
                        result = TRUE;
                        break;

                    case CONTENTTYPE_MEMORY:
                    case CONTENTTYPE_ANY:
                        if (contentSize) {
                            if (!MemoryContentLimit || MemoryContentLimit >= contentSize) {
                                MYASSERT (ObjectContent->ContentInFile == FALSE);
                                ObjectContent->MemoryContent.ContentBytes = (PCBYTE) GetRegValueDataOfType2 (
                                                                                keyHandle,
                                                                                leaf,
                                                                                *dataType,
                                                                                pIsmAlloc,
                                                                                pIsmDealloc
                                                                                );
                                if (ObjectContent->MemoryContent.ContentBytes) {
                                    ObjectContent->MemoryContent.ContentSize = contentSize;
                                    result = TRUE;
                                }
                            }
                        } else {
                            result = TRUE;
                        }
                        break;
                    case CONTENTTYPE_FILE:
                        if (contentSize) {
                            BfGetTempFileName (handle->TempFile, ARRAYSIZE(handle->TempFile));
                            fileHandle = BfCreateFile (handle->TempFile);

                            if (fileHandle) {
                                content = (PCBYTE) GetRegValueDataOfType2 (
                                                        keyHandle,
                                                        leaf,
                                                        *dataType,
                                                        pIsmAlloc,
                                                        pIsmDealloc
                                                        );
                                if (content) {
                                    if (BfWriteFile (fileHandle, content, contentSize)) {
                                        ObjectContent->ContentInFile = TRUE;
                                        ObjectContent->FileContent.ContentPath = PmDuplicateString (g_IsmPool, handle->TempFile);
                                        ObjectContent->FileContent.ContentSize = contentSize;
                                        result = TRUE;
                                    }
                                    IsmReleaseMemory (content);
                                }
                                CloseHandle (fileHandle);
                            }
                        } else {
                            result = TRUE;
                        }
                        break;
                    default:
                        DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in IsmAcquireObject: %d", ContentType));
                }
            }

            CloseRegKey (keyHandle);
        }
    } else {

        prevMode = SetRegOpenAccessMode (KEY_READ);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {
            switch (ContentType) {
                case CONTENTTYPE_MEMORY:
                case CONTENTTYPE_ANY:
                case CONTENTTYPE_DETAILS_ONLY:
                    ObjectContent->ContentInFile = FALSE;
                    result = TRUE;
                    break;
                case CONTENTTYPE_FILE:
                    ObjectContent->ContentInFile = TRUE;
                    result = TRUE;
                    break;
                default:
                    DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in IsmAcquireObject: %d", ContentType));
            }
            CloseRegKey (keyHandle);
        }
    }

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    if (!result) {
        IsmReleaseMemory (dataType);
        dataType = NULL;
        IsmReleaseMemory (handle);
        handle = NULL;
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return result;
}

PCTSTR
ConvertRegistryToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    DWORD size;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    TCHAR buff[3];
    PCTSTR quotedString;
    MULTISZ_ENUM multiSzEnum;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        g_RegConversionBuff.End = 0;

        GbCopyQuotedString (&g_RegConversionBuff, node);
        if (leaf) {
            GbCopyQuotedString (&g_RegConversionBuff, leaf);
        }

        if (leaf) {
            // this is actually a value name
            MYASSERT (ObjectContent->Details.DetailsSize == sizeof (DWORD));

            if ((ObjectContent->Details.DetailsSize == sizeof (DWORD)) &&
                (ObjectContent->Details.DetailsData)
                ) {

                // let's save the details
                wsprintf (
                    (PTSTR) GbGrow (&g_RegConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                    TEXT("0x%08X"),
                    *((PDWORD)ObjectContent->Details.DetailsData)
                    );

                if ((!ObjectContent->ContentInFile) &&
                    (ObjectContent->MemoryContent.ContentSize) &&
                    (ObjectContent->MemoryContent.ContentBytes)
                    ) {

                    // let's save the content
                    switch (*((PDWORD)ObjectContent->Details.DetailsData)) {
                    case REG_SZ:
                    case REG_EXPAND_SZ:
                        quotedString = StringSearchAndReplace (
                                            (PCTSTR)ObjectContent->MemoryContent.ContentBytes,
                                            TEXT("\""),
                                            TEXT("\"\""));
                        if (quotedString) {
                            GbCopyQuotedString (&g_RegConversionBuff, quotedString);
                            FreePathString (quotedString);
                        } else {
                            GbCopyQuotedString (&g_RegConversionBuff, (PCTSTR)ObjectContent->MemoryContent.ContentBytes);
                        }
                        break;
                    case REG_MULTI_SZ:
                        if (EnumFirstMultiSz (&multiSzEnum, (PCTSTR)ObjectContent->MemoryContent.ContentBytes)) {
                            do {
                                quotedString = StringSearchAndReplace (
                                                    multiSzEnum.CurrentString,
                                                    TEXT("\""),
                                                    TEXT("\"\""));
                                if (quotedString) {
                                    GbCopyQuotedString (&g_RegConversionBuff, quotedString);
                                    FreePathString (quotedString);
                                } else {
                                    GbCopyQuotedString (&g_RegConversionBuff, multiSzEnum.CurrentString);
                                }
                            } while (EnumNextMultiSz (&multiSzEnum));
                        }
                        break;
                    case REG_DWORD:
                    case REG_DWORD_BIG_ENDIAN:
                        wsprintf (
                            (PTSTR) GbGrow (&g_RegConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                            TEXT("0x%08X"),
                            *((PDWORD)ObjectContent->MemoryContent.ContentBytes)
                            );
                        break;
                    default:
                        // write it in binary format
                        size = 0;
                        while (size < ObjectContent->MemoryContent.ContentSize) {
                            wsprintf (
                                buff,
                                TEXT("%02X"),
                                ObjectContent->MemoryContent.ContentBytes [size]
                                );
                            GbCopyString (&g_RegConversionBuff, buff);
                            size ++;
                        }
                        break;
                    }
                }
            } else {
                bresult = FALSE;
            }
        }

        if (bresult) {
            GbCopyString (&g_RegConversionBuff, TEXT(""));
            result = IsmGetMemory (g_RegConversionBuff.End);
            CopyMemory (result, g_RegConversionBuff.Buf, g_RegConversionBuff.End);
        }

        g_RegConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToRegistry (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
#define indexNode   0
#define indexLeaf   1
#define indexType   2
#define indexData   3
    MULTISZ_ENUM multiSzEnum;
    PCTSTR node = NULL, leaf = NULL;
    DWORD type = REG_NONE;
    DWORD dummy;
    UINT index;

    g_RegConversionBuff.End = 0;

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == indexNode) {
                node = multiSzEnum.CurrentString;
            }
            if (index == indexLeaf) {
                leaf = multiSzEnum.CurrentString;
                if (StringIMatch (leaf, TEXT("<empty>"))) {
                    leaf = TEXT("");
                }
            }
            if (index == indexType) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &type);
            }
            if (index >= indexData) {
                switch (type) {
                case REG_SZ:
                case REG_EXPAND_SZ:
                    if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        GbCopyString (&g_RegConversionBuff, multiSzEnum.CurrentString);
                    } else {
                        GbCopyString (&g_RegConversionBuff, TEXT(""));
                    }
                    break;
                case REG_MULTI_SZ:
                    if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
                        GbCopyString (&g_RegConversionBuff, multiSzEnum.CurrentString);
                    } else {
                        GbCopyString (&g_RegConversionBuff, TEXT(""));
                    }
                    break;
                case REG_DWORD:
                case REG_DWORD_BIG_ENDIAN:
                    _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                    *((PDWORD)GbGrow (&g_RegConversionBuff, sizeof (DWORD))) = dummy;
                    break;
                default:
                    _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                    *((PBYTE)GbGrow (&g_RegConversionBuff, sizeof (BYTE))) = (BYTE)dummy;
                    break;
                }
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (type == REG_MULTI_SZ) {
        GbCopyString (&g_RegConversionBuff, TEXT(""));
    }

    if (!node) {
        return FALSE;
    }

    if (ObjectContent) {

        ObjectContent->ObjectTypeId = MIG_REGISTRY_TYPE;

        ObjectContent->ContentInFile = FALSE;
        ObjectContent->MemoryContent.ContentSize = g_RegConversionBuff.End;
        if (ObjectContent->MemoryContent.ContentSize) {
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            CopyMemory (
                (PBYTE)ObjectContent->MemoryContent.ContentBytes,
                g_RegConversionBuff.Buf,
                ObjectContent->MemoryContent.ContentSize
                );
            g_RegConversionBuff.End = 0;
        }
        if (leaf) {
            ObjectContent->Details.DetailsSize = sizeof (DWORD);
            ObjectContent->Details.DetailsData = IsmGetMemory (ObjectContent->Details.DetailsSize);
            CopyMemory ((PBYTE)ObjectContent->Details.DetailsData, &type, ObjectContent->Details.DetailsSize);
        }
    }
    *ObjectName = IsmCreateObjectHandle (node, leaf);

    return TRUE;
}

PCTSTR
GetNativeRegistryName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node, leaf, tmp;
    UINT size;
    PTSTR endPtr, result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (leaf) {
            tmp = JoinTextEx (NULL, node, leaf, TEXT("\\["), 1, &endPtr);
            if (tmp) {
                StringCopy (endPtr, TEXT("]"));
                size = SizeOfString (tmp);
                if (size) {
                    result = IsmGetMemory (size);
                    if (result) {
                        CopyMemory (result, tmp, size);
                    }
                }
                FreeText (tmp);
            }
        } else {
            size = SizeOfString (node);
            result = IsmGetMemory (size);
            CopyMemory (result, node, size);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
ReleasePhysicalRegistry (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PREGACQUIREHANDLE handle;
    BOOL result = TRUE;

    handle = (PREGACQUIREHANDLE) ObjectContent->EtmHandle;

    if (handle) {
        if (ObjectContent->ContentInFile) {
            if (ObjectContent->FileContent.ContentPath) {
                IsmReleaseMemory (ObjectContent->FileContent.ContentPath);
                DeleteFile (handle->TempFile);
            }
        } else {
            if (ObjectContent->MemoryContent.ContentBytes) {
                IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
            }
        }
        IsmReleaseMemory (handle);
    }
    if (ObjectContent->Details.DetailsData) {
        IsmReleaseMemory (ObjectContent->Details.DetailsData);
    }
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    return result;
}

BOOL
DoesPhysicalRegistryExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    REGSAM prevMode;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    HKEY keyHandle = NULL;
    DWORD type;
    BOOL result = FALSE;

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (node) {

        prevMode = SetRegOpenAccessMode (KEY_READ);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {
            result = TRUE;
        }
    }

    if (result && leaf) {
        result = GetRegValueTypeAndSize (keyHandle, leaf, &type, NULL);
    }

    if (keyHandle) {
        CloseRegKey (keyHandle);
        keyHandle = NULL;
    }

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    return result;
}

BOOL
RemovePhysicalRegistry (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    REGSAM prevMode;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    HKEY keyHandle;
    DWORD rc;
    BOOL result = FALSE;

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (leaf) {

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {

            // record value name deletion
            IsmRecordOperation (
                JRNOP_DELETE,
                g_RegistryTypeId,
                ObjectName
                );

            rc = RegDeleteValue (keyHandle, leaf);
            if (rc == ERROR_SUCCESS) {
                result = TRUE;
            } else {
                SetLastError (rc);
            }
            CloseRegKey (keyHandle);
        }
    } else {
        // we do attempt to remove empty keys.
        // there is no problem in recording an operation that
        // will potentially fail (if the key is not empty).
        IsmRecordOperation (
            JRNOP_DELETE,
            g_RegistryTypeId,
            ObjectName
            );

        prevMode = SetRegOpenAccessMode (KEY_WRITE | KEY_QUERY_VALUE);

        if (node) {
            result = DeleteEmptyRegKeyStr (node);
        }

        SetRegOpenAccessMode (prevMode);
    }

    PushError ();

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

HKEY
pTrackedCreateRegKeyStr (
    IN      PCTSTR KeyName
    )
{
    REGSAM prevMode;
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR keyCopy;
    PTSTR p;
    HKEY keyHandle;
    BOOL result = TRUE;

    keyCopy = DuplicatePathString (KeyName, 0);

    //
    // Advance past key root
    //
    p = _tcschr (keyCopy, TEXT('\\'));
    if (p) {
        p = _tcschr (p + 1, TEXT('\\'));
    }

    //
    // Make all keys along the path
    //

    while (p) {

        *p = 0;

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (keyCopy);

        SetRegOpenAccessMode (prevMode);

        if (!keyHandle) {

            // record key creation
            objectName = IsmCreateObjectHandle (keyCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_RegistryTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            keyHandle = CreateRegKeyStr (keyCopy);
            if (keyHandle) {
                CloseRegKey (keyHandle);
            } else {
                result = FALSE;
            }
            if (!result) {
                break;
            }
        } else {
            CloseRegKey (keyHandle);
        }

        *p = TEXT('\\');
        p = _tcschr (p + 1, TEXT('\\'));
    }

    //
    // At last, make the FullPath directory
    //

    if (result) {

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (keyCopy);

        SetRegOpenAccessMode (prevMode);

        if (!keyHandle) {

            // record key creation
            objectName = IsmCreateObjectHandle (keyCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_RegistryTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            keyHandle = CreateRegKeyStr (keyCopy);
            if (!keyHandle) {
                result = FALSE;
            }
        } else {
            result = FALSE;
            SetLastError (ERROR_ALREADY_EXISTS);
        }
    }

    FreePathString (keyCopy);

    if (result) {
        return keyHandle;
    }

    if (GetLastError() == ERROR_CHILD_MUST_BE_VOLATILE) {
        // NOTE: There is no way to check for volatile keys before attempting
        //       to create them.  Ideally we do not want to migrate volatile
        //       keys, so we will just ignore this error.  It will not be
        //       created, and we'll continue happily.
        SetLastError (ERROR_SUCCESS);
    }

    return NULL;
}

BOOL
CreatePhysicalRegistry (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    REGSAM prevMode;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    DWORD type;
    PDWORD dataType;
    HKEY keyHandle;
    DWORD rc;
    PCBYTE data = NULL;
    UINT size;
    HANDLE fileHandle = NULL;
    HANDLE mapHandle = NULL;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    dataType = (PDWORD) (ObjectContent->Details.DetailsData);

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (leaf) {

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (!keyHandle) {
            keyHandle = pTrackedCreateRegKeyStr (node);
        }

        if (keyHandle) {

            if (ObjectContent->ContentInFile) {
                data = MapFileIntoMemory (
                            ObjectContent->FileContent.ContentPath,
                            fileHandle,
                            mapHandle
                            );
                size = (UINT) ObjectContent->FileContent.ContentSize;
            } else {
                data = ObjectContent->MemoryContent.ContentBytes;
                size = ObjectContent->MemoryContent.ContentSize;
            }

            if (!GetRegValueTypeAndSize (keyHandle, leaf, &type, NULL)) {

                // record value name creation
                IsmRecordOperation (
                    JRNOP_CREATE,
                    g_RegistryTypeId,
                    ObjectName
                    );

                rc = RegSetValueEx (
                            keyHandle,
                            leaf,
                            0,
                            *dataType,
                            data,
                            size
                            );
                result = (rc == ERROR_SUCCESS);
            } else {
                rc = ERROR_ALREADY_EXISTS;
            }

            if (fileHandle && mapHandle) {
                UnmapFile (
                    data,
                    mapHandle,
                    fileHandle
                    );
            }

            CloseRegKey (keyHandle);

            if (!result) {
                SetLastError (rc);
            }
        }

    } else {

        prevMode = SetRegOpenAccessMode (KEY_WRITE);

        keyHandle = OpenRegKeyStr (node);

        SetRegOpenAccessMode (prevMode);

        if (keyHandle) {

            CloseRegKey (keyHandle);
            SetLastError (ERROR_ALREADY_EXISTS);

        } else {

            keyHandle = pTrackedCreateRegKeyStr (node);

            if (keyHandle) {
                result = TRUE;
                CloseRegKey (keyHandle);
            }
        }
    }

    PushError ();

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

BOOL
ReplacePhysicalRegistry (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PDWORD dataType;
    PCBYTE data = NULL;
    HANDLE fileHandle = NULL;
    HANDLE mapHandle = NULL;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    dataType = (PDWORD) (ObjectContent->Details.DetailsData);

    ObsSplitObjectString (ObjectName, &node, &leaf);

    if (leaf) {
        result = TRUE;
        if (DoesPhysicalRegistryExist (ObjectName)) {
            result = RemovePhysicalRegistry (ObjectName);
        }
        if (result) {
            result = CreatePhysicalRegistry (ObjectName, ObjectContent);
        }
    } else {
        if (DoesPhysicalRegistryExist (ObjectName)) {
            result = TRUE;
        } else {
            result = CreatePhysicalRegistry (ObjectName, ObjectContent);
        }
    }

    PushError ();

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

PMIG_CONTENT
ConvertRegContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;
    DWORD regType = 0;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    if ((ObjectContent->MemoryContent.ContentSize == 0) ||
        (ObjectContent->MemoryContent.ContentBytes == NULL)
        ) {
        return result;
    }

    if ((ObjectContent->Details.DetailsSize == 0) ||
        (ObjectContent->Details.DetailsSize != sizeof (DWORD)) ||
        (ObjectContent->Details.DetailsData == NULL)
        ) {
        return result;
    }

    regType = *((PDWORD) ObjectContent->Details.DetailsData);

    if ((regType == REG_SZ) ||
        (regType == REG_MULTI_SZ) ||
        (regType == REG_EXPAND_SZ)
        ) {
        result = IsmGetMemory (sizeof (MIG_CONTENT));
        if (result) {
            CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize * 2);
            if (!result->MemoryContent.ContentBytes) {
                IsmReleaseMemory (result);
                result = NULL;
                return result;
            }
            ZeroMemory ((PBYTE)result->MemoryContent.ContentBytes, ObjectContent->MemoryContent.ContentSize * 2);
            DirectDbcsToUnicodeN (
                (PWSTR)result->MemoryContent.ContentBytes,
                (PSTR)ObjectContent->MemoryContent.ContentBytes,
                ObjectContent->MemoryContent.ContentSize
                );
            if ((regType == REG_SZ) ||
                (regType == REG_EXPAND_SZ)
                ) {
                result->MemoryContent.ContentSize = SizeOfStringW ((PWSTR)result->MemoryContent.ContentBytes);
            } else {
                result->MemoryContent.ContentSize = SizeOfMultiSzW ((PWSTR)result->MemoryContent.ContentBytes);
            }
        }
    }

    return result;
}

PMIG_CONTENT
ConvertRegContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PMIG_CONTENT result = NULL;
    DWORD regType = 0;

    if (!ObjectContent) {
        return result;
    }

    if (ObjectContent->ContentInFile) {
        return result;
    }

    if ((ObjectContent->MemoryContent.ContentSize == 0) ||
        (ObjectContent->MemoryContent.ContentBytes == NULL)
        ) {
        return result;
    }

    if ((ObjectContent->Details.DetailsSize == 0) ||
        (ObjectContent->Details.DetailsSize != sizeof (DWORD)) ||
        (ObjectContent->Details.DetailsData == NULL)
        ) {
        return result;
    }

    regType = *((PDWORD) ObjectContent->Details.DetailsData);

    if ((regType == REG_SZ) ||
        (regType == REG_MULTI_SZ) ||
        (regType == REG_EXPAND_SZ)
        ) {
        result = IsmGetMemory (sizeof (MIG_CONTENT));
        if (result) {
            CopyMemory (result, ObjectContent, sizeof (MIG_CONTENT));
            result->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            if (!result->MemoryContent.ContentBytes) {
                IsmReleaseMemory (result);
                result = NULL;
                return result;
            }
            ZeroMemory ((PBYTE)result->MemoryContent.ContentBytes, ObjectContent->MemoryContent.ContentSize);
            DirectUnicodeToDbcsN (
                (PSTR)result->MemoryContent.ContentBytes,
                (PWSTR)ObjectContent->MemoryContent.ContentBytes,
                ObjectContent->MemoryContent.ContentSize
                );
            if ((regType == REG_SZ) ||
                (regType == REG_EXPAND_SZ)
                ) {
                result->MemoryContent.ContentSize = SizeOfStringA ((PSTR)result->MemoryContent.ContentBytes);
            } else {
                result->MemoryContent.ContentSize = SizeOfMultiSzA ((PSTR)result->MemoryContent.ContentBytes);
            }
        }
    }

    return result;
}

BOOL
FreeConvertedRegContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (!ObjectContent) {
        return TRUE;
    }

    if (ObjectContent->MemoryContent.ContentBytes) {
        IsmReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
    }

    IsmReleaseMemory (ObjectContent);

    return TRUE;
}

VOID
InitRegistryType (
    VOID
    )
{
    TYPE_REGISTER regTypeData;

    ZeroMemory (&regTypeData, sizeof (TYPE_REGISTER));
    regTypeData.Priority = PRIORITY_REGISTRY;
    regTypeData.EnumFirstPhysicalObject = EnumFirstPhysicalRegistry;
    regTypeData.EnumNextPhysicalObject = EnumNextPhysicalRegistry;
    regTypeData.AbortEnumCurrentPhysicalNode = AbortEnumCurrentKey;
    regTypeData.AbortEnumPhysicalObject = AbortEnumPhysicalRegistry;
    regTypeData.ConvertObjectToMultiSz = ConvertRegistryToMultiSz;
    regTypeData.ConvertMultiSzToObject = ConvertMultiSzToRegistry;
    regTypeData.GetNativeObjectName = GetNativeRegistryName;
    regTypeData.AcquirePhysicalObject = AcquirePhysicalRegistry;
    regTypeData.ReleasePhysicalObject = ReleasePhysicalRegistry;
    regTypeData.DoesPhysicalObjectExist = DoesPhysicalRegistryExist;
    regTypeData.RemovePhysicalObject = RemovePhysicalRegistry;
    regTypeData.CreatePhysicalObject = CreatePhysicalRegistry;
    regTypeData.ReplacePhysicalObject = ReplacePhysicalRegistry;
    regTypeData.ConvertObjectContentToUnicode = ConvertRegContentToUnicode;
    regTypeData.ConvertObjectContentToAnsi = ConvertRegContentToAnsi;
    regTypeData.FreeConvertedObjectContent = FreeConvertedRegContent;

    g_RegistryTypeId = IsmRegisterObjectType (
                            S_REGISTRYTYPE,
                            TRUE,
                            FALSE,
                            &regTypeData
                            );
    MYASSERT (g_RegistryTypeId);
}

VOID
DoneRegistryType (
    VOID
    )
{
    GbFree (&g_RegConversionBuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\inc\allutils.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    allutils.h

Abstract:

    Includes all header files necessary to use the libraries generated under the
    utils directory. Declares many macros and MAX constants.

Author:

    Jim Schmidt (jimschm) 23-Aug-1996

Revision History:

    marcw 2-Sep-1999 Ported over from win95upg project (migutil.h) Needs lots of cleanup.

--*/

#pragma once

//
// Includes
//

#include "utiltypes.h"
#include "main.h"
#include "dbgtrack.h"
#include "basemem.h"
#include "log.h"
#include "growbuf.h"
#include "strings.h"
#include "poolmem.h"
#include "growlist.h"
#include "version.h"
#include "modimage.h"
#include "icons.h"
#include "unicode.h"
#include "hash.h"
#include "basefile.h"
#include "memdb.h"
#include "inf.h"
#include "ini.h"
#include "blobs.h"
#include "objstr.h"
#include "exclist.h"
#include "reg.h"
#include "regenum.h"
#include "fileenum.h"
#include "cablib.h"
#include "wnd.h"
#include "strmap.h"
#include "linkpif.h"
#include "progbar.h"

//
// Strings
//

// None

//
// Constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_SERVER_NAMEA + (20 * 2))
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_SERVER_NAMEW + 20)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

#define MAX_CMDLINEW                1024            // maximum number of chars in a Win95 command line

#ifdef UNICODE

#define MAX_SERVER_NAME             MAX_SERVER_NAMEW
#define MAX_USER_NAME               MAX_USER_NAMEW
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYW
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEW
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEW
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEW
#define MAX_CMDLINE                 MAX_CMDLINEW

#define MAX_TCHAR_PATH              MAX_WCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_WCHAR_PRINTABLE_PATH

#else

#define MAX_SERVER_NAME             MAX_SERVER_NAMEA
#define MAX_USER_NAME               MAX_USER_NAMEA
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYA
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEA
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEA
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEA
#define MAX_CMDLINE                 MAX_CMDLINEA

#define MAX_TCHAR_PATH              MAX_MBCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_MBCHAR_PRINTABLE_PATH

#endif


//
// Macros
//


//
// OSVERSION macros...
//
#define ISNT()              (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
#define ISWIN9X()           (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
#define ISWIN95_GOLDEN()    (ISWIN95() && WORD(g_OsInfo.dwBuildNumber) <= 1000)
#define ISWIN95_OSR2()      (ISWIN95() && WORD(g_OsInfo.dwBuildNumber) > 1000)
#define ISWIN95()           (ISWIN9X() && !ISMEMPHIS())
#define ISMEMPHIS()         (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==10)
#define BUILDNUMBER()       (g_OsInfo.dwBuildNumber)

//
// Error condition tags.
//
// These tags should be used for all error conditions.
//

#define ERROR_CRITICAL
#define ERROR_NONCRITICAL
#define ERROR_TRIVIAL
#define ERROR_ABNORMAL_CONDITION



//
// Types
//

typedef struct {
    HANDLE EventHandle;
} OUR_CRITICAL_SECTION, *POUR_CRITICAL_SECTION;

//
// Globals
//

extern HINSTANCE g_hInst;
extern HANDLE g_hHeap;
extern OSVERSIONINFOA g_OsInfo;


extern BOOL g_IsPc98;

//
// Boot drive letter
//

extern PCSTR g_BootDrivePathA;
extern PCWSTR g_BootDrivePathW;
extern PCSTR g_BootDriveA;
extern PCWSTR g_BootDriveW;
extern CHAR g_BootDriveLetterA;
extern WCHAR g_BootDriveLetterW;


//
// Macro expansion list
//

// None

//
// Public function prototypes
//

//
// Critical Section APIs, implemented because TryEnterCriticalSection is
// supported only on NT, and we need it on Win9x.
//


BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

//
// Includes of util modules
//


VOID
CenterWindow (
    HWND Wnd,
    HWND Parent     OPTIONAL
    );

VOID
TurnOnWaitCursor (
    VOID
    );

VOID
TurnOffWaitCursor (
    VOID
    );

VOID
OutOfMemory_Terminate (
    VOID
    );


VOID
SetOutOfMemoryParent (
    HWND hwnd
    );


HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    );

//
// Macro expansion definition
//

// None

//
// Unicode/Ansi mappings.
//
#ifdef UNICODE

#define g_BootDrivePath     g_BootDrivePathW
#define g_BootDrive         g_BootDriveW
#define g_BootDriveLetter   g_BootDriveLetterW

#else

#define g_BootDrivePath     g_BootDrivePathA
#define g_BootDrive         g_BootDriveA
#define g_BootDriveLetter   g_BootDriveLetterA

#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(n)    (sizeof(n)/sizeof(n[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\typemgr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    typemgr.c

Abstract:

    Provides type abstraction layer to the flow control module. Enumerations of Objects are eventually resolved
    to specific types through the interfaces in this module.

Author:

    Jim Schmidt 11-November-1999

Revision History:

    marcw 16-Nov-1999 Implemented necessary changes needed by flowctrl.c

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_TYPEMGR     "TypeMgr"

//
// Strings
//

#define S_OBJECTTYPES       TEXT("ObjectTypes")
#define S_OBJECTIDS         TEXT("ObjectIds")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR ObjectTypeName [MAX_PATH];
    TCHAR SObjectTypeName [MAX_PATH];
    TCHAR DObjectTypeName [MAX_PATH];
    UINT Priority;
    BOOL CanBeRestored;
    BOOL ReadOnly;
    MIG_OBJECTCOUNT TotalObjects;
    MIG_OBJECTCOUNT SourceObjects;
    MIG_OBJECTCOUNT DestinationObjects;
    PTYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPhysicalObject;
    PTYPE_ENUMNEXTPHYSICALOBJECT EnumNextPhysicalObject;
    PTYPE_ABORTENUMCURRENTPHYSICALNODE AbortEnumCurrentPhysicalNode;
    PTYPE_ABORTENUMPHYSICALOBJECT AbortEnumPhysicalObject;
    PTYPE_CONVERTOBJECTTOMULTISZ ConvertObjectToMultiSz;
    PTYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToObject;
    PTYPE_GETNATIVEOBJECTNAME GetNativeObjectName;
    PTYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalObject;
    PTYPE_RELEASEPHYSICALOBJECT ReleasePhysicalObject;
    PTYPE_DOESPHYSICALOBJECTEXIST DoesPhysicalObjectExist;
    PTYPE_REMOVEPHYSICALOBJECT RemovePhysicalObject;
    PTYPE_CREATEPHYSICALOBJECT CreatePhysicalObject;
    PTYPE_REPLACEPHYSICALOBJECT ReplacePhysicalObject;
    PTYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertObjectContentToUnicode;
    PTYPE_CONVERTOBJECTCONTENTTOANSI ConvertObjectContentToAnsi;
    PTYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedObjectContent;
    HASHTABLE ExclusionTable;
} TYPEINFO, *PTYPEINFO;

typedef struct {
    MIG_TYPEOBJECTENUM Enum;
    BOOL Completed;
} TOPLEVELENUM_HANDLE, *PTOPLEVELENUM_HANDLE;

typedef struct {
    MIG_OBJECTSTRINGHANDLE Pattern;
    MIG_PARSEDPATTERN ParsedPattern;
    BOOL AddedEnums;
    UINT CurrentEnumId;
} ADDEDOBJECTSENUM, *PADDEDOBJECTSENUM;

//
// Globals
//

GROWBUFFER g_TypeList = INIT_GROWBUFFER;
HASHTABLE g_TypeTable;
MIG_OBJECTTYPEID g_MaxType = 0;

//
// Macro expansion list
//

// none

//
// Private function prototypes
//

BOOL
pEnumNextPhysicalObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
InitializeTypeMgr (
    VOID
    )
{
    g_TypeTable = HtAllocWithData (sizeof (UINT));

    InitDataType ();
    InitRegistryType ();
    InitIniType ();
    InitFileType ();

    return TRUE;
}

PTYPEINFO
GetTypeInfo (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO *typeInfo;
    MIG_OBJECTTYPEID objectTypeId;

    objectTypeId = ObjectTypeId & (~PLATFORM_MASK);
    typeInfo = (PTYPEINFO *) (g_TypeList.Buf);
    if (!objectTypeId) {
        return NULL;
    }
    if ((g_TypeList.End / sizeof (PTYPEINFO)) < objectTypeId) {
        return NULL;
    }
    return *(typeInfo + (objectTypeId - 1));
}

HASHTABLE
GetTypeExclusionTable (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (!typeInfo) {
        return NULL;
    }

    return typeInfo->ExclusionTable;
}

BOOL
pInsertTypeIdAt (
    IN      PGROWBUFFER List,
    IN      PTYPEINFO Data,
    IN      UINT Index
    )
{
    UINT existingElems;

    existingElems = (List->End / sizeof (PTYPEINFO));
    if (existingElems < Index) {
        GbGrow (List, (Index - existingElems) * sizeof (PTYPEINFO));
    }
    CopyMemory (List->Buf + ((Index - 1) * sizeof (PTYPEINFO)), &Data, sizeof (PTYPEINFO));
    return TRUE;
}

VOID
TerminateTypeMgr (
    VOID
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    PTYPEINFO objectTypeInfo;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;

    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
        do {
            objectTypeId = objTypeIdEnum.ObjectTypeId;
            objectTypeInfo = GetTypeInfo (objectTypeId);
            if (objectTypeInfo) {
                if (objectTypeInfo->ExclusionTable) {
                    HtFree (objectTypeInfo->ExclusionTable);
                }
            }
        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }

    DoneFileType ();
    DoneIniType ();
    DoneRegistryType ();
    DoneDataType ();
    GbFree (&g_TypeList);

    if (g_TypeTable) {
        HtFree (g_TypeTable);
        g_TypeTable = NULL;
    }
}

MIG_OBJECTTYPEID
GetObjectTypeId (
    IN      PCTSTR Type
    )
{
    HASHITEM rc;
    MIG_OBJECTTYPEID id;

    if (!g_TypeTable) {
        DEBUGMSG ((DBG_ERROR, "No ETMs registered; can't get object type id"));
        return 0;
    }

    //
    // Given a type string (i.e., File, Registry, etc.), return an id
    //

    rc = HtFindStringEx (g_TypeTable, Type, &id, FALSE);

    if (!rc) {
        return 0;
    }

    return id;
}

PCTSTR
pGetDecoratedObjectTypeName (
    IN      PCTSTR ObjectTypeName
    )
{
    return JoinPaths (S_OBJECTTYPES, ObjectTypeName);
}

BOOL
CanObjectTypeBeRestored (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        return (typeInfo->CanBeRestored);
    }
    return FALSE;
}

BOOL
CanObjectTypeBeModified (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        return (!typeInfo->ReadOnly);
    }
    return FALSE;
}

BOOL
IncrementTotalObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.TotalObjects ++;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.TotalObjects ++;
        } else {
            typeInfo->DestinationObjects.TotalObjects ++;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

BOOL
IncrementPersistentObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.PersistentObjects ++;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.PersistentObjects ++;
        } else {
            typeInfo->DestinationObjects.PersistentObjects ++;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

BOOL
DecrementPersistentObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.PersistentObjects --;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.PersistentObjects --;
        } else {
            typeInfo->DestinationObjects.PersistentObjects --;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

BOOL
IncrementApplyObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.ApplyObjects ++;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.ApplyObjects ++;
        } else {
            typeInfo->DestinationObjects.ApplyObjects ++;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

BOOL
DecrementApplyObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        typeInfo->TotalObjects.ApplyObjects --;
        if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
            typeInfo->SourceObjects.ApplyObjects --;
        } else {
            typeInfo->DestinationObjects.ApplyObjects --;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return FALSE;
}

PMIG_OBJECTCOUNT
GetTypeObjectsStatistics (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        if (ObjectTypeId & PLATFORM_SOURCE) {
            return &typeInfo->SourceObjects;
        } else if (ObjectTypeId & PLATFORM_DESTINATION) {
            return &typeInfo->DestinationObjects;
        } else {
            return &typeInfo->TotalObjects;
        }
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Unknown object type ID: %d", ObjectTypeId));
    return NULL;
}

BOOL
SavePerObjectStatistics (
    VOID
    )
{
    MIG_OBJECTCOUNT objectCount [3];
    PCTSTR typeKey;
    MIG_OBJECTTYPEID objectTypeId;
    PTYPEINFO objectTypeInfo;
    BOOL result = TRUE;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;

    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
        do {
            objectTypeId = objTypeIdEnum.ObjectTypeId;
            objectTypeInfo = GetTypeInfo (objectTypeId);
            if (objectTypeInfo) {
                typeKey = JoinPaths (S_OBJECTCOUNT, objectTypeInfo->ObjectTypeName);

                MYASSERT (
                    objectTypeInfo->TotalObjects.TotalObjects ==
                        objectTypeInfo->SourceObjects.TotalObjects +
                        objectTypeInfo->DestinationObjects.TotalObjects
                    );
                MYASSERT (
                    objectTypeInfo->TotalObjects.PersistentObjects ==
                        objectTypeInfo->SourceObjects.PersistentObjects +
                        objectTypeInfo->DestinationObjects.PersistentObjects
                    );
                MYASSERT (
                    objectTypeInfo->TotalObjects.ApplyObjects ==
                        objectTypeInfo->SourceObjects.ApplyObjects +
                        objectTypeInfo->DestinationObjects.ApplyObjects
                    );

                CopyMemory (&(objectCount [0]), &objectTypeInfo->TotalObjects, sizeof (MIG_OBJECTCOUNT));
                CopyMemory (&(objectCount [1]), &objectTypeInfo->SourceObjects, sizeof (MIG_OBJECTCOUNT));
                CopyMemory (&(objectCount [2]), &objectTypeInfo->DestinationObjects, sizeof (MIG_OBJECTCOUNT));
                if (!MemDbSetUnorderedBlob (typeKey, 0, (PCBYTE)objectCount, 3 * sizeof (MIG_OBJECTCOUNT))) {
                    MYASSERT (FALSE);
                    EngineError ();
                    result = FALSE;
                }
                FreePathString (typeKey);
            }
        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }

    return result;
}

BOOL
LoadPerObjectStatistics (
    VOID
    )
{
    PMIG_OBJECTCOUNT objectCount;
    DWORD size;
    PCTSTR typeKey;
    MIG_OBJECTTYPEID objectTypeId;
    PTYPEINFO objectTypeInfo;
    BOOL result = TRUE;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;

    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
        do {
            objectTypeId = objTypeIdEnum.ObjectTypeId;
            objectTypeInfo = GetTypeInfo (objectTypeId);
            if (objectTypeInfo) {
                typeKey = JoinPaths (S_OBJECTCOUNT, objectTypeInfo->ObjectTypeName);
                objectCount = (PMIG_OBJECTCOUNT) MemDbGetUnorderedBlob (typeKey, 0, &size);
                if ((!objectCount) || (size != 3 * sizeof (MIG_OBJECTCOUNT))) {
                    if (objectCount) {
                        MemDbReleaseMemory (objectCount);
                    }
                    MYASSERT (FALSE);
                    result = FALSE;
                } else {
                    CopyMemory (&objectTypeInfo->TotalObjects, objectCount, sizeof (MIG_OBJECTCOUNT));
                    CopyMemory (&objectTypeInfo->SourceObjects, objectCount + 1, sizeof (MIG_OBJECTCOUNT));
                    CopyMemory (&objectTypeInfo->DestinationObjects, objectCount + 2, sizeof (MIG_OBJECTCOUNT));
                    MemDbReleaseMemory (objectCount);

                    MYASSERT (
                        objectTypeInfo->TotalObjects.TotalObjects ==
                            objectTypeInfo->SourceObjects.TotalObjects +
                            objectTypeInfo->DestinationObjects.TotalObjects
                        );
                    MYASSERT (
                        objectTypeInfo->TotalObjects.PersistentObjects ==
                            objectTypeInfo->SourceObjects.PersistentObjects +
                            objectTypeInfo->DestinationObjects.PersistentObjects
                        );
                    MYASSERT (
                        objectTypeInfo->TotalObjects.ApplyObjects ==
                            objectTypeInfo->SourceObjects.ApplyObjects +
                            objectTypeInfo->DestinationObjects.ApplyObjects
                        );
                }
                FreePathString (typeKey);
            }
        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }

    return result;
}

MIG_OBJECTTYPEID
IsmRegisterObjectType (
    IN      PCTSTR ObjectTypeName,
    IN      BOOL CanBeRestored,
    IN      BOOL ReadOnly,
    IN      PTYPE_REGISTER TypeRegisterData
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    HASHITEM hashItem;
    PTYPEINFO typeInfo;

    hashItem = HtFindStringEx (g_TypeTable, ObjectTypeName, &objectTypeId, FALSE);
    if (hashItem) {
        // this type was registered before, update information
        typeInfo = GetTypeInfo (objectTypeId);
        if (typeInfo) {
            typeInfo->CanBeRestored = CanBeRestored;
            typeInfo->ReadOnly = ReadOnly;
            if (TypeRegisterData && TypeRegisterData->Priority) {
                typeInfo->Priority = TypeRegisterData->Priority;
            }
            if (TypeRegisterData && TypeRegisterData->EnumFirstPhysicalObject) {
                typeInfo->EnumFirstPhysicalObject = TypeRegisterData->EnumFirstPhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->EnumNextPhysicalObject) {
                typeInfo->EnumNextPhysicalObject = TypeRegisterData->EnumNextPhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->AbortEnumCurrentPhysicalNode) {
                typeInfo->AbortEnumCurrentPhysicalNode = TypeRegisterData->AbortEnumCurrentPhysicalNode;
            }
            if (TypeRegisterData && TypeRegisterData->AbortEnumPhysicalObject) {
                typeInfo->AbortEnumPhysicalObject = TypeRegisterData->AbortEnumPhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->ConvertObjectToMultiSz) {
                typeInfo->ConvertObjectToMultiSz = TypeRegisterData->ConvertObjectToMultiSz;
            }
            if (TypeRegisterData && TypeRegisterData->ConvertMultiSzToObject) {
                typeInfo->ConvertMultiSzToObject = TypeRegisterData->ConvertMultiSzToObject;
            }
            if (TypeRegisterData && TypeRegisterData->GetNativeObjectName) {
                typeInfo->GetNativeObjectName = TypeRegisterData->GetNativeObjectName;
            }
            if (TypeRegisterData && TypeRegisterData->AcquirePhysicalObject) {
                typeInfo->AcquirePhysicalObject = TypeRegisterData->AcquirePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->ReleasePhysicalObject) {
                typeInfo->ReleasePhysicalObject = TypeRegisterData->ReleasePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->DoesPhysicalObjectExist) {
                typeInfo->DoesPhysicalObjectExist = TypeRegisterData->DoesPhysicalObjectExist;
            }
            if (TypeRegisterData && TypeRegisterData->RemovePhysicalObject) {
                typeInfo->RemovePhysicalObject = TypeRegisterData->RemovePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->CreatePhysicalObject) {
                typeInfo->CreatePhysicalObject = TypeRegisterData->CreatePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->ReplacePhysicalObject) {
                typeInfo->ReplacePhysicalObject = TypeRegisterData->ReplacePhysicalObject;
            }
            if (TypeRegisterData && TypeRegisterData->ConvertObjectContentToUnicode) {
                typeInfo->ConvertObjectContentToUnicode = TypeRegisterData->ConvertObjectContentToUnicode;
            }
            if (TypeRegisterData && TypeRegisterData->ConvertObjectContentToAnsi) {
                typeInfo->ConvertObjectContentToAnsi = TypeRegisterData->ConvertObjectContentToAnsi;
            }
            if (TypeRegisterData && TypeRegisterData->FreeConvertedObjectContent) {
                typeInfo->FreeConvertedObjectContent = TypeRegisterData->FreeConvertedObjectContent;
            }
        } else {
            DEBUGMSG ((DBG_WHOOPS, "Cannot get type info for a registered type: %s", ObjectTypeName));
        }
    } else {
        //
        // Allocate a new type
        //

        typeInfo = IsmGetMemory (sizeof (TYPEINFO));
        ZeroMemory (typeInfo, sizeof (TYPEINFO));
        g_MaxType ++;
        objectTypeId = g_MaxType;

        //
        // Separate source and destination types
        //

        StringCopy (typeInfo->SObjectTypeName, TEXT("S"));
        StringCat (typeInfo->SObjectTypeName, ObjectTypeName);
        objectTypeId = objectTypeId | PLATFORM_SOURCE;
        HtAddStringEx (g_TypeTable, typeInfo->SObjectTypeName, &objectTypeId, FALSE);
        objectTypeId = objectTypeId & (~PLATFORM_MASK);

        StringCopy (typeInfo->DObjectTypeName, TEXT("D"));
        StringCat (typeInfo->DObjectTypeName, ObjectTypeName);
        objectTypeId = objectTypeId | PLATFORM_DESTINATION;
        HtAddStringEx (g_TypeTable, typeInfo->DObjectTypeName, &objectTypeId, FALSE);
        objectTypeId = objectTypeId & (~PLATFORM_MASK);

        StringCopy (typeInfo->ObjectTypeName, ObjectTypeName);
        HtAddStringEx (g_TypeTable, typeInfo->ObjectTypeName, &objectTypeId, FALSE);

        //
        // Initialize type info struct's callback members and exclusion list
        //

        typeInfo->CanBeRestored = CanBeRestored;
        typeInfo->ReadOnly = ReadOnly;
        typeInfo->Priority = PRIORITY_LOWEST;

        if (TypeRegisterData) {
            if (TypeRegisterData->Priority) {
                typeInfo->Priority = TypeRegisterData->Priority;
            }
            typeInfo->EnumFirstPhysicalObject = TypeRegisterData->EnumFirstPhysicalObject;
            typeInfo->EnumNextPhysicalObject = TypeRegisterData->EnumNextPhysicalObject;
            typeInfo->AbortEnumCurrentPhysicalNode = TypeRegisterData->AbortEnumCurrentPhysicalNode;
            typeInfo->AbortEnumPhysicalObject = TypeRegisterData->AbortEnumPhysicalObject;
            typeInfo->ConvertObjectToMultiSz = TypeRegisterData->ConvertObjectToMultiSz;
            typeInfo->ConvertMultiSzToObject = TypeRegisterData->ConvertMultiSzToObject;
            typeInfo->GetNativeObjectName = TypeRegisterData->GetNativeObjectName;
            typeInfo->AcquirePhysicalObject = TypeRegisterData->AcquirePhysicalObject;
            typeInfo->ReleasePhysicalObject = TypeRegisterData->ReleasePhysicalObject;
            typeInfo->DoesPhysicalObjectExist = TypeRegisterData->DoesPhysicalObjectExist;
            typeInfo->RemovePhysicalObject = TypeRegisterData->RemovePhysicalObject;
            typeInfo->CreatePhysicalObject = TypeRegisterData->CreatePhysicalObject;
            typeInfo->ReplacePhysicalObject = TypeRegisterData->ReplacePhysicalObject;
            typeInfo->ConvertObjectContentToUnicode = TypeRegisterData->ConvertObjectContentToUnicode;
            typeInfo->ConvertObjectContentToAnsi = TypeRegisterData->ConvertObjectContentToAnsi;
            typeInfo->FreeConvertedObjectContent = TypeRegisterData->FreeConvertedObjectContent;
        }

        typeInfo->ExclusionTable = HtAlloc();

        //
        // Put the typeInfo struct in our list. Then update the flow control
        // structs so that other ETMs can hook the acquire callback of this
        // type.
        //

        pInsertTypeIdAt (&g_TypeList, typeInfo, objectTypeId);
        AddTypeToGlobalEnumerationEnvironment (objectTypeId);

    }
    return objectTypeId;
}

MIG_OBJECTTYPEID
IsmGetObjectTypeId (
    IN      PCTSTR ObjectTypeName
    )
{
    return GetObjectTypeId (ObjectTypeName);
}

PCTSTR
GetObjectTypeName (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        switch (ObjectTypeId & PLATFORM_MASK) {
        case PLATFORM_SOURCE:
            return typeInfo->SObjectTypeName;
        case PLATFORM_DESTINATION:
            return typeInfo->DObjectTypeName;
        default:
            return typeInfo->ObjectTypeName;
        }
    } else {
        return FALSE;
    }
}

PCTSTR
IsmGetObjectTypeName (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    return GetObjectTypeName (ObjectTypeId & (~PLATFORM_MASK));
}

UINT
IsmGetObjectTypePriority (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPEINFO typeInfo;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        return typeInfo->Priority;
    }
    return 0xFFFFFFFF;
}

BOOL
IsmEnumFirstObjectTypeId (
    OUT     PMIG_OBJECTTYPEIDENUM ObjectTypeIdEnum
    )
{
    UINT numTypes = 0;
    UINT index = 0;
    PTYPEINFO typeInfo = NULL;
    UINT priority = 0xFFFFFFFF;
    MIG_OBJECTTYPEID objectTypeId = 0;
    BOOL changed = FALSE;

    ZeroMemory (ObjectTypeIdEnum, sizeof (PMIG_OBJECTTYPEIDENUM));
    numTypes = (g_TypeList.End / sizeof (PTYPEINFO));
    index = 0;
    while (index < numTypes) {
        typeInfo = GetTypeInfo (index + 1);
        if (typeInfo && (typeInfo->Priority == priority)) {
            // we only get here when all registered types
            // have 0xFFFFFFFF priority
            if (!changed) {
                objectTypeId = index + 1;
                priority = typeInfo->Priority;
                changed = TRUE;
            }
        }
        if (typeInfo && (typeInfo->Priority < priority)) {
            // we found a higher priority (lower number)
            objectTypeId = index + 1;
            priority = typeInfo->Priority;
            changed = TRUE;
        }
        index ++;
    }
    if (changed && (objectTypeId != 0)) {
        ObjectTypeIdEnum->ObjectTypeId = objectTypeId;
        return TRUE;
    }
    return FALSE;
}

BOOL
IsmEnumNextObjectTypeId (
    IN OUT  PMIG_OBJECTTYPEIDENUM ObjectTypeIdEnum
    )
{
    UINT numTypes = 0;
    UINT index = 0;
    PTYPEINFO typeInfo = NULL;
    UINT priority = 0xFFFFFFFF;
    UINT oldPriority = 0xFFFFFFFF;
    MIG_OBJECTTYPEID objectTypeId = 0;
    BOOL changed = FALSE;
    BOOL nextTypeId = FALSE;

    if (ObjectTypeIdEnum && (ObjectTypeIdEnum->ObjectTypeId != 0)) {
        typeInfo = GetTypeInfo (ObjectTypeIdEnum->ObjectTypeId);
        oldPriority = typeInfo->Priority;
        objectTypeId = ObjectTypeIdEnum->ObjectTypeId;
    }
    numTypes = (g_TypeList.End / sizeof (PTYPEINFO));
    index = 0;
    while (index < numTypes) {
        typeInfo = GetTypeInfo (index + 1);
        if (typeInfo && (typeInfo->Priority < oldPriority)) {
            // we already enumerated this
            index ++;
            continue;
        }
        if (typeInfo && (typeInfo->Priority == oldPriority)) {
            if (!nextTypeId) {
                // let's see if we just reached the one we previously enumerated
                if (ObjectTypeIdEnum->ObjectTypeId == index + 1) {
                    // yep, let's write that down
                    nextTypeId = TRUE;
                }
                index ++;
                continue;
            }
        }
        if (typeInfo && (typeInfo->Priority == priority)) {
            if (!changed) {
                objectTypeId = index + 1;
                priority = typeInfo->Priority;
                changed = TRUE;
            }
        }
        if (typeInfo && (typeInfo->Priority < priority)) {
            objectTypeId = index + 1;
            priority = typeInfo->Priority;
            changed = TRUE;
        }
        index ++;
    }
    if (changed && (objectTypeId != 0)) {
        ObjectTypeIdEnum->ObjectTypeId = objectTypeId;
        return TRUE;
    }
    return FALSE;
}

VOID
IsmAbortObjectTypeIdEnum (
    IN OUT  PMIG_OBJECTTYPEIDENUM ObjectTypeIdEnum
    )
{
    ZeroMemory (ObjectTypeIdEnum, sizeof (MIG_OBJECTTYPEIDENUM));
}

PCTSTR
GetDecoratedObjectPathFromName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      BOOL CanContainPattern
    )
{
    PCTSTR typeStr;

    typeStr = GetObjectTypeName (ObjectTypeId);
    if (!typeStr) {
        return NULL;
    }

    return JoinPaths (typeStr, ObjectName);
}

//
// General
//

VOID
pAbortPhysicalObjectOfTypeEnum (
    IN      PMIG_TYPEOBJECTENUM EnumPtr             ZEROED
    )
{
    PTYPEINFO typeInfo;
    PADDEDOBJECTSENUM handle;

    handle = (PADDEDOBJECTSENUM) EnumPtr->IsmHandle;
    if (!handle) {
        return;
    }

    if (handle->AddedEnums) {
        AbortPhysicalEnumCallback (EnumPtr, handle->CurrentEnumId);
    } else {

        typeInfo = GetTypeInfo (EnumPtr->ObjectTypeId);
        if (typeInfo && typeInfo->AbortEnumPhysicalObject) {
            typeInfo->AbortEnumPhysicalObject (EnumPtr);
        }
    }

    PmReleaseMemory (g_IsmPool, handle->Pattern);
    IsmDestroyParsedPattern (handle->ParsedPattern);
    PmReleaseMemory (g_IsmPool, handle);

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

VOID
pAbortVirtualObjectOfTypeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PMIG_OBJECT_ENUM objEnum;

    if (EnumPtr->NativeObjectName) {
        IsmReleaseMemory (EnumPtr->NativeObjectName);
    }
    if (EnumPtr->ObjectNode) {
        ObsFree (EnumPtr->ObjectNode);
    }
    if (EnumPtr->ObjectLeaf) {
        ObsFree (EnumPtr->ObjectLeaf);
    }
    if (EnumPtr->Details.DetailsData) {
        IsmReleaseMemory (EnumPtr->Details.DetailsData);
    }
    objEnum = (PMIG_OBJECT_ENUM)EnumPtr->IsmHandle;
    if (objEnum) {
        IsmAbortObjectEnum (objEnum);
        IsmReleaseMemory (objEnum);
    }
    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

VOID
AbortObjectOfTypeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    if (g_IsmCurrentPlatform == g_IsmModulePlatformContext) {
        pAbortPhysicalObjectOfTypeEnum (EnumPtr);
    } else {
        pAbortVirtualObjectOfTypeEnum (EnumPtr);
    }
}

BOOL
pEnumFirstPhysicalObjectOfType (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;
    PADDEDOBJECTSENUM handle;

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));

    if (CheckCancel ()) {
        return FALSE;
    }

    handle = (PADDEDOBJECTSENUM) PmGetAlignedMemory (g_IsmPool, sizeof (ADDEDOBJECTSENUM));
    ZeroMemory (handle, sizeof (ADDEDOBJECTSENUM));
    EnumPtr->IsmHandle = handle;
    handle->Pattern = PmDuplicateString (g_IsmPool, Pattern);
    handle->ParsedPattern = IsmCreateParsedPattern (Pattern);

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->EnumFirstPhysicalObject) {
        EnumPtr->ObjectTypeId = ObjectTypeId;
        result = typeInfo->EnumFirstPhysicalObject (EnumPtr, Pattern, MaxLevel);

        MYASSERT (!result || EnumPtr->ObjectTypeId == ObjectTypeId);

        if (result) {
            result = ExecutePhysicalEnumCheckCallbacks (EnumPtr);

            if (!result) {
                result = pEnumNextPhysicalObjectOfType (EnumPtr);
            }
        } else {
            handle->AddedEnums = TRUE;
            handle->CurrentEnumId = 0;

            ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
            EnumPtr->IsmHandle = handle;
            EnumPtr->ObjectTypeId = ObjectTypeId;

            result = ExecutePhysicalEnumAddCallbacks (
                        EnumPtr,
                        handle->Pattern,
                        handle->ParsedPattern,
                        &handle->CurrentEnumId
                        );
        }
    }

    if (!result) {
        pAbortPhysicalObjectOfTypeEnum (EnumPtr);
    }

    return result;
}

BOOL
pEnumFirstVirtualObjectOfType (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR Pattern,
    IN      UINT MaxLevel
    )
{
    PMIG_OBJECT_ENUM objEnum;
    MIG_CONTENT objectContent;
    BOOL result = FALSE;

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));

    if (CheckCancel ()) {
        return FALSE;
    }

    objEnum = (PMIG_OBJECT_ENUM)IsmGetMemory (sizeof (MIG_OBJECT_ENUM));
    ZeroMemory (objEnum, sizeof (MIG_OBJECT_ENUM));
    EnumPtr->IsmHandle = objEnum;
    if ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
        result = IsmEnumFirstSourceObjectEx (objEnum, ObjectTypeId, Pattern, TRUE);
    } else {
        result = IsmEnumFirstDestinationObjectEx (objEnum, ObjectTypeId, Pattern, TRUE);
    }
    if (result) {
        EnumPtr->ObjectTypeId = objEnum->ObjectTypeId;
        EnumPtr->ObjectName = objEnum->ObjectName;
        EnumPtr->NativeObjectName = IsmGetNativeObjectName (objEnum->ObjectTypeId, objEnum->ObjectName);
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        if (EnumPtr->ObjectNode) {
            GetNodePatternMinMaxLevels (EnumPtr->ObjectNode, NULL, &EnumPtr->Level, NULL);
        } else {
            EnumPtr->Level = 1;
        }
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = (EnumPtr->ObjectLeaf != NULL);
        EnumPtr->IsNode = !EnumPtr->IsLeaf;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;
        if (IsmAcquireObject (objEnum->ObjectTypeId, objEnum->ObjectName, &objectContent)) {
            if (objectContent.Details.DetailsSize && objectContent.Details.DetailsData) {
                EnumPtr->Details.DetailsSize = objectContent.Details.DetailsSize;
                EnumPtr->Details.DetailsData = IsmGetMemory (EnumPtr->Details.DetailsSize);
                CopyMemory ((PBYTE)EnumPtr->Details.DetailsData, objectContent.Details.DetailsData, EnumPtr->Details.DetailsSize);
            }
            IsmReleaseObject (&objectContent);
        }
    } else {
        pAbortVirtualObjectOfTypeEnum (EnumPtr);
    }
    return result;
}

BOOL
EnumFirstObjectOfType (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    if (g_IsmCurrentPlatform == g_IsmModulePlatformContext) {
        return pEnumFirstPhysicalObjectOfType (EnumPtr, ObjectTypeId, Pattern, MaxLevel);
    } else {
        return pEnumFirstVirtualObjectOfType (EnumPtr, ObjectTypeId, Pattern, MaxLevel);
    }
}

BOOL
pEnumNextPhysicalObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PTYPEINFO typeInfo;
    PADDEDOBJECTSENUM handle;
    MIG_OBJECTTYPEID objectTypeId = EnumPtr->ObjectTypeId;

    handle = (PADDEDOBJECTSENUM) EnumPtr->IsmHandle;
    MYASSERT (handle);      // if NULL, perhaps the ETM blew it away

    if (CheckCancel ()) {
        pAbortPhysicalObjectOfTypeEnum (EnumPtr);
        return FALSE;
    }

    typeInfo = GetTypeInfo (objectTypeId);
    if (!typeInfo || !typeInfo->EnumNextPhysicalObject) {
        pAbortPhysicalObjectOfTypeEnum (EnumPtr);
        return FALSE;
    }

    if (!handle->AddedEnums) {

        for (;;) {
            if (typeInfo->EnumNextPhysicalObject (EnumPtr)) {

                MYASSERT (EnumPtr->ObjectTypeId == objectTypeId);

                if (ExecutePhysicalEnumCheckCallbacks (EnumPtr)) {
                    return TRUE;
                }

                continue;

            } else {

                break;

            }
        }

        handle->AddedEnums = TRUE;
        handle->CurrentEnumId = 0;

        ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
        EnumPtr->IsmHandle = handle;
        EnumPtr->ObjectTypeId = objectTypeId;
    }

    if (ExecutePhysicalEnumAddCallbacks (
            EnumPtr,
            handle->Pattern,
            handle->ParsedPattern,
            &handle->CurrentEnumId
            )) {
        return TRUE;
    }

    pAbortPhysicalObjectOfTypeEnum (EnumPtr);
    return FALSE;
}


BOOL
pEnumNextVirtualObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PMIG_OBJECT_ENUM objEnum;
    MIG_CONTENT objectContent;
    BOOL result = FALSE;

    if (CheckCancel ()) {
        return FALSE;
    }

    if (EnumPtr->NativeObjectName) {
        IsmReleaseMemory (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }
    if (EnumPtr->ObjectNode) {
        IsmDestroyObjectString (EnumPtr->ObjectNode);
        EnumPtr->ObjectNode = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmDestroyObjectString (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    if (EnumPtr->Details.DetailsData) {
        EnumPtr->Details.DetailsSize = 0;
        IsmReleaseMemory (EnumPtr->Details.DetailsData);
        EnumPtr->Details.DetailsData = NULL;
    }
    objEnum = (PMIG_OBJECT_ENUM)EnumPtr->IsmHandle;
    result = IsmEnumNextObject (objEnum);
    if (result) {
        EnumPtr->ObjectTypeId = objEnum->ObjectTypeId;
        EnumPtr->ObjectName = objEnum->ObjectName;
        EnumPtr->NativeObjectName = IsmGetNativeObjectName (objEnum->ObjectTypeId, objEnum->ObjectName);
        IsmCreateObjectStringsFromHandle (EnumPtr->ObjectName, &EnumPtr->ObjectNode, &EnumPtr->ObjectLeaf);
        if (EnumPtr->ObjectNode) {
            GetNodePatternMinMaxLevels (EnumPtr->ObjectNode, NULL, &EnumPtr->Level, NULL);
        } else {
            EnumPtr->Level = 1;
        }
        EnumPtr->SubLevel = 0;
        EnumPtr->IsLeaf = (EnumPtr->ObjectLeaf != NULL);
        EnumPtr->IsNode = !EnumPtr->IsLeaf;
        EnumPtr->Details.DetailsSize = 0;
        EnumPtr->Details.DetailsData = NULL;

        if (IsmAcquireObject (objEnum->ObjectTypeId, objEnum->ObjectName, &objectContent)) {
            if (objectContent.Details.DetailsSize && objectContent.Details.DetailsData) {
                EnumPtr->Details.DetailsSize = objectContent.Details.DetailsSize;
                EnumPtr->Details.DetailsData = IsmGetMemory (EnumPtr->Details.DetailsSize);
                CopyMemory ((PBYTE)EnumPtr->Details.DetailsData, objectContent.Details.DetailsData, EnumPtr->Details.DetailsSize);
            }
            IsmReleaseObject (&objectContent);
        }
    } else {
        pAbortVirtualObjectOfTypeEnum (EnumPtr);
    }
    return result;
}

BOOL
EnumNextObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    if (g_IsmCurrentPlatform == g_IsmModulePlatformContext) {
        return pEnumNextPhysicalObjectOfType (EnumPtr);
    } else {
        return pEnumNextVirtualObjectOfType (EnumPtr);
    }
}

VOID
pAbortCurrentPhysicalNodeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PTYPEINFO typeInfo;
    PADDEDOBJECTSENUM handle;

    handle = (PADDEDOBJECTSENUM) EnumPtr->IsmHandle;

    if (handle->AddedEnums) {
        return;
    }

    typeInfo = GetTypeInfo (EnumPtr->ObjectTypeId);
    if (typeInfo && typeInfo->AbortEnumCurrentPhysicalNode) {
        typeInfo->AbortEnumCurrentPhysicalNode (EnumPtr);
    }
}

VOID
pAbortCurrentVirtualNodeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    // NTRAID#NTBUG9-153259-2000/08/01-jimschm implement pAbortCurrentVirtualNodeEnum
}

VOID
AbortCurrentNodeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    if (g_IsmCurrentPlatform == g_IsmModulePlatformContext) {
        pAbortCurrentPhysicalNodeEnum (EnumPtr);
    } else {
        pAbortCurrentVirtualNodeEnum (EnumPtr);
    }
}

BOOL
pIsSameSideType (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    return ((ObjectTypeId & PLATFORM_MASK) == g_IsmCurrentPlatform);
}

BOOL
IsmDoesObjectExist (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    MIG_CONTENT content;

    if (IsmAcquireObjectEx (ObjectTypeId,
                            ObjectName,
                            &content,
                            CONTENTTYPE_DETAILS_ONLY,
                            0) ) {
       IsmReleaseObject (&content);
       return TRUE;
    }

    return FALSE;
}


BOOL
IsmAcquireObjectEx (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PTYPEINFO typeInfo;
    PMIG_CONTENT updatedContent;
    BOOL result = FALSE;
    BOOL callbackResult;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    if (!ObjectContent) {
        return FALSE;
    }

    if (g_IsmCurrentPlatform == PLATFORM_SOURCE && ISRIGHTSIDEOBJECT (ObjectTypeId)) {
        DEBUGMSG ((DBG_WHOOPS, "Can't obtain destination side objects on source side"));
        return FALSE;
    }

    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    ObjectContent->ObjectTypeId = ObjectTypeId;

    if (pIsSameSideType (ObjectTypeId)) {
        typeInfo = GetTypeInfo (ObjectTypeId);
        if (typeInfo && typeInfo->AcquirePhysicalObject) {

            result = typeInfo->AcquirePhysicalObject (
                        ObjectName,
                        ObjectContent,
                        ContentType,
                        MemoryContentLimit
                        );

            //
            // Process all acquire hooks
            //

            callbackResult = ExecutePhysicalAcquireCallbacks (
                                    ObjectTypeId,
                                    ObjectName,
                                    result ? ObjectContent : NULL,
                                    ContentType,
                                    MemoryContentLimit,
                                    &updatedContent
                                    );

            if (result) {
                if (!callbackResult || updatedContent) {
                    //
                    // Free the original content because it has been replaced or deleted
                    //

                    if (typeInfo->ReleasePhysicalObject) {
                        typeInfo->ReleasePhysicalObject (ObjectContent);
                    }
                }
            }

            if (callbackResult) {
                if (updatedContent) {
                    //
                    // Copy the updated content into the caller's struct
                    //

                    CopyMemory (ObjectContent, updatedContent, sizeof (MIG_CONTENT));
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    result = TRUE;
                }
            } else {
                result = FALSE;
            }
        }
    } else {
        result = g_SelectedTransport->TransportAcquireObject (
                                        ObjectTypeId,
                                        ObjectName,
                                        ObjectContent,
                                        ContentType,
                                        MemoryContentLimit
                                        );
    }
    if (!result) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return result;
}

BOOL
IsmReleaseObject (
    IN      PMIG_CONTENT ObjectContent          ZEROED
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    if (pIsSameSideType (ObjectContent->ObjectTypeId)) {
        typeInfo = GetTypeInfo (ObjectContent->ObjectTypeId);
        if (typeInfo) {

            if (!FreeViaAcquirePhysicalCallback (ObjectContent)) {

                if (typeInfo->ReleasePhysicalObject) {
                    result = typeInfo->ReleasePhysicalObject (ObjectContent);
                }
            } else {
                result = TRUE;
            }
        }
    } else {
        result = g_SelectedTransport->TransportReleaseObject (ObjectContent);
    }
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));

    return result;
}

PMIG_CONTENT
IsmConvertObjectContentToUnicode (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    PMIG_CONTENT result = NULL;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    if (!ObjectName) {
        return NULL;
    }

    if (!ObjectContent) {
        return NULL;
    }

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->ConvertObjectContentToUnicode) {

        result = typeInfo->ConvertObjectContentToUnicode (
                    ObjectName,
                    ObjectContent
                    );
    }

    return result;
}

PMIG_CONTENT
IsmConvertObjectContentToAnsi (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    PMIG_CONTENT result = NULL;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    if (!ObjectName) {
        return NULL;
    }

    if (!ObjectContent) {
        return NULL;
    }

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->ConvertObjectContentToAnsi) {

        result = typeInfo->ConvertObjectContentToAnsi (
                    ObjectName,
                    ObjectContent
                    );
    }

    return result;
}

BOOL
IsmFreeConvertedObjectContent (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    BOOL result = TRUE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    if (!ObjectContent) {
        return TRUE;
    }

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->FreeConvertedObjectContent) {

        result = typeInfo->FreeConvertedObjectContent (
                    ObjectContent
                    );
    }

    return result;
}

BOOL
pEmptyContent (
    IN      PMIG_CONTENT content
    )
{
    if (content->ContentInFile) {
        return (content->FileContent.ContentPath == NULL);
    } else {
        return (content->MemoryContent.ContentBytes == NULL);
    }
}

BOOL
RestoreObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName,
    OUT     MIG_COMPARERESULT *Compare,             OPTIONAL
    IN      DWORD OperationPriority,
    OUT     PBOOL DeleteFailed
    )
{
    MIG_CONTENT inboundContent;
    MIG_CONTENT outboundContent;
    MIG_FILTEROUTPUT finalObject;
    PTYPEINFO inTypeInfo;
    PTYPEINFO outTypeInfo;
    BOOL result = FALSE;
    MIG_COMPARERESULT compare;
    BOOL overwriteExisting = FALSE;
    BOOL existentSrc = FALSE;

    if (Compare) {
        *Compare = CR_FAILED;
    }
    compare = CR_FAILED;

    if (DeleteFailed) {
        *DeleteFailed = FALSE;
    }

    if (g_IsmCurrentPlatform != PLATFORM_DESTINATION) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot restore objects on left side"));
        return FALSE;
    }

    inTypeInfo = GetTypeInfo (ObjectTypeId);
    if (!inTypeInfo) {
        DEBUGMSG ((DBG_WHOOPS, "Unknown ObjectTypeId"));
        return FALSE;
    }

    if (ISRIGHTSIDEOBJECT (ObjectTypeId)) {
        if (IsmAcquireObject (
                ObjectTypeId,
                ObjectName,
                &inboundContent
                )) {
            existentSrc = TRUE;
        } else {
            existentSrc = FALSE;
            ZeroMemory (&inboundContent, sizeof (MIG_CONTENT));
            inboundContent.ObjectTypeId = ObjectTypeId;
        }
        if (ApplyOperationsOnObject (
                ObjectTypeId,
                ObjectName,
                FALSE,
                FALSE,
                OperationPriority,
                &inboundContent,
                &finalObject,
                &outboundContent
                )) {
            if (finalObject.Deleted) {
                // we need to delete the object
                if (inTypeInfo->RemovePhysicalObject) {
                    result = inTypeInfo->RemovePhysicalObject (ObjectName);
                    if (!result) {
                        if (DeleteFailed) {
                            *DeleteFailed = TRUE;
                        }
                        result = TRUE;
                    }
                } else {
                    DEBUGMSG ((
                        DBG_WHOOPS,
                        "Type %d does not have RemovePhysicalObject callback",
                        (ObjectTypeId & (~PLATFORM_MASK))
                        ));
                }
            } else {
                if (StringIMatch (ObjectName, finalObject.NewObject.ObjectName) &&
                    ((ObjectTypeId & (~PLATFORM_MASK)) == (finalObject.NewObject.ObjectTypeId & (~PLATFORM_MASK))) &&
                    (existentSrc || pEmptyContent (&outboundContent))
                    ) {
                    // same object, nothing to do
                    compare = 0;
                    result = TRUE;
                } else {
                    if ((ObjectTypeId & (~PLATFORM_MASK)) == (finalObject.NewObject.ObjectTypeId & (~PLATFORM_MASK))) {
                        outTypeInfo = inTypeInfo;
                    } else {
                        outTypeInfo = GetTypeInfo (finalObject.NewObject.ObjectTypeId);
                        if (!outTypeInfo) {
                            outTypeInfo = inTypeInfo;
                        }
                    }
                    if (outTypeInfo->CreatePhysicalObject &&
                        outTypeInfo->DoesPhysicalObjectExist &&
                        outTypeInfo->RemovePhysicalObject
                        ) {
                        overwriteExisting = FALSE;
                        if (!overwriteExisting) {
                            overwriteExisting = IsmIsObjectAbandonedOnCollision (
                                                    finalObject.NewObject.ObjectTypeId,
                                                    finalObject.NewObject.ObjectName
                                                    );
                        }
                        if (!overwriteExisting) {
                            overwriteExisting = !IsmIsObjectAbandonedOnCollision (
                                                    ObjectTypeId,
                                                    ObjectName
                                                    );
                        }
                        if (overwriteExisting) {
                            if ((inTypeInfo == outTypeInfo) &&
                                (outTypeInfo->ReplacePhysicalObject)
                                ) {
                                //
                                // we have the same type and the type owner implements ReplacePhysicalObject
                                //
                                if (outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                    compare = CR_DESTINATION_EXISTS;
                                }
                                result = outTypeInfo->ReplacePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                            } else {
                                //
                                // we are having different types or we need to emulate ReplacePhysicalObject
                                //
                                if (outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                    result = outTypeInfo->RemovePhysicalObject (finalObject.NewObject.ObjectName);
                                } else {
                                    result = TRUE;
                                }
                                if (result) {
                                    result = outTypeInfo->CreatePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                                } else {
                                    compare = CR_DESTINATION_EXISTS;
                                }
                            }
                        } else {
                            if (!outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                result = outTypeInfo->CreatePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                            } else {
                                result = TRUE;
                                compare = CR_DESTINATION_EXISTS;
                            }
                        }
                    } else {
                        DEBUGMSG ((
                            DBG_WHOOPS,
                            "Type %d does not have RemovePhysicalObject or CreatePhysicalObject callback",
                            (ObjectTypeId & (~PLATFORM_MASK))
                            ));
                    }
                }
            }
            FreeFilterOutput (ObjectName, &finalObject);
            FreeApplyOutput (&inboundContent, &outboundContent);
        } else {
            DEBUGMSG ((DBG_ERROR, "Failed to apply operations on object %s", ObjectName));
        }

        if (existentSrc) {
            IsmReleaseObject (&inboundContent);
        } else {
            compare = CR_SOURCE_DOES_NOT_EXIST;
        }
    } else {
        if (IsmAcquireObject (
                ObjectTypeId,
                ObjectName,
                &inboundContent
                )) {
            if (ApplyOperationsOnObject (
                    ObjectTypeId,
                    ObjectName,
                    FALSE,
                    FALSE,
                    OperationPriority,
                    &inboundContent,
                    &finalObject,
                    &outboundContent
                    )) {
                if (finalObject.Deleted) {
                    // nothing to do, the virtual object won't get restored
                    result = TRUE;
                } else {
                    if ((ObjectTypeId & (~PLATFORM_MASK)) == (finalObject.NewObject.ObjectTypeId & (~PLATFORM_MASK))) {
                        outTypeInfo = inTypeInfo;
                    } else {
                        outTypeInfo = GetTypeInfo (finalObject.NewObject.ObjectTypeId);
                        if (!outTypeInfo) {
                            outTypeInfo = inTypeInfo;
                        }
                    }
                    if (outTypeInfo->CreatePhysicalObject &&
                        outTypeInfo->DoesPhysicalObjectExist &&
                        outTypeInfo->RemovePhysicalObject
                        ) {
                        overwriteExisting = FALSE;
                        if (!overwriteExisting) {
                            overwriteExisting = IsmIsObjectAbandonedOnCollision (
                                                    (finalObject.NewObject.ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_DESTINATION,
                                                    finalObject.NewObject.ObjectName
                                                    );
                        }
                        if (!overwriteExisting) {
                            overwriteExisting = !IsmIsObjectAbandonedOnCollision (
                                                    ObjectTypeId,
                                                    ObjectName
                                                    );
                        }
                        if (overwriteExisting) {
                            if ((inTypeInfo == outTypeInfo) &&
                                (outTypeInfo->ReplacePhysicalObject)
                                ) {
                                //
                                // we have the same type and the type owner implements ReplacePhysicalObject
                                //
                                if (outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                    compare = CR_DESTINATION_EXISTS;
                                }
                                result = outTypeInfo->ReplacePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                            } else {
                                //
                                // we are having different types or we need to emulate ReplacePhysicalObject
                                //
                                if (outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                    result = outTypeInfo->RemovePhysicalObject (finalObject.NewObject.ObjectName);
                                } else {
                                    result = TRUE;
                                }
                                if (result) {
                                    result = outTypeInfo->CreatePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                                } else {
                                    compare = CR_DESTINATION_EXISTS;
                                }
                            }
                        } else {
                            if (!outTypeInfo->DoesPhysicalObjectExist (finalObject.NewObject.ObjectName)) {
                                result = outTypeInfo->CreatePhysicalObject (finalObject.NewObject.ObjectName, &outboundContent);
                            } else {
                                result = TRUE;
                                compare = CR_DESTINATION_EXISTS;
                            }
                        }
                    } else {
                        DEBUGMSG ((
                            DBG_WHOOPS,
                            "Type %d does not have RemovePhysicalObject or CreatePhysicalObject callback",
                            (ObjectTypeId & (~PLATFORM_MASK))
                            ));
                    }
                }
                FreeFilterOutput (ObjectName, &finalObject);
                FreeApplyOutput (&inboundContent, &outboundContent);
            } else {
                DEBUGMSG ((DBG_ERROR, "Failed to apply operations on object %s", ObjectName));
            }
            IsmReleaseObject (&inboundContent);
        } else {
            compare = CR_SOURCE_DOES_NOT_EXIST;
        }
    }

    if (Compare) {
        *Compare = compare;
    }

    return result;
}

BOOL
pPhysicalObjectEnumWorker (
    IN      BOOL Result,
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum,
    IN      PTOPLEVELENUM_HANDLE Handle
    )
{
    if (!Result) {
        AbortPhysicalObjectEnum (ObjectEnum);
    } else {
        ObjectEnum->ObjectTypeId = Handle->Enum.ObjectTypeId;
        ObjectEnum->ObjectName = Handle->Enum.ObjectName;
    }

    return Result;
}


BOOL
EnumFirstPhysicalObject (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    )
{
    PTOPLEVELENUM_HANDLE handle;
    BOOL b;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    ZeroMemory (ObjectEnum, sizeof (MIG_OBJECT_ENUM));

    ObjectEnum->Handle = MemAllocZeroed (sizeof (TOPLEVELENUM_HANDLE));
    handle = (PTOPLEVELENUM_HANDLE) ObjectEnum->Handle;

    b = EnumFirstObjectOfType (&handle->Enum, ObjectTypeId, ObjectPattern, NODE_LEVEL_MAX);

    return pPhysicalObjectEnumWorker (b, ObjectEnum, handle);
}


BOOL
EnumNextPhysicalObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    )
{
    PTOPLEVELENUM_HANDLE handle;
    BOOL b;

    handle = (PTOPLEVELENUM_HANDLE) ObjectEnum->Handle;

    b = EnumNextObjectOfType (&handle->Enum);

    if (!b) {
        handle->Completed = TRUE;
    }

    return pPhysicalObjectEnumWorker (b, ObjectEnum, handle);
}


VOID
AbortPhysicalObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    )
{
    PTOPLEVELENUM_HANDLE handle;

    handle = (PTOPLEVELENUM_HANDLE) ObjectEnum->Handle;

    if (handle) {
        if (!handle->Completed) {
            AbortObjectOfTypeEnum (&handle->Enum);
        }

        FreeAlloc (handle);
    }

    ZeroMemory (ObjectEnum, sizeof (MIG_OBJECT_ENUM));
}

PCTSTR
IsmConvertObjectToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    PCTSTR result = NULL;

    typeInfo = GetTypeInfo (ObjectContent->ObjectTypeId);
    if (typeInfo && typeInfo->ConvertObjectToMultiSz) {
        result = typeInfo->ConvertObjectToMultiSz (ObjectName, ObjectContent);
    }
    return result;
}

BOOL
IsmConvertMultiSzToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->ConvertMultiSzToObject) {

        if (ObjectContent) {
            ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
            ObjectContent->ObjectTypeId = ObjectTypeId;
        }

        result = typeInfo->ConvertMultiSzToObject (ObjectMultiSz, ObjectName, ObjectContent);
    }
    return result;
}

PCTSTR
TrackedIsmGetNativeObjectName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
            TRACKING_DEF
    )
{
    PTYPEINFO typeInfo;
    PCTSTR result = NULL;

    TRACK_ENTER();

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->GetNativeObjectName) {
        result = typeInfo->GetNativeObjectName (ObjectName);
    }

    TRACK_LEAVE();
    return result;
}

BOOL
pUserKeyPrefix (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR nativeObjectName;
    BOOL result = FALSE;

    nativeObjectName = IsmGetNativeObjectName (ObjectTypeId, ObjectName);
    result = StringIMatchTcharCount (TEXT("HKCU\\"), nativeObjectName, 5);
    IsmReleaseMemory (nativeObjectName);
    return result;
}

BOOL
IsmDoesRollbackDataExist (
    OUT     PCTSTR *UserName,
    OUT     PCTSTR *UserDomain,
    OUT     PCTSTR *UserStringSid,
    OUT     PCTSTR *UserProfilePath,
    OUT     BOOL *UserProfileCreated
    )
{
    TCHAR userName [MAX_TCHAR_PATH];
    TCHAR userDomain [MAX_TCHAR_PATH];
    TCHAR userStringSid [MAX_TCHAR_PATH];
    TCHAR userProfilePath [MAX_TCHAR_PATH];
    BOOL userProfileCreated;
    PCTSTR journalFile = NULL;
    DWORD tempField;
    BOOL result = FALSE;

    if (g_JournalHandle) {
        return FALSE;
    }
    if (!g_JournalDirectory) {
        return FALSE;
    }

    __try {

        // Open the journal file
        journalFile = JoinPaths (g_JournalDirectory, TEXT("JOURNAL.DAT"));
        g_JournalHandle = BfOpenReadFile (journalFile);
        if (!g_JournalHandle) {
            __leave;
        }
        FreePathString (journalFile);
        journalFile = NULL;

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
            __leave;
        }

        if (tempField != JRN_SIGNATURE) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
            __leave;
        }

        if (tempField != JRN_VERSION) {
            __leave;
        }

        // now read user's name, domain, SID and profile path
        if (!BfReadFile (g_JournalHandle, (PBYTE)(userName), MAX_TCHAR_PATH)) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userDomain), MAX_TCHAR_PATH)) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userStringSid), MAX_TCHAR_PATH)) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userProfilePath), MAX_TCHAR_PATH)) {
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&userProfileCreated), sizeof (BOOL))) {
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (g_JournalHandle) {
            CloseHandle (g_JournalHandle);
            g_JournalHandle = NULL;
        }

        if (journalFile) {
            FreePathString (journalFile);
            journalFile = NULL;
        }
    }

    if (result) {
        if (UserName) {
            *UserName = PmDuplicateString (g_IsmPool, userName);
        }
        if (UserDomain) {
            *UserDomain = PmDuplicateString (g_IsmPool, userDomain);
        }
        if (UserStringSid) {
            *UserStringSid = PmDuplicateString (g_IsmPool, userStringSid);
        }
        if (UserProfilePath) {
            *UserProfilePath = PmDuplicateString (g_IsmPool, userProfilePath);
        }
        if (UserProfileCreated) {
            *UserProfileCreated = userProfileCreated;
        }
    }

    return result;
}

BOOL
IsmRollback (
    VOID
    )
{
#ifdef PRERELEASE
    // crash hooks
    static DWORD totalObjects = 0;
    MIG_OBJECTTYPEID objTypeId;
    PCTSTR nativeName = NULL;
#endif
    GROWBUFFER buffer = INIT_GROWBUFFER;
    TCHAR userName [MAX_TCHAR_PATH];
    TCHAR userDomain [MAX_TCHAR_PATH];
    TCHAR userStringSid [MAX_TCHAR_PATH];
    TCHAR userProfilePath [MAX_TCHAR_PATH];
    BOOL userProfileCreated;
    PCTSTR journalFile = NULL;
    DWORD entrySizeHead;
    DWORD entrySizeTail;
    LONGLONG fileMaxPos = 0;
    PBYTE currPtr;
    DWORD tempSize;
    PDWORD operationType;
    MIG_OBJECTTYPEID *objectTypeId;
    ENCODEDSTRHANDLE objectName;
    MIG_CONTENT objectContent;
    PTYPEINFO typeInfo;
    DWORD tempField;
    BOOL ignoreUserKeys = TRUE;
    BOOL mappedUserProfile = FALSE;
    PCURRENT_USER_DATA currentUserData = NULL;
#ifdef DEBUG
    PCTSTR nativeObjectName;
#endif

    if (g_JournalHandle) {
        return FALSE;
    }
    if (!g_JournalDirectory) {
        return FALSE;
    }

    g_RollbackMode = TRUE;

    __try {

        // Open the journal file
        journalFile = JoinPaths (g_JournalDirectory, TEXT("JOURNAL.DAT"));
        g_JournalHandle = BfOpenReadFile (journalFile);
        if (!g_JournalHandle) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_CANT_FIND_JOURNAL, journalFile));
            __leave;
        }
        FreePathString (journalFile);
        journalFile = NULL;

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ROLLBACK_INVALID_JOURNAL, journalFile));
            __leave;
        }

        if (tempField != JRN_SIGNATURE) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ROLLBACK_INVALID_JOURNAL, journalFile));
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ROLLBACK_INVALID_JOURNAL, journalFile));
            __leave;
        }

        if (tempField != JRN_VERSION) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ROLLBACK_INVALID_JOURNAL_VER, journalFile));
            __leave;
        }

        // now read user's name, domain, SID and profile path
        if (!BfReadFile (g_JournalHandle, (PBYTE)(userName), MAX_TCHAR_PATH)) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userDomain), MAX_TCHAR_PATH)) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userStringSid), MAX_TCHAR_PATH)) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(userProfilePath), MAX_TCHAR_PATH)) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        if (!BfReadFile (g_JournalHandle, (PBYTE)(&userProfileCreated), sizeof (BOOL))) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_NOTHING_TO_DO));
            FiRemoveAllFilesInTree (g_JournalDirectory);
            __leave;
        }

        // get current user data
        currentUserData = GetCurrentUserData ();
        if (currentUserData) {
            if (StringIMatch (userProfilePath, currentUserData->UserProfilePath)) {
                // if we are in the same profile we'll just continue if we are talking about the same user
                // This is possible in two cases:
                // 1. There was a merge with current user
                // 2. A profile was created but we are logged on as that profile
                ignoreUserKeys = !(StringIMatch (userStringSid, currentUserData->UserStringSid));
            } else {
                // we are logged on with a different profile
                if (userProfileCreated) {
                    // 1. If the old user was created we will attempt to remove it's profile
                    //    and we will ignore all user keys
                    ignoreUserKeys = TRUE;
                    if (*userProfilePath && *userStringSid) {
                        // we successfully created a user before, let's remove it's profile
                        DeleteUserProfile (userStringSid, userProfilePath);
                    }
                } else {
                    // 2. We did not create the user. It means that we are logged on as
                    //    a different user and we need to map it's profile in. We will not
                    //    ignore user keys
                    mappedUserProfile = MapUserProfile (userStringSid, userProfilePath);
                    if (mappedUserProfile) {
                        ignoreUserKeys = FALSE;
                    } else {
                        // some error occured, we cannot restore user keys
                        ignoreUserKeys = TRUE;
                    }
                }
            }
        } else {
            // we cannot assume nothing about the user's hive.
            // We'll just have to ignore all user's keys
            ignoreUserKeys = TRUE;
        }

        // Validate the file
        // We start from the beginning and read a DWORD, skip the DWORD value and expect to
        // read the same DWORD after that
        // We stop the first time when this is not true, assuming that a crash has made the
        // rest of the file useless.
        while (TRUE) {
            if (!BfReadFile (g_JournalHandle, (PBYTE)&entrySizeHead, sizeof (DWORD))) {
                break;
            }
            if (!BfSetFilePointer (g_JournalHandle, JOURNAL_FULL_HEADER_SIZE + fileMaxPos + sizeof (DWORD) + (LONGLONG)entrySizeHead)) {
                break;
            }
            if (!BfReadFile (g_JournalHandle, (PBYTE)&entrySizeTail, sizeof (DWORD))) {
                break;
            }
            if (entrySizeHead != entrySizeTail) {
                break;
            }
            fileMaxPos += entrySizeHead + 2 * sizeof (DWORD);
        }
        if (fileMaxPos == 0) {
            LOG ((LOG_WARNING, (PCSTR) MSG_ROLLBACK_EMPTY_OR_INVALID_JOURNAL, journalFile));
        } else {
            while (fileMaxPos) {
                fileMaxPos -= sizeof (DWORD);
                if (!BfSetFilePointer (g_JournalHandle, JOURNAL_FULL_HEADER_SIZE + fileMaxPos)) {
                    break;
                }
                if (!BfReadFile (g_JournalHandle, (PBYTE)&entrySizeTail, sizeof (DWORD))) {
                    break;
                }
                fileMaxPos -= entrySizeTail;
                if (!BfSetFilePointer (g_JournalHandle, JOURNAL_FULL_HEADER_SIZE + fileMaxPos)) {
                    break;
                }
                buffer.End = 0;
                if (!BfReadFile (g_JournalHandle, GbGrow (&buffer, entrySizeTail), entrySizeTail)) {
                    break;
                }

                // Now process the entry
                currPtr = buffer.Buf;
                operationType = (PDWORD) currPtr;
                currPtr += sizeof (DWORD);
                switch (*operationType) {
                case JRNOP_CREATE:

                    // get the object type id
                    objectTypeId = (MIG_OBJECTTYPEID *) currPtr;
                    currPtr += sizeof (MIG_OBJECTTYPEID);
                    // get the object name
                    currPtr += sizeof (DWORD);
                    objectName = (ENCODEDSTRHANDLE) currPtr;
#ifdef PRERELEASE
                    // crash hooks
                    totalObjects ++;
                    if (g_CrashCountObjects == totalObjects) {
                        DebugBreak ();
                    }
                    objTypeId = (*objectTypeId) & (~PLATFORM_MASK);
                    if (g_CrashNameTypeId == objTypeId) {
                        nativeName = IsmGetNativeObjectName (objTypeId, objectName);
                        if (StringIMatch (nativeName, g_CrashNameObject)) {
                            DebugBreak ();
                        }
                        IsmReleaseMemory (nativeName);
                    }
#endif

                    if (ignoreUserKeys && (*objectTypeId == MIG_REGISTRY_TYPE) && pUserKeyPrefix (*objectTypeId, objectName)) {
                        // we are just ignoring this
#ifdef DEBUG
                        nativeObjectName = IsmGetNativeObjectName (*objectTypeId, objectName);
                        DEBUGMSG ((DBG_VERBOSE, "Ignoring user key %s", nativeObjectName));
                        IsmReleaseMemory (nativeObjectName);
#endif
                    } else {
                        typeInfo = GetTypeInfo (*objectTypeId);
                        if (!typeInfo) {
                            DEBUGMSG ((DBG_WHOOPS, "Rollback: Unknown ObjectTypeId: %d", *objectTypeId));
                        } else {
                            if (typeInfo->RemovePhysicalObject) {
                                typeInfo->RemovePhysicalObject (objectName);
                            }
                            ELSE_DEBUGMSG ((DBG_WHOOPS, "Rollback: ObjectTypeId %d does not implement RemovePhysicalObject", *objectTypeId));
                        }
                    }
                    break;
                case JRNOP_DELETE:
                    // get the object type id
                    objectTypeId = (MIG_OBJECTTYPEID *) currPtr;
                    currPtr += sizeof (MIG_OBJECTTYPEID);
                    // get the object name
                    tempSize = *((PDWORD)currPtr);
                    currPtr += sizeof (DWORD);
                    objectName = (ENCODEDSTRHANDLE) currPtr;
                    MYASSERT (tempSize == SizeOfString (objectName));
                    currPtr += tempSize;
                    // get the object content
                    tempSize = *((PDWORD)currPtr);
                    MYASSERT (tempSize == sizeof (MIG_CONTENT));
                    currPtr += sizeof (DWORD);
                    CopyMemory (&objectContent, currPtr, sizeof (MIG_CONTENT));
                    objectContent.EtmHandle = NULL;
                    objectContent.IsmHandle = NULL;
                    currPtr += tempSize;
                    // get the object details, put them in the object content
                    tempSize = *((PDWORD)currPtr);
                    currPtr += sizeof (DWORD);
                    objectContent.Details.DetailsSize = tempSize;
                    if (tempSize) {
                        objectContent.Details.DetailsData = IsmGetMemory (tempSize);
                        CopyMemory ((PBYTE)(objectContent.Details.DetailsData), currPtr, tempSize);
                    } else {
                        objectContent.Details.DetailsData = NULL;
                    }
                    currPtr += tempSize;
                    // get the actual memory or file content
                    if (objectContent.ContentInFile) {
                        tempSize = *((PDWORD)currPtr);
                        currPtr += sizeof (DWORD);
                        if (tempSize) {
                            objectContent.FileContent.ContentPath = JoinPaths (g_JournalDirectory, (PCTSTR)currPtr);
                        } else {
                            objectContent.FileContent.ContentSize = 0;
                            objectContent.FileContent.ContentPath = NULL;
                        }
                        currPtr += tempSize;
                    } else {
                        tempSize = *((PDWORD)currPtr);
                        currPtr += sizeof (DWORD);
                        if (tempSize) {
                            MYASSERT (objectContent.MemoryContent.ContentSize == tempSize);
                            objectContent.MemoryContent.ContentSize = tempSize;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (tempSize);
                            CopyMemory ((PBYTE)(objectContent.MemoryContent.ContentBytes), currPtr, tempSize);
                        } else {
                            objectContent.MemoryContent.ContentSize = 0;
                            objectContent.MemoryContent.ContentBytes = NULL;
                        }
                        currPtr += tempSize;
                    }
                    if (ignoreUserKeys && (*objectTypeId == MIG_REGISTRY_TYPE) && pUserKeyPrefix (*objectTypeId, objectName)) {
                        // we are just ignoring this
#ifdef DEBUG
                        nativeObjectName = IsmGetNativeObjectName (*objectTypeId, objectName);
                        DEBUGMSG ((DBG_VERBOSE, "Ignoring user key %s", nativeObjectName));
                        IsmReleaseMemory (nativeObjectName);
#endif
                    } else {
                        typeInfo = GetTypeInfo (*objectTypeId);
                        if (!typeInfo) {
                            DEBUGMSG ((DBG_WHOOPS, "Rollback: Unknown ObjectTypeId: %d", *objectTypeId));
                        } else {
                            if (typeInfo->CreatePhysicalObject) {
                                typeInfo->CreatePhysicalObject (objectName, &objectContent);
                            }
                            ELSE_DEBUGMSG ((DBG_WHOOPS, "Rollback: ObjectTypeId %d does not implement CreatePhysicalObject", *objectTypeId));
                        }
                    }
                    break;
                default:
                    DEBUGMSG ((DBG_WHOOPS, "Rollback: Wrong operation type in pRecordOperation: %d", operationType));
                }

                fileMaxPos -= sizeof (DWORD);
            }
        }
        //
        // We successfully completed the rollback, let's remove the journal directory
        //
        CloseHandle (g_JournalHandle);
        g_JournalHandle = NULL;

        FiRemoveAllFilesInTree (g_JournalDirectory);
    }
    __finally {
        if (mappedUserProfile) {
            UnmapUserProfile (userStringSid);
            mappedUserProfile = FALSE;
        }

        if (currentUserData) {
            FreeCurrentUserData (currentUserData);
            currentUserData = NULL;
        }

        GbFree (&buffer);

        if (g_JournalHandle) {
            CloseHandle (g_JournalHandle);
            g_JournalHandle = NULL;
        }

        if (journalFile) {
            FreePathString (journalFile);
            journalFile = NULL;
        }

        g_RollbackMode = FALSE;

    }

    return TRUE;
}

BOOL
ExecuteDelayedOperations (
    IN      BOOL CleanupOnly
    )
{
    GROWBUFFER buffer = INIT_GROWBUFFER;
    PCURRENT_USER_DATA currentUserData = NULL;
    PCTSTR journalDir = NULL;
    PCTSTR journalFile = NULL;
    HANDLE journalFileHandle = NULL;
    DWORD tempField;
    DWORD entrySizeHead;
    DWORD entrySizeTail;
    LONGLONG fileMaxPos = 0;
    DWORD tempSize;
    PBYTE currPtr;
    PDWORD operationType;
    MIG_OBJECTTYPEID *objectTypeId;
    ENCODEDSTRHANDLE objectName;
    MIG_CONTENT objectContent;
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    __try {
        currentUserData = GetCurrentUserData ();
        if (!currentUserData) {
            __leave;
        }

        journalDir = JoinPaths (currentUserData->UserProfilePath, TEXT("usrusmt2.tmp"));

        if (!CleanupOnly) {

            journalFile = JoinPaths (journalDir, TEXT("JOURNAL.DAT"));

            journalFileHandle = BfOpenReadFile (journalFile);
            if (!journalFileHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_CANT_FIND_JOURNAL, journalFile));
                __leave;
            }

            if (!BfReadFile (journalFileHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL, journalFile));
                __leave;
            }
            if (tempField != JRN_USR_SIGNATURE) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL, journalFile));
                __leave;
            }

            if (!BfReadFile (journalFileHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL, journalFile));
                __leave;
            }
            if (tempField != JRN_USR_VERSION) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL_VER, journalFile));
                __leave;
            }

            if (!BfReadFile (journalFileHandle, (PBYTE)(&tempField), sizeof (DWORD))) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL, journalFile));
                __leave;
            }
            if (tempField != JRN_USR_COMPLETE) {
                LOG ((LOG_ERROR, (PCSTR) MSG_DELAY_INVALID_JOURNAL_STATE, journalFile));
                __leave;
            }

            // Validate the file
            // We start from the beginning and read a DWORD, skip the DWORD value and expect to
            // read the same DWORD after that
            // We stop the first time when this is not true, assuming that a crash has made the
            // rest of the file useless.
            while (TRUE) {
                if (!BfReadFile (journalFileHandle, (PBYTE)&entrySizeHead, sizeof (DWORD))) {
                    break;
                }
                if (!BfSetFilePointer (journalFileHandle, JRN_USR_HEADER_SIZE + fileMaxPos + sizeof (DWORD) + (LONGLONG)entrySizeHead)) {
                    break;
                }
                if (!BfReadFile (journalFileHandle, (PBYTE)&entrySizeTail, sizeof (DWORD))) {
                    break;
                }
                if (entrySizeHead != entrySizeTail) {
                    break;
                }
                fileMaxPos += entrySizeHead + 2 * sizeof (DWORD);
            }

            if (fileMaxPos == 0) {
                LOG ((LOG_WARNING, (PCSTR) MSG_DELAY_EMPTY_OR_INVALID_JOURNAL, journalFile));
            } else {
                while (fileMaxPos) {
                    fileMaxPos -= sizeof (DWORD);
                    if (!BfSetFilePointer (journalFileHandle, JRN_USR_HEADER_SIZE + fileMaxPos)) {
                        break;
                    }
                    if (!BfReadFile (journalFileHandle, (PBYTE)&entrySizeTail, sizeof (DWORD))) {
                        break;
                    }
                    fileMaxPos -= entrySizeTail;
                    if (!BfSetFilePointer (journalFileHandle, JRN_USR_HEADER_SIZE + fileMaxPos)) {
                        break;
                    }
                    buffer.End = 0;
                    if (!BfReadFile (journalFileHandle, GbGrow (&buffer, entrySizeTail), entrySizeTail)) {
                        break;
                    }

                    // Now process the entry
                    // BUGBUG - implement this

                    // Now process the entry
                    currPtr = buffer.Buf;
                    operationType = (PDWORD) currPtr;
                    currPtr += sizeof (DWORD);
                    switch (*operationType) {
                    case JRNOP_DELETE:
                        // get the object type id
                        objectTypeId = (MIG_OBJECTTYPEID *) currPtr;
                        currPtr += sizeof (MIG_OBJECTTYPEID);
                        // get the object name
                        currPtr += sizeof (DWORD);
                        objectName = (ENCODEDSTRHANDLE) currPtr;
                        typeInfo = GetTypeInfo (*objectTypeId);
                        if (!typeInfo) {
                            DEBUGMSG ((DBG_WHOOPS, "Delayed operations: Unknown ObjectTypeId: %d", *objectTypeId));
                        } else {
                            if (typeInfo->RemovePhysicalObject) {
                                typeInfo->RemovePhysicalObject (objectName);
                            }
                            ELSE_DEBUGMSG ((DBG_WHOOPS, "Delayed operations: ObjectTypeId %d does not implement RemovePhysicalObject", *objectTypeId));
                        }
                        break;
                    case JRNOP_CREATE:
                    case JRNOP_REPLACE:
                        // get the object type id
                        objectTypeId = (MIG_OBJECTTYPEID *) currPtr;
                        currPtr += sizeof (MIG_OBJECTTYPEID);
                        // get the object name
                        tempSize = *((PDWORD)currPtr);
                        currPtr += sizeof (DWORD);
                        objectName = (ENCODEDSTRHANDLE) currPtr;
                        MYASSERT (tempSize == SizeOfString (objectName));
                        currPtr += tempSize;
                        // get the object content
                        tempSize = *((PDWORD)currPtr);
                        MYASSERT (tempSize == sizeof (MIG_CONTENT));
                        currPtr += sizeof (DWORD);
                        CopyMemory (&objectContent, currPtr, sizeof (MIG_CONTENT));
                        objectContent.EtmHandle = NULL;
                        objectContent.IsmHandle = NULL;
                        currPtr += tempSize;
                        // get the object details, put them in the object content
                        tempSize = *((PDWORD)currPtr);
                        currPtr += sizeof (DWORD);
                        objectContent.Details.DetailsSize = tempSize;
                        if (tempSize) {
                            objectContent.Details.DetailsData = IsmGetMemory (tempSize);
                            CopyMemory ((PBYTE)(objectContent.Details.DetailsData), currPtr, tempSize);
                        } else {
                            objectContent.Details.DetailsData = NULL;
                        }
                        currPtr += tempSize;
                        // get the actual memory or file content
                        if (objectContent.ContentInFile) {
                            tempSize = *((PDWORD)currPtr);
                            currPtr += sizeof (DWORD);
                            if (tempSize) {
                                objectContent.FileContent.ContentPath = JoinPaths (g_JournalDirectory, (PCTSTR)currPtr);
                            } else {
                                objectContent.FileContent.ContentSize = 0;
                                objectContent.FileContent.ContentPath = NULL;
                            }
                            currPtr += tempSize;
                        } else {
                            tempSize = *((PDWORD)currPtr);
                            currPtr += sizeof (DWORD);
                            if (tempSize) {
                                MYASSERT (objectContent.MemoryContent.ContentSize == tempSize);
                                objectContent.MemoryContent.ContentSize = tempSize;
                                objectContent.MemoryContent.ContentBytes = IsmGetMemory (tempSize);
                                CopyMemory ((PBYTE)(objectContent.MemoryContent.ContentBytes), currPtr, tempSize);
                            } else {
                                objectContent.MemoryContent.ContentSize = 0;
                                objectContent.MemoryContent.ContentBytes = NULL;
                            }
                            currPtr += tempSize;
                        }
                        typeInfo = GetTypeInfo (*objectTypeId);
                        if (!typeInfo) {
                            DEBUGMSG ((DBG_WHOOPS, "Delayed operations: Unknown ObjectTypeId: %d", *objectTypeId));
                        } else {
                            if (*operationType == JRNOP_CREATE) {
                                if (typeInfo->CreatePhysicalObject) {
                                    typeInfo->CreatePhysicalObject (objectName, &objectContent);
                                }
                                ELSE_DEBUGMSG ((
                                        DBG_WHOOPS,
                                        "Delayed operations: ObjectTypeId %d does not implement CreatePhysicalObject",
                                        *objectTypeId
                                        ));
                            } else {
                                if (typeInfo->ReplacePhysicalObject) {
                                    typeInfo->ReplacePhysicalObject (objectName, &objectContent);
                                }
                                ELSE_DEBUGMSG ((
                                        DBG_WHOOPS,
                                        "Delayed operations: ObjectTypeId %d does not implement ReplacePhysicalObject",
                                        *objectTypeId
                                        ));
                            }
                        }
                        break;
                    default:
                        DEBUGMSG ((
                            DBG_WHOOPS,
                            "Delayed operations: Wrong operation type in ExecuteDelayedOperations: %d",
                            operationType
                            ));
                    }
                    fileMaxPos -= sizeof (DWORD);
                }
            }
        }
        result = TRUE;
    }
    __finally {
        GbFree (&buffer);
        if (result) {
            FiRemoveAllFilesInTree (journalDir);
        }
        if (currentUserData) {
            FreeCurrentUserData (currentUserData);
            currentUserData = NULL;
        }
        if (journalDir) {
            FreePathString (journalDir);
            journalDir = NULL;
        }
        if (journalFile) {
            FreePathString (journalFile);
            journalFile = NULL;
        }
        if (journalFileHandle && (journalFileHandle != INVALID_HANDLE_VALUE)) {
            CloseHandle (journalFileHandle);
            journalFileHandle = NULL;
        }
    }
    return result;
}

BOOL
IsmReplacePhysicalObject (
    IN    MIG_OBJECTTYPEID ObjectTypeId,
    IN    MIG_OBJECTSTRINGHANDLE ObjectName,
    IN    PMIG_CONTENT ObjectContent
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo) {
        if (typeInfo->ReplacePhysicalObject) {
            // Type supports Replace
            result = typeInfo->ReplacePhysicalObject (ObjectName, ObjectContent);
        } else {
            // Type does not support Replace, so we need to emulate it
            if (typeInfo->DoesPhysicalObjectExist (ObjectName)) {
                result = typeInfo->RemovePhysicalObject (ObjectName);
            } else {
                result = TRUE;
            }
            if (result) {
                result = typeInfo->CreatePhysicalObject (ObjectName, ObjectContent);
            }
        }
    }
    return result;
}

BOOL
IsmRemovePhysicalObject (
    IN    MIG_OBJECTTYPEID ObjectTypeId,
    IN    MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTYPEINFO typeInfo;
    BOOL result = FALSE;

    typeInfo = GetTypeInfo (ObjectTypeId);
    if (typeInfo && typeInfo->RemovePhysicalObject) {
        if (typeInfo->DoesPhysicalObjectExist (ObjectName)) {
            result = typeInfo->RemovePhysicalObject (ObjectName);
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\users.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    users.c

Abstract:

    Creates user profiles and enumerates users

Author:

    Jim Schmidt (jimschm) 15-May-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_ISMUSERS            "IsmUsers"

//
// Strings
//

#define S_TEMP_HKCU             TEXT("$HKCU$")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef BOOL (WINAPI GETDEFAULTUSERPROFILEDIRECTORY)(PTSTR ProfileDir, PDWORD Size);
typedef GETDEFAULTUSERPROFILEDIRECTORY * PGETDEFAULTUSERPROFILEDIRECTORY;

typedef BOOL (WINAPI GETPROFILESDIRECTORY)(PTSTR ProfileDir, PDWORD Size);
typedef GETPROFILESDIRECTORY * PGETPROFILESDIRECTORY;

typedef LONG (WINAPI REGOVERRIDEPREDEFKEY)(HKEY hKey, HKEY hNewHKey);
typedef REGOVERRIDEPREDEFKEY * PREGOVERRIDEPREDEFKEY;

typedef BOOL (WINAPI CONVERTSIDTOSTRINGSID)(PSID Sid, PTSTR *SidString);
typedef CONVERTSIDTOSTRINGSID * PCONVERTSIDTOSTRINGSID;

typedef BOOL (WINAPI CREATEUSERPROFILE)(
                        PSID Sid,
                        PCTSTR UserName,
                        PCTSTR UserHive,
                        PTSTR ProfileDir,
                        DWORD DirSize,
                        BOOL IsWin9xUpgrade
                        );
typedef CREATEUSERPROFILE * PCREATEUSERPROFILE;

typedef BOOL (WINAPI OLDCREATEUSERPROFILE)(
                        PSID Sid,
                        PCTSTR UserName,
                        PCTSTR UserHive,
                        PTSTR ProfileDir,
                        DWORD DirSize
                        );
typedef OLDCREATEUSERPROFILE * POLDCREATEUSERPROFILE;

typedef BOOL (WINAPI GETUSERPROFILEDIRECTORY)(HANDLE hToken, PTSTR lpProfileDir, PDWORD lpcchSize);
typedef GETUSERPROFILEDIRECTORY * PGETUSERPROFILEDIRECTORY;

typedef BOOL (WINAPI DELETEPROFILE)(PCTSTR lpSidString, PCTSTR lpProfilePath, PCTSTR lpComputerName);
typedef DELETEPROFILE * PDELETEPROFILE;

//
// Globals
//

PTEMPORARYPROFILE g_CurrentOverrideUser;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//


HANDLE
pGetUserEnvLib (
    VOID
    )
{
    static HANDLE lib;

    if (lib) {
        return lib;
    }

    lib = LoadLibrary (TEXT("userenv.dll"));
    if (!lib) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_LOAD_USERENV));
    }

    return lib;
}


HANDLE
pGetAdvApi32Lib (
    VOID
    )
{
    static HANDLE lib;

    if (lib) {
        return lib;
    }

    lib = LoadLibrary (TEXT("advapi32.dll"));
    if (!lib) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_LOAD_ADVAPI32));
    }

    return lib;
}


BOOL
pOurGetDefaultUserProfileDirectory (
    OUT     PTSTR ProfileDir,
    IN OUT  PDWORD Size
    )
{
    HANDLE lib;
    PGETDEFAULTUSERPROFILEDIRECTORY getDefaultUserProfileDirectory;

    lib = pGetUserEnvLib();
    if (!lib) {
        return FALSE;
    }

#ifdef UNICODE
    getDefaultUserProfileDirectory = (PGETDEFAULTUSERPROFILEDIRECTORY) GetProcAddress (lib, "GetDefaultUserProfileDirectoryW");
#else
    getDefaultUserProfileDirectory = (PGETDEFAULTUSERPROFILEDIRECTORY) GetProcAddress (lib, "GetDefaultUserProfileDirectoryA");
#endif

    if (!getDefaultUserProfileDirectory) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_GETDEFAULTUSERPROFILEDIRECTORY));
        return FALSE;
    }

    return getDefaultUserProfileDirectory (ProfileDir, Size);
}


BOOL
pOurGetProfilesDirectory (
    OUT     PTSTR ProfileDir,
    IN OUT  PDWORD Size
    )
{
    HANDLE lib;
    PGETPROFILESDIRECTORY getProfilesDirectory;

    lib = pGetUserEnvLib();
    if (!lib) {
        return FALSE;
    }

#ifdef UNICODE
    getProfilesDirectory = (PGETPROFILESDIRECTORY) GetProcAddress (lib, "GetProfilesDirectoryW");
#else
    getProfilesDirectory = (PGETPROFILESDIRECTORY) GetProcAddress (lib, "GetProfilesDirectoryA");
#endif

    if (!getProfilesDirectory) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_GETPROFILESDIRECTORY));
        return FALSE;
    }

    return getProfilesDirectory (ProfileDir, Size);
}


LONG
pOurConvertSidToStringSid (
    IN      PSID Sid,
    IN      PTSTR *SidString
    )
{
    HANDLE lib;
    PCONVERTSIDTOSTRINGSID convertSidToStringSid;
    BOOL result = FALSE;
    DWORD error;

    lib = pGetAdvApi32Lib();
    if (!lib) {
        error = GetLastError();
        if (error == ERROR_SUCCESS) {
            SetLastError (ERROR_PROC_NOT_FOUND);
        }
    } else {
#ifdef UNICODE
        convertSidToStringSid = (PCONVERTSIDTOSTRINGSID) GetProcAddress(lib, "ConvertSidToStringSidW");
#else
        convertSidToStringSid = (PCONVERTSIDTOSTRINGSID) GetProcAddress(lib, "ConvertSidToStringSidA");
#endif
        if (convertSidToStringSid) {
            result = convertSidToStringSid (Sid, SidString);
        }
    }

    return result;
}


BOOL
pOurGetUserProfileDirectory (
    IN      HANDLE Token,
    IN      PTSTR ProfileDir,
    IN      PDWORD ProfileDirSize
    )
{
    HANDLE lib;
    PGETUSERPROFILEDIRECTORY getUserProfileDirectory;
    BOOL result = FALSE;
    DWORD error;

    lib = pGetUserEnvLib();
    if (!lib) {
        error = GetLastError();
        if (error == ERROR_SUCCESS) {
            SetLastError (ERROR_PROC_NOT_FOUND);
        }
    } else {
#ifdef UNICODE
        getUserProfileDirectory = (PGETUSERPROFILEDIRECTORY) GetProcAddress (lib, "GetUserProfileDirectoryW");
#else
        getUserProfileDirectory = (PGETUSERPROFILEDIRECTORY) GetProcAddress (lib, "GetUserProfileDirectoryA");
#endif
        if (getUserProfileDirectory) {
            result = getUserProfileDirectory (Token, ProfileDir, ProfileDirSize);
        }
    }

    return result;
}


BOOL
pOurDeleteProfile (
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath,
    IN      PCTSTR ComputerName
    )
{
    HANDLE lib;
    PDELETEPROFILE deleteProfile;
    BOOL result = FALSE;
    DWORD error;

    lib = pGetUserEnvLib();
    if (!lib) {
        error = GetLastError();
        if (error == ERROR_SUCCESS) {
            SetLastError (ERROR_PROC_NOT_FOUND);
        }
    } else {
#ifdef UNICODE
        deleteProfile = (PDELETEPROFILE) GetProcAddress (lib, "DeleteProfileW");
#else
        deleteProfile = (PDELETEPROFILE) GetProcAddress (lib, "DeleteProfileA");
#endif
        if (deleteProfile) {
            result = deleteProfile (UserStringSid, UserProfilePath, ComputerName);
        }
    }

    return result;
}


LONG
pOurRegOverridePredefKey (
    IN      HKEY hKey,
    IN      HKEY hNewHKey
    )
{
    HANDLE lib;
    PREGOVERRIDEPREDEFKEY regOverridePredefKey;
    LONG result;

    lib = pGetAdvApi32Lib();
    if (!lib) {
        result = GetLastError();
        if (result == ERROR_SUCCESS) {
            result = ERROR_PROC_NOT_FOUND;
        }
    } else {
        regOverridePredefKey = (PREGOVERRIDEPREDEFKEY) GetProcAddress (lib, "RegOverridePredefKey");
        if (!regOverridePredefKey) {
            result = GetLastError();
        } else {
            result = regOverridePredefKey (hKey, hNewHKey);
        }
    }

    return result;
}


BOOL
pOurCreateUserProfile (
    IN      PSID Sid,
    IN      PCTSTR UserName,
    IN      PCTSTR UserHive,
    OUT     PTSTR ProfileDir,
    IN      DWORD DirSize
    )
{
    HANDLE lib;
    PCREATEUSERPROFILE createUserProfile;
    POLDCREATEUSERPROFILE oldCreateUserProfile;
    MIG_OSVERSIONINFO versionInfo;
    BOOL useNew = FALSE;

    lib = pGetUserEnvLib();
    if (!lib) {
        return FALSE;
    }

    if (IsmGetOsVersionInfo (g_IsmCurrentPlatform, &versionInfo)) {
        if ((versionInfo.OsMajorVersion > OSMAJOR_WINNT5) ||
            (versionInfo.OsMajorVersion == OSMAJOR_WINNT5 &&
             ((versionInfo.OsMinorVersion > OSMINOR_WINNT51) ||
              ((versionInfo.OsMinorVersion == OSMINOR_WINNT51) &&
               (versionInfo.OsBuildNumber >= 2464))))) {
            useNew = TRUE;
        }
    }

    if (useNew) {
#ifdef UNICODE
        createUserProfile = (PCREATEUSERPROFILE) GetProcAddress (lib, (PCSTR) 154);
#else
        createUserProfile = (PCREATEUSERPROFILE) GetProcAddress (lib, (PCSTR) 153);
#endif

        if (!createUserProfile) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_CREATEUSERPROFILE));
            return FALSE;
        }

        return createUserProfile (
                    Sid,
                    UserName,
                    UserHive,
                    ProfileDir,
                    DirSize,
                    FALSE
                    );
    } else {
#ifdef UNICODE
        oldCreateUserProfile = (POLDCREATEUSERPROFILE) GetProcAddress (lib, (PCSTR) 110);
#else
        oldCreateUserProfile = (POLDCREATEUSERPROFILE) GetProcAddress (lib, (PCSTR) 109);
#endif

        if (!oldCreateUserProfile) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_CREATEUSERPROFILE));
            return FALSE;
        }

        return oldCreateUserProfile (
                    Sid,
                    UserName,
                    UserHive,
                    ProfileDir,
                    DirSize
                    );
    }
}


BOOL
pCloneDefaultUserProfile (
    IN      PSID Sid,
    IN      PCTSTR UserName,
    OUT     PTSTR OutUserProfileRoot
    )
{
    TCHAR userProfile[MAX_TCHAR_PATH];
    BOOL result = FALSE;

    __try {

        if (!pOurCreateUserProfile (
                Sid,
                UserName,
                NULL,
                userProfile,
                ARRAYSIZE(userProfile)
                )) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_CREATE_PROFILE, UserName));
            __leave;
        }

        MYASSERT (OutUserProfileRoot);
        StringCopy (OutUserProfileRoot, userProfile);

        result = TRUE;
    }
    __finally {
        if (result) {
            LOG ((LOG_INFORMATION, (PCSTR) MSG_PROFILE_INFO, UserName, OutUserProfileRoot));
        }
    }

    return result;
}


PTEMPORARYPROFILE
OpenTemporaryProfile (
    IN      PCTSTR UserName,
    IN      PCTSTR Domain
    )
{
    DWORD sidSize;
    DWORD domainSize;
    SID_NAME_USE use;
    PTSTR domainBuffer = NULL;
    PSID sidBuffer = NULL;
    PTSTR sidString = NULL;
    PTEMPORARYPROFILE result = NULL;
    PCTSTR accountName = NULL;
    TCHAR userProfileRoot[MAX_TCHAR_PATH];
    PCTSTR hiveFile = NULL;
    LONG rc;
    HKEY key = NULL;
    PMHANDLE allocPool;
    BOOL b;

    __try {
        //
        // Generate the account name
        //

        if (!UserName || !Domain || (UserName [0] == 0)) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_ACCOUNT_INVALID_PARAMETERS));
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        accountName = JoinPaths (Domain, UserName);

        //
        // Obtain the buffer sizes needed to obtain the user's SID
        //

        sidSize = 0;
        domainSize = 0;

        b = LookupAccountName (
                NULL,
                accountName,
                NULL,
                &sidSize,
                NULL,
                &domainSize,
                &use
                );

        if (!b && GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_ACCOUNT, accountName));
            __leave;
        }

        //
        // Allocate the buffers
        //

        domainBuffer = AllocText (domainSize);
        sidBuffer = MemAllocUninit (sidSize);

        if (!domainBuffer || !sidBuffer) {
            __leave;
        }

        //
        // Get the SID
        //

        b = LookupAccountName (
                NULL,
                accountName,
                sidBuffer,
                &sidSize,
                domainBuffer,
                &domainSize,
                &use
                );

        if (!b) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_FIND_ACCOUNT_SID, accountName));
            __leave;
        }

        if (use != SidTypeUser) {
            SetLastError (ERROR_INVALID_ACCOUNT_NAME);
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_NOT_USER_ACCOUNT, accountName));
            __leave;
        }

        //
        // Copy the default profile
        //

        b = pCloneDefaultUserProfile (sidBuffer, UserName, userProfileRoot);

        if (!b) {
            __leave;
        }

        //
        // convert SID into a string SID
        //
        if (!pOurConvertSidToStringSid (sidBuffer, &sidString) || !sidString) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CONVERT_SID_FAILURE));
            __leave;
        }

        //
        // Load the user's hive
        //

        RegUnLoadKey (HKEY_USERS, sidString);

        hiveFile = JoinPaths (userProfileRoot, TEXT("ntuser.dat"));
        rc = RegLoadKey (HKEY_USERS, sidString, hiveFile);

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_LOAD_HIVE, hiveFile));
            __leave;
        }

        //
        // Make the hive the new HKCU
        //

        key = OpenRegKey (HKEY_USERS, sidString);
        if (!key) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_MAP_HIVE, hiveFile));
            __leave;
        }

        if (g_CurrentOverrideUser) {
            pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
            g_CurrentOverrideUser = NULL;
        }

        rc = pOurRegOverridePredefKey (HKEY_CURRENT_USER, key);

        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_REDIRECT_HIVE, hiveFile));
            __leave;
        }

        //
        // Prepare outbound handle
        //

        allocPool = PmCreateNamedPool ("TempProfile");
        if (!allocPool) {
            __leave;
        }

        result = (PTEMPORARYPROFILE) PmGetMemory (allocPool, sizeof (TEMPORARYPROFILE));
        if (!result) {
            __leave;
        }

        g_CurrentOverrideUser = result;

        result->AllocPool = allocPool;
        result->UserName = PmDuplicateString (allocPool, UserName);
        result->DomainName = PmDuplicateString (allocPool, Domain);
        result->AccountName = PmDuplicateString (allocPool, accountName);
        result->UserProfileRoot = PmDuplicateString (allocPool, userProfileRoot);
        result->MapKey = PmDuplicateString (allocPool, sidString);
        result->UserStringSid = PmDuplicateString (allocPool, sidString);
        result->UserHive = PmDuplicateString (allocPool, hiveFile);
        result->UserSid = (PSID) PmDuplicateMemory (
                                        allocPool,
                                        sidBuffer,
                                        GetLengthSid (sidBuffer)
                                        );

        // Everything went just fine. Last thing, let's write the mapped location of
        // the user hive in the environment
        IsmSetEnvironmentString (PLATFORM_DESTINATION, NULL, S_VER_HIVEMAPPEDLOCATION, sidString);
    }
    __finally {

        FreePathString (hiveFile);
        FreePathString (accountName);
        FreeText (domainBuffer);

        if (sidBuffer) {
            FreeAlloc (sidBuffer);
            INVALID_POINTER (sidBuffer);
        }

        if (key) {
            CloseRegKey (key);
        }

        if (!result) {
            if (sidString) {
                RegTerminateCache ();
                RegUnLoadKey (HKEY_USERS, sidString);
            }

            pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
        }

        if (sidString) {
            LocalFree (sidString);
        }
    }

    return result;
}


BOOL
SelectTemporaryProfile (
    IN      PTEMPORARYPROFILE Profile
    )
{
    LONG rc;
    HKEY key;

    if (g_CurrentOverrideUser == Profile) {
        return TRUE;
    }

    key = OpenRegKey (HKEY_LOCAL_MACHINE, Profile->MapKey);
    if (!key) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_OPEN_USER_REGISTRY, Profile->UserName));
        return FALSE;
    }

    if (g_CurrentOverrideUser) {
        pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
        g_CurrentOverrideUser = NULL;
    }

    rc = pOurRegOverridePredefKey (HKEY_CURRENT_USER, key);

    CloseRegKey (key);

    if (rc == ERROR_SUCCESS) {
        g_CurrentOverrideUser = Profile;
        return TRUE;
    }

    return FALSE;
}


BOOL
CloseTemporaryProfile (
    IN      PTEMPORARYPROFILE Profile,
    IN      BOOL MakeProfilePermanent
    )
{
    BOOL result = TRUE;
    LONG rc;
    DWORD error;
    MIG_OSVERSIONINFO osVersionInfo;

    if (g_CurrentOverrideUser == Profile) {
        pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
        g_CurrentOverrideUser = NULL;
    }

    RegTerminateCache ();
    rc = RegUnLoadKey (HKEY_USERS, Profile->MapKey);

    DEBUGMSG_IF ((
        rc != ERROR_SUCCESS,
        DBG_WHOOPS,
        "Can't unload mapped hive: rc=%u; check for registry handle leaks",
        rc
        ));

    if (MakeProfilePermanent) {

        if (!pOurCreateUserProfile (
                Profile->UserSid,
                Profile->UserName,
                Profile->UserHive,
                NULL,
                0
                )) {
            // on Win2k it is known that this will fail with error ERROR_SHARING_VIOLATION
            // but the hive will actually be OK. So, if this is Win2k
            // and the error is ERROR_SHARING_VIOLATION we'll just consider a success.
            result = FALSE;
            error = GetLastError ();
            if (IsmGetOsVersionInfo (PLATFORM_DESTINATION, &osVersionInfo)) {
                if ((osVersionInfo.OsType == OSTYPE_WINDOWSNT) &&
                    (osVersionInfo.OsMajorVersion == OSMAJOR_WINNT5) &&
                    (osVersionInfo.OsMinorVersion == OSMINOR_GOLD) &&
                    (error == ERROR_SHARING_VIOLATION)
                    ) {
                    result = TRUE;
                }
            }
            if (!result) {
                SetLastError (error);
            }
        }
    }

    if (result) {
        PmDestroyPool (Profile->AllocPool);
        INVALID_POINTER (Profile);
    }

    return result;
}

BOOL
MapUserProfile (
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath
    )
{
    PCTSTR hiveFile = NULL;
    LONG rc;
    HKEY key;

    //
    // Unload UserStringSid if loaded
    //
    RegUnLoadKey (HKEY_USERS, UserStringSid);

    hiveFile = JoinPaths (UserProfilePath, TEXT("ntuser.dat"));
    rc = RegLoadKey (HKEY_USERS, UserStringSid, hiveFile);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_LOAD_HIVE, hiveFile));
        FreePathString (hiveFile);
        return FALSE;
    }

    //
    // Make the hive the new HKCU
    //

    key = OpenRegKey (HKEY_USERS, UserStringSid);
    if (!key) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_MAP_HIVE, hiveFile));
        RegUnLoadKey (HKEY_USERS, UserStringSid);
        FreePathString (hiveFile);
        return FALSE;
    }

    rc = pOurRegOverridePredefKey (HKEY_CURRENT_USER, key);

    if (rc != ERROR_SUCCESS) {
        LOG ((LOG_MODULE_ERROR, (PCSTR) MSG_CANT_REDIRECT_HIVE, hiveFile));
        CloseRegKey (key);
        RegTerminateCache ();
        RegUnLoadKey (HKEY_USERS, UserStringSid);
        FreePathString (hiveFile);
        return FALSE;
    }

    CloseRegKey (key);
    FreePathString (hiveFile);

    return TRUE;
}

BOOL
UnmapUserProfile (
    IN      PCTSTR UserStringSid
    )
{
    LONG rc;

    pOurRegOverridePredefKey (HKEY_CURRENT_USER, NULL);
    RegTerminateCache ();

    rc = RegUnLoadKey (HKEY_USERS, UserStringSid);
    DEBUGMSG_IF ((
        rc != ERROR_SUCCESS,
        DBG_WHOOPS,
        "Can't unmap user profile: rc=%u; check for registry handle leaks",
        rc
        ));

    return TRUE;
}

BOOL
DeleteUserProfile (
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath
    )
{
    RegTerminateCache ();
    RegUnLoadKey (HKEY_USERS, UserStringSid);
    return pOurDeleteProfile (UserStringSid, UserProfilePath, NULL);
}

PCURRENT_USER_DATA
GetCurrentUserData (
    VOID
    )
{
    PCURRENT_USER_DATA result = NULL;
    HANDLE token;
    DWORD bytesRequired;
    PTOKEN_USER tokenUser;
    PMHANDLE allocPool;
    PTSTR sidString = NULL;
    TCHAR userName[256];
    DWORD nameSize;
    TCHAR userDomain[256];
    DWORD domainSize;
    SID_NAME_USE dontCare;

    //
    // Open the process token.
    //
    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
        return FALSE;
    }

    bytesRequired = 0;
    if (GetTokenInformation (token, TokenUser, NULL, 0, &bytesRequired)) {
        return FALSE;
    }

    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    tokenUser = (PTOKEN_USER) MemAllocUninit (bytesRequired);

    if (!GetTokenInformation (token, TokenUser, tokenUser, bytesRequired, &bytesRequired)) {
        FreeAlloc (tokenUser);
        return FALSE;
    }

    nameSize = ARRAYSIZE (userName);
    domainSize = ARRAYSIZE (userDomain);

    ZeroMemory (userName, nameSize);
    ZeroMemory (userDomain, domainSize);

    LookupAccountSid (
        NULL,
        tokenUser->User.Sid,
        userName,
        &nameSize,
        userDomain,
        &domainSize,
        &dontCare
        );

    allocPool = PmCreateNamedPool ("CurrentUser");
    if (!allocPool) {
        FreeAlloc (tokenUser);
        return FALSE;
    }

    PmDisableTracking (allocPool);

    result = (PCURRENT_USER_DATA) PmGetMemory (allocPool, sizeof (CURRENT_USER_DATA));
    if (!result) {
        FreeAlloc (tokenUser);
        return FALSE;
    }

    result->AllocPool = allocPool;

    result->UserName = PmDuplicateString (result->AllocPool, userName);

    result->UserDomain = PmDuplicateString (result->AllocPool, userDomain);

    if (!pOurConvertSidToStringSid (tokenUser->User.Sid, &sidString) || !sidString) {
        PmDestroyPool (allocPool);
        FreeAlloc (tokenUser);
        return FALSE;
    }

    result->UserStringSid = PmDuplicateString (allocPool, sidString);

    LocalFree (sidString);

    FreeAlloc (tokenUser);

    // now just get the current user profile path

    bytesRequired = MAX_TCHAR_PATH;
    result->UserProfilePath = PmGetMemory (allocPool, bytesRequired);

    if (!pOurGetUserProfileDirectory (token, (PTSTR)result->UserProfilePath, &bytesRequired)) {
        result->UserProfilePath = PmGetMemory (allocPool, bytesRequired);
        if (!pOurGetUserProfileDirectory (token, (PTSTR)result->UserProfilePath, &bytesRequired)) {
            PmDestroyPool (allocPool);
            return FALSE;
        }
    }

    return result;
}

VOID
FreeCurrentUserData (
    IN      PCURRENT_USER_DATA CurrentUserData
    )
{
    PmDestroyPool (CurrentUserData->AllocPool);
}

PCTSTR
IsmGetCurrentSidString (
    VOID
    )
{
    if (!g_CurrentOverrideUser) {
        return NULL;
    } else {
        return PmDuplicateString (g_IsmPool, g_CurrentOverrideUser->UserStringSid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\inc\baseinc.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    baseinc.h

Abstract:

    Includes SDK headers needed for the project, and allutils.h.

Author:

    Marc R. Whitten (marcw) 02-Sep-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// basetypes.h creates better types for managing DBCS and UNICODE
// with the C runtime, and defines other types that should be defined
// by the Win32 headers but aren't.
//

#include "basetypes.h"

//
// COBJMACROS turns on the C-style macros for COM.  We don't use C++!
//

#define COBJMACROS

//
// Windows
//

#pragma warning(push)

#include <windows.h>
#include <winnt.h>
#include <winerror.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>
#include <spapip.h>
//
// PORTBUG -- I had to uncomment shlobj.h just to get the #define DOUBLE working...
//
#include <shlobj.h>
//#include <objidl.h>
//#include <mmsystem.h>
//

#define STRSAFE_NO_DEPRECATE
#define STRSAFE_LIB
#include <strsafe.h>

#pragma warning(pop)

//
// Private utilities
//

#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\inc\basetypes.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    chartype.h

Abstract:

    Declares macros and types for the multi-byte and Unicode
    character environment that the Win9x upgrade code requires.
    The following macros are defined:

    - Make sure UNICODE is defined if _UNICODE is defined
    - Make the type MBCHAR that holds both bytes of a multi-byte char
    - Make CHARTYPE point to wint_t for UNICODE and MBCHAR for not
      UNICODE
    - Define non-standard types PCTCHAR and PTCHAR for spapip.h

Author:

    Jim Schmidt (jimschm) 10-Oct-1996

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#ifdef NEED_EXPORTS
#define EXPORT  __declspec(dllexport)
#else
#define EXPORT
#endif

#ifndef PCUINT
typedef const unsigned int  *PCUINT;
#endif

#ifndef PCUINT64
typedef const unsigned _int64  *PCUINT64;
#endif

#ifdef _WIN64

#define BINT    INT64
#define UBINT   UINT64
#define PBINT   PINT64
#define PUBINT  PUINT64
#define PCUBINT PCUINT64

#else

#define BINT    INT
#define UBINT   UINT
#define PBINT   PINT
#define PUBINT  PUINT
#define PCUBINT PCUINT

#endif

#if defined _UNICODE && !defined UNICODE
#define UNICODE
#endif

#ifdef UNICODE

//
// If UNICODE, define _UNICODE for tchar.h, and make
// a type to represent a single character.
//

#ifndef _UNICODE
#define _UNICODE
#endif

#define CHARTYPE wint_t

#pragma message ("UNICODE version being built")

#else       // ifdef UNICODE

//
// If not UNICODE, we must assume multibyte characters.
// Define _MBCS for tchar.h, and make a type that can
// hold a complete multibyte character.
//

#ifndef _MBCS
#define _MBCS
#endif
#define CHARTYPE unsigned int

#pragma message ("MBCS version being built")

#endif      // ifdef UNICODE, else

#define MBCHAR unsigned int

#include <tchar.h>

//
// Constant pointer to a void
//

#ifndef PCVOID
typedef const void * PCVOID;
#endif

//
// Pointer to a constant byte sequence
//

#ifndef PCBYTE
typedef const unsigned char * PCBYTE;
#endif

//
// use the result of sizeof operator as a DWORD
//
#define DWSIZEOF(x) ((DWORD)sizeof(x))



// PORTBUG!!  We want to eliminate setupapi.h
//
// Types for Setup API
//

#ifndef PCTCHAR
#define PCTCHAR const TCHAR *
#endif

#ifndef PTCHAR
#define PTCHAR TCHAR *
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\inc\ismproc.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ismproc.h

Abstract:

    Callback function prototype definitions for the Intermediate State Manager.

Author:

    Jim Schmidt (jimschm) 15-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Types
//

//
// misc types
//

#define ISM_VERSION         0x10000

typedef VOID (WINAPI MIG_LOGCALLBACK)(PVOID Arg);
typedef MIG_LOGCALLBACK * PMIG_LOGCALLBACK;

typedef VOID(PROGRESSBARFN)(
                MIG_PROGRESSPHASE Phase,
                MIG_PROGRESSSTATE State,
                UINT WorkDone,
                UINT TotalWork,
                ULONG_PTR Arg
                );

typedef PROGRESSBARFN * PPROGRESSBARFN;

//
// transport
//

typedef BOOL(WINAPI TRANSPORTINITIALIZE)(PMIG_LOGCALLBACK LogCallback);
typedef TRANSPORTINITIALIZE *PTRANSPORTINITIALIZE;

typedef VOID(WINAPI TRANSPORTESTIMATEPROGRESSBAR)(MIG_PLATFORMTYPEID PlatformTypeId);
typedef TRANSPORTESTIMATEPROGRESSBAR *PTRANSPORTESTIMATEPROGRESSBAR;

typedef BOOL(WINAPI TRANSPORTQUERYCAPABILITIES)(
                        IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
                        OUT     PMIG_TRANSPORTTYPE TransportType,
                        OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
                        OUT     PCTSTR *FriendlyDescription
                        );
typedef TRANSPORTQUERYCAPABILITIES *PTRANSPORTQUERYCAPABILITIES;

typedef BOOL(WINAPI TRANSPORTSETSTORAGE)(
                        IN      MIG_PLATFORMTYPEID Platform,
                        IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
                        IN      MIG_TRANSPORTCAPABILITIES Capabilities,
                        IN      PCTSTR StoragePath,
                        OUT     PBOOL Valid,
                        OUT     PBOOL ImageExists
                        );
typedef TRANSPORTSETSTORAGE *PTRANSPORTSETSTORAGE;

typedef VOID(WINAPI TRANSPORTRESETSTORAGE)(MIG_TRANSPORTSTORAGEID TransportStorageId);
typedef TRANSPORTRESETSTORAGE *PTRANSPORTRESETSTORAGE;

typedef VOID(WINAPI TRANSPORTTERMINATE)(VOID);
typedef TRANSPORTTERMINATE *PTRANSPORTTERMINATE;

typedef BOOL(WINAPI TRANSPORTSAVESTATE)(VOID);
typedef TRANSPORTSAVESTATE *PTRANSPORTSAVESTATE;

typedef BOOL(WINAPI TRANSPORTRESUMESAVESTATE)(VOID);
typedef TRANSPORTRESUMESAVESTATE *PTRANSPORTRESUMESAVESTATE;

typedef BOOL(WINAPI TRANSPORTBEGINAPPLY)(VOID);
typedef TRANSPORTBEGINAPPLY *PTRANSPORTBEGINAPPLY;

typedef BOOL(WINAPI TRANSPORTRESUMEAPPLY)(VOID);
typedef TRANSPORTRESUMEAPPLY *PTRANSPORTRESUMEAPPLY;

typedef BOOL(WINAPI TRANSPORTACQUIREOBJECT)(
                            IN      MIG_OBJECTTYPEID ObjectTypeId,
                            IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                            IN OUT  PMIG_CONTENT ObjectContent,
                            IN      MIG_CONTENTTYPE ContentType,
                            IN      UINT MemoryContentLimit
                            );
typedef TRANSPORTACQUIREOBJECT *PTRANSPORTACQUIREOBJECT;

typedef BOOL(WINAPI TRANSPORTRELEASEOBJECT)(PMIG_CONTENT ObjectContent);
typedef TRANSPORTRELEASEOBJECT *PTRANSPORTRELEASEOBJECT;

typedef VOID(WINAPI TRANSPORTENDAPPLY)(VOID);
typedef TRANSPORTENDAPPLY *PTRANSPORTENDAPPLY;

typedef struct {
    UINT Version;
    PTRANSPORTINITIALIZE TransportInitialize;
    PTRANSPORTESTIMATEPROGRESSBAR TransportEstimateProgressBar;
    PTRANSPORTQUERYCAPABILITIES TransportQueryCapabilities;
    PTRANSPORTSETSTORAGE TransportSetStorage;
    PTRANSPORTRESETSTORAGE TransportResetStorage;
    PTRANSPORTTERMINATE TransportTerminate;
    PTRANSPORTSAVESTATE TransportSaveState;
    PTRANSPORTRESUMESAVESTATE TransportResumeSaveState;
    PTRANSPORTBEGINAPPLY TransportBeginApply;
    PTRANSPORTRESUMEAPPLY TransportResumeApply;
    PTRANSPORTACQUIREOBJECT TransportAcquireObject;
    PTRANSPORTRELEASEOBJECT TransportReleaseObject;
    PTRANSPORTENDAPPLY TransportEndApply;
} TRANSPORT_ENTRYPOINTS, *PTRANSPORT_ENTRYPOINTS;

//
// operations
//

typedef BOOL (WINAPI OPMFILTERCALLBACK)(
                        PCMIG_FILTERINPUT InputData,
                        PMIG_FILTEROUTPUT OutputData,
                        BOOL NoRestoreObject,
                        PCMIG_BLOB SourceOperationData,             OPTIONAL
                        PCMIG_BLOB DestinationOperationData         OPTIONAL
                        );
typedef OPMFILTERCALLBACK *POPMFILTERCALLBACK;

typedef BOOL (WINAPI OPMAPPLYCALLBACK)(
                        MIG_OBJECTTYPEID SrcObjectTypeId,
                        MIG_OBJECTSTRINGHANDLE SrcObjectName,
                        PCMIG_CONTENT OriginalContent,
                        PCMIG_CONTENT CurrentContent,
                        PMIG_CONTENT NewContent,
                        PCMIG_BLOB SourceOperationData,             OPTIONAL
                        PCMIG_BLOB DestinationOperationData         OPTIONAL
                        );
typedef OPMAPPLYCALLBACK *POPMAPPLYCALLBACK;

//
// message passing
//

typedef ULONG_PTR(CALLBACK MESSAGECALLBACK)(UINT Message, ULONG_PTR Arg);
typedef MESSAGECALLBACK *PMESSAGECALLBACK;

//
// ETM entry points
//

typedef BOOL(WINAPI TYPE_ENUMFIRSTPHYSICALOBJECT)(
                IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,
                IN      MIG_OBJECTSTRINGHANDLE Pattern,
                IN      UINT MaxLevel
                );
typedef TYPE_ENUMFIRSTPHYSICALOBJECT *PTYPE_ENUMFIRSTPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_ENUMNEXTPHYSICALOBJECT)(
                IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
                );
typedef TYPE_ENUMNEXTPHYSICALOBJECT *PTYPE_ENUMNEXTPHYSICALOBJECT;

typedef VOID(WINAPI TYPE_ABORTENUMCURRENTPHYSICALNODE)(
                IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
                );
typedef TYPE_ABORTENUMCURRENTPHYSICALNODE *PTYPE_ABORTENUMCURRENTPHYSICALNODE;

typedef VOID(WINAPI TYPE_ABORTENUMPHYSICALOBJECT)(
                IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
                );
typedef TYPE_ABORTENUMPHYSICALOBJECT *PTYPE_ABORTENUMPHYSICALOBJECT;

typedef PCTSTR(WINAPI TYPE_CONVERTOBJECTTOMULTISZ)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_CONVERTOBJECTTOMULTISZ *PTYPE_CONVERTOBJECTTOMULTISZ;

typedef BOOL(WINAPI TYPE_CONVERTMULTISZTOOBJECT)(
                IN      PCTSTR ObjectMultiSz,
                OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
                OUT     PMIG_CONTENT ObjectContent          OPTIONAL
                );
typedef TYPE_CONVERTMULTISZTOOBJECT *PTYPE_CONVERTMULTISZTOOBJECT;

typedef PCTSTR(WINAPI TYPE_GETNATIVEOBJECTNAME)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName
                );
typedef TYPE_GETNATIVEOBJECTNAME *PTYPE_GETNATIVEOBJECTNAME;

typedef BOOL(WINAPI TYPE_ACQUIREPHYSICALOBJECT)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                OUT     PMIG_CONTENT ObjectContent,
                IN      MIG_CONTENTTYPE ContentType,
                IN      UINT MemoryContentLimit
                );
typedef TYPE_ACQUIREPHYSICALOBJECT *PTYPE_ACQUIREPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_RELEASEPHYSICALOBJECT)(
                IN OUT  PMIG_CONTENT ObjectContent
                );
typedef TYPE_RELEASEPHYSICALOBJECT *PTYPE_RELEASEPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_DOESPHYSICALOBJECTEXIST)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName
                );
typedef TYPE_DOESPHYSICALOBJECTEXIST *PTYPE_DOESPHYSICALOBJECTEXIST;

typedef BOOL(WINAPI TYPE_REMOVEPHYSICALOBJECT)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName
                );
typedef TYPE_REMOVEPHYSICALOBJECT *PTYPE_REMOVEPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_CREATEPHYSICALOBJECT)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_CREATEPHYSICALOBJECT *PTYPE_CREATEPHYSICALOBJECT;

typedef BOOL(WINAPI TYPE_REPLACEPHYSICALOBJECT)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_REPLACEPHYSICALOBJECT *PTYPE_REPLACEPHYSICALOBJECT;

typedef PMIG_CONTENT(WINAPI TYPE_CONVERTOBJECTCONTENTTOUNICODE)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_CONVERTOBJECTCONTENTTOUNICODE *PTYPE_CONVERTOBJECTCONTENTTOUNICODE;

typedef PMIG_CONTENT(WINAPI TYPE_CONVERTOBJECTCONTENTTOANSI)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_CONVERTOBJECTCONTENTTOANSI *PTYPE_CONVERTOBJECTCONTENTTOANSI;

typedef BOOL(WINAPI TYPE_FREECONVERTEDOBJECTCONTENT)(
                IN      PMIG_CONTENT ObjectContent
                );
typedef TYPE_FREECONVERTEDOBJECTCONTENT *PTYPE_FREECONVERTEDOBJECTCONTENT;

typedef struct {
    UINT Priority;
    PTYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPhysicalObject;
    PTYPE_ENUMNEXTPHYSICALOBJECT EnumNextPhysicalObject;
    PTYPE_ABORTENUMCURRENTPHYSICALNODE AbortEnumCurrentPhysicalNode;
    PTYPE_ABORTENUMPHYSICALOBJECT AbortEnumPhysicalObject;
    PTYPE_CONVERTOBJECTTOMULTISZ ConvertObjectToMultiSz;
    PTYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToObject;
    PTYPE_GETNATIVEOBJECTNAME GetNativeObjectName;
    PTYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalObject;
    PTYPE_RELEASEPHYSICALOBJECT ReleasePhysicalObject;
    PTYPE_DOESPHYSICALOBJECTEXIST DoesPhysicalObjectExist;
    PTYPE_REMOVEPHYSICALOBJECT RemovePhysicalObject;
    PTYPE_CREATEPHYSICALOBJECT CreatePhysicalObject;
    PTYPE_REPLACEPHYSICALOBJECT ReplacePhysicalObject;
    PTYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertObjectContentToUnicode;
    PTYPE_CONVERTOBJECTCONTENTTOANSI ConvertObjectContentToAnsi;
    PTYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedObjectContent;
} TYPE_REGISTER, *PTYPE_REGISTER;

typedef BOOL (WINAPI MIG_PHYSICALENUMCHECK)(
                IN      PMIG_TYPEOBJECTENUM ObjectEnum,
                IN      ULONG_PTR Arg
                );

typedef MIG_PHYSICALENUMCHECK *PMIG_PHYSICALENUMCHECK;

typedef BOOL (WINAPI MIG_PHYSICALENUMADD)(
                IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
                IN      MIG_OBJECTSTRINGHANDLE Pattern,     // NULL if Abort is TRUE
                IN      MIG_PARSEDPATTERN ParsedPattern,    // NULL if Abort is TRUE
                IN      ULONG_PTR Arg,
                IN      BOOL Abort
                );

typedef MIG_PHYSICALENUMADD *PMIG_PHYSICALENUMADD;

typedef BOOL (WINAPI MIG_PHYSICALACQUIREHOOK)(
                IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                IN      PMIG_CONTENT ObjectContent,
                IN      MIG_CONTENTTYPE ContentType,
                IN      UINT MemoryContentLimit,
                OUT     PMIG_CONTENT *NewObjectContent,         CALLER_INITIALIZED OPTIONAL
                IN      BOOL ReleaseContent,
                IN      ULONG_PTR Arg
                );

typedef MIG_PHYSICALACQUIREHOOK *PMIG_PHYSICALACQUIREHOOK;

typedef VOID (WINAPI MIG_PHYSICALACQUIREFREE)(PMIG_CONTENT ObjectContent);

typedef MIG_PHYSICALACQUIREFREE *PMIG_PHYSICALACQUIREFREE;


//
// module entry points
//

typedef BOOL(WINAPI MODULEINITIALIZE)(VOID);
typedef MODULEINITIALIZE * PMODULEINITIALIZE;

typedef VOID(WINAPI MODULETERMINATE)(VOID);
typedef MODULETERMINATE * PMODULETERMINATE;

typedef BOOL(WINAPI ETMINITIALIZE)(MIG_PLATFORMTYPEID Platform, PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef ETMINITIALIZE * PETMINITIALIZE;

typedef BOOL(WINAPI ETMPARSE)(PVOID Reserved);
typedef ETMPARSE *PETMPARSE;

typedef VOID(WINAPI ETMTERMINATE)(VOID);
typedef ETMTERMINATE * PETMTERMINATE;

typedef VOID(WINAPI ETMNEWUSERCREATED)(PCTSTR UserName, PCTSTR DomainName, PCTSTR UserProfileRoot, PSID UserSid);
typedef ETMNEWUSERCREATED * PETMNEWUSERCREATED;

typedef struct {
    UINT Version;
    PETMINITIALIZE EtmInitialize;
    PETMPARSE EtmParse;
    PETMTERMINATE EtmTerminate;
    PETMNEWUSERCREATED EtmNewUserCreated;
} TYPE_ENTRYPOINTS, *PTYPE_ENTRYPOINTS;

typedef BOOL(WINAPI VCMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef VCMINITIALIZE * PVCMINITIALIZE;

typedef BOOL(WINAPI VCMPARSE)(PVOID Reserved);
typedef VCMPARSE * PVCMPARSE;

typedef BOOL(WINAPI VCMQUEUEENUMERATION)(PVOID Reserved);
typedef VCMQUEUEENUMERATION * PVCMQUEUEENUMERATION;

typedef BOOL(WINAPI VCMQUEUEHIGHPRIORITYENUMERATION)(PVOID Reserved);
typedef VCMQUEUEHIGHPRIORITYENUMERATION * PVCMQUEUEHIGHPRIORITYENUMERATION;

typedef UINT(WINAPI VCMENUMERATIONCALLBACK)(
                IN      PCMIG_OBJECTENUMDATA Data,
                IN      ULONG_PTR CallerArg
                );
typedef VCMENUMERATIONCALLBACK * PVCMENUMERATIONCALLBACK;

typedef VOID(WINAPI VCMTERMINATE)(VOID);
typedef VCMTERMINATE * PVCMTERMINATE;

typedef struct {
    UINT Version;
    PVCMINITIALIZE VcmInitialize;
    PVCMPARSE VcmParse;
    PVCMQUEUEENUMERATION VcmQueueEnumeration;
    PVCMQUEUEHIGHPRIORITYENUMERATION VcmQueueHighPriorityEnumeration;
    PVCMTERMINATE VcmTerminate;
} VIRTUAL_COMPUTER_ENTRYPOINTS, *PVIRTUAL_COMPUTER_ENTRYPOINTS;

typedef BOOL(WINAPI SGMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef SGMINITIALIZE * PSGMINITIALIZE;

typedef BOOL(WINAPI SGMPARSE)(PVOID Reserved);
typedef SGMPARSE * PSGMPARSE;

typedef BOOL(WINAPI SGMQUEUEENUMERATION)(PVOID Reserved);
typedef SGMQUEUEENUMERATION * PSGMQUEUEENUMERATION;

typedef BOOL(WINAPI SGMQUEUEHIGHPRIORITYENUMERATION)(PVOID Reserved);
typedef SGMQUEUEHIGHPRIORITYENUMERATION * PSGMQUEUEHIGHPRIORITYENUMERATION;

typedef UINT(WINAPI SGMENUMERATIONCALLBACK)(
                IN      PCMIG_OBJECTENUMDATA Data,
                IN      ULONG_PTR CallerArg
                );
typedef SGMENUMERATIONCALLBACK * PSGMENUMERATIONCALLBACK;

typedef VOID(WINAPI SGMTERMINATE)(VOID);
typedef SGMTERMINATE * PSGMTERMINATE;

typedef BOOL(WINAPI SAMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef SAMINITIALIZE * PSAMINITIALIZE;

typedef BOOL(WINAPI SAMEXECUTE)(VOID);
typedef SAMEXECUTE * PSAMEXECUTE;

typedef VOID(WINAPI SAMESTIMATEPROGRESSBAR)(VOID);
typedef SAMESTIMATEPROGRESSBAR *PSAMESTIMATEPROGRESSBAR;

typedef VOID(WINAPI SAMTERMINATE)(VOID);
typedef SAMTERMINATE * PSAMTERMINATE;

typedef struct {
    UINT Version;
    PSGMINITIALIZE SgmInitialize;
    PSGMPARSE SgmParse;
    PSGMQUEUEENUMERATION SgmQueueEnumeration;
    PSGMQUEUEHIGHPRIORITYENUMERATION SgmQueueHighPriorityEnumeration;
    PSGMTERMINATE SgmTerminate;
    PSAMINITIALIZE SamInitialize;
    PSAMEXECUTE SamExecute;
    PSAMESTIMATEPROGRESSBAR SamEstimateProgressBar;
    PSAMTERMINATE SamTerminate;
} SOURCE_ENTRYPOINTS, *PSOURCE_ENTRYPOINTS;

typedef BOOL(WINAPI DGMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef DGMINITIALIZE * PDGMINITIALIZE;

typedef BOOL(WINAPI DGMQUEUEENUMERATION)(PVOID Reserved);
typedef DGMQUEUEENUMERATION * PDGMQUEUEENUMERATION;

typedef BOOL(WINAPI DGMQUEUEHIGHPRIORITYENUMERATION)(PVOID Reserved);
typedef DGMQUEUEHIGHPRIORITYENUMERATION * PDGMQUEUEHIGHPRIORITYENUMERATION;

typedef UINT(WINAPI DGMENUMERATIONCALLBACK)(
                IN      PCMIG_OBJECTENUMDATA Data,
                IN      ULONG_PTR CallerArg
                );
typedef DGMENUMERATIONCALLBACK * PDGMENUMERATIONCALLBACK;

typedef VOID(WINAPI DGMTERMINATE)(VOID);
typedef DGMTERMINATE * PDGMTERMINATE;

typedef BOOL(WINAPI DAMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef DAMINITIALIZE * PDAMINITIALIZE;

typedef BOOL(WINAPI DAMEXECUTE)(VOID);
typedef DAMEXECUTE * PDAMEXECUTE;

typedef VOID(WINAPI DAMESTIMATEPROGRESSBAR)(VOID);
typedef DAMESTIMATEPROGRESSBAR *PDAMESTIMATEPROGRESSBAR;

typedef VOID(WINAPI DAMTERMINATE)(VOID);
typedef DAMTERMINATE * PDAMTERMINATE;

typedef BOOL(WINAPI CSMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef CSMINITIALIZE * PCSMINITIALIZE;

typedef BOOL(WINAPI CSMEXECUTE)(VOID);
typedef CSMEXECUTE * PCSMEXECUTE;

typedef VOID(WINAPI CSMESTIMATEPROGRESSBAR)(VOID);
typedef CSMESTIMATEPROGRESSBAR *PCSMESTIMATEPROGRESSBAR;

typedef VOID(WINAPI CSMTERMINATE)(VOID);
typedef CSMTERMINATE * PCSMTERMINATE;

typedef BOOL(WINAPI OPMINITIALIZE)(PMIG_LOGCALLBACK LogCallback, PVOID Reserved);
typedef OPMINITIALIZE * POPMINITIALIZE;

typedef VOID(WINAPI OPMTERMINATE)(VOID);
typedef OPMTERMINATE * POPMTERMINATE;

typedef struct {
    UINT Version;
    PDGMINITIALIZE DgmInitialize;
    PDGMQUEUEENUMERATION DgmQueueEnumeration;
    PDGMQUEUEHIGHPRIORITYENUMERATION DgmQueueHighPriorityEnumeration;
    PDGMTERMINATE DgmTerminate;
    PDAMINITIALIZE DamInitialize;
    PDAMEXECUTE DamExecute;
    PDAMESTIMATEPROGRESSBAR DamEstimateProgressBar;
    PDAMTERMINATE DamTerminate;
    PCSMINITIALIZE CsmInitialize;
    PCSMEXECUTE CsmExecute;
    PCSMESTIMATEPROGRESSBAR CsmEstimateProgressBar;
    PCSMTERMINATE CsmTerminate;
    POPMINITIALIZE OpmInitialize;
    POPMTERMINATE OpmTerminate;
} DESTINATION_ENTRYPOINTS, *PDESTINATION_ENTRYPOINTS;

//
// callback prototypes
//

typedef UINT (WINAPI MIG_OBJECTENUMCALLBACK)(PCMIG_OBJECTENUMDATA Data, ULONG_PTR CallerArg);
typedef MIG_OBJECTENUMCALLBACK *PMIG_OBJECTENUMCALLBACK;

typedef BOOL (WINAPI MIG_PREENUMCALLBACK)(VOID);
typedef MIG_PREENUMCALLBACK *PMIG_PREENUMCALLBACK;

typedef BOOL (WINAPI MIG_POSTENUMCALLBACK)(VOID);
typedef MIG_POSTENUMCALLBACK *PMIG_POSTENUMCALLBACK;

typedef BOOL (WINAPI MIG_DYNAMICEXCLUSIONCALLBACK)(
                    MIG_OBJECTTYPEID ObjectTypeId,
                    MIG_OBJECTSTRINGHANDLE EncodedObjectName,
                    ULONG_PTR Arg
                    );

typedef MIG_DYNAMICEXCLUSIONCALLBACK *PMIG_DYNAMICEXCLUSIONCALLBACK;

typedef BOOL (WINAPI MIG_RESTORECALLBACK)(MIG_OBJECTTYPEID,MIG_OBJECTID,MIG_OBJECTSTRINGHANDLE);
typedef MIG_RESTORECALLBACK *PMIG_RESTORECALLBACK;

typedef BOOL (WINAPI MIG_COMPARECALLBACK)(BOOL,MIG_OBJECTTYPEID,MIG_OBJECTSTRINGHANDLE,PMIG_CONTENT,MIG_OBJECTTYPEID,MIG_OBJECTSTRINGHANDLE,PMIG_CONTENT,PBOOL,PBOOL);
typedef MIG_COMPARECALLBACK *PMIG_COMPARECALLBACK;

//
// entry points that return module funciton addresses
//

typedef BOOL(WINAPI VIRTUALCOMPUTERMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PVIRTUAL_COMPUTER_ENTRYPOINTS VirtualComputerEntryPoints
                );
typedef VIRTUALCOMPUTERMODULE *PVIRTUALCOMPUTERMODULE;

typedef BOOL(WINAPI SOURCEMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PSOURCE_ENTRYPOINTS SourceEntryPoints
                );
typedef SOURCEMODULE *PSOURCEMODULE;

typedef BOOL(WINAPI DESTINATIONMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PDESTINATION_ENTRYPOINTS DestinationEntryPoints
                );
typedef DESTINATIONMODULE *PDESTINATIONMODULE;

typedef BOOL(WINAPI TYPEMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PTYPE_ENTRYPOINTS TypeEntryPoints
                );
typedef TYPEMODULE *PTYPEMODULE;

typedef BOOL(WINAPI TRANSPORTMODULE)(
                IN      PCTSTR ModuleId,
                IN OUT  PTRANSPORT_ENTRYPOINTS TransportEntryPoints
                );
typedef TRANSPORTMODULE *PTRANSPORTMODULE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\inc\ism.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ism.h

Abstract:

    Base definitions for the Intermediate State Manager.

Author:

    Jim Schmidt (jimschm) 15-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// Strings
//

#define S_DATATYPE                      TEXT("Data")
#define S_REGISTRYTYPE                  TEXT("Registry")
#define S_INITYPE                       TEXT("IniFile")
#define S_FILETYPE                      TEXT("File")
#define S_VER_HIVEMAPPEDLOCATION        TEXT("HiveMappedLocation")

//
// Constants
//

// Priorities for the type IDs. This gives the order of
// processing and enumeration inside the engine.
#define PRIORITY_DATA           0x00000100
#define PRIORITY_REGISTRY       0x00000200
#define PRIORITY_INI            0x00000300
#define PRIORITY_FILE           0x00000400
#define PRIORITY_LOWEST         0xFFFFFFFF

//
// If either DBG or DEBUG defined, use debug mode
//

#if defined(DBG) && !defined(DEBUG)
#define DEBUG
#endif

#if defined(DEBUG) && !defined(DBG)
#define DBG
#endif

#ifdef DEBUG

#define TRACKING_DEF , PCSTR File, UINT Line
#define TRACKING_CALL ,__FILE__,__LINE__
#define TRACKING_INLINE_CALL ,File,Line

#else

#define TRACKING_DEF
#define TRACKING_CALL
#define TRACKING_INLINE_CALL

#endif

//
// callback constants
//

#define CALLBACK_ENUM_CONTINUE          0x00000000

#define CALLBACK_SKIP_LEAVES            0x00000001
#define CALLBACK_SKIP_NODES             0x00000002
#define CALLBACK_SKIP_TREE              0x00000004
#define CALLBACK_SKIP_REMAINING_TREE    CALLBACK_SKIP_TREE
#define CALLBACK_THIS_TREE_ONLY         0x00000008
#define CALLBACK_DONE_ENUMERATING       0x00000010
#define CALLBACK_ERROR                  0x80000000

#define ALL_PATTERN                     ((PMIG_SEGMENTS) 1)

//
// used by rollback and delayed operations mechanism
//
#define JRNOP_CREATE                    0x00000001
#define JRNOP_DELETE                    0x00000002
#define JRNOP_REPLACE                   0x00000003

#define ZEROED
#define CALLER_INITIALIZED

//
// component constants
//

#define MASTERGROUP_NONE                0
#define MASTERGROUP_SCRIPT              1
#define MASTERGROUP_FILES_AND_FOLDERS   2
#define MASTERGROUP_USER                3
#define MASTERGROUP_APP                 4
#define MASTERGROUP_SYSTEM              5
#define MASTERGROUP_ALL                 255

//
// IsmQueueEnumeration constants
//

#define QUEUE_MAKE_APPLY                0x0001
#define QUEUE_MAKE_PERSISTENT           0x0002
#define QUEUE_OVERWRITE_DEST            0x0004
#define QUEUE_DONT_OVERWRITE_DEST       0x0008
#define QUEUE_MAKE_NONCRITICAL          0x0010

//
// execute constants
//
#define MIG_EXECUTE_PREPROCESS          0x0001
#define MIG_EXECUTE_REFRESH             0x0002
#define MIG_EXECUTE_POSTPROCESS         0x0003

#define ISMMESSAGE_EXECUTE_PREPROCESS   0x0001
#define ISMMESSAGE_EXECUTE_REFRESH      0x0002
#define ISMMESSAGE_EXECUTE_POSTPROCESS  0x0003
#define ISMMESSAGE_EXECUTE_ROLLBACK     0x0004
#define ISMMESSAGE_APP_INFO             0x0005
#define ISMMESSAGE_APP_INFO_NOW         0x0006

//
// Macros
//

// None

//
// Types
//

//
// misc types
//

typedef enum {
    CONTENTTYPE_ANY = 0,
    CONTENTTYPE_MEMORY,
    CONTENTTYPE_FILE,
    CONTENTTYPE_DETAILS_ONLY
} MIG_CONTENTTYPE;


#define PLATFORM_CURRENT        0x00000000
#define PLATFORM_SOURCE         0x10000000
#define PLATFORM_DESTINATION    0x20000000
#define PLATFORM_MASK           0xF0000000
#define TYPE_MASK               0x0FFFFFFF

#define COMPONENTENUM_ALIASES                   0x00000001
#define COMPONENTENUM_ENABLED                   0x00000002
#define COMPONENTENUM_DISABLED                  0x00000004
#define COMPONENTENUM_PREFERRED_ONLY            0x00000008
#define COMPONENTENUM_NON_PREFERRED_ONLY        0x00000010

#define COMPONENTENUM_ALL_COMPONENTS            (COMPONENTENUM_ENABLED|COMPONENTENUM_DISABLED)
#define COMPONENTENUM_ALL_ALIASES               (COMPONENTENUM_ALIASES|COMPONENTENUM_ENABLED|COMPONENTENUM_DISABLED)

#define EXECUTETYPE_VIRTUALCOMPUTER_PARSING     0x00000001
#define EXECUTETYPE_VIRTUALCOMPUTER             0x00000002
#define EXECUTETYPE_EXECUTESOURCE_PARSING       0x00000003
#define EXECUTETYPE_EXECUTESOURCE               0x00000004
#define EXECUTETYPE_EXECUTEDESTINATION          0x00000005
#define EXECUTETYPE_DELAYEDOPERATIONS           0x00000006
#define EXECUTETYPE_DELAYEDOPERATIONSCLEANUP    0x00000007

#define TRANSPORTTYPE_LIGHT             0x00000001
#define TRANSPORTTYPE_FULL              0x00000002

#define MIG_DATA_TYPE           IsmGetObjectTypeId(S_DATATYPE)
#define MIG_REGISTRY_TYPE       IsmGetObjectTypeId(S_REGISTRYTYPE)
#define MIG_INI_TYPE            IsmGetObjectTypeId(S_INITYPE)
#define MIG_FILE_TYPE           IsmGetObjectTypeId(S_FILETYPE)

typedef enum {
    MIG_TRANSPORT_PHASE = 1,
    MIG_HIGHPRIORITYQUEUE_PHASE,
    MIG_HIGHPRIORITYESTIMATE_PHASE,
    MIG_HIGHPRIORITYGATHER_PHASE,
    MIG_GATHERQUEUE_PHASE,
    MIG_GATHERESTIMATE_PHASE,
    MIG_GATHER_PHASE,
    MIG_ANALYSIS_PHASE,
    MIG_APPLY_PHASE
} MIG_PROGRESSPHASE;

typedef enum {
    MIG_BEGIN_PHASE = 1,
    MIG_IN_PHASE,
    MIG_END_PHASE
} MIG_PROGRESSSTATE;

typedef struct {
    DWORD TotalObjects;
    DWORD PersistentObjects;
    DWORD ApplyObjects;
} MIG_OBJECTCOUNT, *PMIG_OBJECTCOUNT;

#ifndef PCVOID
typedef const void * PCVOID;
#endif

#ifndef PCBYTE
typedef const unsigned char * PCBYTE;
#endif

typedef unsigned long       MIG_ATTRIBUTEID;
typedef unsigned int        MIG_PROPERTYID;
typedef unsigned long       MIG_OBJECTTYPEID;
typedef unsigned long       MIG_OPERATIONID;
typedef signed int          MIG_OBJECTID;
typedef unsigned int        MIG_PROPERTYDATAID;
typedef unsigned int        MIG_DATAHANDLE;
typedef PCTSTR              MIG_OBJECTSTRINGHANDLE;
typedef unsigned int        MIG_PLATFORMTYPEID;
typedef LONG_PTR            MIG_TRANSPORTID;
typedef signed long         MIG_TRANSPORTSTORAGEID;
typedef unsigned long       MIG_TRANSPORTTYPE;
typedef unsigned long       MIG_TRANSPORTCAPABILITIES;
typedef signed short        MIG_PROGRESSSLICEID;
typedef unsigned int        MIG_EXECUTETYPEID;
typedef PCVOID              MIG_PARSEDPATTERN;

typedef MIG_TRANSPORTTYPE *PMIG_TRANSPORTTYPE;
typedef MIG_TRANSPORTCAPABILITIES *PMIG_TRANSPORTCAPABILITIES;

typedef enum {
    PHYSICAL_OBJECT = 1,
    ISM_OBJECT
} MIG_LOCATION_TYPE;

typedef enum {
    CR_FAILED = 1,
    CR_SOURCE_DOES_NOT_EXIST,
    CR_DESTINATION_EXISTS
} MIG_COMPARERESULT;

//
// object values
//

typedef struct {
    UINT DetailsSize;
    PCVOID DetailsData;
} MIG_DETAILS, *PMIG_DETAILS;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;

    BOOL ContentInFile;

    union {

        struct _TAG_FILECONTENT {
            PCTSTR ContentPath;
            LONGLONG ContentSize;
        } FileContent;

        struct _TAG_MEMORYCONTENT {
            PCBYTE ContentBytes;
            UINT ContentSize;
        } MemoryContent;
    };

    MIG_DETAILS Details;

    // internal members
    union {
        PVOID EtmHandle;
        PVOID TransHandle;
    };

    PVOID IsmHandle;

} MIG_CONTENT, *PMIG_CONTENT;

typedef MIG_CONTENT const * PCMIG_CONTENT;

typedef struct {
    PCTSTR Segment;
    BOOL IsPattern;
} MIG_SEGMENTS, *PMIG_SEGMENTS;

//
// transport module structs and function types
//

typedef struct {
    MIG_TRANSPORTID TransportId;
    MIG_TRANSPORTSTORAGEID SupportedStorageId;
    MIG_TRANSPORTTYPE TransportType;
    MIG_TRANSPORTCAPABILITIES Capabilities;
    PCTSTR FriendlyDescription;

    PVOID Handle;
} MIG_TRANSPORTENUM, *PMIG_TRANSPORTENUM;

//
// type id enum
//

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    LONG_PTR EnumHandle;
} MIG_OBJECTTYPEIDENUM, *PMIG_OBJECTTYPEIDENUM;

//
// object enum
//

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;

    PCTSTR NativeObjectName;
    PCTSTR ObjectNode;
    PCTSTR ObjectLeaf;

    UINT Level;
    UINT SubLevel;
    BOOL IsLeaf;
    BOOL IsNode;

    MIG_DETAILS Details;

    LONG_PTR EtmHandle;
    PVOID IsmHandle;
} MIG_TYPEOBJECTENUM, *PMIG_TYPEOBJECTENUM;

typedef struct {

    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;

    PCTSTR NativeObjectName;
    PCTSTR ObjectNode;
    PCTSTR ObjectLeaf;

    UINT Level;
    UINT SubLevel;
    BOOL IsLeaf;
    BOOL IsNode;

    MIG_DETAILS Details;
} MIG_OBJECTENUMDATA, *PMIG_OBJECTENUMDATA;

typedef const MIG_OBJECTENUMDATA * PCMIG_OBJECTENUMDATA;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;

    MIG_OBJECTID ObjectId;              // 0 == physical object

    PVOID Handle;       // used by enum routines
} MIG_OBJECT_ENUM, *PMIG_OBJECT_ENUM;

//
// properties
//

typedef enum {
    BLOBTYPE_STRING = 1,
    BLOBTYPE_BINARY = 2
} MIG_BLOBTYPE, *PMIG_BLOBTYPE;

typedef struct {
    MIG_BLOBTYPE Type;

    union {
        PCTSTR String;
        struct {
            PCBYTE BinaryData;
            UINT BinarySize;
        };
    };

} MIG_BLOB, *PMIG_BLOB;

typedef const MIG_BLOB * PCMIG_BLOB;

typedef struct {
    MIG_PROPERTYID PropertyId;
    MIG_PROPERTYDATAID PropertyDataId;
    BOOL Private;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTPROPERTY_ENUM, *PMIG_OBJECTPROPERTY_ENUM;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
    MIG_OBJECTID ObjectId;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTWITHPROPERTY_ENUM, *PMIG_OBJECTWITHPROPERTY_ENUM;

//
// attributes
//

typedef struct {
    MIG_ATTRIBUTEID AttributeId;
    BOOL Private;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTATTRIBUTE_ENUM, *PMIG_OBJECTATTRIBUTE_ENUM;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
    MIG_OBJECTID ObjectId;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTWITHATTRIBUTE_ENUM, *PMIG_OBJECTWITHATTRIBUTE_ENUM;

//
// operations
//

typedef struct {
    MIG_OPERATIONID OperationId;
    PCMIG_BLOB SourceData;              OPTIONAL
    PCMIG_BLOB DestinationData;         OPTIONAL
    BOOL Private;

    PVOID Handle;       // used by enum routines
} MIG_OBJECTOPERATION_ENUM, *PMIG_OBJECTOPERATION_ENUM;

typedef struct {
    MIG_OBJECTSTRINGHANDLE ObjectName;
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTID ObjectId;
    MIG_OPERATIONID OperationId;
    PCMIG_BLOB SourceData;              OPTIONAL
    PCMIG_BLOB DestinationData;         OPTIONAL

    PVOID Handle;       // used by enum routines
} MIG_OBJECTWITHOPERATION_ENUM, *PMIG_OBJECTWITHOPERATION_ENUM;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
} MIG_OBJECT, *PMIG_OBJECT;

typedef const MIG_OBJECT * PCMIG_OBJECT;

typedef struct {
    MIG_OBJECT OriginalObject;
    MIG_OBJECT CurrentObject;
    BOOL FilterTreeChangesOnly;
    BOOL Deleted;
    BOOL Replaced;
} MIG_FILTERINPUT, *PMIG_FILTERINPUT;

typedef MIG_FILTERINPUT const * PCMIG_FILTERINPUT;

typedef struct {
    MIG_OBJECT NewObject;
    BOOL Deleted;
    BOOL Replaced;
} MIG_FILTEROUTPUT, *PMIG_FILTEROUTPUT;

//
// environment & message passing types
//

typedef enum {
    ENVENTRY_NONE = 0,
    ENVENTRY_STRING,
    ENVENTRY_MULTISZ,
    ENVENTRY_CALLBACK,
    ENVENTRY_BINARY
} ENVENTRY_TYPE, *PENVENTRY_TYPE;

typedef BOOL (WINAPI ENVENTRYCALLBACK)(PCTSTR,PTSTR,UINT,PUINT,PCTSTR);
typedef ENVENTRYCALLBACK *PENVENTRYCALLBACK;

typedef struct {
    ENVENTRY_TYPE Type;
    union {
        PCTSTR EnvString;
        PCTSTR MultiSz;
        struct {
            PCBYTE EnvBinaryData;
            UINT EnvBinaryDataSize;
        };
        PENVENTRYCALLBACK EnvCallback;
    };
} ENVENTRY_STRUCT, *PENVENTRY_STRUCT;

typedef struct {
    PCTSTR UserName;
    PCTSTR DomainName;
    PCTSTR AccountName;
    PCTSTR UserProfileRoot;
    PSID UserSid;
} MIG_USERDATA, *PMIG_USERDATA;

typedef struct {
    MIG_PROGRESSPHASE Phase;
    UINT SubPhase;
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
    PCTSTR Text;
} MIG_APPINFO, *PMIG_APPINFO;

//
// components
//

typedef struct {
    PCTSTR ComponentString;
    PCTSTR LocalizedAlias;
    UINT Instance;
    UINT GroupId;
    BOOL Preferred;
    BOOL UserSupplied;
    BOOL Enabled;
    UINT MasterGroup;

    BOOL SkipToNextComponent;       // set this to TRUE to cause enumeration to continue to next component
                                    // (instead of next alias of same component)

    PVOID Handle;
} MIG_COMPONENT_ENUM, *PMIG_COMPONENT_ENUM;

//
// Version
//

#define OSTYPE_WINDOWS9X        1
#define OSTYPE_WINDOWS9X_STR    TEXT("9X")
#define OSTYPE_WINDOWSNT        2
#define OSTYPE_WINDOWSNT_STR    TEXT("NT")

#define OSMAJOR_WIN95           1
#define OSMAJOR_WIN95_STR       TEXT("Windows 95")
#define OSMAJOR_WIN95OSR2       2
#define OSMAJOR_WIN95OSR2_STR   TEXT("Windows 95 - OSR2")
#define OSMAJOR_WIN98           3
#define OSMAJOR_WIN98_STR       TEXT("Windows 98")
#define OSMAJOR_WINME           4
#define OSMAJOR_WINME_STR       TEXT("Windows Millennium")
#define OSMAJOR_WINNT4          1
#define OSMAJOR_WINNT4_STR      TEXT("Windows NT4")
#define OSMAJOR_WINNT5          2
#define OSMAJOR_WINNT5_STR      TEXT("Windows 2000")

#define OSMINOR_GOLD            0
#define OSMINOR_GOLD_STR        TEXT("Gold")
#define OSMINOR_WIN95OSR21      1
#define OSMINOR_WIN95OSR21_STR  TEXT("1")
#define OSMINOR_WIN95OSR25      2
#define OSMINOR_WIN95OSR25_STR  TEXT("5")
#define OSMINOR_WIN98SE         1
#define OSMINOR_WIN98SE_STR     TEXT("Second Edition")
#define OSMINOR_WINNT51         1
#define OSMINOR_WINNT51_STR     TEXT("XP")

typedef struct {
    UINT OsType;
    PCTSTR OsTypeName;
    UINT OsMajorVersion;
    PCTSTR OsMajorVersionName;
    UINT OsMinorVersion;
    PCTSTR OsMinorVersionName;
    UINT OsBuildNumber;
} MIG_OSVERSIONINFO, *PMIG_OSVERSIONINFO;

#include "ismproc.h"

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Public function declarations
//

//
// app layer
//

BOOL
WINAPI
IsmInitialize (
    IN      PCTSTR InfPath,
    IN      PMESSAGECALLBACK MessageCallback,   OPTIONAL
    IN      PMIG_LOGCALLBACK LogCallback
    );

BOOL
WINAPI
IsmSetPlatform (
    IN      MIG_PLATFORMTYPEID Platform
    );

BOOL
WINAPI
IsmRegisterProgressBarCallback (
    IN      PPROGRESSBARFN ProgressBarFn,
    IN      ULONG_PTR Arg
    );

BOOL
WINAPI
IsmStartEtmModules (
    VOID
    );

BOOL
WINAPI
IsmStartTransport (
    VOID
    );

BOOL
WINAPI
IsmEnumFirstTransport (
    OUT     PMIG_TRANSPORTENUM Enum,
    IN      MIG_TRANSPORTSTORAGEID DesiredType  OPTIONAL
    );

BOOL
WINAPI
IsmEnumNextTransport (
    IN OUT  PMIG_TRANSPORTENUM Enum
    );

VOID
WINAPI
IsmAbortTransportEnum (
    IN      PMIG_TRANSPORTENUM Enum
    );

MIG_TRANSPORTID
WINAPI
IsmSelectTransport (
    IN      MIG_TRANSPORTSTORAGEID DesiredStorageId,
    IN      MIG_TRANSPORTTYPE TransportType,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities
    );

BOOL
WINAPI
IsmSetTransportStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTID TransportId,
    IN      MIG_TRANSPORTSTORAGEID StorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL StoragePathIsValid,                       OPTIONAL
    OUT     PBOOL ImageExistsInStorage                      OPTIONAL
    );

BOOL
WINAPI
IsmPerformParsing (
    VOID
    );

BOOL
WINAPI
IsmExecute (
    IN      MIG_EXECUTETYPEID ExecuteType
    );

BOOL
WINAPI
IsmLoad (
    VOID
    );

BOOL
WINAPI
IsmResumeLoad (
    VOID
    );

BOOL
WINAPI
IsmSave (
    VOID
    );

BOOL
WINAPI
IsmResumeSave (
    VOID
    );

VOID
WINAPI
IsmTerminate (
    VOID
    );

//
// component apis
//

BOOL
WINAPI
IsmAddComponentAlias (
    IN      PCTSTR ComponentString,             OPTIONAL
    IN      UINT MasterGroup,
    IN      PCTSTR LocalizedAlias,
    IN      UINT ComponentGroupId,
    IN      BOOL UserSupplied
    );

BOOL
WINAPI
IsmSelectPreferredAlias (
    IN      PCTSTR ComponentString,
    IN      PCTSTR LocalizedAlias,          OPTIONAL
    IN      UINT ComponentGroupId           OPTIONAL
    );

BOOL
WINAPI
IsmSelectComponent (
    IN      PCTSTR ComponentOrAlias,
    IN      UINT ComponentGroupId,              OPTIONAL
    IN      BOOL Enable
    );

BOOL
WINAPI
IsmSelectMasterGroup (
    IN      UINT MasterGroup,
    IN      BOOL Enable
    );

BOOL
WINAPI
IsmEnumFirstComponent (
    OUT     PMIG_COMPONENT_ENUM EnumPtr,
    IN      DWORD ComponentEnumFlags,
    IN      UINT GroupIdFilter                  OPTIONAL
    );

BOOL
WINAPI
IsmEnumNextComponent (
    IN OUT  PMIG_COMPONENT_ENUM EnumPtr
    );


VOID
WINAPI
IsmAbortComponentEnum (
    IN      PMIG_COMPONENT_ENUM EnumPtr         ZEROED
    );

VOID
WINAPI
IsmRemoveAllUserSuppliedComponents (
    VOID
    );

BOOL
WINAPI
IsmIsComponentSelected (
    IN      PCTSTR ComponentOrAlias,
    IN      UINT ComponentGroupId               OPTIONAL
    );

//
// module support routines
//

PVOID
WINAPI
TrackedIsmGetMemory (
    IN      UINT Size
            TRACKING_DEF
    );
#define IsmGetMemory(s) TrackedIsmGetMemory(s TRACKING_CALL)

PCTSTR
WINAPI
TrackedIsmDuplicateString (
    IN      PCTSTR String
            TRACKING_DEF
    );
#define IsmDuplicateString(s) TrackedIsmDuplicateString(s TRACKING_CALL)

BOOL
WINAPI
IsmReleaseMemory (
    IN      PCVOID Memory
    );

MIG_PLATFORMTYPEID
WINAPI
IsmGetRealPlatform (
    VOID
    );

BOOL
WINAPI
IsmCreateUser (
    IN      PCTSTR UserName,
    IN      PCTSTR Domain
    );

MIG_OBJECTSTRINGHANDLE
TrackedIsmGetLongName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
            TRACKING_DEF
    );
#define IsmGetLongName(t,n) TrackedIsmGetLongName(t,n TRACKING_CALL)

//
// type module interface
//

MIG_OBJECTTYPEID
WINAPI
IsmRegisterObjectType (
    IN      PCTSTR ObjectTypeName,
    IN      BOOL CanBeRestored,
    IN      BOOL ReadOnly,
    IN      PTYPE_REGISTER TypeRegisterData
    );

BOOL
WINAPI
IsmEnumFirstObjectTypeId (
    OUT     PMIG_OBJECTTYPEIDENUM ObjectTypeIdEnum
    );

BOOL
WINAPI
IsmEnumNextObjectTypeId (
    IN OUT  PMIG_OBJECTTYPEIDENUM ObjectTypeIdEnum
    );

VOID
WINAPI
IsmAbortObjectTypeIdEnum (
    IN OUT  PMIG_OBJECTTYPEIDENUM ObjectTypeIdEnum
    );

PCTSTR
WINAPI
IsmConvertObjectToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

BOOL
WINAPI
IsmConvertMultiSzToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    );

PCTSTR
WINAPI
TrackedIsmGetNativeObjectName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
            TRACKING_DEF
    );
#define IsmGetNativeObjectName(t,n) TrackedIsmGetNativeObjectName(t,n TRACKING_CALL)

BOOL
IsmRegisterPhysicalAcquireHook (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_PHYSICALACQUIREHOOK HookCallback,
    IN      PMIG_PHYSICALACQUIREFREE FreeCallback,          OPTIONAL
    IN      ULONG_PTR CallbackArg,                          OPTIONAL
    IN      PCTSTR FunctionId                               OPTIONAL
    );

BOOL
IsmProhibitPhysicalEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_PHYSICALENUMCHECK EnumCheckCallback,       OPTIONAL
    IN      ULONG_PTR CallbackArg,                          OPTIONAL
    IN      PCTSTR FunctionId                               OPTIONAL
    );

BOOL
IsmAddToPhysicalEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectBase,
    IN      PMIG_PHYSICALENUMADD EnumAddCallback,
    IN      ULONG_PTR CallbackArg                           OPTIONAL
    );

//
// environment & messaging
//

BOOL
WINAPI
IsmSetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PENVENTRY_STRUCT VariableData   OPTIONAL
    );

BOOL
WINAPI
IsmSetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    );

BOOL
WINAPI
IsmSetEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    );

BOOL
WINAPI
IsmAppendEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    );

BOOL
WINAPI
IsmAppendEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    );

BOOL
WINAPI
IsmSetEnvironmentCallback (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PENVENTRYCALLBACK VariableCallback
    );

BOOL
WINAPI
IsmSetEnvironmentData (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCBYTE VariableData,
    IN      UINT VariableDataSize
    );

BOOL
WINAPI
IsmSetEnvironmentFlag (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName
    );

BOOL
WINAPI
IsmGetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE Data,                 OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded,       OPTIONAL
    OUT     PENVENTRY_TYPE DataType     OPTIONAL
    );

BOOL
WINAPI
IsmGetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PTSTR VariableValue,        OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    );

#define IsmCopyEnvironmentString(p,g,n,v) IsmGetEnvironmentString(p,g,n,v,sizeof(v)/sizeof((v)[0]),NULL)

BOOL
WINAPI
IsmGetEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PTSTR VariableValue,        OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    );

BOOL
WINAPI
IsmGetEnvironmentCallback (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                           OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PENVENTRYCALLBACK *VariableCallback     OPTIONAL
    );

BOOL
WINAPI
IsmGetEnvironmentData (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE VariableData,         OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    );

BOOL
WINAPI
IsmIsEnvironmentFlagSet (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName
    );

BOOL
WINAPI
IsmDeleteEnvironmentVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName
    );

PCTSTR
WINAPI
TrackedIsmExpandEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR SrcString,
    IN      PCTSTR Context
            TRACKING_DEF
    );
#define IsmExpandEnvironmentString(p,g,s,c) TrackedIsmExpandEnvironmentString(p,g,s,c TRACKING_CALL)

PCTSTR
WINAPI
TrackedIsmCompressEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR SrcString,
    IN      PCTSTR Context,
    IN      BOOL MustExistOnOtherPlatform
            TRACKING_DEF
    );
#define IsmCompressEnvironmentString(p,g,s,c,m) TrackedIsmCompressEnvironmentString(p,g,s,c,m TRACKING_CALL)

BOOL
WINAPI
IsmGetTransportVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    OUT     PTSTR KeyData,              OPTIONAL
    IN      UINT KeyDataBufferSizeInBytes
    );

BOOL
WINAPI
IsmSetTransportVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      PCTSTR KeyData
    );

ULONG_PTR
WINAPI
IsmSendMessageToApp (
    UINT Message,
    ULONG_PTR Arg
    );

MIG_PROGRESSSLICEID
WINAPI
IsmRegisterProgressSlice (
    IN      UINT Ticks,
    IN      UINT TimeEstimateInSeconds
    );

BOOL
WINAPI
IsmTickProgressBar (
    IN      MIG_PROGRESSSLICEID SliceId,
    IN      UINT TickDelta                  OPTIONAL
    );

#define IsmCheckCancel()    (IsmTickProgressBar(0,0)==FALSE)

BOOL
WINAPI
IsmCurrentlyExecuting (
    VOID
    );

VOID
WINAPI
IsmSetCancel (
    VOID
    );

//
// encoded strings support
//

MIG_OBJECTSTRINGHANDLE
WINAPI
TrackedIsmCreateObjectHandle (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
            TRACKING_DEF
    );
#define IsmCreateObjectHandle(n,l) TrackedIsmCreateObjectHandle(n,l TRACKING_CALL)

BOOL
WINAPI
TrackedIsmCreateObjectStringsFromHandleEx (
    IN      MIG_OBJECTSTRINGHANDLE Handle,
    OUT     PCTSTR *Node,               OPTIONAL
    OUT     PCTSTR *Leaf,               OPTIONAL
    IN      BOOL DoNotDecode
            TRACKING_DEF
    );

#define IsmCreateObjectStringsFromHandleEx(h,n,l,d) TrackedIsmCreateObjectStringsFromHandleEx(h,n,l,d TRACKING_CALL)
#define IsmCreateObjectStringsFromHandle(handle,node,leaf)  IsmCreateObjectStringsFromHandleEx(handle,node,leaf,FALSE)

BOOL
WINAPI
IsmIsObjectHandleNodeOnly (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    );

BOOL
WINAPI
IsmIsObjectHandleLeafOnly (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    );


VOID
WINAPI
IsmDestroyObjectString (
    IN      PCTSTR String
    );

VOID
WINAPI
IsmDestroyObjectHandle (
    IN      MIG_OBJECTSTRINGHANDLE Handle
    );

MIG_OBJECTSTRINGHANDLE
WINAPI
TrackedIsmCreateObjectPattern (
    IN      PMIG_SEGMENTS NodeSegments,     OPTIONAL
    IN      UINT NodeSegmentsNr,
    IN      PMIG_SEGMENTS LeafSegments,     OPTIONAL
    IN      UINT LeafSegmentsNr
            TRACKING_DEF
    );

#define IsmCreateObjectPattern(node,ncnt,leaf,lcnt) TrackedIsmCreateObjectPattern(node,ncnt,leaf,lcnt TRACKING_CALL)

MIG_OBJECTSTRINGHANDLE
WINAPI
TrackedIsmCreateSimpleObjectPattern (
    IN      PCTSTR BaseNode,                    OPTIONAL
    IN      BOOL EnumTree,
    IN      PCTSTR Leaf,                        OPTIONAL
    IN      BOOL LeafIsPattern
            TRACKING_DEF
    );

#define IsmCreateSimpleObjectPattern(base,tree,leaf,pat) TrackedIsmCreateSimpleObjectPattern(base,tree,leaf,pat TRACKING_CALL)

MIG_PARSEDPATTERN
IsmCreateParsedPattern (
    IN      MIG_OBJECTSTRINGHANDLE EncodedObject
    );

VOID
IsmDestroyParsedPattern (
    IN      MIG_PARSEDPATTERN ParsedPattern
    );

BOOL
WINAPI
IsmParsedPatternMatchEx (
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      MIG_OBJECTTYPEID ObjectTypeId,      OPTIONAL
    IN      PCTSTR Node,                        OPTIONAL
    IN      PCTSTR Leaf                         OPTIONAL
    );

BOOL
WINAPI
IsmParsedPatternMatch (
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN      MIG_OBJECTTYPEID ObjectTypeId,      OPTIONAL
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

//
// objects
//

MIG_OBJECTID
WINAPI
IsmGetObjectIdFromName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      BOOL MustExist
    );

VOID
WINAPI
IsmLockObjectId (
    IN      MIG_OBJECTID ObjectId
    );

VOID
WINAPI
IsmLockObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

MIG_OBJECTSTRINGHANDLE
WINAPI
IsmFilterObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     MIG_OBJECTTYPEID *NewObjectTypeId,          OPTIONAL
    OUT     PBOOL ObjectDeleted,                        OPTIONAL
    OUT     PBOOL ObjectReplaced                        OPTIONAL
    );

BOOL
WINAPI
IsmEnumFirstSourceObjectEx (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      BOOL EnumerateVirtualObjects
    );
#define IsmEnumFirstSourceObject(e,t,p) IsmEnumFirstSourceObjectEx(e,t,p,FALSE)

BOOL
WINAPI
IsmEnumFirstDestinationObjectEx (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      BOOL EnumerateVirtualObjects
    );
#define IsmEnumFirstDestinationObject(e,t,p) IsmEnumFirstDestinationObjectEx(e,t,p,FALSE)

BOOL
WINAPI
IsmEnumNextObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    );

VOID
WINAPI
IsmAbortObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    );

//
// persistence, apply, AbandonOnCollision, and NonCritical flags
//

BOOL
WINAPI
IsmMakePersistentObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmMakePersistentObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmClearPersistenceOnObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmClearPersistenceOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmIsPersistentObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmIsPersistentObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmEnumFirstPersistentObject (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmEnumNextPersistentObject (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortPersistentObjectEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmMakeApplyObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmMakeApplyObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmClearApplyOnObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmClearApplyOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmIsApplyObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmIsApplyObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmEnumFirstApplyObject (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmEnumNextApplyObject (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortApplyObjectEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmAbandonObjectIdOnCollision (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmAbandonObjectOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmClearAbandonObjectIdOnCollision (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmClearAbandonObjectOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmIsObjectIdAbandonedOnCollision (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmIsObjectAbandonedOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmMakeNonCriticalObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmMakeNonCriticalObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmClearNonCriticalFlagOnObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmClearNonCriticalFlagOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmIsNonCriticalObjectId (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmIsNonCriticalObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );



//
// attributes
//

MIG_ATTRIBUTEID
WINAPI
IsmRegisterAttribute (
    IN      PCTSTR AttributeName,
    IN      BOOL Private
    );

BOOL
WINAPI
IsmGetAttributeName (
    IN      MIG_ATTRIBUTEID AttributeId,
    OUT     PTSTR AttributeName,            OPTIONAL
    IN      UINT AttributeNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    );

MIG_ATTRIBUTEID
WINAPI
IsmGetAttributeGroup (
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmSetAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmSetAttributeOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    );

VOID
WINAPI
IsmLockAttribute (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmClearAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmClearAttributeOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmIsAttributeSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmIsAttributeSetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmEnumFirstObjectAttributeById (
    OUT     PMIG_OBJECTATTRIBUTE_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmEnumFirstObjectAttribute (
    OUT     PMIG_OBJECTATTRIBUTE_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmEnumNextObjectAttribute (
    IN OUT  PMIG_OBJECTATTRIBUTE_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectAttributeEnum (
    IN OUT  PMIG_OBJECTATTRIBUTE_ENUM EnumPtr
    );

BOOL
WINAPI
IsmEnumFirstObjectWithAttribute (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr,
    IN      MIG_ATTRIBUTEID AttributeId
    );

BOOL
WINAPI
IsmEnumNextObjectWithAttribute (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectWithAttributeEnum (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    );


//
// properties
//

MIG_PROPERTYID
WINAPI
IsmRegisterProperty (
    IN      PCTSTR PropertyName,
    IN      BOOL Private
    );

BOOL
WINAPI
IsmGetPropertyName (
    IN      MIG_PROPERTYID PropertyId,
    OUT     PTSTR PropertyName,             OPTIONAL
    IN      UINT PropertyNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    );

MIG_PROPERTYID
WINAPI
IsmGetPropertyGroup (
    IN      MIG_PROPERTYID PropertyId
    );

MIG_PROPERTYDATAID
WINAPI
IsmAddPropertyToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property
    );

MIG_PROPERTYDATAID
WINAPI
IsmAddPropertyToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId,
    IN      PCMIG_BLOB Property
    );

MIG_PROPERTYDATAID
WINAPI
IsmRegisterPropertyData (
    IN      PCMIG_BLOB Property
    );

BOOL
WINAPI
IsmAddPropertyDataToObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId,
    IN      MIG_PROPERTYDATAID PropertyDataId
    );

BOOL
WINAPI
IsmAddPropertyDataToObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId,
    IN      MIG_PROPERTYDATAID PropertyDataId
    );

VOID
WINAPI
IsmLockProperty (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmGetPropertyData (
    IN      MIG_PROPERTYDATAID PropertyDataId,
    OUT     PBYTE Buffer,                               OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT PropertyDataSize,                     OPTIONAL
    OUT     PMIG_BLOBTYPE PropertyDataType              OPTIONAL
    );

BOOL
WINAPI
IsmRemovePropertyData (
    IN      MIG_PROPERTYDATAID PropertyDataId
    );

BOOL
WINAPI
IsmRemovePropertyFromObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_PROPERTYDATAID PropertyId
    );

BOOL
WINAPI
IsmRemovePropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmIsPropertySetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmIsPropertySetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmEnumFirstObjectProperty (
    OUT     PMIG_OBJECTPROPERTY_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_PROPERTYID FilterProperty           OPTIONAL
    );

BOOL
WINAPI
IsmEnumFirstObjectPropertyById (
    OUT     PMIG_OBJECTPROPERTY_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID FilterProperty           OPTIONAL
    );

BOOL
WINAPI
IsmEnumNextObjectProperty (
    IN OUT  PMIG_OBJECTPROPERTY_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectPropertyEnum (
    IN OUT  PMIG_OBJECTPROPERTY_ENUM EnumPtr
    );

MIG_PROPERTYDATAID
WINAPI
IsmGetPropertyFromObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_PROPERTYID ObjectProperty
    );

MIG_PROPERTYDATAID
WINAPI
IsmGetPropertyFromObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_PROPERTYID ObjectProperty
    );

BOOL
WINAPI
IsmEnumFirstObjectWithProperty (
    OUT     PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr,
    IN      MIG_PROPERTYID PropertyId
    );

BOOL
WINAPI
IsmEnumNextObjectWithProperty (
    IN OUT  PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectWithPropertyEnum (
    IN OUT  PMIG_OBJECTWITHPROPERTY_ENUM EnumPtr
    );


//
// operations
//

MIG_OPERATIONID
WINAPI
IsmRegisterOperation (
    IN      PCTSTR Name,
    IN      BOOL Private
    );

BOOL
WINAPI
IsmGetOperationName (
    IN      MIG_OPERATIONID OperationId,
    OUT     PTSTR OperationName,            OPTIONAL
    IN      UINT OperationNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    );

MIG_OPERATIONID
WINAPI
IsmGetOperationGroup (
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmSetOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData      OPTIONAL
    );

BOOL
WINAPI
IsmSetOperationOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId,
    IN      PCMIG_BLOB SourceData,          OPTIONAL
    IN      PCMIG_BLOB DestinationData      OPTIONAL
    );

MIG_DATAHANDLE
WINAPI
IsmRegisterOperationData (
    IN      PCMIG_BLOB Data
    );

BOOL
WINAPI
IsmSetOperationOnObjectId2 (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    IN      MIG_DATAHANDLE SourceData,      OPTIONAL
    IN      MIG_DATAHANDLE DestinationData  OPTIONAL
    );

BOOL
WINAPI
IsmSetOperationOnObject2 (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId,
    IN      MIG_DATAHANDLE SourceData,      OPTIONAL
    IN      MIG_DATAHANDLE DestinationData  OPTIONAL
    );

VOID
WINAPI
IsmLockOperation (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmClearOperationOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmClearOperationOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmIsOperationSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmIsOperationSetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmGetObjectOperationDataById (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OPERATIONID OperationId,
    OUT     PBYTE Buffer,                   OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT BufferSizeNeeded,         OPTIONAL
    OUT     PMIG_BLOBTYPE Type,             OPTIONAL
    IN      BOOL DestinationData
    );

BOOL
WINAPI
IsmGetObjectOperationData (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      MIG_OPERATIONID OperationId,
    OUT     PBYTE Buffer,                   OPTIONAL
    IN      UINT BufferSize,
    OUT     PUINT BufferSizeNeeded,         OPTIONAL
    OUT     PMIG_BLOBTYPE Type,             OPTIONAL
    IN      BOOL DestinationData
    );


BOOL
WINAPI
IsmEnumFirstObjectOperationById (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId
    );

BOOL
WINAPI
IsmEnumFirstObjectOperation (
    OUT     PMIG_OBJECTOPERATION_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

BOOL
WINAPI
IsmEnumNextObjectOperation (
    IN OUT  PMIG_OBJECTOPERATION_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectOperationEnum (
    IN OUT  PMIG_OBJECTOPERATION_ENUM EnumPtr
    );

BOOL
WINAPI
IsmEnumFirstObjectWithOperation (
    OUT     PMIG_OBJECTWITHOPERATION_ENUM EnumPtr,
    IN      MIG_OPERATIONID OperationId
    );

BOOL
WINAPI
IsmEnumNextObjectWithOperation (
    IN OUT  PMIG_OBJECTWITHOPERATION_ENUM EnumPtr
    );

VOID
WINAPI
IsmAbortObjectWithOperationEnum (
    IN OUT  PMIG_OBJECTWITHOPERATION_ENUM EnumPtr
    );

BOOL
WINAPI
IsmRegisterOperationFilterCallback (
    IN      MIG_OPERATIONID OperationId,
    IN      POPMFILTERCALLBACK Callback,
    IN      BOOL TreeFilter,
    IN      BOOL HighPriority,
    IN      BOOL CanHandleNoRestore
    );

BOOL
WINAPI
IsmRegisterGlobalFilterCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR FunctionId,
    IN      POPMFILTERCALLBACK Callback,
    IN      BOOL TreeFilter,
    IN      BOOL CanHandleNoRestore
    );

BOOL
WINAPI
IsmRegisterOperationApplyCallback (
    IN      MIG_OPERATIONID OperationId,
    IN      POPMAPPLYCALLBACK Callback,
    IN      BOOL HighPriority
    );

BOOL
WINAPI
IsmRegisterGlobalApplyCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR FunctionId,
    IN      POPMAPPLYCALLBACK Callback
    );

//
// enumeration and object types
//

BOOL
WINAPI
IsmQueueEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_OBJECTENUMCALLBACK Callback,       OPTIONAL
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmHookEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_OBJECTENUMCALLBACK Callback,
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterStaticExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

BOOL
WINAPI
IsmRegisterDynamicExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_DYNAMICEXCLUSIONCALLBACK Callback,
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterPreEnumerationCallback (
    IN      PMIG_PREENUMCALLBACK Callback,
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterTypePreEnumerationCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_PREENUMCALLBACK Callback,
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterPostEnumerationCallback (
    IN      PMIG_POSTENUMCALLBACK Callback,
    IN      PCTSTR FunctionId                       OPTIONAL
    );

BOOL
WINAPI
IsmRegisterTypePostEnumerationCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_POSTENUMCALLBACK Callback,
    IN      PCTSTR FunctionId                       OPTIONAL
    );

MIG_OBJECTTYPEID
WINAPI
IsmGetObjectTypeId (
    IN      PCTSTR ObjectTypeName
    );

PCTSTR
WINAPI
IsmGetObjectTypeName (
    IN      MIG_OBJECTTYPEID TypeId
    );

UINT
WINAPI
IsmGetObjectTypePriority (
    IN      MIG_OBJECTTYPEID TypeId
    );

VOID
WINAPI
IsmExecuteHooks (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    );

//
// transport interface
//

BOOL
IsmDoesObjectExist (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

BOOL
WINAPI
IsmAcquireObjectEx (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    );

#define IsmAcquireObject(type,name,content)   IsmAcquireObjectEx(type,name,content,CONTENTTYPE_ANY,0)

BOOL
WINAPI
IsmReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    );

PMIG_CONTENT
IsmConvertObjectContentToUnicode (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

PMIG_CONTENT
IsmConvertObjectContentToAnsi (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

BOOL
IsmFreeConvertedObjectContent (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_CONTENT ObjectContent
    );

BOOL
WINAPI
IsmRegisterRestoreCallback (
    IN      PMIG_RESTORECALLBACK RestoreCallback
    );

BOOL
WINAPI
IsmRegisterCompareCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_COMPARECALLBACK CompareCallback
    );

BOOL
IsmAreObjectsIdentical (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PMIG_CONTENT SrcContent,
    IN      MIG_OBJECTTYPEID DestObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE DestObjectName,
    IN      PMIG_CONTENT DestContent,
    OUT     PBOOL DifferentDetailsOnly  OPTIONAL
    );

MIG_TRANSPORTSTORAGEID
WINAPI
IsmRegisterTransport (
    IN      PCTSTR TypeString
    );

BOOL
WINAPI
IsmGetMappedUserData (
    OUT     PMIG_USERDATA UserData
    );

BOOL
WINAPI
IsmAddControlFile (
    IN      PCTSTR ObjectName,
    IN      PCTSTR NativePath
    );

BOOL
WINAPI
IsmGetControlFile (
    MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      PTSTR Buffer
    );

BOOL
WINAPI
IsmSetRollbackJournalType (
    IN      BOOL Common
    );

BOOL
WINAPI
IsmCanWriteRollbackJournal (
    VOID
    );

BOOL
IsmDoesRollbackDataExist (
    OUT     PCTSTR *UserName,
    OUT     PCTSTR *UserDomain,
    OUT     PCTSTR *UserStringSid,
    OUT     PCTSTR *UserProfilePath,
    OUT     BOOL *UserProfileCreated
    );

VOID
WINAPI
IsmRecordOperation (
    IN      DWORD OperationType,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

BOOL
WINAPI
IsmRollback (
    VOID
    );

BOOL
IsmPreserveJournal (
    IN      BOOL Preserve
    );

BOOL
WINAPI
IsmSetDelayedOperationsCommand (
    IN      PCTSTR DelayedOperationsCommand
    );

VOID
IsmRecordDelayedOperation (
    IN      DWORD OperationType,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

PMIG_OBJECTCOUNT
IsmGetObjectsStatistics (
    IN      MIG_OBJECTTYPEID ObjectTypeId   OPTIONAL
    );

BOOL
IsmGetOsVersionInfo (
    IN      MIG_PLATFORMTYPEID Platform,
    OUT     PMIG_OSVERSIONINFO VersionInfo
    );

BOOL
IsmGetTempStorage (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    );

BOOL
IsmGetTempDirectory (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    );

BOOL
IsmGetTempFile (
    OUT     PTSTR Path,
    IN      UINT PathTchars
    );

BOOL
IsmExecuteFunction (
    IN      UINT ExecutionPhase,
    IN      PCTSTR FunctionMultiSz
    );

BOOL
IsmReplacePhysicalObject (
    IN    MIG_OBJECTTYPEID ObjectTypeId,
    IN    MIG_OBJECTSTRINGHANDLE ObjectName,
    IN    PMIG_CONTENT ObjectContent
    );

BOOL
IsmRemovePhysicalObject (
    IN    MIG_OBJECTTYPEID ObjectTypeId,
    IN    MIG_OBJECTSTRINGHANDLE ObjectName
    );

PCTSTR
IsmGetCurrentSidString (
    VOID
    );

//
// ANSI/UNICODE macros
//

// None


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\inc\modules.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    modules.h

Abstract:

    Base definitions for the Intermediate State Manager.

Author:

    Calin Negreanu (calinn) 15-Nov-1999

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Includes
//

#include "ism.h"

//
// Strings
//

// None

//
// Constants
//

// Priorities for the type IDs. This gives the order of
// processing and enumeration inside the engine.
#define PRIORITY_COOKIE         0x10000100
#define PRIORITY_PRINTER        0x10000200
#define PRIORITY_RASCONNECTION  0x10000300
#define PRIORITY_MAPPEDDRIVE    0x10000400
#define PRIORITY_NETSHARE       0x10000500
#define PRIORITY_CERTIFICATES   0x10000600

// messages from 0x0001 to 0x000F are reserved by the engine
#define TRANSPORTMESSAGE_IMAGE_EXISTS           0x0010
#define TRANSPORTMESSAGE_IMAGE_LOCKED           0x0011
#define TRANSPORTMESSAGE_SIZE_SAVED             0x0012
#define TRANSPORTMESSAGE_RMEDIA_SAVE            0x0013
#define TRANSPORTMESSAGE_RMEDIA_LOAD            0x0014
#define TRANSPORTMESSAGE_MULTIPLE_DESTS         0x0015          // return TRUE if multiple dests are resolved
#define TRANSPORTMESSAGE_READY_TO_CONNECT       0x0016
#define TRANSPORTMESSAGE_SRC_COPY_ERROR         0x0017
#define TRANSPORTMESSAGE_OLD_STORAGE            0x0018
#define TRANSPORTMESSAGE_NET_DISPLAY_PASSWORD   0x0019
#define TRANSPORTMESSAGE_NET_GATHER_PASSWORD    0x001A
#define MODULEMESSAGE_DISPLAYERROR              0x001B
#define MODULEMESSAGE_DISPLAYWARNING            0x001C
#define MODULEMESSAGE_ASKQUESTION               0x001D

#define APPRESPONSE_NONE                    0
#define APPRESPONSE_SUCCESS                 1
#define APPRESPONSE_FAIL                    2
#define APPRESPONSE_IGNORE                  3

//
// Known attributes
//

#define S_ATTRIBUTE_FIXEDPATH           TEXT("FixedPath")
#define S_OBJECTTYPE_FILE               TEXT("File")
#define S_OBJECTTYPE_REGISTRY           TEXT("Registry")
#define S_ATTRIBUTE_V1                  TEXT("v1")
#define S_ATTRIBUTE_OSFILE              TEXT("OSFILE")
#define S_ATTRIBUTE_COPYIFRELEVANT      TEXT("CopyIfRelevant")
#define S_ATTRIBUTE_PARTITIONLOCK       TEXT("PartitionLock")

//
// Known properties
//

#define S_PROPERTY_FILEMOVE             TEXT("Move.FileMove")
#define S_PROPERTY_FILEMOVE_HINT        TEXT("Move.FileMove.Hint")

//
// known operations
//

#define S_OPERATION_MOVE                TEXT("Move.General")
#define S_OPERATION_INIMOVE             TEXT("Move.INI")
#define S_OPERATION_ENHANCED_MOVE       TEXT("Move.Ex")
#define S_OPERATION_ENHANCED_INIMOVE    TEXT("Move.INIEx")
#define S_OPERATION_V1_FILEMOVEEX       TEXT("Move.V1FileMoveEx")
#define S_OPERATION_V1_FILEMOVE         TEXT("Move.V1FileMove")
#define S_OPERATION_ENHANCED_FILEMOVE   TEXT("Move.FileMoveEx")
#define S_OPERATION_PARTITION_MOVE      TEXT("Move.Partition")
#define S_OPERATION_DELETE              TEXT("Delete")
#define S_OPERATION_LNKMIG_FIXCONTENT   TEXT("Content.LnkMigFixContent")
#define S_OPERATION_DEFICON_FIXCONTENT  TEXT("Content.DefaultIcon")
#define S_OPERATION_DRIVEMAP_FIXCONTENT TEXT("Content.MappedDrive")
#define S_OPERATION_DESTADDOBJ          TEXT("Content.DestAddObject")
#define S_OPERATION_REG_AUTO_FILTER     TEXT("Content.RegAutoFilter")
#define S_OPERATION_INI_AUTO_FILTER     TEXT("Content.INIAutoFilter")

//
// known environment groups
//

#define S_SYSENVVAR_GROUP               TEXT("SysEnvVar")

//
// v1 functionality attributes and environment variables
//

#define S_GLOBAL_INF_HANDLE             TEXT("GlobalInfHandle")
#define S_ENV_HKCU_V1                   TEXT("HKCU_V1")
#define S_ENV_HKCU_ON                   TEXT("HKCU_ON")
#define S_ENV_HKLM_ON                   TEXT("HKLM_ON")
#define S_ENV_ALL_FILES                 TEXT("FILES_ON")
#define S_INF_FILE_MULTISZ              TEXT("INF_FILES")
#define S_ENV_CREATE_USER               TEXT("CreateUser")
#define S_ENV_ICONLIB                   TEXT("IconLib")
#define S_ENV_SAVE_ICONLIB              TEXT("SaveIconLib")
#define S_ENV_DEST_DELREG               TEXT("DelDestReg")
#define S_ENV_DEST_DELREGEX             TEXT("DelDestRegEx")
#define S_ENV_DEST_RESTORE              TEXT("RestoreCallback")
#define S_ENV_SCRIPT_EXECUTE            TEXT("ScriptExecute")
#define S_ENV_DEST_ADDOBJECT            TEXT("DestAddObject")
#define S_ENV_DEST_CHECKDETECT          TEXT("DestCheckDetect")
#define S_ENV_APPLIED_DPI               TEXT("AppliedDPI")

//
// module-to-app environment variables
//

#define S_REQUIRE_DOMAIN_USER           TEXT("RequireDomainUser")

// component groups
#define COMPONENT_NAME                  5
#define COMPONENT_SUBCOMPONENT          4
#define COMPONENT_EXTENSION             3
#define COMPONENT_FILE                  2
#define COMPONENT_FOLDER                1

//
// strings shared between apps
//

#define S_INF_OBJECT_NAME               TEXT("inf")

//
// Macros
//

// None

//
// Types
//

//
// Types for errors to be presented to the user
//

typedef enum {
    ERRUSER_ERROR_UNKNOWN = 0,          // Unknown error
    ERRUSER_ERROR_NOTRANSPORTPATH,      // Transport path is not selected. Don't know where to write or where to read from
    ERRUSER_ERROR_TRANSPORTPATHBUSY,    // Transport path is in use. Cannot save there.
    ERRUSER_ERROR_CANTEMPTYDIR,         // USMT dir inside transport path could not be erased.
    ERRUSER_ERROR_ALREADYEXISTS,        // USMT dir inside transport path already exists. Cannot override.
    ERRUSER_ERROR_CANTCREATEDIR,        // USMT dir inside transport path could not be created.
    ERRUSER_ERROR_CANTCREATESTATUS,     // USMT status file inside transport path could not be created.
    ERRUSER_ERROR_CANTCREATETEMPDIR,    // Transport can't create temp dir to prepare for save.
    ERRUSER_ERROR_CANTCREATECABFILE,    // Transport can't create cabinet file to prepare for save.
    ERRUSER_ERROR_CANTSAVEOBJECT,       // Transport can't save a particular object
    ERRUSER_ERROR_CANTSAVEINTERNALDATA, // Transport can't save it's internal data
    ERRUSER_ERROR_CANTWRITETODESTPATH,  // Transport can't write to destination path
    ERRUSER_ERROR_TRANSPORTINVALIDIMAGE,// Transport image is invalid. Cannot read data.
    ERRUSER_ERROR_CANTOPENSTATUS,       // USMT status file inside transport path could not be opened.
    ERRUSER_ERROR_CANTREADIMAGE,        // Transport can't read the saved image. The image may be corrupt.
    ERRUSER_ERROR_CANTFINDDESTINATION,  // HomeNet transport can't find the destination machine
    ERRUSER_ERROR_CANTSENDTODEST,       // HomeNet transport can't send to the destination machine
    ERRUSER_ERROR_CANTFINDSOURCE,       // HomeNet transport can't find the source machine
    ERRUSER_ERROR_CANTRECEIVEFROMSOURCE,// HomeNet transport can't receive from the source machine
    ERRUSER_ERROR_INVALIDDATARECEIVED,  // HomeNet transport received invalid data from the source machine
    ERRUSER_ERROR_CANTUNPACKIMAGE,      // Transport can't unpack loaded image. This might be a disk space problem.
    ERRUSER_ERROR_CANTRESTOREOBJECT,    // Failed to restore some object on the destination machine.
    ERRUSER_ERROR_DISKSPACE,            // The user might not have enough disk space.
    ERRUSER_ERROR_NOENCRYPTION,         // There is no encryption available. HomeNet won't work.
    ERRUSER_WARNING_OUTLOOKRULES,       // The user must retouch their Outlook message rules.
    ERRUSER_WARNING_OERULES,            // The user must retouch their Outlook Express message rules.
} ERRUSER_ERROR, *PERRUSER_ERROR;

typedef enum {
    ERRUSER_AREA_UNKNOWN = 0,
    ERRUSER_AREA_INIT,
    ERRUSER_AREA_GATHER,
    ERRUSER_AREA_SAVE,
    ERRUSER_AREA_LOAD,
    ERRUSER_AREA_RESTORE,
} ERRUSER_AREA, *PERRUSER_AREA;

typedef struct {
    ERRUSER_ERROR Error;
    ERRUSER_AREA ErrorArea;
    MIG_OBJECTTYPEID ObjectTypeId;
    MIG_OBJECTSTRINGHANDLE ObjectName;
} ERRUSER_EXTRADATA, *PERRUSER_EXTRADATA;

typedef struct {
    PSTR Key;
    UINT KeySize;
    HANDLE Event;
} PASSWORD_DATA, *PPASSWORD_DATA;

typedef struct {
    PCTSTR Question;
    UINT MessageStyle;
    INT WantedResult;
} QUESTION_DATA, *PQUESTION_DATA;

// These are the subphases for the transport phase. They are
// used to update the app about the transport modules status.
#define SUBPHASE_CONNECTING1    1
#define SUBPHASE_CONNECTING2    2
#define SUBPHASE_NETPREPARING   3
#define SUBPHASE_PREPARING      4
#define SUBPHASE_COMPRESSING    5
#define SUBPHASE_TRANSPORTING   6
#define SUBPHASE_MEDIAWRITING   7
#define SUBPHASE_FINISHING      8
#define SUBPHASE_CABLETRANS     9
#define SUBPHASE_UNCOMPRESSING  10

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Public function declarations
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\inc\trans.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    trans.h

Abstract:

    Provides constants for interacting with the transport module.

    This is primarily used to pass transport messages to the app layer.

Author:

    Jim Schmidt (jimschm) 26-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Includes
//

// None

#define DBG_FOO     "Foo"

//
// Strings
//

#define S_RELIABLE_STORAGE_TRANSPORT    TEXT("RELIABLE_STORAGE_TRANSPORT")
#define S_COMPRESSED_TRANSPORT          TEXT("COMPRESSED_TRANSPORT")
#define S_REMOVABLE_MEDIA_TRANSPORT     TEXT("REMOVABLE_MEDIA_TRANSPORT")
#define S_HOME_NETWORK_TRANSPORT        TEXT("HOME_NETWORK_TRANSPORT")
#define S_DIRECT_CABLE_TRANSPORT        TEXT("DIRECT_CABLE_TRANSPORT")

//
// Constants
//

#define TRANSPORT_ENVVAR_RMEDIA_DISKNR          TEXT("RemovableMediaTransport:NextDiskNumber")
#define TRANSPORT_ENVVAR_HOMENET_DESTINATIONS   TEXT("HomeNetDestinationNames")
#define TRANSPORT_ENVVAR_HOMENET_TAG            TEXT("HomeNetTag")

#define CAPABILITY_COMPRESSED               0x00000001
#define CAPABILITY_ENCRYPTED                0x00000002
#define CAPABILITY_AUTOMATED                0x00000004
#define CAPABILITY_SPACEESTIMATE            0x00000008

//
// Macros
//

// None

//
// Types
//

typedef enum {
    RMEDIA_ERR_NOERROR = 0,
    RMEDIA_ERR_GENERALERROR,
    RMEDIA_ERR_WRONGMEDIA,
    RMEDIA_ERR_OLDMEDIA,
    RMEDIA_ERR_USEDMEDIA,
    RMEDIA_ERR_DISKFULL,
    RMEDIA_ERR_NOTREADY,
    RMEDIA_ERR_WRITEPROTECT,
    RMEDIA_ERR_CRITICAL,
} RMEDIA_ERR, *PRMEDIA_ERR;

typedef struct {
    RMEDIA_ERR LastError;
    DWORD MediaNumber;
    ULONGLONG TotalImageSize;
    ULONGLONG TotalImageWritten;
} RMEDIA_EXTRADATA, *PRMEDIA_EXTRADATA;

typedef struct {
    PCTSTR ObjectType;
    PCTSTR ObjectName;
    DWORD Error;
} TRANSCOPY_ERROR, *PTRANSCOPY_ERROR;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\inc\v2app.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    v2app.h

Abstract:

    Constants used to communicate with the v2 app layer.

Author:

    Jim Schmidt (jimschm) 24-May-2000

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Includes
//

#include "ism.h"
#include "trans.h"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Public function declarations
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\entry.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the DLL entry point that provides all Cobra module entry points
    to the engine.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "guitrans.h"

typedef struct {
    PCTSTR Name;
    TRANSPORT_ENTRYPOINTS EntryPoints;
} TRANSPORT_TABLE, *PTRANSPORT_TABLE;

#define NOPROGBAR NULL
#define NORESET NULL
#define NORESUME NULL

//
// Add an entry for each transport module in the DLL
//

TRANSPORT_TABLE g_TransportEntryPoints[] = {
    {   TEXT("REMOVABLE_MEDIA"), ISM_VERSION,
        RmvMedTransportInitialize,
        RmvMedTransportEstimateProgressBar,
        RmvMedTransportQueryCapabilities,
        RmvMedTransportSetStorage,
        NORESET,
        RmvMedTransportTerminate,
        RmvMedTransportSaveState,
        NORESUME,
        RmvMedTransportBeginApply,
        NORESUME,
        RmvMedTransportAcquireObject,
        RmvMedTransportReleaseObject,
        RmvMedTransportEndApply
    },

    {   TEXT("DIRECT_CABLE"), ISM_VERSION,
        DirectCableTransportInitialize,
        DirectCableTransportEstimateProgressBar,
        DirectCableTransportQueryCapabilities,
        DirectCableTransportSetStorage,
        NORESET,
        DirectCableTransportTerminate,
        DirectCableTransportSaveState,
        NORESUME,
        DirectCableTransportBeginApply,
        NORESUME,
        DirectCableTransportAcquireObject,
        DirectCableTransportReleaseObject,
        DirectCableTransportEndApply
    },

    {   TEXT("HOME_NETWORKING"), ISM_VERSION,
        HomeNetTransportInitialize,
        HomeNetTransportEstimateProgressBar,
        HomeNetTransportQueryCapabilities,
        HomeNetTransportSetStorage,
        HomeNetTransportResetStorage,
        HomeNetTransportTerminate,
        HomeNetTransportSaveState,
        NORESUME,
        HomeNetTransportBeginApply,
        NORESUME,
        HomeNetTransportAcquireObject,
        HomeNetTransportReleaseObject,
        HomeNetTransportEndApply
    },

    {   TEXT("OPAQUE_UNC_TRANSPORT"), ISM_VERSION,
        OpaqueTransportInitialize,
        OpaqueTransportEstimateProgressBar,
        OpaqueTransportQueryCapabilities,
        OpaqueTransportSetStorage,
        NORESET,
        OpaqueTransportTerminate,
        OpaqueTransportSaveState,
        NORESUME,
        OpaqueTransportBeginApply,
        NORESUME,
        OpaqueTransportAcquireObject,
        OpaqueTransportReleaseObject,
        OpaqueTransportEndApply
    },

    {NULL}
};

EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }

    return TRUE;
}


EXPORT
BOOL
WINAPI
ModuleInitialize (
    VOID
    )
{
    TCHAR memDbDir[MAX_PATH];

    UtInitialize (NULL);
    RegInitialize ();

    IsmGetTempDirectory (memDbDir, ARRAYSIZE (memDbDir));
    if (!MemDbInitializeEx (memDbDir)) {
        IsmSetCancel();
        return FALSE;
    }

    return TRUE;
}

EXPORT
VOID
WINAPI
ModuleTerminate (
    VOID
    )
{
    MemDbTerminateEx (TRUE);
    RegTerminate();
    UtTerminate ();
}


BOOL
WINAPI
pFindModule (
    IN      PCTSTR ModuleId,
    OUT     PVOID IsmBuffer,
    IN      PCTSTR *TableEntry,
    IN      UINT StructureSize
    )
{

    while (*TableEntry) {
        if (StringIMatch (*TableEntry, ModuleId)) {
            CopyMemory (
                IsmBuffer,
                (PBYTE) (TableEntry + 1),
                StructureSize
                );
            return TRUE;
        }

        TableEntry = (PCTSTR *) ((PBYTE) (TableEntry + 1) + StructureSize);
    }

    return FALSE;
}



EXPORT
BOOL
WINAPI
TransportModule (
    IN      PCTSTR ModuleId,
    IN OUT  PTRANSPORT_ENTRYPOINTS TransportEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) TransportEntryPoints,
                (PCTSTR *) g_TransportEntryPoints,
                sizeof (TRANSPORT_ENTRYPOINTS)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\direct.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    direct.c

Abstract:

    Implements a transport module that works with serial and parallel ports

Author:

    Calin Negreanu (calinn) 14-Apr-2001

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <compress.h>

#define DBG_DIRECT    "DIRECT"

//
// Strings
//

#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_DEST_FILE   TEXT("USMT2IMG.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")
#define S_UNCOMPRESSED_FILE     TEXT("TEMPFILE.DAT")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//
#define TRFLAG_FILE         0x01
#define TRFLAG_MEMORY       0x02
#define COPY_BUFFER_SIZE    32768
#define DIRECTTR_CONVSIG    0x55534D33  //USM3
#define DIRECTTR_SIG        0x55534D34  //USM4
#define DIRECT_BUFFER_SIZE  1024

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

typedef struct {
    DWORD Signature;
    DWORD NumberOfFiles;
    LONGLONG TotalImageSize;
} HEADER1, *PHEADER1;

typedef struct {
    DWORD FileNumber;
    LONGLONG FileSize;
} HEADER2, *PHEADER2;

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_DirectCableId;
UINT g_DirectCablePlatform;
PCTSTR g_DirectCablePath = NULL;
PCTSTR g_DirectCableTempPath = NULL;
DWORD g_DirectCableBaudRate = 0;
MIG_PROGRESSSLICEID g_PersistentSlice;
MIG_PROGRESSSLICEID g_DatabaseSlice;
UINT g_CompressedTicks;
UINT g_CompressedTicked;
MIG_PROGRESSSLICEID g_CompressedSlice;
UINT g_DownloadTicks;
UINT g_DownloadTicked;
MIG_PROGRESSSLICEID g_DownloadSlice;
UINT g_UncompressTicks;
UINT g_UncompressTicked;
MIG_PROGRESSSLICEID g_UncompressSlice;
LONGLONG g_TotalFiles;
LONGLONG g_FilesRead;
DWORD g_BaudRate [] = {CBR_256000,
                       CBR_128000,
                       CBR_115200,
                       CBR_57600,
                       CBR_56000,
                       CBR_38400,
                       CBR_19200,
                       CBR_14400,
                       CBR_9600,
                       CBR_4800,
                       CBR_2400,
                       CBR_1200,
                       CBR_600,
                       CBR_300,
                       CBR_110,
                       0};

DWORD g_StartTicks = 0;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pDCCleanupTempDir (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
WINAPI
DirectCableTransportInitialize (
    PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_DirectCableId = IsmRegisterTransport (S_DIRECT_CABLE_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
DirectCableTransportTerminate (
    VOID
    )
{
    pDCCleanupTempDir ();

    if (g_DirectCableTempPath) {
        FreePathString (g_DirectCableTempPath);
        g_DirectCableTempPath = NULL;
    }
    if (g_DirectCablePath) {
        FreePathString (g_DirectCablePath);
        g_DirectCablePath = NULL;
    }
}

VOID
WINAPI
DirectCableTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on the count of the
        // persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        g_DatabaseSlice = IsmRegisterProgressSlice (3, 1);

        g_CompressedTicks = ticks;

        g_CompressedSlice = IsmRegisterProgressSlice (g_CompressedTicks, max (1, g_CompressedTicks / 5));
    } else {
        g_DownloadTicked = 0;
        g_DownloadTicks = 1000;
        g_DownloadSlice = IsmRegisterProgressSlice (g_DownloadTicks, 180);
        g_UncompressTicked = 0;
        g_UncompressTicks = 1000;
        g_UncompressSlice = IsmRegisterProgressSlice (g_UncompressTicks, 180);
    }
}

BOOL
WINAPI
DirectCableTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_DirectCableId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED;
    *FriendlyDescription = TEXT("Direct Cable");
    return TRUE;
}

VOID
pDCCleanupTempDir (
    VOID
    )
{
    if (g_DirectCableTempPath) {
        FiRemoveAllFilesInTree (g_DirectCableTempPath);
    }
}

PCTSTR
pDCCreateTemporaryDir (
    VOID
    )
{
    TCHAR tempFile[MAX_PATH];

    if (!IsmGetTempDirectory (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }
    return DuplicatePathString (tempFile, 0);
}

BOOL
WINAPI
DirectCableTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    BOOL result = FALSE;
    PTSTR baudRatePtr = NULL;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_DirectCableId) {

        if ((!RequiredCapabilities) || (RequiredCapabilities == CAPABILITY_COMPRESSED)) {

            if (g_DirectCablePath) {
                FreePathString (g_DirectCablePath);
                g_DirectCablePath = NULL;
            }
            g_DirectCablePath = DuplicatePathString (StoragePath, 0);
            baudRatePtr = _tcschr (g_DirectCablePath, TEXT(':'));
            if (baudRatePtr) {
                *baudRatePtr = 0;
                baudRatePtr ++;
                g_DirectCableBaudRate = _ttoi (baudRatePtr);
            }

            if (Valid) {
                *Valid = TRUE;
            }

            if (ImageExists) {
                if (Platform == PLATFORM_SOURCE) {
                    *ImageExists = FALSE;
                } else {
                    *ImageExists = TRUE;
                }
            }

            result = TRUE;
        }
    }
    return result;
}

PCTSTR
pDCBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    PCTSTR typeStr;

    typeStr = IsmGetObjectTypeName (ObjectTypeId);
    if (!typeStr) {
        return NULL;
    }

    return JoinPaths (typeStr, ObjectName);
}

VOID
pDCDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pDCSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

    FreeText (key);

    return b;
}

PCTSTR
pDCAllocStorageFileName (
    VOID
    )
{
    static UINT fileIndex = 0;
    TCHAR buffer [32];

    fileIndex ++;
    wsprintf (buffer, TEXT("%08X.DAT"), fileIndex);

    return DuplicatePathString (buffer, 0);
}

BOOL
pDCSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT ObjectValue
    )
{
    BOOL result = FALSE;

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (ObjectValue->MemoryContent.ContentBytes && ObjectValue->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            ObjectValue->MemoryContent.ContentBytes,
            ObjectValue->MemoryContent.ContentSize
            );
    }

    result = pDCSaveDetails (DecoratedObject, &ObjectValue->Details);

    return result;
}

BOOL
pDCAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR StoredName,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    return CompressAddFileToHandle (FileName, StoredName, CompressedHandle);
}

BOOL
pDCSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;
    DWORD attributes = INVALID_ATTRIBUTES;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use the CopyFile API to move the file from local to storage.
    //

    __try {
        if (Content && (Content->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) && Content->Details.DetailsData) {
            attributes = ((PWIN32_FIND_DATAW)Content->Details.DetailsData)->dwFileAttributes;
        }
        if ((attributes != INVALID_ATTRIBUTES) && (attributes & FILE_ATTRIBUTE_DIRECTORY)) {

            // this must be a directory, let's just write the key

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }
            result = TRUE;

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = pDCAllocStorageFileName ();
            if (!destPath) {
                __leave;
            }

            if (!pDCAddFileToImage (Content->FileContent.ContentPath, destPath, CompressedHandle)) {
                __leave;
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, destPath, 0)) {
                __leave;
            }

            FreePathString (destPath);
            destPath = NULL;
        }

        //
        // Save details
        //

        result = pDCSaveDetails (DecoratedObject, &(Content->Details));
    }
    __finally {
        if (destPath) {
            FreePathString (destPath);
            destPath = NULL;
        }
    }

    return result;
}

PCTSTR
pDCGetImageFile (
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (g_DirectCableTempPath, imageFileName);
}

HANDLE
pDCOpenAndSetPort (
    IN      PCTSTR ComPort
    )
{
    HANDLE result = INVALID_HANDLE_VALUE;
    COMMTIMEOUTS commTimeouts;
    DCB dcb;

    // let's open the port. If we can't we just exit with error;
    result = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (result == INVALID_HANDLE_VALUE) {
        return result;
    }

    // we want 3 sec timeout for both read and write
    commTimeouts.ReadIntervalTimeout = 0;
    commTimeouts.ReadTotalTimeoutMultiplier = 0;
    commTimeouts.ReadTotalTimeoutConstant = 3000;
    commTimeouts.WriteTotalTimeoutMultiplier = 0;
    commTimeouts.WriteTotalTimeoutConstant = 3000;
    SetCommTimeouts (result, &commTimeouts);

    // let's set some comm state data
    if (GetCommState (result, &dcb)) {
        dcb.fBinary = 1;
        dcb.fParity = 1;
        dcb.ByteSize = 8;
        dcb.fOutxCtsFlow = 1;
        dcb.fTXContinueOnXoff = 1;
        dcb.fRtsControl = 2;
        dcb.fAbortOnError = 1;
        dcb.Parity = 0;
        dcb.BaudRate = g_DirectCableBaudRate?g_DirectCableBaudRate:CBR_115200;
        if (!SetCommState (result, &dcb)) {
            CloseHandle (result);
            result = INVALID_HANDLE_VALUE;
            return result;
        }
    } else {
        CloseHandle (result);
        result = INVALID_HANDLE_VALUE;
        return result;
    }

    return result;
}

#define ACK         0x16
#define NAK         0x15
#define SOH         0x01
#define EOT         0x04
#define BLOCKSIZE   1024

BOOL
pDCSendFileToHandle (
    IN      HANDLE DeviceHandle,
    IN      PCTSTR FileName,
    IN OUT  ULONGLONG *TotalImageWritten,
    IN      ULONGLONG TotalImageSize
    )
{
    HANDLE fileHandle = NULL;
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 0;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = FALSE;
    UINT index;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;
    UINT elapsedTicks;
    UINT estimatedTime;
    UINT percent, percent100;
    UINT hour, minute, second;
    MIG_APPINFO appInfo;
    PCTSTR statusMsg;
    PCTSTR argArray[5];

    fileHandle = BfOpenReadFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    if (!g_StartTicks) {
        g_StartTicks = GetTickCount ();
    }

    // finally let's start the protocol

    // We are going to listen for the NAK(15h) signal.
    // As soon as we get it we are going to send a 4 + BLOCKSIZE bytes block having:
    // 1 byte - SOH (01H)
    // 1 byte - block number
    // 1 byte - FF - block number
    // BLOCKSIZE bytes of data
    // 1 byte - checksum - sum of all BLOCKSIZE bytes of data
    // After the block is sent, we are going to wait for ACK(16h). If we don't get
    // it after timeout or if we get something else we are going to send the block again.

    // wait for NAK
    while ((!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
            (numRead != 1) ||
            (signal != NAK)
            ) &&
           (!IsmCheckCancel ())
           );

    repeat = FALSE;
    while (TRUE) {

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (!repeat) {
            // prepare the next block
            currBlock ++;
            if (currBlock == 0) {
                result = TRUE;
            }
            buffer [0] = SOH;
            buffer [1] = currBlock;
            buffer [2] = 0xFF - currBlock;
            if (!ReadFile (fileHandle, buffer + 3, BLOCKSIZE, &numRead, NULL) ||
                (numRead == 0)
                ) {
                // we are done with data, send the EOT signal
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
                break;
            }

            if (TotalImageWritten) {
                *TotalImageWritten += numRead;
            }
            // compute the checksum
            buffer [sizeof (buffer) - 1] = 0;
            signal = 0;
            for (index = 0; index < sizeof (buffer) - 1; index ++) {
                signal += buffer [index];
            }
            buffer [sizeof (buffer) - 1] = signal;
        }

        // now send the block to the other side
        if (!WriteFile (DeviceHandle, buffer, sizeof (buffer), &numWritten, NULL) ||
            (numWritten != sizeof (buffer))
            ) {
            repeat = TRUE;
        } else {
            repeat = FALSE;
        }

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // we could not send the data last time
            // let's just wait for a NAK for 10 sec and then send it again
            ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL);
        } else {
            // we sent it OK. We need to wait for an ACK to come. If we timeout
            // or we get something else, we will repeat the block.
            if (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
                (numRead != sizeof (signal)) ||
                (signal != ACK)
                ) {
                repeat = TRUE;
            }
            if (!repeat) {
                if (TotalImageWritten) {
                    // now update the progress bar
                    numerator = (LONGLONG) (*TotalImageWritten) * (LONGLONG) g_CompressedTicks;
                    divisor = (LONGLONG) TotalImageSize;
                    if (divisor) {
                        tick = numerator / divisor;
                    } else {
                        tick = 0;
                    }
                    delta = (UINT) tick - g_CompressedTicked;
                    if (delta) {
                        IsmTickProgressBar (g_CompressedSlice, delta);
                        g_CompressedTicked += delta;
                    }
                    // now update the estimated time and %
                    elapsedTicks = GetTickCount () - g_StartTicks;
                    estimatedTime = (UINT)(TotalImageSize * elapsedTicks / (*TotalImageWritten)) - elapsedTicks;
                    percent100 = (UINT)((*TotalImageWritten) * 10000 / TotalImageSize);
                    percent = percent100 / 100;
                    percent100 = percent100 - (percent * 100);
                    if (elapsedTicks > 45000) { // after about 45 seconds
                        // let's send the message to the app
                        hour = estimatedTime / 3600000;
                        minute = estimatedTime / 60000 - hour * 60;
                        second = estimatedTime / 1000 - hour * 3600 - minute * 60;

                        argArray[0] = (PCTSTR) (UINT_PTR) (percent);
                        argArray[1] = (PCTSTR) (UINT_PTR) (percent100);
                        argArray[2] = (PCTSTR) (UINT_PTR) (hour);
                        argArray[3] = (PCTSTR) (UINT_PTR) (minute);
                        argArray[4] = (PCTSTR) (UINT_PTR) (second);
                        statusMsg = ParseMessageID (MSG_TRANSFER_INFO, argArray);

                        if (statusMsg) {
                            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                            appInfo.Phase = MIG_TRANSPORT_PHASE;
                            appInfo.SubPhase = SUBPHASE_CABLETRANS;
                            appInfo.Text = statusMsg;
                            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));
                            FreeStringResource (statusMsg);
                        }
                    }
                }
            }
        }
    }

    if (result) {
        // we are done here. However, let's listen one more timeout for a
        // potential NAK. If we get it, we'll repeat the EOT signal
        while (ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) &&
            (numRead == 1)
            ) {
            if (signal == NAK) {
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
            }
        }
    }

    CloseHandle (fileHandle);

    return result;
}

BOOL
pDCSendFile (
    IN      PCTSTR ComPort,
    IN      PCTSTR FileName,
    IN OUT  ULONGLONG *TotalImageWritten,
    IN      ULONGLONG TotalImageSize
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    deviceHandle = pDCOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pDCSendFileToHandle (deviceHandle, FileName, TotalImageWritten, TotalImageSize);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pDCSendBlockToHandle (
    IN      HANDLE DeviceHandle,
    IN      PCBYTE Buffer
    )
{
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 0;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = FALSE;
    UINT index;

    // let's start the protocol

    // We are going to listen for the NAK(15h) signal.
    // As soon as we get it we are going to send a 4 + BLOCKSIZE bytes block having:
    // 1 byte - SOH (01H)
    // 1 byte - block number
    // 1 byte - FF - block number
    // BLOCKSIZE bytes of data
    // 1 byte - checksum - sum of all BLOCKSIZE bytes of data
    // After the block is sent, we are going to wait for ACK(16h). If we don't get
    // it after timeout or if we get something else we are going to send the block again.

    // wait for NAK
    while ((!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
            (numRead != 1) ||
            (signal != NAK)
            ) &&
           (!IsmCheckCancel ())
           );

    repeat = FALSE;
    while (TRUE) {

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (!repeat) {
            // prepare the next block
            currBlock ++;
            if (currBlock == 0) {
                result = TRUE;
            }
            buffer [0] = SOH;
            buffer [1] = currBlock;
            buffer [2] = 0xFF - currBlock;
            CopyMemory (buffer + 3, Buffer, BLOCKSIZE);

            // compute the checksum
            buffer [sizeof (buffer) - 1] = 0;
            signal = 0;
            for (index = 0; index < sizeof (buffer) - 1; index ++) {
                signal += buffer [index];
            }
            buffer [sizeof (buffer) - 1] = signal;
        }

        // now send the block to the other side
        if (!WriteFile (DeviceHandle, buffer, sizeof (buffer), &numWritten, NULL) ||
            (numWritten != sizeof (buffer))
            ) {
            repeat = TRUE;
        } else {
            repeat = FALSE;
        }

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // we could not send the data last time
            // let's just wait for a NAK for 10 sec and then send it again
            ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL);
        } else {
            // we sent it OK. We need to wait for an ACK to come. If we timeout
            // or we get something else, we will repeat the block.
            if (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
                (numRead != sizeof (signal)) ||
                (signal != ACK)
                ) {
                repeat = TRUE;
            } else {
                // we are done with data, send the EOT signal
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
                break;
            }
        }
    }

    if (result) {
        // we are done here. However, let's listen one more timeout for a
        // potential NAK. If we get it, we'll repeat the EOT signal
        while (ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) &&
            (numRead == 1)
            ) {
            if (signal == NAK) {
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
            }
        }
    }

    return result;
}

BOOL
pDCSendBlock (
    IN      PCTSTR ComPort,
    IN      PCBYTE Buffer
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    // Buffer must have BLOCKSIZE size

    deviceHandle = pDCOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pDCSendBlockToHandle (deviceHandle, Buffer);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pDCReceiveFileFromHandle (
    IN      HANDLE DeviceHandle,
    IN      PCTSTR FileName,
    IN      LONGLONG FileSize,
    IN OUT  ULONGLONG *TotalImageRead,
    IN      ULONGLONG TotalImageSize
    )
{
    HANDLE fileHandle = NULL;
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 1;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = TRUE;
    UINT index;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;
    UINT elapsedTicks;
    UINT estimatedTime;
    UINT percent, percent100;
    UINT hour, minute, second;
    MIG_APPINFO appInfo;
    PCTSTR statusMsg;
    PCTSTR argArray[5];

    fileHandle = BfCreateFile (FileName);
    if (!fileHandle) {
        return FALSE;
    }

    if (!g_StartTicks) {
        g_StartTicks = GetTickCount ();
    }

    // finally let's start the protocol

    // We are going to send an NAK(15h) signal.
    // After that we are going to listen for a block.
    // If we don't get the block in time, or the block is wrong size
    // or it has a wrong checksum we are going to send a NAK signal,
    // otherwise we are going to send an ACK signal
    // One exception. If the block size is 1 and the block is actually the
    // EOT signal it means we are done.

    while (TRUE) {

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // send the NAK
            signal = NAK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        } else {
            // send the ACK
            signal = ACK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        repeat = TRUE;
        // let's read the data block
        if (ReadFile (DeviceHandle, buffer, sizeof (buffer), &numRead, NULL)) {
            if ((numRead == 1) &&
                (buffer [0] == EOT)
                ) {
                // we are done
                break;
            }
            if (numRead == sizeof (buffer)) {
                // compute the checksum
                signal = 0;
                for (index = 0; index < sizeof (buffer) - 1; index ++) {
                    signal += buffer [index];
                }
                if (buffer [sizeof (buffer) - 1] == signal) {
                    repeat = FALSE;
                    // checksum is correct, let's see if this is the right block
                    if (currBlock < buffer [1]) {
                        // this is a major error, the sender is ahead of us,
                        // we have to fail
                        result = FALSE;
                        break;
                    }
                    if (currBlock == buffer [1]) {
                        if (FileSize > BLOCKSIZE) {
                            if ((!WriteFile (fileHandle, buffer + 3, BLOCKSIZE, &numWritten, NULL)) ||
                                (numWritten != BLOCKSIZE)
                                ) {
                                // Write failed. Let's get out of here
                                result = FALSE;
                                break;
                            }
                            if (TotalImageRead) {
                                *TotalImageRead += BLOCKSIZE;
                            }
                            FileSize -= BLOCKSIZE;
                        } else {
                            if ((!WriteFile (fileHandle, buffer + 3, (DWORD)FileSize, &numWritten, NULL)) ||
                                (numWritten != FileSize)
                                ) {
                                // Write failed. Let's get out of here
                                result = FALSE;
                                break;
                            }
                            if (TotalImageRead) {
                                *TotalImageRead += FileSize;
                            }
                            FileSize = 0;
                        }
                        if (TotalImageRead) {
                            // now update the progress bar
                            numerator = (LONGLONG) (*TotalImageRead) * (LONGLONG) g_DownloadTicks;
                            divisor = (LONGLONG) TotalImageSize;
                            if (divisor) {
                                tick = numerator / divisor;
                            } else {
                                tick = 0;
                            }
                            delta = (UINT) tick - g_DownloadTicked;
                            if (delta) {
                                IsmTickProgressBar (g_DownloadSlice, delta);
                                g_DownloadTicked += delta;
                            }
                            // now update the estimated time and %
                            elapsedTicks = GetTickCount () - g_StartTicks;
                            estimatedTime = (UINT)(TotalImageSize * elapsedTicks / (*TotalImageRead)) - elapsedTicks;
                            percent100 = (UINT)((*TotalImageRead) * 10000 / TotalImageSize);
                            percent = percent100 / 100;
                            percent100 = percent100 - (percent * 100);
                            if (elapsedTicks > 45000) { // after about 45 seconds
                                // let's send the message to the app
                                hour = estimatedTime / 3600000;
                                minute = estimatedTime / 60000 - hour * 60;
                                second = estimatedTime / 1000 - hour * 3600 - minute * 60;

                                argArray[0] = (PCTSTR) (UINT_PTR) (percent);
                                argArray[1] = (PCTSTR) (UINT_PTR) (percent100);
                                argArray[2] = (PCTSTR) (UINT_PTR) (hour);
                                argArray[3] = (PCTSTR) (UINT_PTR) (minute);
                                argArray[4] = (PCTSTR) (UINT_PTR) (second);
                                statusMsg = ParseMessageID (MSG_TRANSFER_INFO, argArray);

                                if (statusMsg) {
                                    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                                    appInfo.SubPhase = SUBPHASE_CABLETRANS;
                                    appInfo.Text = statusMsg;
                                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));
                                    FreeStringResource (statusMsg);
                                }
                            }
                        }
                        currBlock ++;
                    }
                }
            }
        }
    }

    CloseHandle (fileHandle);

    return result;
}

BOOL
pDCReceiveFile (
    IN      PCTSTR ComPort,
    IN      PCTSTR FileName,
    IN      LONGLONG FileSize,
    IN OUT  ULONGLONG *TotalImageRead,
    IN      ULONGLONG TotalImageSize
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    deviceHandle = pDCOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pDCReceiveFileFromHandle (deviceHandle, FileName, FileSize, TotalImageRead, TotalImageSize);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pDCReceiveBlockFromHandle (
    IN      HANDLE DeviceHandle,
    OUT     PBYTE Buffer
    )
{
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 1;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = TRUE;
    UINT index;

    // finally let's start the protocol

    // We are going to send an NAK(15h) signal.
    // After that we are going to listen for a block.
    // If we don't get the block in time, or the block is wrong size
    // or it has a wrong checksum we are going to send a NAK signal,
    // otherwise we are going to send an ACK signal
    // One exception. If the block size is 1 and the block is actually the
    // EOT signal it means we are done.

    ZeroMemory (Buffer, BLOCKSIZE);

    while (TRUE) {

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // send the NAK
            signal = NAK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        } else {
            // send the ACK
            signal = ACK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }

        if (IsmCheckCancel ()) {
            result = FALSE;
            break;
        }

        repeat = TRUE;
        // let's read the data block
        if (ReadFile (DeviceHandle, buffer, sizeof (buffer), &numRead, NULL)) {
            if ((numRead == 1) &&
                (buffer [0] == EOT)
                ) {
                // we are done
                break;
            }
            if (numRead == sizeof (buffer)) {
                // compute the checksum
                signal = 0;
                for (index = 0; index < sizeof (buffer) - 1; index ++) {
                    signal += buffer [index];
                }
                if (buffer [sizeof (buffer) - 1] == signal) {
                    repeat = FALSE;
                    // checksum is correct, let's see if this is the right block
                    if (currBlock < buffer [1]) {
                        // this is a major error, the sender is ahead of us,
                        // we have to fail
                        result = FALSE;
                        break;
                    }
                    if (currBlock == buffer [1]) {
                        CopyMemory (Buffer, buffer + 3, BLOCKSIZE);
                        currBlock ++;
                    }
                }
            }
        }
    }

    return result;
}

BOOL
pDCReceiveBlock (
    IN      PCTSTR ComPort,
    OUT     PBYTE Buffer
    )
{
    HANDLE deviceHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    // Buffer must have BLOCKSIZE size

    deviceHandle = pDCOpenAndSetPort (ComPort);
    if ((!deviceHandle) || (deviceHandle == INVALID_HANDLE_VALUE)) {
        return result;
    }

    result = pDCReceiveBlockFromHandle (deviceHandle, Buffer);

    CloseHandle (deviceHandle);

    return result;
}

BOOL
pDCWriteAllImages (
    VOID
    )
{
    MIG_APPINFO appInfo;
    PHEADER1 header1;
    PHEADER2 header2;
    BYTE buffer [BLOCKSIZE];
    ULONGLONG totalImageWritten = 0;
    ULONGLONG totalImageSize = 0;
    UINT numberOfFiles = 0;
    UINT imageIdx = 1;
    ULONGLONG imageSize = 0;
    PCTSTR imageFile;

    // let's get the total image size and the total number of bytes
    imageIdx = 1;
    while (TRUE) {
        imageFile = pDCGetImageFile (imageIdx);
        imageSize = BfGetFileSize (imageFile);
        if (imageSize == 0) {
            FreePathString (imageFile);
            break;
        }
        numberOfFiles ++;
        totalImageSize += imageSize;
        FreePathString (imageFile);
        imageIdx ++;
    }

    // let's prepare the initial header
    ZeroMemory (buffer, sizeof (buffer));
    header1 = (PHEADER1) buffer;
    header1->Signature = DIRECTTR_SIG;
    header1->NumberOfFiles = numberOfFiles;
    header1->TotalImageSize = totalImageSize;

    if (!pDCSendBlock (g_DirectCablePath, buffer)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    if (!pDCReceiveBlock (g_DirectCablePath, buffer)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    if (header1->Signature != DIRECTTR_SIG) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    if (header1->NumberOfFiles != numberOfFiles) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    if (header1->TotalImageSize != totalImageSize) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
        return FALSE;
    }

    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
    appInfo.Phase = MIG_TRANSPORT_PHASE;
    appInfo.SubPhase = SUBPHASE_NETPREPARING;
    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

    imageIdx = 1;
    while (TRUE) {
        imageFile = pDCGetImageFile (imageIdx);
        imageSize = BfGetFileSize (imageFile);
        if (imageSize == 0) {
            FreePathString (imageFile);
            break;
        }
        // send info about the current file
        ZeroMemory (buffer, sizeof (buffer));
        header2 = (PHEADER2) buffer;
        header2->FileNumber = imageIdx;
        header2->FileSize = imageSize;

        if (!pDCSendBlock (g_DirectCablePath, buffer)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        if (!pDCReceiveBlock (g_DirectCablePath, buffer)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        if (header2->FileNumber != imageIdx) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        if (header2->FileSize != imageSize) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        // send the actual file
        if (!pDCSendFile (g_DirectCablePath, imageFile, &totalImageWritten, totalImageSize)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
            return FALSE;
        }

        FreePathString (imageFile);
        imageIdx ++;
    }

    return TRUE;
}

BOOL
WINAPI
DirectCableTransportSaveState (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR databaseFile = NULL;
    PCTSTR decoratedObject = NULL;
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    COMPRESS_HANDLE compressedHandle;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
#ifdef DEBUG
    PCTSTR nativeObjectName;
#endif
    BOOL result = FALSE;

    g_DirectCablePlatform = PLATFORM_SOURCE;

    __try {

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_PREPARING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        ZeroMemory (&compressedHandle, sizeof (COMPRESS_HANDLE));

        g_DirectCableTempPath = pDCCreateTemporaryDir ();

        if (!g_DirectCableTempPath) {
            extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        if (!CompressCreateHandle (g_DirectCableTempPath, S_TRANSPORT_IMG_FILE, 1, 0, &compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        //
        // Enumerate all persistent objects
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                if (IsmCheckCancel()) {
                    __leave;
                }

#ifdef DEBUG
                nativeObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                DEBUGMSG ((DBG_DIRECT, "Transporting: %s", nativeObjectName));
                IsmReleaseMemory (nativeObjectName);
#endif

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                            extraData.ErrorArea = ERRUSER_AREA_SAVE;
                            extraData.ObjectTypeId = objEnum.ObjectTypeId;
                            extraData.ObjectName = objEnum.ObjectName;
                            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = pDCBuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                    appInfo.SubPhase = SUBPHASE_COMPRESSING;
                    appInfo.ObjectTypeId = (objEnum.ObjectTypeId & (~PLATFORM_MASK));
                    appInfo.ObjectName = objEnum.ObjectName;
                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pDCSaveContentInFile (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue, &compressedHandle)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pDCSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    pDCDestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                IsmTickProgressBar (g_PersistentSlice, 1);

                if (IsmCheckCancel()) {
                    __leave;
                }

            } while (IsmEnumNextPersistentObject (&objEnum));

            IsmAbortPersistentObjectEnum (&objEnum);
        }

        if (IsmCheckCancel()) {
            __leave;
        }

        databaseFile = JoinPaths (g_DirectCableTempPath, S_TRANSPORT_DAT_FILE);

        if (!MemDbSave (databaseFile)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (IsmCheckCancel()) {
            __leave;
        }

        if (!pDCAddFileToImage (databaseFile, S_TRANSPORT_DAT_FILE, &compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        FreePathString (databaseFile);
        databaseFile = NULL;

        if (!CompressFlushAndCloseHandle (&compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (IsmCheckCancel()) {
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_CONNECTING1;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!pDCWriteAllImages ()) {
            extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        result = TRUE;

    }
    __finally {

        PushError ();

        CompressCleanupHandle (&compressedHandle);

        if (databaseFile) {
            FreePathString (databaseFile);
            databaseFile = NULL;
        }

        PopError ();
    }

    PushError ();

    pDCCleanupTempDir ();

    PopError ();

    return result;
}

BOOL
pDCReadAllImages (
    VOID
    )
{
    MIG_APPINFO appInfo;
    PHEADER1 header1;
    PHEADER2 header2;
    BYTE buffer [BLOCKSIZE];
    ULONGLONG totalImageSize = 0;
    ULONGLONG totalImageRead = 0;
    UINT numberOfFiles = 0;
    UINT imageIdx = 1;
    ULONGLONG imageSize = 0;
    PCTSTR imageFile;
    BOOL wrongVer = FALSE;

    // Let's get the initial header
    ZeroMemory (buffer, sizeof (buffer));
    if (!pDCReceiveBlock (g_DirectCablePath, buffer)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
        return FALSE;
    }

    header1 = (PHEADER1) buffer;
    if (header1->Signature != DIRECTTR_SIG) {
        wrongVer = TRUE;
    }

    header1->Signature = DIRECTTR_SIG;
    if (!pDCSendBlock (g_DirectCablePath, buffer)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
        return FALSE;
    }

    if (wrongVer) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
        return FALSE;
    }

    numberOfFiles = header1->NumberOfFiles;
    totalImageSize = header1->TotalImageSize;

    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
    appInfo.Phase = MIG_TRANSPORT_PHASE;
    appInfo.SubPhase = SUBPHASE_NETPREPARING;
    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

    imageIdx = 1;
    while (imageIdx <= numberOfFiles) {
        imageFile = pDCGetImageFile (imageIdx);

        // receive info about the current file
        ZeroMemory (buffer, sizeof (buffer));
        header2 = (PHEADER2) buffer;

        if (!pDCReceiveBlock (g_DirectCablePath, buffer)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            return FALSE;
        }

        if (header2->FileNumber != imageIdx) {
            wrongVer = TRUE;
        }

        header2->FileNumber = imageIdx;
        if (!pDCSendBlock (g_DirectCablePath, buffer)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            return FALSE;
        }

        if (wrongVer) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            return FALSE;
        }

        // receive the actual file
        if (!pDCReceiveFile (g_DirectCablePath, imageFile, header2->FileSize, &totalImageRead, totalImageSize)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            return FALSE;
        }

        FreePathString (imageFile);
        imageIdx ++;
    }

    return TRUE;
}

PCTSTR
pDCGetNewFileName (
    IN      PCTSTR FileName
    )
{
    PCTSTR newFileName = NULL;
    PTSTR tempPtr1 = NULL;
    PCTSTR endStr1 = NULL;
    PCTSTR tempPtr2 = NULL;
    PCTSTR endStr2 = NULL;
    INT i;

    // let's modify the file to extract. The file name will
    // be split in 2 after the first 5 characters
    newFileName = DuplicatePathString (FileName, 1);
    if (!newFileName) {
        return NULL;
    }
    tempPtr1 = (PTSTR) GetFileNameFromPath (newFileName);
    if (!tempPtr1) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr1 = GetEndOfString (newFileName);
    if (!endStr1) {
        FreePathString (newFileName);
        return NULL;
    }
    tempPtr2 = GetFileNameFromPath (FileName);
    if (!tempPtr2) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr2 = GetEndOfString (FileName);
    if (!endStr2) {
        FreePathString (newFileName);
        return NULL;
    }
    for (i = 0; i < 5; i ++) {
        tempPtr1 = _tcsinc (tempPtr1);
        tempPtr2 = _tcsinc (tempPtr2);
    }

    if ((tempPtr1 < endStr1) &&
        (tempPtr2 < endStr2)
        ) {
        StringCopy (tempPtr1, TEXT("\\"));
        tempPtr1 = _tcsinc (tempPtr1);
        StringCopy (tempPtr1, tempPtr2);
    } else {
        FreePathString (newFileName);
        newFileName = NULL;
    }
    return newFileName;
}

BOOL
pDirectCableCallback (
    IN      PCTSTR FileToExtract,
    IN      LONGLONG FileSize,
    OUT     PBOOL ExtractFile,
    IN OUT  PCTSTR *NewFileName
    )
{
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;

    if (NewFileName) {
        *NewFileName = pDCGetNewFileName (FileToExtract);
    }

    g_FilesRead ++;
    // now update the progress bar
    numerator = (LONGLONG) g_FilesRead * (LONGLONG) g_UncompressTicks;
    divisor = (LONGLONG) g_TotalFiles;
    if (divisor) {
        tick = numerator / divisor;
    } else {
        tick = 0;
    }
    delta = (UINT) tick - g_UncompressTicked;
    if (delta) {
        IsmTickProgressBar (g_UncompressSlice, delta);
        g_UncompressTicked += delta;
    }

    if (ExtractFile) {
        *ExtractFile = TRUE;
    }

    return (!IsmCheckCancel());
}

BOOL
pDCUnpackAllFiles (
    VOID
    )
{
    COMPRESS_HANDLE compressedHandle;
    BOOL result = FALSE;

    if (CompressOpenHandle (g_DirectCableTempPath, S_TRANSPORT_IMG_FILE, 1, &compressedHandle)) {
        g_TotalFiles = compressedHandle.FilesStored;
        if (CompressExtractAllFiles (g_DirectCableTempPath, &compressedHandle, pDirectCableCallback)) {
            result = TRUE;
        }
        CompressCleanupHandle (&compressedHandle);
    }

    return result;
}

BOOL
WINAPI
DirectCableTransportBeginApply (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    PCTSTR imageFile = NULL;
    PCTSTR newImageFile = NULL;
    BOOL result = FALSE;

    g_DirectCablePlatform = PLATFORM_DESTINATION;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
    appInfo.Phase = MIG_TRANSPORT_PHASE;
    appInfo.SubPhase = SUBPHASE_CONNECTING2;
    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

    __try {

        g_DirectCableTempPath = pDCCreateTemporaryDir ();

        if (!g_DirectCableTempPath) {
            extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
            __leave;
        }

        if (!pDCReadAllImages ()) {
            if (GetLastError () == ERROR_DISK_FULL) {
                extraData.Error = ERRUSER_ERROR_DISKSPACE;
            } else {
                extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
            }
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_UNCOMPRESSING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!pDCUnpackAllFiles ()) {
            extraData.Error = ERRUSER_ERROR_CANTUNPACKIMAGE;
            __leave;
        }

        newImageFile = pDCGetNewFileName (S_TRANSPORT_DAT_FILE);

        imageFile = JoinPaths (g_DirectCableTempPath, newImageFile?newImageFile:S_TRANSPORT_DAT_FILE);

        if (newImageFile) {
            FreePathString (newImageFile);
            newImageFile = NULL;
        }

        if (!MemDbLoad (imageFile)) {
            extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (imageFile) {
            FreePathString (imageFile);
            imageFile = NULL;
        }
    }

    if (!result) {
        extraData.ErrorArea = ERRUSER_AREA_LOAD;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
    }

    return result;
}

VOID
WINAPI
DirectCableTransportEndApply (
    VOID
    )
{
    MYASSERT (g_DirectCablePlatform == PLATFORM_DESTINATION);

    pDCCleanupTempDir ();
}

BOOL
WINAPI
DirectCableTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    PCTSTR newFileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_DirectCablePlatform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pDCBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                newFileValue = pDCGetNewFileName (fileValue);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = JoinPaths (g_DirectCableTempPath, newFileValue?newFileValue:fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = JoinPaths (g_DirectCableTempPath, newFileValue?newFileValue:fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreePathString (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                if (newFileValue) {
                    FreePathString (newFileValue);
                    newFileValue = NULL;
                }
                if (fileValue) {
                    MemDbReleaseMemory (fileValue);
                    fileValue = NULL;
                }
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
DirectCableTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_DirectCablePlatform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\homenetp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    homenetp.h

Abstract:

    Header file for functions shared in home network transport.

Author:

    Jim Schmidt (jimschm) 03-Jul-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "logmsg.h"

//
// Strings
//

#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")


//
// Constants
//

#define GLOBALKEY_SIZE  8

#define HOMENETTR_CONVSIG   0x55534D32  //USM2
#define HOMENETTR_SIG       0x55534D34  //USM4

#define TRSTATUS_DIRTY  0x00000001
#define TRSTATUS_READY  0x00000002
#define TRSTATUS_LOCKED 0x00000003

#define TRFLAG_FILE     0x01
#define TRFLAG_MEMORY   0x02

#define MESSAGE_ERROR               0x0000
#define MESSAGE_FILE                0x0001
#define MESSAGE_DONE                0x0002
#define MESSAGE_KEEP_ALIVE          0x0003
#define MESSAGE_DATA                0x0004
#define MESSAGE_PASSWORDWRONG       0x0005
#define MESSAGE_PASSWORDOK          0x0006
#define MESSAGE_CANCEL              0x0007

#define MAX_SOCKADDR                (max(sizeof(SOCKADDR_IN),max(sizeof(SOCKADDR_IPX),sizeof(SOCKADDR_NB))))


//
// Macros
//

// None

//
// Types
//

#pragma pack(push,1)

typedef struct {
    WORD PacketNumber;
    WORD DataLength;
} DATAGRAM_PACKET, *PDATAGRAM_PACKET;

#pragma pack(pop)

typedef struct TAG_DATAGRAM_POOL_ITEM {
    struct TAG_DATAGRAM_POOL_ITEM *Next, *Prev;
    DATAGRAM_PACKET Header;
    PCBYTE PacketData;
    // PacketData follows
} DATAGRAM_POOL_ITEM, *PDATAGRAM_POOL_ITEM;

typedef struct {
    PMHANDLE Pool;
    PDATAGRAM_POOL_ITEM FirstItem;
    WORD SendSequenceNumber;
    WORD RecvSequenceNumber;
    UINT LastPacketNumber;
} DATAGRAM_POOL, *PDATAGRAM_POOL;

typedef struct {
    SOCKET Socket;
    BYTE LocalAddress[MAX_SOCKADDR];
    INT LocalAddressLen;
    BYTE RemoteAddress[MAX_SOCKADDR];
    INT RemoteAddressLen;
    INT Family;
    INT Protocol;
    DATAGRAM_POOL DatagramPool;
    BOOL Datagram;
    UINT LastSend;
    UINT KeepAliveSpacing;
} CONNECTIONSOCKET, *PCONNECTIONSOCKET;

typedef struct {
    BYTE LocalAddress[MAX_SOCKADDR];
    INT LocalAddressLen;
    BYTE RemoteAddress[MAX_SOCKADDR];
    INT RemoteAddressLen;
    INT Family;
    INT Protocol;
    BOOL Datagram;
    TCHAR DestinationName[MAX_COMPUTER_NAME];
} CONNECTADDRESS, *PCONNECTADDRESS;

typedef struct {
    UINT StructSize;
    DWORD Signature;
    UINT FileCount;
    LONGLONG TotalSize;
    TCHAR SourceName[MAX_COMPUTER_NAME];
} TRANSFERMETRICS, *PTRANSFERMETRICS;

//
// Globals
//

extern PCTSTR g_TransportTempDir;
extern PCTSTR g_StatusFile;
extern HANDLE g_StatusFileHandle;
extern UINT g_Platform;
extern TRANSFERMETRICS g_Metrics;
extern CONNECTIONSOCKET g_Connection;
extern BOOL g_CompressData;
extern HANDLE g_BackgroundThread;
extern HANDLE g_BackgroundThreadTerminate;
extern MIG_PROGRESSSLICEID g_DownloadSlice;
extern UINT g_DownloadTicks;
extern UINT g_DownloadSliceSize;
extern CHAR g_GlobalKey [GLOBALKEY_SIZE + 1];

//
// Macro expansion list
//

// None

//
// Public function prototypes
//

BOOL
FindDestination (
    OUT     PCONNECTADDRESS Address,
    IN      UINT Timeout,               OPTIONAL
    IN      BOOL IgnoreMultipleDests
    );

BOOL
TestConnection (
    IN      PCONNECTADDRESS Address
    );

BOOL
ConnectToDestination (
    IN      PCONNECTADDRESS Address,
    IN      PTRANSFERMETRICS Metrics,
    OUT     PCONNECTIONSOCKET Connection
    );

DWORD
SendMessageToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      DWORD Message
    );

BOOL
SendFileToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCTSTR LocalPath,                   OPTIONAL
    IN      PCTSTR DestSubPath                  OPTIONAL
    );

BOOL
SendDataToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCBYTE Data,
    IN      UINT DataSize
    );

BOOL
ConnectToSource (
    OUT     PCONNECTIONSOCKET Connection,
    OUT     PTRANSFERMETRICS Metrics
    );

DWORD
ReceiveFromSource (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCTSTR LocalFileRoot,
    OUT     PBYTE *Buffer,
    IN      UINT Timeout    OPTIONAL
    );

VOID
CloseConnection (
    IN      PCONNECTIONSOCKET Connection
    );


DWORD
GetTransportStatus (
    IN      PCTSTR TrJournal,
    OUT     PBOOL Compressed    OPTIONAL
    );

PCTSTR
BuildImageFileName (
    IN      UINT ImageIdx
    );

VOID
FreeImageFileName (
    IN      PCTSTR ImageFileName
    );

PCTSTR
CreateStorageDir (
    VOID
    );

PCTSTR
BuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    );

VOID
DestroyDecoratedObject (
    IN      PCTSTR String
    );

PCTSTR
AllocStorageFileName (
    IN      PCTSTR FileName         OPTIONAL
    );

VOID
FreeStorageFileName (
    IN      PCTSTR NameToFree
    );

DWORD
WINAPI
DestinationBackgroundThread (
    PVOID DontCare
    );

//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\guitrans.h ===
//
// Module entry points
//

// homenet
TRANSPORTINITIALIZE HomeNetTransportInitialize;
TRANSPORTQUERYCAPABILITIES HomeNetTransportQueryCapabilities;
TRANSPORTSETSTORAGE HomeNetTransportSetStorage;
TRANSPORTRESETSTORAGE HomeNetTransportResetStorage;
TRANSPORTTERMINATE HomeNetTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR HomeNetTransportEstimateProgressBar;
TRANSPORTSAVESTATE HomeNetTransportSaveState;
TRANSPORTBEGINAPPLY HomeNetTransportBeginApply;
TRANSPORTACQUIREOBJECT HomeNetTransportAcquireObject;
TRANSPORTRELEASEOBJECT HomeNetTransportReleaseObject;
TRANSPORTENDAPPLY HomeNetTransportEndApply;

// removable media
TRANSPORTINITIALIZE RmvMedTransportInitialize;
TRANSPORTQUERYCAPABILITIES RmvMedTransportQueryCapabilities;
TRANSPORTSETSTORAGE RmvMedTransportSetStorage;
TRANSPORTSAVESTATE RmvMedTransportSaveState;
TRANSPORTBEGINAPPLY RmvMedTransportBeginApply;
TRANSPORTACQUIREOBJECT RmvMedTransportAcquireObject;
TRANSPORTRELEASEOBJECT RmvMedTransportReleaseObject;
TRANSPORTENDAPPLY RmvMedTransportEndApply;
TRANSPORTTERMINATE RmvMedTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR RmvMedTransportEstimateProgressBar;

// direct cable
TRANSPORTINITIALIZE DirectCableTransportInitialize;
TRANSPORTQUERYCAPABILITIES DirectCableTransportQueryCapabilities;
TRANSPORTSETSTORAGE DirectCableTransportSetStorage;
TRANSPORTSAVESTATE DirectCableTransportSaveState;
TRANSPORTBEGINAPPLY DirectCableTransportBeginApply;
TRANSPORTACQUIREOBJECT DirectCableTransportAcquireObject;
TRANSPORTRELEASEOBJECT DirectCableTransportReleaseObject;
TRANSPORTENDAPPLY DirectCableTransportEndApply;
TRANSPORTTERMINATE DirectCableTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR DirectCableTransportEstimateProgressBar;

// opaque.c
TRANSPORTINITIALIZE OpaqueTransportInitialize;
TRANSPORTQUERYCAPABILITIES OpaqueTransportQueryCapabilities;
TRANSPORTSETSTORAGE OpaqueTransportSetStorage;
TRANSPORTSAVESTATE OpaqueTransportSaveState;
TRANSPORTBEGINAPPLY OpaqueTransportBeginApply;
TRANSPORTACQUIREOBJECT OpaqueTransportAcquireObject;
TRANSPORTRELEASEOBJECT OpaqueTransportReleaseObject;
TRANSPORTENDAPPLY OpaqueTransportEndApply;
TRANSPORTTERMINATE OpaqueTransportTerminate;
TRANSPORTESTIMATEPROGRESSBAR OpaqueTransportEstimateProgressBar;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\netcommon.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Implements functionality common to both the source and destination side

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include "homenetp.h"

#define DBG_HOMENET   "HomeNet"

//
// Strings
//

#define S_TRANSPORT_DIR         TEXT("USMT2.HN")
#define S_TRANSPORT_STATUS_FILE TEXT("status")

//
// Constants
//

// none

//
// Macros
//

// None

//
// Types
//

// none

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_TransportId;
PCTSTR g_TransportTempDir;
PCTSTR g_StatusFile;
HANDLE g_StatusFileHandle = INVALID_HANDLE_VALUE;
UINT g_Platform;
TRANSFERMETRICS g_Metrics;
CONNECTIONSOCKET g_Connection;
BOOL g_CompressData = FALSE;
MIG_PROGRESSSLICEID g_DatabaseSlice;
MIG_PROGRESSSLICEID g_PersistentSlice;
MIG_PROGRESSSLICEID g_DownloadSlice;
UINT g_DownloadTicks;
UINT g_DownloadSliceSize;
HANDLE g_BackgroundThread;
HANDLE g_BackgroundThreadTerminate;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
pStopBackgroundThread (
    VOID
    )
{
    if (g_BackgroundThread) {

        DEBUGMSG ((DBG_HOMENET, "Stopping background thread"));

        SetEvent (g_BackgroundThreadTerminate);
        WaitForSingleObject (g_BackgroundThread, INFINITE);

        CloseHandle (g_BackgroundThread);
        CloseHandle (g_BackgroundThreadTerminate);

        g_BackgroundThread = NULL;
        g_BackgroundThreadTerminate = NULL;
    }
}


BOOL
WINAPI
HomeNetTransportInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    WSADATA startupData;
    INT result;

    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    //
    // Start sockets
    //

    result = WSAStartup (0x0101, &startupData);

    //
    // Register transport
    //

    if (!result) {
        g_TransportId = IsmRegisterTransport (S_HOME_NETWORK_TRANSPORT);
        return TRUE;
    }

    return FALSE;
}


BOOL
WINAPI
HomeNetTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_TransportId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED|CAPABILITY_AUTOMATED;
    *FriendlyDescription = TEXT("Automatic network transfer");

    return TRUE;
}


VOID
WINAPI
HomeNetTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on the count of the
        // persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        ticks = 0;
        g_DatabaseSlice = IsmRegisterProgressSlice (ticks, ticks * 3);

    } else {
        //
        // When restoring, we don't know the progress until we connect. We need
        // to set up a scale.
        //

        g_DownloadTicks = 0;
        g_DownloadSliceSize = 1000;
        g_DownloadSlice = IsmRegisterProgressSlice (g_DownloadSliceSize, 360);
    }
}


VOID
pResetTempDir (
    VOID
    )
{
    FreePathString (g_TransportTempDir);
    g_TransportTempDir = NULL;

    if (g_StatusFileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle (g_StatusFileHandle);
        g_StatusFileHandle = INVALID_HANDLE_VALUE;
    }

    FreeStorageFileName (g_StatusFile);
    g_StatusFile = NULL;
}


DWORD
GetTransportStatus (
    IN      PCTSTR TrJournal,
    OUT     PBOOL Compressed    OPTIONAL
    )
{
    HANDLE trJrnHandle;
    BOOL compressed = FALSE;
    DWORD signature = 0;
    DWORD error;
    DWORD result = 0;

    if (TrJournal && TrJournal [0]) {
        trJrnHandle = BfOpenReadFile (TrJournal);
        if (trJrnHandle) {
            if (BfSetFilePointer (trJrnHandle, 0)) {
                if (BfReadFile (trJrnHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                    if (signature == HOMENETTR_SIG) {
                        if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                            BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                        }
                    }
                }
            }
            CloseHandle (trJrnHandle);
        } else {
            error = GetLastError ();
            if ((error == ERROR_ACCESS_DENIED) ||
                (error == ERROR_SHARING_VIOLATION)
                ) {
                result = TRSTATUS_LOCKED;
            }
        }
    }
    if (Compressed) {
        *Compressed = compressed;
    }
    return result;
}


VOID
WINAPI
HomeNetTransportResetStorage (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId
    )
{
    if (TransportStorageId == g_TransportId) {
        DEBUGMSG ((DBG_HOMENET, "Resetting transport"));

        pStopBackgroundThread();

        if (g_TransportTempDir) {
            pResetTempDir();
            MYASSERT (!g_TransportTempDir);
        }

        DEBUGMSG ((DBG_HOMENET, "Reset complete"));
    }
}


BOOL
WINAPI
HomeNetTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )

/*++

Routine Description:

  TransportSetStorage tells the transport to be prepared for a future IsmSave
  or IsmLoad, and provides the storage path and capabilities. The StoragePath
  tells the home networking transport where to save its temporary files
  during the transfer. This routine is called when IsmSetTransportStorage is
  called.

Arguments:

  Platform             - Specifies the platform of the transport. This is
                         potentially different than the current platform.
                         Also, it is never PLATFORM_CURRENT.
  TransportStorageId   - Specifies the desired storage ID. For this
                         transport, it will always be g_TransportId, unless
                         the caller passes in garbage.
  RequiredCapabilities - Specifies two optional flags: CAPABILITY_COMPRESSED
                         and CAPABILITY_AUTOMATED.
  StoragePath          - Specifies the path to the temporary directory, or
                         NULL to use the Windows temporary directory.
  Valid                - Receives TRUE if the transport storage ID is valid
                         and was selected, FALSE otherwise. NOTE: this is not
                         an optional parameter.
  ImageExists          - Receives TRUE if the platform is PLATFORM_DESTINATION,
                         FALSE if the platform is PLATFORM_SOURCE. The value is
                         undefined if Valid is FALSE.

Return Value:

  TRUE if the transport is ready for IsmSave or IsmLoad, FALSE otherwise.

--*/

{
    PCTSTR transportPath = NULL;
    MIG_OBJECTSTRINGHANDLE encodedPath;
    BOOL result = FALSE;
    DWORD attribs;
    TCHAR tempDir[MAX_TCHAR_PATH];
    BOOL startAutoDest = FALSE;
    CONNECTADDRESS connectAddress;
    BOOL capabilitiesValid = TRUE;

    if (!Valid || !ImageExists) {
        DEBUGMSG ((DBG_ERROR, "TransportSetStorage requires Valid and ImageExists params"));
        return FALSE;
    }

    *Valid = FALSE;
    *ImageExists = FALSE;

    if (TransportStorageId == g_TransportId) {

        //
        // Make sure we support the requested capabilities
        //

        if (RequiredCapabilities & (~(CAPABILITY_AUTOMATED|CAPABILITY_COMPRESSED))) {
            capabilitiesValid = FALSE;
        } else {
            DEBUGMSG ((DBG_HOMENET, "Accepting a TransportSetStorage request (capabilities: 0%Xh)", RequiredCapabilities));
        }

        if (capabilitiesValid) {

            //
            // Validate the inbound args, update the globals
            //

            if (RequiredCapabilities & CAPABILITY_COMPRESSED) {
                g_CompressData = TRUE;
            } else {
                g_CompressData = FALSE;
            }

            if (!StoragePath) {
                IsmGetTempStorage (tempDir, ARRAYSIZE(tempDir));
                StoragePath = tempDir;
            }

            MYASSERT (!g_TransportTempDir);

            //
            // Compute the transport storage directory, then make sure it is empty.
            // If Storage is NULL, then the storage directory is %temp%\usmtv2.hn
            //

            transportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);

            attribs = GetFileAttributes (transportPath);

            if (attribs != INVALID_ATTRIBUTES) {
                SetFileAttributes (transportPath, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (transportPath);
                FiRemoveAllFilesInTree (transportPath);
            }

            //
            // Now esablish the temporary directory and put a status file in it
            // for restartability
            //

            attribs = GetFileAttributes (transportPath);

            if (attribs == INVALID_ATTRIBUTES) {

                if (BfCreateDirectory (transportPath)) {
                    *Valid = TRUE;

                    //
                    // it exists on the destination because we are going to download it;
                    // it does not exist on the source because we always overwrite it
                    //

                    *ImageExists = (Platform == PLATFORM_DESTINATION);

                    g_TransportTempDir = DuplicatePathString (transportPath, 0);
                    g_StatusFile = AllocStorageFileName (S_TRANSPORT_STATUS_FILE);

                    encodedPath = IsmCreateSimpleObjectPattern (g_TransportTempDir, FALSE, NULL, FALSE);
                    if (encodedPath) {
                        IsmRegisterStaticExclusion (MIG_FILE_TYPE, encodedPath);
                        IsmDestroyObjectHandle (encodedPath);
                    }
                }
            } else {
                *ImageExists = TRUE;
            }

            //
            // If CAPABILITY_AUTOMATED, start the process of looking for a connection now
            //

            if (*Valid && (RequiredCapabilities & CAPABILITY_AUTOMATED)) {

                if (Platform == PLATFORM_SOURCE) {
                    //
                    // Check for a destination
                    //

                    DEBUGMSG ((DBG_HOMENET, "Looking for destination broadcasts"));
                    *ImageExists = FindDestination (&connectAddress, 5, TRUE);
                    if (*ImageExists) {
                        *ImageExists = TestConnection (&connectAddress);
                    }

                } else {
                    //
                    // Launch background thread
                    //

                    DEBUGMSG ((DBG_HOMENET, "Launching background broadcast thread"));

                    if (!g_BackgroundThread) {
                        g_BackgroundThreadTerminate = CreateEvent (NULL, TRUE, FALSE, NULL);
                        g_BackgroundThread = StartThread (DestinationBackgroundThread, 0);
                    }
                }
            }

            result = TRUE;
        }
    }

    FreePathString (transportPath);
    return result;
}


VOID
WINAPI
HomeNetTransportTerminate (
    VOID
    )
{
    pStopBackgroundThread();

    //
    // Shut down sockets
    //

    WSACleanup();

    //
    // Clean up utils
    //

    if (g_TransportTempDir) {
        FiRemoveAllFilesInTree (g_TransportTempDir);
        pResetTempDir();
    }
}


PCTSTR
BuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    PCTSTR typeStr;

    typeStr = IsmGetObjectTypeName (ObjectTypeId);
    if (!typeStr) {
        return NULL;
    }

    return JoinPaths (typeStr, ObjectName);
}

VOID
DestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}


PCTSTR
AllocStorageFileName (
    IN      PCTSTR FileName         OPTIONAL
    )
{
    TCHAR buffer[32];
    static UINT sequencer = 0;

    if (FileName) {
        return JoinPaths (g_TransportTempDir, FileName);
    }

    sequencer++;
    wsprintf (buffer, TEXT("%08X.DAT"), sequencer);

    return JoinPaths (g_TransportTempDir, buffer);
}


VOID
FreeStorageFileName (
    IN      PCTSTR NameToFree
    )
{
    FreePathString (NameToFree);
}


PCTSTR
BuildImageFileName (
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (g_TransportTempDir, imageFileName);
}


VOID
FreeImageFileName (
    IN      PCTSTR ImageFileName
    )
{
    FreePathString (ImageFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\netdest.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dest.c

Abstract:

    Implements the destination side of the home networking transport

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include "homenetp.h"

#define DBG_HOMENET   "HomeNet"

//
// Strings
//

#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

//
// Globals
//

BOOL g_ConnectionRequested;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pHomeNetReadAllImages (
    VOID
    )
{
    PCTSTR imageFile = NULL;
    UINT imageIdx = 1;
    OCABHANDLE cabHandle;
    BOOL result = TRUE;

    do {

        imageFile = BuildImageFileName (imageIdx);
        if (!DoesFileExist (imageFile)) {
            FreeImageFileName (imageFile);
            break;
        }

        cabHandle = CabOpenCabinet (imageFile);
        if (cabHandle) {
            if (!CabExtractAllFiles (cabHandle, g_TransportTempDir)) {
                result = FALSE;
            }
            CabCloseCabinet (cabHandle);
            DeleteFile (imageFile);
        } else {
            result = FALSE;
        }

        FreeImageFileName (imageFile);
        imageIdx ++;

    } while (result);

    return result;
}

BOOL
pGeneratePassword (
    OUT     PSTR Key,
    IN      UINT KeySize
    )
{
    // no ILOilo0 characters
    CHAR validChars[] = "ABCDEFGHJKMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz123456789";
    DWORD validCharsNr = TcharCountA (validChars);
    HCRYPTPROV hProv = 0;
    UINT i;

    if (!CryptAcquireContext (&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
        return FALSE;
    }

    CryptGenRandom (hProv, KeySize, (LPBYTE)Key);
    for (i=0; i<KeySize; i++) {
        Key[i] = validChars[Key[i] % validCharsNr];
    }

    if (hProv) {
        CryptReleaseContext (hProv, 0);
        hProv = 0;
    }

    return TRUE;
}

DWORD WINAPI
DisplayPasswordProc (
    LPVOID lpParameter   // thread data
    )
{
    PPASSWORD_DATA passwordData;

    passwordData = (PPASSWORD_DATA) lpParameter;

    IsmSendMessageToApp (TRANSPORTMESSAGE_NET_DISPLAY_PASSWORD, (ULONG_PTR)passwordData);

    if (passwordData) {
        IsmReleaseMemory (passwordData);
    }

    ExitThread (0);
}

HANDLE
pDisplayPassword (
    IN      PCSTR Key,
    IN      HANDLE Event
    )
{
    PPASSWORD_DATA passwordData;
    DWORD threadId;

    passwordData = IsmGetMemory (sizeof (PASSWORD_DATA));
    if (!passwordData) {
        return NULL;
    }

    ZeroMemory (passwordData, sizeof (PASSWORD_DATA));
    passwordData->Key = (PSTR)Key;
    passwordData->KeySize = 0;
    passwordData->Event = Event;

    return CreateThread (
                NULL,
                0,
                DisplayPasswordProc,
                (LPVOID)(passwordData),
                0,
                &threadId
                );
}

BOOL
WINAPI
HomeNetTransportBeginApply (
    VOID
    )
{
    ERRUSER_EXTRADATA extraData;
    DWORD status = 0;
    PCTSTR memDbFile;
    BOOL b = FALSE;
    DWORD msg;
    UINT fileNumber = 0;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;
    HANDLE event = NULL;
    HANDLE thread = NULL;
    DWORD waitResult;
    PBYTE buffer;

    g_Platform = PLATFORM_DESTINATION;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    __try {
        //
        // Download the image
        //

        if (g_BackgroundThread) {
            WaitForSingleObject (g_BackgroundThread, INFINITE);
        } else {
            g_ConnectionRequested = ConnectToSource (&g_Connection, &g_Metrics);
        }

        if (!g_ConnectionRequested) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            extraData.Error = ERRUSER_ERROR_CANTFINDSOURCE;
            __leave;
        }

        // now we connected to the source. Let's pop up a dialog showing a randomly generated
        // password and ask the user to type the password on the source machine.
        if (!pGeneratePassword (g_GlobalKey, GLOBALKEY_SIZE)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            extraData.Error = ERRUSER_ERROR_NOENCRYPTION;
            __leave;
        }

        event = CreateEvent (NULL, TRUE, FALSE, NULL);

        thread =  pDisplayPassword (g_GlobalKey, event);

        // Let's wait for the first message (should be MESSAGE_PASSWORD);
        do {
            msg = ReceiveFromSource (&g_Connection, NULL, &buffer, 1000);

            if (msg == MESSAGE_DATA) {
                if (buffer && StringMatchA (g_GlobalKey, buffer)) {
                    // This is it, the key is correct
                    SetEvent (event);
                    SendMessageToDestination (&g_Connection, MESSAGE_PASSWORDOK);
                } else {
                    msg = 0;
                    SendMessageToDestination (&g_Connection, MESSAGE_PASSWORDWRONG);
                }
                if (buffer) {
                    HeapFree (g_hHeap, 0, buffer);
                }
            }

            if (msg == MESSAGE_CANCEL) {
                // The source computer cancelled
                SetEvent (event);
            }

            waitResult = WaitForSingleObject (thread, 0);

        } while ((waitResult == WAIT_TIMEOUT) && (msg != MESSAGE_DATA) && (msg != MESSAGE_CANCEL));

        if (thread) {
            waitResult = WaitForSingleObject (thread, 5000);
            if (waitResult == WAIT_TIMEOUT) {
                TerminateThread (thread, 0);
            }
            CloseHandle (thread);
            thread = NULL;
        }

        if (event) {
            CloseHandle (event);
            event = NULL;
        }

        if (msg != MESSAGE_DATA) {
            // the user cancelled
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_SOURCE));
            extraData.Error = ERRUSER_ERROR_CANTFINDSOURCE;
            __leave;
        }

        DEBUGMSG ((DBG_HOMENET, "Receiving from source"));

        do {
            msg = ReceiveFromSource (&g_Connection, g_TransportTempDir, NULL, 0);

            if (msg == MESSAGE_FILE) {
                //
                // Tick the progress bar
                //

                fileNumber++;

                numerator = (LONGLONG) fileNumber * (LONGLONG) g_DownloadSliceSize;
                divisor = (LONGLONG) g_Metrics.FileCount;
                if (divisor) {
                    tick = numerator / divisor;
                } else {
                    tick = 0;
                }

                delta = (UINT) tick - g_DownloadTicks;

                if (delta) {
                    IsmTickProgressBar (g_DownloadSlice, delta);
                }
            }

        } while (msg && msg != MESSAGE_DONE);

        if (msg != MESSAGE_DONE) {
            if (GetLastError () == ERROR_DISK_FULL) {
                // we just failed because we don't have enough space on the destination
                // path. Let's tell that to the user
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            } else {
                extraData.Error = ERRUSER_ERROR_CANTRECEIVEFROMSOURCE;
            }
            PushError ();
            LOG ((LOG_ERROR, (PCSTR) MSG_TRANSFER_INCOMPLETE));
            CloseConnection (&g_Connection);
            PopError ();
            __leave;
        }

        SendMessageToDestination (&g_Connection, MESSAGE_DONE);

        DEBUGMSG ((DBG_HOMENET, "Image transfer finished"));

        //
        // Now process the image
        //

        status = GetTransportStatus (g_StatusFile, &g_CompressData);

        if (status != TRSTATUS_READY) {
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_DOWNLOAD));
            extraData.Error = ERRUSER_ERROR_INVALIDDATARECEIVED;
            __leave;
        }

        g_StatusFileHandle = BfOpenFile (g_StatusFile);
        if (g_StatusFileHandle == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_STATUS_FILE, g_StatusFile));
            extraData.Error = ERRUSER_ERROR_INVALIDDATARECEIVED;
            __leave;
        }

        if (g_CompressData) {
            b = pHomeNetReadAllImages ();
        } else {
            b = TRUE;
        }

        if (b) {
            memDbFile = AllocStorageFileName (S_TRANSPORT_DAT_FILE);
            b = MemDbLoad (memDbFile);
            FreeStorageFileName (memDbFile);
        }

        if (!b) {
            extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
        }
    }
    __finally {
    }

    if (!b) {
        PushError ();
        extraData.ErrorArea = ERRUSER_AREA_LOAD;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
        PopError ();
    }

    return b;
}


VOID
WINAPI
HomeNetTransportEndApply (
    VOID
    )
{
    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    CloseConnection (&g_Connection);
}


BOOL
WINAPI
HomeNetTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,         CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_Platform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = BuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = AllocStorageFileName (fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = AllocStorageFileName (fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreeStorageFileName (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                MemDbReleaseMemory (fileValue);
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    DestroyDecoratedObject (decoratedObject);

    return result;
}

BOOL
WINAPI
HomeNetTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreeStorageFileName (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}


DWORD
WINAPI
DestinationBackgroundThread (
    PVOID DontCare
    )
{
    BOOL connect;
    ULONG_PTR result;

    DEBUGMSG ((DBG_HOMENET, "Destination background thread is running"));

    for (;;) {
        connect = ConnectToSource (&g_Connection, &g_Metrics);

        if (connect) {

            DEBUGMSG ((DBG_HOMENET, "Asking app if connection is acceptable"));

            result = IsmSendMessageToApp (TRANSPORTMESSAGE_READY_TO_CONNECT, (ULONG_PTR) g_Metrics.SourceName);

            if (result == APPRESPONSE_FAIL) {
                DEBUGMSG ((DBG_HOMENET, "App says NO!"));
                CloseConnection (&g_Connection);
                continue;
            }

            DEBUGMSG ((DBG_HOMENET, "App says YES!"));
        }

        break;
    }

    g_ConnectionRequested = connect;

    DEBUGMSG ((DBG_HOMENET, "Destination background thread is complete"));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\netsource.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    source.c

Abstract:

    Implements the source side of the home networking transport

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include <winsock.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include "homenetp.h"

#define DBG_HOMENET   "HomeNet"

//
// Strings
//

#define S_TRANSPORT_DSK_FILE    TEXT("DSK%05X")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//

//
// Macros
//

// None

//
// Types
//

// none

//
// Globals
//

MIG_PROGRESSSLICEID g_PersistentSlice;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pSetTransportStatus (
    IN      HANDLE TrJournalHandle,
    IN      BOOL Compressed,
    IN      DWORD Status
    )
{
    DWORD signature = HOMENETTR_SIG;

    if (BfSetFilePointer (TrJournalHandle, 0)) {
        BfWriteFile (TrJournalHandle, (PBYTE)(&signature), sizeof (DWORD));
        BfWriteFile (TrJournalHandle, (PBYTE)(&Compressed), sizeof (BOOL));
        BfWriteFile (TrJournalHandle, (PBYTE)(&Status), sizeof (DWORD));
    }
    FlushFileBuffers (TrJournalHandle);
    return TRUE;
}


BOOL
pTransportFile (
    IN      PCTSTR LocalPath,
    IN      PCTSTR StoragePath
    )
{
    static UINT tcharsToSkip;
    BOOL b;

    if (!tcharsToSkip) {
        tcharsToSkip = TcharCount (g_TransportTempDir);
    }

    StoragePath += tcharsToSkip;
    MYASSERT (*StoragePath == TEXT('\\'));
    StoragePath++;

    b = SendFileToDestination (&g_Connection, LocalPath, StoragePath);

    DEBUGMSG_IF ((!b, DBG_ERROR, "Can't send %s to destination", LocalPath));

    return b;
}


BOOL
pHomeNetSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b = FALSE;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    if (key) {

        b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

        FreeText (key);
    }

    return b;
}

BOOL
pHomeNetAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR CabName,
    IN OUT  CCABHANDLE CabHandle
    )
{
    return CabAddFileToCabinet (CabHandle, FileName, CabName);
}

BOOL
pHomeNetSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  CCABHANDLE CabHandle    OPTIONAL
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;
    DWORD attributes = INVALID_ATTRIBUTES;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use sockets to move the file from local to storage.
    //

    __try {
        if (Content && (Content->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) && Content->Details.DetailsData) {
            attributes = ((PWIN32_FIND_DATAW)Content->Details.DetailsData)->dwFileAttributes;
        }
        if ((attributes != INVALID_ATTRIBUTES) && (attributes & FILE_ATTRIBUTE_DIRECTORY)) {

            // this must be a directory, let's just write the key
            // BUGBUG - what about zero-length files?

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = AllocStorageFileName (NULL);
            if (!destPath) {
                DEBUGMSG ((DBG_ERROR, "Can't get storage path"));
                __leave;
            }

            if (CabHandle) {
                if (!pHomeNetAddFileToImage (
                        Content->FileContent.ContentPath,
                        GetFileNameFromPath (destPath),
                        CabHandle
                        )) {
                    __leave;
                }
            } else {
                if (!pTransportFile (Content->FileContent.ContentPath, destPath)) {
                    __leave;
                }
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, GetFileNameFromPath (destPath), 0)) {
                __leave;
            }
        }

        //
        // Save details
        //

        result = pHomeNetSaveDetails (DecoratedObject, &(Content->Details));

    }
    __finally {
        FreeStorageFileName (destPath);
        INVALID_POINTER (destPath);
    }

    return result;
}

BOOL
pHomeNetSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content
    )
{
    BOOL result = FALSE;

    MYASSERT (!Content->ContentInFile);
    if (Content->ContentInFile) {
        return FALSE;
    }

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (Content->MemoryContent.ContentBytes && Content->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            Content->MemoryContent.ContentBytes,
            Content->MemoryContent.ContentSize
            );
    }

    result = pHomeNetSaveDetails (DecoratedObject, &(Content->Details));

    return result;
}

BOOL
pHomeNetWriteAllImages (
    VOID
    )
{
    UINT imageIdx = 1;
    PCTSTR imageFile;
    BOOL result = FALSE;

    for (;;) {
        imageFile = BuildImageFileName (imageIdx);

        if (DoesFileExist (imageFile)) {
            if (!pTransportFile (imageFile, imageFile)) {
                break;
            }
        } else {
            result = TRUE;
            break;
        }

        FreeImageFileName (imageFile);
        imageIdx ++;
    }

    return result;
}

BOOL
pAskForPassword (
    OUT     PSTR Key,
    IN      UINT KeySize
    )
{
    INT_PTR appReply;
    PASSWORD_DATA passwordData;

    passwordData.Key = (PSTR)Key;
    passwordData.KeySize = KeySize;
    passwordData.Event = NULL;

    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_NET_GATHER_PASSWORD, (ULONG_PTR)&passwordData);

    return (appReply == APPRESPONSE_SUCCESS);
}

BOOL
pSaveAllState (
    IN      BOOL Compressed
    )
{
    MIG_APPINFO appInfo;
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    ULONGLONG size;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR ourDbFile = NULL;
    PCTSTR decoratedObject = NULL;
    ULONGLONG bytesSaved = 0;
    UINT lastTick = GetTickCount();
    UINT fraction;
    CCABHANDLE cabHandle = NULL;
    CONNECTADDRESS destination;
    DWORD nameSize;
    UINT fileCount;
    LONGLONG fileSize;
    UINT nextKeepAlive = lastTick + 60000;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
    BOOL result = FALSE;
    PCTSTR statusMsg;
    PCTSTR argArray[2];
    ERRUSER_EXTRADATA extraData;
    UINT message;
    UINT numTry = 0;

    ZeroMemory (&g_Connection, sizeof (g_Connection));
    g_Connection.Socket = INVALID_SOCKET;

    ZeroMemory (&g_Metrics, sizeof (g_Metrics));
    g_Metrics.Signature = HOMENETTR_SIG;

    __try {

        nameSize = ARRAYSIZE(g_Metrics.SourceName);
        GetComputerName (g_Metrics.SourceName, &nameSize);

        if (Compressed) {

            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_PREPARING;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            cabHandle = CabCreateCabinet (g_TransportTempDir, S_TRANSPORT_IMG_FILE, S_TRANSPORT_DSK_FILE, IsmGetTempFile, 0);
            if (!cabHandle) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        } else {

            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_CONNECTING1;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            //
            // Connect to the destination
            //
            // NOTE: This is designed such that FindDestination can run in a background
            //       thread, allowing us to estimate the number of files at the same time
            //

            if (IsmEnumFirstPersistentObject (&objEnum)) {
                do {
                    okSave = FALSE;
                    while (!okSave) {

                        if (!IsmAcquireObjectEx (
                                objEnum.ObjectTypeId,
                                objEnum.ObjectName,
                                &value,
                                CONTENTTYPE_DETAILS_ONLY,
                                0
                                )) {

                            transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                            transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                            transCopyError.Error = GetLastError ();

                            if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                appReply = APPRESPONSE_IGNORE;
                            } else {
                                appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                if ((appReply == APPRESPONSE_NONE) ||
                                    (appReply == APPRESPONSE_FAIL)
                                    ) {
                                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    IsmAbortPersistentObjectEnum (&objEnum);
                                    __leave;
                                }
                            }
                            if (appReply == APPRESPONSE_IGNORE) {
                                LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                break;
                            }
                            IsmReleaseMemory (transCopyError.ObjectName);
                            continue;
                        }
                        okSave = TRUE;
                    }

                    if (value.ContentInFile) {
                        g_Metrics.FileCount++;
                        g_Metrics.TotalSize += value.FileContent.ContentSize; // estimated
                    }
                } while (IsmEnumNextPersistentObject (&objEnum));
            }

            g_Metrics.FileCount++;        // our memdb

            if (!FindDestination (&destination, 60, FALSE)) {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_FIND_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                }

                __leave;
            }

            if (!ConnectToDestination (&destination, &g_Metrics, &g_Connection)) {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                }
                __leave;
            }

            numTry = 0;

            do {

                // now we connected to the destination. Let's pop up a dialog asking the user to
                // type in the password that the destination has.
                if (!pAskForPassword (g_GlobalKey, 33)) {
                    // let's tell the destination computer that we are bailing out.
                    SendMessageToDestination (&g_Connection, MESSAGE_CANCEL);

                    // BUGBUG - better error message
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                    __leave;
                }

                if (!SendDataToDestination (&g_Connection, g_GlobalKey, SizeOfStringA (g_GlobalKey))) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                    __leave;
                }

                message = ReceiveFromSource (&g_Connection, NULL, NULL, 0);
                if (message == MESSAGE_PASSWORDWRONG) {
                    numTry ++;
                    if (numTry >= 3) {
                        // let's tell the destination computer that we are bailing out.
                        SendMessageToDestination (&g_Connection, MESSAGE_CANCEL);

                        // BUGBUG - better error message
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                        extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                        extraData.ObjectTypeId = 0;
                        extraData.ObjectName = NULL;
                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                        __leave;
                    }
                }
            } while (message == MESSAGE_PASSWORDWRONG);

            if (message != MESSAGE_PASSWORDOK) {
                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        //
        // Enumerate all objects with "save" attribute
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // Send keep-alive to connection every 30 seconds of idle time
                //

                if (!Compressed) {
                    if (GetTickCount() - g_Connection.LastSend > g_Connection.KeepAliveSpacing) {
                        SendMessageToDestination (&g_Connection, MESSAGE_KEEP_ALIVE);
                    }
                }

                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                            extraData.ErrorArea = ERRUSER_AREA_SAVE;
                            extraData.ObjectTypeId = objEnum.ObjectTypeId;
                            extraData.ObjectName = objEnum.ObjectName;
                            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = BuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                    if (Compressed) {
                        appInfo.SubPhase = SUBPHASE_COMPRESSING;
                    } else {
                        appInfo.SubPhase = SUBPHASE_TRANSPORTING;
                    }
                    appInfo.ObjectTypeId = (objEnum.ObjectTypeId & (~PLATFORM_MASK));
                    appInfo.ObjectName = objEnum.ObjectName;
                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pHomeNetSaveContentInFile (
                                    objEnum.ObjectTypeId,
                                    objEnum.ObjectName,
                                    decoratedObject,
                                    convValue,
                                    cabHandle
                                    )) {

                                if (GetLastError () == ERROR_NETWORK_UNREACHABLE) {
                                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    IsmAbortPersistentObjectEnum (&objEnum);
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->FileContent.ContentSize;
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pHomeNetSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->MemoryContent.ContentSize;
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    DestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                IsmTickProgressBar (g_PersistentSlice, 1);

                //
                // Send bytes saved to app every 3 seconds
                //

                bytesSaved += size;

                if (GetTickCount() - lastTick > 3000) {

                    if (bytesSaved < 1048576) {

                        argArray[0] = (PCTSTR) (UINT_PTR) (bytesSaved / 1024);
                        statusMsg = ParseMessageID (MSG_SAVED_K, argArray);

                    } else if (bytesSaved < 8388608) {

                        fraction = (UINT) (bytesSaved / 10485);
                        argArray[0] = (PCTSTR) (UINT_PTR) (fraction / 100);
                        argArray[1] = (PCTSTR) (UINT_PTR) (fraction % 100);
                        statusMsg = ParseMessageID (MSG_SAVED_M, argArray);

                    } else if (bytesSaved < 1073741824) {

                        argArray[0] = (PCTSTR) (UINT_PTR) (bytesSaved / 1048576);
                        statusMsg = ParseMessageID (MSG_SAVED_M2, argArray);

                    } else {

                        fraction = (UINT) (bytesSaved / 10737418);
                        argArray[0] = (PCTSTR) (UINT_PTR) (fraction / 100);
                        argArray[1] = (PCTSTR) (UINT_PTR) (fraction % 100);
                        statusMsg = ParseMessageID (MSG_SAVED_G, argArray);
                    }

                    IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, (ULONG_PTR) statusMsg);

                    FreeStringResource (statusMsg);
                    lastTick = GetTickCount();
                }

            } while (IsmEnumNextPersistentObject (&objEnum));
        }

        ourDbFile = AllocStorageFileName (S_TRANSPORT_DAT_FILE);
        if (!ourDbFile) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        DEBUGMSG ((DBG_HOMENET, "Saving memdb"));

        BfCreateDirectory (g_TransportTempDir);
        if (!MemDbSave (ourDbFile)) {
            DEBUGMSG ((DBG_ERROR, "Can't save our database to %s", ourDbFile));
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        if (Compressed) {
            if (!pHomeNetAddFileToImage (ourDbFile, S_TRANSPORT_DAT_FILE, cabHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
            if (!CabFlushAndCloseCabinetEx (cabHandle, NULL, NULL, &fileCount, &fileSize)) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }

            DEBUGMSG ((DBG_HOMENET, "Compression results: files=%u size=%u", fileCount, (UINT) fileSize));
            g_Metrics.FileCount += fileCount;
            g_Metrics.TotalSize += fileSize;

            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_CONNECTING1;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            if (!FindDestination (&destination, 0, FALSE)) {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_FIND_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                }
                __leave;
            }

            if (!ConnectToDestination (&destination, &g_Metrics, &g_Connection)) {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CONNECT_TO_DESTINATION));
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                }
                __leave;
            }

            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_FINISHING;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            if (!pHomeNetWriteAllImages ()) {
                extraData.Error = ERRUSER_ERROR_CANTSENDTODEST;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        } else {
            ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
            appInfo.Phase = MIG_TRANSPORT_PHASE;
            appInfo.SubPhase = SUBPHASE_FINISHING;
            IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

            DEBUGMSG ((DBG_HOMENET, "Transporting memdb"));

            if (!pTransportFile (ourDbFile, ourDbFile)) {
                if (GetLastError () == ERROR_NETWORK_UNREACHABLE) {
                    extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                    __leave;
                } else {
                    extraData.Error = ERRUSER_ERROR_CANTSENDTODEST;
                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                    extraData.ObjectTypeId = 0;
                    extraData.ObjectName = NULL;
                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                    __leave;
                }
            }
        }

        DEBUGMSG ((DBG_HOMENET, "Transporting status file"));

        pSetTransportStatus (g_StatusFileHandle, g_CompressData, TRSTATUS_READY);
        CloseHandle (g_StatusFileHandle);
        g_StatusFileHandle = INVALID_HANDLE_VALUE;

        if (!pTransportFile (g_StatusFile, g_StatusFile)) {
            if (GetLastError () == ERROR_NETWORK_UNREACHABLE) {
                extraData.Error = ERRUSER_ERROR_CANTFINDDESTINATION;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            } else {
                extraData.Error = ERRUSER_ERROR_CANTSENDTODEST;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        DEBUGMSG ((DBG_HOMENET, "Done sending files"));

        SendMessageToDestination (&g_Connection, MESSAGE_DONE);
        if (MESSAGE_DONE != ReceiveFromSource (&g_Connection, NULL, NULL, 0)) {
            if (GetLastError() != WSAECONNRESET) {
                DEBUGMSG ((DBG_ERROR, "No acknowledgement from the destination"));
                extraData.Error = ERRUSER_ERROR_CANTSENDTODEST;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, 0);
        result = TRUE;

    }
    __finally {

        PushError ();

        FreeStorageFileName (ourDbFile);
        INVALID_POINTER (ourDbFile);

        DestroyDecoratedObject (decoratedObject);
        INVALID_POINTER (decoratedObject);

        CloseConnection (&g_Connection);

        PopError ();
    }

    return result;
}


BOOL
WINAPI
HomeNetTransportSaveState (
    VOID
    )
{
    ERRUSER_EXTRADATA extraData;

    g_Platform = PLATFORM_SOURCE;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    g_StatusFileHandle = BfCreateFile (g_StatusFile);
    if (g_StatusFileHandle == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_NET_STATUS_FILE));
        extraData.Error = ERRUSER_ERROR_NOTRANSPORTPATH;
        extraData.ErrorArea = ERRUSER_AREA_SAVE;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
        return FALSE;
    }

    return pSaveAllState (g_CompressData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tmrmvmed.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\removemed.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    removemed.c

Abstract:

    Implements a transport module that works with removable media

Author:

    Calin Negreanu (calinn) 24-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <compress.h>

#define DBG_RMVMED    "RmvMed"

//
// Strings
//

#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_DEST_FILE   TEXT("USMT2IMG.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")
#define S_UNCOMPRESSED_FILE     TEXT("TEMPFILE.DAT")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//
#define TRFLAG_FILE         0x01
#define TRFLAG_MEMORY       0x02
#define COPY_BUFFER_SIZE    32768
#define RMVMEDTR_OLDSIG1    0x55534D31  //USM1
#define RMVMEDTR_OLDSIG2    0x55534D32  //USM2
#define RMVMEDTR_OLDSIG3    0x55534D33  //USM3
#define RMVMEDTR_CONVSIG    0x55534D33  //USM3
#define RMVMEDTR_SIG        0x55534D34  //USM4

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

typedef struct {
    DWORD Signature;
    DWORD LastImage;
    DWORD ImageNr;
    DWORD CheckSum;
    LONGLONG TotalImageSize;
} IMAGE_HEADER, *PIMAGE_HEADER;

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_RemovableMediaId;
UINT g_RmvMedPlatform;
PCTSTR g_RemovableMediaPath = NULL;
PCTSTR g_RmvMedTempPath = NULL;
MIG_PROGRESSSLICEID g_PersistentSlice;
MIG_PROGRESSSLICEID g_DatabaseSlice;
UINT g_CompressedTicks;
UINT g_CompressedTicked;
MIG_PROGRESSSLICEID g_CompressedSlice;
UINT g_DownloadTicks;
UINT g_DownloadTicked;
MIG_PROGRESSSLICEID g_DownloadSlice;
UINT g_UncompressTicks;
UINT g_UncompressTicked;
MIG_PROGRESSSLICEID g_UncompressSlice;
LONGLONG g_TotalFiles;
LONGLONG g_FilesRead;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pCleanupTempDir (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
WINAPI
RmvMedTransportInitialize (
    PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_RemovableMediaId = IsmRegisterTransport (S_REMOVABLE_MEDIA_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
RmvMedTransportTerminate (
    VOID
    )
{
    pCleanupTempDir ();

    if (g_RmvMedTempPath) {
        FreePathString (g_RmvMedTempPath);
        g_RmvMedTempPath = NULL;
    }
    if (g_RemovableMediaPath) {
        FreePathString (g_RemovableMediaPath);
        g_RemovableMediaPath = NULL;
    }
}

VOID
WINAPI
RmvMedTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on the count of the
        // persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        g_DatabaseSlice = IsmRegisterProgressSlice (3, 1);

        g_CompressedTicks = ticks;

        g_CompressedSlice = IsmRegisterProgressSlice (g_CompressedTicks, max (1, g_CompressedTicks / 5));
    } else {
        g_DownloadTicked = 0;
        g_DownloadTicks = 1000;
        g_DownloadSlice = IsmRegisterProgressSlice (g_DownloadTicks, 180);
        g_UncompressTicked = 0;
        g_UncompressTicks = 1000;
        g_UncompressSlice = IsmRegisterProgressSlice (g_UncompressTicks, 180);
    }
}

BOOL
WINAPI
RmvMedTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_RemovableMediaId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED;
    *FriendlyDescription = TEXT("Span Media");
    return TRUE;
}

VOID
pCleanupTempDir (
    VOID
    )
{
    if (g_RmvMedTempPath) {
        FiRemoveAllFilesInTree (g_RmvMedTempPath);
    }
}

PCTSTR
pCreateTemporaryDir (
    VOID
    )
{
    TCHAR tempFile[MAX_PATH];

    if (!IsmGetTempDirectory (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }
    return DuplicatePathString (tempFile, 0);
}

BOOL
WINAPI
RmvMedTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    BOOL result = FALSE;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_RemovableMediaId) {

        if ((!RequiredCapabilities) || (RequiredCapabilities == CAPABILITY_COMPRESSED)) {

            if (g_RemovableMediaPath) {
                FreePathString (g_RemovableMediaPath);
                g_RemovableMediaPath = NULL;
            }
            g_RemovableMediaPath = DuplicatePathString (StoragePath, 0);

            if (Valid) {
                *Valid = TRUE;
            }

            if (ImageExists) {
                if (Platform == PLATFORM_SOURCE) {
                    *ImageExists = FALSE;
                } else {
                    *ImageExists = TRUE;
                }
            }

            result = TRUE;
        }
    }
    return result;
}

PCTSTR
pBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    PCTSTR typeStr;

    typeStr = IsmGetObjectTypeName (ObjectTypeId);
    if (!typeStr) {
        return NULL;
    }

    return JoinPaths (typeStr, ObjectName);
}

VOID
pDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b = FALSE;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    if (key) {

        b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

        FreeText (key);
    }

    return b;
}

PCTSTR
pAllocStorageFileName (
    VOID
    )
{
    static UINT fileIndex = 0;
    TCHAR buffer [32];

    fileIndex ++;
    wsprintf (buffer, TEXT("%08X.DAT"), fileIndex);

    return DuplicatePathString (buffer, 0);
}

BOOL
pSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT ObjectValue
    )
{
    BOOL result = FALSE;

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (ObjectValue->MemoryContent.ContentBytes && ObjectValue->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            ObjectValue->MemoryContent.ContentBytes,
            ObjectValue->MemoryContent.ContentSize
            );
    }

    result = pSaveDetails (DecoratedObject, &ObjectValue->Details);

    return result;
}

BOOL
pAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR StoredName,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    return CompressAddFileToHandle (FileName, StoredName, CompressedHandle);
}

BOOL
pSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;
    DWORD attributes = INVALID_ATTRIBUTES;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use the CopyFile API to move the file from local to storage.
    //

    __try {
        if (Content && (Content->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) && Content->Details.DetailsData) {
            attributes = ((PWIN32_FIND_DATAW)Content->Details.DetailsData)->dwFileAttributes;
        }
        if ((attributes != INVALID_ATTRIBUTES) && (attributes & FILE_ATTRIBUTE_DIRECTORY)) {

            // this must be a directory, let's just write the key

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }
            result = TRUE;

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = pAllocStorageFileName ();
            if (!destPath) {
                __leave;
            }

            if (!pAddFileToImage (Content->FileContent.ContentPath, destPath, CompressedHandle)) {
                __leave;
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, destPath, 0)) {
                __leave;
            }

            FreePathString (destPath);
            destPath = NULL;
        }

        //
        // Save details
        //

        result = pSaveDetails (DecoratedObject, &(Content->Details));
    }
    __finally {
        if (destPath) {
            FreePathString (destPath);
            destPath = NULL;
        }
    }

    return result;
}

PCTSTR
pGetImageFile (
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (g_RmvMedTempPath, imageFileName);
}

BOOL
pIsOurMedia (
    IN      PCTSTR MediaFile,
    IN      DWORD CheckSum,
    IN      UINT MediaIdx
    )
{
    HANDLE mediaHandle = NULL;
    IMAGE_HEADER imageHeader;
    BOOL result = FALSE;

    mediaHandle = BfOpenReadFile (MediaFile);
    if (!mediaHandle) {
        return result;
    }

    if (BfReadFile (mediaHandle, (PBYTE)(&imageHeader), sizeof (imageHeader))) {
        if ((imageHeader.Signature == RMVMEDTR_SIG) &&
            (imageHeader.CheckSum == CheckSum) &&
            (imageHeader.ImageNr != MediaIdx)
            ) {
            result = TRUE;
        }
    }

    CloseHandle (mediaHandle);
    return result;
}

HANDLE
pLocalCreateFile (
    IN      PCTSTR FileName
    )
{
    HANDLE h;

    h = CreateFile (
            FileName,
            GENERIC_READ|GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_WRITE_THROUGH,
            NULL
            );

    if (h == INVALID_HANDLE_VALUE) {
        h = NULL;
    }

    return h;
}

BOOL
pWriteToMedia (
    IN      HANDLE MediaHandle,
    IN      PBYTE Data,
    IN      DWORD DataSize,
    IN      UINT MediaIdx,
    OUT     RMEDIA_ERR *Error
    )
{
    DWORD err;
    RMEDIA_EXTRADATA extraData;
    INT_PTR appReply;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;

    if (!BfWriteFile (MediaHandle, Data, DataSize)) {
        error = RMEDIA_ERR_GENERALERROR;
        // let's see the error code
        err = GetLastError ();
        if (err == ERROR_DISK_FULL) {
            error = RMEDIA_ERR_DISKFULL;
        }
        if (err == ERROR_NOT_READY) {
            error = RMEDIA_ERR_NOTREADY;
        }
        if (Error) {
            *Error = error;
        }
        return FALSE;
    }
    if (Error) {
        *Error = RMEDIA_ERR_NOERROR;
    }
    return TRUE;
}

VOID
pWriteImageToMedia (
    IN      ULONGLONG TotalImageSize,
    IN      DWORD CheckSum,
    IN OUT  PUINT MediaIdx,
    IN OUT  PUINT ImageIdx,
    IN OUT  PULONGLONG ImagePtr,
    OUT     PULONGLONG TotalImageWritten,
    OUT     PRMEDIA_ERR Error,
    OUT     PBOOL Done
    )
{
    static ULONGLONG totalImageWritten = 0;
    ULONGLONG imageWrittenLast = totalImageWritten;
    PCTSTR imageFile = NULL;
    PCTSTR mediaFile = NULL;
    HANDLE imageHandle = NULL;
    HANDLE mediaHandle = NULL;
    IMAGE_HEADER imageHeader;
    UINT mediaIdx;
    UINT imageIdx;
    ULONGLONG imagePtr;
    ULONGLONG imageSize;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;
    BOOL done = FALSE;
    PBYTE memImage = NULL;
    DWORD chunkSize;
    ULARGE_INTEGER thisMediaMaxSize;
    ULARGE_INTEGER dummy1, dummy2;
    FARPROC pGetDiskFreeSpaceEx;
    DWORD sectPerClust;
    DWORD bytesPerSect;
    DWORD freeClusters;
    DWORD totalClusters;
    DWORD err;
    BOOL deleteFile = FALSE;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;

    mediaIdx = *MediaIdx;
    imageIdx = *ImageIdx;
    imagePtr = *ImagePtr;
    imageFile = pGetImageFile (imageIdx);
    imageSize = BfGetFileSize (imageFile);
    mediaFile = JoinPaths (g_RemovableMediaPath, S_TRANSPORT_DEST_FILE);

    __try {
        if (!DoesFileExist (imageFile)) {
            DEBUGMSG ((DBG_ERROR, "Image file does not exist: %s", imageFile));
            done = TRUE;
            __leave;
        }
        imageHandle = BfOpenReadFile (imageFile);
        if (!imageHandle) {
            DEBUGMSG ((DBG_ERROR, "Can't open image file %s", imageFile));
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        if (!BfSetFilePointer (imageHandle, imagePtr)) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        if (pIsOurMedia (mediaFile, CheckSum, mediaIdx)) {
            DEBUGMSG ((DBG_ERROR, "Cannot overwrite our own file %s", mediaFile));
            error = RMEDIA_ERR_USEDMEDIA;
            __leave;
        }
        mediaHandle = BfCreateFile (mediaFile);
        if (!mediaHandle) {
            error = RMEDIA_ERR_GENERALERROR;
            err = GetLastError ();
            if ((err == ERROR_ACCESS_DENIED) ||
                (err == ERROR_SHARING_VIOLATION)
                ) {
                error = RMEDIA_ERR_WRONGMEDIA;
            }
            if (err == ERROR_WRITE_PROTECT) {
                error = RMEDIA_ERR_WRITEPROTECT;
            }
            if (err == ERROR_NOT_READY) {
                error = RMEDIA_ERR_NOTREADY;
            }
            DEBUGMSG ((DBG_ERROR, "Can't create media file %s", mediaFile));
            __leave;
        }

        deleteFile = TRUE;

        imageHeader.Signature = RMVMEDTR_SIG;
        imageHeader.LastImage = 0;
        imageHeader.ImageNr = mediaIdx;
        imageHeader.CheckSum = CheckSum;
        imageHeader.TotalImageSize = TotalImageSize;
        if (!pWriteToMedia (mediaHandle, (PBYTE)(&imageHeader), sizeof (imageHeader), mediaIdx, &error)) {
            DEBUGMSG ((DBG_ERROR, "Can't write header to media file %s", mediaFile));
            __leave;
        }
        memImage = HeapAlloc (g_hHeap, 0, COPY_BUFFER_SIZE);
        if (!memImage) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }

        while (TRUE) {
            if (IsmCheckCancel()) {
                error = RMEDIA_ERR_CRITICAL;
                done = TRUE;
            }
            if (imagePtr == 0) {
                // let's write this image size to the file
                if (!pWriteToMedia (mediaHandle, (PBYTE)(&imageSize), sizeof (imageSize), mediaIdx, &error)) {
                    DEBUGMSG ((DBG_ERROR, "Can't write image size to media file %s", mediaFile));
                    __leave;
                }
            }

            while (imageSize > imagePtr) {
                if (IsmCheckCancel()) {
                    error = RMEDIA_ERR_CRITICAL;
                    done = TRUE;
                }
                chunkSize = COPY_BUFFER_SIZE;
                if ((ULONGLONG)chunkSize > (imageSize - imagePtr)) {
                    chunkSize = (DWORD)(imageSize - imagePtr);
                }
                if (!BfReadFile (imageHandle, memImage, chunkSize)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from image file %s", imageFile));
                    error = RMEDIA_ERR_CRITICAL;
                    done = TRUE;
                    __leave;
                }
                if (!pWriteToMedia (mediaHandle, memImage, chunkSize, mediaIdx, &error)) {
                    // write failed, let's see if we just ran out of space

                    if (error == RMEDIA_ERR_DISKFULL) {

                        // the disk is (almost) full
                        // we will make an attempt to use the remaining space
                        // either way we do not consider this an error
                        done = FALSE;
                        mediaIdx ++;

                        // Find out if GetDiskFreeSpaceEx is supported
#ifdef UNICODE
                        pGetDiskFreeSpaceEx = GetProcAddress( GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExW");
#else
                        pGetDiskFreeSpaceEx = GetProcAddress( GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExA");
#endif
                        if (pGetDiskFreeSpaceEx) {
                            if (!pGetDiskFreeSpaceEx (g_RemovableMediaPath, &dummy1, &dummy2, &thisMediaMaxSize)) {
                                DEBUGMSG ((DBG_WHOOPS, "Can't get media free space of %s using EX routine", g_RemovableMediaPath));
                                __leave;
                            }
                        } else {
                            if (GetDiskFreeSpace (g_RemovableMediaPath, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                                thisMediaMaxSize.QuadPart = Int32x32To64 ((sectPerClust * bytesPerSect), freeClusters);
                            } else {
                                DEBUGMSG ((DBG_WHOOPS, "Can't get media free space of %s", g_RemovableMediaPath));
                                __leave;
                            }
                        }

                        // regardless of the outcome of the next write we don't want to report an error
                        error = 0;

                        if (thisMediaMaxSize.LowPart < chunkSize) {
                            if (thisMediaMaxSize.LowPart) {
                                // we attempt one more write with the
                                // available media disk size
                                if (!pWriteToMedia (mediaHandle, memImage, thisMediaMaxSize.LowPart, mediaIdx, &error)) {
                                    // this should have succeeded but...
                                    DEBUGMSG ((DBG_WHOOPS, "Can't write the remaining free bytes. Something is wrong with GetDiskFreeSpace %s", mediaFile));
                                    // regardless of the outcome of this write we don't want to report an error
                                    error = 0;
                                    __leave;
                                }

                                // let's adjust imagePtr
                                imagePtr += thisMediaMaxSize.LowPart;
                                totalImageWritten += thisMediaMaxSize.LowPart;
                            }
                        }
                    } else {
                        error = RMEDIA_ERR_GENERALERROR;
                    }
                    __leave;
                } else {
                    imagePtr += chunkSize;
                    totalImageWritten += chunkSize;
                }

                // now update the progress bar
                numerator = (LONGLONG) totalImageWritten * (LONGLONG) g_CompressedTicks;
                divisor = (LONGLONG) TotalImageSize;
                if (divisor) {
                    tick = numerator / divisor;
                } else {
                    tick = 0;
                }
                delta = (UINT) tick - g_CompressedTicked;
                if (delta) {
                    if (!IsmTickProgressBar (g_CompressedSlice, delta)) {
                        error = RMEDIA_ERR_CRITICAL;
                        done = TRUE;
                        __leave;
                    }
                    g_CompressedTicked += delta;
                }
            }
            // we just finished writing the image, let's see if there is some other image out there
            imageIdx ++;
            CloseHandle (imageHandle);
            imageHandle = NULL;
            FreePathString (imageFile);
            imageFile = pGetImageFile (imageIdx);
            if (!DoesFileExist (imageFile)) {
                imageSize = 0;
                imagePtr = 0;
                // let's go back and write that this is the last media
                if (!BfSetFilePointer (mediaHandle, 0)) {
                    DEBUGMSG ((DBG_ERROR, "Can't update media file %s", mediaFile));
                    error = RMEDIA_ERR_GENERALERROR;
                    __leave;
                }
                imageHeader.LastImage = 1;
                if (!pWriteToMedia (mediaHandle, (PBYTE)(&imageHeader), sizeof (imageHeader), mediaIdx, &error)) {
                    DEBUGMSG ((DBG_ERROR, "Can't update media file %s", mediaFile));
                    __leave;
                }
                done = TRUE;
                __leave;
            }
            imageSize = BfGetFileSize (imageFile);
            imagePtr = 0;
            imageHandle = BfOpenReadFile (imageFile);
            if (!imageHandle) {
                DEBUGMSG ((DBG_ERROR, "Can't open next image file %s", imageFile));
                error = RMEDIA_ERR_CRITICAL;
                done = TRUE;
                __leave;
            }
        }
    }
    __finally {

        if (mediaHandle) {
            if (error == RMEDIA_ERR_NOERROR) {
                if (!FlushFileBuffers (mediaHandle)) {
                    error = RMEDIA_ERR_GENERALERROR;
                    // let's see the error code
                    err = GetLastError ();
                    if (err == ERROR_NOT_READY) {
                        error = RMEDIA_ERR_NOTREADY;
                    }
                    done = FALSE;
                }
            }
            CloseHandle (mediaHandle);
            mediaHandle = NULL;
        }

        if ((error != RMEDIA_ERR_NOERROR) &&
            mediaFile &&
            deleteFile
            ) {
            DeleteFile (mediaFile);
        }

        if (memImage) {
            HeapFree (g_hHeap, 0, memImage);
            memImage = NULL;
        }

        if (imageHandle) {
            CloseHandle (imageHandle);
            imageHandle = NULL;
        }

        if (imageFile) {
            FreePathString (imageFile);
            imageFile = NULL;
        }

        if (mediaFile) {
            FreePathString (mediaFile);
            mediaFile = NULL;
        }
    }
    if (!error) {
        *MediaIdx = mediaIdx;
        *ImageIdx = imageIdx;
        *ImagePtr = imagePtr;
    } else {
        totalImageWritten = imageWrittenLast;
    }
    if (TotalImageWritten) {
        *TotalImageWritten = totalImageWritten;
    }
    *Error = error;
    *Done = done;
}

BOOL
pWriteAllImages (
    VOID
    )
{
    ULONGLONG totalImageSize = 0;
    ULONGLONG totalImageWritten = 0;
    ULONGLONG imageSize = 0;
    UINT mediaIdx = 1;
    UINT imageIdx = 1;
    ULONGLONG imagePtr = 0;
    PCTSTR imageFile;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;
    BOOL done = FALSE;
    BOOL result = TRUE;
    BOOL diskFull = FALSE;
    INT_PTR appReply;
    INT r1,r2,r3;
    DWORD checkSum;
    RMEDIA_EXTRADATA extraData;

    // let's get the total image size for the progress bar
    imageIdx = 1;
    while (TRUE) {
        imageFile = pGetImageFile (imageIdx);
        imageSize = BfGetFileSize (imageFile);
        if (imageSize == 0) {
            FreePathString (imageFile);
            break;
        }
        totalImageSize += imageSize;
        FreePathString (imageFile);
        imageIdx ++;
    }
    imageIdx = 1;

    imageFile = pGetImageFile (imageIdx);

    srand( GetTickCount());
    r1 = rand();
    r2 = rand();
    r3 = rand();
    checkSum = r1 + r2 * 32768 + (r3 & 3) * 1073741824;
    FreePathString (imageFile);

    while (!done) {
        // send the proper message to the app

        extraData.LastError = error;
        extraData.MediaNumber = mediaIdx;
        extraData.TotalImageSize = totalImageSize;
        extraData.TotalImageWritten = totalImageWritten;
        appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_RMEDIA_SAVE, (ULONG_PTR)&extraData);

        if (!appReply) {
            //
            // user cancelled
            //
            done = TRUE;
            result = FALSE;
            continue;
        }

        // write this disk and loop until we finish
        pWriteImageToMedia (totalImageSize, checkSum, &mediaIdx, &imageIdx, &imagePtr, &totalImageWritten, &error, &done);

        if (done) {
            result = !error;
        }
    }
    return result;
}

BOOL
WINAPI
RmvMedTransportSaveState (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR databaseFile = NULL;
    PCTSTR decoratedObject = NULL;
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    COMPRESS_HANDLE compressedHandle;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
#ifdef DEBUG
    PCTSTR nativeObjectName;
#endif
    BOOL result = FALSE;

    g_RmvMedPlatform = PLATFORM_SOURCE;

    __try {

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_PREPARING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        ZeroMemory (&compressedHandle, sizeof (COMPRESS_HANDLE));

        g_RmvMedTempPath = pCreateTemporaryDir ();

        if (!g_RmvMedTempPath) {
            extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

#ifdef PRERELEASE
        {
            HINF debugInfHandle;
            INFSTRUCT context = INITINFSTRUCT_PMHANDLE;
            DWORD maxSize = 0;

            debugInfHandle = InfOpenInfFile (TEXT("c:\\debug.inf"));
            if (debugInfHandle && (debugInfHandle != INVALID_HANDLE_VALUE)) {
                if (InfFindFirstLine (
                        debugInfHandle,
                        TEXT("RemovableMedia"),
                        TEXT("LimitCabSize"),
                        &context
                        )
                    ) {
                    InfGetIntField (&context, 1, &maxSize);
                }
                InfCleanUpInfStruct (&context);
            }
            if (!CompressCreateHandle (g_RmvMedTempPath, S_TRANSPORT_IMG_FILE, 1, maxSize, &compressedHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }
#else
        if (!CompressCreateHandle (g_RmvMedTempPath, S_TRANSPORT_IMG_FILE, 1, 0, &compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }
#endif

        //
        // Enumerate all persistent objects
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                if (IsmCheckCancel()) {
                    __leave;
                }

#ifdef DEBUG
                nativeObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                DEBUGMSG ((DBG_RMVMED, "Transporting: %s", nativeObjectName));
                IsmReleaseMemory (nativeObjectName);
#endif

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                            extraData.ErrorArea = ERRUSER_AREA_SAVE;
                            extraData.ObjectTypeId = objEnum.ObjectTypeId;
                            extraData.ObjectName = objEnum.ObjectName;
                            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = pBuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                    appInfo.SubPhase = SUBPHASE_COMPRESSING;
                    appInfo.ObjectTypeId = (objEnum.ObjectTypeId & (~PLATFORM_MASK));
                    appInfo.ObjectName = objEnum.ObjectName;
                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pSaveContentInFile (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue, &compressedHandle)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    pDestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                IsmTickProgressBar (g_PersistentSlice, 1);

                if (IsmCheckCancel()) {
                    __leave;
                }

            } while (IsmEnumNextPersistentObject (&objEnum));

            IsmAbortPersistentObjectEnum (&objEnum);
        }

        if (IsmCheckCancel()) {
            __leave;
        }

        databaseFile = JoinPaths (g_RmvMedTempPath, S_TRANSPORT_DAT_FILE);

        if (!MemDbSave (databaseFile)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (IsmCheckCancel()) {
            __leave;
        }

        if (!pAddFileToImage (databaseFile, S_TRANSPORT_DAT_FILE, &compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        FreePathString (databaseFile);
        databaseFile = NULL;

        if (!CompressFlushAndCloseHandle (&compressedHandle)) {
            extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (IsmCheckCancel()) {
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_MEDIAWRITING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!pWriteAllImages ()) {
            extraData.Error = ERRUSER_ERROR_CANTWRITETODESTPATH;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        result = TRUE;

    }
    __finally {

        PushError ();

        CompressCleanupHandle (&compressedHandle);

        if (databaseFile) {
            FreePathString (databaseFile);
            databaseFile = NULL;
        }

        PopError ();
    }

    PushError ();

    pCleanupTempDir ();

    PopError ();

    return result;
}

VOID
pReadImageFromMedia (
    IN      PDWORD CheckSum,
    IN OUT  PUINT MediaIdx,
    IN OUT  PUINT ImageIdx,
    IN OUT  PULONGLONG ImageRemaining,
    OUT     PRMEDIA_ERR Error,
    OUT     PBOOL Done
    )
{
    static ULONGLONG totalImageSize = 0;
    static ULONGLONG totalImageRead = 0;
    ULONGLONG imageReadLast = totalImageRead;
    PCTSTR imageFile = NULL;
    PCTSTR mediaFile = NULL;
    HANDLE imageHandle = NULL;
    HANDLE mediaHandle = NULL;
    IMAGE_HEADER imageHeader;
    DWORD checkSum;
    UINT mediaIdx;
    UINT imageIdx;
    ULONGLONG imageRemaining;
    ULONGLONG imageSize;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;
    RMEDIA_EXTRADATA extraData;
    INT_PTR appReply;
    BOOL done = FALSE;
    PBYTE memImage = NULL;
    DWORD chunkSize;
    DWORD bytesRead;
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;
    DWORD err;

    checkSum = *CheckSum;
    mediaIdx = *MediaIdx;
    imageIdx = *ImageIdx;
    imageRemaining = *ImageRemaining;
    mediaFile = JoinPaths (g_RemovableMediaPath, S_TRANSPORT_DEST_FILE);

    __try {
        mediaHandle = BfOpenReadFile (mediaFile);
        if (!mediaHandle) {
            error = RMEDIA_ERR_WRONGMEDIA;
            err = GetLastError ();
            if (err == ERROR_NOT_READY) {
                error = RMEDIA_ERR_NOTREADY;
            }
            DEBUGMSG ((DBG_ERROR, "Can't create media file %s", mediaFile));
            __leave;
        }
        imageFile = pGetImageFile (imageIdx);
        if (DoesFileExist (imageFile)) {
            imageSize = BfGetFileSize (imageFile);
            imageHandle = BfOpenFile (imageFile);
        } else {
            imageSize = 0;
            imageHandle = BfCreateFile (imageFile);
        }
        if (!imageHandle) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        if (!BfSetFilePointer (imageHandle, imageSize)) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        if (!BfReadFile (mediaHandle, (PBYTE)(&imageHeader), sizeof (imageHeader))) {
            error = RMEDIA_ERR_WRONGMEDIA;
            err = GetLastError ();
            if (err == ERROR_NOT_READY) {
                error = RMEDIA_ERR_NOTREADY;
            }
            __leave;
        }
        if (imageHeader.Signature != RMVMEDTR_SIG) {
            if ((imageHeader.Signature != RMVMEDTR_OLDSIG1) &&
                (imageHeader.Signature != RMVMEDTR_OLDSIG2) &&
                (imageHeader.Signature != RMVMEDTR_OLDSIG3)
                ) {
                error = RMEDIA_ERR_WRONGMEDIA;
                __leave;
            }
            error = RMEDIA_ERR_OLDMEDIA;
            __leave;
        }
        if (imageHeader.ImageNr != mediaIdx) {
            error = RMEDIA_ERR_WRONGMEDIA;
            __leave;
        }
        if (checkSum) {
            if (checkSum != imageHeader.CheckSum) {
                error = RMEDIA_ERR_WRONGMEDIA;
                __leave;
            }
        } else {
            checkSum = imageHeader.CheckSum;
        }
        totalImageSize = imageHeader.TotalImageSize;
        memImage = HeapAlloc (g_hHeap, 0, COPY_BUFFER_SIZE);
        if (!memImage) {
            error = RMEDIA_ERR_CRITICAL;
            done = TRUE;
            __leave;
        }
        while (TRUE) {
            if (IsmCheckCancel()) {
                error = RMEDIA_ERR_CRITICAL;
                done = TRUE;
            }
            if (imageRemaining == 0) {
                // let's read this image size to the file
                if (!BfReadFile (mediaHandle, (PBYTE)(&imageRemaining), sizeof (imageRemaining))) {
                    error = RMEDIA_ERR_GENERALERROR;
                    err = GetLastError ();
                    if (err == ERROR_NOT_READY) {
                        error = RMEDIA_ERR_NOTREADY;
                    }
                    __leave;
                }
            }
            while (imageRemaining) {
                if (IsmCheckCancel()) {
                    error = RMEDIA_ERR_CRITICAL;
                    done = TRUE;
                }
                chunkSize = COPY_BUFFER_SIZE;
                if ((ULONGLONG)chunkSize > imageRemaining) {
                    chunkSize = (DWORD)(imageRemaining);
                }
                while (TRUE) {
                    if (!ReadFile (mediaHandle, memImage, chunkSize, &bytesRead, NULL)) {
                        // let's see the error code
                        err = GetLastError ();
                        if (err == ERROR_NOT_READY) {
                            error = RMEDIA_ERR_NOTREADY;
                            extraData.LastError = error;
                            extraData.MediaNumber = mediaIdx;
                            extraData.TotalImageSize = 0;
                            extraData.TotalImageWritten = 0;
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_RMEDIA_LOAD, (ULONG_PTR)&extraData);
                            if (!appReply) {
                                //
                                // user cancelled
                                //
                                error = RMEDIA_ERR_CRITICAL;
                                done = TRUE;
                                __leave;
                            } else {
                                error = RMEDIA_ERR_NOERROR;
                                continue;
                            }
                        }
                        // read failed, major problem, exiting
                        error = RMEDIA_ERR_GENERALERROR;
                        __leave;
                    } else {
                        break;
                    }
                }
                if (!BfWriteFile (imageHandle, memImage, bytesRead)) {
                    // major problem, exiting
                    error = RMEDIA_ERR_CRITICAL;
                    done = TRUE;
                    __leave;
                }
                imageRemaining -= bytesRead;
                totalImageRead += bytesRead;

                // now update the progress bar
                numerator = (LONGLONG) totalImageRead * (LONGLONG) g_DownloadTicks;
                divisor = (LONGLONG) totalImageSize;
                if (divisor) {
                    tick = numerator / divisor;
                } else {
                    tick = 0;
                }
                delta = (UINT) tick - g_DownloadTicked;
                if (delta) {
                    if (!IsmTickProgressBar (g_DownloadSlice, delta)) {
                        error = RMEDIA_ERR_CRITICAL;
                        done = TRUE;
                        __leave;
                    }
                    g_DownloadTicked += delta;
                }

                if (bytesRead != chunkSize) {
                    // our media image is done, let's get the new one
                    mediaIdx ++;
                    done = FALSE;
                    __leave;
                }
            }
            // we just finished reading the image, let's see if there is some other image out there
            // let's read this image size to the file
            if (!BfReadFile (mediaHandle, (PBYTE)(&imageRemaining), sizeof (imageRemaining))) {
                if (imageHeader.LastImage) {
                    done = TRUE;
                } else {
                    error = RMEDIA_ERR_GENERALERROR;
                    err = GetLastError ();
                    if (err == ERROR_NOT_READY) {
                        error = RMEDIA_ERR_NOTREADY;
                    }
                }
                __leave;
            }
            CloseHandle (imageHandle);
            FreePathString (imageFile);
            imageIdx ++;
            imageFile = pGetImageFile (imageIdx);
            imageHandle = BfCreateFile (imageFile);
            if (!imageHandle) {
                error = RMEDIA_ERR_CRITICAL;
                done = TRUE;
                __leave;
            }
        }
    }
    __finally {
        if (memImage) {
            HeapFree (g_hHeap, 0, memImage);
            memImage = NULL;
        }
        if (imageHandle) {
            CloseHandle (imageHandle);
            imageHandle = NULL;
        }
        if (imageFile) {
            FreePathString (imageFile);
            imageFile = NULL;
        }
        if (mediaHandle) {
            CloseHandle (mediaHandle);
            mediaHandle = NULL;
        }
        if (mediaFile) {
            FreePathString (mediaFile);
            mediaFile = NULL;
        }
    }
    if (!error) {
        *CheckSum = checkSum;
        *MediaIdx = mediaIdx;
        *ImageIdx = imageIdx;
        *ImageRemaining = imageRemaining;
    } else {
        totalImageRead = imageReadLast;
    }
    *Error = error;
    *Done = done;
}

BOOL
pReadAllImages (
    VOID
    )
{
    UINT mediaIdx = 1;
    UINT imageIdx = 1;
    ULONGLONG imageRemaining = 0;
    RMEDIA_ERR error = RMEDIA_ERR_NOERROR;
    BOOL done = FALSE;
    BOOL result = TRUE;
    INT_PTR appReply;
    DWORD checkSum = 0;
    RMEDIA_EXTRADATA extraData;

    while (!done) {

        // send the proper message to the app

        if (error == RMEDIA_ERR_OLDMEDIA) {
            PushError ();
            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_OLD_STORAGE, 0);
            PopError ();
        } else {
            extraData.LastError = error;
            extraData.MediaNumber = mediaIdx;
            extraData.TotalImageSize = 0;
            extraData.TotalImageWritten = 0;
            PushError ();
            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_RMEDIA_LOAD, (ULONG_PTR)&extraData);
            PopError ();
        }

        if (!appReply) {
            //
            // user cancelled
            //
            done = TRUE;
            result = FALSE;
            continue;
        }
        pReadImageFromMedia (&checkSum, &mediaIdx, &imageIdx, &imageRemaining, &error, &done);
        if (done) {
            result = !error;
        }
    }
    return result;
}

PCTSTR
pRmvMedGetNewFileName (
    IN      PCTSTR FileName
    )
{
    PCTSTR newFileName = NULL;
    PTSTR tempPtr1 = NULL;
    PCTSTR endStr1 = NULL;
    PCTSTR tempPtr2 = NULL;
    PCTSTR endStr2 = NULL;
    INT i;

    // let's modify the file to extract. The file name will
    // be split in 2 after the first 5 characters
    newFileName = DuplicatePathString (FileName, 1);
    if (!newFileName) {
        return NULL;
    }
    tempPtr1 = (PTSTR) GetFileNameFromPath (newFileName);
    if (!tempPtr1) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr1 = GetEndOfString (newFileName);
    if (!endStr1) {
        FreePathString (newFileName);
        return NULL;
    }
    tempPtr2 = GetFileNameFromPath (FileName);
    if (!tempPtr2) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr2 = GetEndOfString (FileName);
    if (!endStr2) {
        FreePathString (newFileName);
        return NULL;
    }
    for (i = 0; i < 5; i ++) {
        tempPtr1 = _tcsinc (tempPtr1);
        tempPtr2 = _tcsinc (tempPtr2);
    }

    if ((tempPtr1 < endStr1) &&
        (tempPtr2 < endStr2)
        ) {
        StringCopy (tempPtr1, TEXT("\\"));
        tempPtr1 = _tcsinc (tempPtr1);
        StringCopy (tempPtr1, tempPtr2);
    } else {
        FreePathString (newFileName);
        newFileName = NULL;
    }
    return newFileName;
}

BOOL
pRmvMedCallback (
    IN      PCTSTR FileToExtract,
    IN      LONGLONG FileSize,
    OUT     PBOOL ExtractFile,
    IN OUT  PCTSTR *NewFileName
    )
{
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;

    if (NewFileName) {
        *NewFileName = pRmvMedGetNewFileName (FileToExtract);
    }

    g_FilesRead ++;
    // now update the progress bar
    numerator = (LONGLONG) g_FilesRead * (LONGLONG) g_UncompressTicks;
    divisor = (LONGLONG) g_TotalFiles;
    if (divisor) {
        tick = numerator / divisor;
    } else {
        tick = 0;
    }
    delta = (UINT) tick - g_UncompressTicked;
    if (delta) {
        IsmTickProgressBar (g_UncompressSlice, delta);
        g_UncompressTicked += delta;
    }

    if (ExtractFile) {
        *ExtractFile = TRUE;
    }

    return (!IsmCheckCancel());
}

BOOL
pUnpackAllFiles (
    VOID
    )
{
    COMPRESS_HANDLE compressedHandle;
    BOOL result = FALSE;

    if (CompressOpenHandle (g_RmvMedTempPath, S_TRANSPORT_IMG_FILE, 1, &compressedHandle)) {
        g_TotalFiles = compressedHandle.FilesStored;
        if (CompressExtractAllFiles (g_RmvMedTempPath, &compressedHandle, pRmvMedCallback)) {
            result = TRUE;
        }
        CompressCleanupHandle (&compressedHandle);
    }

    return result;
}

BOOL
WINAPI
RmvMedTransportBeginApply (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    PCTSTR imageFile = NULL;
    PCTSTR newImageFile = NULL;
    BOOL result = FALSE;

    g_RmvMedPlatform = PLATFORM_DESTINATION;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    __try {

        g_RmvMedTempPath = pCreateTemporaryDir ();

        if (!g_RmvMedTempPath) {
            extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
            __leave;
        }

        if (!pReadAllImages ()) {
            if (GetLastError () == ERROR_DISK_FULL) {
                extraData.Error = ERRUSER_ERROR_DISKSPACE;
            } else {
                extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
            }
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_UNCOMPRESSING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!pUnpackAllFiles ()) {
            extraData.Error = ERRUSER_ERROR_CANTUNPACKIMAGE;
            __leave;
        }

        newImageFile = pRmvMedGetNewFileName (S_TRANSPORT_DAT_FILE);

        imageFile = JoinPaths (g_RmvMedTempPath, newImageFile?newImageFile:S_TRANSPORT_DAT_FILE);

        if (newImageFile) {
            FreePathString (newImageFile);
            newImageFile = NULL;
        }

        if (!MemDbLoad (imageFile)) {
            extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (imageFile) {
            FreePathString (imageFile);
            imageFile = NULL;
        }
    }

    if (!result) {
        extraData.ErrorArea = ERRUSER_AREA_LOAD;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
    }

    return result;
}

VOID
WINAPI
RmvMedTransportEndApply (
    VOID
    )
{
    MYASSERT (g_RmvMedPlatform == PLATFORM_DESTINATION);

    pCleanupTempDir ();
}

BOOL
WINAPI
RmvMedTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    PCTSTR newFileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_RmvMedPlatform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                newFileValue = pRmvMedGetNewFileName (fileValue);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = JoinPaths (g_RmvMedTempPath, newFileValue?newFileValue:fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = JoinPaths (g_RmvMedTempPath, newFileValue?newFileValue:fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreePathString (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                if (newFileValue) {
                    FreePathString (newFileValue);
                    newFileValue = NULL;
                }
                if (fileValue) {
                    MemDbReleaseMemory (fileValue);
                    fileValue = NULL;
                }
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
RmvMedTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_RmvMedPlatform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\sources.inc ===
!include ..\..\modules.mk

MINORCOMP=guitrans

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\entry.c          \
    ..\guitrans.rc      \
    ..\removemed.c      \
    ..\netcommon.c      \
    ..\netsource.c      \
    ..\netdest.c        \
    ..\sockets.c        \
    ..\opaque.c         \
    ..\direct.c         \
    ..\logmsg.mc        \


DLLENTRY=_DllMainCRTStartup
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\modimage.lib     \
            $(COBRA_ROOT)\lib\$(O)\compress.lib     \
            $(COBRA_ROOT)\lib\$(O)\cablib.lib       \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \
            $(COBRA_ROOT)\lib\$(O)\reg.lib          \
            $(SDK_LIB_PATH)\cabinet.lib \
            $(SDK_LIB_PATH)\wsock32.lib \

PRECOMPILED_INCLUDE=pch.h

DLLDEF=..\guitrans.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\unicode\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\ansi\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\sockets.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockets.c

Abstract:

    Implements the network interface for the home net transport.

Author:

    Jim Schmidt (jimschm) 01-Jul-2000

Revision History:

    <full name> (<alias>) <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include <winsock2.h>
#include <wsipx.h>
#include <wsnwlink.h>
#include <wsnetbs.h>
#include <nb30.h>
#include <ws2tcpip.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmwksta.h>
#include "homenetp.h"

#define DBG_HOMENET                 "HomeNet"

//
// Strings
//

#define S_64CHARTAG     TEXT("usmt-v2@01234567890123456789012345678901234567890123456789012345")

//
// Constants
//

#define IDLE_TIMEOUT                45

#define TCPIP_BROADCAST_PORT        2048
#define IPX_BROADCAST_PORT          1150
#define NETBIOS_BROADCAST_PORT      0x50

#define TCPIP_CONNECT_PORT          2049
#define IPX_CONNECT_PORT            1151
#define NETBIOS_CONNECT_PORT        0x51

#define NAME_SIZE                       64
#define NAME_SIZE_PLUS_NUL              65
#define NAME_SIZE_PLUS_COMMA            65
#define NAME_SIZE_PLUS_COMMA_PLUS_NUL   66
#define MIN_MESSAGE_SIZE                (NAME_SIZE_PLUS_COMMA_PLUS_NUL + 2)

#define MAX_DATA_PACKET_SIZE        65536

//
// Macros
//

// none

//
// Types
//

typedef INT (WSAIOCTL)(
                SOCKET s,
                DWORD IoControlCode,
                PVOID InBuffer,
                DWORD InBufferSize,
                PVOID OutBuffer,
                DWORD OutBufferSize,
                PDWORD BytesReturned,
                WSAOVERLAPPED *Overlapped,
                LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
                );
typedef WSAIOCTL *PWSAIOCTL;

typedef struct {
    SOCKET Socket;
    BYTE BroadcastAddress[MAX_SOCKADDR];
    INT AddressLen;
    INT Family;
    INT Protocol;
} BROADCASTSOCKET, *PBROADCASTSOCKET;

typedef struct {
    SOCKET Socket;
    INT Family;
    INT Protocol;
    BOOL Datagram;
} LISTENSOCKET, *PLISTENSOCKET;

typedef struct {
    PBROADCASTSOCKET BroadcastSockets;
    INT BroadcastCount;
    PLISTENSOCKET ListenSockets;
    INT ListenCount;
    CONNECTIONSOCKET ConnectionSocket;
    PGROWBUFFER AddressArray;
    UINT Timeout;
} BROADCASTARGS, *PBROADCASTARGS;

typedef NET_API_STATUS(WINAPI NETWKSTAGETINFO)(PWSTR, DWORD, PBYTE *);
typedef NETWKSTAGETINFO *PNETWKSTAGETINFO;

typedef NET_API_STATUS(WINAPI NETAPIBUFFERFREE)(PVOID);
typedef NETAPIBUFFERFREE *PNETAPIBUFFERFREE;

//
// Globals
//

HANDLE g_StopHandle;
HANDLE g_ConnectionDone;
CHAR g_GlobalKey [GLOBALKEY_SIZE + 1];

//
// Macro expansion list
//

// none

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// none

//
// Code
//

PBROADCASTSOCKET
pOpenOneBroadcastSocket (
    IN OUT  PGROWBUFFER BroadcastSockets,
    IN      SOCKADDR *SockAddr,
    IN      INT SockAddrLen,
    IN      INT Family,
    IN      INT Protocol,
    IN      PCTSTR DebugText
    )

/*++

Routine Description:

  pOpenOneBroadcastSocket opens a socket for the specified
  family/protocol/address combination, sets the socket into SO_REUSEADDR and
  SO_BROADCAST mode, and puts the socket information in the array stored in
  the caller's grow buffer.

  The socket opened will be used for broadcast send or receive.

Arguments:

  BroadcastSockets - Specifies the grow buffer that holds the array of
                     BROADCASTSOCKET elements. Receives an additional entry
                     on success.
  SockAddr         - Specifies the protocol-specific socket address structure
                     (cast to SOCKADDR), giving the broadcast address.
  SockAddrLen      - Specifies the length of SockAddr, in bytes
  Family           - Specifies the protocol family (AF_IPX, AF_INET)
  Protocol         - Specifies the protocol (IPPROTO_UDP, NSPROTO_IPX, -lana)
  DebugText        - Specifies the protocol in text form for debug messages

Return Value:

  A pointer to the new BROADCASTSOCKET element allocated from BroadcastSockets,
  or NULL if the socket could not be opened.

  NOTE: BroadcastSockets->Buf will potentially change on success.  Do not rely
        on this address.

--*/

{
    PBROADCASTSOCKET broadcastSocket;
    BOOL b;

    broadcastSocket = (PBROADCASTSOCKET) GbGrow (BroadcastSockets, sizeof (BROADCASTSOCKET));
    broadcastSocket->Socket = socket (Family, SOCK_DGRAM, Protocol);

    if (broadcastSocket->Socket != INVALID_SOCKET) {

        b = TRUE;
        setsockopt (broadcastSocket->Socket, SOL_SOCKET, SO_BROADCAST, (PBYTE) &b, sizeof (b));
        setsockopt (broadcastSocket->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        if (bind (broadcastSocket->Socket, SockAddr, SockAddrLen)) {
            DEBUGMSG ((DBG_ERROR, "Can't bind to %s socket", DebugText));
            closesocket (broadcastSocket->Socket);
            broadcastSocket->Socket = INVALID_SOCKET;
        }
    }

    if (broadcastSocket->Socket == INVALID_SOCKET) {
        BroadcastSockets->End -= sizeof (BROADCASTSOCKET);
        broadcastSocket = NULL;
    } else {
        DEBUGMSG ((
            DBG_HOMENET,
            "%s is available for broadcast on socket %u",
            DebugText,
            (BroadcastSockets->End / sizeof (BROADCASTSOCKET)) - 1
            ));

        broadcastSocket->AddressLen = SockAddrLen;
        MYASSERT (SockAddrLen <= MAX_SOCKADDR);
        CopyMemory (broadcastSocket->BroadcastAddress, (PBYTE) SockAddr, SockAddrLen);
        broadcastSocket->Family = Family;
        broadcastSocket->Protocol = Protocol;
    }

    return broadcastSocket;
}


INT
pOpenBroadcastSockets (
    OUT     PGROWBUFFER BroadcastSockets
    )

/*++

Routine Description:

  pOpenBroadcastSockets opens a broadcast socket on each supported protocol.

Arguments:

  BroadcastSockets - Receives an array of BROADCASTSOCKET elements (one for
                     each protocol).  IMPORTANT: This parameter must be
                     zero-initialized by the caller.

Return Value:

  The number of elements in BroadcastSockets, or zero on failure.

--*/

{
    SOCKADDR_IPX ipxAddr;
    SOCKADDR_IN tcpipAddr;
    PBROADCASTSOCKET broadcastSocket;

    MYASSERT (!BroadcastSockets->Buf && !BroadcastSockets->End);

    //
    // Open sockets for broadcasts
    //

    // IPX
    ZeroMemory (&ipxAddr, sizeof (ipxAddr));
    ipxAddr.sa_family = AF_IPX;
    ipxAddr.sa_socket = IPX_BROADCAST_PORT;

    broadcastSocket = pOpenOneBroadcastSocket (
                            BroadcastSockets,
                            (SOCKADDR *) &ipxAddr,
                            sizeof (ipxAddr),
                            AF_IPX,
                            NSPROTO_IPX,
                            TEXT("IPX")
                            );
    if (broadcastSocket) {
        memset (ipxAddr.sa_nodenum, 0xFF, 6);
        CopyMemory (broadcastSocket->BroadcastAddress, &ipxAddr, sizeof (ipxAddr));
    }

    // TCP/IP
    ZeroMemory (&tcpipAddr, sizeof (tcpipAddr));
    tcpipAddr.sin_family = AF_INET;
    tcpipAddr.sin_addr.s_addr = htonl (INADDR_ANY);
    tcpipAddr.sin_port = TCPIP_BROADCAST_PORT;

    broadcastSocket = pOpenOneBroadcastSocket (
                            BroadcastSockets,
                            (SOCKADDR *) &tcpipAddr,
                            sizeof (tcpipAddr),
                            AF_INET,
                            IPPROTO_UDP,
                            TEXT("UDP")
                            );

    if (broadcastSocket) {
        tcpipAddr.sin_addr.s_addr = htonl (INADDR_BROADCAST);
        CopyMemory (broadcastSocket->BroadcastAddress, &tcpipAddr, sizeof (tcpipAddr));
    }

    return BroadcastSockets->End / sizeof (BROADCASTSOCKET);
}


PLISTENSOCKET
pOpenOneListenSocket (
    IN OUT  PGROWBUFFER ListenSockets,
    IN      SOCKADDR *SockAddr,
    IN      INT SockAddrLen,
    IN      INT Family,
    IN      BOOL Multicast,
    IN      INT Protocol,
    IN      PCTSTR DebugText
    )

/*++

Routine Description:

  pOpenOneListenSocket opens a socket for the specified
  family/protocol/address combination, sets the socket into SO_REUSEADDR mode,
  and puts the socket information in the array stored in the caller's grow
  buffer.  If Multicast is specified, then SO_BROADCAST is also set.
  Otherwise, the socket is set to listen for one connection.

  The socket opened will be used to accept connections.

Arguments:

  ListenSockets - Specifies the grow buffer that holds the array of
                  LISTENSOCKET elements. Receives an additional entry on
                  success.
  SockAddr      - Specifies the protocol-specific socket address structure
                  (cast to SOCKADDR), giving the local address for binding.
  SockAddrLen   - Specifies the length of SockAddr, in bytes
  Family        - Specifies the protocol family (AF_IPX, AF_INET)
  Multicast     - Specifies TRUE if the protocol family does not support
                  streaming sockets, but instead uses datagrams for all data
                  transfer. (NetBIOS for example is a multicast protocol.)

                  NOTE: UNSUPPORTED because NetBIOS is not implemented anymore

  Protocol      - Specifies the protocol (IPPROTO_UDP, NSPROTO_IPX, -lana)
  DebugText     - Specifies the protocol in text form for debug messages

Return Value:

  A pointer to the new LISTENSOCKET element allocated from ListenSockets, or
  NULL if the socket could not be opened.

  NOTE: ListenSockets->Buf will potentially change on success.  Do not rely on
        this address.

--*/

{
    PLISTENSOCKET listenSocket;
    BOOL b;

    listenSocket = (PLISTENSOCKET) GbGrow (ListenSockets, sizeof (LISTENSOCKET));
    listenSocket->Socket = socket (Family, Multicast ? SOCK_DGRAM : SOCK_STREAM, Protocol);
    listenSocket->Datagram = Multicast;
    listenSocket->Family = Family;
    listenSocket->Protocol = Protocol;

    if (listenSocket->Socket != INVALID_SOCKET) {

        b = TRUE;
        setsockopt (listenSocket->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        if (Multicast) {
            setsockopt (listenSocket->Socket, SOL_SOCKET, SO_BROADCAST, (PBYTE) &b, sizeof (b));
        }

        if (bind (listenSocket->Socket, SockAddr, SockAddrLen) ||
            (!Multicast && listen (listenSocket->Socket, 1))
            ) {
            DEBUGMSG ((DBG_ERROR, "Can't bind/listen to %s socket", DebugText));
            closesocket (listenSocket->Socket);
            listenSocket->Socket = INVALID_SOCKET;
        }
    }

    if (listenSocket->Socket == INVALID_SOCKET) {
        ListenSockets->End -= sizeof (LISTENSOCKET);
        listenSocket = NULL;
    } else {
        DEBUGMSG ((
            DBG_HOMENET,
            "%s is availble for connection on socket %u",
            DebugText,
            (ListenSockets->End / sizeof (LISTENSOCKET)) - 1
            ));
    }

    return listenSocket;
}


INT
pOpenListenSockets (
    OUT     PGROWBUFFER ListenSockets
    )

/*++

Routine Description:

  pOpenListenSockets opens a connection socket on each supported protocol.

Arguments:

  ListenSockets - Receives an array of LISTENSOCKET elements (one for each
                  protocol).  IMPORTANT: This parameter must be
                  zero-initialized by the caller.

Return Value:

  The number of elements in ListenSockets, or zero on failure.

--*/

{
    SOCKADDR_IPX ipxAddr;
    SOCKADDR_IN tcpipAddr;

    MYASSERT (!ListenSockets->Buf && !ListenSockets->End);

    //
    // Open sockets to accept inbound connections
    //

    // SPX
    ZeroMemory (&ipxAddr, sizeof (ipxAddr));
    ipxAddr.sa_family = AF_IPX;
    ipxAddr.sa_socket = IPX_CONNECT_PORT;

    pOpenOneListenSocket (
        ListenSockets,
        (SOCKADDR *) &ipxAddr,
        sizeof (ipxAddr),
        AF_IPX,
        FALSE,
        NSPROTO_SPX,
        TEXT("SPX")
        );

    // TCP/IP
    ZeroMemory (&tcpipAddr, sizeof (tcpipAddr));
    tcpipAddr.sin_family = AF_INET;
    tcpipAddr.sin_port = TCPIP_CONNECT_PORT;

    pOpenOneListenSocket (
        ListenSockets,
        (SOCKADDR *) &tcpipAddr,
        sizeof (tcpipAddr),
        AF_INET,
        FALSE,
        IPPROTO_TCP,
        TEXT("TCP")
        );

    return ListenSockets->End / sizeof (LISTENSOCKET);
}


PCTSTR
pGetNameFromMessage (
    IN      PCWSTR Message
    )

/*++

Routine Description:

  pGetNameFromMessage extracts the computer name from a broadcast.

Arguments:

  Message - Specifies the encoded message.

Return Value:

  The computer name encoded in the message, or NULL if the message is garbage.

--*/

{
    PCTSTR message = NULL;
    PCTSTR orgMessage = NULL;
    TCHAR sigStr [sizeof (TEXT("0xFFFFFFFF"))];
    DWORD signature = 0;
    PCTSTR p;
    PCTSTR name = NULL;
    INT len;
    CHARTYPE ch;
    PCTSTR tag = S_64CHARTAG;       // must be 64 chars
    TCHAR alternateTag[NAME_SIZE_PLUS_NUL];
    TCHAR prefix[NAME_SIZE_PLUS_COMMA_PLUS_NUL];
    PTSTR q, r;

#ifdef UNICODE
    orgMessage = Message;
#else
    orgMessage = ConvertWtoA (Message);
#endif

    if (!orgMessage) {
        return name;
    }

    message = orgMessage;

    __try {

        p = _tcschr (message, TEXT(','));
        if (!p) {
            DEBUGMSG ((DBG_HOMENET, "Invalid Signature"));
            __leave;
        }

        ZeroMemory (sigStr, sizeof (sigStr));
        CopyMemory (sigStr, message, min (sizeof (sigStr) - 1, ((UINT)(p - message)) * sizeof (TCHAR)));
        _stscanf (sigStr, TEXT("0x%08X"), &signature);
        if (signature != HOMENETTR_SIG) {
            DEBUGMSG ((DBG_HOMENET, "Signature does not match"));
            __leave;
        }

        message = _tcsinc (p);
        if (!message) {
            DEBUGMSG ((DBG_HOMENET, "Invalid Signature"));
            __leave;
        }

        if (IsmCopyEnvironmentString (PLATFORM_SOURCE, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, alternateTag)) {

            q = GetEndOfString (alternateTag);
            r = alternateTag + NAME_SIZE;

            while (q < r) {
                *q++ = TEXT('@');
            }

            *r = 0;

            tag = alternateTag;
        }

        DEBUGMSG ((DBG_HOMENET, "Comparing our tag %s against message %s", tag, message));

        StringCopy (prefix, tag);
        StringCat (prefix, TEXT(","));

        if (StringIPrefix (message, prefix)) {

            p = message + NAME_SIZE_PLUS_COMMA;
            len = 0;

            while (*p) {

                ch = (CHARTYPE) _tcsnextc (p);
                p = _tcsinc (p);

                if (ch == TEXT(',')) {
                    break;
                }

                if (ch < TEXT('0') || ch > TEXT('9')) {
                    break;
                }

                len = len * 10 + (ch - TEXT('0'));
            }

            if (ch == TEXT(',') && len < MAX_COMPUTER_NAME) {

                name = p;

                while (*p && len) {
                    if (*p < 32) {
                        break;
                    }

                    p++;
                    len--;
                }

                if (len || *p) {
                    name = NULL;
                }
            }
        }
        ELSE_DEBUGMSG ((DBG_HOMENET, "TAG does not match"));
    }
    __finally {
#ifndef UNICODE
        if (orgMessage) {
            FreeConvertedStr (orgMessage);
            orgMessage = NULL;
        }
#endif
    }

    return name;
}


VOID
pTranslateBroadcastAddrToConnectAddr (
    IN      INT Family,
    IN OUT  PINT Protocol,
    IN OUT  PBOOL Datagram,
    IN OUT  SOCKADDR *SockAddr
    )

/*++

Routine Description:

  pTranslateBroadcastAddrToConnectAddr transforms a broadcast address into a
  connection address.  The broadcast address is typically obtained from a
  datagram response, and must be transformed before accepting a sequenced
  connection.

Arguments:

  Family   - Specifies the protocol family
  Protocol - Specifies the datagram protocol; receives the sequenced packet
             protocol if available
  Datagram - Specifies a pointer to FALSE, receives TRUE if the protocol does
             not support sequenced connections.
  SockAddr - Specifies the peer socket address. Receives the updated address
             (a different port is used for connections).

Return Value:

  None.

--*/

{
    SOCKADDR_IPX *ipxAddr;
    SOCKADDR_IN *tcpipAddr;

    switch (Family) {

    case AF_INET:
        *Protocol = IPPROTO_TCP;
        tcpipAddr = (SOCKADDR_IN *) SockAddr;
        tcpipAddr->sin_port = TCPIP_CONNECT_PORT;
        break;

    case AF_IPX:
        *Protocol = NSPROTO_SPX;
        ipxAddr = (SOCKADDR_IPX *) SockAddr;
        ipxAddr->sa_socket = IPX_CONNECT_PORT;
        break;

    }
}


VOID
pResetPort (
    IN      INT Family,
    IN OUT  SOCKADDR *SockAddr
    )

/*++

Routine Description:

  pResetPort sets the port to zero for TCP/IP, so that the system will pick
  an unused port for the local address.  This is used when connecting.

Arguments:

  Family   - Specifies the protocol family (such as AF_INET)
  SockAddr - Specifies the address to reset

Return Value:

  None.

--*/

{
    SOCKADDR_IN *tcpipAddr;

    switch (Family) {

    case AF_INET:
        tcpipAddr = (SOCKADDR_IN *) SockAddr;
        tcpipAddr->sin_port = 0;
        break;
    }
}


INT
pSourceBroadcast (
    IN OUT  PBROADCASTARGS Args
    )

/*++

Routine Description:

  pSourceBroadcast implements the name resolution mechanism for the source
  end of the connection. This involves checking for cancel, collecting
  inbound datagrams from all transports, and parsing the datagrams to obtain
  the server name.

Arguments:

  Args - Specifies a structure containing all of the parameters, such as
         the socket array and socket addresses.

Return Value:

  The number of server addresses collected, or 0 if the collection was
  cancelled.

--*/

{
    INT i;
    INT bytesIn;
    DWORD rc;
    WCHAR message[256];
    FD_SET set;
    TIMEVAL zero = {0,0};
    INT waitCycle = -1;
    BOOL result = FALSE;
    PCTSTR name;
    PCONNECTADDRESS address;
    PCONNECTADDRESS end;
    PBROADCASTSOCKET broadcastSocket;
    BYTE remoteAddr[MAX_SOCKADDR];
    INT remoteAddrLen;
    DWORD startTick = GetTickCount();

    for (;;) {
        //
        // Check cancel
        //

        if (g_StopHandle) {
            rc = WaitForSingleObject (g_StopHandle, 0);
        } else {
            rc = WAIT_FAILED;
        }

        if (rc == WAIT_OBJECT_0 || IsmCheckCancel()) {
            result = FALSE;
            break;
        }

        //
        // Check time to live
        //

        if (Args->Timeout) {
            if (((GetTickCount() - startTick) / 1000) >= Args->Timeout) {
                DEBUGMSG ((DBG_HOMENET, "Name search timed out"));
                break;
            }
        }

        if (waitCycle > -1) {
            waitCycle--;

            if (!waitCycle) {
                break;
            }
        }

        //
        // Check for a message
        //

        FD_ZERO (&set);
        for (i = 0 ; i < Args->BroadcastCount ; i++) {
            FD_SET (Args->BroadcastSockets[i].Socket, &set);
        }

        i = select (0, &set, NULL, NULL, &zero);

        if (i > 0) {

            for (i = 0 ; i < Args->BroadcastCount ; i++) {

                broadcastSocket = &Args->BroadcastSockets[i];

                if (FD_ISSET (broadcastSocket->Socket, &set)) {

                    remoteAddrLen = MAX_SOCKADDR;

                    bytesIn = recvfrom (
                                    broadcastSocket->Socket,
                                    (PSTR) message,
                                    254 * sizeof (WCHAR),
                                    0,
                                    (SOCKADDR *) remoteAddr,
                                    &remoteAddrLen
                                    );

                    if (bytesIn >= (MIN_MESSAGE_SIZE * sizeof (WCHAR))) {
                        message[bytesIn] = 0;
                        message[bytesIn + 1] = 0;

                        //
                        // Parse the inbound text.  It must be in the format of
                        //
                        //      <signature>,<tag>,<tchars>,<name>
                        //
                        // <tag> must be 64 characters, and is usmt-v2 by default
                        // (followed by fill numbers).
                        //

                        name = pGetNameFromMessage (message);

                        if (name) {

                            // once we receive something, wait 5 additional seconds for other inbound datagrams
                            if (waitCycle == -1) {
                                waitCycle = 20;
                            }

                            result = TRUE;

                            //
                            // Scan the address list for the name
                            //

                            address = (PCONNECTADDRESS) Args->AddressArray->Buf;
                            end = (PCONNECTADDRESS) (Args->AddressArray->Buf + Args->AddressArray->End);

                            while (address < end) {
                                if (StringIMatch (address->DestinationName, name)) {
                                    if (address->Family == broadcastSocket->Family) {
                                        break;
                                    }
                                }

                                address++;
                            }

                            if (address >= end) {
                                //
                                // New computer name; add to the address list
                                //

                                address = (PCONNECTADDRESS) GbGrow (Args->AddressArray, sizeof (CONNECTADDRESS));

                                address->RemoteAddressLen = remoteAddrLen;
                                CopyMemory (address->RemoteAddress, remoteAddr, remoteAddrLen);

                                address->LocalAddressLen = MAX_SOCKADDR;
                                if (getsockname (
                                        broadcastSocket->Socket,
                                        (SOCKADDR *) address->LocalAddress,
                                        &address->LocalAddressLen
                                        )) {
                                    address->LocalAddressLen = broadcastSocket->AddressLen;
                                    ZeroMemory (address->LocalAddress, broadcastSocket->AddressLen);
                                    DEBUGMSG ((DBG_HOMENET, "Failed to get local socket name; using nul name instead"));
                                }

                                address->Family = broadcastSocket->Family;
                                address->Protocol = broadcastSocket->Protocol;
                                address->Datagram = FALSE;

                                pTranslateBroadcastAddrToConnectAddr (
                                    address->Family,
                                    &address->Protocol,
                                    &address->Datagram,
                                    (SOCKADDR *) &address->RemoteAddress
                                    );

                                StringCopy (address->DestinationName, name);

                                DEBUGMSG ((DBG_HOMENET, "Destination found: %s (protocol %i)", name, address->Family));
                            }
                        }
                        ELSE_DEBUGMSGW ((DBG_HOMENET, "garbage found: %s", message));
                    }
                }
            }
        }

        Sleep (250);
    }

    return result ? Args->AddressArray->End / sizeof (CONNECTADDRESS) : 0;
}


BOOL
pIsAddrFromLocalSubnet (
    IN      SOCKET Socket,
    IN      INT Family,
    IN      SOCKADDR *Address,
    IN      INT AddressLength
    )
{
    SOCKADDR_IPX *ipxAddr;
    SOCKADDR_IN *tcpipAddr;
    BOOL result = TRUE;
    IPX_ADDRESS_DATA ipxLocalAddr;
    INT size;
    PWSAIOCTL wsaIoctlFn;
    HANDLE lib;
    INT rc;
    INTERFACE_INFO info[32];
    DWORD bytesRead;
    INT i;
    INT j;
    SOCKADDR_IN localAddr;
    PBYTE localNetPtr;
    PBYTE remoteNetPtr;
    PBYTE subnetMaskPtr;
    INT k;

    switch (Family) {

    case AF_INET:
        tcpipAddr = (SOCKADDR_IN *) Address;

        i = sizeof (localAddr);
        if (getsockname (Socket, (SOCKADDR *) &localAddr, &i)) {
            DEBUGMSG ((DBG_ERROR, "Can't get local socket addr"));
            break;
        }

        lib = LoadLibrary (TEXT("ws2_32.dll"));
        if (lib) {

            wsaIoctlFn = (PWSAIOCTL) GetProcAddress (lib, "WSAIoctl");

            if (wsaIoctlFn) {
                rc = wsaIoctlFn (
                        Socket,
                        SIO_GET_INTERFACE_LIST,
                        NULL,
                        0,
                        info,
                        sizeof (info),
                        &bytesRead,
                        NULL,
                        NULL
                        );

                if (rc != SOCKET_ERROR) {

                    j = (INT) (bytesRead / sizeof (INTERFACE_INFO));

                    for (i = 0 ; i < j ; i++) {

                        if (!memcmp (
                                &localAddr.sin_addr,
                                &info[i].iiAddress.AddressIn.sin_addr,
                                sizeof (struct in_addr)
                                )) {

                            localNetPtr = (PBYTE) &localAddr.sin_addr;
                            remoteNetPtr = (PBYTE) &info[i].iiAddress.AddressIn.sin_addr;
                            subnetMaskPtr = (PBYTE) &info[i].iiNetmask.AddressIn.sin_addr;

                            for (k = 0 ; k < sizeof (struct in_addr) ; k++) {
                                localNetPtr[k] &= subnetMaskPtr[k];
                                remoteNetPtr[k] &= subnetMaskPtr[k];

                                if (localNetPtr[k] != remoteNetPtr[k]) {
                                    break;
                                }
                            }

                            if (k < sizeof (struct in_addr)) {
                                LOG ((LOG_WARNING, (PCSTR) MSG_REFUSE_OUTSIDE_CONNECTION));
                            } else {
                                DEBUGMSG ((DBG_HOMENET, "Found interface on the same subnet!"));
                            }

                            break;
                        }
                    }
                }
                ELSE_DEBUGMSG ((DBG_ERROR, "WSAIoctl failed"));
            }
            ELSE_DEBUGMSG ((DBG_WARNING, "Can't load WSAIoctl"));

            FreeLibrary (lib);
        }
        ELSE_DEBUGMSG ((DBG_WARNING, "Can't load ws2_32.dll"));

        break;

    case AF_IPX:
        ipxAddr = (SOCKADDR_IPX *) Address;

        //
        // Compare the specified address against the local address of the socket
        //

        size = sizeof (ipxLocalAddr);

        if (!getsockopt (Socket, NSPROTO_IPX, IPX_GETNETINFO, (PBYTE) &ipxLocalAddr, &size)) {
            if (memcmp (ipxAddr->sa_netnum, ipxLocalAddr.netnum, 4)) {
                if (ipxAddr->sa_netnum[0] || ipxAddr->sa_netnum[1] ||
                    ipxAddr->sa_netnum[2] || ipxAddr->sa_netnum[3]
                    ) {

                    LOG ((LOG_WARNING, (PCSTR) MSG_REFUSE_OUTSIDE_CONNECTION_IPX));
                    result = FALSE;

                }
            }
        }

        break;

    }

    return result;
}


BOOL
pDestinationBroadcast (
    IN OUT  PBROADCASTARGS Args
    )

/*++

Routine Description:

  pDestinationBroadcast implements the name resolution mechanism for the
  destination end of the connection. This involves checking for cancel, and
  sending out regular datagrams to all transports to provide the server name.

  At the same time, listen connections are monitored, and the datagram traffic
  is stopped once one connection is accepted.

Arguments:

  Args - Specifies a structure containing all of the parameters, such as the
         socket array and socket addresses. Receives the connection address.

Return Value:

  TRUE if a connection was accepted, or FALSE if cancel was detected.

--*/

{
    INT i;
    DWORD rc;
    INT socketNum = 0;
    WCHAR message[256];
    TCHAR name[128];
    UINT size;
    FD_SET set;
    TIMEVAL zero = {0,0};
    PBROADCASTSOCKET broadcastSocket;
    BOOL result = FALSE;
    PCTSTR tag = S_64CHARTAG;       // must be 64 chars
    TCHAR alternateTag[NAME_SIZE_PLUS_NUL];
    PTSTR p, q;
    LINGER linger;

    size = MAX_COMPUTER_NAME;
    GetComputerName (name, &size);

    //
    // Get the tag that is registered in the environment
    //

    if (IsmCopyEnvironmentString (PLATFORM_DESTINATION, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, alternateTag)) {

        p = GetEndOfString (alternateTag);
        q = alternateTag + NAME_SIZE;

        if (p) {
            while (p < q) {
                *p++ = TEXT('@');
            }
        }

        *q = 0;

        tag = alternateTag;
    }

    DEBUGMSG ((DBG_HOMENET, "Broadcasting using the following tag: %s", tag));

#ifdef UNICODE
    size = wsprintfW (message, L"0x%08X,%s,%u,%s", HOMENETTR_SIG, tag, TcharCount (name), name);
#else
    size = wsprintfW (message, L"0x%08X,%S,%u,%S", HOMENETTR_SIG, tag, TcharCount (name), name);
#endif
    size = (size + 1) * sizeof (WCHAR);

    for (;;) {
        //
        // Check cancel
        //

        if (g_StopHandle) {
            rc = WaitForSingleObject (g_StopHandle, 0);
        } else {
            rc = WAIT_FAILED;
        }

        if (rc == WAIT_OBJECT_0 || IsmCheckCancel()) {
            break;
        }

        if (g_BackgroundThreadTerminate) {
            rc = WaitForSingleObject (g_BackgroundThreadTerminate, 0);

            if (rc == WAIT_OBJECT_0) {
                break;
            }
        }

        //
        // Send out the message
        //

        broadcastSocket = &Args->BroadcastSockets[socketNum];

        i = sendto (
                broadcastSocket->Socket,
                (PSTR) message,
                size,
                0,
                (SOCKADDR *) broadcastSocket->BroadcastAddress,
                broadcastSocket->AddressLen
                );

        if (i == SOCKET_ERROR) {
            DEBUGMSG ((DBG_VERBOSE, "Error sending on socket %u: %u", socketNum, WSAGetLastError()));
        } else {
            Sleep (350);
            DEBUGMSG ((DBG_HOMENET, "Sent data on socket %u", socketNum));
        }

        socketNum++;
        if (socketNum >= Args->BroadcastCount) {
            socketNum = 0;
        }

        //
        // Check for an inbound connection
        //

        FD_ZERO (&set);
        for (i = 0 ; i < Args->ListenCount ; i++) {
            FD_SET (Args->ListenSockets[i].Socket, &set);
        }

        i = select (0, &set, NULL, NULL, &zero);

        if (i > 0) {
            DEBUGMSG ((DBG_HOMENET, "Connection request count = %i", i));
            for (i = 0 ; i < Args->ListenCount ; i++) {
                if (FD_ISSET (Args->ListenSockets[i].Socket, &set)) {

                    Args->ConnectionSocket.RemoteAddressLen = MAX_SOCKADDR;

                    if (!Args->ListenSockets[i].Datagram) {
                        Args->ConnectionSocket.Socket = accept (
                                                            Args->ListenSockets[i].Socket,
                                                            (SOCKADDR *) Args->ConnectionSocket.RemoteAddress,
                                                            &Args->ConnectionSocket.RemoteAddressLen
                                                            );

                        //
                        // Verify socket connection is on the subnet only
                        //

                        if (!pIsAddrFromLocalSubnet (
                                Args->ConnectionSocket.Socket,
                                Args->ListenSockets[i].Family,
                                (SOCKADDR *) Args->ConnectionSocket.RemoteAddress,
                                Args->ConnectionSocket.RemoteAddressLen
                                )) {

                            LOG ((LOG_WARNING, (PCSTR) MSG_OUTSIDE_OF_LOCAL_SUBNET));
                            closesocket (Args->ConnectionSocket.Socket);
                            Args->ConnectionSocket.Socket = INVALID_SOCKET;
                        } else {

                            linger.l_onoff = 1;
                            linger.l_linger = IDLE_TIMEOUT;

                            setsockopt (
                                Args->ConnectionSocket.Socket,
                                SOL_SOCKET,
                                SO_LINGER,
                                (PBYTE) &linger,
                                sizeof (linger)
                                );

                            DEBUGMSG ((DBG_HOMENET, "Connection requested"));
                        }

                    } else {

                        DEBUGMSG ((DBG_HOMENET, "Accepting datagram connection"));

                        if (DuplicateHandle (
                                GetCurrentProcess(),
                                (HANDLE) Args->ListenSockets[i].Socket,
                                GetCurrentProcess(),
                                (HANDLE *) &Args->ConnectionSocket.Socket,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS
                                )) {

                            getpeername (
                                Args->ConnectionSocket.Socket,
                                (SOCKADDR *) Args->ConnectionSocket.RemoteAddress,
                                &Args->ConnectionSocket.RemoteAddressLen
                                );
                        } else {
                            DEBUGMSG ((DBG_ERROR, "Can't duplicate socket handle"));
                            Args->ConnectionSocket.Socket = INVALID_SOCKET;
                        }
                    }

                    if (Args->ConnectionSocket.Socket != INVALID_SOCKET) {

                        Args->ConnectionSocket.Family = Args->ListenSockets[i].Family;
                        Args->ConnectionSocket.Protocol = Args->ListenSockets[i].Protocol;

                        Args->ConnectionSocket.Datagram = Args->ListenSockets[i].Datagram;
                        ZeroMemory (&Args->ConnectionSocket.DatagramPool, sizeof (DATAGRAM_POOL));
                        if (Args->ConnectionSocket.Datagram) {
                            Args->ConnectionSocket.DatagramPool.Pool = PmCreatePool();
                            Args->ConnectionSocket.DatagramPool.LastPacketNumber = (UINT) -1;
                        }

                        Args->ConnectionSocket.LocalAddressLen = MAX_SOCKADDR;
                        if (getsockname (
                                Args->ConnectionSocket.Socket,
                                (SOCKADDR *) Args->ConnectionSocket.LocalAddress,
                                &Args->ConnectionSocket.LocalAddressLen
                                )) {
                            Args->ConnectionSocket.LocalAddressLen = broadcastSocket->AddressLen;
                            ZeroMemory (Args->ConnectionSocket.LocalAddress, broadcastSocket->AddressLen);
                            DEBUGMSG ((DBG_HOMENET, "Failed to get local socket name; using nul name instead"));
                        }

                        DEBUGMSG ((DBG_HOMENET, "Connection accepted"));

                        result = TRUE;
                        break;
                    } else {
                        DEBUGMSG ((DBG_ERROR, "select indicated connection, but accept failed"));
                    }
                }
            }

            if (result) {
                break;
            }
        }
    }

    return result;
}


BOOL
pGetDomainUserName (
    OUT     PTSTR UserNameBuf       // 65 char buffer
    )
{
    HKEY domainLogonKey;
    PDWORD data;
    BOOL result = TRUE;
    DWORD size;
    NET_API_STATUS rc;
    PWKSTA_INFO_102 buffer;
    HANDLE netApi32Lib;
    PNETWKSTAGETINFO netWkstaGetInfo;
    PNETAPIBUFFERFREE netApiBufferFree;
    BYTE sid[256];
    DWORD sidSize;
    WCHAR domain[256];
    DWORD domainSize;
    SID_NAME_USE use;

    if (!ISNT()) {
        //
        // Require the Log On To Domain setting to be checked
        //

        SetLastError (ERROR_SUCCESS);

        domainLogonKey = OpenRegKeyStr (TEXT("HKLM\\Network\\Logon"));
        if (!domainLogonKey) {
            DEBUGMSG ((DBG_HOMENET, "No HKLM\\Network\\Logon key"));
            return FALSE;
        }

        data = (PDWORD) GetRegValueBinary (domainLogonKey, TEXT("LMLogon"));
        if (!data) {
            DEBUGMSG ((DBG_HOMENET, "No LMLogon value"));
            result = FALSE;
        } else {

            if (!(*data)) {
                DEBUGMSG ((DBG_HOMENET, "Domain logon is not enabled"));
                result = FALSE;
            }

            FreeAlloc (data);
        }

        CloseRegKey (domainLogonKey);

    } else {
        //
        // Require domain membership
        //

        netApi32Lib = LoadLibrary (TEXT("netapi32.dll"));
        if (netApi32Lib) {
            netWkstaGetInfo = (PNETWKSTAGETINFO) GetProcAddress (netApi32Lib, "NetWkstaGetInfo");
            netApiBufferFree = (PNETAPIBUFFERFREE) GetProcAddress (netApi32Lib, "NetApiBufferFree");
        } else {
            netWkstaGetInfo = NULL;
            netApiBufferFree = NULL;
        }

        if (!netWkstaGetInfo || !netApiBufferFree) {
            DEBUGMSG ((DBG_HOMENET, "Can't get net wksta apis"));
            result = FALSE;
        } else {

            rc = netWkstaGetInfo (NULL, 102, (PBYTE *) &buffer);

            if (rc == NO_ERROR) {
                result = buffer->wki102_langroup && (buffer->wki102_langroup[0] != 0);
                if (result) {
                    DEBUGMSGW ((DBG_HOMENET, "Getting account type of %s", buffer->wki102_langroup));

                    sidSize = ARRAYSIZE(sid);
                    domainSize = ARRAYSIZE(domain);

                    result = LookupAccountNameW (
                                    NULL,
                                    buffer->wki102_langroup,
                                    sid,
                                    &sidSize,
                                    domain,
                                    &domainSize,
                                    &use
                                    );
                    DEBUGMSG ((DBG_HOMENET, "Account type result is %u (use=%u)", result, use));
                }
                ELSE_DEBUGMSG ((DBG_HOMENET, "No langroup specified"));

                netApiBufferFree (buffer);
            } else {
                DEBUGMSG ((DBG_HOMENET, "Can't get net wksta info"));
                result = FALSE;
            }
        }

        if (netApi32Lib) {
            FreeLibrary (netApi32Lib);
        }
    }

    //
    // Make sure a user name is specified
    //

    if (result) {
        size = NAME_SIZE_PLUS_NUL;
        if (!GetUserName (UserNameBuf, &size)) {
            result = FALSE;
        } else if (*UserNameBuf == 0) {
            result = FALSE;
        }

        if (result) {
            DEBUGMSG ((DBG_HOMENET, "Domain user: %s", UserNameBuf));
        } else {
            DEBUGMSG ((DBG_HOMENET, "Not on domain"));
        }
    }

    return result;
}


INT
pNameResolver (
    IN      MIG_PLATFORMTYPEID Platform,
    OUT     PGROWBUFFER AddressBuffer,
    IN      UINT SourceTimeout,
    OUT     PCONNECTIONSOCKET ConnectionSocket
    )

/*++

Routine Description:

  pNameResolver implements the name resolution protocol. The source side
  collects datagrams, looking for a destination to choose from. The
  destination side sends out broadcasts to announce themselves, and accepts a
  connection from the source.

  At the end of name resolution, an event is signaled. This is used for
  coordination with cancel.

Arguments:

  AddressBuffer - Receives the array of addresses that is used on the
                  source side to collect a list of destinations.
                  This buffer must be zero-initialized by the caller.
                  This argument is NULL on the destination side.

  SourceTimeout - Specifies the number of seconds to wait for a broadcast,
                  or zero to wait forever. The timeout only affects the
                  source side.

  ConnectionSocket - Receives the connection socket and address information
                     that is used on the destination side.  This argument
                     is NULL on the source side.

Return Value:

  Source Side: The number of addresses in AddressBuffer, or zero if an error
               occurred

  Destination Side: 1 indicating that ConnectionSocket is valid, or zero if
                    an error occurred.

--*/

{
    BROADCASTARGS args;
    INT i;
    INT result = 0;
    BOOL b;
    BOOL connected = FALSE;
    GROWBUFFER broadcastSockets = INIT_GROWBUFFER;
    GROWBUFFER listenSockets = INIT_GROWBUFFER;
    INT broadcastSocketCount;
    INT listenSocketCount = 0;
    BOOL destinationMode;
    TCHAR envTag[NAME_SIZE_PLUS_NUL];

    __try {
        //
        // If tag is not set, then force it to the user name if domains are enabled
        //

        if (!IsmCopyEnvironmentString (Platform, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, envTag)) {
            if (pGetDomainUserName (envTag)) {
                IsmSetEnvironmentString (Platform, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, envTag);
            }
        }

        if (!AddressBuffer && ConnectionSocket) {
            destinationMode = TRUE;
        } else if (AddressBuffer && !ConnectionSocket) {
            destinationMode = FALSE;
        } else {
            MYASSERT (FALSE);
            __leave;
        }

        //
        // In source mode, we collect datagrams sent by destinations on the network.  After
        // the first datagram is received, collection continues for 15 seconds.  At
        // that point, we have a list of socket addresses, protocol, and destination names.
        //
        // In destination mode, we send out periodic broadcasts, and we wait until a source
        // connects or the cancel event is signaled.
        //

        broadcastSocketCount = pOpenBroadcastSockets (&broadcastSockets);

        if (!broadcastSocketCount) {
            __leave;
        }

        if (destinationMode) {
            listenSocketCount = pOpenListenSockets (&listenSockets);

            if (!listenSocketCount) {
                DEBUGMSG ((DBG_ERROR, "Able to set up broadcast sockets but not connection sockets"));
                __leave;
            }
        }

        // call mode-specific routine
        ZeroMemory (&args, sizeof (args));

        args.AddressArray = AddressBuffer;
        args.BroadcastSockets = (PBROADCASTSOCKET) broadcastSockets.Buf;
        args.BroadcastCount = broadcastSocketCount;
        args.ListenSockets = (PLISTENSOCKET) listenSockets.Buf;
        args.ListenCount = listenSocketCount;
        args.Timeout = SourceTimeout;

        b = destinationMode ? pDestinationBroadcast (&args) : pSourceBroadcast (&args);

        //
        // Clean up all sockets
        //

        PushError();

        for (i = 0 ; i < args.BroadcastCount ; i++) {
            closesocket (args.BroadcastSockets[i].Socket);
        }

        if (destinationMode) {
            for (i = 0 ; i < args.ListenCount ; i++) {
                closesocket (args.ListenSockets[i].Socket);
            }
        }

        PopError();

        if (b) {
            if (destinationMode) {
                CopyMemory (ConnectionSocket, &args.ConnectionSocket, sizeof (CONNECTIONSOCKET));
                result = 1;
            } else {
                result = AddressBuffer->End / sizeof (CONNECTADDRESS);
            }
        }
    }
    __finally {
        PushError();

        GbFree (&broadcastSockets);
        GbFree (&listenSockets);
        if (g_ConnectionDone) {
            SetEvent (g_ConnectionDone);
        }

        PopError();
    }

    return result;
}


INT
pSendWithTimeout (
    IN      SOCKET Socket,
    IN      PCBYTE Data,
    IN      UINT DataLen,
    IN      INT Flags
    )
{
    FD_SET writeSet;
    FD_SET errorSet;
    TIMEVAL timeout = {1,0};
    UINT timeToLive = GetTickCount() + IDLE_TIMEOUT * 1000;
    INT result;

    //
    // Wait up to IDLE_TIMEOUT seconds for the socket to be sendable
    //

    do {

        FD_ZERO (&writeSet);
        FD_SET (Socket, &writeSet);
        FD_ZERO (&errorSet);
        FD_SET (Socket, &errorSet);

        //
        // Check the ISM cancel flag
        //

        if (IsmCheckCancel ()) {
            SetLastError (ERROR_CANCELLED);
            return SOCKET_ERROR;
        }

        //
        // Wait 1 second for the socket to be writable
        //

        result = select (0, NULL, &writeSet, &errorSet, &timeout);

        if (result) {
            if (FD_ISSET (Socket, &writeSet)) {
                return send (Socket, Data, DataLen, Flags);
            }

            LOG ((LOG_ERROR, (PCSTR) MSG_SOCKET_HAS_ERROR));
            return SOCKET_ERROR;
        }

    } while ((timeToLive - GetTickCount()) < IDLE_TIMEOUT * 1000);

    LOG ((LOG_ERROR, (PCSTR) MSG_SOCKET_SEND_TIMEOUT));
    return SOCKET_ERROR;
}


BOOL
pSendExactData (
    IN      SOCKET Socket,
    IN      PCBYTE Data,
    IN      UINT DataLen
    )

/*++

Routine Description:

  pSendExactData sends data to the specified socket.

  [TODO: need to support datagram mode]

Arguments:

  Socket  - Specifies the socket to send data to
  Data    - Specifies the data to send
  DataLen - Specifies the number of bytes in Data

Return Value:

  TRUE if the data was sent, FALSE otherwise.

--*/

{
    INT result;
    PCBYTE pos;
    UINT bytesLeft;
    UINT packetSize;

    bytesLeft = DataLen;
    pos = Data;

    while (bytesLeft) {
        if (IsmCheckCancel()) {
            return FALSE;
        }

        packetSize = min (1024, bytesLeft);
        result = pSendWithTimeout (Socket, pos, packetSize, 0);

        if (result > 0) {
            bytesLeft -= (UINT) result;
            pos += result;
        } else {
            if (GetLastError() == WSAENOBUFS) {
                Sleep (100);
            } else {
                return FALSE;
            }
        }
    }

    return bytesLeft == 0;
}


BOOL
pSendDatagramData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,
    IN      PCBYTE Data,
    IN      UINT DataLen
    )

/*++

Routine Description:

  pSendDatagramData puts data on the wire in the form of small, numbered
  packets. The packets can potentially scatter and be received out of order,
  so the packets are numbered such that they can be reassembled properly.

  It is assumed that the datagram protocol is reliable (datagrams are not
  dropped), and that the underlying protocol implements the naggle algorithm
  to cache packets for efficiency.

Arguments:

  Socket       - Specifies the datagram socket to send data on
  DatagramPool - Specifies a structure that is used to track packets
  Data         - Specifies the data to send
  DataLen      - Specifies the length of the data to send

Return Value:

  TRUE if data was sent, FALSE otherwise

--*/

{
    PDATAGRAM_PACKET header;
    BYTE buffer[512];
    PBYTE dataPtr;
    UINT bytesSent = 0;
    UINT bytesToSend;

    header = (PDATAGRAM_PACKET) buffer;
    dataPtr = (PBYTE) (&header[1]);

    do {

        bytesToSend = DataLen - bytesSent;
        bytesToSend = min (bytesToSend, 256);

        header->PacketNumber = DatagramPool->SendSequenceNumber;
        DatagramPool->SendSequenceNumber++;
        header->DataLength = (WORD) bytesToSend;

        CopyMemory (dataPtr, Data, bytesToSend);

        if (!pSendExactData (
                Socket,
                (PBYTE) header,
                bytesToSend + sizeof (DATAGRAM_PACKET)
                )) {
            break;
        }

        Data += bytesToSend;
        bytesSent += bytesToSend;

    } while (bytesSent < DataLen);

    return bytesSent == DataLen;
}


BOOL
pSendData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    IN      PCBYTE Data,
    IN      UINT DataLen
    )
{
    if (!DatagramPool) {
        return pSendExactData (Socket, Data, DataLen);
    }

    return pSendDatagramData (Socket, DatagramPool, Data, DataLen);
}


INT
pRecvWithTimeout (
    IN      SOCKET Socket,
    IN      PBYTE Data,
    IN      UINT DataLen,
    IN      INT Flags,
    IN      UINT Timeout    OPTIONAL
    )

/*++

Routine Description:

  pRecvWithTimeout implements a basic socket recv call with a IDLE_TIMEOUT second
  timeout and with a check for the ISM cancel flag.

Arguments:

  Socket - Specifies the socket to recv from

  Data - Specifies the data buffer

  DataLen - Specifies the length of data buffer

  Flags - Specifies zero for normal recv, or MSG_PEEK

Return Value:

  The number of bytes read, or SOCKET_ERROR.  GetLastError contains the reason
  for failure.

--*/

{
    FD_SET readSet;
    FD_SET errorSet;
    TIMEVAL timeout = {1,0};
    INT timeToLive;
    INT result;

    if (Timeout == 0) {
        Timeout = IDLE_TIMEOUT * 1000;
    }

    timeToLive = GetTickCount() + Timeout;

    //
    // Wait up to IDLE_TIMEOUT seconds for the socket to have data
    //

    do {
        FD_ZERO (&readSet);
        FD_SET (Socket, &readSet);
        FD_ZERO (&errorSet);
        FD_SET (Socket, &errorSet);

        //
        // Check the ISM cancel flag
        //

        if (IsmCheckCancel ()) {
            SetLastError (ERROR_CANCELLED);
            return SOCKET_ERROR;
        }

        //
        // Wait 1 second for the socket to be readable
        //

        result = select (0, &readSet, NULL, &errorSet, &timeout);

        if (result) {
            if (FD_ISSET (Socket, &readSet)) {
                result = recv (Socket, Data, DataLen, Flags);
                return result;
            }

            if (FD_ISSET (Socket, &errorSet)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_SOCKET_HAS_ERROR));
                return SOCKET_ERROR;
            }

            DEBUGMSG ((DBG_HOMENET, "select returned %i but socket is not in readSet or errorSet", result));
        }

    } while ((timeToLive - GetTickCount()) < Timeout);

    LOG ((LOG_ERROR, (PCSTR) MSG_SOCKET_RECV_TIMEOUT));
    return SOCKET_ERROR;
}


PBYTE
pReceiveExactData (
    IN      SOCKET Socket,
    IN OUT  PGROWBUFFER Buffer,         OPTIONAL
    OUT     PBYTE AlternateBuffer,      OPTIONAL
    IN      UINT BytesToReceive,
    IN      UINT Timeout                OPTIONAL
    )

/*++

Routine Description:

  pReceiveExactData allocates a buffer from the caller-specified grow buffer,
  and receives data until the buffer is full, or until receive fails.

Arguments:

  Socket          - Specifies the socket to receive data on. The socket must
                    be in blocking mode.
  Buffer          - Specifies the buffer to allocate from; the end pointer is
                    reset to zero. Receives the data from the wire.
  AlternateBuffer - Specifies the buffer to put data into
  BytesToReceive  - Specifies the number of bytes to get from the socket. All
                    bytes must be read before this function returns.

Return Value:

  TRUE if the buffer was completed, or FALSE if receive failed.

  NOTE: Either Buffer or AlternateBuffer must be specified.  If both are
        specified, Buffer is used.


--*/

{
    PBYTE recvBuf;
    PBYTE bufPos;
    UINT bytesSoFar = 0;
    INT result;
    UINT readSize;

    if (Buffer) {
        Buffer->End = 0;
        recvBuf = GbGrow (Buffer, BytesToReceive);
    } else {
        recvBuf = AlternateBuffer;
    }

    bufPos = recvBuf;

    do {

        if (IsmCheckCancel()) {
            return FALSE;
        }

        readSize = BytesToReceive - bytesSoFar;
        result = pRecvWithTimeout (Socket, bufPos, readSize, 0, Timeout);

        if (!result) {
            // connection broken
            SetLastError (ERROR_CANCELLED);
            break;
        }

        if (result == SOCKET_ERROR) {
            DEBUGMSG ((DBG_ERROR, "Error reading from socket"));
            break;
        }

        bufPos += result;
        bytesSoFar += result;

    } while (bytesSoFar < BytesToReceive);

    MYASSERT (bytesSoFar <= BytesToReceive);

    return bytesSoFar == BytesToReceive ? recvBuf : NULL;
}


PBYTE
pReceiveDatagramData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,
    IN OUT  PGROWBUFFER Buffer,         OPTIONAL
    OUT     PBYTE AlternateBuffer,      OPTIONAL
    IN      UINT BytesToReceive,
    IN      UINT Timeout                OPTIONAL
    )

/*++

Routine Description:

  pReceiveDatagramData checks the datagram queue for data, allocates a
  receive buffer, and fills the buffer with the data from the wire. If
  necessary, this function will fill the queue, until there is enough data to
  fill the caller's buffer.

Arguments:

  Socket          - Specifies the datagram socket
  DatagramPool    - Specifies the structure containing the receive pool and
                    other sequencing info
  Buffer          - Specifies the buffer to allocate from; the end pointer is
                    reset to zero. Receives the data from the wire.
  AlternateBuffer - Specifies the buffer to put data into
  BytesToReceive  - Specifies the number of bytes to get from the socket. All
                    bytes must be read before this function returns.

Return Value:

  TRUE if the buffer was completed, or FALSE if receive failed.

  NOTE: Either Buffer or AlternateBuffer must be specified.  If both are
        specified, Buffer is used.

--*/

{
    PDATAGRAM_POOL_ITEM itemHeader;
    PDATAGRAM_POOL_ITEM prevItem, nextItem;
    BYTE buffer[512];
    PBYTE dataPtr;
    PBYTE recvBuf;
    PBYTE bufPos;
    UINT bytesSoFar = 0;
    UINT bytesLeft;
    INT result;
    PDATAGRAM_POOL_ITEM item;
    UINT newPacketNum;
    UINT currentPacketNum;
    ULONG available;
    PBYTE bigBuf = NULL;
    PBYTE p;

    if (Buffer) {
        Buffer->End = 0;
        recvBuf = GbGrow (Buffer, BytesToReceive);
    } else {
        recvBuf = AlternateBuffer;
    }

    bufPos = recvBuf;

    itemHeader = (PDATAGRAM_POOL_ITEM) buffer;
    dataPtr = (PBYTE) (&itemHeader[1]);

    for (;;) {
        //
        // Take all available data out of the pool
        //

        item = DatagramPool->FirstItem;
        bytesLeft = BytesToReceive - bytesSoFar;

        while (item) {

            if (item->Header.PacketNumber == DatagramPool->RecvSequenceNumber) {
                //
                // Two cases:
                //
                // 1. Want entire packet
                // 2. Want partial packet
                //

                if (bytesLeft >= item->Header.DataLength) {
                    // entire packet
                    CopyMemory (bufPos, item->PacketData, item->Header.DataLength);

                    MYASSERT (!item->Prev);
                    if (item->Next) {
                        item->Next->Prev = NULL;
                    }
                    DatagramPool->FirstItem = item->Next;

                    bytesSoFar += item->Header.DataLength;
                    PmReleaseMemory (DatagramPool->Pool, item);

                    DatagramPool->RecvSequenceNumber++;

                } else {
                    // partial packet
                    CopyMemory (bufPos, item->PacketData, bytesLeft);

                    item->PacketData += bytesLeft;
                    item->Header.DataLength -= (WORD) bytesLeft;

                    bytesSoFar += bytesLeft;
                }

                if (BytesToReceive == bytesSoFar) {
                    return recvBuf;
                }
            }

            item = item->Next;
        }

        //
        // Data is not available in the pool. Receive one packet and then try again.
        //

        ioctlsocket (Socket, FIONREAD, &available);
        if (!available) {
            Sleep (100);
            continue;
        }

        bigBuf = PmGetMemory (DatagramPool->Pool, available);

        result = pRecvWithTimeout (Socket, bigBuf, available, 0, Timeout);

        if (result == INVALID_SOCKET) {
            DEBUGMSG ((DBG_ERROR, "Can't receive datagram"));
            break;
        }

        p = bigBuf;

        while (result > 0) {

            if (result < sizeof (DATAGRAM_PACKET)) {
                DEBUGMSG ((DBG_ERROR, "Datagram header is too small"));
                break;
            }

            CopyMemory (&itemHeader->Header, p, sizeof (DATAGRAM_PACKET));
            p += sizeof (DATAGRAM_PACKET);
            result -= sizeof (DATAGRAM_PACKET);

            if (itemHeader->Header.DataLength > 256) {
                DEBUGMSG ((DBG_ERROR, "Datagram contains garbage"));
                break;
            }

            if (result < itemHeader->Header.DataLength) {
                DEBUGMSG ((DBG_ERROR, "Datagram data is too small"));
                break;
            }

            CopyMemory (dataPtr, p, itemHeader->Header.DataLength);
            p += itemHeader->Header.DataLength;
            result -= itemHeader->Header.DataLength;

            if ((UINT) itemHeader->Header.PacketNumber == DatagramPool->LastPacketNumber) {
                continue;
            }

            DatagramPool->LastPacketNumber = itemHeader->Header.PacketNumber;

            //
            // Put the packet in the item linked list, sorted by packet number
            //

            item = (PDATAGRAM_POOL_ITEM) PmDuplicateMemory (
                                            DatagramPool->Pool,
                                            (PCBYTE) itemHeader,
                                            itemHeader->Header.DataLength + sizeof (DATAGRAM_POOL_ITEM)
                                            );

            item->PacketData = (PBYTE) (&item[1]);

            prevItem = NULL;
            nextItem = DatagramPool->FirstItem;

            while (nextItem) {

                //
                // Account for wrapping; assume a packet number difference no more
                // than 16383 out-of-sequence packets in the queue (about 4M of
                // data)
                //

                if (nextItem->Header.PacketNumber >= 49152 && item->Header.PacketNumber < 16384) {
                    newPacketNum = (UINT) item->Header.PacketNumber + 65536;
                    currentPacketNum = (UINT) nextItem->Header.PacketNumber;
                } else if (nextItem->Header.PacketNumber < 16384 && item->Header.PacketNumber >= 49152) {
                    newPacketNum = (UINT) item->Header.PacketNumber;
                    currentPacketNum = (UINT) nextItem->Header.PacketNumber + 65536;
                } else {
                    newPacketNum = (UINT) item->Header.PacketNumber;
                    currentPacketNum = (UINT) nextItem->Header.PacketNumber;
                }

                if (newPacketNum < currentPacketNum) {
                    break;
                }

                prevItem = nextItem;
                nextItem = nextItem->Next;
            }

            item->Next = nextItem;
            item->Prev = prevItem;

            if (!prevItem) {
                DatagramPool->FirstItem = item;
            }
        }

        PmReleaseMemory (DatagramPool->Pool, bigBuf);
    }

    return bytesSoFar == BytesToReceive ? recvBuf : NULL;
}


PBYTE
pReceiveData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,    OPTIONAL
    IN OUT  PGROWBUFFER Buffer,             OPTIONAL
    OUT     PBYTE AlternateBuffer,          OPTIONAL
    IN      UINT BytesToReceive,
    IN      UINT Timeout                    OPTIONAL
    )
{
    if (!DatagramPool) {
        return pReceiveExactData (Socket, Buffer, AlternateBuffer, BytesToReceive, Timeout);
    }

    return pReceiveDatagramData (Socket, DatagramPool, Buffer, AlternateBuffer, BytesToReceive, Timeout);
}


BOOL
pSendFile (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,    OPTIONAL
    IN      PCTSTR LocalFileName,           OPTIONAL
    IN      PCTSTR DestFileName             OPTIONAL
    )

/*++

Routine Description:

  pSendFile sends a file on the wire.

Arguments:

  Socket        - Specifies the socket to send the file on
  DatagramPool  - Specifies the datagram pool for sockets that are connecitonless
  LocalFileName - Specifies the path to the local file
  DestFileName  - Specifies the subpath that is sent to the destination. The
                  destination uses the subpath to construct its corresponding
                  file name.

Return Value:

  TRUE if the file was sent, FALSE otherwise.

--*/

{
    PCWSTR destFileName = NULL;
    INT len;
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;
    HANDLE file = NULL;
    LONGLONG fileSize;
    DWORD msg;

    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    HCRYPTHASH hHash = 0;

    __try {

        //
        // Build the encrypt stuff
        //
        if ((!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
            (!CryptCreateHash (hProv, CALG_MD5, 0, 0, &hHash)) ||
            (!CryptHashData (hHash, (PBYTE)g_GlobalKey, ByteCountA (g_GlobalKey), 0)) ||
            (!CryptDeriveKey (hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hKey))
            ) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        //
        // Try to open the file
        //

        fileSize = BfGetFileSize (LocalFileName);

        file = BfOpenReadFile (LocalFileName);
        if (!file) {
            // nothing to do
            __leave;
        }

        //
        // Send the message "FILE"
        //

        msg = MESSAGE_FILE;
        if (!pSendData (Socket, DatagramPool, (PBYTE) &msg, sizeof (msg))) {
            SetLastError (ERROR_NETWORK_UNREACHABLE);
            DEBUGMSG ((DBG_ERROR, "Can't send MSG_FILE"));
            __leave;
        }

        //
        // If no file was specified, send length of zero
        //

        if (!LocalFileName || !DestFileName) {
            len = 0;
            if (!pSendData (Socket, DatagramPool, (PBYTE) &len, 4)) {
                SetLastError (ERROR_NETWORK_UNREACHABLE);
                DEBUGMSG ((DBG_ERROR, "Can't send nul file length"));
                __leave;
            }

            result = TRUE;
            __leave;
        }

        //
        // Send the file name and file size
        //

#ifdef UNICODE
        destFileName = DuplicatePathString (DestFileName, 0);
#else
        destFileName = ConvertAtoW (DestFileName);
#endif
        len = ByteCountW (destFileName);

        if (!pSendData (Socket, DatagramPool, (PBYTE) &len, 4)) {
            SetLastError (ERROR_NETWORK_UNREACHABLE);
            DEBUGMSG ((DBG_ERROR, "Can't send file length"));
            __leave;
        }

        // Encrypt the name of the file
        if (!CryptEncrypt(hKey, 0, TRUE, 0, (PBYTE)destFileName, &len, len)) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        if (!pSendData (Socket, DatagramPool, (PBYTE) destFileName, len)) {
            SetLastError (ERROR_NETWORK_UNREACHABLE);
            DEBUGMSG ((DBG_ERROR, "Can't send file name"));
            __leave;
        }

        if (!pSendData (Socket, DatagramPool, (PBYTE) &fileSize, 8)) {
            SetLastError (ERROR_NETWORK_UNREACHABLE);
            DEBUGMSG ((DBG_ERROR, "Can't send file size"));
            __leave;
        }

        //
        // Send the data 64K at a time
        //

        GbGrow (&data, 0x10000);

        while (fileSize) {
            if (fileSize > 0x10000) {

                len = 0x10000;

                if (!BfReadFile (file, data.Buf, len)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from file"));
                    __leave;
                }

                // Encrypt the buffer
                if (!CryptEncrypt(hKey, 0, FALSE, 0, data.Buf, &len, len)) {
                    SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
                    LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
                    __leave;
                }

                if (!pSendData (Socket, DatagramPool, data.Buf, len)) {
                    SetLastError (ERROR_NETWORK_UNREACHABLE);
                    DEBUGMSG ((DBG_ERROR, "Can't send file data"));
                    __leave;
                }

                fileSize -= 0x10000;
            } else {

                len = (INT)fileSize;

                if (!BfReadFile (file, data.Buf, (UINT) fileSize)) {
                    DEBUGMSG ((DBG_ERROR, "Can't read from file"));
                    __leave;
                }

                // Encrypt the buffer (last piece so set the last to TRUE)
                if (!CryptEncrypt(hKey, 0, TRUE, 0, data.Buf, &len, len)) {
                    SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
                    LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
                    __leave;
                }

                if (!pSendData (Socket, DatagramPool, data.Buf, (UINT) len)) {
                    SetLastError (ERROR_NETWORK_UNREACHABLE);
                    DEBUGMSG ((DBG_ERROR, "Can't send file data"));
                    __leave;
                }

                fileSize = 0;
            }
        }

        //
        // Done!
        //

        result = TRUE;
        DEBUGMSG ((DBG_HOMENET, "Sent %s", LocalFileName));
    }
    __finally {
        if (hKey) {
            CryptDestroyKey(hKey);
            hKey = 0;
        }
        if (hHash) {
            CryptDestroyHash(hHash);
            hHash = 0;
        }
        if (hProv) {
            CryptReleaseContext(hProv,0);
            hProv = 0;
        }
        GbFree (&data);
        if (file) {
            CloseHandle (file);
        }
        if (destFileName) {
#ifndef UNICODE
            FreeConvertedStr (destFileName);
#else
            FreePathString (destFileName);
#endif
            destFileName = NULL;
        }
    }

    return result;
}


BOOL
pReceiveFile (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    IN      PCTSTR LocalFileRoot,
    IN      UINT Timeout                        OPTIONAL
    )

/*++

Routine Description:

  pReceiveStreamFile obtains a file from the socket. The file is stored in
  g_StorageRoot. The subpath and file name is obtained from the data on the
  wire.

  NOTE: The caller must pull off the message DWORD before calling
        pReceiveStreamFile. This is unlike the send, which puts the message
        on the wire automatically.

Arguments:

  Socket - Specifies the socket to receive from.

  DatagramPool - Specifies the packet pool for a datagram-based socket

  LocalFileRoot - Specifies the local root path for the file

Return Value:

  TRUE if the file was received, FALSE otherwise.

--*/

{
    PCTSTR fileName = NULL;
    INT len;
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;
    PTSTR p;
    HANDLE file = NULL;
    LONGLONG fileSize;

    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    HCRYPTHASH hHash = 0;

    __try {

        //
        // Build the encrypt stuff
        //
        if ((!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
            (!CryptCreateHash (hProv, CALG_MD5, 0, 0, &hHash)) ||
            (!CryptHashData (hHash, (PBYTE)g_GlobalKey, ByteCountA (g_GlobalKey), 0)) ||
            (!CryptDeriveKey (hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hKey))
            ) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        //
        // Wait for file name
        //

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, 4, Timeout)) {
            __leave;
        }

        len = *((PDWORD) data.Buf);

        if (!len) {
            result = TRUE;
            __leave;
        }

        if (len >= (MAX_PATH * sizeof (TCHAR))) {
            __leave;
        }

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, len, Timeout)) {
            __leave;
        }

        // Decrypt the file name
        if (!CryptDecrypt(hKey, 0, TRUE, 0, data.Buf, &len)) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        GbGrow (&data, sizeof (TCHAR) * 2);
        p = (PTSTR) data.Buf;
        p[len / sizeof (TCHAR)] = 0;
        p[(len / sizeof (TCHAR)) + 1] = 0;

        fileName = JoinPaths (LocalFileRoot, p);
        if (!fileName) {
            __leave;
        }

        //
        // Get the file size
        //

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, 8, Timeout)) {
            __leave;
        }

        fileSize = *((PLONGLONG) data.Buf);

        DEBUGMSG ((DBG_HOMENET, "Receiving %s", fileName));

        //
        // Create the file
        //

        file = BfCreateFile (fileName);
        if (file == INVALID_HANDLE_VALUE) {
            PushError ();
            DEBUGMSG ((DBG_ERROR, "Can't create %s", fileName));
            PopError ();
            __leave;
        }

        //
        // Fetch the data 64K at a time
        //

        while (fileSize) {
            if (fileSize > 0x10000) {

                if (!pReceiveData (Socket, DatagramPool, &data, NULL, 0x10000, Timeout)) {
                    __leave;
                }

                len = data.End;

                // Decrypt the file name
                if (!CryptDecrypt(hKey, 0, FALSE, 0, data.Buf, &len)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
                    SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
                    __leave;
                }

                if (!BfWriteFile (file, data.Buf, len)) {
                    PushError ();
                    DEBUGMSG ((DBG_ERROR, "Can't write to file"));
                    PopError ();
                    __leave;
                }

                fileSize -= data.End;
            } else {

                if (!pReceiveData (Socket, DatagramPool, &data, NULL, (UINT) fileSize, Timeout)) {
                    __leave;
                }

                len = data.End;

                // Decrypt the file name
                if (!CryptDecrypt(hKey, 0, TRUE, 0, data.Buf, &len)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
                    SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
                    __leave;
                }

                if (!BfWriteFile (file, data.Buf, len)) {
                    PushError ();
                    DEBUGMSG ((DBG_ERROR, "Can't write to file"));
                    PopError ();
                    __leave;
                }

                fileSize = 0;
            }
        }

        //
        // Done!
        //

        result = TRUE;
        DEBUGMSG ((DBG_HOMENET, "Received %s", fileName));

    }
    __finally {
        PushError ();
        if (hKey) {
            CryptDestroyKey(hKey);
            hKey = 0;
        }
        if (hHash) {
            CryptDestroyHash(hHash);
            hHash = 0;
        }
        if (hProv) {
            CryptReleaseContext(hProv,0);
            hProv = 0;
        }
        GbFree (&data);
        if (file) {
            CloseHandle (file);
            if (!result) {
                DeleteFile (fileName);
            }
        }
        if (fileName) {
            FreePathString (fileName);
            fileName = NULL;
        }
        PopError ();
    }

    return result;
}


BOOL
pSendEncryptedData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,    OPTIONAL
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  pSendEncryptedFile sends a file on the wire.

Arguments:

  Socket        - Specifies the socket to send the file on
  DatagramPool  - Specifies the datagram pool for sockets that are connecitonless
  Data          - Buffer to be sent
  DataSize      - Size of data to be sent

Return Value:

  TRUE if the buffer was sent, FALSE otherwise.

--*/

{
    INT len;
    GROWBUFFER encData = INIT_GROWBUFFER;
    BOOL result = FALSE;
    DWORD msg;

    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    HCRYPTHASH hHash = 0;

    __try {

        //
        // Build the encrypt stuff
        //
        if ((!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
            (!CryptCreateHash (hProv, CALG_MD5, 0, 0, &hHash)) ||
            (!CryptHashData (hHash, (PBYTE)g_GlobalKey, ByteCountA (g_GlobalKey), 0)) ||
            (!CryptDeriveKey (hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hKey))
            ) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        //
        // Send the message "DATA"
        //

        msg = MESSAGE_DATA;
        if (!pSendData (Socket, DatagramPool, (PBYTE) &msg, sizeof (msg))) {
            DEBUGMSG ((DBG_ERROR, "Can't send MSG_FILE"));
            __leave;
        }

        //
        // Send the size of data
        //
        if (!pSendData (Socket, DatagramPool, (PBYTE) &DataSize, 4)) {
            DEBUGMSG ((DBG_ERROR, "Can't send file length"));
            __leave;
        }

        //
        // Send the data
        //

        GbGrow (&encData, DataSize);
        CopyMemory (encData.Buf, Data, DataSize);
        // Encrypt the buffer
        if (!CryptEncrypt(hKey, 0, TRUE, 0, encData.Buf, &DataSize, DataSize)) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        if (!pSendData (Socket, DatagramPool, encData.Buf, DataSize)) {
            DEBUGMSG ((DBG_ERROR, "Can't send file data"));
            __leave;
        }

        //
        // Done!
        //

        result = TRUE;
    }
    __finally {
        if (hKey) {
            CryptDestroyKey(hKey);
            hKey = 0;
        }
        if (hHash) {
            CryptDestroyHash(hHash);
            hHash = 0;
        }
        if (hProv) {
            CryptReleaseContext(hProv,0);
            hProv = 0;
        }
        GbFree (&encData);
    }

    return result;
}


BOOL
pReceiveEncryptedData (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    IN      PBYTE *Buffer,
    IN      UINT Timeout                        OPTIONAL
    )

/*++

Routine Description:

  pReceiveEncryptedData obtains a buffer from the socket. The data is stored in
  Buffer.

  NOTE: The caller must pull off the message DWORD before calling
        pReceiveEncryptedData. This is unlike the send, which puts the message
        on the wire automatically.

Arguments:

  Socket - Specifies the socket to receive from.

  DatagramPool - Specifies the packet pool for a datagram-based socket

  Buffer - Specifies a pointer to a PBYTE

Return Value:

  TRUE if the file was received, FALSE otherwise.

--*/

{
    GROWBUFFER data = INIT_GROWBUFFER;
    DWORD dataSize;
    BOOL result = FALSE;

    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    HCRYPTHASH hHash = 0;

    __try {

        //
        // Build the encrypt stuff
        //
        if ((!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
            (!CryptCreateHash (hProv, CALG_MD5, 0, 0, &hHash)) ||
            (!CryptHashData (hHash, (PBYTE)g_GlobalKey, ByteCountA (g_GlobalKey), 0)) ||
            (!CryptDeriveKey (hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &hKey))
            ) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        //
        // Wait for data size
        //

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, 4, Timeout)) {
            __leave;
        }

        dataSize = *((PDWORD) data.Buf);

        if (!dataSize) {
            result = TRUE;
            __leave;
        }

        if (dataSize > MAX_DATA_PACKET_SIZE) {
            // The only thing sent this way so far is the encrypted key. Obviously this
            // does not exceed 64k
            SetLastError (ERROR_INVALID_DATA);
            __leave;
        }

        if (!pReceiveData (Socket, DatagramPool, &data, NULL, dataSize, Timeout)) {
            __leave;
        }

        // Decrypt the content
        if (!CryptDecrypt(hKey, 0, TRUE, 0, data.Buf, &dataSize)) {
            SetLastError (ERROR_NO_SECURITY_ON_OBJECT);
            LOG ((LOG_ERROR, (PCSTR) MSG_ENCRYPTION_FAILED));
            __leave;
        }

        // Now allocate the result
        *Buffer = HeapAlloc (g_hHeap, 0, dataSize);
        if (*Buffer) {
            CopyMemory (*Buffer, data.Buf, dataSize);
            result = TRUE;
        }

    }
    __finally {
        if (hKey) {
            CryptDestroyKey(hKey);
            hKey = 0;
        }
        if (hHash) {
            CryptDestroyHash(hHash);
            hHash = 0;
        }
        if (hProv) {
            CryptReleaseContext(hProv,0);
            hProv = 0;
        }
        GbFree (&data);
    }

    return result;
}


BOOL
pSendMetrics (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,            OPTIONAL
    IN OUT  PTRANSFERMETRICS Metrics
    )

/*++

Routine Description:

  pSendMetrics sends transport data (such as the number of files or number of
  bytes to expect).  This is the first bit of information sent to the
  destination.

Arguments:

  Socket   - Specifies the socket to send the data to.

  DatagramPool - Specifies the structure for datagram mode

  Metrics  - Specifies a pointer to the metrics structure to send. The
             metrics structure member StructSize is updated before the struct
             is sent.

Return Value:

  TRUE if the metrics struct was sent, FALSE otherwise.

--*/

{
    Metrics->StructSize = sizeof (TRANSFERMETRICS);

    if (!pSendData (Socket, DatagramPool, (PBYTE) Metrics, sizeof (TRANSFERMETRICS))) {
        DEBUGMSG ((DBG_ERROR, "Failed to send data"));
        return FALSE;
    }

    return TRUE;
}


BOOL
pReceiveMetrics (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    OUT     PTRANSFERMETRICS Metrics
    )

/*++

Routine Description:

  pReceiveMetrics obtains a TRANSFERMETRICS structure from the wire. This is
  the first bit of information received by the destination. It provides the
  number of files, total number of file bytes, and other information.

Arguments:

  Socket  - Specifies the socket to receive data on.

  DatagramPool - Specifies the structure used for datagram data reception

  Metrics - Receives the metrics from the wire.

Return Value:

  TRUE if the metrics structure was received properly, FALSE otherwise.

--*/

{
    GROWBUFFER data = INIT_GROWBUFFER;
    BOOL result = FALSE;

    __try {
        if (!pReceiveData (Socket, DatagramPool, NULL, (PBYTE) Metrics, sizeof (TRANSFERMETRICS), 0)) {
            __leave;
        }

        if (Metrics->StructSize != sizeof (TRANSFERMETRICS)) {
            DEBUGMSG ((DBG_ERROR, "Invalid transfer metrics received"));
            __leave;
        }

        if (Metrics->Signature != HOMENETTR_SIG) {
            DEBUGMSG ((DBG_ERROR, "Invalid transfer signature received"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        GbFree (&data);
    }

    return result;
}


DWORD
pReceiveMessage (
    IN      SOCKET Socket,
    IN      PDATAGRAM_POOL DatagramPool,        OPTIONAL
    IN      UINT Timeout                        OPTIONAL
    )

/*++

Routine Description:

  pReceiveMessage obtains the next DWORD from the socket and returns it to
  the caller. This DWORD provides a message, indicating what action to
  take next.

Arguments:

  Socket  - Specifies the socket to receive data on

  DatagramPool - Specifies the structure used for datagram data reception

Return Value:

  The message, or 0 if no message is available.

--*/

{
    DWORD msg = 0;

    if (!pReceiveData (Socket, DatagramPool, NULL, (PBYTE) &msg, sizeof (DWORD), Timeout)) {
        msg = 0;
    }

    return msg;
}


BOOL
pConnectToDestination (
    IN      PCONNECTADDRESS Address,
    OUT     PCONNECTIONSOCKET Connection
    )
{
    BOOL result = FALSE;
    BOOL b;
    LINGER lingerStruct;

    CopyMemory (Connection->LocalAddress, Address->LocalAddress, Address->LocalAddressLen);
    Connection->LocalAddressLen = Address->LocalAddressLen;

    CopyMemory (Connection->RemoteAddress, Address->RemoteAddress, Address->RemoteAddressLen);
    Connection->RemoteAddressLen = Address->RemoteAddressLen;

    Connection->Socket = socket (
                            Address->Family,
                            Address->Datagram ? SOCK_DGRAM : SOCK_STREAM,
                            Address->Protocol
                            );

    if (Connection->Socket == INVALID_SOCKET) {
        DEBUGMSG ((DBG_ERROR, "Can't create socket for connection"));
        return FALSE;
    }

    __try {

        b = TRUE;
        setsockopt (Connection->Socket, SOL_SOCKET, SO_REUSEADDR, (PBYTE) &b, sizeof (b));

        b = TRUE;
        setsockopt (Connection->Socket, SOL_SOCKET, SO_KEEPALIVE, (PBYTE) &b, sizeof (b));

        lingerStruct.l_onoff = 1;
        lingerStruct.l_linger = 90;
        setsockopt (Connection->Socket, SOL_SOCKET, SO_LINGER, (PBYTE) &lingerStruct, sizeof (lingerStruct));

        pResetPort (Address->Family, (SOCKADDR *) Address->LocalAddress);

        if (bind (Connection->Socket, (SOCKADDR *) Address->LocalAddress, Address->LocalAddressLen)) {
            DEBUGMSG ((DBG_ERROR, "Failed to bind to connection socket"));
            __leave;
        }

        if (connect (Connection->Socket, (SOCKADDR *) Address->RemoteAddress, Address->RemoteAddressLen)) {
            DEBUGMSG ((DBG_ERROR, "Failed to connect to socket"));
            __leave;
        }

        Connection->Family = Address->Family;
        Connection->Protocol = Address->Protocol;

        Connection->Datagram = Address->Datagram;
        ZeroMemory (&Connection->DatagramPool, sizeof (DATAGRAM_POOL));
        if (Connection->Datagram) {
            Connection->DatagramPool.Pool = PmCreatePool();
            Connection->DatagramPool.LastPacketNumber = (UINT) -1;
        }

        result = TRUE;
    }
    __finally {
        if (!result && Connection->Socket != INVALID_SOCKET) {
            closesocket (Connection->Socket);
            Connection->Socket = INVALID_SOCKET;
        }
    }

    return result;
}


BOOL
FindDestination (
    OUT     PCONNECTADDRESS Address,
    IN      UINT Timeout,               OPTIONAL
    IN      BOOL IgnoreMultipleDests
    )

/*++

Routine Description:

  FindDestination invokes the name resolution algorithm to locate a
  destination. It selects the best transport to communicate on, and returns
  the address. The caller can use the return address to make a connection.

Arguments:

  Address - Receives the address of the destination

  Timeout - Specifies the number of seconds to wait for the first
            destination broadcast, or zero to wait forever.

  IgnoreMultipleDests - Specifies TRUE if multiple destinations should be
                        ignored (taking the first one as the connection),
                        or FALSE if a message should be passed to the UI
                        to resolve the conflict.

Return Value:

  TRUE if a destination was found, FALSE otherwise.

--*/

{
    GROWBUFFER destinationAddresses = INIT_GROWBUFFER;
    INT destinationCount;
    PCONNECTADDRESS addressArray;
    INT i;
    PCTSTR firstName;
    BOOL result = FALSE;
    GROWBUFFER destNames = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    BOOL duplicate;
    BOOL oneValid;
    ULONG_PTR response;

    __try {

        destinationCount = pNameResolver (PLATFORM_SOURCE, &destinationAddresses, Timeout, NULL);

        if (!destinationCount) {
            __leave;
        }

        addressArray = (PCONNECTADDRESS) destinationAddresses.Buf;

        //
        // Determine which address to use.  Rules are:
        //
        // 1. Must have only one destination to choose from
        // 2. Pick TCP/IP, then IPX. [, then NetBIOS -- no longer supported]
        //

        if (destinationCount > 1) {
            firstName = addressArray[0].DestinationName;

            for (i = 1 ; i < destinationCount ; i++) {
                if (!StringIMatch (firstName, addressArray[i].DestinationName)) {
                    break;
                }
            }

            if (i < destinationCount) {
                DEBUGMSG ((DBG_WARNING, "Multiple destinations found on the subnet"));

                //
                // put all destinations in an ISM environment variable, then call the
                // UI to allow it to resolve the conflict, and finally make sure
                // the one remaining destination is the only one used.
                //

                GbMultiSzAppend (&destNames, firstName);

                for (i = 1 ; i < destinationCount ; i++) {
                    if (EnumFirstMultiSz (&e, (PCTSTR) destNames.Buf)) {

                        duplicate = FALSE;

                        do {
                            if (StringIMatch (e.CurrentString, addressArray[i].DestinationName)) {
                                duplicate = TRUE;
                                break;
                            }
                        } while (EnumNextMultiSz (&e));
                    }

                    if (!duplicate) {
                        GbMultiSzAppend (&destNames, addressArray[i].DestinationName);
                    }
                }

                IsmSetEnvironmentMultiSz (
                    PLATFORM_DESTINATION,
                    NULL,
                    TRANSPORT_ENVVAR_HOMENET_DESTINATIONS,
                    (PCTSTR) destNames.Buf
                    );

                //
                // Tell the UI.  The UI must return TRUE and also update
                // TRANSPORT_ENVVAR_HOMENET_DESTINATIONS so that the selected
                // destination is the only member of the multi-sz.
                //

                if (!IgnoreMultipleDests) {
                    response = IsmSendMessageToApp (TRANSPORTMESSAGE_MULTIPLE_DESTS, 0);

                    if (IsmCheckCancel()) {
                        __leave;
                    }

                    if (!response) {
                        DEBUGMSG ((DBG_VERBOSE, "Multiple destinations were not resolved; can't continue"));
                        __leave;
                    }

                    if (!IsmGetEnvironmentMultiSz (
                            PLATFORM_DESTINATION,
                            NULL,
                            TRANSPORT_ENVVAR_HOMENET_DESTINATIONS,
                            (PTSTR) destNames.Buf,
                            destNames.End,
                            NULL
                            )) {
                        DEBUGMSG ((DBG_ERROR, "Can't get resolved destinations"));
                        __leave;
                    }
                }

                //
                // Reset all Family members for names not selected
                //

                oneValid = FALSE;

                for (i = 0 ; i < destinationCount ; i++) {
                    if (!StringIMatch (addressArray[i].DestinationName, (PCTSTR) destNames.Buf)) {
                        addressArray[i].Family = 0;
                    } else {
                        oneValid = TRUE;
                    }
                }

                if (!oneValid) {
                    DEBUGMSG ((DBG_ERROR, "Resolved destination does not exist"));
                    __leave;
                }
            }
        }

        //
        // Select the best protocol
        //

        for (i = 0 ; i < destinationCount ; i++) {
            if (addressArray[i].Family == AF_INET) {
                break;
            }
        }

        if (i == destinationCount) {
            for (i = 0 ; i < destinationCount ; i++) {
                if (addressArray[i].Family == AF_IPX) {
                    break;
                }
            }

            if (i == destinationCount) {
                for (i = 0 ; i < destinationCount ; i++) {
                    if (addressArray[i].Family == AF_NETBIOS) {
                        //break;
                    }
                }

                if (i == destinationCount) {
                    DEBUGMSG ((DBG_WHOOPS, "Connection is from unsupported protocol"));
                    __leave;
                }
            }
        }

        DEBUGMSG ((
            DBG_HOMENET,
            "Destination connection is %s (protocol %i)",
            addressArray[i].DestinationName,
            addressArray[i].Protocol
            ));

        CopyMemory (Address, &addressArray[i], sizeof (CONNECTADDRESS));
        result = TRUE;
    }
    __finally {
        PushError();

        GbFree (&destinationAddresses);
        GbFree (&destNames);

        PopError();
    }

    return result;
}


BOOL
TestConnection (
    IN      PCONNECTADDRESS Address
    )

/*++

Routine Description:

  TestConnection establishes a connection to the destination specified
  by Address. Will immediately disconnect since this was just a connection
  test.

Arguments:

  Address    - Specifies the address of the destination, as returned by
               FindDestination.

Return Value:

  TRUE if a connection could be established to the destination, FALSE otherwise.

--*/

{
    CONNECTIONSOCKET connection;
    BOOL result = FALSE;

    ZeroMemory (&connection, sizeof (CONNECTIONSOCKET));
    connection.Socket = INVALID_SOCKET;
    connection.KeepAliveSpacing = 30000;
    connection.LastSend = GetTickCount();

    __try {

        if (!pConnectToDestination (Address, &connection)) {
            __leave;
        }

        DEBUGMSG ((DBG_HOMENET, "TestConnection: Connected!"));

        result = TRUE;
    }
    __finally {
        if (connection.Socket != INVALID_SOCKET) {
            closesocket (connection.Socket);
            connection.Socket = INVALID_SOCKET;
        }

        if (connection.Datagram) {
            PmDestroyPool (connection.DatagramPool.Pool);
            connection.Datagram = FALSE;
        }
    }

    return result;
}


BOOL
ConnectToDestination (
    IN      PCONNECTADDRESS Address,
    IN      PTRANSFERMETRICS Metrics,
    OUT     PCONNECTIONSOCKET Connection
    )

/*++

Routine Description:

  ConnectToDestination establishes a connection to the destination specified
  by Address. Once connected, the Metrics structure is passed to the
  destination.  The caller receives the Connection structure for addtional
  communication.

Arguments:

  Address    - Specifies the address of the destination, as returned by
               FindDestination.
  Metrics    - Specifies the metrics structure that provides basic
               information such as the number of files to expect.
  Connection - Receives the connection to the destination, to be used in
               additional data transfer.

Return Value:

  TRUE if a connection was established to the destination, FALSE otherwise.

--*/

{
    BOOL result = FALSE;

    ZeroMemory (Connection, sizeof (CONNECTIONSOCKET));
    Connection->Socket = INVALID_SOCKET;
    Connection->KeepAliveSpacing = 30000;
    Connection->LastSend = GetTickCount();

    __try {

        if (!pConnectToDestination (Address, Connection)) {
            __leave;
        }

        DEBUGMSG ((DBG_HOMENET, "Connected!"));

        if (!pSendMetrics (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                Metrics
                )) {
            DEBUGMSG ((DBG_HOMENET, "Can't send metrics to destination"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (!result) {
            if (Connection->Socket != INVALID_SOCKET) {
                closesocket (Connection->Socket);
                Connection->Socket = INVALID_SOCKET;
            }
        }
    }

    return result;
}


DWORD
SendMessageToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      DWORD Message
    )
{
    Connection->LastSend = GetTickCount();

    return pSendData (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                (PBYTE) &Message,
                sizeof (DWORD)
                );
}


BOOL
SendFileToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCTSTR LocalPath,                   OPTIONAL
    IN      PCTSTR DestSubPath                  OPTIONAL
    )

/*++

Routine Description:

  SendFileToDestination sends a file to the connection specified.

  If LocalPath is NULL, then no file will be sent. This is used to skip files
  that cannot be accessed locally.

  If DestSubPath is NULL, then the file name in LocalPath will be used
  as DestSubPath.

Arguments:

  Connection  - Specifies the connection to send the file to, as returned by
                ConnectToDestination.
  LocalPath   - Specifies the local path of the file to send
  DestSubPath - Specifies the sub path to send to the destination (so it can
                reconstruct a path)

Return Value:

  TRUE if the file was sent, FALSE otherwise.

--*/

{
    if (LocalPath && !DestSubPath) {
        DestSubPath = GetFileNameFromPath (LocalPath);
    }

    return pSendFile (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                LocalPath,
                DestSubPath
                );
}


BOOL
SendDataToDestination (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCBYTE Data,
    IN      UINT DataSize
    )

/*++

Routine Description:

  SendDataToDestination sends a buffer to the connection specified.

Arguments:

  Connection  - Specifies the connection to send the file to, as returned by
                ConnectToDestination.
  Data        - Specifies the buffer to send
  DataSize    - Specifies the data size

Return Value:

  TRUE if the file was sent, FALSE otherwise.

--*/

{
    return pSendEncryptedData (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                Data,
                DataSize
                );
}


VOID
CloseConnection (
    IN      PCONNECTIONSOCKET Connection
    )
{
    if (Connection->Socket != INVALID_SOCKET) {
        closesocket (Connection->Socket);
        Connection->Socket = INVALID_SOCKET;
    }

    if (Connection->Datagram) {
        PmDestroyPool (Connection->DatagramPool.Pool);
        Connection->Datagram = FALSE;
    }
}


BOOL
ConnectToSource (
    OUT     PCONNECTIONSOCKET Connection,
    OUT     PTRANSFERMETRICS Metrics
    )

/*++

Routine Description:

  ConnectToSource locates the source machine and accepts a connection from
  it. To locate the source machine, broadcast messages are sent out on all
  available transports. The source machine collects the broadcasts, then
  selects the best transport, and connects to the destination machine. After
  the connection completes, this function returns the connection to the
  caller.

Arguments:

  Connection - Receives the connection to the source machine. This connection
               structure is then used to obtain data from the source.

  Metrics - Recieves the metrics from the source machine, indicating what
            data is going to be sent.

Return Value:

  TRUE if a connection was accepted, FALSE otherwise.

--*/

{
    ZeroMemory (Connection, sizeof (CONNECTIONSOCKET));
    Connection->Socket = INVALID_SOCKET;

    for (;;) {

        if (!pNameResolver (PLATFORM_DESTINATION, NULL, 0, Connection)) {
            return FALSE;
        }

        if (pReceiveMetrics (
                Connection->Socket,
                Connection->Datagram ? &Connection->DatagramPool : NULL,
                Metrics
                )) {
            return TRUE;
        }

        CloseConnection (Connection);
    }

    return TRUE;
}

DWORD
ReceiveFromSource (
    IN      PCONNECTIONSOCKET Connection,
    IN      PCTSTR LocalFileRoot,
    OUT     PBYTE *Buffer,
    IN      UINT Timeout    OPTIONAL
    )

/*++

Routine Description:

  ReceiveFromSource obtains whatever data is being sent from the source. If the data
  is a file, the file is saved into the directory indicated by LocalFileRoot.
  If the data is encrypted buffer we will allocate Buffer and return the decrypted
  data there.

Arguments:

  Connection    - Specifies the connection to send the file to, as returned by
                  ConnectToDestination.
  LocalFileRoot - Specifies the root of the local path of the file to save. The
                  actual file name and optional subpath comes from the destination.
  Buffer        - Specifies the buffer to be allocated and filled with decrypted data.

Return Value:

  The message ID received, or 0 if no message was recieved.

--*/

{
    DWORD msg;
    BOOL retry;

    do {

        retry = FALSE;

        msg = pReceiveMessage (Connection->Socket, Connection->Datagram ? &Connection->DatagramPool : NULL, Timeout);
        DEBUGMSG ((DBG_HOMENET, "Message from source: %u", msg));

        switch (msg) {

        case MESSAGE_FILE:
            BfCreateDirectory (LocalFileRoot);
            if (!pReceiveFile (
                    Connection->Socket,
                    Connection->Datagram ? &Connection->DatagramPool : NULL,
                    LocalFileRoot,
                    Timeout
                    )) {
                msg = 0;
            }

            break;

        case MESSAGE_DATA:
            if (!pReceiveEncryptedData (
                    Connection->Socket,
                    Connection->Datagram ? &Connection->DatagramPool : NULL,
                    Buffer,
                    Timeout
                    )) {
                msg = 0;
            }

            break;

        case MESSAGE_KEEP_ALIVE:
            retry = TRUE;
            break;

        }
    } while (retry);

    return msg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\guitrans\opaque.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    opaque.c

Abstract:

    Implements a basic secure server transport module

Author:

    Jim Schmidt (jimschm) 08-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "logmsg.h"
#include <compress.h>

#define DBG_OPAQUE   "OpaqueUnc"

//
// Strings
//

#define S_TRANSPORT_DIR         TEXT("USMT2.UNC")
#define S_TRANSPORT_DAT_FILE    TEXT("TRANSDB.DAT")
#define S_TRANSPORT_IMG_FILE    TEXT("IMG%05X.DAT")
#define S_TRANSPORT_STATUS_FILE TEXT("status")
#define S_FILEOBJECT_NAME       TEXT("File")
#define S_REGOBJECT_NAME        TEXT("Registry")
#define S_DATABASEOBJECT_NAME   TEXT("Database")
#define S_DETAILS_PREFIX        TEXT("details-")

//
// Constants
//
#define TRFLAG_FILE         0x01
#define TRFLAG_MEMORY       0x02
#define COPY_BUFFER_SIZE    32768
#define OPAQUETR_OLDSIG1    0x55534D31  //USM1
#define OPAQUETR_OLDSIG2    0x55534D32  //USM2
#define OPAQUETR_OLDSIG3    0x55534D33  //USM3
#define OPAQUETR_CONVSIG    0x55534D33  //USM3
#define OPAQUETR_SIG        0x55534D34  //USM4

#define TRSTATUS_DIRTY      0x00000001
#define TRSTATUS_READY      0x00000002
#define TRSTATUS_LOCKED     0x00000003

//
// Macros
//

// None

//
// Types
//

typedef struct {
    TCHAR TempFile [MAX_PATH];
    PCVOID AllocPtr;
    PCVOID DetailsPtr;
    HANDLE FileHandle;
    HANDLE MapHandle;
} ALLOCSTATE, *PALLOCSTATE;

//
// Globals
//

MIG_TRANSPORTSTORAGEID g_ReliableStorageId;
PCTSTR g_TransportPath = NULL;
PCTSTR g_TransportTempPath = NULL;
PCTSTR g_TransportStatus = NULL;
HANDLE g_TransportStatusHandle = NULL;
BOOL g_OtCompressData = FALSE;
BOOL g_OtOldFormat = FALSE;
UINT g_Platform;
MIG_PROGRESSSLICEID g_PersistentSlice;
MIG_PROGRESSSLICEID g_DatabaseSlice;
UINT g_CompressedTicks;
UINT g_CompressedTicked;
MIG_PROGRESSSLICEID g_CompressedSlice;
UINT g_UncompressTicks;
UINT g_UncompressTicked;
MIG_PROGRESSSLICEID g_UncompressSlice;
LONGLONG g_TotalFiles;
LONGLONG g_FilesRead;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pOtSaveAllState (
    IN      BOOL Compressed
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pSetOpaqueTransportStatus (
    IN      HANDLE TrJournalHandle,
    IN      BOOL Compressed,
    IN      DWORD Status
    )
{
    DWORD signature = OPAQUETR_SIG;
    BOOL result = FALSE;

    if (BfSetFilePointer (TrJournalHandle, 0)) {
        result = TRUE;
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&signature), sizeof (DWORD));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Compressed), sizeof (BOOL));
        result = result && BfWriteFile (TrJournalHandle, (PBYTE)(&Status), sizeof (DWORD));
        result = result && FlushFileBuffers (TrJournalHandle);
    }
    return result;
}

DWORD
pGetOpaqueTransportStatus (
    IN      PCTSTR TrJournal,
    OUT     PBOOL Compressed,   OPTIONAL
    OUT     PBOOL OldStorage,   OPTIONAL
    IN      BOOL OpenReadOnly
    )
{
    HANDLE trJrnHandle;
    BOOL compressed = FALSE;
    DWORD signature = 0;
    DWORD fileSize = 0;
    DWORD error;
    DWORD result = 0;

    if (OldStorage) {
        *OldStorage = FALSE;
    }

    if (TrJournal && TrJournal [0]) {
        if (OpenReadOnly) {
            trJrnHandle = BfOpenReadFile (TrJournal);
        } else {
            trJrnHandle = BfOpenFile (TrJournal);
        }
        if (trJrnHandle) {
            if (BfSetFilePointer (trJrnHandle, 0)) {
                fileSize = GetFileSize (trJrnHandle, NULL);
                if (fileSize == (sizeof (BOOL) + sizeof (DWORD))) {
                    if (OldStorage) {
                        *OldStorage = TRUE;
                    }
                    if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                        BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                    }
                }
                if (fileSize == (sizeof (BOOL) + sizeof (DWORD) + sizeof (DWORD))) {
                    if (BfReadFile (trJrnHandle, (PBYTE)(&signature), sizeof (DWORD))) {
                        if (signature == OPAQUETR_SIG) {
                            if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                                BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                            }
                        }
                        if ((signature == OPAQUETR_OLDSIG1) ||
                            (signature == OPAQUETR_OLDSIG2) ||
                            (signature == OPAQUETR_OLDSIG3)
                            ) {
                            if (OldStorage) {
                                *OldStorage = TRUE;
                            }
                            if (BfReadFile (trJrnHandle, (PBYTE)(&compressed), sizeof (BOOL))) {
                                BfReadFile (trJrnHandle, (PBYTE)(&result), sizeof (DWORD));
                            }
                        }
                    }
                }
            }
            CloseHandle (trJrnHandle);
        } else {
            error = GetLastError ();
            if ((error == ERROR_ACCESS_DENIED) ||
                (error == ERROR_SHARING_VIOLATION)
                ) {
                result = TRSTATUS_LOCKED;
            }
        }
    }
    if (Compressed) {
        *Compressed = compressed;
    }
    return result;
}

PCTSTR
pGetOpaqueImageFile (
    IN      PCTSTR BasePath,
    IN      UINT ImageIdx
    )
{
    TCHAR imageFileName [13];
    PCTSTR imageFile = NULL;
    HANDLE imageFileHandle = NULL;

    wsprintf (imageFileName, S_TRANSPORT_IMG_FILE, ImageIdx);
    return JoinPaths (BasePath, imageFileName);
}

PCTSTR
pGetRealTransportPath (
    VOID
    )
{
    return g_OtCompressData?g_TransportTempPath:g_TransportPath;
}

BOOL
WINAPI
OpaqueTransportInitialize (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    //
    // Initialize globals
    //

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_ReliableStorageId = IsmRegisterTransport (S_RELIABLE_STORAGE_TRANSPORT);

    return TRUE;
}

VOID
WINAPI
OpaqueTransportEstimateProgressBar (
    MIG_PLATFORMTYPEID PlatformTypeId
    )
{
    UINT ticks;
    PMIG_OBJECTCOUNT objectCount;

    if (PlatformTypeId == PLATFORM_SOURCE) {

        //
        // If saving, we know the number of ticks based on the count of the
        // persistent attribute.
        //

        objectCount = IsmGetObjectsStatistics (PLATFORM_SOURCE);

        if (objectCount) {
            ticks = objectCount->PersistentObjects;
        } else {
            ticks = 0;
        }

        g_PersistentSlice = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

        if (g_OtCompressData) {
            g_DatabaseSlice = IsmRegisterProgressSlice (3, 1);
        } else {
            g_DatabaseSlice = IsmRegisterProgressSlice (1, 1);
        }

    } else {
        if (g_OtCompressData) {
            g_UncompressTicked = 0;
            g_UncompressTicks = 1000;
            g_UncompressSlice = IsmRegisterProgressSlice (g_UncompressTicks, 180);
        } else {
            //
            // If restoring, we have almost no work to account for, since
            // we download from the secure server file-by-file.
            //

            DEBUGMSG ((DBG_VERBOSE, "Assuming transport download has no progress impact"));
        }
    }
}

BOOL
WINAPI
OpaqueTransportQueryCapabilities (
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    OUT     PMIG_TRANSPORTTYPE TransportType,
    OUT     PMIG_TRANSPORTCAPABILITIES Capabilities,
    OUT     PCTSTR *FriendlyDescription
    )
{
    if (TransportStorageId != g_ReliableStorageId) {
        return FALSE;
    }

    *TransportType = TRANSPORTTYPE_FULL;
    *Capabilities = CAPABILITY_COMPRESSED;
    *FriendlyDescription = TEXT("Local computer or another computer on the Network");
    return TRUE;
}

VOID
pOtCleanUpTempDir (
    VOID
    )
{
    if (g_TransportTempPath) {
        FiRemoveAllFilesInTree (g_TransportTempPath);
    }
}

PCTSTR
pOtCreateTemporaryDir (
    VOID
    )
{
    TCHAR tempFile[MAX_PATH];

    if (!IsmGetTempDirectory (tempFile, ARRAYSIZE(tempFile))) {
        return NULL;
    }
    return DuplicatePathString (tempFile, 0);
}

BOOL
WINAPI
OpaqueTransportSetStorage (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      MIG_TRANSPORTSTORAGEID TransportStorageId,
    IN      MIG_TRANSPORTCAPABILITIES RequiredCapabilities,
    IN      PCTSTR StoragePath,
    OUT     PBOOL Valid,
    OUT     PBOOL ImageExists
    )
{
    PCTSTR lastDirPtr = NULL;
    PCTSTR transportPath = NULL;
    PCTSTR transportStatus = NULL;
    HANDLE transportStatusHandle = INVALID_HANDLE_VALUE;
    MIG_OBJECTSTRINGHANDLE encodedPath;
    DWORD status;
    BOOL result = FALSE;

    if (Valid) {
        *Valid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    if (TransportStorageId == g_ReliableStorageId) {

        if ((!RequiredCapabilities) || (RequiredCapabilities == CAPABILITY_COMPRESSED)) {

            if (RequiredCapabilities == CAPABILITY_COMPRESSED) {
                g_OtCompressData = TRUE;
            } else {
                g_OtCompressData = FALSE;
            }

            // If this is the destination, let's check if the user included USMT2.UNC in
            // the path by mistake. If he did (the StoragePath ends in USMT2.UNC and
            // StoragePath has our transport status) we will accept it.
            if (Platform == PLATFORM_DESTINATION) {
                lastDirPtr = _tcsrchr (StoragePath, TEXT('\\'));
                if (lastDirPtr) {
                    lastDirPtr = _tcsinc (lastDirPtr);
                    if (lastDirPtr) {
                        if (StringIMatch (lastDirPtr, S_TRANSPORT_DIR)) {
                            transportPath = DuplicatePathString (StoragePath, 0);
                            transportStatus = JoinPaths (transportPath, S_TRANSPORT_STATUS_FILE);
                            if ((!DoesFileExist (transportPath)) ||
                                (pGetOpaqueTransportStatus (transportStatus, NULL, NULL, TRUE) != TRSTATUS_READY)
                                ) {
                                FreePathString (transportPath);
                                transportPath = NULL;
                                FreePathString (transportStatus);
                                transportStatus = NULL;
                            }
                        }
                    }
                }
            }

            if (!transportPath) {
                transportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
            }
            if (!transportStatus) {
                transportStatus = JoinPaths (transportPath, S_TRANSPORT_STATUS_FILE);
            }

            if (!DoesFileExist (transportPath)) {

                // we require UNC path or a full path (like c:\...)
                if (transportPath[0] == '\\' && transportPath[1] == '\\') {
                    // this is a UNC path
                    *Valid = TRUE;
                } else if (transportPath[1] == ':') {
                    // this is a normal full path
                    *Valid = TRUE;
                } else {
                    *Valid = FALSE;
                }

                if ((*Valid) && (Platform == PLATFORM_SOURCE)) {
                    // we need to actually try to create our transport directory and the status file
                    // After that we will remove them but this is just the way for us to validate the
                    // store

                    *Valid = FALSE;
                    if (BfCreateDirectory (transportPath)) {
                        transportStatusHandle = BfCreateFile (transportStatus);
                        if (transportStatusHandle) {
                            *Valid = TRUE;
                            CloseHandle (transportStatusHandle);
                        }
                        PushError ();
                        FiRemoveAllFilesInTree (transportPath);
                        PopError ();
                    }
                }

                *ImageExists = FALSE;

            } else {

                // we try to open this transport status file with Read/Write. If we
                // fail this is either because somebody has it opened or we don't
                // have access rights. In both cases we should get back TRSTATUS_LOCKED

                status = pGetOpaqueTransportStatus (transportStatus, NULL, NULL, TRUE);

                switch (status) {
                case TRSTATUS_LOCKED:
                    *ImageExists = TRUE;
                    *Valid = FALSE;
                    break;
                case TRSTATUS_READY:
                    *ImageExists = TRUE;
                    *Valid = TRUE;
                    break;
                case TRSTATUS_DIRTY:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                    break;
                default:
                    *ImageExists = FALSE;
                    *Valid = TRUE;
                }
            }

            result = TRUE;
        }
    }

    if (result && *Valid) {

        if (g_TransportPath) {
            FreePathString (g_TransportPath);
            g_TransportPath = NULL;
        }

        if (g_TransportStatus) {
            FreePathString (g_TransportStatus);
            g_TransportStatus = NULL;
        }

        if (transportPath) {
            g_TransportPath = transportPath;
        } else {
            g_TransportPath = JoinPaths (StoragePath, S_TRANSPORT_DIR);
        }
        if (transportStatus) {
            g_TransportStatus = transportStatus;
        } else {
            g_TransportStatus = JoinPaths (g_TransportPath, S_TRANSPORT_STATUS_FILE);
        }

        encodedPath = IsmCreateSimpleObjectPattern (g_TransportPath, FALSE, NULL, FALSE);
        if (encodedPath) {
            IsmRegisterStaticExclusion (MIG_FILE_TYPE, encodedPath);
            IsmDestroyObjectHandle (encodedPath);
        }
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportSaveState (
    VOID
    )
{
    MIG_APPINFO appInfo;
    ERRUSER_EXTRADATA extraData;
    DWORD status;
    BOOL result = FALSE;
    BOOL allowDelete = FALSE;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    __try {

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_PREPARING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (!g_TransportPath) {
            DEBUGMSG ((DBG_ERROR, "Transport Path is not selected"));
            extraData.Error = ERRUSER_ERROR_NOTRANSPORTPATH;
            __leave;
        }

        if (DoesFileExist (g_TransportPath)) {

            status = pGetOpaqueTransportStatus (g_TransportStatus, NULL, NULL, FALSE);

            switch (status) {
            case TRSTATUS_LOCKED:
                SetLastError (ERROR_ACCESS_DENIED);
                LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_TransportPath));
                extraData.Error = ERRUSER_ERROR_TRANSPORTPATHBUSY;
                __leave;
            case TRSTATUS_DIRTY:
                result = FiRemoveAllFilesInTree (g_TransportPath);
                if (!result) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR, g_TransportPath));
                    extraData.Error = ERRUSER_ERROR_CANTEMPTYDIR;
                    __leave;
                }
                break;
            case TRSTATUS_READY:
            default:
                if (IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_EXISTS, 0)) {
                    if (!FiRemoveAllFilesInTree (g_TransportPath)) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_EMPTY_DIR, g_TransportPath));
                        extraData.Error = ERRUSER_ERROR_CANTEMPTYDIR;
                        __leave;
                    }
                } else {
                    LOG ((LOG_ERROR, (PCSTR) MSG_NOT_EMPTY, g_TransportPath));
                    SetLastError (ERROR_ALREADY_EXISTS);
                    extraData.Error = ERRUSER_ERROR_ALREADYEXISTS;
                    __leave;
                }
                break;
            }
        }

        allowDelete = TRUE;

        if (!BfCreateDirectory (g_TransportPath)) {
            PushError ();
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_DIR, g_TransportPath));
            PopError ();
            extraData.Error = ERRUSER_ERROR_CANTCREATEDIR;
            __leave;
        }

        g_TransportStatusHandle = BfCreateFile (g_TransportStatus);
        if (!g_TransportStatusHandle) {
            PushError ();
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_STATUS_FILE, g_TransportStatus));
            PopError ();
            extraData.Error = ERRUSER_ERROR_CANTCREATESTATUS;
            __leave;
        }

        result = pSetOpaqueTransportStatus (g_TransportStatusHandle, g_OtCompressData, TRSTATUS_DIRTY);
        if (!result) {
            PushError ();
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_CREATE_STATUS_FILE, g_TransportStatus));
            PopError ();
            extraData.Error = ERRUSER_ERROR_CANTCREATESTATUS;
            __leave;
        }

        g_Platform = PLATFORM_SOURCE;
        result = pOtSaveAllState (g_OtCompressData);

        if (result) {
            result = result && pSetOpaqueTransportStatus (g_TransportStatusHandle, g_OtCompressData, TRSTATUS_READY);
        }

        result = result && FlushFileBuffers (g_TransportStatusHandle);
        result = result && CloseHandle (g_TransportStatusHandle);
        if (result) {
            g_TransportStatusHandle = NULL;
        }
    }
    __finally {
        PushError ();
        if (g_TransportStatusHandle) {
            // if we got here there was some error. Let's just close the handle
            CloseHandle (g_TransportStatusHandle);
        }
        if (allowDelete && (!result)) {
            FiRemoveAllFilesInTree (g_TransportPath);
        }
        PopError ();
    }

    PushError ();

    if (!result) {
        extraData.ErrorArea = ERRUSER_AREA_SAVE;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
    }

    PopError ();

    return result;
}

PCTSTR
pOpaqueGetNewFileName (
    IN      PCTSTR FileName
    )
{
    PCTSTR newFileName = NULL;
    PTSTR tempPtr1 = NULL;
    PCTSTR endStr1 = NULL;
    PCTSTR tempPtr2 = NULL;
    PCTSTR endStr2 = NULL;
    INT i;

    // let's modify the file to extract. The file name will
    // be split in 2 after the first 5 characters
    newFileName = DuplicatePathString (FileName, 1);
    if (!newFileName) {
        return NULL;
    }
    tempPtr1 = (PTSTR) GetFileNameFromPath (newFileName);
    if (!tempPtr1) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr1 = GetEndOfString (newFileName);
    if (!endStr1) {
        FreePathString (newFileName);
        return NULL;
    }
    tempPtr2 = GetFileNameFromPath (FileName);
    if (!tempPtr2) {
        FreePathString (newFileName);
        return NULL;
    }
    endStr2 = GetEndOfString (FileName);
    if (!endStr2) {
        FreePathString (newFileName);
        return NULL;
    }
    for (i = 0; i < 5; i ++) {
        tempPtr1 = _tcsinc (tempPtr1);
        tempPtr2 = _tcsinc (tempPtr2);
    }

    if ((tempPtr1 < endStr1) &&
        (tempPtr2 < endStr2)
        ) {
        StringCopy (tempPtr1, TEXT("\\"));
        tempPtr1 = _tcsinc (tempPtr1);
        StringCopy (tempPtr1, tempPtr2);
    } else {
        FreePathString (newFileName);
        newFileName = NULL;
    }
    return newFileName;
}

BOOL
pOpaqueCallback (
    IN      PCTSTR FileToExtract,
    IN      LONGLONG FileSize,
    OUT     PBOOL ExtractFile,
    IN OUT  PCTSTR *NewFileName
    )
{
    LONGLONG numerator;
    LONGLONG divisor;
    LONGLONG tick;
    UINT delta;

    if (NewFileName) {
        *NewFileName = pOpaqueGetNewFileName (FileToExtract);
    }

    g_FilesRead ++;
    // now update the progress bar
    numerator = (LONGLONG) g_FilesRead * (LONGLONG) g_UncompressTicks;
    divisor = (LONGLONG) g_TotalFiles;
    if (divisor) {
        tick = numerator / divisor;
    } else {
        tick = 0;
    }
    delta = (UINT) tick - g_UncompressTicked;
    if (delta) {
        IsmTickProgressBar (g_UncompressSlice, delta);
        g_UncompressTicked += delta;
    }

    if (ExtractFile) {
        *ExtractFile = TRUE;
    }

    return (!IsmCheckCancel());
}

BOOL
pOtReadAllImages (
    VOID
    )
{
    COMPRESS_HANDLE compressedHandle;
    BOOL result = FALSE;

    if (CompressOpenHandle (g_TransportPath, S_TRANSPORT_IMG_FILE, 1, &compressedHandle)) {
        g_TotalFiles = compressedHandle.FilesStored;
        if (CompressExtractAllFiles (g_TransportTempPath, &compressedHandle, pOpaqueCallback)) {
            result = TRUE;
        }
        CompressCleanupHandle (&compressedHandle);
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportBeginApply (
    VOID
    )
{
    ERRUSER_EXTRADATA extraData;
    DWORD status = 0;
    PCTSTR memDbFile;
    INT_PTR appReply;
    PCTSTR newTransDbFile = NULL;
    BOOL result = FALSE;

    g_Platform = PLATFORM_DESTINATION;

    ZeroMemory (&extraData, sizeof (ERRUSER_EXTRADATA));
    extraData.Error = ERRUSER_ERROR_UNKNOWN;

    __try {
        if (!g_TransportPath) {
            DEBUGMSG ((DBG_ERROR, "Transport Path is not selected"));
            extraData.Error = ERRUSER_ERROR_NOTRANSPORTPATH;
            __leave;
        }

        while (status != TRSTATUS_READY) {

            status = pGetOpaqueTransportStatus (g_TransportStatus, &g_OtCompressData, &g_OtOldFormat, TRUE);

            switch (status) {
            case TRSTATUS_LOCKED:
                if (!IsmSendMessageToApp (TRANSPORTMESSAGE_IMAGE_LOCKED, 0)) {
                    SetLastError (ERROR_ACCESS_DENIED);
                    LOG ((LOG_ERROR, (PCSTR) MSG_TRANSPORT_DIR_BUSY, g_TransportPath));
                    extraData.Error = ERRUSER_ERROR_TRANSPORTPATHBUSY;
                    __leave;
                }
                break;
            case TRSTATUS_DIRTY:
                SetLastError (ERROR_INVALID_DATA);
                LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
                extraData.Error = ERRUSER_ERROR_TRANSPORTINVALIDIMAGE;
                __leave;
            case TRSTATUS_READY:
                break;
            default:
                SetLastError (ERROR_INVALID_DATA);
                LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
                extraData.Error = ERRUSER_ERROR_TRANSPORTINVALIDIMAGE;
                __leave;
            }
        }

        if (g_OtOldFormat) {
            IsmSendMessageToApp (TRANSPORTMESSAGE_OLD_STORAGE, 0);
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_IMAGE, g_TransportPath));
            extraData.Error = ERRUSER_ERROR_TRANSPORTINVALIDIMAGE;
            __leave;
        }

        g_TransportStatusHandle = BfOpenReadFile (g_TransportStatus);
        if (!g_TransportStatusHandle) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_STATUS_FILE, g_TransportStatus));
            extraData.Error = ERRUSER_ERROR_CANTOPENSTATUS;
            __leave;
        }

        if (g_OtCompressData) {
            g_TransportTempPath = pOtCreateTemporaryDir ();

            if (!g_TransportTempPath) {
                CloseHandle (g_TransportStatusHandle);
                g_TransportStatusHandle = NULL;
                extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
                __leave;
            }

            if (!pOtReadAllImages ()) {
                CloseHandle (g_TransportStatusHandle);
                g_TransportStatusHandle = NULL;
                extraData.Error = ERRUSER_ERROR_CANTUNPACKIMAGE;
                __leave;
            }
            CloseHandle (g_TransportStatusHandle);
            g_TransportStatusHandle = NULL;
        }

        newTransDbFile = pOpaqueGetNewFileName (S_TRANSPORT_DAT_FILE);

        memDbFile = JoinPaths (pGetRealTransportPath (), newTransDbFile?newTransDbFile:S_TRANSPORT_DAT_FILE);

        if (newTransDbFile) {
            FreePathString (newTransDbFile);
            newTransDbFile = NULL;
        }

        result = MemDbLoad (memDbFile);
        if (!result) {
            extraData.Error = ERRUSER_ERROR_CANTREADIMAGE;
        }
        FreePathString (memDbFile);
    }
    __finally {
    }

    if (!result) {
        extraData.ErrorArea = ERRUSER_AREA_LOAD;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
    }

    return result;
}

VOID
WINAPI
OpaqueTransportEndApply (
    VOID
    )
{
    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    if (g_OtCompressData) {
        pOtCleanUpTempDir ();
    } else {
        CloseHandle (g_TransportStatusHandle);
        g_TransportStatusHandle = NULL;
    }
}

VOID
WINAPI
OpaqueTransportTerminate (
    VOID
    )
{
    pOtCleanUpTempDir();

    if (g_TransportTempPath) {
        FreePathString (g_TransportTempPath);
        g_TransportTempPath = NULL;
    }
    if (g_TransportStatus) {
        FreePathString (g_TransportStatus);
        g_TransportStatus = NULL;
    }
    if (g_TransportPath) {
        FreePathString (g_TransportPath);
        g_TransportPath = NULL;
    }
}

static
VOID
pGetTempFileName (
    OUT     PTSTR Buffer
    )
{
    static fileIndex = 0;

    fileIndex ++;
    wsprintf (Buffer, TEXT("%08X.DAT"), fileIndex);
}

PCTSTR
pOpaqueAllocStorageFileName (
    IN      PCTSTR FileName         OPTIONAL
    )
{
    TCHAR buffer[32];

    if (FileName) {
        StringCopy (buffer, FileName);
    } else {
        pGetTempFileName (buffer);
    }

    return JoinPaths (g_TransportPath, buffer);
}

VOID
pFreeStorageFileName (
    IN      PCTSTR FileName
    )
{
    FreePathString (FileName);
}

BOOL
pOpaqueSaveDetails (
    IN      PCTSTR DecoratedObject,
    IN      PMIG_DETAILS Details
    )
{
    PCTSTR key;
    BOOL b = FALSE;

    if ((!Details) || (!Details->DetailsSize)) {
        return TRUE;
    }

    key = JoinText (S_DETAILS_PREFIX, DecoratedObject);

    if (key) {

        b = (MemDbSetUnorderedBlob (key, 0, Details->DetailsData, Details->DetailsSize) != 0);

        FreeText (key);
    }

    return b;
}

BOOL
pOtAddFileToImage (
    IN      PCTSTR FileName,
    IN      PCTSTR StoredName,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle
    )
{
    return CompressAddFileToHandle (FileName, StoredName, CompressedHandle);
}

BOOL
pOtSaveContentInFile (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedFileName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content,
    IN OUT  PCOMPRESS_HANDLE CompressedHandle    OPTIONAL
    )
{
    BOOL result = FALSE;
    PCTSTR destPath = NULL;
    DWORD attributes = INVALID_ATTRIBUTES;

    MYASSERT (Content->ContentInFile);
    if (!Content->ContentInFile) {
        return FALSE;
    }

    //
    // Use the CopyFile API to move the file from local to storage.
    //

    __try {
        if (Content && (Content->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) && Content->Details.DetailsData) {
            attributes = ((PWIN32_FIND_DATAW)Content->Details.DetailsData)->dwFileAttributes;
        }
        if ((attributes != INVALID_ATTRIBUTES) && (attributes & FILE_ATTRIBUTE_DIRECTORY)) {

            // this must be a directory, let's just write the key

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

        } else {

            //
            // Get a temp file, assemble the src path, copy the file
            //

            destPath = pOpaqueAllocStorageFileName (NULL);
            if (!destPath) {
                __leave;
            }

            if (CompressedHandle) {
                if (!pOtAddFileToImage (Content->FileContent.ContentPath, GetFileNameFromPath (destPath), CompressedHandle)) {
                    __leave;
                }
            } else {
                if (!CopyFile (Content->FileContent.ContentPath, destPath, FALSE)) {
                    __leave;
                }
            }

            //
            // Keep track of where the file went
            //

            if (!MemDbSetValue (DecoratedObject, TRFLAG_FILE)) {
                __leave;
            }

            if (!MemDbAddSingleLinkage (DecoratedObject, GetFileNameFromPath (destPath), 0)) {
                __leave;
            }
        }

        //
        // Save details
        //

        result = pOpaqueSaveDetails (DecoratedObject, &(Content->Details));

    }
    __finally {
        pFreeStorageFileName (destPath);
        INVALID_POINTER (destPath);
    }

    return result;
}

BOOL
pOtSaveContentInMemory (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR EncodedObjectName,
    IN      PCTSTR DecoratedObject,
    IN      PMIG_CONTENT Content
    )
{
    BOOL result = FALSE;

    MYASSERT (!Content->ContentInFile);
    if (Content->ContentInFile) {
        return FALSE;
    }

    MemDbSetValue (DecoratedObject, TRFLAG_MEMORY);

    if (Content->MemoryContent.ContentBytes && Content->MemoryContent.ContentSize) {

        MemDbSetUnorderedBlob (
            DecoratedObject,
            0,
            Content->MemoryContent.ContentBytes,
            Content->MemoryContent.ContentSize
            );
    }

    result = pOpaqueSaveDetails (DecoratedObject, &(Content->Details));

    return result;
}

PCTSTR
pOpaqueBuildDecoratedObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName
    )
{
    PCTSTR typeStr;

    typeStr = IsmGetObjectTypeName (ObjectTypeId);
    if (!typeStr) {
        return NULL;
    }

    return JoinPaths (typeStr, ObjectName);
}

VOID
pOtDestroyDecoratedObject (
    IN      PCTSTR String
    )
{
    FreePathString (String);
}

BOOL
pOtSaveAllState (
    IN      BOOL Compressed
    )
{
    MIG_APPINFO appInfo;
    MIG_CONTENT value;
    PMIG_CONTENT convValue;
    ULONGLONG size;
    MIG_OBJECTWITHATTRIBUTE_ENUM objEnum;
    PCTSTR ourDbFile = NULL;
    PCTSTR decoratedObject = NULL;
    ULONGLONG bytesSaved = 0;
    UINT lastTick = GetTickCount();
    TCHAR text[64];
    UINT fraction;
    COMPRESS_HANDLE compressedHandle;
    INT_PTR appReply;
    BOOL okSave = FALSE;
    TRANSCOPY_ERROR transCopyError;
    ERRUSER_EXTRADATA extraData;
    BOOL result = FALSE;

    __try {

        ZeroMemory (&compressedHandle, sizeof (COMPRESS_HANDLE));

        if (Compressed) {
            g_TransportTempPath = pOtCreateTemporaryDir ();

            if (!g_TransportTempPath) {
                extraData.Error = ERRUSER_ERROR_CANTCREATETEMPDIR;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }

            if (!CompressCreateHandle (g_TransportPath, S_TRANSPORT_IMG_FILE, 1, 0, &compressedHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        //
        // Enumerate all objects with "save" attribute
        //

        if (IsmEnumFirstPersistentObject (&objEnum)) {
            do {
                //
                // For each object to be saved, do the appropriate
                // data copy action
                //

                okSave = FALSE;
                while (!okSave) {

                    if (!IsmAcquireObjectEx (
                            objEnum.ObjectTypeId,
                            objEnum.ObjectName,
                            &value,
                            CONTENTTYPE_ANY,
                            0
                            )) {

                        transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                        transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                        transCopyError.Error = GetLastError ();

                        if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                            appReply = APPRESPONSE_IGNORE;
                        } else {
                            appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                            if ((appReply == APPRESPONSE_NONE) ||
                                (appReply == APPRESPONSE_FAIL)
                                ) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                IsmReleaseMemory (transCopyError.ObjectName);
                                extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                extraData.ObjectName = objEnum.ObjectName;
                                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                IsmAbortPersistentObjectEnum (&objEnum);
                                __leave;
                            }
                        }
                        if (appReply == APPRESPONSE_IGNORE) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                            IsmReleaseMemory (transCopyError.ObjectName);
                            extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                            extraData.ErrorArea = ERRUSER_AREA_SAVE;
                            extraData.ObjectTypeId = objEnum.ObjectTypeId;
                            extraData.ObjectName = objEnum.ObjectName;
                            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                            break;
                        }
                        IsmReleaseMemory (transCopyError.ObjectName);
                        continue;
                    }
                    okSave = TRUE;
                }

                if (okSave) {

#ifdef UNICODE
                    convValue = &value;
#else
                    // now let's convert this object content to UNICODE
                    convValue = IsmConvertObjectContentToUnicode (objEnum.ObjectTypeId, objEnum.ObjectName, &value);
                    if (!convValue) {
                        convValue = &value;
                    }
#endif
                    decoratedObject = pOpaqueBuildDecoratedObject (objEnum.ObjectTypeId, objEnum.ObjectName);

                    ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                    appInfo.Phase = MIG_TRANSPORT_PHASE;
                    appInfo.SubPhase = SUBPHASE_COMPRESSING;
                    appInfo.ObjectTypeId = (objEnum.ObjectTypeId & (~PLATFORM_MASK));
                    appInfo.ObjectName = objEnum.ObjectName;
                    IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

                    if (convValue->ContentInFile) {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pOtSaveContentInFile (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue, &compressedHandle)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->FileContent.ContentSize;
                    } else {
                        okSave = FALSE;
                        while (!okSave) {
                            if (!pOtSaveContentInMemory (objEnum.ObjectTypeId, objEnum.ObjectName, decoratedObject, convValue)) {
                                if (GetLastError () == ERROR_DISK_FULL) {
                                    // we just failed because we don't have enough space on the destination
                                    // path. Let's tell that to the user
                                    extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = 0;
                                    extraData.ObjectName = NULL;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                    __leave;
                                }

                                transCopyError.ObjectType = IsmGetObjectTypeName (objEnum.ObjectTypeId);
                                transCopyError.ObjectName = IsmGetNativeObjectName (objEnum.ObjectTypeId, objEnum.ObjectName);
                                transCopyError.Error = GetLastError ();

                                if (IsmIsNonCriticalObject (objEnum.ObjectTypeId, objEnum.ObjectName)) {
                                    appReply = APPRESPONSE_IGNORE;
                                } else {
                                    appReply = IsmSendMessageToApp (TRANSPORTMESSAGE_SRC_COPY_ERROR, (ULONG_PTR)&transCopyError);
                                    if ((appReply == APPRESPONSE_NONE) ||
                                        (appReply == APPRESPONSE_FAIL)
                                        ) {
                                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_COPYSOURCE, transCopyError.ObjectName));
                                        IsmReleaseMemory (transCopyError.ObjectName);
                                        extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                        extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                        extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                        extraData.ObjectName = objEnum.ObjectName;
                                        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                                        IsmAbortPersistentObjectEnum (&objEnum);
                                        __leave;
                                    }
                                }
                                if (appReply == APPRESPONSE_IGNORE) {
                                    LOG ((LOG_WARNING, (PCSTR) MSG_IGNORE_COPYSOURCE, transCopyError.ObjectName));
                                    IsmReleaseMemory (transCopyError.ObjectName);
                                    extraData.Error = ERRUSER_ERROR_CANTSAVEOBJECT;
                                    extraData.ErrorArea = ERRUSER_AREA_SAVE;
                                    extraData.ObjectTypeId = objEnum.ObjectTypeId;
                                    extraData.ObjectName = objEnum.ObjectName;
                                    IsmSendMessageToApp (MODULEMESSAGE_DISPLAYWARNING, (ULONG_PTR)(&extraData));
                                    break;
                                }
                                IsmReleaseMemory (transCopyError.ObjectName);
                                continue;
                            }
                            okSave = TRUE;
                        }
                        size = convValue->MemoryContent.ContentSize;
                    }

#ifndef UNICODE
                    if (convValue != (&value)) {
                        IsmFreeConvertedObjectContent (objEnum.ObjectTypeId, convValue);
                    }
#endif
                    IsmReleaseObject (&value);

                    pOtDestroyDecoratedObject (decoratedObject);
                    decoratedObject = NULL;
                }

                IsmTickProgressBar (g_PersistentSlice, 1);

                if (IsmCheckCancel()) {
                    __leave;
                }

                //
                // Send bytes saved to app every 3 seconds
                //

                bytesSaved += size;

                if (GetTickCount() - lastTick > 3000) {

                    if (bytesSaved < 1048576) {
                        wsprintf (text, TEXT("Saved: %u K"), (UINT) (bytesSaved / 1024));
                    } else if (bytesSaved < 8388608) {
                        fraction = (UINT) (bytesSaved / 10485);
                        wsprintf (text, TEXT("Saved: %u.%02u M"), fraction / 100, fraction % 100);
                    } else if (bytesSaved < 1073741824) {
                        wsprintf (text, TEXT("Saved: %u M"), (UINT) (bytesSaved / 1048576));
                    } else {
                        fraction = (UINT) (bytesSaved / 10737418);
                        wsprintf (text, TEXT("Saved: %u.%02u G"), fraction / 100, fraction % 100);
                    }

                    IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, (ULONG_PTR) text);

                    lastTick = GetTickCount();
                }

            } while (IsmEnumNextPersistentObject (&objEnum));
        }

        if (IsmCheckCancel()) {
            __leave;
        }

        ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
        appInfo.Phase = MIG_TRANSPORT_PHASE;
        appInfo.SubPhase = SUBPHASE_FINISHING;
        IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR)(&appInfo));

        if (Compressed) {
            ourDbFile = JoinPaths (g_TransportTempPath, S_TRANSPORT_DAT_FILE);
        } else {
            ourDbFile = pOpaqueAllocStorageFileName (S_TRANSPORT_DAT_FILE);
            if (!ourDbFile) {
                extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }
        }

        if (!MemDbSave (ourDbFile)) {
            extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
            extraData.ErrorArea = ERRUSER_AREA_SAVE;
            extraData.ObjectTypeId = 0;
            extraData.ObjectName = NULL;
            IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
            __leave;
        }

        IsmTickProgressBar (g_DatabaseSlice, 1);

        if (Compressed) {
            if (IsmCheckCancel()) {
                __leave;
            }

            if (!pOtAddFileToImage (ourDbFile, S_TRANSPORT_DAT_FILE, &compressedHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTSAVEINTERNALDATA;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }

            IsmTickProgressBar (g_DatabaseSlice, 1);

            if (IsmCheckCancel()) {
                __leave;
            }

            if (!CompressFlushAndCloseHandle (&compressedHandle)) {
                extraData.Error = ERRUSER_ERROR_CANTCREATECABFILE;
                extraData.ErrorArea = ERRUSER_AREA_SAVE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));
                __leave;
            }

            IsmTickProgressBar (g_DatabaseSlice, 1);

            if (IsmCheckCancel()) {
                __leave;
            }
        }

        IsmSendMessageToApp (TRANSPORTMESSAGE_SIZE_SAVED, 0);
        result = TRUE;

    }
    __finally {
        PushError ();
        CompressCleanupHandle (&compressedHandle);

        pFreeStorageFileName (ourDbFile);
        INVALID_POINTER (ourDbFile);

        pOtDestroyDecoratedObject (decoratedObject);
        INVALID_POINTER (decoratedObject);

        if (g_OtCompressData && g_TransportTempPath) {
            pOtCleanUpTempDir ();
        }
        PopError ();
    }

    return result;
}

BOOL
WINAPI
OpaqueTransportAcquireObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,                 CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    UINT value;
    PCBYTE memValue;
    UINT memValueSize;
    PCTSTR fileValue = NULL;
    PCTSTR newFileValue = NULL;
    BOOL valueInFile;
    KEYHANDLE keyHandle;
    PALLOCSTATE allocState;
    PCTSTR detailsKey = NULL;
    PBYTE details;
    UINT detailsSize;
    PCTSTR sourceFile;
    PCTSTR decoratedObject = NULL;
    HANDLE fileHandle;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    MYASSERT (g_Platform == PLATFORM_DESTINATION);
    MYASSERT ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE);

    decoratedObject = pOpaqueBuildDecoratedObject (ObjectTypeId, ObjectName);

    allocState = (PALLOCSTATE) MemAllocZeroed (sizeof (ALLOCSTATE));

    if (MemDbGetValue (decoratedObject, &value)) {
        if (value == TRFLAG_FILE) {
            valueInFile = TRUE;
            keyHandle = MemDbGetSingleLinkage (decoratedObject, 0, 0);
            if (keyHandle) {
                fileValue = MemDbGetKeyFromHandle (keyHandle, 0);
                newFileValue = pOpaqueGetNewFileName (fileValue);
                result = fileValue != NULL;
            } else {
                fileValue = NULL;
                result = TRUE;
            }
        } else if (value == TRFLAG_MEMORY) {
            valueInFile = FALSE;
            memValueSize = 0;
            memValue = MemDbGetUnorderedBlob (decoratedObject, 0, &memValueSize);
            result = TRUE;
        } else {
            LOG ((LOG_ERROR, (PCSTR) MSG_UNSUPPORTED_DATA, value));
            SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        }
        if (result) {
            result = FALSE;

            if (valueInFile) {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_FILE) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as a file and it's wanted as a file
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = TRUE;
                    if (fileValue) {
                        ObjectContent->FileContent.ContentPath = JoinPaths (pGetRealTransportPath (), newFileValue?newFileValue:fileValue);
                        ObjectContent->FileContent.ContentSize = BfGetFileSize (ObjectContent->FileContent.ContentPath);
                    } else {
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                    result = TRUE;
                } else {
                    // this is stored as a file and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    if (fileValue) {
                        sourceFile = JoinPaths (pGetRealTransportPath (), newFileValue?newFileValue:fileValue);
                        ObjectContent->MemoryContent.ContentSize = (UINT) BfGetFileSize (sourceFile);
                        ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                        sourceFile,
                                                                        &allocState->FileHandle,
                                                                        &allocState->MapHandle
                                                                        );
                        FreePathString (sourceFile);
                        result = (ObjectContent->MemoryContent.ContentBytes != NULL);
                    } else {
                        ObjectContent->MemoryContent.ContentSize = 0;
                        ObjectContent->MemoryContent.ContentBytes = NULL;
                        result = TRUE;
                    }
                }
                if (newFileValue) {
                    FreePathString (newFileValue);
                    newFileValue = NULL;
                }
                if (fileValue) {
                    MemDbReleaseMemory (fileValue);
                    fileValue = NULL;
                }
            } else {
                if ((ContentType == CONTENTTYPE_ANY) ||
                    (ContentType == CONTENTTYPE_MEMORY) ||
                    (ContentType == CONTENTTYPE_DETAILS_ONLY)
                    ) {
                    // this is stored as memory and it's wanted as memory
                    ObjectContent->ObjectTypeId = ObjectTypeId;
                    ObjectContent->ContentInFile = FALSE;
                    ObjectContent->MemoryContent.ContentSize = memValueSize;
                    ObjectContent->MemoryContent.ContentBytes = memValue;
                    result = TRUE;
                } else {
                    // this is stored as memory and it's wanted as a file
                    if (memValue) {
                        if (IsmGetTempFile (allocState->TempFile, ARRAYSIZE(allocState->TempFile))) {
                            fileHandle = BfCreateFile (allocState->TempFile);
                            if (fileHandle) {
                                if (BfWriteFile (fileHandle, memValue, memValueSize)) {
                                    ObjectContent->ObjectTypeId = ObjectTypeId;
                                    ObjectContent->ContentInFile = TRUE;
                                    ObjectContent->FileContent.ContentSize = memValueSize;
                                    ObjectContent->FileContent.ContentPath = DuplicatePathString (allocState->TempFile, 0);
                                    result = TRUE;
                                }
                                CloseHandle (fileHandle);
                            }
                        }
                        MemDbReleaseMemory (memValue);
                    } else {
                        ObjectContent->ObjectTypeId = ObjectTypeId;
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentSize = 0;
                        ObjectContent->FileContent.ContentPath = NULL;
                    }
                }
            }
        }
    } else {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
    }

    if (result) {
        //
        // Fill the details
        //

        detailsKey = JoinText (S_DETAILS_PREFIX, decoratedObject);

        details = MemDbGetUnorderedBlob (detailsKey, 0, &detailsSize);

        if (!details) {
            detailsSize = 0;
        }

        allocState->DetailsPtr = details;

        ObjectContent->Details.DetailsSize = detailsSize;
        ObjectContent->Details.DetailsData = details;

        FreeText (detailsKey);

        ObjectContent->TransHandle = allocState;
    }

    if (!result) {
        FreeAlloc (allocState);
    }

    FreePathString (decoratedObject);

    return result;
}

BOOL
WINAPI
OpaqueTransportReleaseObject (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PALLOCSTATE allocState;

    MYASSERT (g_Platform == PLATFORM_DESTINATION);

    allocState = (PALLOCSTATE) ObjectContent->TransHandle;

    if (ObjectContent->ContentInFile) {
        FreePathString (ObjectContent->FileContent.ContentPath);
        if (allocState && allocState->TempFile[0]) {
            DeleteFile (allocState->TempFile);
        }
    } else {
        if (allocState && allocState->FileHandle && allocState->MapHandle) {
            UnmapFile (
                ObjectContent->MemoryContent.ContentBytes,
                allocState->MapHandle,
                allocState->FileHandle
                );
        } else {
            MemDbReleaseMemory (ObjectContent->MemoryContent.ContentBytes);
        }
    }

    if (allocState && allocState->DetailsPtr) {
        MemDbReleaseMemory (allocState->DetailsPtr);
    }

    FreeAlloc (allocState);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\app.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    app.c

Abstract:

    Implements a set of functions to manage data for an application section.

Author:

    Jim Schmidt (jimschm) 05-Jun-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

#define MAX_EXPANDED_STRING         4096

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PMHANDLE g_AppPool;
extern BOOL g_VcmMode;  // in sgmqueue.c
GROWLIST g_SectionStack = INIT_GROWLIST;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pParseAppEnvSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    );

//
// Macro expansion definition
//

// None

//
// Code
//


VOID
InitAppModule (
    VOID
    )
{
    g_AppPool = PmCreateNamedPool ("v1 App");
}


VOID
TerminateAppModule (
    VOID
    )
{
    PmDestroyPool (g_AppPool);
    INVALID_POINTER (g_AppPool);
}


UINT
pSafeTcharCount (
    IN      PCTSTR String
    )
{
    if (String) {
        return TcharCount (String);
    }

    return 0;
}


PCTSTR
GetMostSpecificSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR BaseSection
    )
{
    PTSTR specificSection;
    MIG_OSVERSIONINFO versionInfo;
    UINT tchars;

    if (!IsmGetOsVersionInfo (Platform, &versionInfo)) {
        return NULL;
    }

    tchars = TcharCount (BaseSection) + 1;
    tchars += pSafeTcharCount (versionInfo.OsTypeName) + 1;
    tchars += pSafeTcharCount (versionInfo.OsMajorVersionName) + 1;
    tchars += pSafeTcharCount (versionInfo.OsMinorVersionName) + 1;

    specificSection = AllocText (tchars);

    if (versionInfo.OsTypeName &&
        versionInfo.OsMajorVersionName &&
        versionInfo.OsMinorVersionName
        ) {
        wsprintf (
            specificSection,
            TEXT("%s.%s.%s.%s"),
            BaseSection,
            versionInfo.OsTypeName,
            versionInfo.OsMajorVersionName,
            versionInfo.OsMinorVersionName
            );

        if (InfFindFirstLine (InfFile, specificSection, NULL, InfStruct)) {
            return specificSection;
        }
    }

    if (versionInfo.OsTypeName &&
        versionInfo.OsMajorVersionName
        ) {
        wsprintf (
            specificSection,
            TEXT("%s.%s.%s"),
            BaseSection,
            versionInfo.OsTypeName,
            versionInfo.OsMajorVersionName
            );

        if (InfFindFirstLine (InfFile, specificSection, NULL, InfStruct)) {
            return specificSection;
        }
    }

    if (versionInfo.OsTypeName) {
        wsprintf (
            specificSection,
            TEXT("%s.%s"),
            BaseSection,
            versionInfo.OsTypeName
            );

        if (InfFindFirstLine (InfFile, specificSection, NULL, InfStruct)) {
            return specificSection;
        }
    }

    FreeText (specificSection);
    return NULL;
}


BOOL
pCheckForRecursion (
    IN      PCTSTR Section
    )
{
    UINT count;
    UINT u;


    count = GlGetSize (&g_SectionStack);
    for (u = 0 ; u < count ; u++) {
        if (StringIMatch (GlGetString (&g_SectionStack, u), Section)) {
            return TRUE;
        }
    }

    return FALSE;
}


VOID
pPushSection (
    IN      PCTSTR Section
    )
{
    GlAppendString (&g_SectionStack, Section);
}


VOID
pPopSection (
    IN      PCTSTR Section
    )
{
    UINT u;

    u = GlGetSize (&g_SectionStack);

    while (u > 0) {
        u--;

        if (StringIMatch (GlGetString (&g_SectionStack, u), Section)) {
            GlDeleteItem (&g_SectionStack, u);
            return;
        }
    }

    MYASSERT (FALSE);
}

UINT
pGetDisplayTypeFromString (
    IN      PCTSTR String
    )
{
    if (!String) {
        return 0;
    }

    if (StringIMatch (String, TEXT("EXT"))) {
        return COMPONENT_EXTENSION;
    }

    if (StringIMatch (String, TEXT("FILE"))) {
        return COMPONENT_FILE;
    }

    if (StringIMatch (String, TEXT("DIR"))) {
        return COMPONENT_FOLDER;
    }

    return 0;
}


BOOL
pAddFilesAndFoldersComponent (
    IN      PCTSTR ComponentString,         OPTIONAL
    IN      PCTSTR TypeString,
    IN      PCTSTR MultiSz,
    IN      UINT MasterGroup,
    IN OUT  PBOOL MarkAsPreferred
    )
{
    MULTISZ_ENUM e;
    TCHAR expandBuffer[MAX_PATH];
    UINT displayType;

    displayType = pGetDisplayTypeFromString (TypeString);
    if (!displayType) {
        LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_FNF_TYPE, TypeString));
        return TRUE;
    }

    if (EnumFirstMultiSz (&e, MultiSz)) {
        do {

            //
            // Expand e.CurrentString
            //

            MappingSearchAndReplaceEx (
                g_EnvMap,
                e.CurrentString,
                expandBuffer,
                0,
                NULL,
                ARRAYSIZE(expandBuffer),
                0,
                NULL,
                NULL
                );

            //
            // Add component
            //

            IsmAddComponentAlias (
                ComponentString,
                MasterGroup,
                expandBuffer,
                displayType,
                FALSE
                );

            if (ComponentString && *MarkAsPreferred) {
                IsmSelectPreferredAlias (ComponentString, expandBuffer, displayType);
                *MarkAsPreferred = FALSE;
            }


        } while (EnumNextMultiSz (&e));

    } else {
        LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_FNF_SPEC, TypeString));
    }

    return TRUE;
}


BOOL
pAddFilesAndFoldersSection (
    IN      HINF InfFile,
    IN      PCTSTR Section,
    IN      UINT MasterGroup,
    IN      BOOL GroupAllUnderSection,
    IN      PBOOL MarkAsPreferred
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR type;
    PCTSTR multiSz;
    BOOL result = TRUE;
    PCTSTR decoratedSection = NULL;

    if (GroupAllUnderSection) {
        decoratedSection = JoinText (TEXT("$"), Section);
    }

    if (InfFindFirstLine (InfFile, Section, NULL, &is)) {
        do {

            InfResetInfStruct (&is);

            type = InfGetStringField (&is, 1);
            multiSz = InfGetMultiSzField (&is, 2);

            result = pAddFilesAndFoldersComponent (
                            decoratedSection,
                            type,
                            multiSz,
                            MasterGroup,
                            MarkAsPreferred
                            );

        } while (result && InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);
    FreeText (decoratedSection);

    if (!result) {
        LOG ((LOG_ERROR, (PCSTR) MSG_SECTION_ERROR, Section));
    }

    return result;
}


BOOL
pAddFilesAndFoldersComponentOrSection (
    IN      HINF InfFile,
    IN      PCTSTR ComponentString,         OPTIONAL
    IN      PCTSTR TypeString,
    IN      PCTSTR MultiSz,
    IN      UINT MasterGroup,
    IN      PBOOL MarkAsPreferred
    )
{
    MULTISZ_ENUM e;
    BOOL result = TRUE;

    if (StringIMatch (TypeString, TEXT("Section"))) {
        if (EnumFirstMultiSz (&e, MultiSz)) {
            do {
                result = pAddFilesAndFoldersSection (InfFile, e.CurrentString, MasterGroup, TRUE, MarkAsPreferred);

            } while (result && EnumNextMultiSz (&e));
        }
    } else {
        result = pAddFilesAndFoldersComponent (ComponentString, TypeString, MultiSz, MasterGroup, MarkAsPreferred);
    }

    return result;
}


BOOL
AddAppSpecificEnvVar (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR AppTag,
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableData             OPTIONAL
    )
{
    PTSTR buffer;
    PTSTR p;
    PTSTR q;
    BOOL ignoreLastPercent = FALSE;
    PCTSTR undefText;

    //
    // Verify VariableName is legal
    //

    if (_tcsnextc (VariableName) == TEXT('%')) {
        VariableName++;
        ignoreLastPercent = TRUE;
    }

    if (*VariableName == 0) {
        LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_APP_ENV_VAR));
        return FALSE;
    }

    //
    // Transfer VariableName into %<VariableName>%
    //

    buffer = AllocText (SizeOfString (VariableName) + 2);
    MYASSERT (buffer);
    if (!buffer) {
        return FALSE;
    }

    p = buffer;

    *p++ = TEXT('%');
    *p = 0;
    p = StringCat (p, VariableName);

    if (ignoreLastPercent) {
        q = _tcsdec (buffer, p);
        if (q) {
            if (_tcsnextc (q) == TEXT('%')) {
                p = q;
            }
        }
    }

    *p++ = TEXT('%');
    *p = 0;

    //
    // Add %<VariableName>% -> VariableData to string mapping table
    //

    if (VariableData) {
        // let's check to see if this was already defined. If yes, we will log a warning
        // but we will still set the env variable
        if (IsmGetEnvironmentString (Platform, S_SYSENVVAR_GROUP, VariableName, NULL, 0, NULL)) {

            LOG ((LOG_INFORMATION, (PCSTR) MSG_DUPLICATE_ENV_VAR, buffer));

        }

        if (Platform == PLATFORM_SOURCE) {

            IsmSetEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, VariableName, VariableData);
            AddStringMappingPair (g_EnvMap, buffer, VariableData);

        } else {

            IsmSetEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, VariableName, VariableData);
            AddRemappingEnvVar (g_DestEnvMap, g_FileNodeFilterMap, NULL, VariableName, VariableData);

        }

    } else {
        // let's check to see if this was previously defined
        if (!IsmGetEnvironmentString (Platform, S_SYSENVVAR_GROUP, VariableName, NULL, 0, NULL)) {

            LOG ((LOG_INFORMATION, (PCSTR) MSG_UNDEF_APP_VAR, buffer));
            undefText = JoinTextEx (NULL, TEXT("--> "), TEXT(" <--"), buffer, 0, NULL);
            AddStringMappingPair (g_UndefMap, buffer, undefText);
            FreeText (undefText);

        }
    }

    FreeText (buffer);
    return TRUE;
}


BOOL
AppCheckAndLogUndefVariables (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR UnexpandedString
    )
{
    TCHAR buffer[MAX_TCHAR_PATH * 4];
    PMAPSTRUCT mapArray[1];
    UINT mapCount = 0;
    BOOL updated;

    mapArray[mapCount] = g_UndefMap;

    updated = MappingMultiTableSearchAndReplaceEx (
                    mapArray,
                    mapCount + 1,
                    UnexpandedString,
                    buffer,
                    0,
                    NULL,
                    ARRAYSIZE(buffer),
                    0,
                    NULL,
                    NULL
                    );

    if (updated) {
        if (buffer [0]) {
            LOG ((LOG_INFORMATION, (PCSTR) MSG_UNDEF_BUT_GOOD_VAR, buffer));
        }
    } else {
        if (buffer [0]) {
            LOG ((LOG_INFORMATION, (PCSTR) MSG_ENV_VAR_COULD_BE_BAD, buffer));
        }
    }

    return updated;
}



BOOL
AppSearchAndReplace (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR UnexpandedString,
    OUT     PTSTR ExpandedString,
    IN      UINT ExpandedStringTchars
    )
{
    PMAPSTRUCT mapArray[1];
    UINT mapCount = 0;
    BOOL updated;
    PCTSTR newString = NULL;
    PCTSTR percent;
    PCTSTR endPercent;
    PCTSTR equals;
    BOOL result = TRUE;

    //
    // Let's expand the incoming string by using the source machine defined environment variables.
    //
    newString = IsmExpandEnvironmentString (Platform, S_SYSENVVAR_GROUP, UnexpandedString, NULL);

    if (Platform == PLATFORM_SOURCE) {
        mapArray[mapCount] = g_EnvMap;
    } else {
        MYASSERT (Platform == PLATFORM_DESTINATION);
        mapArray[mapCount] = g_DestEnvMap;
    }

    updated = MappingMultiTableSearchAndReplaceEx (
                    mapArray,
                    mapCount + 1,
                    newString,
                    ExpandedString,
                    0,
                    NULL,
                    ExpandedStringTchars,
                    0,
                    NULL,
                    NULL
                    );

    if (newString) {
        IsmReleaseMemory (newString);
        newString = NULL;
    }

    //
    // Alert the user to an unexpanded environment variable
    //

    if (!updated) {
        percent = ExpandedString;

        do {
            percent = _tcschr (percent, TEXT('%'));

            if (percent) {
                percent = _tcsinc (percent);
                endPercent = _tcschr (percent, TEXT('%'));

                if (endPercent > percent) {

                    equals = percent;
                    while (equals < endPercent) {
                        if (_tcsnextc (equals) == TEXT('=')) {
                            break;
                        }

                        equals = _tcsinc (equals);
                    }

                    if (equals >= endPercent) {
                        result = FALSE;
                        break;
                    }
                }
            }

        } while (percent && endPercent);
    }

    return result;
}

BOOL
pGetDataFromObjectSpec (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR InfObjectType,
    IN      PCTSTR InfObjectName,
    IN      PCTSTR ArgumentMultiSz,         OPTIONAL
    OUT     PTSTR OutContentBuffer,         OPTIONAL
    IN      UINT OutContentBufferTchars,
    OUT     PBOOL TestResults               OPTIONAL
    )
{
    ATTRIB_DATA attribData;
    BOOL test;

    MYASSERT (Application);
    MYASSERT (InfObjectType);
    MYASSERT (InfObjectName);

    ZeroMemory (&attribData, sizeof (ATTRIB_DATA));
    attribData.Platform = Platform;
    attribData.ScriptSpecifiedType = InfObjectType;
    attribData.ScriptSpecifiedObject = InfObjectName;
    attribData.ApplicationName = Application;

    if (AllocScriptType (&attribData)) {
        if (g_VcmMode && attribData.ObjectName) {
            if (IsmDoesObjectExist (attribData.ObjectTypeId, attribData.ObjectName)) {
                IsmMakePersistentObject (attribData.ObjectTypeId, attribData.ObjectName);
            }
        }

        if (attribData.ReturnString) {
            if (OutContentBuffer) {
                StringCopyTcharCount (
                    OutContentBuffer,
                    attribData.ReturnString,
                    OutContentBufferTchars
                    );
            }
        }
        if (TestResults) {
            if (ArgumentMultiSz) {
                test = TestAttributes (g_AppPool, ArgumentMultiSz, &attribData);
            } else {
                test = (attribData.ReturnString != NULL);
            }

            *TestResults = test;
        }
        FreeScriptType (&attribData);
    } else {
        return FALSE;
    }
    return TRUE;
}

VOID
pAddPlatformEnvVar (
    IN      HINF InfFile,
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR Section,
    IN      PCTSTR Variable,
    IN      PCTSTR Type,
    IN      PCTSTR Data,
    IN      PCTSTR ArgMultiSz,
    IN      PINFSTRUCT InfStruct
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTSTRINGHANDLE objectNameLong;
    PCTSTR nativeNameLong;
    BOOL exists;
    BOOL validString;
    PCTSTR p;
    PCTSTR end;
    TCHAR variableData[MAX_PATH + 1];
    PCTSTR varDataLong = NULL;

    ZeroMemory (&variableData, sizeof (variableData));

    //
    // Variable data is specified in the object represented by <data>
    //

    if (!pGetDataFromObjectSpec (
            Platform,
            Application,
            Type,
            Data,
            ArgMultiSz,
            variableData,
            ARRAYSIZE(variableData) - 1,
            &exists
            )) {

        switch (GetLastError()) {

        case ERROR_INVALID_DATA:
            LOG ((
                LOG_WARNING,
                (PCSTR) MSG_DETECT_DATA_OBJECT_IS_BAD,
                Data,
                Variable
                ));
            InfLogContext (LOG_WARNING, InfFile, InfStruct);
            break;

        case ERROR_INVALID_DATATYPE:
            LOG ((
                LOG_ERROR,
                (PCSTR) MSG_DETECT_DATA_TYPE_IS_BAD,
                Type,
                Variable
                ));
            InfLogContext (LOG_ERROR, InfFile, InfStruct);
            break;
        }
    } else {
        validString = FALSE;

        if (exists) {

            p = variableData;
            end = variableData + MAX_PATH;

            while (p < end) {
                if (_tcsnextc (p) < 32) {
                    break;
                }

                p = _tcsinc (p);
            }

            if (*p == 0 && p < end && p > variableData) {
                validString = TRUE;
            }
        }

        if (validString) {
            varDataLong = variableData;
            if (IsValidFileSpec (variableData)) {
                // let's get the long file name for this. We need to call
                // ISM for this because we might be on the wrong platform
                // Unfortunately we don't know if this is a directory or
                // a file. We'll just assume it's a directory. ISM will
                // work fine either way.
                objectName = IsmCreateObjectHandle (variableData, NULL);
                if (objectName) {
                    objectNameLong = IsmGetLongName (MIG_FILE_TYPE|Platform, objectName);
                    if (objectNameLong) {
                        nativeNameLong = IsmGetNativeObjectName (MIG_FILE_TYPE|Platform, objectNameLong);
                        if (nativeNameLong) {
                            varDataLong = DuplicatePathString (nativeNameLong, 0);
                            IsmReleaseMemory (nativeNameLong);
                        }
                        IsmDestroyObjectHandle (objectNameLong);
                    }
                    IsmDestroyObjectHandle (objectName);
                }
            }
        }

        if (!validString && exists) {
            LOG ((LOG_INFORMATION, (PCSTR) MSG_DATA_IS_NOT_A_STRING, Variable));
        } else {
            LOG_IF ((
                validString,
                LOG_INFORMATION,
                (PCSTR) MSG_APP_ENV_DEF_INFO,
                Variable,
                Type,
                Data,
                variableData
                ));

            LOG_IF ((
                !validString,
                LOG_INFORMATION,
                (PCSTR) MSG_NUL_APP_ENV_DEF_INFO,
                Variable,
                Type,
                Data
                ));

            AddAppSpecificEnvVar (
                Platform,
                Application,
                Variable,
                validString ? varDataLong : NULL
                );

        }

        if (varDataLong && (varDataLong != variableData)) {
            FreePathString (varDataLong);
            varDataLong = NULL;
        }
    }
}


PCTSTR
pProcessArgEnvironmentVars (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR Args,
    IN      BOOL MultiSz,
    OUT     PGROWBUFFER UpdatedData
    )
{
    MULTISZ_ENUM e;
    TCHAR buffer[MAX_EXPANDED_STRING];

    UpdatedData->End = 0;

    if (MultiSz) {
        if (EnumFirstMultiSz (&e, Args)) {

            do {

                AppSearchAndReplace (
                    Platform,
                    Application,
                    e.CurrentString,
                    buffer,
                    MAX_EXPANDED_STRING
                    );

                GbMultiSzAppend (UpdatedData, buffer);

            } while (EnumNextMultiSz (&e));
        }
    } else {
        AppSearchAndReplace (
            Platform,
            Application,
            Args,
            buffer,
            MAX_EXPANDED_STRING
            );

        GbMultiSzAppend (UpdatedData, buffer);
    }

    return (PCTSTR) UpdatedData->Buf;
}


BOOL
pParseAppEnvSectionWorker (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    BOOL result = FALSE;
    PCTSTR variable;
    PCTSTR type;
    PCTSTR data;
    PCTSTR args;
    PCTSTR updatedData;
    PCTSTR updatedArgs;
    PTSTR lastChar;
    GROWBUFFER dataBuf = INIT_GROWBUFFER;
    GROWBUFFER argBuf = INIT_GROWBUFFER;

    //
    // Section must not be on the stack
    //

    if (pCheckForRecursion (Section)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_ENV_SECTION_RECURSION, Section));
        // Assume success
        return TRUE;
    }

    //
    // Format is
    //
    // <variable> = <type>, <data> [, <arguments>]
    //
    // <type> specifies one of the supported parse types (see parse.c),
    //        or "Text" when <data> is arbitrary text
    //
    // <data> is specific to <type>
    //
    // <arguments> specify qualifiers.  If they evaluate to FALSE, then
    //             the variable is not set.
    //

    __try {
        if (InfFindFirstLine (InfFile, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (InfStruct);

                variable = InfGetStringField (InfStruct, 0);
                type = InfGetStringField (InfStruct, 1);

                if (variable && StringIMatch (variable, TEXT("ProcessSection"))) {
                    if (type && *type) {
                        pPushSection (Section);
                        result = pParseAppEnvSection (Platform, InfFile, Application, type);
                        pPopSection (Section);

                        if (!result) {
                            __leave;
                        }
                        continue;
                    }
                }

                data = InfGetStringField (InfStruct, 2);
                args = InfGetMultiSzField (InfStruct, 3);

                if (variable) {
                    //
                    // Remove %s from the variable name
                    //

                    if (_tcsnextc (variable) == TEXT('%')) {
                        lastChar = _tcsdec2 (variable, GetEndOfString (variable));

                        if (lastChar > variable && _tcsnextc (lastChar) == TEXT('%')) {
                            variable = _tcsinc (variable);
                            *lastChar = 0;
                        }
                    }
                }

                if (!variable || !(*variable) || !type || !(*type) || !data) {
                    LOG ((LOG_WARNING, (PCSTR) MSG_GARBAGE_LINE_IN_INF, Section));
                    InfLogContext (LOG_WARNING, InfFile, InfStruct);
                    continue;
                }

                //
                // Update all environment variables in data and args
                //

                updatedData = pProcessArgEnvironmentVars (
                                    Platform,
                                    Application,
                                    data,
                                    FALSE,
                                    &dataBuf
                                    );

                if (args && *args) {
                    updatedArgs = pProcessArgEnvironmentVars (
                                        Platform,
                                        Application,
                                        args,
                                        TRUE,
                                        &argBuf
                                        );
                } else {
                    updatedArgs = NULL;
                }

                //
                // Add the app-specific environment variables.  If we are
                // on the destination, add both a source and destination
                // value (as they might be different).
                //

                pAddPlatformEnvVar (
                    InfFile,
                    Platform,
                    Application,
                    Section,
                    variable,
                    type,
                    updatedData,
                    updatedArgs,
                    InfStruct
                    );

            } while (InfFindNextLine (InfStruct));
        }

        result = TRUE;

    }
    __finally {
        GbFree (&dataBuf);
        GbFree (&argBuf);
    }

    return result;
}


BOOL
pParseAppEnvSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;

    b = pParseAppEnvSectionWorker (Platform, &is, InfFile, Application, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (Platform, &is, InfFile, Section);
        if (osSpecificSection) {
            b = pParseAppEnvSectionWorker (Platform, &is, InfFile, Application, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);
    return b;
}


BOOL
pParseAppDetectSectionPart (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    BOOL result = TRUE;
    PCTSTR type;
    PCTSTR data;
    PCTSTR args;
    GROWBUFFER dataBuf = INIT_GROWBUFFER;
    GROWBUFFER argBuf = INIT_GROWBUFFER;
    PCTSTR updatedData;
    PCTSTR updatedArgs;
    PTSTR buffer;
    BOOL test;

    //
    // Section must not be on the stack
    //

    if (pCheckForRecursion (Section)) {
        LOG ((LOG_ERROR, (PCSTR) MSG_DETECT_SECTION_RECURSION, Section));
        // Assume successful detection
        return TRUE;
    }

    //
    // Format is
    //
    // <type>, <data> [, <arguments>]
    //
    // <type> specifies one of the supported parse types (see parse.c),
    //        and may include environment variables specified in the
    //        app's [App.Environment] section.
    //
    // <data> is specific to <type>.  If <data> begins with a !, then the
    //        existence of the object fails the detect test
    //
    // <arguments> specify qualifiers
    //

    __try {

        buffer = AllocText (MAX_EXPANDED_STRING);      // arbitrary big text buffer

        if (InfFindFirstLine (InfFile, Section, NULL, InfStruct)) {

            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (InfStruct);

                //
                // Obtain the line data
                //

                type = InfGetStringField (InfStruct, 0);

                if (type && StringIMatch (type, TEXT("ProcessSection"))) {
                    data = InfGetStringField (InfStruct, 1);
                    if (data && *data) {
                        pPushSection (Section);
                        result = ParseAppDetectSection (Platform, InfFile, Application, data);
                        pPopSection (Section);
                        continue;
                    }
                }

                type = InfGetStringField (InfStruct, 1);
                data = InfGetStringField (InfStruct, 2);
                args = InfGetMultiSzField (InfStruct, 3);

                if (!type || !data) {
                    LOG ((LOG_WARNING, (PCSTR) MSG_GARBAGE_LINE_IN_INF, Section));
                    InfLogContext (LOG_WARNING, InfFile, InfStruct);
                    continue;
                }

                //
                // Update all environment variables in data and args
                //

                updatedData = pProcessArgEnvironmentVars (
                                    PLATFORM_SOURCE,
                                    Application,
                                    data,
                                    FALSE,
                                    &dataBuf
                                    );

                if (args && *args) {
                    updatedArgs = pProcessArgEnvironmentVars (
                                        PLATFORM_SOURCE,
                                        Application,
                                        args,
                                        TRUE,
                                        &argBuf
                                        );
                } else {
                    updatedArgs = NULL;
                }

                //
                // Now try to obtain the data
                //

                if (pGetDataFromObjectSpec (
                        Platform,
                        Application,
                        type,
                        updatedData,
                        updatedArgs,
                        NULL,
                        0,
                        &test
                        )) {

                    if (test) {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_DETECT_INFO, type, updatedData));
                    } else {
                        LOG ((LOG_INFORMATION, (PCSTR) MSG_NOT_DETECT_INFO, type, updatedData));
                        result = FALSE;
                        break;
                    }
                } else {
                    result = FALSE;
                    break;
                }

            } while (result && InfFindNextLine (InfStruct));
        }
    }
    __finally {
        FreeText (buffer);
        GbFree (&dataBuf);
        GbFree (&argBuf);
    }

    return result;
}


BOOL
pParseOsAppDetectSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;

    b = pParseAppDetectSectionPart (Platform, InfStruct, InfFile, Application, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (Platform, InfStruct, InfFile, Section);
        if (osSpecificSection) {
            b = pParseAppDetectSectionPart (Platform, InfStruct, InfFile, Application, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    return b;
}


BOOL
ParseAppDetectSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    TCHAR number[32];
    PCTSTR orSection;
    UINT count;
    BOOL orSectionProcessed = FALSE;
    BOOL detected = FALSE;
    BOOL done = FALSE;

    //
    // Process all "or" sections
    //

    count = 0;

    do {

        count++;
        wsprintf (number, TEXT(".%u"), count);

        orSection = JoinText (Section, number);

        if (orSection) {

            if (InfFindFirstLine (InfFile, orSection, NULL, &is)) {

                orSectionProcessed = TRUE;

                if (pParseOsAppDetectSection (Platform, &is, InfFile, Application, orSection)) {
                    detected = TRUE;
                    done = TRUE;
                }

            } else {
                done = TRUE;
            }

            FreeText (orSection);
            INVALID_POINTER (orSection);

        } else {
            done = TRUE;
        }

    } while (!done);

    //
    // If no "or" sections, process Section itself
    //

    if (!orSectionProcessed) {

        detected = pParseOsAppDetectSection (Platform, &is, InfFile, Application, Section);
    }

    InfCleanUpInfStruct (&is);

    return detected;
}


BOOL
pDoesAppSectionExists (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;

    b = InfFindFirstLine (InfFile, Application, NULL, &is);

    if (!b) {
        osSpecificSection = GetMostSpecificSection (Platform, &is, InfFile, Application);

        if (osSpecificSection) {
            b = TRUE;
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);
    return b;
}

BOOL
pParseOneDestInstruction (
    IN      HINF InfHandle,
    IN      PCTSTR Type,
    IN      PCTSTR SectionMultiSz,
    IN      PINFSTRUCT InfStruct,
    IN      PCTSTR Application          OPTIONAL
    )
{
    MULTISZ_ENUM e;
    BOOL result = TRUE;

    //
    // First thing: look for nested sections
    //
    if (StringIMatch (Type, TEXT("ProcessSection"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {
            do {
                result = result & ParseOneApplication (
                                    PLATFORM_DESTINATION,
                                    InfHandle,
                                    Application,
                                    FALSE,
                                    0,
                                    e.CurrentString,
                                    NULL,
                                    NULL,
                                    NULL
                                    );
            } while (EnumNextMultiSz (&e));
        }
        return result;
    }

    return TRUE;
}

BOOL
pParseDestInfInstructionsWorker (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Application,     OPTIONAL
    IN      PCTSTR Section
    )
{
    PCTSTR type;
    PCTSTR sections;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    BOOL result = TRUE;

    if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
        do {

            if (IsmCheckCancel()) {
                result = FALSE;
                break;
            }

            InfResetInfStruct (InfStruct);

            type = InfGetStringField (InfStruct, 0);
            sections = InfGetMultiSzField (InfStruct, 1);

            if (!type || !sections) {
                LOG ((LOG_WARNING, (PCSTR) MSG_BAD_INF_LINE, Section));
                InfLogContext (LOG_WARNING, InfHandle, InfStruct);
                continue;
            }

            result = pParseOneDestInstruction (InfHandle, type, sections, InfStruct, Application);

        } while (result && InfFindNextLine (InfStruct));
    }

    InfCleanUpInfStruct (InfStruct);

    GbFree (&multiSz);

    return result;
}

BOOL
ParseDestInfInstructions (
    IN      HINF InfHandle,
    IN      PCTSTR Application,     OPTIONAL
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PTSTR instrSection;

    b = pParseDestInfInstructionsWorker (&is, InfHandle, Application, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (PLATFORM_SOURCE, &is, InfHandle, Section);

        if (osSpecificSection) {
            b = pParseDestInfInstructionsWorker (&is, InfHandle, Application, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);

    return b;
}

BOOL
ParseOneApplication (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      BOOL PreParse,
    IN      UINT MasterGroup,
    IN      PCTSTR Application,
    IN      PCTSTR LocSection,
    IN      PCTSTR AliasType,
    IN      PCTSTR MultiSz
    )
{
    PCTSTR appSection = NULL;
    BOOL detected = FALSE;
    PCTSTR appEnvVar;
    PCTSTR decoratedSection;
    BOOL componentized = FALSE;
    BOOL executeSection = FALSE;
    BOOL markAsPreferred;

    __try {
        if (LocSection || AliasType) {
            componentized = TRUE;
        } else {
            componentized = FALSE;
        }

        if (!Application) {
            __leave;
        }

        decoratedSection = JoinText (TEXT("$"), Application);

        if (Platform == PLATFORM_SOURCE) {

            //
            // locSection exists for all applications we want to send to
            // the UI for approval. PreParse builds the list of apps we
            // send to the UI. Only do detection if this is PreParsing
            // localized apps, or not preparsing non-localized apps
            //

            if ((PreParse && componentized) ||
                (!PreParse && !componentized)
                ) {

                appSection = JoinText (Application, TEXT(".Environment"));
                if (!pParseAppEnvSection (PLATFORM_SOURCE, Inf, Application, appSection)) {
                    __leave;
                }
                FreeText (appSection);
                appSection = NULL;
                GlFree (&g_SectionStack);

                appSection = JoinText (Application, TEXT(".Detect"));
                detected = ParseAppDetectSection (Platform, Inf, Application, appSection);
                FreeText (appSection);
                appSection = NULL;
                GlFree (&g_SectionStack);

                if (!detected && pDoesAppSectionExists (Platform, Inf, Application)) {
                    detected = TRUE;
                } else if (!detected) {
                    LOG ((LOG_INFORMATION, (PCSTR) MSG_APP_NOT_DETECT_INFO, Application));
                } else {
                    LOG ((LOG_INFORMATION, (PCSTR) MSG_APP_DETECT_INFO, Application));
                    appEnvVar = JoinTextEx (NULL, Section, Application, TEXT("."), 0, NULL);
                    IsmSetEnvironmentFlag (PLATFORM_SOURCE, NULL, appEnvVar);
                    FreeText (appEnvVar);
                }

                if (componentized && detected) {

                    //
                    // we should put it in the selection list
                    //

                    if (LocSection) {
                        IsmAddComponentAlias (
                            decoratedSection,
                            MasterGroup,
                            LocSection,
                            COMPONENT_NAME,
                            FALSE
                            );

                        IsmSelectPreferredAlias (decoratedSection, LocSection, COMPONENT_NAME);
                    }

                    if (AliasType) {
                        markAsPreferred = (LocSection == NULL);
                        pAddFilesAndFoldersComponentOrSection (
                            Inf,
                            decoratedSection,
                            AliasType,
                            MultiSz,
                            MasterGroup,
                            &markAsPreferred
                            );
                    }
                }
                executeSection = (!PreParse) && detected;
            } else {
                executeSection = (!PreParse) && IsmIsComponentSelected (decoratedSection, 0);
            }

            // Now actually load the application instructions if it's not preparsing
            if (executeSection) {

                appSection = DuplicateText (Application);
                if (!ParseInfInstructions (Inf, Application, appSection)) {
                    __leave;
                }
                FreeText (appSection);
                appSection = NULL;
                appEnvVar = JoinTextEx (NULL, Section, Application, TEXT("."), 0, NULL);
                if (IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, appEnvVar)) {
                    appSection = JoinText (Application, TEXT(".Instructions"));
                    if (!ParseInfInstructions (Inf, Application, appSection)) {
                        __leave;
                    }
                    FreeText (appSection);
                    appSection = NULL;
                }
                FreeText (appEnvVar);
            } else {
                if (!PreParse) {
                    appEnvVar = JoinTextEx (NULL, Section, Application, TEXT("."), 0, NULL);
                    IsmDeleteEnvironmentVariable (PLATFORM_SOURCE, NULL, appEnvVar);
                    FreeText (appEnvVar);
                }
            }
        } else {
            MYASSERT (Platform == PLATFORM_DESTINATION);

            appSection = JoinText (Application, TEXT(".Environment"));
            if (!pParseAppEnvSection (PLATFORM_DESTINATION, Inf, Application, appSection)) {
                __leave;
            }
            FreeText (appSection);
            appSection = NULL;
            GlFree (&g_SectionStack);

            appEnvVar = JoinTextEx (NULL, Section, Application, TEXT("."), 0, NULL);
            if (IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, appEnvVar)) {
                appSection = DuplicateText (Application);
                if (!ParseDestInfInstructions (Inf, Application, appSection)) {
                    __leave;
                }
                FreeText (appSection);
                appSection = NULL;
                appSection = JoinText (Application, TEXT(".Instructions"));
                if (!ParseDestInfInstructions (Inf, Application, appSection)) {
                    __leave;
                }
                FreeText (appSection);
                appSection = NULL;
            }
            FreeText (appEnvVar);
        }

        FreeText (decoratedSection);
        decoratedSection = NULL;
    }
    __finally {
        if (appSection) {
            FreeText (appSection);
            appSection = NULL;
        }
        GlFree (&g_SectionStack);
    }

    return TRUE;
}

BOOL
ParseApplications (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      BOOL PreParse,
    IN      UINT MasterGroup
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR application;
    BOOL result = FALSE;
    PCTSTR locSection;
    PCTSTR aliasType;
    PCTSTR multiSz;

    __try {
        if (InfFindFirstLine (Inf, Section, NULL, &is)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (&is);

                application = InfGetStringField (&is, 1);
                locSection = InfGetStringField (&is, 2);
                aliasType = InfGetStringField (&is, 3);
                multiSz = InfGetMultiSzField (&is, 4);

                if (application && !application[0]) {
                    application = NULL;
                }

                if (locSection && !locSection[0]) {
                    locSection = NULL;
                }

                if (aliasType && !aliasType[0]) {
                    aliasType = NULL;
                }

                if (multiSz && !multiSz[0]) {
                    multiSz = NULL;
                }

                if (!aliasType || !multiSz) {
                    aliasType = NULL;
                    multiSz = NULL;
                }

                ParseOneApplication (
                    Platform,
                    Inf,
                    Section,
                    PreParse,
                    MasterGroup,
                    application,
                    locSection,
                    aliasType,
                    multiSz
                    );

            } while (InfFindNextLine (&is));

        }

        result = TRUE;

    } __finally {
        InfCleanUpInfStruct (&is);
    }

    return result;
}

BOOL
ProcessFilesAndFolders (
    IN      HINF InfHandle,
    IN      PCTSTR Section,
    IN      BOOL PreParse
    )
{
    BOOL b = TRUE;
    BOOL markAsPreferred = TRUE;

    if (PreParse) {
        b = pAddFilesAndFoldersSection (InfHandle, Section, MASTERGROUP_FILES_AND_FOLDERS, FALSE, &markAsPreferred);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\entry.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    entry.c

Abstract:

    Implements the DLL entry point that provides all Cobra module entry points
    to the engine.

Author:

    Jim Schmidt (jimschm) 11-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "v1p.h"


typedef struct {
    PCTSTR Name;
    TYPE_ENTRYPOINTS EntryPoints;
} ETM_TABLE, *PETM_TABLE;

typedef struct {
    PCTSTR Name;
    VIRTUAL_COMPUTER_ENTRYPOINTS EntryPoints;
} VCM_TABLE, *PVCM_TABLE;

typedef struct {
    PCTSTR Name;
    SOURCE_ENTRYPOINTS EntryPoints;
} SOURCE_TABLE, *PSOURCE_TABLE;

typedef struct {
    PCTSTR Name;
    DESTINATION_ENTRYPOINTS EntryPoints;
} DESTINATION_TABLE, *PDESTINATION_TABLE;


//
// Add an entry for each ETM module in the DLL
//

ETM_TABLE g_EtmEntryPoints[] = {
    {   TEXT("SCRIPT"), ISM_VERSION,
        ScriptEtmInitialize, ScriptEtmParse, ScriptEtmTerminate, NULL
    },

    {   TEXT("CERTIFICATES"), ISM_VERSION,
        CertificatesEtmInitialize, NULL, NULL, CertificatesEtmNewUserCreated
    },

    {NULL}
};

//
// Add an entry for each VCM module in the DLL
//

VCM_TABLE g_VcmEntryPoints[] = {
    {   TEXT("SCRIPT"), ISM_VERSION,
        ScriptVcmInitialize, ScriptVcmParse, ScriptVcmQueueEnumeration, NULL, ScriptTerminate
    },

    {NULL}
};

//
// Add an entry for each source module in the DLL
//

SOURCE_TABLE g_SourceEntryPoints[] = {
    {   TEXT("SCRIPT"), ISM_VERSION,
        ScriptSgmInitialize, ScriptSgmParse, ScriptSgmQueueEnumeration, NULL, (PSGMTERMINATE) ScriptTerminate,
        NULL, NULL, NULL, NULL
    },

    {NULL}
};

//
// Add an entry for each destination module in the DLL
//

DESTINATION_TABLE g_DestinationEntryPoints[] = {
    {   TEXT("SCRIPT"), ISM_VERSION,
        ScriptDgmInitialize, ScriptDgmQueueEnumeration, NULL, NULL,
        NULL, NULL, NULL, NULL,
        ScriptCsmInitialize, ScriptCsmExecute, NULL, ScriptCsmTerminate,
        ScriptOpmInitialize, ScriptOpmTerminate
    },

    {NULL}
};


EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
    }

    return TRUE;
}


BOOL
WINAPI
pFindModule (
    IN      PCTSTR ModuleId,
    OUT     PVOID IsmBuffer,
    IN      PCTSTR *TableEntry,
    IN      UINT StructureSize
    )
{

    while (*TableEntry) {
        if (StringIMatch (*TableEntry, ModuleId)) {
            CopyMemory (
                IsmBuffer,
                (PBYTE) (TableEntry + 1),
                StructureSize
                );
            return TRUE;
        }

        TableEntry = (PCTSTR *) ((PBYTE) (TableEntry + 1) + StructureSize);
    }

    return FALSE;
}



EXPORT
BOOL
WINAPI
TypeModule (
    IN      PCTSTR ModuleId,
    IN OUT  PTYPE_ENTRYPOINTS TypeEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) TypeEntryPoints,
                (PCTSTR *) g_EtmEntryPoints,
                sizeof (TYPE_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
VirtualComputerModule (
    IN      PCTSTR ModuleId,
    IN OUT  PVIRTUAL_COMPUTER_ENTRYPOINTS VirtualComputerEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) VirtualComputerEntryPoints,
                (PCTSTR *) g_VcmEntryPoints,
                sizeof (VIRTUAL_COMPUTER_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
SourceModule (
    IN      PCTSTR ModuleId,
    IN OUT  PSOURCE_ENTRYPOINTS SourceEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) SourceEntryPoints,
                (PCTSTR *) g_SourceEntryPoints,
                sizeof (SOURCE_ENTRYPOINTS)
                );
}


EXPORT
BOOL
WINAPI
DestinationModule (
    IN      PCTSTR ModuleId,
    IN OUT  PDESTINATION_ENTRYPOINTS DestinationEntryPoints
    )
{
    return pFindModule (
                ModuleId,
                (PVOID) DestinationEntryPoints,
                (PCTSTR *) g_DestinationEntryPoints,
                sizeof (DESTINATION_ENTRYPOINTS)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\dgm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dgm.c

Abstract:

    Implements the initialization/termination code for the data gather portion
    of scanstate v1 compatiblity.

Author:

    Calin Negreanu (calinn) 16-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_OPERATIONID g_DestAddObject;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

DGMINITIALIZE ScriptDgmInitialize;
DGMQUEUEENUMERATION ScriptDgmQueueEnumeration;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
WINAPI
ScriptDgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TCHAR userName[256];
    TCHAR altUserName[256];
    BOOL useAltUser = TRUE;
    TCHAR domainName[256];
    TCHAR altDomainName[256];
    BOOL useAltDomain = TRUE;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    if (IsmIsEnvironmentFlagSet (PLATFORM_DESTINATION, NULL, S_ENV_CREATE_USER)) {

        if (!IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("USERNAME"),
                userName,
                sizeof (userName),
                NULL
                )) {
            IsmSetCancel();
            SetLastError (ERROR_INVALID_DATA);
            LOG ((LOG_ERROR, (PCSTR) MSG_USER_REQUIRED));
            return FALSE;
        }

        ZeroMemory (altUserName, sizeof (altUserName));
        if (!IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("ALTUSERNAME"),
                altUserName,
                sizeof (altUserName),
                NULL
                )) {
            useAltUser = FALSE;
        }

        if (!IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("USERDOMAIN"),
                domainName,
                sizeof (domainName),
                NULL
                )) {
            IsmSetCancel();
            SetLastError (ERROR_INVALID_DOMAINNAME);
            LOG ((LOG_ERROR, (PCSTR) MSG_DOMAIN_REQUIRED));
            return FALSE;
        }

        ZeroMemory (altDomainName, sizeof (altDomainName));
        if (!IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("ALTUSERDOMAIN"),
                altDomainName,
                sizeof (altDomainName),
                NULL
                )) {
            useAltDomain = FALSE;
        }

        LOG ((LOG_INFORMATION, (PCSTR) MSG_PROFILE_CREATE_INFO, useAltDomain?altDomainName:domainName, useAltUser?altUserName:userName));

        if (!IsmCreateUser (useAltUser?altUserName:userName, useAltDomain?altDomainName:domainName)) {
            IsmSetCancel();
            return FALSE;
        }

        // we created a new user, this is the one that %username% and %userdomain% should refer to on the
        // destination machine. Making the correction...
        if (useAltDomain) {
            IsmSetEnvironmentString (
                PLATFORM_DESTINATION,
                S_SYSENVVAR_GROUP,
                TEXT("USERDOMAIN"),
                altDomainName
                );
        }
        if (useAltUser) {
            IsmSetEnvironmentString (
                PLATFORM_DESTINATION,
                S_SYSENVVAR_GROUP,
                TEXT("USERNAME"),
                altUserName
                );
        }
    }

    return TRUE;
}

BOOL
pParseDestinationDetect (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    GROWBUFFER appList = INIT_GROWBUFFER;
    PCTSTR displayName = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    PCTSTR appSection = NULL;
    BOOL detected = FALSE;
    BOOL appFound = FALSE;
    QUESTION_DATA questionData;
    ULONG_PTR appResult;
    PCTSTR loadedStr = NULL;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_CHECKDETECT,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_CHECKDETECT,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        loadedStr = GetStringResource (MSG_INSTALL_APPS1);
        if (loadedStr) {
            GbAppendString (&appList, loadedStr);
            FreeStringResource (loadedStr);
            loadedStr = NULL;
        }
        GbAppendString (&appList, TEXT("\n\n"));

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                // e.CurrentString is the actual section that we need to execute
                // we are going to append a .DETECT to it though

                appSection = JoinText (e.CurrentString, TEXT(".Detect"));
                detected = ParseAppDetectSection (PLATFORM_DESTINATION, InfHandle, e.CurrentString, appSection);
                if (!detected) {
                    // let's try to find the display name for this app
                    if (InfFindFirstLine (InfHandle, TEXT("Strings"), e.CurrentString, &is)) {
                        displayName = InfGetStringField (&is, 1);
                    }
                    if (!displayName) {
                        displayName = e.CurrentString;
                    }
                    if (displayName) {
                        appFound = TRUE;
                        GbAppendString (&appList, TEXT("- "));
                        GbAppendString (&appList, displayName);
                        GbAppendString (&appList, TEXT("\n"));
                        LOG ((LOG_WARNING, (PCSTR) MSG_APP_NOT_DETECTED, displayName));
                    }
                }
                FreeText (appSection);
                appSection = NULL;
                GlFree (&g_SectionStack);

            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    // now, if we have something in our app list, we will send it to the wizard, so he can
    // prompt the user about it.
    if (appFound) {
        GbAppendString (&appList, TEXT("\n"));
        loadedStr = GetStringResource (MSG_INSTALL_APPS2);
        if (loadedStr) {
            GbAppendString (&appList, loadedStr);
            FreeStringResource (loadedStr);
            loadedStr = NULL;
        }
        GbAppendString (&appList, TEXT("\n"));

        // we have some applications that were not detected. Let's tell the wizard about them
        ZeroMemory (&questionData, sizeof (QUESTION_DATA));
        questionData.Question = (PCTSTR)appList.Buf;
        questionData.MessageStyle = MB_ICONWARNING | MB_OKCANCEL;
        questionData.WantedResult = IDOK;
        appResult = IsmSendMessageToApp (MODULEMESSAGE_ASKQUESTION, (ULONG_PTR)(&questionData));
        if (appResult != APPRESPONSE_SUCCESS) {
            // the user cancelled
            IsmSetCancel ();
        }
    }

    GbFree (&appList);

    return result;
}

UINT
pSuppressDestinationSettings (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmMakeApplyObject (
        Data->ObjectTypeId,
        Data->ObjectName
        );
    IsmSetOperationOnObject (
        Data->ObjectTypeId,
        Data->ObjectName,
        g_DeleteOp,
        NULL,
        NULL
        );
    return CALLBACK_ENUM_CONTINUE;
}

BOOL
pParseInfForExclude (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    ENCODEDSTRHANDLE srcHandle = NULL;
    ENCODEDSTRHANDLE srcBase = NULL;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    BOOL hadLeaf = FALSE;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_DELREG,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_DELREG,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                // on all systems, process "DestDelRegEx"
                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        pattern = InfGetStringField (&is, 0);

                        if (!pattern) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_REG_SPEC));
                            continue;
                        }

                        srcHandle = TurnRegStringIntoHandle (pattern, TRUE, &hadLeaf);
                        if (!srcHandle) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                            continue;
                        }

                        if (!hadLeaf) {
                            srcBase = TurnRegStringIntoHandle (pattern, FALSE, NULL);
                            if (!srcBase) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                                continue;
                            }

                            IsmQueueEnumeration (
                                g_RegType,
                                srcBase,
                                pSuppressDestinationSettings,
                                0,
                                NULL
                                );
                        }

                        IsmQueueEnumeration (
                            g_RegType,
                            srcHandle,
                            pSuppressDestinationSettings,
                            0,
                            NULL
                            );
                        IsmDestroyObjectHandle (srcHandle);
                        srcHandle = NULL;

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
pParseInfForExcludeEx (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR srcNode;
    PCTSTR srcLeaf;
    ENCODEDSTRHANDLE srcHandle = NULL;
    ENCODEDSTRHANDLE srcBase = NULL;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    BOOL hadLeaf = FALSE;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_DELREGEX,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_DELREGEX,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                // on all systems, process "DestDelReg"
                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        srcNode = InfGetStringField (&is, 1);
                        srcLeaf = InfGetStringField (&is, 2);

                        if (!srcNode && !srcLeaf) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_REG_SPEC));
                            continue;
                        }

                        // Validate rule
                        if (!StringIMatchTcharCount (srcNode, S_HKLM, ARRAYSIZE(S_HKLM) - 1) &&
                            !StringIMatchTcharCount (srcNode, S_HKR, ARRAYSIZE(S_HKR) - 1) &&
                            !StringIMatchTcharCount (srcNode, S_HKCC, ARRAYSIZE(S_HKCC) - 1)
                            ) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_REGROOT, srcNode));
                            __leave;
                        }

                        srcHandle = CreatePatternFromNodeLeaf (srcNode, srcLeaf);
                        if (!srcHandle) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, srcNode));
                            __leave;
                        }

                        if (!hadLeaf) {
                            srcBase = MakeRegExBase (srcNode, srcLeaf);
                            if (!srcBase) {
                                LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, srcNode));
                                continue;
                            }

                            IsmQueueEnumeration (
                                g_RegType,
                                srcBase,
                                pSuppressDestinationSettings,
                                0,
                                NULL
                                );
                        }

                        IsmQueueEnumeration (
                            g_RegType,
                            srcHandle,
                            pSuppressDestinationSettings,
                            0,
                            NULL
                            );
                        IsmDestroyObjectHandle (srcHandle);
                        srcHandle = NULL;

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
pParseInfForDestAdd (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR objectTypeName;
    UINT objectPriority;
    MIG_OBJECTTYPEID objectTypeId;
    PCTSTR objectMultiSz;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTID objectId;
    MIG_CONTENT existentContent;
    MIG_BLOB blob;
    MIG_DATAHANDLE dataHandle;
    BOOL added = FALSE;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_ADDOBJECT,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_ADDOBJECT,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                // on all systems, process "DestAddObject"
                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        objectTypeName = InfGetStringField (&is, 1);
                        if (!InfGetIntField (&is, 2, &objectPriority)) {
                            objectPriority = 0;
                        }

                        if (objectTypeName) {
                            objectTypeId = IsmGetObjectTypeId (objectTypeName);
                            if (objectTypeId) {
                                // let's read the object multi-sz
                                objectMultiSz = InfGetMultiSzField (&is, 3);

                                if (objectMultiSz) {
                                    if (IsmConvertMultiSzToObject (
                                            objectTypeId,
                                            objectMultiSz,
                                            &objectName,
                                            &objectContent
                                            )) {
                                        // finally we have the object
                                        // We need to:
                                        // 1. Verify that the destination object does not exist
                                        // 2. Add the destination object handle in ISMs database
                                        // 3. Set an operation on the object passing the objectContent
                                        //    as data

                                        added = FALSE;

                                        if (IsmAcquireObject (
                                                objectTypeId | PLATFORM_DESTINATION,
                                                objectName,
                                                &existentContent
                                                )) {
                                            if (objectPriority) {
                                                objectId = IsmGetObjectIdFromName (
                                                                objectTypeId | PLATFORM_DESTINATION,
                                                                objectName,
                                                                TRUE
                                                                );
                                                if (objectId) {
                                                    blob.Type = BLOBTYPE_BINARY;
                                                    blob.BinarySize = sizeof (objectContent);
                                                    blob.BinaryData = (PBYTE) &objectContent;
                                                    dataHandle = IsmRegisterOperationData (&blob);
                                                    if (dataHandle) {
                                                        IsmMakeApplyObjectId (objectId);
                                                        IsmSetOperationOnObjectId2 (
                                                            objectId,
                                                            g_DestAddObject,
                                                            0,
                                                            dataHandle
                                                            );
                                                        added = TRUE;
                                                    }
                                                }
                                            } else {
                                                IsmReleaseObject (&existentContent);
                                            }
                                        } else {
                                            objectId = IsmGetObjectIdFromName (
                                                            objectTypeId | PLATFORM_DESTINATION,
                                                            objectName,
                                                            FALSE
                                                            );
                                            if (objectId) {
                                                blob.Type = BLOBTYPE_BINARY;
                                                blob.BinarySize = sizeof (objectContent);
                                                blob.BinaryData = (PBYTE) &objectContent;
                                                dataHandle = IsmRegisterOperationData (&blob);
                                                if (dataHandle) {
                                                    IsmMakeApplyObjectId (objectId);
                                                    IsmSetOperationOnObjectId2 (
                                                        objectId,
                                                        g_DestAddObject,
                                                        0,
                                                        dataHandle
                                                        );
                                                    added = TRUE;
                                                }
                                            }
                                        }
                                        if (!added) {
                                            IsmDestroyObjectHandle (objectName);
                                            if (objectContent.ContentInFile) {
                                                if (objectContent.FileContent.ContentPath) {
                                                    IsmReleaseMemory (objectContent.FileContent.ContentPath);
                                                }
                                            } else {
                                                if (objectContent.MemoryContent.ContentBytes) {
                                                    IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
                                                }
                                            }
                                            if (objectContent.Details.DetailsData) {
                                                IsmReleaseMemory (objectContent.Details.DetailsData);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
pParseInfForExecute (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR time;
    PCTSTR currString;
    UINT index;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    GROWBUFFER funcStr = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_SCRIPT_EXECUTE,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_SCRIPT_EXECUTE,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        time = InfGetStringField (&is, 0);

                        if (!time) {
                            continue;
                        }

                        index = 1;
                        funcStr.End = 0;
                        while (currString = InfGetStringField (&is, index)) {
                            GbMultiSzAppend (&funcStr, currString);
                            index ++;
                        }

                        if (funcStr.End) {
                            GbMultiSzAppend (&funcStr, TEXT(""));
                            if (StringIMatch (time, TEXT("PreProcess"))) {
                                IsmExecuteFunction (MIG_EXECUTE_PREPROCESS, (PCTSTR)funcStr.Buf);
                            }
                            if (StringIMatch (time, TEXT("Refresh"))) {
                                IsmExecuteFunction (MIG_EXECUTE_REFRESH, (PCTSTR)funcStr.Buf);
                            }
                            if (StringIMatch (time, TEXT("PostProcess"))) {
                                IsmExecuteFunction (MIG_EXECUTE_POSTPROCESS, (PCTSTR)funcStr.Buf);
                            }
                        }

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        GbFree (&funcStr);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
pParseDestinationEnvironment (
    IN      HINF InfHandle
    )
{
    BOOL result = TRUE;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Process the application sections
    //

    if (!ParseApplications (PLATFORM_DESTINATION, InfHandle, TEXT("Applications"), FALSE, MASTERGROUP_APP)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_APP_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process system settings
    //

    if (!ParseApplications (PLATFORM_DESTINATION, InfHandle, TEXT("System Settings"), FALSE, MASTERGROUP_SYSTEM)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_SYSTEM_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process user settings
    //

    if (!ParseApplications (PLATFORM_DESTINATION, InfHandle, TEXT("User Settings"), FALSE, MASTERGROUP_USER)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_USER_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process the administrator script sections
    //

    if (!ParseApplications (PLATFORM_DESTINATION, InfHandle, TEXT("Administrator Scripts"), FALSE, MASTERGROUP_SCRIPT)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_SCRIPT_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
ScriptDgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = TRUE;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {
        if (!pParseDestinationEnvironment (infHandle)) {
            result = FALSE;
        }
        if (!pParseDestinationDetect (infHandle)) {
            result = FALSE;
        }
        if (!pParseInfForExclude (infHandle)) {
            result = FALSE;
        }
        if (!pParseInfForExcludeEx (infHandle)) {
            result = FALSE;
        }
        if (!pParseInfForExecute (infHandle)) {
            result = FALSE;
        }
        if (!pParseInfForDestAdd (infHandle)) {
            result = FALSE;
        }
    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                result = FALSE;
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                result = FALSE;
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {
                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseDestinationEnvironment (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseDestinationDetect (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseInfForExclude (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseInfForExcludeEx (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseInfForExecute (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }
                        if (!pParseInfForDestAdd (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }

                        InfCloseInfFile (infHandle);
                        infHandle = INVALID_HANDLE_VALUE;
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                } while (EnumNextMultiSz (&e));

            }
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\etm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    etm.c

Abstract:

    Implements the code for the ETM part of the script module

Author:

    Calin Negreanu (calinn) 13-Sep-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

HASHTABLE g_ObjectsTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pAddObjectToTable (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    );

//
// Macro expansion definition
//

// None

//
// Code
//

#define S_LOCATIONS TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations")

BOOL
pTranslateLocations (
    VOID
    )
{
    INFSTRUCT context = INITINFSTRUCT_PMHANDLE;
    HINF hInf = NULL;
    TCHAR windir [MAX_PATH] = TEXT("");
    TCHAR locationStr [] = TEXT("Location9999999999");
    PCTSTR infPath = NULL;
    INT totalLocations = 0;
    INT currentLocation = 0;
    INT currLocInt = 0;
    PCTSTR currLocStr = NULL;
    PCTSTR currLocReg = NULL;
    MIG_OBJECTTYPEID objectTypeId;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;

    GetWindowsDirectory (windir, MAX_PATH);
    infPath = JoinPaths (windir, TEXT("TELEPHON.INI"));
    if (infPath) {
        hInf = InfOpenInfFile (infPath);
        if (hInf != INVALID_HANDLE_VALUE) {
            if (InfFindFirstLine (hInf, TEXT("Locations"), TEXT("Locations"), &context)) {
                if (InfGetIntField (&context, 1, &totalLocations)) {
                    if (totalLocations > 0) {
                        objectTypeId = MIG_REGISTRY_TYPE;
                        ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
                        objectContent.ObjectTypeId = objectTypeId;
                        objectContent.ContentInFile = FALSE;

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("DisableCallWaiting"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_BINARY;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                *((PDWORD)objectContent.MemoryContent.ContentBytes) = 3;
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("DisableCallWaiting0"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (TEXT("*70,")));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = SizeOfString (TEXT("*70,"));
                                CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, TEXT("*70,"), objectContent.MemoryContent.ContentSize);
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("DisableCallWaiting1"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (TEXT("70#,")));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = SizeOfString (TEXT("70#,"));
                                CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, TEXT("70#,"), objectContent.MemoryContent.ContentSize);
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("DisableCallWaiting2"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (TEXT("1170,")));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = SizeOfString (TEXT("1170,"));
                                CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, TEXT("1170,"), objectContent.MemoryContent.ContentSize);
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("NextID"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                *((PDWORD)objectContent.MemoryContent.ContentBytes) = totalLocations + 1;
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("NumEntries"));
                        objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                        if (objectContent.Details.DetailsData) {
                            objectContent.Details.DetailsSize = sizeof (DWORD);
                            *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                            objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            if (objectContent.MemoryContent.ContentBytes) {
                                objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                *((PDWORD)objectContent.MemoryContent.ContentBytes) = totalLocations;
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);
                            }
                        }

                        currentLocation = 0;
                        if (InfFindFirstLine (hInf, TEXT("Locations"), TEXT("CurrentLocation"), &context)) {
                            if (InfGetIntField (&context, 1, &currentLocation)) {
                            }
                        }

                        while (totalLocations) {
                            wsprintf (locationStr, TEXT("Location%d"), totalLocations - 1);
                            if (InfFindFirstLine (hInf, TEXT("Locations"), locationStr, &context)) {
                                wsprintf (locationStr, TEXT("Location%d"), totalLocations);
                                // let's read all the items for this location
                                currLocInt = 0;
                                InfGetIntField (&context, 1, &currLocInt);
                                if (currLocInt == currentLocation) {
                                    // this is the current location, let's write that
                                    objectName = IsmCreateObjectHandle (S_LOCATIONS, TEXT("CurrentID"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                            *((PDWORD)objectContent.MemoryContent.ContentBytes) = currLocInt + 1;
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                currLocReg = JoinPaths (S_LOCATIONS, locationStr);

                                objectName = IsmCreateObjectHandle (currLocReg, NULL);
                                objectContent.Details.DetailsData = NULL;
                                objectContent.Details.DetailsSize = 0;
                                objectContent.MemoryContent.ContentBytes = NULL;
                                objectContent.MemoryContent.ContentSize = 0;
                                pAddObjectToTable (objectTypeId, objectName, &objectContent);

                                /*
                                objectName = IsmCreateObjectHandle (currLocReg, TEXT("ID"));
                                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                if (objectContent.Details.DetailsData) {
                                    objectContent.Details.DetailsSize = sizeof (DWORD);
                                    *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                                    objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.MemoryContent.ContentBytes) {
                                        objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.MemoryContent.ContentBytes) = currLocInt;
                                        pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                    }
                                }
                                */

                                currLocStr = InfGetStringField (&context, 2);
                                if (!currLocStr) {
                                    currLocStr = locationStr;
                                }
                                objectName = IsmCreateObjectHandle (currLocReg, TEXT("Name"));
                                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                if (objectContent.Details.DetailsData) {
                                    objectContent.Details.DetailsSize = sizeof (DWORD);
                                    *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                    objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                    if (objectContent.MemoryContent.ContentBytes) {
                                        objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                        CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                        pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                    }
                                }

                                currLocStr = InfGetStringField (&context, 3);
                                if (currLocStr) {
                                    objectName = IsmCreateObjectHandle (currLocReg, TEXT("OutsideAccess"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                            CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                currLocStr = InfGetStringField (&context, 4);
                                if (currLocStr) {
                                    objectName = IsmCreateObjectHandle (currLocReg, TEXT("LongDistanceAccess"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                            CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                currLocStr = InfGetStringField (&context, 5);
                                if (currLocStr) {
                                    objectName = IsmCreateObjectHandle (currLocReg, TEXT("AreaCode"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                            CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                currLocInt = 1;
                                InfGetIntField (&context, 6, &currLocInt);
                                objectName = IsmCreateObjectHandle (currLocReg, TEXT("Country"));
                                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                if (objectContent.Details.DetailsData) {
                                    objectContent.Details.DetailsSize = sizeof (DWORD);
                                    *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                                    objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.MemoryContent.ContentBytes) {
                                        objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.MemoryContent.ContentBytes) = currLocInt;
                                        pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                    }
                                }

                                currLocInt = 1;
                                InfGetIntField (&context, 11, &currLocInt);
                                objectName = IsmCreateObjectHandle (currLocReg, TEXT("Flags"));
                                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                if (objectContent.Details.DetailsData) {
                                    objectContent.Details.DetailsSize = sizeof (DWORD);
                                    *((PDWORD)objectContent.Details.DetailsData) = REG_DWORD;
                                    objectContent.MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.MemoryContent.ContentBytes) {
                                        objectContent.MemoryContent.ContentSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.MemoryContent.ContentBytes) = (!currLocInt)?0x00000005:0x00000004;
                                        pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                    }
                                }

                                currLocStr = InfGetStringField (&context, 12);
                                if (currLocStr) {
                                    objectName = IsmCreateObjectHandle (currLocReg, TEXT("DisableCallWaiting"));
                                    objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                                    if (objectContent.Details.DetailsData) {
                                        objectContent.Details.DetailsSize = sizeof (DWORD);
                                        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                                        objectContent.MemoryContent.ContentBytes = IsmGetMemory (SizeOfString (currLocStr));
                                        if (objectContent.MemoryContent.ContentBytes) {
                                            objectContent.MemoryContent.ContentSize = SizeOfString (currLocStr);
                                            CopyMemory ((PTSTR)objectContent.MemoryContent.ContentBytes, currLocStr, objectContent.MemoryContent.ContentSize);
                                            pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                        }
                                    }
                                }

                                FreePathString (currLocReg);
                                currLocReg = NULL;
                            }
                            totalLocations --;
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}

BOOL
WINAPI
ScriptEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    MIG_OSVERSIONINFO versionInfo;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);
    g_ObjectsTable = HtAllocWithData (sizeof (MIG_CONTENT));
    if (!g_ObjectsTable) {
        return FALSE;
    }
    // Now let's look if we need to translate the Telephony locations settings.
    // On Win95 these settings are in %windir%\TELEPHONY.INI and they need to be
    // moved in HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations key.
    if (IsmGetRealPlatform () == PLATFORM_SOURCE) {
        ZeroMemory (&versionInfo, sizeof (MIG_OSVERSIONINFO));
        if (IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo)) {
            if ((versionInfo.OsType == OSTYPE_WINDOWS9X) &&
                ((versionInfo.OsMajorVersion == OSMAJOR_WIN95) ||
                 (versionInfo.OsMajorVersion == OSMAJOR_WIN95OSR2)
                 )
                ) {
                // we are on a Win95 Gold system
                pTranslateLocations ();
            }
        }
    }
    return TRUE;
}

BOOL
WINAPI
AcquireScriptObject (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit,
    OUT     PMIG_CONTENT *NewObjectContent,         CALLER_INITIALIZED OPTIONAL
    IN      BOOL ReleaseContent,
    IN      ULONG_PTR Arg
    )
{
    PMIG_CONTENT objectContent;
    BOOL result = FALSE;

    __try {
        objectContent = IsmGetMemory (sizeof (MIG_CONTENT));
        if (HtFindStringEx (g_ObjectsTable, ObjectName, objectContent, FALSE)) {
            if ((ContentType == CONTENTTYPE_FILE) &&
                (!objectContent->ContentInFile)
                ) {
                DEBUGMSG ((DBG_ERROR, "Script added object content cannot be saved to a file: %s", ObjectName));
                __leave;
            }
            if ((ContentType == CONTENTTYPE_MEMORY) &&
                (objectContent->ContentInFile)
                ) {
                DEBUGMSG ((DBG_ERROR, "Script added object content cannot be saved to memory: %s", ObjectName));
                __leave;
            }
            *NewObjectContent = objectContent;
            objectContent->EtmHandle = objectContent;
            result = TRUE;
        }
    }
    __finally {
        if (!result && objectContent) {
            IsmReleaseMemory (objectContent);
            objectContent = NULL;
        }
    }
    return result;
}

VOID
WINAPI
ReleaseScriptObject (
    IN      PMIG_CONTENT ObjectContent
    )
{
    if (ObjectContent) {
        IsmReleaseMemory (ObjectContent->EtmHandle);
    }
}

BOOL
WINAPI
ScriptAddObject (
    IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,     // NULL if Abort is TRUE
    IN      MIG_PARSEDPATTERN ParsedPattern,    // NULL if Abort is TRUE
    IN      ULONG_PTR Arg,
    IN      BOOL Abort
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    BOOL enumDone = FALSE;
    PCTSTR p;
    BOOL result = FALSE;

    if (Abort) {

        IsmDestroyObjectString (ObjectEnum->ObjectNode);
        ObjectEnum->ObjectNode = NULL;
        IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
        ObjectEnum->ObjectLeaf = NULL;
        IsmReleaseMemory (ObjectEnum->NativeObjectName);
        ObjectEnum->NativeObjectName = NULL;
        result = TRUE;

    } else {

        enumDone = (ObjectEnum->EtmHandle == 1);

        if (enumDone) {

            IsmDestroyObjectString (ObjectEnum->ObjectNode);
            ObjectEnum->ObjectNode = NULL;
            IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
            ObjectEnum->ObjectLeaf = NULL;
            IsmReleaseMemory (ObjectEnum->NativeObjectName);
            ObjectEnum->NativeObjectName = NULL;
            ObjectEnum->EtmHandle = 0;
            result = FALSE;

        } else {

            objectName = (MIG_OBJECTSTRINGHANDLE) Arg;

            if (HtFindStringEx (g_ObjectsTable, objectName, &objectContent, FALSE)) {

                if (IsmParsedPatternMatch (ParsedPattern, objectContent.ObjectTypeId, objectName)) {

                    ObjectEnum->ObjectName = objectName;

                    //
                    // Fill in node, leaf and details
                    //
                    IsmDestroyObjectString (ObjectEnum->ObjectNode);
                    IsmDestroyObjectString (ObjectEnum->ObjectLeaf);
                    IsmReleaseMemory (ObjectEnum->NativeObjectName);

                    IsmCreateObjectStringsFromHandle (
                        ObjectEnum->ObjectName,
                        &ObjectEnum->ObjectNode,
                        &ObjectEnum->ObjectLeaf
                        );

                    ObjectEnum->Level = 0;

                    if (ObjectEnum->ObjectNode) {
                        p = _tcschr (ObjectEnum->ObjectNode, TEXT('\\'));
                        while (p) {
                            ObjectEnum->Level++;
                            p = _tcschr (p + 1, TEXT('\\'));
                        }
                    }

                    if (ObjectEnum->ObjectLeaf) {
                        ObjectEnum->Level ++;
                    }

                    ObjectEnum->SubLevel = 0;

                    if (ObjectEnum->ObjectLeaf) {
                        ObjectEnum->IsNode = FALSE;
                        ObjectEnum->IsLeaf = TRUE;
                    } else {
                        ObjectEnum->IsNode = TRUE;
                        ObjectEnum->IsLeaf = FALSE;
                    }

                    ObjectEnum->Details.DetailsSize = objectContent.Details.DetailsSize;
                    ObjectEnum->Details.DetailsData = objectContent.Details.DetailsData;

                    //
                    // Rely on base type to get the native object name
                    //

                    ObjectEnum->NativeObjectName = IsmGetNativeObjectName (
                                                        ObjectEnum->ObjectTypeId,
                                                        ObjectEnum->ObjectName
                                                        );
                    result = TRUE;

                    ObjectEnum->EtmHandle = 1;
                }
            }
        }
    }
    return result;
}

BOOL
pAddObjectToTable (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    BOOL b = TRUE;
    HtAddStringEx (g_ObjectsTable, ObjectName, ObjectContent, FALSE);
    b = b && IsmProhibitPhysicalEnum (
                ObjectTypeId,
                ObjectName,
                NULL,
                0,
                NULL
                );
    b = b && IsmAddToPhysicalEnum (
                ObjectTypeId,
                ObjectName,
                ScriptAddObject,
                (ULONG_PTR)ObjectName
                );
    b = b && IsmRegisterPhysicalAcquireHook (
                ObjectTypeId,
                ObjectName,
                AcquireScriptObject,
                ReleaseScriptObject,
                0,
                NULL
                );
    return b;
}

BOOL
pDoesObjectExist (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    MIG_CONTENT objectContent;
    BOOL result = FALSE;

    if (IsmAcquireObject (ObjectTypeId, ObjectName, &objectContent)) {
        IsmReleaseObject (&objectContent);
        result = TRUE;
    }

    return result;
}

BOOL
pParseEtmInfSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR objectTypeName;
    MIG_OBJECTTYPEID objectTypeId;
    PCTSTR objectMultiSz;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL result = TRUE;
    BOOL b = TRUE;
    UINT force = 0;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    __try {
        if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (InfStruct);

                objectTypeName = InfGetStringField (InfStruct, 1);

                if (objectTypeName) {
                    objectTypeId = IsmGetObjectTypeId (objectTypeName);
                    if (objectTypeId) {

                        if (!InfGetIntField (InfStruct, 2, &force)) {
                            force = 0;
                        }

                        // let's read the object multi-sz
                        objectMultiSz = InfGetMultiSzField (InfStruct, 3);

                        if (objectMultiSz) {
                            if (IsmConvertMultiSzToObject (
                                    objectTypeId,
                                    objectMultiSz,
                                    &objectName,
                                    &objectContent
                                    )) {
                                // finally we have an object
                                // if force==0 we need to see if this object already exists
                                if ((force == 1) || (!pDoesObjectExist (objectTypeId, objectName))) {
                                    // save it in our hash table and
                                    // call the appropriate hooks
                                    pAddObjectToTable (objectTypeId, objectName, &objectContent);
                                } else {
                                    if ((objectContent.Details.DetailsSize) &&
                                        (objectContent.Details.DetailsData)
                                        ) {
                                        IsmReleaseMemory (objectContent.Details.DetailsData);
                                    }
                                    if (objectContent.ContentInFile) {
                                        if (objectContent.FileContent.ContentPath) {
                                            IsmReleaseMemory (objectContent.FileContent.ContentPath);
                                        }
                                    } else {
                                        if ((objectContent.MemoryContent.ContentSize) &&
                                            (objectContent.MemoryContent.ContentBytes)
                                            ) {
                                            IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

            } while (InfFindNextLine (InfStruct));
        }
        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (InfStruct);
    }
    return result;
}

BOOL
pParseEtmIniInfSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR iniFile;
    PCTSTR iniFileExp = NULL;
    PCTSTR iniSection;
    PCTSTR iniValue;
    PCTSTR iniRegKey;
    PCTSTR iniRegValue;
    TCHAR iniItem [MAX_TCHAR_PATH];
    MIG_OBJECTTYPEID objectTypeId;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL result = TRUE;
    BOOL b = TRUE;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    __try {
        if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                InfResetInfStruct (InfStruct);

                iniFile = InfGetStringField (InfStruct, 1);
                if (!iniFile || !iniFile[0]) {
                    __leave;
                }

                iniFileExp = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, iniFile, NULL);
                if (!iniFileExp || !iniFileExp[0]) {
                    __leave;
                }

                iniSection = InfGetStringField (InfStruct, 2);
                if (!iniSection || !iniSection[0]) {
                    __leave;
                }

                iniValue = InfGetStringField (InfStruct, 3);
                if (!iniValue || !iniValue[0]) {
                    __leave;
                }

                iniRegKey = InfGetStringField (InfStruct, 4);
                if (!iniRegKey || !iniRegKey[0]) {
                    __leave;
                }

                iniRegValue = InfGetStringField (InfStruct, 5);
                if (!iniRegValue || !iniRegValue[0]) {
                    __leave;
                }

                // let's get the INI item
                GetPrivateProfileString (iniSection, iniValue, TEXT(""), iniItem, MAX_TCHAR_PATH, iniFileExp);
                if (!iniItem[0]) {
                    __leave;
                }

                objectTypeId = MIG_REGISTRY_TYPE;

                objectName = IsmCreateObjectHandle (iniRegKey, iniRegValue);

                ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
                objectContent.ObjectTypeId = objectTypeId;
                objectContent.ContentInFile = FALSE;
                objectContent.MemoryContent.ContentSize = SizeOfString (iniItem);
                objectContent.MemoryContent.ContentBytes = IsmGetMemory (objectContent.MemoryContent.ContentSize);
                CopyMemory ((PBYTE)objectContent.MemoryContent.ContentBytes, iniItem, objectContent.MemoryContent.ContentSize);
                objectContent.Details.DetailsSize = sizeof (DWORD);
                objectContent.Details.DetailsData = IsmGetMemory (sizeof (DWORD));
                *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;

                // finally we have an object
                // save it in our hash table and
                // call the appropriate hooks
                b = b && pAddObjectToTable (objectTypeId, objectName, &objectContent);

                if (iniFileExp) {
                    IsmReleaseMemory (iniFileExp);
                    iniFileExp = NULL;
                }

            } while (InfFindNextLine (InfStruct));
        }
        result = TRUE;
    }
    __finally {
        if (iniFileExp) {
            IsmReleaseMemory (iniFileExp);
            iniFileExp = NULL;
        }
        InfCleanUpInfStruct (InfStruct);
    }
    return result;
}

BOOL
pParseEtmInf (
    IN      HINF InfHandle
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;

    b = pParseEtmInfSection (&is, InfHandle, TEXT("AddObject"));

    if (b) {
        osSpecificSection = GetMostSpecificSection (PLATFORM_SOURCE, &is, InfHandle, TEXT("AddObject"));

        if (osSpecificSection) {
            b = pParseEtmInfSection (&is, InfHandle, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    b = pParseEtmIniInfSection (&is, InfHandle, TEXT("AddIniRegObject"));

    if (b) {
        osSpecificSection = GetMostSpecificSection (PLATFORM_SOURCE, &is, InfHandle, TEXT("AddIniRegObject"));

        if (osSpecificSection) {
            b = pParseEtmIniInfSection (&is, InfHandle, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    return b;
}

BOOL
WINAPI
ScriptEtmParse (
    IN      PVOID Reserved
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = FALSE;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (pParseEtmInf (infHandle)) {
            result = TRUE;
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {

                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseEtmInf (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            __leave;
                        }
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                    InfCloseInfFile (infHandle);
                    infHandle = INVALID_HANDLE_VALUE;
                } while (EnumNextMultiSz (&e));

            }

            result = TRUE;
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }
    return result;
}

VOID
WINAPI
ScriptEtmTerminate (
    VOID
    )
{
    HASHTABLE_ENUM e;
    PMIG_CONTENT objectContent;

    if (g_ObjectsTable) {
        // enumerate the table and release all memory
        if (EnumFirstHashTableString (&e, g_ObjectsTable)) {
            do {
                objectContent = (PMIG_CONTENT) e.ExtraData;
                if ((objectContent->Details.DetailsSize) &&
                    (objectContent->Details.DetailsData)
                    ) {
                    IsmReleaseMemory (objectContent->Details.DetailsData);
                }
                if (objectContent->ContentInFile) {
                    if (objectContent->FileContent.ContentPath) {
                        IsmReleaseMemory (objectContent->FileContent.ContentPath);
                    }
                } else {
                    if ((objectContent->MemoryContent.ContentSize) &&
                        (objectContent->MemoryContent.ContentBytes)
                        ) {
                        IsmReleaseMemory (objectContent->MemoryContent.ContentBytes);
                    }
                }
            } while (EnumNextHashTableString (&e));
        }
        HtFree (g_ObjectsTable);
        g_ObjectsTable = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\oeutils.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    oe.c

Abstract:

    Implements Outlook Express utilities

Author:

    Jay Thaler (jthaler) 05-Apr-2001

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"
#include <wab.h>
#include <sddl.h>
#include <rpcdce.h>
#define COBJMACROS
#include <msoeimp.h>

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

#define OETEMPDIR TEXT("%CSIDL_LOCAL_APPDATA%\\Identities\\USMTTMP")
#define DEFAULTWAB TEXT("default.wab")

//
// Macros
//

#define IF_NULLEND(x) if (NULL==x) { goto end; }

//
// Types
//

typedef IMailImport * (STDMETHODCALLTYPE OECREATE)(
    LPCSTR pszSrcDir
    );
typedef OECREATE FAR *LPOECREATE;

typedef HRESULT (STDMETHODCALLTYPE IMPORTSTORE)(
    IMailImport *pMailImport,
    GUID *pDestUUID,
    LPCSTR pszDestDir
    );
typedef IMPORTSTORE FAR *LPIMPORTSTORE;

typedef HRESULT (STDMETHODCALLTYPE IMPORTNEWS)(
    LPCSTR pszSrcDir,
    GUID *pDestUUID,
    LPCSTR pszDestDir
    );
typedef IMPORTNEWS FAR *LPIMPORTNEWS;

//
// Globals
//

PTSTR g_DestAssociatedId = NULL;
HMODULE g_msoedll = NULL;
HMODULE g_oemiglib = NULL;
BOOL g_CoInit = FALSE;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pUuidFromBracketedString (
    PCTSTR InStr,
    UUID *Uuid
    )
{
    PTSTR strippedStr = NULL;
    TCHAR *p;
    BOOL retval = FALSE;

    if (!InStr || !Uuid)
    {
        return FALSE;
    }

    if (*InStr == TEXT('{')) {
        strippedStr = DuplicateText(_tcsinc(InStr));
        p = _tcsrchr (strippedStr, TEXT('}'));
        if (p) {
            *p = 0;
        }
    } else {
        strippedStr = DuplicateText(InStr);
    }

    if (strippedStr) {
       if (RPC_S_OK == UuidFromString(strippedStr, Uuid)) {
           retval = TRUE;
       }
       FreeText(strippedStr);
    }

    return retval;
}

MIG_OBJECTSTRINGHANDLE
pBuildStoreRootKeyForId (
    PCTSTR Identity
    )
{
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    PTSTR tmpStr;

    tmpStr = JoinPathsInPoolEx ((
                NULL,
                TEXT("HKCU\\Identities"),
                Identity,
                TEXT("Software\\Microsoft\\Outlook Express\\5.0"),
                NULL
                ));

    if (tmpStr) {
        objectName = IsmCreateObjectHandle (tmpStr, TEXT("Store Root"));
        FreePathString (tmpStr);
        tmpStr = NULL;
    }

    return objectName;
}


PTSTR
pGetDestStoreRootForId (
    PCTSTR Identity
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PTSTR retval = NULL;
    PTSTR tmpStr;
    PCTSTR destStore;

    objectName = pBuildStoreRootKeyForId (Identity);
    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                          objectName,
                          &objectContent)) {
        if (IsValidRegSz(&objectContent)) {
            destStore = IsmExpandEnvironmentString (PLATFORM_DESTINATION,
                                                    S_SYSENVVAR_GROUP,
                                                    (PCTSTR)objectContent.MemoryContent.ContentBytes,
                                                    NULL);
            if (destStore) {
                retval = DuplicateText(destStore);
                IsmReleaseMemory(destStore);
            }
        }
        IsmReleaseObject (&objectContent);
    }
    IsmDestroyObjectHandle(objectName);

    return retval;
}

VOID
WABMerge (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_OBJECTSTRINGHANDLE destObjectName;
    MIG_OBJECTSTRINGHANDLE lpWABObjectName = NULL;
    MIG_CONTENT objectContent;
    PCTSTR srcFile = NULL;
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PTSTR destFile = NULL;
    PCTSTR wabKey = NULL;
    PCTSTR wabPath = NULL;
    PCTSTR destPath;
    HANDLE lib;
    LPWABOPEN lpfnWABOpen = NULL;
    LPWABOBJECT lpWABObject;
    LPADRBOOK lpAdrBookWAB;
    WAB_PARAM wabParams;
    WABIMPORTPARAM wabImportParam;
    HRESULT hr;
    PCTSTR srcIdentity;
    PCTSTR destIdentity;
    PCTSTR destNode;
    PCTSTR defaultWABPath = NULL;
    BOOL fNewOE = FALSE;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        (IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE4_APPDETECT) ||
         IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT))) {
        //
        // Get the source WAB filename
        //
        lpWABObjectName = IsmCreateObjectHandle (TEXT("HKCU\\Software\\Microsoft\\WAB\\WAB4\\Wab File Name"), TEXT(""));
        if (IsmAcquireObject (g_RegType | PLATFORM_SOURCE,
                              lpWABObjectName,
                              &objectContent)) {
            if (IsValidRegSz (&objectContent)) {
                objectName = TurnFileStringIntoHandle ((PCTSTR)objectContent.MemoryContent.ContentBytes,
                                                       PFF_NO_PATTERNS_ALLOWED);
                filteredName = IsmFilterObject (g_FileType | PLATFORM_SOURCE,
                                                objectName,
                                                NULL,
                                                NULL,
                                                NULL);
                if (filteredName) {
                    IsmCreateObjectStringsFromHandle (filteredName, &srcNode, &srcLeaf);
                    IsmDestroyObjectHandle (filteredName);
                } else {
                    IsmCreateObjectStringsFromHandle (objectName, &srcNode, &srcLeaf);
                }
                srcFile = JoinPaths (srcNode, srcLeaf);

                IsmDestroyObjectString (srcNode);
                IsmDestroyObjectString (srcLeaf);
                IsmDestroyObjectHandle (objectName);
            }
            IsmReleaseObject (&objectContent);
        }

        //
        // Get the dest WAB filename
        //
        if (srcFile) {
            if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                                  lpWABObjectName,
                                  &objectContent)) {
                if (IsValidRegSz (&objectContent)) {
                    destFile = DuplicateText ((PCTSTR)objectContent.MemoryContent.ContentBytes);
                }
                IsmReleaseObject (&objectContent);
            }
        }

        if (destFile) {
            // If we are upgrading from an old WAB version, and the destination does not have
            // a new WAB already, then we need to supply a new filename to WABOpen

            // if srcFile = destFile, then we wrote destFile during migration, which means it
            // didn't exist before.  They would not otherwise be equal, because we'd filename
            // collide the wab
            if (StringIMatch (srcFile, destFile)) {
                fNewOE = TRUE;

                defaultWABPath = GetStringResource (OE_DEFAULT_WAB_PATH);
                if (defaultWABPath) {
                    destPath = IsmExpandEnvironmentString (
                        PLATFORM_DESTINATION,
                        S_SYSENVVAR_GROUP,
                        defaultWABPath,
                        NULL);

                    FreeStringResource (defaultWABPath);
                }

                FreeText (destFile);
                destFile = AllocText (TcharCount(destPath) + TcharCount(DEFAULTWAB) + 1);
                StringCopy (destFile, destPath);
                StringCat (destFile, DEFAULTWAB);

                if StringIMatch (srcFile, destFile) {
//                    Crud!  Now what?
                    // We should name collide the default wab filename in this case, which
                    // would mean allocating a bigger destFile
                }
                if (!DoesFileExist (destPath)) {
                    BfCreateDirectory (destPath);
                }

                IsmReleaseMemory (destPath);

                // Set HKCU\Software\Microsoft\WAB\WAB4\Wab File Name [] = destFile
                ZeroMemory (&objectContent, sizeof(MIG_CONTENT));
                objectContent.ObjectTypeId = g_RegType;
                objectContent.Details.DetailsSize = sizeof(DWORD);
                objectContent.Details.DetailsData = IsmGetMemory (sizeof(DWORD));
                *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
                objectContent.MemoryContent.ContentSize = SizeOfString (destFile);
                objectContent.MemoryContent.ContentBytes = IsmGetMemory (objectContent.MemoryContent.ContentSize);
                CopyMemory ((PVOID)objectContent.MemoryContent.ContentBytes,
                            destFile,
                            objectContent.MemoryContent.ContentSize);

                objectName = IsmCreateObjectHandle(TEXT("HKCU\\Software\\Microsoft\\WAB\\WAB4\\Wab File Name"),
                                                   TEXT(""));
                if (objectName) {
                    IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
                    IsmDestroyObjectHandle (objectName);
                }
                IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
                IsmReleaseMemory (objectContent.Details.DetailsData);
            }
        }

        if (destFile) {
            // Get the WAB32.DLL location
            wabKey = JoinPaths (TEXT("HKLM"), WAB_DLL_PATH_KEY);
            objectName = IsmCreateObjectHandle (wabKey, TEXT(""));
            FreePathString (wabKey);
            if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                                  objectName,
                                  &objectContent)) {
                if (IsValidRegSz (&objectContent)) {
                    wabPath = DuplicateText ((PCTSTR)objectContent.MemoryContent.ContentBytes);
                }
                IsmReleaseObject (&objectContent);
            }
            IsmDestroyObjectHandle (objectName);
        }

        if (wabPath) {
            // Loadlibrary the DLL
            lib = LoadLibrary (wabPath);
            if (lib) {

                // Open the destination WAB
                lpfnWABOpen = (LPWABOPEN) GetProcAddress (lib, "WABOpen");
                if (lpfnWABOpen) {
                    ZeroMemory (&wabParams, sizeof (WAB_PARAM));
                    wabParams.cbSize = sizeof (WAB_PARAM);
                    if (!fNewOE) {
                        wabParams.ulFlags = WAB_ENABLE_PROFILES | MAPI_UNICODE;
                    }
#ifdef UNICODE
                    wabParams.szFileName = (PSTR) ConvertWtoA (destFile);
#else
                    wabParams.szFileName = (PSTR) destFile;
#endif
                    hr = lpfnWABOpen (&lpAdrBookWAB, &lpWABObject, &wabParams, 0);
#ifdef UNICODE
                    FreeConvertedStr (wabParams.szFileName);
#endif
                    if (hr == S_OK) {

                        // Import the source WAB
                        ZeroMemory (&wabImportParam, sizeof (WABIMPORTPARAM));
                        wabImportParam.cbSize = sizeof (WABIMPORTPARAM);
                        wabImportParam.lpAdrBook = lpAdrBookWAB;
#ifdef UNICODE
                        wabImportParam.lpszFileName = (PSTR) ConvertWtoA (srcFile);
#else
                        wabImportParam.lpszFileName = (PSTR) srcFile;
#endif
                        hr = lpWABObject->lpVtbl->Import (lpWABObject, (LPSTR)&wabImportParam);
#ifdef UNICODE
                    FreeConvertedStr (wabImportParam.lpszFileName);
#endif
                        if (hr == S_OK) {
                            if (!StringIMatch (srcFile, destFile)) {
                                // Delete the source WAB
                                DeleteFile (srcFile);
                            }
                        } else {
                            // Log a message that the user must manually import the WAB
                            LOG ((LOG_WARNING, (PCSTR) MSG_WAB_MERGE_FAILED, srcFile));
                        }

                        lpWABObject->lpVtbl->Release (lpWABObject);
                        lpAdrBookWAB->lpVtbl->Release (lpAdrBookWAB);
                    }
                }
                FreeLibrary (lib);
            }
        }

        if (srcFile) {
            FreePathString (srcFile);
        }
        if (destFile) {
            FreeText (destFile);
        }
        if (wabPath) {
            FreeText (wabPath);
        }
        if (lpWABObjectName) {
            IsmDestroyObjectHandle (lpWABObjectName);
        }
    }
}

PCTSTR
pBuildDefaultStoreRoot (
    IN      PCTSTR Guid,
    IN      BOOL GuidHasBrackets
    )
{
    PTSTR storeRoot = NULL;
    PCTSTR storeBegin = NULL;
    UINT charCount;

    // output should be "%UserProfile%\Local Settings\Application Data\Identities\{guid}\Microsoft\Outlook Express"

#define STOREEND   TEXT("\\Microsoft\\Outlook Express")

    storeBegin = GetStringResource (OE_DEFAULT_ID_PATH);
    if (storeBegin) {
        storeRoot = AllocText(TcharCount(storeBegin) +
                              TcharCount(Guid) +
                              TcharCount(STOREEND) +
                              (GuidHasBrackets ? 1 : 3));
        if (!storeRoot) {
            // Out of memory?
            return NULL;
        }
        StringCopy (storeRoot, storeBegin);
        FreeStringResource (storeBegin);
    }
    if (FALSE == GuidHasBrackets) {
        StringCat (storeRoot, TEXT("{"));
    }
    StringCat (storeRoot, Guid);
    if (FALSE == GuidHasBrackets) {
        StringCat (storeRoot, TEXT("}"));
    }
    StringCat (storeRoot, STOREEND);

    return storeRoot;
}

BOOL
pOE5Import (
    IN     PCTSTR SourceDir,
    IN     PCTSTR DestDir,
    IN     PCTSTR DestIdentity
    )
{
    UUID uid;
    BOOL result = FALSE;
    PSTR szSrcPath;
    PSTR szDestPath;

    MIG_CONTENT dllObjectContent;
    MIG_OBJECTSTRINGHANDLE dllObjectName = NULL;
    PCTSTR dllExpPath = NULL;
    PTSTR dllTmpPath = NULL;
    IMailImport *mailImport = NULL;
    static LPOECREATE lpfnOE5SimpleCreate = NULL;
    static LPIMPORTSTORE lpfnImportMailStoreToGUID = NULL;
    static LPIMPORTNEWS lpfnImportNewsListToGUID = NULL;

    if (g_msoedll == NULL) {
        CoInitialize(NULL);
        g_CoInit = TRUE;

        dllObjectName = IsmCreateObjectHandle (TEXT("HKLM\\Software\\Microsoft\\Outlook Express"),
                                               TEXT("InstallRoot"));
        if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                              dllObjectName,
                              &dllObjectContent)) {
            // dllObjectContent should be "%ProgramFiles%\\Outlook Express"

            if (IsValidRegSz (&dllObjectContent)) {
                dllExpPath = IsmExpandEnvironmentString(PLATFORM_DESTINATION,
                                                        S_SYSENVVAR_GROUP,
                                                        (PCTSTR)dllObjectContent.MemoryContent.ContentBytes,
                                                        NULL);
            }
            if (dllExpPath) {

                dllTmpPath = JoinPaths (dllExpPath, TEXT("oemiglib.dll"));
                if (dllTmpPath) {
                    g_oemiglib = LoadLibrary(dllTmpPath);
                    FreePathString (dllTmpPath);
                }

                dllTmpPath = JoinPaths (dllExpPath, TEXT("msoe.dll"));
                if (dllTmpPath) {
                    g_msoedll = LoadLibrary(dllTmpPath);
                    FreePathString (dllTmpPath);
                }

                IsmReleaseMemory (dllExpPath);
            }
            IsmReleaseObject (&dllObjectContent);
        }
        IsmDestroyObjectHandle (dllObjectName);

        if (g_msoedll && g_oemiglib) {
            lpfnOE5SimpleCreate = (LPOECREATE) GetProcAddress (g_oemiglib, "OE5SimpleCreate");
            lpfnImportMailStoreToGUID = (LPIMPORTSTORE) GetProcAddress (g_msoedll, "ImportMailStoreToGUID");
            lpfnImportNewsListToGUID = (LPIMPORTNEWS) GetProcAddress (g_msoedll, "ImportNewsListToGUID");
        }
    }

    if (DestDir) {
        if (lpfnOE5SimpleCreate &&
            lpfnImportMailStoreToGUID &&
            lpfnImportNewsListToGUID) {

            // Convert to GUID *
            if (pUuidFromBracketedString(DestIdentity, &uid)) {
#ifdef UNICODE
                szSrcPath = (PSTR) ConvertWtoA (SourceDir);
                szDestPath = (PSTR) ConvertWtoA (DestDir);
#else
                szSrcPath = (PSTR) SourceDir;
                szDestPath = (PSTR) DestDir;
#endif
                mailImport = lpfnOE5SimpleCreate(szSrcPath);

                if (mailImport) {
                    lpfnImportMailStoreToGUID(mailImport, &uid, szDestPath);
                    IMailImport_Release(mailImport);
                    mailImport = NULL;
                    result = TRUE;
                }

                lpfnImportNewsListToGUID (szSrcPath, &uid, szDestPath);
#ifdef UNICODE
                FreeConvertedStr (szSrcPath);
                FreeConvertedStr (szDestPath);
#endif
            }
        }
        if (SourceDir && DestDir) {
            // Copy source folder to dest folder, but never overwrite
            if (!DoesFileExist (DestDir)) {
                BfCreateDirectory (DestDir);
            }
            FiCopyAllFilesInTreeEx(SourceDir, DestDir, TRUE);
        }
    }

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////
// OE5MergeStorefolders
// This cycles through every store folder and decides whether to just copy it to the
// destination or merge into an existing store folder in the destination
VOID
OE5MergeStoreFolders (
    VOID
    )
{
    TCHAR szGuid[37];
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_CONTENT objectContent;
    MIG_CONTENT destObjectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    PTSTR srcStoreRoot = NULL;
    PCTSTR destStoreRoot = NULL;
    PCTSTR destFolderFile = NULL;
    PTSTR node;
    PTSTR leaf;
    PTSTR junk;
    PCTSTR expandedName = NULL;
    BOOL fImport;


    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        // Enumerate each source Store Folder
        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKCU\\Identities"),
                          TRUE,
                          TEXT("Store Root"),
                          FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               fImport = FALSE;

               IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
               if (leaf && *leaf) {
                   if (IsmAcquireObject (g_RegType | PLATFORM_SOURCE, objectEnum.ObjectName, &objectContent)) {
                       if (IsValidRegSz (&objectContent)) {
                           expandedName = IsmExpandEnvironmentString (
                               PLATFORM_SOURCE,
                               S_SYSENVVAR_GROUP,
                               (PCTSTR)objectContent.MemoryContent.ContentBytes,
                               NULL);
                       }
                       if (expandedName) {
                           objectName = IsmCreateObjectHandle(expandedName, NULL);
                           IsmReleaseMemory (expandedName);
                           expandedName = NULL;
                       }

                       if (objectName) {
                           filteredName = IsmFilterObject (g_FileType | PLATFORM_SOURCE,
                                                            objectName,
                                                            NULL,
                                                            NULL,
                                                            NULL);

                           if (filteredName) {
                               IsmCreateObjectStringsFromHandle (filteredName, &srcStoreRoot, &junk);
                               // srcStoreRoot is now the source directory

                               IsmDestroyObjectHandle (filteredName);
                               filteredName = NULL;
                           } else {
                               IsmCreateObjectStringsFromHandle(objectName, &srcStoreRoot, &junk);
                           }

                           if (junk) {
                               IsmDestroyObjectString (junk);
                               junk = NULL;
                           }

                           IsmDestroyObjectHandle (objectName);
                           objectName = NULL;
                       }

                       // Now check to see if the dest Store Root previously existed
                       if (srcStoreRoot) {
                           filteredName = IsmFilterObject (g_RegType | PLATFORM_SOURCE,
                                                           objectEnum.ObjectName,
                                                           NULL,
                                                           NULL,
                                                           NULL);

                           // Extract GUID out of destination object name
                           _stscanf(filteredName ? filteredName : objectEnum.ObjectName,
                                    TEXT("%*[^{]{%[^}]"),
                                    szGuid);
                           // szGuid is now the destination identity guid, minus the {}

                           if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                                                 filteredName ? filteredName : objectEnum.ObjectName,
                                                 &destObjectContent)) {
                               if (IsValidRegSz (&destObjectContent)) {
                                   destStoreRoot = IsmExpandEnvironmentString (
                                       PLATFORM_DESTINATION,
                                       S_SYSENVVAR_GROUP,
                                       (PCTSTR)destObjectContent.MemoryContent.ContentBytes,
                                       NULL);
                               }
                               if (destStoreRoot) {
                                   destFolderFile = JoinPaths(destStoreRoot, TEXT("folders.dbx"));
                               }
                               if (destFolderFile) {
                                   if ((!StringIMatch(srcStoreRoot, destStoreRoot)) &&
                                       (DoesFileExist(destFolderFile))) {
                                       fImport = TRUE;
                                   }
                                   FreePathString(destFolderFile);
                               }
                               IsmReleaseObject (&destObjectContent);
                           }
                       }

                       if (szGuid[0]) {
                           if (!fImport) {
                               // This is a FIRST migration, so set the dest store root to default
                               IsmReleaseMemory(destStoreRoot);
                               destStoreRoot = pBuildDefaultStoreRoot(szGuid, FALSE);

                               // Set [StoreRoot] = destStoreRoot
                               ZeroMemory (&destObjectContent, sizeof(MIG_CONTENT));
                               destObjectContent.ObjectTypeId = g_RegType;
                               destObjectContent.Details.DetailsSize = sizeof(DWORD);
                               destObjectContent.Details.DetailsData = IsmGetMemory (sizeof(DWORD));
                               *((PDWORD)destObjectContent.Details.DetailsData) = REG_EXPAND_SZ;
                               destObjectContent.MemoryContent.ContentSize = SizeOfString (destStoreRoot);
                               destObjectContent.MemoryContent.ContentBytes = (PBYTE)destStoreRoot;

                               IsmReplacePhysicalObject (g_RegType,
                                                         filteredName ? filteredName : objectEnum.ObjectName,
                                                         &destObjectContent);
                               IsmDestroyObjectHandle (objectName);

                               // expand environment on destStoreRoot
                               FreeText(destStoreRoot);

                               destStoreRoot = IsmExpandEnvironmentString (
                                   PLATFORM_DESTINATION,
                                   S_SYSENVVAR_GROUP,
                                   (PCTSTR)destObjectContent.MemoryContent.ContentBytes,
                                   NULL);

                               // Cleanup the objectContent we allocated
                               IsmReleaseMemory (destObjectContent.Details.DetailsData);
                           }

                           if (srcStoreRoot && destStoreRoot) {
                               if (!DoesFileExist (destStoreRoot)) {
                                   BfCreateDirectory (destStoreRoot);
                               }
                               pOE5Import(srcStoreRoot, destStoreRoot, szGuid);
                           }
                       }


                       if (filteredName) {
                           IsmDestroyObjectHandle(filteredName);
                           filteredName = NULL;
                       }

                       if (destStoreRoot) {
                           IsmReleaseMemory(destStoreRoot);
                           destStoreRoot = NULL;
                       }

                       if (srcStoreRoot) {
                           IsmDestroyObjectString (srcStoreRoot);
                           srcStoreRoot = NULL;
                       }

                       IsmReleaseObject (&objectContent);
                   }
               }
               IsmDestroyObjectString (node);
               IsmDestroyObjectString (leaf);
           } while (IsmEnumNextObject (&objectEnum));

           // Remove temp folder
           expandedName = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, OETEMPDIR, NULL);
           if (expandedName) {
               FiRemoveAllFilesInTree (expandedName);
               IsmReleaseMemory (expandedName);
           } else {
               FiRemoveAllFilesInTree (OETEMPDIR);
           }
        }
        IsmDestroyObjectHandle (enumPattern);
    }
}

VOID
OE4MergeStoreFolder (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE regKey;
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_OBJECTSTRINGHANDLE filteredName;
    MIG_CONTENT objectContent;
    HANDLE h;
    PCTSTR srcStorePath = NULL;
    PCTSTR expPath = NULL;
    PTSTR destIdentity = NULL;
    PTSTR tmpStr = NULL;
    PTSTR tmpNode = NULL;
    PTSTR cmdLine = NULL;
    PCTSTR sid = NULL;
    DWORD exitCode;
    DWORD cmdLen;
    TCHAR tmpDir[MAX_PATH];
    PCTSTR destDir = NULL;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE4_APPDETECT)) {

        objectName = IsmCreateObjectHandle (TEXT("HKLM\\Software\\Microsoft\\Outlook Express"),
                                            TEXT("InstallRoot"));
        if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                              objectName,
                              &objectContent)) {

            // objectContent should be "%ProgramFiles%\\Outlook Express"

            if (IsValidRegSz (&objectContent)) {
                tmpStr = JoinPaths (objectContent.MemoryContent.ContentBytes, TEXT("oemig50.exe"));

                // tmpStr should be "%ProgramFiles%\\OutlookExpress\\oemig50.exe"
                expPath = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, tmpStr, NULL);

                FreePathString (tmpStr);
            }
            IsmReleaseObject (&objectContent);
        }
        IsmDestroyObjectHandle (objectName);

        // Get the dest identity
        if (expPath) {
            destIdentity = OEGetDefaultId (PLATFORM_DESTINATION);
        }

        // Now get the source's Store Root
        if (destIdentity) {
            objectName = IsmCreateObjectHandle (TEXT("HKCU\\Software\\Microsoft\\Outlook Express"),
                                                TEXT("Store Root"));
            if (IsmAcquireObject (g_RegType | PLATFORM_SOURCE,
                                  objectName,
                                  &objectContent)) {
                if (IsValidRegSz (&objectContent)) {
                    IsmDestroyObjectHandle (objectName);
                    objectName = IsmCreateObjectHandle ((PCTSTR) objectContent.MemoryContent.ContentBytes,
                                                        NULL);
                    filteredName = IsmFilterObject (g_FileType | PLATFORM_SOURCE,
                                                    objectName,
                                                    NULL,
                                                    NULL,
                                                    NULL);
                    if (filteredName) {
                        IsmCreateObjectStringsFromHandle (filteredName, &srcStorePath, NULL);
                        IsmDestroyObjectHandle (filteredName);
                    } else {
                        IsmCreateObjectStringsFromHandle (objectName, &srcStorePath, NULL);
                    }
                }
                IsmReleaseObject (&objectContent);
            }
            IsmDestroyObjectHandle (objectName);
        }

        // Now grab a temporary place to stuff the upgraded files
        IsmGetTempDirectory(tmpDir, ARRAYSIZE(tmpDir));

        // Call the external upgrade exe
        if (srcStorePath != NULL &&
            expPath != NULL) {


            sid = IsmGetCurrentSidString();

            cmdLen =  TcharCount(expPath) + TcharCount(srcStorePath) + TcharCount(tmpDir) + 35;
            if (sid) {
                cmdLen += TcharCount(sid) + 6;
            }
            cmdLine = AllocText (cmdLen);
            StringCopy (cmdLine, expPath);
            StringCat (cmdLine, TEXT(" /type:V1+V4-V5 /src:"));  // 21
            StringCat (cmdLine, srcStorePath);
            StringCat (cmdLine, TEXT(" /dst:"));                 // 6
            StringCat (cmdLine, tmpDir);
            StringCat (cmdLine, TEXT(" /quiet"));                // 7
            if (sid) {
                StringCat (cmdLine, TEXT(" /key:"));             // (6)
                StringCat (cmdLine, sid);
            }

            LOG ((LOG_INFORMATION, (PCSTR) MSG_SPAWNING_PROCESS_INFO, cmdLine));

            h = StartProcess (cmdLine);
            if (h != NULL) {
                WaitForSingleObject (h, INFINITE);
                if (GetExitCodeProcess (h, &exitCode)) {
                    if ((exitCode != STILL_ACTIVE) && ((exitCode & 0xFFFF) != 800 )) {
                        LOG ((LOG_ERROR, (PCSTR)MSG_OE4_UPGRADE_FAILED));
                    }
                }
                CloseHandle (h);

                FreeText (cmdLine);

                // Cleanup the source store
                FiRemoveAllFilesInTree (srcStorePath);
            }

            destDir = pGetDestStoreRootForId(destIdentity);
            if (destDir) {
                if (!DoesFileExist (destDir)) {
                    // Just copy into to the dest dir
                    BfCreateDirectory (destDir);
                    FiCopyAllFilesInTreeEx(tmpDir, destDir, TRUE);
                } else {
                    // Now do an OE5 Import from tmpDir to destIdentity
                    pOE5Import(tmpDir, destDir, destIdentity);
                }
                FreeText(destDir);
            }
            FiRemoveAllFilesInTree (tmpDir);

            // Set [StoreMigratedV5] = 1
            // Set [ConvertedToDBX] = 1
            tmpStr = JoinText(TEXT("HKCU\\Identities\\"), destIdentity);
            if (tmpStr) {
                tmpNode = JoinText(tmpStr, TEXT("\\Software\\Microsoft\\Outlook Express\\5.0"));
                if (tmpNode) {
                    CreateDwordRegObject (tmpNode, TEXT("StoreMigratedV5"), 1);
                    CreateDwordRegObject (tmpNode, TEXT("ConvertedToDBX"), 1);
                    FreeText(tmpNode);
                }

                FreeText(tmpStr);
            }
        }

        if (destIdentity) {
            FreeText(destIdentity);
        }
        if (sid) {
            IsmReleaseMemory (sid);
        }
        if (expPath) {
            IsmReleaseMemory (expPath);
        }
        if (srcStorePath) {
            IsmDestroyObjectString (srcStorePath);
        }
    }
}

BOOL
OEIAMAssociateId (
    IN      PTSTR SrcId
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTTYPEID objectTypeId;
    MIG_CONTENT objectContent;
    PTSTR srcStr;
    TCHAR *p;
    UUID srcUUID;
    RPC_STATUS status;
    BOOL retval = FALSE;
    DWORD regType = REG_BINARY;

    if (pUuidFromBracketedString (SrcId, &srcUUID)) {
        // Create [AssociatedID] = Uuid

        objectTypeId = g_RegType | PLATFORM_DESTINATION;

        ZeroMemory(&objectContent, sizeof(MIG_CONTENT));

        objectContent.ContentInFile = FALSE;
        objectContent.MemoryContent.ContentSize = sizeof(UUID);
        objectContent.MemoryContent.ContentBytes = IsmGetMemory(sizeof(UUID));
        CopyMemory ((PVOID)objectContent.MemoryContent.ContentBytes, &srcUUID, sizeof(UUID));
        objectContent.Details.DetailsData = &regType;

        objectName = IsmCreateObjectHandle (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"),
                                            TEXT("AssociatedID"));
        if (objectName) {
            retval = IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
            IsmDestroyObjectHandle (objectName);
            g_DestAssociatedId = DuplicateText(SrcId);
        }

        IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);
    }
    return retval;
}

BOOL
OEIsIdentityAssociated (
    IN      PTSTR IdStr
    )
{
    BOOL associated = FALSE;

    if (!g_DestAssociatedId) {
        g_DestAssociatedId = OEGetAssociatedId(PLATFORM_DESTINATION);
    }

    if (g_DestAssociatedId) {
        associated = StringIMatch(IdStr, g_DestAssociatedId);
    } else {
        // Apparently there is no associated ID.  Let's claim it.
        OEIAMAssociateId(IdStr);
        associated = TRUE;
    }
    return associated;
}

PTSTR
OEGetRemappedId(
    IN      PCTSTR IdStr
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTSTRINGHANDLE filteredName;
    PTSTR tmpName;
    PTSTR node;
    PTSTR leaf;
    PTSTR result = NULL;
    TCHAR *p;

    tmpName = JoinText(TEXT("HKCU\\Identities\\"), IdStr);
    if (tmpName) {
        objectName = IsmCreateObjectHandle(tmpName, NULL);
        if (objectName) {
            filteredName = IsmFilterObject(g_RegType | PLATFORM_SOURCE,
                                           objectName,
                                           NULL,
                                           NULL,
                                           NULL);
            if (filteredName) {
                IsmCreateObjectStringsFromHandle (filteredName, &node, &leaf);
                if (node) {
                    p = (PTSTR)FindLastWack(node);
                    if (p) {
                        result = DuplicateText(_tcsinc(p));
                    }
                    IsmDestroyObjectString(node);
                }
                if (leaf) {
                    IsmDestroyObjectString (leaf);
                }
                IsmDestroyObjectHandle(filteredName);
            } else {
                result = DuplicateText(IdStr);
            }
            IsmDestroyObjectHandle (objectName);
        }
        FreeText(tmpName);
    }
    return result;
}

PTSTR
OEGetDefaultId (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PTSTR retval = NULL;


    objectName = IsmCreateObjectHandle (TEXT("HKCU\\Identities"),
                                        TEXT("Default User ID"));
    if (objectName) {
        if (IsmAcquireObject ( g_RegType | Platform, objectName, &objectContent)) {
            if (IsValidRegSz(&objectContent)) {
                retval = DuplicateText((PTSTR)objectContent.MemoryContent.ContentBytes);
            }
            IsmReleaseObject (&objectContent);
        }
        IsmDestroyObjectHandle (objectName);
    }
    return retval;
}

PTSTR
OEGetAssociatedId (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    PTSTR uuidStr;
    PTSTR retval = NULL;

    objectName = IsmCreateObjectHandle (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"),
                                        TEXT("AssociatedID"));
    if (objectName) {
        if (IsmAcquireObject ( g_RegType | Platform, objectName, &objectContent)) {
            if (IsValidRegType(&objectContent, REG_BINARY)) {
                if (RPC_S_OK == UuidToString ((UUID *)objectContent.MemoryContent.ContentBytes, &uuidStr)) {
                   retval = AllocText(CharCount(uuidStr) + 3);
                   if (retval) {
                       StringCopy(retval, TEXT("{"));
                       StringCat(retval, uuidStr);
                       StringCat(retval, TEXT("}"));
                   }
                   RpcStringFree(&uuidStr);
                }
            }
            IsmReleaseObject (&objectContent);
        }
        IsmDestroyObjectHandle (objectName);
    }

    return retval;
}

VOID
OETerminate (
    VOID
    )
{
    if (g_DestAssociatedId) {
        FreeText(g_DestAssociatedId);
    }
    if (g_msoedll) {
        FreeLibrary(g_msoedll);
        g_msoedll = NULL;
    }
    if (g_oemiglib) {
        FreeLibrary(g_oemiglib);
        g_oemiglib = NULL;
    }
    if (g_CoInit) {
        CoUninitialize();
        g_CoInit = FALSE;
    }

}

pRenameRegTreePattern (
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      PCMIG_BLOB SrcBlob,
    IN      PCMIG_BLOB DestBlob,
    IN      BOOL ReplaceOld
)
{
    MIG_OBJECT_ENUM objectEnum;

    if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, Pattern)) {
        if (!g_RenameOp) {
            g_RenameOp = IsmRegisterOperation (S_OPERATION_MOVE, FALSE);
        }

        do {
            // Set operation on all source objects in this ID
            if (ReplaceOld) {
                IsmClearOperationOnObject(g_RegType | PLATFORM_SOURCE,
                                          objectEnum.ObjectName,
                                          g_RenameOp);
            }
            IsmSetOperationOnObject(g_RegType | PLATFORM_SOURCE,
                                    objectEnum.ObjectName,
                                    g_RenameOp,
                                    SrcBlob,
                                    DestBlob);
        } while (IsmEnumNextObject(&objectEnum));
    }
}

pRenameRegTree (
    IN      PCTSTR SrcIdName,
    IN      PCTSTR DestIdName,
    IN      BOOL ReplaceOld
)
{
    MIG_BLOB srcBlob;
    MIG_BLOB destBlob;
    MIG_OBJECTSTRINGHANDLE pattern;


    srcBlob.Type = BLOBTYPE_STRING;
    srcBlob.String = IsmCreateObjectHandle(SrcIdName, NULL);
    if (srcBlob.String) {
        destBlob.Type = BLOBTYPE_STRING;
        destBlob.String = IsmCreateObjectHandle(DestIdName, NULL);
        if (destBlob.String) {

            // Recursive
            pattern = IsmCreateSimpleObjectPattern(SrcIdName, TRUE, NULL, TRUE);
            if (pattern) {
                pRenameRegTreePattern(pattern, &srcBlob, &destBlob, ReplaceOld);
                IsmDestroyObjectHandle(pattern);
            }

            // Now for the node's values
            pattern = IsmCreateSimpleObjectPattern(SrcIdName, FALSE, NULL, TRUE);
            if (pattern) {
                pRenameRegTreePattern(pattern, &srcBlob, &destBlob, ReplaceOld);
                IsmDestroyObjectHandle(pattern);
            }

            // Now for only the node itself
            pattern = IsmCreateSimpleObjectPattern(SrcIdName, FALSE, NULL, FALSE);
            if (pattern) {
                pRenameRegTreePattern(pattern, &srcBlob, &destBlob, ReplaceOld);
                IsmDestroyObjectHandle(pattern);
            }
            IsmDestroyObjectHandle(destBlob.String);
        }
        IsmDestroyObjectHandle(srcBlob.String);
    }
}

BOOL
pClearApply (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL result = FALSE;

    objectName = IsmCreateObjectHandle(Node, Leaf);
    if (objectName) {
        IsmClearApplyOnObject((g_RegType & (~PLATFORM_MASK)) | PLATFORM_SOURCE, objectName);
        IsmDestroyObjectHandle (objectName);
        result = TRUE;
    }

    return result;
}

BOOL
OE5RemapDefaultId (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE destObjectName;
    MIG_OBJECTSTRINGHANDLE pattern;
    MIG_CONTENT destIdObjectContent;
    PTSTR idName;
    PTSTR destIdName;
    PTSTR srcDefaultId;
    PTSTR destDefaultId;
    MIG_OBJECT_ENUM objectEnum;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        srcDefaultId = OEGetDefaultId(PLATFORM_SOURCE);
        if (srcDefaultId) {
            destDefaultId = OEGetDefaultId(PLATFORM_DESTINATION);
            if (destDefaultId) {
                if (!StringIMatch (srcDefaultId, destDefaultId)) {
                    // different default IDs
                    idName = JoinText(TEXT("HKCU\\Identities\\"), srcDefaultId);
                    if (idName) {
                        destObjectName = IsmCreateObjectHandle(idName, NULL);
                        if (IsmAcquireObject(
                            g_RegType | PLATFORM_DESTINATION,
                            destObjectName,
                            &destIdObjectContent)) {

                            // The source ID already exists on the dest.. do nothing extra
                            IsmReleaseObject(&destIdObjectContent);
                        } else {
                            // Remap this identity into destination default
                            destIdName = JoinText(TEXT("HKCU\\Identities\\"),
                                                  destDefaultId);
                            if (destIdName) {
                                pRenameRegTree(idName, destIdName, TRUE);
                                FreeText(destIdName);
                            }
                            pClearApply(TEXT("HKCU\\Identities"), TEXT("Default User ID"));
                            pClearApply(TEXT("HKCU\\Identities"), TEXT("Last User ID"));
                            pClearApply(TEXT("HKCU\\Identities"), TEXT("Last Username"));

                            // ForceDestReg the top level Identities values
                            pattern = IsmCreateSimpleObjectPattern(idName, FALSE, NULL, TRUE);
                            if (pattern) {
                                if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, pattern)) {
                                    do {
                                        IsmClearApplyOnObject(
                                            (g_RegType & (~PLATFORM_MASK)) | PLATFORM_SOURCE,
                                            objectEnum.ObjectName);
                                    } while (IsmEnumNextObject(&objectEnum));
                                }
                                IsmDestroyObjectHandle(pattern);
                            }
                        }
                        IsmDestroyObjectHandle(destObjectName);
                        FreeText(idName);
                    }
                }
                FreeText(destDefaultId);
            }
            FreeText(srcDefaultId);
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// pOE5RemapRules
// This adds a renregfn rule for \ConvertOE5MailRules to
//     HKCU\Identities\{*}\Software\Microsoft\Outlook Express\5.0\Rules\Mail\*
// ditto for News rules
// Also for Block Senders\Mail\Criteria\* and News
BOOL
pOE5RemapRules (
    VOID
    )
{
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECTSTRINGHANDLE subPattern;
    PTSTR tmpNode;
    PTSTR node;
    PTSTR leaf;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        // Find HKCU\Identities\{*}\Software\Microsoft\Outlook Express\5.0\Rules\Mail\*
        // First enum each identity
        enumPattern = IsmCreateSimpleObjectPattern (TEXT("HKCU\\Identities"), TRUE,
                                                    TEXT("User ID"), FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
               if (node && leaf) {
                   // Enum the Rules keys under this identity
                   tmpNode = JoinText(node, TEXT("\\Software\\Microsoft\\Outlook Express\\5.0\\Rules\\Mail"));
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5MailRules"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
                   tmpNode = JoinText(node, TEXT("\\Software\\Microsoft\\Outlook Express\\5.0\\Rules\\News"));
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5NewsRules"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
                   tmpNode = JoinText(
                       node,
                       TEXT("\\Software\\Microsoft\\Outlook Express\\5.0\\Block Senders\\Mail\\Criteria")
                       );
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5Block"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
                   tmpNode = JoinText(
                       node,
                       TEXT("\\Software\\Microsoft\\Outlook Express\\5.0\\Block Senders\\News\\Criteria")
                       );
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5Block"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
               }
               IsmDestroyObjectString(node);
               if (leaf) {
                   IsmDestroyObjectString(leaf);
               }
           } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);
    }
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////
// pOE5RemapAccounts
// This adds a renregfn rule for \ConvertOE5IdIAM to
//     HKCU\Identities\{*}\Software\Microsoft\Internet Account Manager\*
BOOL
pOE5RemapAccounts (
    VOID
    )
{
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECTSTRINGHANDLE subPattern;
    PTSTR tmpNode;
    PTSTR node;
    PTSTR leaf;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        // Find HKCU\Identities\{*}\Software\Microsoft\Internet Account Manger\*
        // First enum each identity
        enumPattern = IsmCreateSimpleObjectPattern (TEXT("HKCU\\Identities"), TRUE,
                                                    TEXT("User ID"), FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
               if (node && leaf) {
                   // Enum the IAM keys under this identity
                   tmpNode = JoinText(node, TEXT("\\Software\\Microsoft\\Internet Account Manager"));
                   if (tmpNode) {
                       subPattern = IsmCreateSimpleObjectPattern (tmpNode, TRUE, NULL, TRUE);
                       if (subPattern) {
                           AddSpecialRenameRule (subPattern, TEXT("\\ConvertOE5IdIAM"));
                           IsmDestroyObjectHandle(subPattern);
                       }
                       FreeText(tmpNode);
                   }
               }
               IsmDestroyObjectString(node);
               if (leaf) {
                   IsmDestroyObjectString(leaf);
               }
           } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// OECreateFirstIdentity
// This is used to create the very first identity for a user that we just created
PTSTR
OECreateFirstIdentity (
    VOID
    )
{
    PTSTR destID = NULL;
    PTSTR uuidStr;
    UUID uuid;
    RPC_STATUS result;
    MIG_OBJECTSTRINGHANDLE objectName = NULL;
    MIG_CONTENT objectContent;
    PTSTR node;
    PCTSTR defaultStore;

    result = UuidCreate (&uuid);
    if (result == RPC_S_OK || result == RPC_S_UUID_LOCAL_ONLY) {
        result = UuidToString (&uuid, &uuidStr);
        if (result == RPC_S_OK) {
            destID = AllocText (CharCount (uuidStr) + 3);
            wsprintf (destID, TEXT("{%s}"), uuidStr);
            RpcStringFree (&uuidStr);
        }
    }
    if (destID) {
        // Create [Default User ID] = &destID
        ZeroMemory (&objectContent, sizeof(MIG_CONTENT));
        objectContent.ObjectTypeId = g_RegType;
        objectContent.Details.DetailsSize = sizeof(DWORD);
        objectContent.Details.DetailsData = IsmGetMemory (sizeof(DWORD));
        *((PDWORD)objectContent.Details.DetailsData) = REG_SZ;
        objectContent.MemoryContent.ContentSize = SizeOfString (destID);
        objectContent.MemoryContent.ContentBytes = IsmGetMemory (objectContent.MemoryContent.ContentSize);
        CopyMemory ((PVOID)objectContent.MemoryContent.ContentBytes, destID, objectContent.MemoryContent.ContentSize);

        objectName = IsmCreateObjectHandle(TEXT("HKCU\\Identities"), TEXT("Default User ID"));
        if (objectName) {
            IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
            IsmDestroyObjectHandle (objectName);
            objectName = NULL;
        }

        // Set [Last User ID] = &destID
        objectName = IsmCreateObjectHandle(TEXT("HKCU\\Identities"), TEXT("Last User ID"));
        if (objectName) {
            IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
            IsmDestroyObjectHandle (objectName);
            objectName = NULL;
        }
        // Create [User ID] = &destID
        node = JoinPaths (TEXT("HKCU\\Identities"), destID);
        if (node) {
            objectName = IsmCreateObjectHandle(node,  TEXT("User ID"));
            FreePathString (node);
        }
        if (objectName) {
            IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
            IsmDestroyObjectHandle (objectName);
            objectName = NULL;
        }

        IsmReleaseMemory (objectContent.MemoryContent.ContentBytes);

        // Set [Store Root] = %UserProfile%\Local Settings\Application Data\Identities\&destID\Microsoft\Outlook Express
        defaultStore = pBuildDefaultStoreRoot(destID, TRUE);
        if (defaultStore) {
            objectContent.MemoryContent.ContentBytes = (PCBYTE)defaultStore;
            objectContent.MemoryContent.ContentSize = SizeOfString(defaultStore);
            *((PDWORD)objectContent.Details.DetailsData) = REG_EXPAND_SZ;

            node = JoinPathsInPoolEx ((
                        NULL,
                        TEXT("HKCU\\Identities"),
                        destID,
                        TEXT("Software\\Microsoft\\Outlook Express\\5.0"),
                        NULL
                        ));
            if (node) {
                objectName = IsmCreateObjectHandle(node, TEXT("Store Root"));
                FreePathString (node);
            }
            if (objectName) {
                IsmReplacePhysicalObject (g_RegType, objectName, &objectContent);
                IsmDestroyObjectHandle (objectName);
            }
            FreeText(defaultStore);
        }
        IsmReleaseMemory (objectContent.Details.DetailsData);

        OEIAMAssociateId (destID);
    }

    return destID;
}


//////////////////////////////////////////////////////////////////////////////////////
// OEInitializeIdentity
// This is used to initialize a destination identity that has been created but never used.
BOOL
OEInitializeIdentity (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE storeRootKey = NULL;
    MIG_CONTENT objectContent;
    PCTSTR defaultId;
    PCTSTR defaultStoreRoot;
    BOOL reinit = TRUE;

    defaultId = OEGetDefaultId (PLATFORM_DESTINATION);
    if (defaultId) {
        storeRootKey = pBuildStoreRootKeyForId (defaultId);
        if (storeRootKey) {
            if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, storeRootKey, &objectContent)) {
                if (IsValidRegSz(&objectContent)) {
                    reinit = FALSE;
                }
                IsmReleaseObject (&objectContent);
            }

            if (reinit) {
                defaultStoreRoot = pBuildDefaultStoreRoot (defaultId, TRUE);
                if (defaultStoreRoot) {
                    ZeroMemory (&objectContent, sizeof(MIG_CONTENT));
                    objectContent.ObjectTypeId = g_RegType;
                    objectContent.Details.DetailsSize = sizeof(DWORD);
                    objectContent.Details.DetailsData = IsmGetMemory (sizeof(DWORD));
                    *((PDWORD)objectContent.Details.DetailsData) = REG_EXPAND_SZ;
                    objectContent.MemoryContent.ContentSize = SizeOfString (defaultStoreRoot);
                    objectContent.MemoryContent.ContentBytes = (PBYTE)defaultStoreRoot;

                    IsmReplacePhysicalObject (g_RegType, storeRootKey, &objectContent);

                    IsmReleaseMemory (objectContent.Details.DetailsData);
                    FreeText(defaultStoreRoot);
                }
            }
            IsmDestroyObjectHandle(storeRootKey);
        }
        FreeText(defaultId);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// pOE5RemapStores
// This is used to set a special RegFolder rule for the OE5 [Store Root] values
// The rule will redirect all store folders into a temporary directory.  Later,
// OE5MergeStorefolders will decide whether to copy or merge them into the proper
// location on the destination
BOOL
pOE5RemapStores (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECT_ENUM objectEnum;
    PTSTR node;
    PTSTR leaf;
    TCHAR tmpDir[MAX_PATH];
    BOOL result = FALSE;
    ACTION_STRUCT actionStruct;
    DWORD index = 0;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT)) {

        // Find HKCU\Identities\* [Store Root]
        // First enum each identity
        enumPattern = IsmCreateSimpleObjectPattern (TEXT("HKCU\\Identities"), TRUE,
                                                    TEXT("Store Root"), FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
               if (node && leaf) {
                   // Regfolder the rule with a destination to a unique TEMP directory
                   // Grab a temporary place to copy the mail store
                   wsprintf(tmpDir, TEXT("%s\\%03x"), OETEMPDIR, index++);

                   ZeroMemory(&actionStruct, sizeof(ACTION_STRUCT));
                   actionStruct.ObjectBase = objectEnum.ObjectName;
                   actionStruct.AddnlDest = TurnFileStringIntoHandle (
                                tmpDir,
                                PFF_COMPUTE_BASE|
                                    PFF_NO_SUBDIR_PATTERN|
                                    PFF_NO_PATTERNS_ALLOWED|
                                    PFF_NO_LEAF_AT_ALL
                                );
                   result = AddRule (g_RegType,
                                     objectEnum.ObjectName,
                                     objectEnum.ObjectName,
                                     ACTIONGROUP_INCFOLDER,
                                     ACTION_PERSIST_PATH_IN_DATA,
                                     &actionStruct);
               }
               IsmDestroyObjectString(node);
               if (leaf) {
                   IsmDestroyObjectString(leaf);
               }
           } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);
    }
    return result;
}

BOOL
OEAddComplexRules (
    VOID
    )
{
    pOE5RemapRules();
    pOE5RemapAccounts();
    pOE5RemapStores();
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////
// OEFixLastUser
// If for some reason the [Last User ID] value is set to zeroes or does not exist,
// we'll copy in the [Default User ID] value.  If we dont do this, we'll get a popup
// during migration asking the user to select an identity, which would be really bad.
BOOL
OEFixLastUser (
    VOID
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    MIG_OBJECTSTRINGHANDLE defName;
    MIG_CONTENT defContent;
    BOOL fFix = FALSE;

    if (IsmIsComponentSelected (S_OE_COMPONENT, 0) &&
        (IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE4_APPDETECT) ||
         IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OE5_APPDETECT))) {

        objectName = IsmCreateObjectHandle (TEXT("HKCU\\Identities"), TEXT("Last User ID"));
        if (objectName) {
            if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, objectName, &objectContent)) {
                if (IsValidRegSz(&objectContent) &&
                    StringMatch((PCTSTR)objectContent.MemoryContent.ContentBytes,
                                TEXT("{00000000-0000-0000-0000-000000000000}"))) {
                    fFix = TRUE;
                }
                IsmReleaseObject (&objectContent);
            } else {
                fFix = TRUE;
            }

            if (fFix) {
                defName = IsmCreateObjectHandle (TEXT("HKCU\\Identities"), TEXT("Default User ID"));
                if (defName) {
                    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, defName, &defContent)) {
                        if (IsValidRegSz (&defContent)) {
                            IsmReplacePhysicalObject (g_RegType, objectName, &defContent);
                        }
                        IsmReleaseObject (&defContent);
                    }
                    IsmDestroyObjectHandle (defName);
                }
            }
            IsmDestroyObjectHandle (objectName);
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\cert.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cert.c

Abstract:

    Implements the certificates type module, which abstracts physical access to
    certificates

Author:

    Calin Negreanu (calinn) 03 Oct 2001

Revision History:

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"
#include "logmsg.h"
#include <wincrypt.h>

#define DBG_CERT            "Certificates"

//
// Strings
//

#define S_CERT_POOL_NAME    "Certificates"
#define S_CERT_NAME         TEXT("Certificates")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    HCERTSTORE StoreHandle;
    PCTSTR CertStore;
    PCTSTR CertPattern;
    PCCERT_CONTEXT CertContext;
} CERT_ENUM, *PCERT_ENUM;

// Certificate APIs

// NT4 SP3
// Win95 OSR2
typedef HCERTSTORE(WINAPI CERTOPENSTORE) (
                            IN      LPCSTR lpszStoreProvider,
                            IN      DWORD dwMsgAndCertEncodingType,
                            IN      HCRYPTPROV hCryptProv,
                            IN      DWORD dwFlags,
                            IN      const void *pvPara
                            );
typedef CERTOPENSTORE *PCERTOPENSTORE;

// NT4 SP3
// Win95 OSR2
typedef PCCERT_CONTEXT(WINAPI CERTENUMCERTIFICATESINSTORE) (
                                    IN      HCERTSTORE hCertStore,
                                    IN      PCCERT_CONTEXT pPrevCertContext
                                    );
typedef CERTENUMCERTIFICATESINSTORE *PCERTENUMCERTIFICATESINSTORE;

// NT4 SP3
// Win95 OSR2
typedef BOOL(WINAPI CERTGETCERTIFICATECONTEXTPROPERTY) (
                        IN      PCCERT_CONTEXT pCertContext,
                        IN      DWORD dwPropId,
                        OUT     void *pvData,
                        IN OUT  DWORD *pcbData
                        );
typedef CERTGETCERTIFICATECONTEXTPROPERTY *PCERTGETCERTIFICATECONTEXTPROPERTY;

// NT4 SP3
// Win95 OSR2
typedef BOOL(WINAPI CERTCLOSESTORE) (
                        IN      HCERTSTORE hCertStore,
                        IN      DWORD dwFlags
                        );
typedef CERTCLOSESTORE *PCERTCLOSESTORE;

// NT4 SP3
typedef BOOL(WINAPI CRYPTACQUIRECERTIFICATEPRIVATEKEY) (
                        IN      PCCERT_CONTEXT pCert,
                        IN      DWORD dwFlags,
                        IN      void *pvReserved,
                        OUT     HCRYPTPROV *phCryptProv,
                        OUT     DWORD *pdwKeySpec,
                        OUT     BOOL *pfCallerFreeProv
                        );
typedef CRYPTACQUIRECERTIFICATEPRIVATEKEY *PCRYPTACQUIRECERTIFICATEPRIVATEKEY;

// NT4 SP3
// Win95 OSR2
typedef BOOL(WINAPI CERTADDCERTIFICATECONTEXTTOSTORE) (
                        IN      HCERTSTORE hCertStore,
                        IN      PCCERT_CONTEXT pCertContext,
                        IN      DWORD dwAddDisposition,
                        OUT     PCCERT_CONTEXT *ppStoreContext
                        );
typedef CERTADDCERTIFICATECONTEXTTOSTORE *PCERTADDCERTIFICATECONTEXTTOSTORE;

// NT4 SP3
// Win95 OSR2
typedef BOOL(WINAPI CERTFREECERTIFICATECONTEXT) (
                        IN      PCCERT_CONTEXT pCertContext
                        );
typedef CERTFREECERTIFICATECONTEXT *PCERTFREECERTIFICATECONTEXT;

// NT4 SP3
// Win95 OSR2
typedef BOOL(WINAPI CERTDELETECERTIFICATEFROMSTORE) (
                        IN      PCCERT_CONTEXT pCertContext
                        );
typedef CERTDELETECERTIFICATEFROMSTORE *PCERTDELETECERTIFICATEFROMSTORE;

// Win2k?
// Win98?
typedef BOOL(WINAPI PFXEXPORTCERTSTORE) (
                        IN      HCERTSTORE hStore,
                        IN OUT  CRYPT_DATA_BLOB* pPFX,
                        IN      LPCWSTR szPassword,
                        IN      DWORD dwFlags
                        );
typedef PFXEXPORTCERTSTORE *PPFXEXPORTCERTSTORE;

// Win2k?
// Win98?
typedef HCERTSTORE(WINAPI PFXIMPORTCERTSTORE) (
                            IN      CRYPT_DATA_BLOB* pPFX,
                            IN      PCWSTR szPassword,
                            IN      DWORD dwFlags
                            );
typedef PFXIMPORTCERTSTORE *PPFXIMPORTCERTSTORE;

//
// Globals
//

PMHANDLE g_CertPool = NULL;
BOOL g_DelayCertOp;
MIG_OBJECTTYPEID g_CertType = 0;
GROWBUFFER g_CertConversionBuff = INIT_GROWBUFFER;

PCERTOPENSTORE g_CertOpenStore = NULL;
PCERTENUMCERTIFICATESINSTORE g_CertEnumCertificatesInStore = NULL;
PCERTGETCERTIFICATECONTEXTPROPERTY g_CertGetCertificateContextProperty = NULL;
PCERTCLOSESTORE g_CertCloseStore = NULL;
PCRYPTACQUIRECERTIFICATEPRIVATEKEY g_CryptAcquireCertificatePrivateKey = NULL;
PCERTADDCERTIFICATECONTEXTTOSTORE g_CertAddCertificateContextToStore = NULL;
PCERTFREECERTIFICATECONTEXT g_CertFreeCertificateContext = NULL;
PCERTDELETECERTIFICATEFROMSTORE g_CertDeleteCertificateFromStore = NULL;
PPFXEXPORTCERTSTORE g_PFXExportCertStore = NULL;
PPFXIMPORTCERTSTORE g_PFXImportCertStore = NULL;

//
// Types
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Private prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstCertificate;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextCertificate;
TYPE_ABORTENUMPHYSICALOBJECT AbortCertificateEnum;
TYPE_CONVERTOBJECTTOMULTISZ ConvertCertificateToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToCertificate;
TYPE_GETNATIVEOBJECTNAME GetNativeCertificateName;
TYPE_ACQUIREPHYSICALOBJECT AcquireCertificate;
TYPE_RELEASEPHYSICALOBJECT ReleaseCertificate;
TYPE_DOESPHYSICALOBJECTEXIST DoesCertificateExist;
TYPE_REMOVEPHYSICALOBJECT RemoveCertificate;
TYPE_CREATEPHYSICALOBJECT CreateCertificate;
TYPE_CONVERTOBJECTCONTENTTOUNICODE ConvertCertificateContentToUnicode;
TYPE_CONVERTOBJECTCONTENTTOANSI ConvertCertificateContentToAnsi;
TYPE_FREECONVERTEDOBJECTCONTENT FreeConvertedCertificateContent;

//
// Code
//

BOOL
CertificatesInitialize (
    VOID
    )

/*++

Routine Description:

  CertificateInitialize is the ModuleInitialize entry point for the certificates
  module.

Arguments:

  None.

Return Value:

  TRUE if init succeeded, FALSE otherwise.

--*/

{
    g_CertPool = PmCreateNamedPool (S_CERT_POOL_NAME);
    return (g_CertPool != NULL);
}

VOID
CertificatesTerminate (
    VOID
    )

/*++

Routine Description:

  CertificatesTerminate is the ModuleTerminate entry point for the certificates module.

Arguments:

  None.

Return Value:

  None.

--*/

{
    GbFree (&g_CertConversionBuff);

    if (g_CertPool) {
        PmDestroyPool (g_CertPool);
        g_CertPool = NULL;
    }
}

VOID
WINAPI
CertificatesEtmNewUserCreated (
    IN      PCTSTR UserName,
    IN      PCTSTR DomainName,
    IN      PCTSTR UserProfileRoot,
    IN      PSID UserSid
    )

/*++

Routine Description:

  CertificatesEtmNewUserCreated is a callback that gets called when a new user
  account is created. In this case, we must delay the apply of certificates,
  because we can only apply to the current user.

Arguments:

  UserName        - Specifies the name of the user being created
  DomainName      - Specifies the NT domain name for the user (or NULL for no
                    domain)
  UserProfileRoot - Specifies the root path to the user profile directory
  UserSid         - Specifies the user's SID

Return Value:

  None.

--*/

{
    // a new user was created, the certificate operations need to be delayed
    g_DelayCertOp = TRUE;
}

BOOL
pLoadCertEntries (
    VOID
    )
{
    HMODULE cryptDll = NULL;
    BOOL result = FALSE;

    __try {
        cryptDll = LoadLibrary (TEXT("CRYPT32.DLL"));
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        cryptDll = NULL;
    }
    if (cryptDll) {
        g_CertOpenStore = (PCERTOPENSTORE) GetProcAddress (cryptDll, "CertOpenStore");
        g_CertEnumCertificatesInStore = (PCERTENUMCERTIFICATESINSTORE) GetProcAddress (cryptDll, "CertEnumCertificatesInStore");
        g_CertGetCertificateContextProperty = (PCERTGETCERTIFICATECONTEXTPROPERTY) GetProcAddress (cryptDll, "CertGetCertificateContextProperty");
        g_CertCloseStore = (PCERTCLOSESTORE) GetProcAddress (cryptDll, "CertCloseStore");
        g_CryptAcquireCertificatePrivateKey = (PCRYPTACQUIRECERTIFICATEPRIVATEKEY) GetProcAddress (cryptDll, "CryptAcquireCertificatePrivateKey");
        g_CertAddCertificateContextToStore = (PCERTADDCERTIFICATECONTEXTTOSTORE) GetProcAddress (cryptDll, "CertAddCertificateContextToStore");
        g_CertFreeCertificateContext = (PCERTFREECERTIFICATECONTEXT) GetProcAddress (cryptDll, "CertFreeCertificateContext");
        g_PFXExportCertStore = (PPFXEXPORTCERTSTORE) GetProcAddress (cryptDll, "PFXExportCertStore");
        g_CertDeleteCertificateFromStore = (PCERTDELETECERTIFICATEFROMSTORE) GetProcAddress (cryptDll, "CertDeleteCertificateFromStore");
        g_PFXImportCertStore = (PPFXIMPORTCERTSTORE) GetProcAddress (cryptDll, "PFXImportCertStore");

        // BUGBUG - verify that all functions are installed
    } else {
        DEBUGMSG ((DBG_CERT, "Crypt APIs are not installed on this computer."));
    }
    return result;
}

BOOL
WINAPI
CertificatesEtmInitialize (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )

/*++

Routine Description:

  CertificatesEtmInitialize initializes the physical type module aspect of this
  code. The ETM module is responsible for abstracting all access to certificates.

Arguments:

  Platform    - Specifies the platform that the type is running on
                (PLATFORM_SOURCE or PLATFORM_DESTINATION)
  LogCallback - Specifies the arg to pass to the central logging mechanism
  Reserved    - Unused

Return Value:

  TRUE if initialization succeeded, FALSE otherwise.

--*/

{
    TYPE_REGISTER certTypeData;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    //
    // Register the type module callbacks
    //

    ZeroMemory (&certTypeData, sizeof (TYPE_REGISTER));
    certTypeData.Priority = PRIORITY_CERTIFICATES;

    if (Platform != PLATFORM_SOURCE) {
        certTypeData.RemovePhysicalObject = RemoveCertificate;
        certTypeData.CreatePhysicalObject = CreateCertificate;
    }

    certTypeData.DoesPhysicalObjectExist = DoesCertificateExist;
    certTypeData.EnumFirstPhysicalObject = EnumFirstCertificate;
    certTypeData.EnumNextPhysicalObject = EnumNextCertificate;
    certTypeData.AbortEnumPhysicalObject = AbortCertificateEnum;
    certTypeData.ConvertObjectToMultiSz = ConvertCertificateToMultiSz;
    certTypeData.ConvertMultiSzToObject = ConvertMultiSzToCertificate;
    certTypeData.GetNativeObjectName = GetNativeCertificateName;
    certTypeData.AcquirePhysicalObject = AcquireCertificate;
    certTypeData.ReleasePhysicalObject = ReleaseCertificate;
    certTypeData.ConvertObjectContentToUnicode = ConvertCertificateContentToUnicode;
    certTypeData.ConvertObjectContentToAnsi = ConvertCertificateContentToAnsi;
    certTypeData.FreeConvertedObjectContent = FreeConvertedCertificateContent;

    g_CertType = IsmRegisterObjectType (
                        S_CERT_NAME,
                        TRUE,
                        FALSE,
                        &certTypeData
                        );

    MYASSERT (g_CertType);

    pLoadCertEntries ();

    return TRUE;
}

BOOL
pFillCertEnumPtr (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PCERT_ENUM CertEnum,
    IN      PCTSTR CertName
    )
{
    BOOL result = FALSE;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmReleaseMemory (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        IsmReleaseMemory (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }

    EnumPtr->ObjectLeaf = IsmDuplicateString (CertName);

    EnumPtr->ObjectName = IsmCreateObjectHandle (CertEnum->CertStore, EnumPtr->ObjectLeaf);
    EnumPtr->ObjectNode = CertEnum->CertStore;
    EnumPtr->NativeObjectName = GetNativeCertificateName (EnumPtr->ObjectName);
    GetNodePatternMinMaxLevels (CertEnum->CertStore, NULL, &EnumPtr->Level, NULL);
    EnumPtr->SubLevel = 0;
    EnumPtr->IsLeaf = TRUE;
    EnumPtr->IsNode = TRUE;
    EnumPtr->Details.DetailsSize = 0;
    EnumPtr->Details.DetailsData = NULL;

    return TRUE;
}

PCTSTR
pGetCertName (
    IN      PCCERT_CONTEXT CertContext
    )
{
    PTSTR result = NULL;
    PTSTR resultPtr = NULL;
    UINT i;

    if (!CertContext) {
        return NULL;
    }
    if (!CertContext->pCertInfo) {
        return NULL;
    }
    if (!CertContext->pCertInfo->SerialNumber.cbData) {
        return NULL;
    }
    result = PmGetMemory (g_CertPool, CertContext->pCertInfo->SerialNumber.cbData * 3 * sizeof (TCHAR));
    if (result) {
        resultPtr = result;
        *resultPtr = 0;
        for (i = CertContext->pCertInfo->SerialNumber.cbData; i > 0; i--) {
            wsprintf (resultPtr, TEXT("%02x"), CertContext->pCertInfo->SerialNumber.pbData[i - 1]);
            resultPtr = GetEndOfString (resultPtr);
            if (i > 1) {
                _tcscat (resultPtr, TEXT(" "));
                resultPtr = GetEndOfString (resultPtr);
            }
        }
    }
    return result;
}

BOOL
pGetNextCertFromStore (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,
    IN      PCERT_ENUM CertEnum
    )
{
    PCTSTR name = NULL;
    DWORD nameSize = 0;
    BOOL result = FALSE;

    do {
        // do we have the API?
        if (g_CertEnumCertificatesInStore == NULL) {
            return FALSE;
        }

        CertEnum->CertContext = g_CertEnumCertificatesInStore (CertEnum->StoreHandle, CertEnum->CertContext);
        if (!CertEnum->CertContext) {
            return FALSE;
        }

        // let's get the certificate "name". This is actually the serial number made
        // into a string. This is the only unique thing that I could see.
        name = pGetCertName (CertEnum->CertContext);
        if (!name) {
            return FALSE;
        }

        if (IsPatternMatchEx (CertEnum->CertPattern, name)) {
            break;
        }

    } while (TRUE);

    result = pFillCertEnumPtr (EnumPtr, CertEnum, name);

    PmReleaseMemory (g_CertPool, name);
    name = NULL;

    return result;
}

HCERTSTORE
pOpenCertStore (
    IN      PCTSTR CertStore,
    IN      BOOL Create
    )
{
    PCWSTR certStoreW = NULL;
    HCERTSTORE result = NULL;

    __try {
        // let's do the UNICODE conversion if needed
#ifndef UNICODE
        certStoreW = ConvertAtoW (CertStore);
#endif

        // do we have the API?
        if (g_CertOpenStore != NULL) {
            // now let's understand what kind of store is this
            // First we try to see if this is a file
            if (DoesFileExist (CertStore)) {
                // it is a file, open it
                // first we try current user
                result = g_CertOpenStore (
                                CERT_STORE_PROV_FILENAME,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                0,
                                Create?CERT_SYSTEM_STORE_CURRENT_USER:CERT_SYSTEM_STORE_CURRENT_USER|CERT_STORE_OPEN_EXISTING_FLAG,
#ifdef UNICODE
                                CertStore
#else
                                certStoreW
#endif
                                );
            } else {
                // we assume it's a system store
                result = g_CertOpenStore (
                                CERT_STORE_PROV_SYSTEM,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                0,
                                Create?CERT_SYSTEM_STORE_CURRENT_USER:CERT_SYSTEM_STORE_CURRENT_USER|CERT_STORE_OPEN_EXISTING_FLAG,
#ifdef UNICODE
                                CertStore
#else
                                certStoreW
#endif
                                );
                if (result == NULL) {
                    // now we try HKLM
                    result = g_CertOpenStore (
                                    CERT_STORE_PROV_SYSTEM,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    0,
                                    Create?CERT_SYSTEM_STORE_LOCAL_MACHINE:CERT_SYSTEM_STORE_LOCAL_MACHINE|CERT_STORE_OPEN_EXISTING_FLAG,
#ifdef UNICODE
                                    CertStore
#else
                                    certStoreW
#endif
                                    );
                }
            }
        }
    }
    __finally {
        if (certStoreW) {
            FreeConvertedStr (certStoreW);
            certStoreW = NULL;
        }
    }
    return result;
}

BOOL
EnumFirstCertificate (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr,            CALLER_INITIALIZED
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      UINT MaxLevel
    )
{
    PCTSTR certStore, certPattern;
    PCWSTR certStoreW = NULL;
    PCERT_ENUM certEnum = NULL;
    BOOL result = FALSE;

    if (!IsmCreateObjectStringsFromHandle (
            Pattern,
            &certStore,
            &certPattern
            )) {
        return FALSE;
    }

    if (certStore && certPattern) {

        __try {

            certEnum = (PCERT_ENUM) PmGetMemory (g_CertPool, sizeof (CERT_ENUM));
            if (!certEnum) {
                __leave;
            }
            ZeroMemory (certEnum, sizeof (CERT_ENUM));
            certEnum->CertStore = PmDuplicateString (g_CertPool, certStore);
            certEnum->CertPattern = PmDuplicateString (g_CertPool, certPattern);
            EnumPtr->EtmHandle = (LONG_PTR) certEnum;

            certEnum->StoreHandle = pOpenCertStore (certStore, FALSE);
            if (certEnum->StoreHandle == NULL) {
                __leave;
            }

            result = pGetNextCertFromStore (EnumPtr, certEnum);
        }
        __finally {
            if (certStoreW) {
                FreeConvertedStr (certStoreW);
                certStoreW = NULL;
            }
        }
    }

    IsmDestroyObjectString (certStore);
    IsmDestroyObjectString (certPattern);

    if (!result) {
        AbortCertificateEnum (EnumPtr);
    }

    return result;
}

BOOL
EnumNextCertificate (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PCERT_ENUM certEnum = NULL;
    BOOL result = FALSE;

    certEnum = (PCERT_ENUM)(EnumPtr->EtmHandle);
    if (!certEnum) {
        return FALSE;
    }

    result = pGetNextCertFromStore (EnumPtr, certEnum);

    return result;
}

VOID
AbortCertificateEnum (
    IN      PMIG_TYPEOBJECTENUM EnumPtr             ZEROED
    )
{
    PCERT_ENUM certEnum;

    if (EnumPtr->ObjectName) {
        IsmDestroyObjectHandle (EnumPtr->ObjectName);
        EnumPtr->ObjectName = NULL;
    }
    if (EnumPtr->ObjectLeaf) {
        IsmReleaseMemory (EnumPtr->ObjectLeaf);
        EnumPtr->ObjectLeaf = NULL;
    }
    if (EnumPtr->NativeObjectName) {
        IsmReleaseMemory (EnumPtr->NativeObjectName);
        EnumPtr->NativeObjectName = NULL;
    }

    certEnum = (PCERT_ENUM)(EnumPtr->EtmHandle);
    if (certEnum) {
        if (certEnum->StoreHandle && g_CertCloseStore) {
            g_CertCloseStore (certEnum->StoreHandle, CERT_CLOSE_STORE_FORCE_FLAG);
        }
        if (certEnum->CertStore) {
            PmReleaseMemory (g_CertPool, certEnum->CertStore);
            certEnum->CertStore = NULL;
        }
        if (certEnum->CertPattern) {
            PmReleaseMemory (g_CertPool, certEnum->CertPattern);
            certEnum->CertPattern = NULL;
        }
        if (certEnum->CertContext) {
            if (g_CertFreeCertificateContext) {
                g_CertFreeCertificateContext (certEnum->CertContext);
            }
        }
        PmReleaseMemory (g_CertPool, certEnum);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}


/*++

  The next set of functions implement the ETM entry points to acquire, test,
  create and remove certificates.

--*/

BOOL
pDoesPrivateKeyExist (
    IN      PCCERT_CONTEXT CertContext
    )
{
    DWORD data = 0;
    BOOL result = FALSE;

    // do we have the API?
    if (!g_CertGetCertificateContextProperty) {
        return FALSE;
    }

    result = g_CertGetCertificateContextProperty (
                CertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &data
                );
    return result;
}

BOOL
pIsPrivateKeyExportable (
    IN      PCCERT_CONTEXT CertContext
    )
{
    HCRYPTPROV cryptProv = 0;
    DWORD keySpec = 0;
    HCRYPTKEY keyHandle = 0;
    BOOL callerFreeProv = FALSE;
    DWORD permissions = 0;
    DWORD size = 0;
    BOOL result = FALSE;

    // do we have the API?
    if (!g_CryptAcquireCertificatePrivateKey) {
        // we don't have the API, let's assume it is
        // exportable.
        return TRUE;
    }

    if (g_CryptAcquireCertificatePrivateKey (
            CertContext,
            CRYPT_ACQUIRE_USE_PROV_INFO_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,
            &cryptProv,
            &keySpec,
            &callerFreeProv
            )) {

        if (CryptGetUserKey (cryptProv, keySpec, &keyHandle)) {

            size = sizeof (permissions);
            if (CryptGetKeyParam (keyHandle, KP_PERMISSIONS, (PBYTE)&permissions, &size, 0)) {
                result = ((permissions & CRYPT_EXPORT) != 0);
            }

            if (keyHandle != 0) {
                CryptDestroyKey(keyHandle);
                keyHandle = 0;
            }
        }

        if (callerFreeProv != 0) {
            CryptReleaseContext(cryptProv, 0);
            cryptProv = 0;
        }
    }
    return result;
}

PCBYTE
pGetCertificateData (
    IN      PCCERT_CONTEXT CertContext,
    IN      BOOL ExportPrivateKey,
    IN      PCWSTR Password,
    OUT     PDWORD DataSize
    )
{
    HCERTSTORE memoryStore;
    CRYPT_DATA_BLOB dataBlob;
    PCBYTE result = NULL;

    if (!DataSize) {
        return NULL;
    }

    __try {

        // do we have the API?
        if (!g_CertOpenStore) {
            __leave;
        }

        // first we create a memory store and put this certificate there
        memoryStore = g_CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        0,
                        0,
                        0,
                        NULL
                        );
        if (memoryStore == NULL) {
            __leave;
        }

        // do we have the API?
        if (!g_CertAddCertificateContextToStore) {
            __leave;
        }

        if (!g_CertAddCertificateContextToStore (
                memoryStore,
                CertContext,
                CERT_STORE_ADD_REPLACE_EXISTING,
                NULL
                )) {
            __leave;
        }

        // now we export the store using PFXExportCertStore
        ZeroMemory (&dataBlob, sizeof (CRYPT_DATA_BLOB));

        // do we have the API?
        if (!g_PFXExportCertStore) {
            __leave;
        }

        // get the needed size
        if (!g_PFXExportCertStore (
                memoryStore,
                &dataBlob,
                Password,
                ExportPrivateKey?EXPORT_PRIVATE_KEYS:0
                )) {
            __leave;
        }

        dataBlob.pbData = PmGetMemory (g_CertPool, dataBlob.cbData);
        if (!dataBlob.pbData) {
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        // now get the actual data
        if (!g_PFXExportCertStore (
                memoryStore,
                &dataBlob,
                Password,
                ExportPrivateKey?EXPORT_PRIVATE_KEYS:0
                )) {
            __leave;
        }

        // now we have the data
        *DataSize = dataBlob.cbData;
        result = dataBlob.pbData;

    }
    __finally {
        PushError ();
        if (memoryStore && g_CertCloseStore) {
            g_CertCloseStore (memoryStore, CERT_CLOSE_STORE_FORCE_FLAG);
            memoryStore = NULL;
        }
        if (!result) {
            if (dataBlob.pbData) {
                PmReleaseMemory (g_CertPool, dataBlob.pbData);
                dataBlob.pbData = NULL;
            }
        }
        PopError ();
    }

    return result;
}

PCCERT_CONTEXT
pGetCertContext (
    IN      HCERTSTORE StoreHandle,
    IN      PCTSTR CertName
    )
{
    PCTSTR certName;
    PCCERT_CONTEXT result = NULL;

    // do we have the API?
    if (!g_CertEnumCertificatesInStore) {
        return FALSE;
    }

    // basically we are going to enumerate the certificates until we find the one
    // that we need
    result = g_CertEnumCertificatesInStore (StoreHandle, result);
    while (result) {
        certName = pGetCertName (result);
        if (StringIMatch (CertName, certName)) {
            PmReleaseMemory (g_CertPool, certName);
            break;
        }
        PmReleaseMemory (g_CertPool, certName);
        result = g_CertEnumCertificatesInStore (StoreHandle, result);
    }
    return result;
}

BOOL
pAcquireCertFromStore (
    IN      HCERTSTORE StoreHandle,
    IN      PCTSTR CertName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      UINT MemoryContentLimit
    )
{
    PCCERT_CONTEXT certContext = NULL;
    PCTSTR certName;
    BOOL exportPrivateKey = FALSE;
    DWORD dataSize = 0;
    PCBYTE dataBytes = NULL;
    BOOL result = FALSE;

    certContext = pGetCertContext (StoreHandle, CertName);
    if (!certContext) {
        return FALSE;
    }

    // we found it. Let's build the data.
    exportPrivateKey = pDoesPrivateKeyExist (certContext) && pIsPrivateKeyExportable (certContext);

    dataBytes = pGetCertificateData (certContext, exportPrivateKey, L"USMT", &dataSize);
    if (dataBytes) {
        // let's build the object content
        ObjectContent->MemoryContent.ContentSize = dataSize;
        ObjectContent->MemoryContent.ContentBytes = dataBytes;
        result = TRUE;
    }

    if (g_CertFreeCertificateContext) {
        g_CertFreeCertificateContext (certContext);
    }

    return result;
}

BOOL
AcquireCertificate (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,             CALLER_INITIALIZED
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    HCERTSTORE storeHandle = NULL;
    PCTSTR certStore = NULL, certName = NULL;
    PCCERT_CONTEXT certContext;
    BOOL result = FALSE;

    if (!ObjectContent) {
        return FALSE;
    }

    if (ContentType == CONTENTTYPE_FILE) {
        // nobody should request this as a file
        MYASSERT (FALSE);
        return FALSE;
    }

    if (!IsmCreateObjectStringsFromHandle (
            ObjectName,
            &certStore,
            &certName
            )) {
        return FALSE;
    }

    if (certStore && certName) {

        __try {

            storeHandle = pOpenCertStore (certStore, FALSE);
            if (!storeHandle) {
                __leave;
            }

            result = pAcquireCertFromStore (storeHandle, certName, ObjectContent, MemoryContentLimit);
        }
        __finally {
            if (storeHandle && g_CertCloseStore) {
                g_CertCloseStore (storeHandle, CERT_CLOSE_STORE_FORCE_FLAG);
                storeHandle = NULL;
            }
        }
    }

    IsmDestroyObjectString (certStore);
    IsmDestroyObjectString (certName);

    return result;
}

BOOL
ReleaseCertificate (
    IN      PMIG_CONTENT ObjectContent              ZEROED
    )
{
    if (ObjectContent) {
        if (ObjectContent->MemoryContent.ContentBytes) {
            PmReleaseMemory (g_CertPool, ObjectContent->MemoryContent.ContentBytes);
        }
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return TRUE;
}

BOOL
DoesCertificateExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    HCERTSTORE storeHandle = NULL;
    PCCERT_CONTEXT certContext = NULL;
    PCTSTR certStore = NULL, certName = NULL;
    BOOL result = FALSE;

    if (g_DelayCertOp) {
        return FALSE;
    }

    if (!IsmCreateObjectStringsFromHandle (
            ObjectName,
            &certStore,
            &certName
            )) {
        return FALSE;
    }

    if (certStore && certName) {

        __try {

            storeHandle = pOpenCertStore (certStore, FALSE);
            if (!storeHandle) {
                __leave;
            }

            certContext = pGetCertContext (storeHandle, certName);
            if (!certContext) {
                __leave;
            }
            result = TRUE;
        }
        __finally {
            if (certContext && g_CertFreeCertificateContext) {
                g_CertFreeCertificateContext (certContext);
                certContext = NULL;
            }
            if (storeHandle && g_CertCloseStore) {
                g_CertCloseStore (storeHandle, CERT_CLOSE_STORE_FORCE_FLAG);
                storeHandle = NULL;
            }
        }
    }

    IsmDestroyObjectString (certStore);
    IsmDestroyObjectString (certName);

    return result;
}

BOOL
RemoveCertificate (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    HCERTSTORE storeHandle = NULL;
    PCCERT_CONTEXT certContext;
    PCTSTR certStore = NULL, certName = NULL;
    BOOL result = FALSE;

    if (g_DelayCertOp) {

        //
        // delay this certificate create because cert apis do not work
        // for non-logged on users
        //

        IsmRecordDelayedOperation (
            JRNOP_DELETE,
            g_CertType,
            ObjectName,
            NULL
            );
        result = TRUE;

    } else {
        //
        // add journal entry, then perform certificate deletion
        //

        IsmRecordOperation (
            JRNOP_DELETE,
            g_CertType,
            ObjectName
            );

        if (IsmCreateObjectStringsFromHandle (
                ObjectName,
                &certStore,
                &certName
                )) {

            if (certStore && certName) {

                __try {

                    storeHandle = pOpenCertStore (certStore, FALSE);
                    if (!storeHandle) {
                        __leave;
                    }

                    certContext = pGetCertContext (storeHandle, certName);
                    if (!certContext) {
                        __leave;
                    }

                    if (g_CertDeleteCertificateFromStore &&
                        g_CertDeleteCertificateFromStore (certContext)
                        ) {
						// certContext is not valid any more
						certContext = NULL;
                        result = TRUE;
                    }
                }
                __finally {
                    if (certContext && g_CertFreeCertificateContext) {
                        g_CertFreeCertificateContext (certContext);
                        certContext = NULL;
                    }
                    if (storeHandle && g_CertCloseStore) {
                        g_CertCloseStore (storeHandle, CERT_CLOSE_STORE_FORCE_FLAG);
                        storeHandle = NULL;
                    }
                }
            }

            IsmDestroyObjectString (certStore);
            IsmDestroyObjectString (certName);
        }
    }

    return result;
}

HCERTSTORE
pBuildStoreFromData (
    PCRYPT_DATA_BLOB DataBlob,
    PCWSTR Password
    )
{
    HCERTSTORE result;

    // Do we have the API?
    if (!g_PFXImportCertStore) {
        return NULL;
    }

    result = g_PFXImportCertStore (
                DataBlob,
                Password,
                CRYPT_EXPORTABLE
                );

    return result;
}

BOOL
CreateCertificate (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    CRYPT_DATA_BLOB dataBlob;
    HCERTSTORE srcStoreHandle = NULL;
    HCERTSTORE destStoreHandle = NULL;
    PCCERT_CONTEXT certContext = NULL;
    PCTSTR certStore = NULL, certName = NULL;
    PTSTR certFile = NULL, certFileNode, certFilePtr;
    MIG_OBJECTSTRINGHANDLE certFileHandle, destCertFileHandle;
    BOOL result = FALSE;

    if (g_DelayCertOp) {

        //
        // delay this certificate create because cert apis do not work
        // for non-logged on users
        //

        IsmRecordDelayedOperation (
            JRNOP_CREATE,
            g_CertType,
            ObjectName,
            ObjectContent
            );
        result = TRUE;

    } else {
        //
        // add journal entry, then create the certificate
        //

        IsmRecordOperation (
            JRNOP_CREATE,
            g_CertType,
            ObjectName
            );

        if (ObjectContent && ObjectContent->MemoryContent.ContentSize && ObjectContent->MemoryContent.ContentBytes) {

            if (!IsmCreateObjectStringsFromHandle (
                    ObjectName,
                    &certStore,
                    &certName
                    )) {
                return FALSE;
            }

            if (certStore && certName) {

                __try {

                    // let's create the store from this data
                    dataBlob.cbData = ObjectContent->MemoryContent.ContentSize;
                    dataBlob.pbData = (PBYTE)ObjectContent->MemoryContent.ContentBytes;

                    srcStoreHandle = pBuildStoreFromData (&dataBlob, L"USMT");
                    if (!srcStoreHandle) {
                        __leave;
                    }

                    // now we need to figure out where the destination store is
                    // If it's a file we will filter it out and find out where
                    // the file is supposed to go.

                    if (IsValidFileSpec (certStore)) {
                        // looks like a file.
                        certFile = PmDuplicateString (g_CertPool, certStore);
                        if (certFile) {
                            certFilePtr = _tcsrchr (certFile, TEXT('\\'));
                            if (certFilePtr) {
                                *certFilePtr = 0;
                                certFilePtr ++;
                                certFileHandle = IsmCreateObjectHandle (certFile, certFilePtr);
                                if (certFileHandle) {
                                    destCertFileHandle = IsmFilterObject (MIG_FILE_TYPE, certFileHandle, NULL, NULL, NULL);
                                    if (destCertFileHandle) {
                                        PmReleaseMemory (g_CertPool, certFile);
                                        certFile = NULL;
                                        if (IsmCreateObjectStringsFromHandle (destCertFileHandle, &certFileNode, &certFilePtr)) {
                                            certFile = JoinPaths (certFileNode, certFilePtr);
                                            IsmDestroyObjectString (certFileNode);
                                            IsmDestroyObjectString (certFilePtr);
                                        }
                                    }
                                    IsmDestroyObjectHandle (certFileHandle);
                                } else {
                                    PmReleaseMemory (g_CertPool, certFile);
                                    certFile = NULL;
                                }
                            } else {
                                PmReleaseMemory (g_CertPool, certFile);
                                certFile = NULL;
                            }
                        }
                    }

                    destStoreHandle = pOpenCertStore (certFile?certFile:certStore, TRUE);
                    if (!destStoreHandle) {
                        __leave;
                    }

                    // Do we have the APIs?
                    if (g_CertEnumCertificatesInStore && g_CertAddCertificateContextToStore) {

                        // now let's enumerate the store and add the certificates into the
                        // system store
                        certContext = g_CertEnumCertificatesInStore (srcStoreHandle, certContext);
                        while (certContext) {

                            if (!g_CertAddCertificateContextToStore (
                                    destStoreHandle,
                                    certContext,
                                    CERT_STORE_ADD_REPLACE_EXISTING,
                                    NULL
                                    )) {
                                __leave;
                            }

                            certContext = g_CertEnumCertificatesInStore (srcStoreHandle, certContext);
                        }
                        result = TRUE;
                    }
                }
                __finally {
                    if (certContext && g_CertFreeCertificateContext) {
                        g_CertFreeCertificateContext (certContext);
                        certContext = NULL;
                    }
                    if (srcStoreHandle && g_CertCloseStore) {
                        g_CertCloseStore (srcStoreHandle, CERT_CLOSE_STORE_FORCE_FLAG);
                        srcStoreHandle = NULL;
                    }
                    if (destStoreHandle && g_CertCloseStore) {
                        g_CertCloseStore (destStoreHandle, CERT_CLOSE_STORE_FORCE_FLAG);
                        destStoreHandle = NULL;
                    }
                }
            }

            IsmDestroyObjectString (certStore);
            IsmDestroyObjectString (certName);
        }
    }

    return result;
}


/*++

  The next group of functions converts a certificate object into a string format,
  suitable for output to an INF file. The reverse conversion is also
  implemented.

--*/

PCTSTR
ConvertCertificateToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR certStore = NULL, certName = NULL;
    TCHAR tmpStr[3];
    UINT index;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &certStore, &certName)) {
        g_CertConversionBuff.End = 0;
        GbCopyQuotedString (&g_CertConversionBuff, certStore);
        GbCopyQuotedString (&g_CertConversionBuff, certName);
        if (ObjectContent && (!ObjectContent->ContentInFile) && ObjectContent->MemoryContent.ContentBytes) {
            index = 0;
            while (index < ObjectContent->MemoryContent.ContentSize) {
                wsprintf (tmpStr, TEXT("%02X"), ObjectContent->MemoryContent.ContentBytes [index]);
                GbCopyString (&g_CertConversionBuff, tmpStr);
                index ++;
            }
            GbCopyString (&g_CertConversionBuff, TEXT(""));
            result = IsmGetMemory (g_CertConversionBuff.End);
            CopyMemory (result, g_CertConversionBuff.Buf, g_CertConversionBuff.End);
        }
    }

    return result;
}

BOOL
ConvertMultiSzToCertificate (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent              OPTIONAL CALLER_INITIALIZED
    )
{
    MULTISZ_ENUM multiSzEnum;
    PCTSTR certStore = NULL;
    PCTSTR certName = NULL;
    DWORD dummy;
    UINT index;

    g_CertConversionBuff.End = 0;

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == 0) {
                certStore = multiSzEnum.CurrentString;
            }
            if (index == 1) {
                certName = multiSzEnum.CurrentString;
            }
            if (index >= 2) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                *((PBYTE)GbGrow (&g_CertConversionBuff, sizeof (BYTE))) = (BYTE)dummy;
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (!certStore) {
        return FALSE;
    }

    if (!certName) {
        return FALSE;
    }

    if (ObjectContent) {

        ObjectContent->ObjectTypeId = g_CertType;

        ObjectContent->ContentInFile = FALSE;
        ObjectContent->MemoryContent.ContentSize = g_CertConversionBuff.End;
        if (ObjectContent->MemoryContent.ContentSize) {
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            CopyMemory (
                (PBYTE)ObjectContent->MemoryContent.ContentBytes,
                g_CertConversionBuff.Buf,
                ObjectContent->MemoryContent.ContentSize
                );
            g_CertConversionBuff.End = 0;
        }
    }
    *ObjectName = IsmCreateObjectHandle (certStore, certName);

    return TRUE;
}


PCTSTR
GetNativeCertificateName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )

/*++

Routine Description:

  GetNativeCertificateName converts the standard Cobra object into a more friendly
  format. The Cobra object comes in the form of ^a<node>^b^c<leaf>, where
  <node> is the URL, and <leaf> is the certificate name. The Certificate native name is
  in the format of <CertificateStore>:<CertificateName>.

Arguments:

  ObjectName - Specifies the encoded object name

Return Value:

  A string that is equivalent to ObjectName, but is in a friendly format.
  This string must be freed with IsmReleaseMemory.

--*/

{
    PCTSTR certStore, certName, tmp;
    PCTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &certStore, &certName)) {
        if (certStore && certName) {
            tmp = JoinTextEx (NULL, certStore, certName, TEXT(":"), 0, NULL);
            if (tmp) {
                result = IsmDuplicateString (tmp);
                FreeText (tmp);
            }
        }
        IsmDestroyObjectString (certStore);
        IsmDestroyObjectString (certName);
    }
    return result;
}

PMIG_CONTENT
ConvertCertificateContentToUnicode (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    // we don't need to convert the content

    return NULL;
}

PMIG_CONTENT
ConvertCertificateContentToAnsi (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    // we don't need to convert the content

    return NULL;
}

BOOL
FreeConvertedCertificateContent (
    IN      PMIG_CONTENT ObjectContent
    )
{
    // there is nothing to do
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\csm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    csm.c

Abstract:

    Implements the existing state analyze portion of the v1 module.
    The existing state module enumerates everything in the environment
    variables DelReg* and DelFile* (where * is a one-based number),
    and then sets the delete operation on everything that matches.

Author:

    Jim Schmidt (jimschm) 21-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

#define NORMAL_DRIVE_BUFFER_BYTES 50000000
#define SYSTEM_DRIVE_BUFFER_BYTES (NORMAL_DRIVE_BUFFER_BYTES + 50000000)

#define MAX_CONTENT_CHECK   0x100000

//
// Macros
//

// None

//
// Types
//

typedef struct {
    ULARGE_INTEGER FreeSpace;
    DWORD BytesPerCluster;
} DRIVE_INFO, *PDRIVE_INFO;

//
// Globals
//

MIG_OPERATIONID g_DeleteOp;
MIG_OPERATIONID g_PartMoveOp;
HASHTABLE g_PartitionSpaceTable;
HASHTABLE g_PartitionMatchTable;
HASHTABLE g_CollisionSrcTable;
HASHTABLE g_CollisionDestTable;
PMHANDLE g_UntrackedCsmPool;
TCHAR g_SystemDrive[_MAX_DRIVE + 1];

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

CSMINITIALIZE ScriptCsmInitialize;
CSMEXECUTE ScriptCsmExecute;

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
pPopulatePartitionTable (
    VOID
    )
{
    PCTSTR drive;
    DRIVE_INFO driveInfo;
    ULARGE_INTEGER whoCares;
    PTSTR driveList = NULL;
    DWORD driveListLen;
    DWORD sectPerClust, bytesPerSect, freeClusters, totalClusters;
    FARPROC pGetDiskFreeSpaceEx;
    BOOL validDrive;

    if (!GetEnvironmentVariable (TEXT("SYSTEMDRIVE"), g_SystemDrive, _MAX_DRIVE)) {
        StringCopyTcharCount (g_SystemDrive, TEXT("C:"), _MAX_DRIVE);
    }

    driveListLen = GetLogicalDriveStrings (0, driveList);

    driveList = AllocText (driveListLen + 1);
    if (!driveList) {
        return;
    }

    GetLogicalDriveStrings (driveListLen, driveList);

    drive = driveList;

    // Find out if GetDiskFreeSpaceEx is supported
#ifdef UNICODE
    pGetDiskFreeSpaceEx = GetProcAddress (GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExW");
#else
    pGetDiskFreeSpaceEx = GetProcAddress (GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExA");
#endif

    while (*drive) {
        validDrive = FALSE;

        if (GetDriveType (drive) == DRIVE_FIXED) {
            ZeroMemory (&driveInfo, sizeof (DRIVE_INFO));
            if (pGetDiskFreeSpaceEx) {
                if (pGetDiskFreeSpaceEx (drive, &driveInfo.FreeSpace, &whoCares, &whoCares)) {
                    validDrive = TRUE;
                    if (GetDiskFreeSpace (drive, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                        driveInfo.BytesPerCluster = bytesPerSect * sectPerClust;
                        if (!driveInfo.BytesPerCluster) {
                            driveInfo.BytesPerCluster = 1;
                        }
                    }
                }
            } else  {
                if (GetDiskFreeSpace (drive, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                    driveInfo.FreeSpace.QuadPart = Int32x32To64 ((sectPerClust * bytesPerSect), freeClusters);
                    driveInfo.BytesPerCluster = bytesPerSect * sectPerClust;
                    if (!driveInfo.BytesPerCluster) {
                        driveInfo.BytesPerCluster = 1;
                    }
                    validDrive = TRUE;
                }
            }
        }

        if (validDrive) {
            HtAddStringEx (g_PartitionSpaceTable, drive, &driveInfo, FALSE);
        }

        // Advance to the next drive in the drive list
        drive = _tcschr (drive, 0) + 1;
    }

    FreeText (driveList);

}


BOOL
pIsSystemDrive (
    IN      PCTSTR Drive
    )
{
    if (StringIMatchCharCount (g_SystemDrive, Drive, 2)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pReserveDiskSpace (
    IN      PCTSTR DestDrive,
    IN      ULARGE_INTEGER FileSize,
    IN      BOOL IgnoreBuffer
    )
{
    DRIVE_INFO driveInfo;
    ULARGE_INTEGER buffer;
    HASHITEM hashItem;
    BOOL success = FALSE;

    hashItem = HtFindStringEx (g_PartitionSpaceTable, DestDrive, &driveInfo, FALSE);
    if (hashItem) {
        // let's transform the FileSize so it is alligned to BytesPerCluster
        FileSize.QuadPart = ((FileSize.QuadPart + driveInfo.BytesPerCluster - 1) / driveInfo.BytesPerCluster) * driveInfo.BytesPerCluster;
        if (IgnoreBuffer) {
            if (pIsSystemDrive (DestDrive)) {
                buffer.QuadPart = NORMAL_DRIVE_BUFFER_BYTES;
            } else {
                buffer.QuadPart = 0;
            }
        } else {
            if (pIsSystemDrive (DestDrive)) {
                buffer.QuadPart = SYSTEM_DRIVE_BUFFER_BYTES;
            } else {
                buffer.QuadPart = NORMAL_DRIVE_BUFFER_BYTES;
            }
        }

        // Check for available space
        if (driveInfo.FreeSpace.QuadPart > buffer.QuadPart &&
            FileSize.QuadPart < driveInfo.FreeSpace.QuadPart - buffer.QuadPart) {

            // Subtract claimed disk space
            driveInfo.FreeSpace.QuadPart -= FileSize.QuadPart;
            HtSetStringData (g_PartitionSpaceTable, hashItem, &driveInfo);
            success = TRUE;
        }
    }
    return success;
}

BOOL
pValidatePartition (
    IN      MIG_OBJECTSTRINGHANDLE CurrentObjectName,
    IN      PCTSTR Destination
    )
{
    MIG_CONTENT srcContent;
    PWIN32_FIND_DATAW findData;
    TCHAR tmpDrive[_MAX_DRIVE + 1];
    ULARGE_INTEGER fileSize;
    UINT driveType;
    PTSTR fullDest;

    fullDest = DuplicatePathString (Destination, 1);
    AppendWack (fullDest);

    // Check with full Destination path for cases of UNC paths
    driveType = GetDriveType (fullDest);

    if (driveType == DRIVE_NO_ROOT_DIR) {
        // It thinks there is nothing mounted at that destination.  If the destination
        // looks like G:\files1 then it will give this error when G: is a valid mapped
        // drive.  So we'll check one more time with just "G:\"
        fullDest[3] = 0;
        driveType = GetDriveType (fullDest);
    }
    FreePathString (fullDest);

    if (driveType == DRIVE_REMOTE ||
        (Destination[0] == TEXT('\\') && Destination[1] == TEXT('\\'))
        ) {
        return TRUE;
    }

    if (driveType == DRIVE_FIXED) {

        // Acquire the object to get the filesize
        if (IsmAcquireObjectEx (
                g_FileType | PLATFORM_SOURCE,
                CurrentObjectName,
                &srcContent,
                CONTENTTYPE_DETAILS_ONLY,
                0
                )) {

            // Check to see if the desired destination has space
            findData = (PWIN32_FIND_DATAW)srcContent.Details.DetailsData;
            fileSize.LowPart = findData->nFileSizeLow;
            fileSize.HighPart = findData->nFileSizeHigh;

            tmpDrive[0] = Destination[0];
            tmpDrive[1] = Destination[1];
            tmpDrive[2] = TEXT('\\');
            tmpDrive[3] = 0;

            IsmReleaseObject (&srcContent);

            return (pReserveDiskSpace (tmpDrive, fileSize, FALSE));
        }
    }

    // Not a Fixed drive or Remote drive, so it's not a valid destination
    return FALSE;
}

BOOL
pFindValidPartition (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN OUT  PTSTR DestNode,
    IN      BOOL IgnoreBuffer     // must be FALSE except when called by itself
    )
{
    MIG_CONTENT srcContent;
    PWIN32_FIND_DATAW findData;
    PTSTR drivePtr;
    ULARGE_INTEGER fileSize;
    TCHAR tmpDrive[_MAX_DRIVE + 1];
    BOOL newDestFound = FALSE;
    PTSTR driveList = NULL;
    DWORD driveListLen;
    TCHAR destDrive;
    BOOL destChanged = FALSE;
    PCTSTR oldDestNode;
    BOOL result = TRUE;

    oldDestNode = DuplicatePathString (DestNode, 0);

    if (IsmAcquireObjectEx (
            g_FileType | PLATFORM_SOURCE,
            ObjectName,
            &srcContent,
            CONTENTTYPE_DETAILS_ONLY,
            0
            )) {

        // First check to see if we already matched up this file
        if (HtFindStringEx (g_PartitionMatchTable, ObjectName, &destDrive, FALSE)) {
            DestNode[0] = destDrive;
        } else {
            // Need a new destination for this file
            destChanged = TRUE;

            findData = (PWIN32_FIND_DATAW)srcContent.Details.DetailsData;
            fileSize.LowPart = findData->nFileSizeLow;
            fileSize.HighPart = findData->nFileSizeHigh;

            if (GetEnvironmentVariable (TEXT("SYSTEMDRIVE"), tmpDrive, _MAX_DRIVE)) {
                AppendWack (tmpDrive);
                if (pReserveDiskSpace (tmpDrive, fileSize, IgnoreBuffer)) {
                    newDestFound = TRUE;
                    DestNode[0] = tmpDrive[0];
                }
            }

            if (newDestFound == FALSE) {
                // Check drives in alphabetical order
                driveListLen = GetLogicalDriveStrings (0, driveList);
                driveList = AllocText (driveListLen + 1);
                GetLogicalDriveStrings (driveListLen, driveList);

                drivePtr = driveList;
                while (*drivePtr) {
                    if (pReserveDiskSpace (drivePtr, fileSize, IgnoreBuffer)) {
                        DestNode[0] = drivePtr[0];
                        newDestFound = TRUE;
                        break;
                    }

                    // Advance to the next drive in the drive list
                    drivePtr = _tcschr (drivePtr, 0) + 1;
                }

                FreeText (driveList);
            }

            if (newDestFound == FALSE) {
                if (IgnoreBuffer == FALSE) {
                    // We couldn't find space.  Look again, but override the buffer space

                    // NTRAID#NTBUG9-153274-2000/08/01-jimschm It will currently fill up the system drive first, which is not what we should do.

                    result = pFindValidPartition (ObjectName, DestNode, TRUE);
                } else {
                    // Okay it's hopeless.  Keep track of how badly we're out of space
                    LOG ((
                        LOG_ERROR,
                        (PCSTR) MSG_PARTMAP_DISKFULL,
                        IsmGetNativeObjectName (g_FileType, ObjectName)
                        ));
                    result = FALSE;
                }
            } else {
                if (destChanged == TRUE) {
                    LOG ((
                        LOG_WARNING,
                        (PCSTR) MSG_PARTMAP_FORCED_REMAP,
                        IsmGetNativeObjectName (g_FileType, ObjectName),
                        oldDestNode,
                        DestNode
                        ));
                }
            }
        }
        IsmReleaseObject (&srcContent);
    }

    FreePathString (oldDestNode);

    return result;
}

BOOL
pCompareFiles (
    IN      PCTSTR File1,
    IN      PCTSTR File2
    )
{
    HANDLE fileHandle1 = NULL;
    HANDLE fileHandle2 = NULL;
#define BUFFER_SIZE 4096
    BYTE buffer1[BUFFER_SIZE], buffer2[BUFFER_SIZE];
    BOOL result = FALSE;
    BOOL res1, res2;
    DWORD read1, read2;

    __try {
        fileHandle1 = BfOpenReadFile (File1);
        fileHandle2 = BfOpenReadFile (File2);

        if (fileHandle1 && fileHandle2) {
            while (TRUE) {
                if (IsmCheckCancel ()) {
                    result = FALSE;
                    break;
                }
                res1 = ReadFile (fileHandle1, buffer1, BUFFER_SIZE, &read1, NULL);
                res2 = ReadFile (fileHandle2, buffer2, BUFFER_SIZE, &read2, NULL);
                if (!res1 && !res2) {
                    result = TRUE;
                    break;
                }
                if (res1 && res2) {
                    if (read1 != read2) {
                        break;
                    }
                    if (read1 == 0) {
                        result = TRUE;
                        break;
                    }
                    if (!TestBuffer (buffer1, buffer2, read1)) {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
    }
    __finally {
        if (fileHandle1) {
            CloseHandle (fileHandle1);
            fileHandle1 = NULL;
        }
        if (fileHandle2) {
            CloseHandle (fileHandle2);
            fileHandle2 = NULL;
        }
    }
    return result;
}

BOOL
pDoesFileContentMatch (
    IN      BOOL AlreadyProcessed,
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PMIG_CONTENT SrcContent,
    IN      MIG_OBJECTTYPEID DestObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE DestObjectName,
    IN      PMIG_CONTENT DestContent,
    OUT     PBOOL Identical,
    OUT     PBOOL DifferentDetailsOnly
    )
{
    UINT index;
    PWIN32_FIND_DATAW find1, find2;
    BOOL result = FALSE;
    PUBINT src;
    PUBINT dest;
    UINT remainder;
    UINT count;
    DWORD allAttribs;
    DWORD extendedAttribs;

    if (AlreadyProcessed) {
        return FALSE;
    }

    if ((SrcObjectTypeId != MIG_FILE_TYPE) ||
        (DestObjectTypeId != MIG_FILE_TYPE)
        ) {
        return FALSE;
    }

    if (DifferentDetailsOnly) {
        *DifferentDetailsOnly = FALSE;
    }

    if (SrcContent->Details.DetailsSize != DestContent->Details.DetailsSize) {
        if (Identical) {
            Identical = FALSE;
        }
        return TRUE;
    }
    if (!SrcContent->Details.DetailsData || !DestContent->Details.DetailsData) {
        if (Identical) {
            Identical = FALSE;
        }
        return TRUE;
    }

    find1 = (PWIN32_FIND_DATAW)SrcContent->Details.DetailsData;
    find2 = (PWIN32_FIND_DATAW)DestContent->Details.DetailsData;

    if (find1->nFileSizeHigh != find2->nFileSizeHigh) {
        if (Identical) {
            Identical = FALSE;
        }
        return TRUE;
    }
    if (find1->nFileSizeLow != find2->nFileSizeLow) {
        if (Identical) {
            Identical = FALSE;
        }
        return TRUE;
    }
    if (SrcContent->ContentInFile && DestContent->ContentInFile) {
        result = pCompareFiles (SrcContent->FileContent.ContentPath, DestContent->FileContent.ContentPath);
    }
    if (!SrcContent->ContentInFile && !DestContent->ContentInFile) {
        if (SrcContent->MemoryContent.ContentSize != DestContent->MemoryContent.ContentSize) {
            if (Identical) {
                Identical = FALSE;
            }
            return TRUE;
        }
        if ((!SrcContent->MemoryContent.ContentBytes && DestContent->MemoryContent.ContentBytes) ||
            (SrcContent->MemoryContent.ContentBytes && !DestContent->MemoryContent.ContentBytes)
            ) {
            if (Identical) {
                Identical = FALSE;
            }
            return TRUE;
        }

        //
        // Compare the content using the largest unsigned int available, then
        // compare any remaining bytes
        //

        index = 0;
        count = SrcContent->MemoryContent.ContentSize / sizeof (UBINT);
        remainder = SrcContent->MemoryContent.ContentSize % sizeof (UBINT);
        src = (PUBINT) SrcContent->MemoryContent.ContentBytes;
        dest = (PUBINT) DestContent->MemoryContent.ContentBytes;

        while (count) {
            if (*src++ != *dest++) {
                DEBUGMSG ((DBG_WARNING, "Content mismatch because UBINTs differ"));
                if (Identical) {
                    Identical = FALSE;
                }
                return TRUE;
            }

            count--;
        }

        for (index = 0 ; index < remainder ; index++) {
            if (((PBYTE) src)[index] != ((PBYTE) dest)[index]) {
                DEBUGMSG ((DBG_WARNING, "Content mismatch because bytes differ"));
                if (Identical) {
                    Identical = FALSE;
                }
                return TRUE;
            }
        }

        result = TRUE;
    }

    if (!result) {
        if (Identical) {
            Identical = FALSE;
        }
        return TRUE;
    }

    //
    // At this point the files are the same. Now if the attributes are different, return
    // FALSE indicating that only the details differ.
    //

    if (DifferentDetailsOnly) {
        *DifferentDetailsOnly = TRUE;
    }

    if (find1->dwFileAttributes != find2->dwFileAttributes) {
        if (Identical) {
            Identical = FALSE;
        }
        return TRUE;
    }
    if (find1->ftLastWriteTime.dwLowDateTime != find2->ftLastWriteTime.dwLowDateTime) {
        if (Identical) {
            Identical = FALSE;
        }
        return TRUE;
    }
    if (find1->ftLastWriteTime.dwHighDateTime != find2->ftLastWriteTime.dwHighDateTime) {
        if (Identical) {
            Identical = FALSE;
        }
        return TRUE;
    }

    if (DifferentDetailsOnly) {
        *DifferentDetailsOnly = FALSE;
    }

    if (Identical) {
        *Identical = TRUE;
    }

    return TRUE;
}

BOOL
WINAPI
ScriptCsmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Get file and registry types
    //
    g_FileType = MIG_FILE_TYPE;
    g_RegType = MIG_REGISTRY_TYPE;
    g_IniType = MIG_INI_TYPE;

    //
    // Get operation types
    //
    g_DeleteOp = IsmRegisterOperation (S_OPERATION_DELETE, FALSE);
    g_PartMoveOp = IsmRegisterOperation (S_OPERATION_PARTITION_MOVE, TRUE);

    g_LockPartitionAttr = IsmRegisterAttribute (S_ATTRIBUTE_PARTITIONLOCK, FALSE);

    g_CollisionSrcTable = HtAllocWithData (sizeof (HASHITEM));
    g_CollisionDestTable = HtAllocWithData (sizeof (MIG_OBJECTSTRINGHANDLE));

    g_PartitionSpaceTable = HtAllocWithData (sizeof (DRIVE_INFO));
    g_PartitionMatchTable = HtAllocWithData (sizeof (TCHAR));

    pPopulatePartitionTable ();

    g_UntrackedCsmPool = PmCreatePool ();
    PmDisableTracking (g_UntrackedCsmPool);

    OE5RemapDefaultId();

    IsmRegisterCompareCallback (MIG_FILE_TYPE, pDoesFileContentMatch);

    return TRUE;
}


VOID
WINAPI
ScriptCsmTerminate (
    VOID
    )
{
    HtFree (g_CollisionSrcTable);
    g_CollisionSrcTable = NULL;

    HtFree (g_CollisionDestTable);
    g_CollisionDestTable = NULL;

    HtFree (g_PartitionSpaceTable);
    g_PartitionSpaceTable = NULL;

    HtFree (g_PartitionMatchTable);
    g_PartitionMatchTable = NULL;

    PmDestroyPool (g_UntrackedCsmPool);
    g_UntrackedCsmPool = NULL;

}


BOOL
pExecuteDeleteEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE Pattern
    )
{
    MIG_OBJECT_ENUM e;
    BOOL b = TRUE;

    if (IsmEnumFirstDestinationObject (&e, ObjectTypeId, Pattern)) {

        do {

            b = IsmSetOperationOnObject (
                    e.ObjectTypeId,
                    e.ObjectName,
                    g_DeleteOp,
                    NULL,
                    NULL
                    );

            if (!b) {
                IsmAbortObjectEnum (&e);
                break;
            }

        } while (IsmEnumNextObject (&e));
    }

    return b;
}

BOOL
pDoesDifferentFileExist (
    IN      MIG_OBJECTSTRINGHANDLE SrcName,
    IN      MIG_OBJECTSTRINGHANDLE DestName,
    IN      PCTSTR DestNativeName,
    OUT     PBOOL DifferentDetailsOnly
    )
{
    MIG_CONTENT srcContent;
    MIG_CONTENT destContent;
    WIN32_FIND_DATA findData;
    BOOL result = FALSE;

    if (!DoesFileExistEx (DestNativeName, &findData)) {
        return FALSE;
    }
    if (findData.nFileSizeHigh) {
        return TRUE;
    }

    if (IsmAcquireObject (
            g_FileType | PLATFORM_DESTINATION,
            DestName,
            &destContent
            )) {
        result = TRUE;
        if (IsmAcquireObject (
                g_FileType | PLATFORM_SOURCE,
                SrcName,
                &srcContent
                )) {
            result = !IsmAreObjectsIdentical (
                            MIG_FILE_TYPE,
                            SrcName,
                            &srcContent,
                            MIG_FILE_TYPE,
                            DestName,
                            &destContent,
                            DifferentDetailsOnly
                            );
            IsmReleaseObject (&srcContent);
        }
        IsmReleaseObject (&destContent);
    } else {
        result = DoesFileExist (DestNativeName);
    }
    return result;
}

BOOL
pIsFileDestCollision (
    IN      MIG_OBJECTSTRINGHANDLE CurrentObjectName,
    IN      MIG_OBJECTSTRINGHANDLE OriginalObjectName,
    IN      PCTSTR CurrentNativeName,
    IN      BOOL CompareDestFiles,
    IN      BOOL *OnlyDetailsDiffer
)
{
    if (HtFindString (g_CollisionDestTable, CurrentObjectName)) {
       return TRUE;
    }
    if (CompareDestFiles &&
        pDoesDifferentFileExist (OriginalObjectName,
                                 CurrentObjectName,
                                 CurrentNativeName,
                                 OnlyDetailsDiffer)) {
        if (*OnlyDetailsDiffer == FALSE) {
            return TRUE;
        }
    }
    return FALSE;
}


MIG_OBJECTSTRINGHANDLE
pCollideFile (
    IN      MIG_OBJECTID OriginalObjectId,
    IN      MIG_OBJECTSTRINGHANDLE OriginalObjectName,
    IN      PCTSTR NewNode,
    IN      PCTSTR NewLeaf,
    IN      BOOL CompareDestFiles
    )
{
    MIG_OBJECTSTRINGHANDLE result = NULL;
    HASHITEM hashItem;
    PCTSTR testNativeName;
    PCTSTR leafExt = NULL;
    TCHAR buff[MAX_TCHAR_PATH * 2];
    PTSTR openParen = NULL;
    PTSTR closeParen = NULL;
    PTSTR tmpLeaf = NULL;
    PTSTR testLeaf = NULL;
    size_t testLeafTchars;
    PTSTR chr;
    BOOL onlyDetailsDiffer = FALSE;
    BOOL replaceOk = TRUE;
    UINT fileIndex = 0;
    MIG_PROPERTYDATAID propDataId;
    BOOL specialPattern = FALSE;
    PTSTR fileCollPattern = NULL;
    MIG_BLOBTYPE propDataType;
    UINT requiredSize;
    HRESULT hr;


    if (!HtFindStringEx (g_CollisionSrcTable, OriginalObjectName, (PVOID)(&hashItem), FALSE)) {

        // we don't have a spot just yet. Let's make one.
        result = IsmCreateObjectHandle (NewNode, NewLeaf);
        testNativeName = JoinPaths (NewNode, NewLeaf);

        if (pIsFileDestCollision(result,
                                 OriginalObjectName,
                                 testNativeName,
                                 CompareDestFiles,
                                 &onlyDetailsDiffer)) {

            tmpLeaf = AllocText (TcharCount (NewLeaf) + 1);

            leafExt = _tcsrchr (NewLeaf, TEXT('.'));
            if (leafExt) {
                StringCopyAB (tmpLeaf, NewLeaf, leafExt);
                leafExt = _tcsinc (leafExt);
            } else {
                StringCopy (tmpLeaf, NewLeaf);
            }

            // Let's check if we wanted some special pattern for this file
            propDataId = IsmGetPropertyFromObjectId (OriginalObjectId, g_FileCollPatternData);
            if (propDataId) {
                if (IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
                    if (propDataType == BLOBTYPE_STRING) {
                        fileCollPattern = IsmGetMemory (requiredSize);
                        if (fileCollPattern) {
                            if (IsmGetPropertyData (
                                        propDataId,
                                        (PBYTE)fileCollPattern,
                                        requiredSize,
                                        NULL,
                                        &propDataType)) {
                                specialPattern = TRUE;
                            }
                            if (!specialPattern) {
                                IsmReleaseMemory (fileCollPattern);
                                fileCollPattern = NULL;
                            }
                        }
                    }
                }
            }

            if (specialPattern) {
                //
                // Loop until we find a non-colliding destination, or a colliding
                // dest that differs only by attributes
                //

                do {
                    FreePathString (testNativeName);
                    IsmDestroyObjectHandle (result);
                    fileIndex ++;

                    __try {
                        hr = StringCbPrintf (buff, sizeof (buff), fileCollPattern, tmpLeaf, fileIndex, leafExt?leafExt:TEXT(""), NULL);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        // something went wrong. The pattern might have been terribly wrong
                        hr = S_FALSE;
                    }
                    if (hr != S_OK) {
                        // something went wrong, we assume that the pattern from the inf is probably bad.
                        // Just incrementing the index won't solve the problem. Let's just abort this.
                        fileIndex = 0;
                    }

                    result = IsmCreateObjectHandle (NewNode, buff);
                    testNativeName = JoinPaths (NewNode, buff);
                } while (fileIndex && pIsFileDestCollision(
                                            result,
                                            OriginalObjectName,
                                            testNativeName,
                                            CompareDestFiles,
                                            &onlyDetailsDiffer));
                if (fileCollPattern) {
                    IsmReleaseMemory (fileCollPattern);
                    fileCollPattern = NULL;
                }

                if (!fileIndex) {
                    // The collision pattern was bogus and we looped until
                    // we ran out of indexes. Let's go with the default
                    // collision mechanism.
                    specialPattern = FALSE;
                }
            }
            if (!specialPattern) {
                // Check if the filename already has a (number) tacked on
                openParen = _tcsrchr (tmpLeaf, TEXT('('));
                closeParen = _tcsrchr (tmpLeaf, TEXT(')'));

                if (closeParen && openParen &&
                    closeParen > openParen &&
                    closeParen - openParen > 1) {

                    // Make sure it's purely numerical
                    for (chr = openParen+1; chr < closeParen; chr++) {
                       if (!_istdigit (*chr)) {
                           replaceOk = FALSE;
                           break;
                       }
                    }

                    if (replaceOk == TRUE) {
                        if (_stscanf (openParen, TEXT("(%d)"), &fileIndex)) {
                            *openParen = 0;
                        }
                    }
                }

                //
                // Loop until we find a non-colliding destination, or a colliding
                // dest that differs only by attributes
                //

                do {
                    FreePathString (testNativeName);
                    IsmDestroyObjectHandle (result);
                    FreeText (testLeaf);
                    fileIndex ++;

                    wsprintf (buff, TEXT("(%d)"), fileIndex);
                    testLeafTchars = TcharCount (tmpLeaf) + TcharCount (buff) + 1;
                    if (leafExt) {
                        testLeafTchars += TcharCount (leafExt) + 1;
                    }
                    testLeaf = AllocText (testLeafTchars);
                    StringCopy (testLeaf, tmpLeaf);
                    StringCat (testLeaf, buff);
                    if (leafExt) {
                        StringCat (testLeaf, TEXT("."));
                        StringCat (testLeaf, leafExt);
                    }

                    result = IsmCreateObjectHandle (NewNode, testLeaf);
                    testNativeName = JoinPaths (NewNode, testLeaf);
                } while (pIsFileDestCollision(result,
                                              OriginalObjectName,
                                              testNativeName,
                                              CompareDestFiles,
                                              &onlyDetailsDiffer));
            }

            FreeText (tmpLeaf);
        }

        if (onlyDetailsDiffer) {
            IsmAbandonObjectOnCollision (g_FileType | PLATFORM_DESTINATION, OriginalObjectName);
        }

        FreePathString (testNativeName);
        FreeText (testLeaf);

        //
        // Put new destination in the hash table and store the Ism handle, which will
        // be cleaned up at the end.
        //

        hashItem = HtAddStringEx (g_CollisionDestTable, result, &result, FALSE);
        HtAddStringEx (g_CollisionSrcTable, OriginalObjectName, &hashItem, FALSE);
    } else {
        //
        // Get the already computed collision destination.
        //

        HtCopyStringData (g_CollisionDestTable, hashItem, (PVOID)(&result));
    }

    return result;
}


MIG_OBJECTSTRINGHANDLE
pCollisionGetDestination (
    IN      MIG_OBJECTID OriginalObjectId,
    IN      MIG_OBJECTSTRINGHANDLE OriginalObjectName,
    IN      PCTSTR NewNode,
    IN      PCTSTR NewLeaf
    )
{
    MIG_OBJECTSTRINGHANDLE result = NULL;
    BOOL onlyDetailsDiffer = FALSE;

    // now we have the destination node. If this is actually a file
    // we need to check for collisions. For this we look if the
    // destination already has a file like this. After that we use
    // a table to reserve ourselves a spot.

    if (NewLeaf) {
        if (IsmIsObjectAbandonedOnCollision (g_FileType | PLATFORM_DESTINATION, OriginalObjectName)) {
            // we don't care about existing files on the destination machine.
            // However, some files that we just copy may collide with each other
            // so we have to check that.
            result = pCollideFile (OriginalObjectId, OriginalObjectName, NewNode, NewLeaf, FALSE);
        } else if (IsmIsObjectAbandonedOnCollision (g_FileType | PLATFORM_SOURCE, OriginalObjectName)) {
            // this will potentially collide with an existent file but then the source file
            // would not survive.
            result = IsmCreateObjectHandle (NewNode, NewLeaf);
        } else {
            result = pCollideFile (OriginalObjectId, OriginalObjectName, NewNode, NewLeaf, TRUE);

        }
    } else {
        result = IsmCreateObjectHandle (NewNode, NULL);
    }
    return result;
}


BOOL
pExecuteFixFilename (
    VOID
    )
{
    UINT ticks;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_PROGRESSSLICEID sliceId;
    PCTSTR destination = NULL;
    MIG_OBJECTSTRINGHANDLE destFilename;
    PTSTR node = NULL;
    PCTSTR leaf = NULL;
    MIG_BLOB opData;
    PMIG_OBJECTCOUNT objectCount;
    BOOL deleted;

    objectCount = IsmGetObjectsStatistics (g_FileType | PLATFORM_SOURCE);
    if (objectCount) {
        ticks = objectCount->TotalObjects;
    } else {
        ticks = 0;
    }

    sliceId = IsmRegisterProgressSlice (ticks, max (1, ticks / 5));

    // Enum source file objects
    enumPattern = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);  // *,*
    if (IsmEnumFirstSourceObject (&objectEnum, g_FileType, enumPattern)) {
        do {
            // Check if Apply
            if (IsmIsApplyObjectId (objectEnum.ObjectId)) {

                // Macro expansion, rule processing, etc
                destination = IsmFilterObject (objectEnum.ObjectTypeId,
                                               objectEnum.ObjectName,
                                               NULL,
                                               &deleted,
                                               NULL);

                if (deleted) {
                    continue;
                }

                if (!destination) {
                    destination = objectEnum.ObjectName;
                }

                IsmCreateObjectStringsFromHandle (destination, &node, &leaf);

                if (node && _tcslen (node) >= 2) {
                    if (IsValidFileSpec (node)) {
                        if (!pValidatePartition (objectEnum.ObjectName, node)) {
                            if (!IsmIsAttributeSetOnObjectId (objectEnum.ObjectId, g_LockPartitionAttr)) {
                                // Pick a new destination partition
                                pFindValidPartition (objectEnum.ObjectName, node, FALSE);
                            }
                        }
                    }
                }

                // We have selected a new partition, so now check for file collisions
                destFilename = pCollisionGetDestination (
                                    objectEnum.ObjectId,
                                    objectEnum.ObjectName,
                                    node,
                                    leaf
                                    );

                if (node) {
                    IsmDestroyObjectString (node);
                    node = NULL;
                }
                if (leaf) {
                    IsmDestroyObjectString (leaf);
                    leaf = NULL;
                }

                opData.Type = BLOBTYPE_STRING;
                opData.String = PmDuplicateString (g_UntrackedCsmPool, destFilename);
                IsmDestroyObjectHandle (destFilename);
                destFilename = NULL;

                // Set a custom operation that will fix the name
                IsmSetOperationOnObjectId (
                    objectEnum.ObjectId,
                    g_PartMoveOp,
                    (MIG_DATAHANDLE) 0,
                    &opData
                    );

                if (!IsmTickProgressBar (sliceId, 1)) {
                   IsmAbortObjectEnum (&objectEnum);
                   break;
                }

                if (destination != objectEnum.ObjectName) {
                    IsmDestroyObjectHandle (destination);
                }

            }
        } while (IsmEnumNextObject (&objectEnum));
    }

    IsmDestroyObjectHandle (enumPattern);
    INVALID_POINTER (enumPattern);

    return TRUE;
}


BOOL
WINAPI
ScriptCsmExecute (
    VOID
    )
{
    UINT u;
    TCHAR string[32];
    TCHAR pattern[MAX_TCHAR_PATH];

    //
    // Enumerate the environment variables DelReg* and DelFile*,
    // then enumerate all physical objects represented by the
    // pattern, and finally, mark the objects with delete operations.
    //

    u = 1;
    for (;;) {
        wsprintf (string, TEXT("DelReg%u"), u);
        u++;

        if (IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                NULL,
                string,
                pattern,
                ARRAYSIZE(pattern),
                NULL
                )) {

            if (!pExecuteDeleteEnum (g_RegType, (MIG_OBJECTSTRINGHANDLE) pattern)) {
                return FALSE;
            }
        } else {
            break;
        }
    }

    u = 1;
    for (;;) {
        wsprintf (string, TEXT("DelFile%u"), u);
        u++;

        if (IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                NULL,
                string,
                pattern,
                ARRAYSIZE(pattern),
                NULL
                )) {

            if (!pExecuteDeleteEnum (g_FileType, (MIG_OBJECTSTRINGHANDLE) pattern)) {
                return FALSE;
            }
        } else {
            break;
        }
    }

    pExecuteFixFilename ();

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\attrib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    attrib.c

Abstract:

    Implements the v1 script application attributes.

Author:

    Jim Schmidt (jimschm) 08-Jun-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_ATTRIB      "Attrib"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct _MIGDB_ATTRIB {
    INT AttribIndex;
    UINT ArgCount;
    PCTSTR Arguments;
    BOOL NotOperator;
    struct _MIGDB_ATTRIB *Next;
} MIGDB_ATTRIB, *PMIGDB_ATTRIB;

typedef BOOL(ATTRIBUTE_FUNCTION)(PCTSTR ArgMultiSz, PATTRIB_DATA Content);
typedef ATTRIBUTE_FUNCTION *PATTRIBUTE_FUNCTION;

typedef struct {
    PCTSTR AttributeName;
    PATTRIBUTE_FUNCTION Function;
    UINT RequiredArgs;
} ATTRIBUTE_FUNCTION_ITEM, *PATTRIBUTE_FUNCTION_ITEM;


//
// Globals
//

extern BOOL g_VcmMode;  // in sgmqueue.c

//
// Macro expansion list
//

#define ATTRIBUTE_LIST                                          \
    DEFMAC(EXISTS, pExists, 0)                                  \
    DEFMAC(SAMEOBJECTNAME, pSameObjectName, 1)                  \
    DEFMAC(SAMEOBJECTCONTENT, pSameObjectContent, 2)            \
    DEFMAC(ISREGFLAGSET, pIsRegFlagSet, 1)                      \
    DEFMAC(MATCHES, pMatches, 1)                                \
    DEFMAC(SET_PERSIST_FLAG, pSetPersistFlag, 0)                \
    DEFMAC(NOTEMPTY, pNotEmpty, 0)                              \
    DEFMAC(VERSION, pVersion, 2)                                \

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

#define DEFMAC(name,fn,req_args)    ATTRIBUTE_FUNCTION fn;

ATTRIBUTE_LIST

#undef DEFMAC

#define DEFMAC(name,fn,req_args)    TEXT(#name), fn, req_args,

ATTRIBUTE_FUNCTION_ITEM g_FnList[] = {

    ATTRIBUTE_LIST /* , */
    NULL, NULL, 0
};



//
// Code
//

#define STATE_ATTRNAME  1
#define STATE_ATTRARG   2

INT
pGetAttribIndex (
    IN      PCTSTR AttribName
    )

/*++

Routine Description:

  This routine returns the index in attribute functions array for a specified
  attribute.

Arguments:

  AttribName - Attribute name

Return value:

  -1 - no such attribute in attribute table

--*/

{
    INT attribIndex;
    INT rc = 0;
    PTSTR attrEnd = NULL;
    TCHAR savedChar = 0;

    attrEnd = (PTSTR) SkipSpaceR (AttribName, GetEndOfString (AttribName));
    if (attrEnd != NULL) {
        attrEnd = _tcsinc (attrEnd);
        savedChar = attrEnd [0];
        attrEnd [0] = 0;
    }
    __try {
        for (attribIndex = 0 ; g_FnList[attribIndex].AttributeName ; attribIndex++) {
            if (StringIMatch (g_FnList[attribIndex].AttributeName, AttribName)) {
                break;
            }
        }

        if (!g_FnList[attribIndex].AttributeName) {
            attribIndex = -1;
            LOG ((LOG_ERROR, (PCSTR) MSG_DETECT_ATTRIB_NOT_FOUND, AttribName));
        }

        rc = attribIndex;
    }
    __finally {
        if (attrEnd != NULL) {
            attrEnd [0] = savedChar;
        }
    }

    return rc;
}


UINT
pGetReqArgCount (
    IN      INT AttributeIndex
    )
{
    if (AttributeIndex < 0 || AttributeIndex > ARRAYSIZE(g_FnList)) {
        return 0;
    }

    return g_FnList[AttributeIndex].RequiredArgs;
}


BOOL
pValidateArg (
    IN OUT  PMIGDB_ATTRIB AttribStruct
    )
{
    //
    // Validate all AttribStruct members
    //

    MYASSERT (AttribStruct);

    if (AttribStruct->ArgCount != pGetReqArgCount (AttribStruct->AttribIndex)) {
        AttribStruct->AttribIndex = -1;
        return FALSE;
    }

    return TRUE;
}


PMIGDB_ATTRIB
pLoadAttribData (
    IN      PMHANDLE Pool,
    IN      PCTSTR MultiSzStr
    )

/*++

Routine Description:

  This routine creates a list of MIGDB_ATTRIBs from a multisz.

Arguments:

  Pool - Specifies a pool that temporary structures and the return value
         will be allocated from

  MultiSzStr - Specifies the multisz to be processed. The multi-sz must
               be in the form of ATTRIB or ATTRIB(arg[,arg,...])

Return value:

  MIGDB_ATTRIB nodes

--*/

{
    MULTISZ_ENUM multiSzEnum;
    PMIGDB_ATTRIB result  = NULL;
    PMIGDB_ATTRIB tmpAttr = NULL;
    INT state = STATE_ATTRNAME;
    PTSTR currStrPtr = NULL;
    PTSTR currArgPtr = NULL;
    PTSTR endArgPtr  = NULL;
    TCHAR savedChar  = 0;
    GROWBUFFER argList = INIT_GROWBUFFER;

    if (EnumFirstMultiSz (&multiSzEnum, MultiSzStr)) {

        do {
            currStrPtr = (PTSTR) SkipSpace (multiSzEnum.CurrentString);

            if (state == STATE_ATTRNAME) {
                tmpAttr = (PMIGDB_ATTRIB) PmGetMemory (Pool, sizeof (MIGDB_ATTRIB));

                ZeroMemory (tmpAttr, sizeof (MIGDB_ATTRIB));

                if (_tcsnextc (currStrPtr) == TEXT('!')) {
                    currStrPtr = _tcsinc (currStrPtr);
                    currStrPtr = (PTSTR) SkipSpace (currStrPtr);
                    tmpAttr->NotOperator = TRUE;
                }

                currArgPtr = _tcschr (currStrPtr, TEXT('('));

                if (currArgPtr) {
                    endArgPtr = _tcsdec (currStrPtr, currArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PTSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _tcsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }

                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    *endArgPtr = savedChar;
                    currStrPtr = _tcsinc (currArgPtr);
                    state = STATE_ATTRARG;
                }
                else {
                    // this attribute has no arguments.
                    tmpAttr->AttribIndex = pGetAttribIndex (currStrPtr);
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                    continue;
                }
            }

            if (state == STATE_ATTRARG) {
                currStrPtr = (PTSTR) SkipSpace (currStrPtr);
                endArgPtr = _tcsrchr (currStrPtr, TEXT(')'));
                if (endArgPtr && endArgPtr[1] == 0) {
                    endArgPtr = _tcsdec (currStrPtr, endArgPtr);
                    if (endArgPtr) {
                        endArgPtr = (PTSTR) SkipSpaceR (currStrPtr, endArgPtr);
                        endArgPtr = _tcsinc (endArgPtr);
                    }
                    else {
                        endArgPtr = currStrPtr;
                    }
                    savedChar = *endArgPtr;
                    *endArgPtr = 0;
                } else {
                    endArgPtr = NULL;
                }

                GbMultiSzAppend (&argList, currStrPtr);

                tmpAttr->ArgCount++;

                if (endArgPtr) {
                    *endArgPtr = savedChar;
                    tmpAttr->Arguments = PmDuplicateMultiSz (Pool, (PTSTR) argList.Buf);
                    GbFree (&argList);
                    state = STATE_ATTRNAME;
                    tmpAttr->Next = result;
                    result = tmpAttr;

                    pValidateArg (result);
                }
            }

        } while (EnumNextMultiSz (&multiSzEnum));
    }

    return result;
}


BOOL
TestAttributes (
    IN      PMHANDLE WorkPool,
    IN      PCTSTR ArgumentMultiSz,
    IN      PATTRIB_DATA AttribData
    )

/*++

Routine Description:

  TestAttributes executes the attribute functions specified in the
  ArgumentMultiSz parameter. Each argument is tested until they all succeed
  or until one fails.

Arguments:

  WorkPool        - Specifies a pool handle for fast allocations
  ArgumentMultiSz - Specifies the multi-sz that contains argument
                    specifications
  AttribData      - Specifies the object name, script specifications and
                    object content

Return Value:

  TRUE if all attributes pass (or if zero attributes were specified), FALSE
  otherwise.

--*/

{
    PMIGDB_ATTRIB attrib;
    PMIGDB_ATTRIB tmpAttrib;
    BOOL result = TRUE;

    attrib = pLoadAttribData (WorkPool, ArgumentMultiSz);
    tmpAttrib = attrib;

    while (result && attrib) {
        if (attrib->AttribIndex < 0 || attrib->AttribIndex >= ARRAYSIZE(g_FnList)) {
            DEBUGMSG ((DBG_WHOOPS, "Invalid attribute index %i", attrib->AttribIndex));
            result = FALSE;
        } else {

            result = g_FnList[attrib->AttribIndex].Function (attrib->Arguments, AttribData);

            if (attrib->NotOperator) {
                result = !result;
            }
        }

        attrib = attrib->Next;
    }

    // now free the attribute list
    attrib = tmpAttrib;
    while (attrib) {
        tmpAttrib = attrib->Next;
        if (attrib->Arguments) {
            PmReleaseMemory (WorkPool, attrib->Arguments);
        }
        PmReleaseMemory (WorkPool, attrib);
        attrib = tmpAttrib;
    }

    return result;
}


//
// Attribute functions (see ATTRIBUTE_LIST)
//

BOOL
pExists (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    return (Data->ReturnString != NULL);
}

BOOL
pSameObjectName (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    return (StringIMatch (FunctionArguments, Data->ScriptSpecifiedObject));
}

BOOL
pSameObjectContent (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    PCTSTR scriptObjectType = NULL;
    PCTSTR scriptObjectName = NULL;
    ATTRIB_DATA attribData;
    BOOL result = FALSE;

    scriptObjectType = FunctionArguments;
    scriptObjectName = GetEndOfString (FunctionArguments);
    if (scriptObjectName) {
        scriptObjectName ++;
    }

    if (!scriptObjectType || !scriptObjectName) {
        return FALSE;
    }

    ZeroMemory (&attribData, sizeof (ATTRIB_DATA));
    attribData.Platform = Data->Platform;
    attribData.ScriptSpecifiedType = scriptObjectType;
    attribData.ScriptSpecifiedObject = scriptObjectName;
    attribData.ApplicationName = Data->ApplicationName;

    if (!AllocScriptType (&attribData)) {
        return FALSE;
    }

    // let's persist the object in VCM mode so we can look at it later
    if (g_VcmMode && attribData.ObjectName) {
        if (IsmDoesObjectExist (attribData.ObjectTypeId, attribData.ObjectName)) {
            IsmMakePersistentObject (attribData.ObjectTypeId, attribData.ObjectName);
        }
    }

    if (Data->ObjectContent && attribData.ObjectContent) {
        if (Data->ObjectContent->ObjectTypeId == attribData.ObjectContent->ObjectTypeId) {
            if (Data->ObjectContent->Details.DetailsSize == attribData.ObjectContent->Details.DetailsSize) {
                if (!Data->ObjectContent->Details.DetailsSize ||
                    TestBuffer (
                        Data->ObjectContent->Details.DetailsData,
                        attribData.ObjectContent->Details.DetailsData,
                        Data->ObjectContent->Details.DetailsSize
                        )
                    ) {
                    if (Data->ObjectContent->ContentInFile == attribData.ObjectContent->ContentInFile) {
                        if (Data->ObjectContent->ContentInFile) {
                            if (StringIMatch (
                                    Data->ObjectContent->FileContent.ContentPath,
                                    attribData.ObjectContent->FileContent.ContentPath
                                    )
                                ) {
                                result = TRUE;
                            }
                        } else {
                            if (Data->ObjectContent->MemoryContent.ContentSize == attribData.ObjectContent->MemoryContent.ContentSize) {
                                if (!Data->ObjectContent->MemoryContent.ContentSize ||
                                    TestBuffer (
                                        Data->ObjectContent->MemoryContent.ContentBytes,
                                        attribData.ObjectContent->MemoryContent.ContentBytes,
                                        Data->ObjectContent->MemoryContent.ContentSize
                                        )
                                    ) {
                                    result = TRUE;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    FreeScriptType (&attribData);

    return result;
}

BOOL
pIsRegFlagSet (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    DWORD inValue;
    DWORD value;

    if (!Data) {
        return FALSE;
    }
    if (!FunctionArguments) {
        return FALSE;
    }
    if (!Data->ObjectContent) {
        return FALSE;
    }
    if ((Data->ObjectContent->ObjectTypeId & ~PLATFORM_MASK) != MIG_REGISTRY_TYPE) {
        return FALSE;
    }
    if (Data->ObjectContent->Details.DetailsSize != sizeof (DWORD)) {
        return FALSE;
    }
    if ((*((PDWORD)(Data->ObjectContent->Details.DetailsData)) != REG_DWORD) &&
        (*((PDWORD)(Data->ObjectContent->Details.DetailsData)) != REG_SZ)
        ) {
        return FALSE;
    }
    if (Data->ObjectContent->ContentInFile) {
        return FALSE;
    }
    if (Data->ObjectContent->MemoryContent.ContentSize == 0) {
        return FALSE;
    }
    if (Data->ObjectContent->MemoryContent.ContentBytes == NULL) {
        return FALSE;
    }
    if (*((PDWORD)(Data->ObjectContent->Details.DetailsData)) == REG_DWORD) {
        inValue = *((PDWORD)(Data->ObjectContent->MemoryContent.ContentBytes));
    } else {
        _stscanf ((PCTSTR)Data->ObjectContent->MemoryContent.ContentBytes, TEXT("%ld"), &inValue);
    }
    _stscanf (FunctionArguments, TEXT("%lx"), &value);
    if (!(inValue & value)) {
        return FALSE;
    }
    return TRUE;
}

BOOL
pMatches (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    if (!Data->ReturnString) {
        return FALSE;
    }

    return (StringIMatch (FunctionArguments, Data->ReturnString));
}

BOOL
pSetPersistFlag (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    if (IsmDoesObjectExist (Data->ObjectTypeId, Data->ObjectName)) {
        IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);
    }

    return TRUE;
}

BOOL
pNotEmpty (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    if (!Data->ReturnString) {
        return FALSE;
    }

    return (Data->ReturnString[0] != 0);
}

BOOL
pVersion (
    IN      PCTSTR FunctionArguments,
    IN      PATTRIB_DATA Data
    )
{
    PCTSTR versionStr = NULL;
    PCTSTR versionValue = NULL;
    ATTRIB_DATA attribData;
    BOOL result = FALSE;

    versionStr = FunctionArguments;
    if (!versionStr) {
        return FALSE;
    }

    versionValue = GetEndOfString (FunctionArguments);
    if (!versionValue) {
        return FALSE;
    }
    versionValue ++;

    if (!Data) {
        return FALSE;
    }
    if (!Data->ReturnString) {
        return FALSE;
    }

    ZeroMemory (&attribData, sizeof (ATTRIB_DATA));
    attribData.Platform = Data->Platform;
    attribData.ScriptSpecifiedType = TEXT("File");
    attribData.ScriptSpecifiedObject = Data->ReturnString;
    attribData.ApplicationName = Data->ApplicationName;

    if (!AllocScriptType (&attribData)) {
        return FALSE;
    }

    // let's persist the object in VCM mode so we can look at it later
    if (g_VcmMode && attribData.ObjectName) {
        if (IsmDoesObjectExist (attribData.ObjectTypeId, attribData.ObjectName)) {
            IsmMakePersistentObject (attribData.ObjectTypeId, attribData.ObjectName);
        }
    }

    if (attribData.ObjectContent &&
        attribData.ObjectContent->ContentInFile &&
        attribData.ObjectContent->FileContent.ContentPath
        ) {
        result = VrCheckFileVersion (attribData.ObjectContent->FileContent.ContentPath, versionStr, versionValue);
    }

    FreeScriptType (&attribData);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\opm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    opm.c

Abstract:

    Implements the data apply portion of scanstate v1 compatiblity.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"
#include <sddl.h>

#define DBG_V1          "v1"
#define MAXINISIZE      65536

//
// Strings
//

#define S_RENAMEEX_START_CHAR TEXT('<')
#define S_RENAMEEX_END_CHAR   TEXT('>')

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_OPERATIONID g_V1MoveExOp;
MIG_OPERATIONID g_V1MoveOp;
MIG_OPERATIONID g_DeleteOp;
MIG_OPERATIONID g_PartMoveOp;
PMAPSTRUCT g_RegNodeFilterMap;
PMAPSTRUCT g_RegLeafFilterMap;
PMAPSTRUCT g_FileNodeFilterMap;
PMAPSTRUCT g_FileLeafFilterMap;
PMAPSTRUCT g_IniSectFilterMap;
PMAPSTRUCT g_IniKeyFilterMap;
PMAPSTRUCT g_DestEnvMap;
HASHTABLE g_RegCollisionDestTable;
HASHTABLE g_RegCollisionSrcTable;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

OPMINITIALIZE ScriptOpmInitialize;
OPMFILTERCALLBACK FilterV1MoveEx;
OPMFILTERCALLBACK FilterV1Move;
OPMFILTERCALLBACK FilterMove;
OPMFILTERCALLBACK FilterIniMove;
OPMAPPLYCALLBACK DoRegAutoFilter;
OPMAPPLYCALLBACK DoIniAutoFilter;
OPMFILTERCALLBACK FilterRegAutoFilter;
OPMFILTERCALLBACK FilterIniAutoFilter;
OPMFILTERCALLBACK FilterFileAutoFilter;
OPMFILTERCALLBACK FilterDelete;
OPMAPPLYCALLBACK DoFixDefaultIcon;
OPMFILTERCALLBACK FilterRenameExFilter;
OPMFILTERCALLBACK FilterRenameIniExFilter;
OPMFILTERCALLBACK FilterPartitionMove;
OPMAPPLYCALLBACK DoDestAddObject;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pParseInfForRemapEnvVar (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR envVar;
    PTSTR envValue;
    UINT sizeNeeded;
    PTSTR encodedVariableName;
    BOOL result = FALSE;

    __try {

        // on all systems, process "Delete Destination Settings"
        if (InfFindFirstLine (InfHandle, TEXT("RemapEnvVar"), NULL, &is)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                envVar = InfGetStringField (&is, 1);

                if (!envVar) {
                    LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_REG_SPEC));
                    continue;
                }

                if (IsmGetEnvironmentString (
                        PLATFORM_DESTINATION,
                        S_SYSENVVAR_GROUP,
                        envVar,
                        NULL,
                        0,
                        &sizeNeeded
                        )) {

                    envValue = AllocPathString (sizeNeeded);
                    if (envValue) {

                        if (IsmGetEnvironmentString (
                                PLATFORM_DESTINATION,
                                S_SYSENVVAR_GROUP,
                                envVar,
                                envValue,
                                sizeNeeded,
                                NULL
                                )) {
                            AddRemappingEnvVar (g_DestEnvMap, g_FileNodeFilterMap, NULL, envVar, envValue);
                        }
                        FreePathString (envValue);
                        envValue = NULL;
                    }
                }

                // now let's see if this env. variable was present on the source machine.
                // If it was, we are going to add it into g_RevEnvMap to allow file move
                // to create subdirectories only from this variable up.
                if (IsmGetEnvironmentString (
                        PLATFORM_SOURCE,
                        S_SYSENVVAR_GROUP,
                        envVar,
                        NULL,
                        0,
                        &sizeNeeded
                        )) {

                    envValue = AllocPathString (sizeNeeded);
                    if (envValue) {
                        if (IsmGetEnvironmentString (
                                PLATFORM_SOURCE,
                                S_SYSENVVAR_GROUP,
                                envVar,
                                envValue,
                                sizeNeeded,
                                NULL
                                )) {
                            encodedVariableName = AllocPathString (TcharCount (envVar) + 3);
                            if (encodedVariableName) {
                                wsprintf (encodedVariableName, TEXT("%%%s%%"), envVar);
                                AddStringMappingPair (g_RevEnvMap, envValue, encodedVariableName);
                                FreePathString (encodedVariableName);
                                encodedVariableName = NULL;
                            }

                        }
                        FreePathString (envValue);
                        envValue = NULL;
                    }
                }

            } while (InfFindNextLine (&is));
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (&is);
    }

    return result;
}

BOOL
pParseRemapEnvVar (
    VOID
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = TRUE;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {
        if (!pParseInfForRemapEnvVar (infHandle)) {
            result = FALSE;
        }
    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                result = FALSE;
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                result = FALSE;
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {
                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseInfForRemapEnvVar (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            result = FALSE;
                            __leave;
                        }

                        InfCloseInfFile (infHandle);
                        infHandle = INVALID_HANDLE_VALUE;
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                } while (EnumNextMultiSz (&e));

            }
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }

    return result;
}

VOID
pOutlookClearConvKeys (
    VOID
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern = NULL;

    // This registry tree was needed only for conversion data.  We don't want to
    // write them to the destination, so clear the apply attribute on each item.

    if ((IsmIsComponentSelected (S_OUTLOOK9798_COMPONENT, 0) &&
         IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OUTLOOK9798_APPDETECT)) ||
        (IsmIsComponentSelected (S_OFFICE_COMPONENT, 0) &&
         IsmIsEnvironmentFlagSet (PLATFORM_SOURCE, NULL, S_OFFICE9798_APPDETECT))) {

        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKLM\\Software\\Microsoft\\MS Setup (ACME)\\Table Files"),
                          TRUE,
                          NULL,
                          TRUE);

        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
            do {
               IsmClearApplyOnObject (g_RegType | PLATFORM_SOURCE, objectEnum.ObjectName);
            } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);
    }
}

BOOL
WINAPI
ScriptOpmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    //
    // Get file and registry types
    //
    g_FileType = MIG_FILE_TYPE;
    g_RegType = MIG_REGISTRY_TYPE;
    g_IniType = MIG_INI_TYPE;

    //
    // Get attribute and operation types
    //
    g_V1MoveExOp = IsmRegisterOperation (S_OPERATION_V1_FILEMOVEEX, TRUE);
    g_V1MoveOp = IsmRegisterOperation (S_OPERATION_V1_FILEMOVE, TRUE);
    g_RenameOp = IsmRegisterOperation (S_OPERATION_MOVE, FALSE);
    g_RenameIniOp = IsmRegisterOperation (S_OPERATION_INIMOVE, FALSE);
    g_DeleteOp = IsmRegisterOperation (S_OPERATION_DELETE, FALSE);
    g_DefaultIconOp = IsmRegisterOperation (S_OPERATION_DEFICON_FIXCONTENT, FALSE);
    g_DefaultIconData = IsmRegisterProperty (S_V1PROP_ICONDATA, FALSE);
    g_FileCollPatternData = IsmRegisterProperty (S_V1PROP_FILECOLLPATTERN, FALSE);
    g_RenameExOp = IsmRegisterOperation (S_OPERATION_ENHANCED_MOVE, FALSE);
    g_RenameIniExOp = IsmRegisterOperation (S_OPERATION_ENHANCED_INIMOVE, FALSE);
    g_PartMoveOp = IsmRegisterOperation (S_OPERATION_PARTITION_MOVE, TRUE);
    g_DestAddObject = IsmRegisterOperation (S_OPERATION_DESTADDOBJ, FALSE);
    g_RegAutoFilterOp = IsmRegisterOperation (S_OPERATION_REG_AUTO_FILTER, FALSE);
    g_IniAutoFilterOp = IsmRegisterOperation (S_OPERATION_INI_AUTO_FILTER, FALSE);

    //
    // Register operation callbacks
    //

    // FYI: Filter callbacks adjust the name of the object
    //      Apply callbacks adjust the content of the object

    // global operation callbacks
    IsmRegisterGlobalApplyCallback (g_RegType | PLATFORM_SOURCE, TEXT("ContentAutoFilter"), DoRegAutoFilter);
    IsmRegisterGlobalApplyCallback (g_IniType | PLATFORM_SOURCE, TEXT("ContentAutoFilter"), DoIniAutoFilter);
    IsmRegisterGlobalFilterCallback (g_RegType | PLATFORM_SOURCE, TEXT("AutoFilter"), FilterRegAutoFilter, TRUE, FALSE);
    IsmRegisterGlobalFilterCallback (g_IniType | PLATFORM_SOURCE, TEXT("AutoFilter"), FilterIniAutoFilter, TRUE, FALSE);
    IsmRegisterGlobalFilterCallback (g_FileType | PLATFORM_SOURCE, TEXT("AutoFilter"), FilterFileAutoFilter, TRUE, TRUE);

    // operation-specific callbacks
    IsmRegisterOperationFilterCallback (g_V1MoveExOp, FilterV1MoveEx, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_V1MoveOp, FilterV1Move, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_RenameOp, FilterMove, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_RenameIniOp, FilterIniMove, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_DeleteOp, FilterDelete, FALSE, TRUE, FALSE);
    IsmRegisterOperationApplyCallback (g_DefaultIconOp, DoFixDefaultIcon, TRUE);
    IsmRegisterOperationFilterCallback (g_RenameExOp, FilterRenameExFilter, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_RenameIniExOp, FilterRenameIniExFilter, TRUE, TRUE, FALSE);
    IsmRegisterOperationFilterCallback (g_PartMoveOp, FilterPartitionMove, TRUE, TRUE, FALSE);
    IsmRegisterOperationApplyCallback (g_DestAddObject, DoDestAddObject, TRUE);
    IsmRegisterOperationApplyCallback (g_RegAutoFilterOp, DoRegAutoFilter, TRUE);
    IsmRegisterOperationApplyCallback (g_IniAutoFilterOp, DoIniAutoFilter, TRUE);

    //
    // Call special conversion entry point
    //
    InitSpecialConversion (PLATFORM_DESTINATION);
    InitSpecialRename (PLATFORM_DESTINATION);

    g_RegNodeFilterMap = CreateStringMapping();

    g_FileNodeFilterMap = CreateStringMapping();

    g_DestEnvMap = CreateStringMapping();

    SetIsmEnvironmentFromPhysicalMachine (g_DestEnvMap, FALSE, NULL);
    SetIsmEnvironmentFromPhysicalMachine (g_FileNodeFilterMap, TRUE, NULL);

    pParseRemapEnvVar ();

    g_RegLeafFilterMap = CreateStringMapping();

    g_FileLeafFilterMap = CreateStringMapping();

    if ((!g_EnvMap) || (!g_RevEnvMap) || (!g_UndefMap)) {
        g_EnvMap = CreateStringMapping();
        g_UndefMap = CreateStringMapping();
        g_RevEnvMap = CreateStringMapping();
        SetIsmEnvironmentFromVirtualMachine (g_EnvMap, g_RevEnvMap, g_UndefMap);
    }

    g_IniSectFilterMap = CreateStringMapping ();
    g_IniKeyFilterMap = CreateStringMapping ();

    g_RegCollisionDestTable = HtAllocWithData (sizeof (MIG_OBJECTSTRINGHANDLE));
    g_RegCollisionSrcTable = HtAllocWithData (sizeof (HASHITEM));

    InitRestoreCallback (PLATFORM_DESTINATION);

    pOutlookClearConvKeys();

    return TRUE;
}


BOOL
pDoesDifferentRegExist (
    IN      MIG_OBJECTSTRINGHANDLE DestName
    )
{
    BOOL result = FALSE;
    MIG_CONTENT content;

    if (IsmAcquireObject (g_RegType|PLATFORM_DESTINATION, DestName, &content)) {
        IsmReleaseObject (&content);
        result = TRUE;
    } else if (HtFindString (g_RegCollisionDestTable, DestName)) {
        result = TRUE;
    }

    return result;
}


BOOL
WINAPI
FilterV1MoveEx (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR orgSrcNode = NULL;
    PCTSTR orgSrcLeaf = NULL;
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PCTSTR destNode = NULL;
    PCTSTR destLeaf = NULL;
    PCTSTR newDestNode = NULL;
    PCTSTR destNodePtr = NULL;
    // NTRAID#NTBUG9-153274-2000/08/01-jimschm Static buffer size
    TCHAR expDestNode[MAX_PATH * 4];
    PCTSTR ismExpDestNode = NULL;
    TCHAR expDestLeaf[MAX_PATH * 4];
    PCTSTR ismExpDestLeaf = NULL;
    CHARTYPE ch;
    MIG_OBJECTSTRINGHANDLE destHandle;

    __try {

        //
        // For v1 compatibility, we support only a transformation from
        // original source to inf-specified destination.  Chaining of
        // operations is not allowed (these are restrictions caused by the
        // existing INF syntax).
        //

        if (!DestinationOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing dest data in FilterV1MoveEx"));
            __leave;
        }

        if ((InputData->CurrentObject.ObjectTypeId & (~PLATFORM_MASK)) != g_FileType) {
            DEBUGMSG ((DBG_ERROR, "Unexpected object type in FilterV1MoveEx"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                DestinationOperationData->String,
                &destNode,
                &destLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split dest object in FilterV1MoveEx"));
            __leave;
        }

        MYASSERT (destNode);

        if (!destNode) {
            DEBUGMSG ((DBG_ERROR, "Destination spec must be a node"));
            __leave;
        }

        //
        // Split the source object into node and leaf
        //

        if (!IsmCreateObjectStringsFromHandle (
                InputData->CurrentObject.ObjectName,
                &srcNode,
                &srcLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split v1 src object in FilterV1MoveEx"));
            __leave;
        }

        if (!srcNode) {
            MYASSERT (FALSE);
            __leave;
        }

        //
        // If not a local path, do not process
        //

        if (!_istalpha ((CHARTYPE) _tcsnextc (srcNode)) ||
            _tcsnextc (srcNode + 1) != TEXT(':')
            ) {
            DEBUGMSG ((DBG_WARNING, "Ignoring %s\\%s because it does not have a drive spec", srcNode, srcLeaf));
            __leave;
        }

        ch = (CHARTYPE) _tcsnextc (srcNode + 2);

        if (ch && ch != TEXT('\\')) {
            DEBUGMSG ((DBG_WARNING, "Ignoring %s\\%s because it does not have a drive spec (2)", srcNode, srcLeaf));
            __leave;
        }

        // let's see if the current name has something in common
        // with SourceOperationData->String. If so, get the extra part
        // and add it to the destNode

        //
        // Split the original rule source object into node and leaf
        //
        if (SourceOperationData) {

            if (IsmCreateObjectStringsFromHandle (
                    SourceOperationData->String,
                    &orgSrcNode,
                    &orgSrcLeaf
                    )) {
                if (orgSrcNode) {
                    if (StringIPrefix (srcNode, orgSrcNode)) {
                        destNodePtr = srcNode + TcharCount (orgSrcNode);
                        if (destNodePtr && *destNodePtr) {
                            if (_tcsnextc (destNodePtr) == TEXT('\\')) {
                                destNodePtr = _tcsinc (destNodePtr);
                            }
                            if (destNodePtr) {
                                newDestNode = JoinPaths (destNode, destNodePtr);
                            }
                        }
                    }
                }
            }
        }

        if (!newDestNode) {
            newDestNode = destNode;
        }

        //
        // Expand the destination
        //
        MappingSearchAndReplaceEx (
            g_DestEnvMap,
            newDestNode,
            expDestNode,
            0,
            NULL,
            MAX_PATH,
            STRMAP_FIRST_CHAR_MUST_MATCH,
            NULL,
            NULL
            );

        ismExpDestNode = IsmExpandEnvironmentString (
                            PLATFORM_DESTINATION,
                            S_SYSENVVAR_GROUP,
                            expDestNode,
                            NULL
                            );

        if (destLeaf) {
            MappingSearchAndReplaceEx (
                g_DestEnvMap,
                destLeaf,
                expDestLeaf,
                0,
                NULL,
                MAX_PATH,
                STRMAP_FIRST_CHAR_MUST_MATCH,
                NULL,
                NULL
                );
            ismExpDestLeaf = IsmExpandEnvironmentString (
                                PLATFORM_DESTINATION,
                                S_SYSENVVAR_GROUP,
                                expDestLeaf,
                                NULL
                                );

        }

        if (destLeaf) {
            destHandle = IsmCreateObjectHandle (
                            ismExpDestNode?ismExpDestNode:expDestNode,
                            ismExpDestLeaf?ismExpDestLeaf:expDestLeaf
                            );
        } else {
            destHandle = IsmCreateObjectHandle (
                            ismExpDestNode?ismExpDestNode:expDestNode,
                            srcLeaf
                            );
        }

        if (ismExpDestNode) {
            IsmReleaseMemory (ismExpDestNode);
            ismExpDestNode = NULL;
        }
        if (ismExpDestLeaf) {
            IsmReleaseMemory (ismExpDestLeaf);
            ismExpDestLeaf = NULL;
        }

        if (destHandle) {
            OutputData->NewObject.ObjectName = destHandle;
        }
    }
    __finally {
        if (newDestNode && (newDestNode != destNode)) {
            FreePathString (newDestNode);
            newDestNode = NULL;
        }
        IsmDestroyObjectString (orgSrcNode);
        IsmDestroyObjectString (orgSrcLeaf);
        IsmDestroyObjectString (destNode);
        IsmDestroyObjectString (destLeaf);
        IsmDestroyObjectString (srcNode);
        IsmDestroyObjectString (srcLeaf);
    }

    return TRUE;
}


BOOL
WINAPI
FilterV1Move (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR destNode = NULL;
    // NTRAID#NTBUG9-153274-2000/08/01-jimschm Static buffer size
    TCHAR expDest[MAX_PATH * 4];
    PCTSTR destLeaf = NULL;
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PCTSTR pathStart;
    // NTRAID#NTBUG9-153274-2000/08/01-jimschm Static buffer size
    TCHAR pathCopy[MAX_PATH * 4];
    PCTSTR newDestNode = NULL;
    PCTSTR newerDestNode = NULL;
    PCTSTR subPath;
    BOOL b;
    CHARTYPE ch;
    MIG_OBJECTSTRINGHANDLE destHandle;

    __try {

        //
        // For v1 compatibility, we support only a transformation from
        // original source to inf-specified destination.  Chaining of
        // operations is not allowed (these are restrictions caused by the
        // existing INF syntax).
        //

        if (!DestinationOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing dest data in FilterV1Move"));
            __leave;
        }

        if ((InputData->CurrentObject.ObjectTypeId & (~PLATFORM_MASK)) != g_FileType) {
            DEBUGMSG ((DBG_ERROR, "Unexpected object type in FilterV1Move"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                DestinationOperationData->String,
                &destNode,
                &destLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split dest object in FilterV1Move"));
            __leave;
        }

        MYASSERT (destNode);

        if (!destNode) {
            DEBUGMSG ((DBG_ERROR, "Destination spec must be a node"));
            __leave;
        }

        if (destLeaf) {
            DEBUGMSG ((DBG_WARNING, "Dest leaf specification %s (in %s) ignored", destLeaf, destNode));
        }

        //
        // Find the longest CSIDL inside InputData.  Take that as the base directory,
        // and take the rest as the subdirectory.
        //

        if (!IsmCreateObjectStringsFromHandle (
                InputData->CurrentObject.ObjectName,
                &srcNode,
                &srcLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split v1 src object in FilterV1Move"));
            __leave;
        }

        if (!srcNode) {
            MYASSERT (FALSE);
            __leave;
        }

        //
        // If not a local path, do not process
        //

        if (!_istalpha ((CHARTYPE) _tcsnextc (srcNode)) ||
            _tcsnextc (srcNode + 1) != TEXT(':')
            ) {
            DEBUGMSG ((DBG_WARNING, "Ignoring %s\\%s because it does not have a drive spec", srcNode, srcLeaf));
            __leave;
        }

        ch = (CHARTYPE) _tcsnextc (srcNode + 2);

        if (ch && ch != TEXT('\\')) {
            DEBUGMSG ((DBG_WARNING, "Ignoring %s\\%s because it does not have a drive spec (2)", srcNode, srcLeaf));
            __leave;
        }

        //
        // Expand the destination
        //
        b = MappingSearchAndReplaceEx (
                g_DestEnvMap,
                destNode,
                expDest,
                0,
                NULL,
                MAX_PATH,
                STRMAP_FIRST_CHAR_MUST_MATCH,
                NULL,
                NULL
                );

        //
        // Skip over the drive spec
        //

        pathStart = srcNode;

        //
        // Find the longest CSIDL by using the reverse mapping table. This takes
        // our full path spec in pathStart and encodes it with an environment
        // variable.
        //

        b = MappingSearchAndReplaceEx (
                g_RevEnvMap,
                pathStart,
                pathCopy,
                0,
                NULL,
                ARRAYSIZE(pathCopy),
                STRMAP_FIRST_CHAR_MUST_MATCH|
                    STRMAP_RETURN_AFTER_FIRST_REPLACE|
                    STRMAP_REQUIRE_WACK_OR_NUL,
                NULL,
                &subPath
                );

#ifdef DEBUG
        if (!b) {
            TCHAR debugBuf[MAX_PATH];

            if (MappingSearchAndReplaceEx (
                    g_RevEnvMap,
                    pathStart,
                    debugBuf,
                    0,
                    NULL,
                    ARRAYSIZE(debugBuf),
                    STRMAP_FIRST_CHAR_MUST_MATCH|STRMAP_RETURN_AFTER_FIRST_REPLACE,
                    NULL,
                    NULL
                    )) {
                DEBUGMSG ((DBG_WARNING, "Ignoring conversion: %s -> %s", pathStart, debugBuf));
            }
        }
#endif

        if (!b) {
            subPath = pathStart + (UINT) (ch ? 3 : 2);
            *pathCopy = 0;
        } else {
            if (*subPath) {
                MYASSERT (_tcsnextc (subPath) == TEXT('\\'));

                *(PTSTR) subPath = 0;
                subPath++;
            }
        }

        //
        // pathCopy gives us the base, with CSIDL_ environment variables (might be an empty string)
        // subPath gives us the subdir (might also be an empty string)
        //
        // append subPath to the destination node
        //

        if (*subPath) {
            newDestNode = JoinPaths (expDest, subPath);
        } else {
            newDestNode = expDest;
        }

        destHandle = IsmCreateObjectHandle (newDestNode, srcLeaf);

        if (destHandle) {
            OutputData->NewObject.ObjectName = destHandle;
        }
    }
    __finally {
        IsmDestroyObjectString (destNode);
        IsmDestroyObjectString (destLeaf);
        IsmDestroyObjectString (srcNode);
        IsmDestroyObjectString (srcLeaf);

        if (newDestNode != expDest) {
            FreePathString (newDestNode);
        }
    }

    return TRUE;
}


BOOL
WINAPI
FilterMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    PCTSTR baseNode = NULL;
    PCTSTR baseLeaf = NULL;
    PCTSTR destNode = NULL;
    PCTSTR destLeaf = NULL;
    PCTSTR node;
    PCTSTR leaf;
    UINT baseNodeLen;

    __try {
        //
        // Take InputData, break it into node & leaf, take DestinationOperationData,
        // do the same, then replace InputData's node & leaf as appropriate.
        //

        if (!SourceOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing source data in general move operation"));
            __leave;
        }

        if (!DestinationOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing destination data in general move operation"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                InputData->CurrentObject.ObjectName,
                &srcNode,
                &srcLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split src object in general move operation"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                SourceOperationData->String,
                &baseNode,
                &baseLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split src object in general move operation"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                DestinationOperationData->String,
                &destNode,
                &destLeaf
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split dest object in general move operation"));
            __leave;
        }

        baseNodeLen = TcharCount (baseNode);
        node = NULL;
        leaf = NULL;
        if (StringIMatchTcharCount (srcNode, baseNode, baseNodeLen)) {
            if (srcNode [baseNodeLen]) {
                node = JoinPaths (destNode, &(srcNode [baseNodeLen]));
            } else {
                node = DuplicatePathString (destNode, 0);
            }
            if (!baseLeaf && !destLeaf) {
                leaf = srcLeaf;
            } else if (baseLeaf && srcLeaf && StringIMatch (srcLeaf, baseLeaf)) {
                leaf = destLeaf?destLeaf:baseLeaf;
            } else if (!baseLeaf && destLeaf) {
                if (srcLeaf) {
                    leaf = destLeaf;
                }
            } else {
                FreePathString (node);
                node = NULL;
            }
        }

        if (node) {
            OutputData->NewObject.ObjectName = IsmCreateObjectHandle (node, leaf);
            FreePathString (node);
            node = NULL;
        }
    }
    __finally {
        IsmDestroyObjectString (srcNode);
        IsmDestroyObjectString (srcLeaf);
        IsmDestroyObjectString (baseNode);
        IsmDestroyObjectString (baseLeaf);
        IsmDestroyObjectString (destNode);
        IsmDestroyObjectString (destLeaf);
    }

    return TRUE;
}


BOOL
WINAPI
FilterIniMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcFile = NULL;
    PTSTR srcSect = NULL;
    PTSTR srcKey = NULL;
    PCTSTR baseNode = NULL;
    PCTSTR baseFile = NULL;
    PTSTR baseSect = NULL;
    PTSTR baseKey = NULL;
    PCTSTR destNode = NULL;
    PCTSTR destFile = NULL;
    PTSTR destSect = NULL;
    PTSTR destKey = NULL;
    UINT baseNodeLen;
    BOOL nodeAlloc = FALSE;
    BOOL fileAlloc = FALSE;
    PCTSTR node = NULL;
    PCTSTR file = NULL;
    PCTSTR destSectKey = NULL;
    PCTSTR destLeaf = NULL;
    MIG_OBJECTSTRINGHANDLE baseNodeHandle = NULL;
    MIG_OBJECTSTRINGHANDLE newBaseNode = NULL;
    PCTSTR tempStr = NULL;

    __try {
        //
        // Take InputData, break it into node & leaf, take DestinationOperationData,
        // do the same, then replace InputData's node & leaf as appropriate.
        //

        if (!SourceOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing source data in general move operation"));
            __leave;
        }

        if (!DestinationOperationData) {
            DEBUGMSG ((DBG_ERROR, "Missing destination data in general move operation"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                InputData->CurrentObject.ObjectName,
                &srcNode,
                &srcFile
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split src object in general move operation"));
            __leave;
        }
        if (srcFile [0] == 0) {
            IsmDestroyObjectString (srcFile);
            srcFile = NULL;
        }
        if (srcFile) {
            srcSect = _tcschr (srcFile, TEXT('\\'));
            if (srcSect) {
                *srcSect = 0;
                srcSect ++;
                srcKey = _tcsrchr (srcSect, TEXT('='));
                if (srcKey) {
                    *srcKey = 0;
                    srcKey ++;
                }
            }
        }

        if (!srcNode || !srcFile || !srcSect || !srcKey) {
            DEBUGMSG ((DBG_ERROR, "INI src object expected to have node, file, section and key"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                SourceOperationData->String,
                &baseNode,
                &baseFile
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split base object in general move operation"));
            __leave;
        }
        if (baseFile [0] == 0) {
            IsmDestroyObjectString (baseFile);
            baseFile = NULL;
        }
        if (baseFile) {
            baseSect = _tcschr (baseFile, TEXT('\\'));
            if (baseSect) {
                *baseSect = 0;
                baseSect ++;
                baseKey = _tcsrchr (baseSect, TEXT('='));
                if (baseKey) {
                    *baseKey = 0;
                    baseKey ++;
                }
            }
        }

        if (!baseNode) {
            DEBUGMSG ((DBG_ERROR, "INI base object expected to have at least a node"));
            __leave;
        }

        if (!IsmCreateObjectStringsFromHandle (
                DestinationOperationData->String,
                &destNode,
                &destFile
                )) {
            DEBUGMSG ((DBG_ERROR, "Can't split dest object in general move operation"));
            __leave;
        }
        if (destFile [0] == 0) {
            IsmDestroyObjectString (destFile);
            destFile = NULL;
        }
        if (destFile) {
            destSect = _tcschr (destFile, TEXT('\\'));
            if (destSect) {
                *destSect = 0;
                destSect ++;
                destKey = _tcsrchr (destSect, TEXT('='));
                if (destKey) {
                    *destKey = 0;
                    destKey ++;
                }
            }
        }

        if (!destNode || (destNode [0] == 0)) {
            // We need to use the src node, there was no specification of
            // the node where the INI file is supposed to end up.
            if (!destFile || (destFile [0] == 0)) {
                // destFile is not specified. Let's filter the whole thing
                baseNodeHandle = IsmCreateObjectHandle (srcNode, srcFile);
                if (baseNodeHandle) {
                    newBaseNode = IsmFilterObject (
                                    g_FileType | PLATFORM_SOURCE,
                                    baseNodeHandle,
                                    NULL,
                                    NULL,
                                    NULL
                                    );
                    if (newBaseNode) {
                        IsmCreateObjectStringsFromHandle (newBaseNode, &node, &file);
                        nodeAlloc = TRUE;
                        fileAlloc = TRUE;
                        IsmDestroyObjectHandle (newBaseNode);
                    } else {
                        node = srcNode;
                        file = srcFile;
                    }
                    IsmDestroyObjectHandle (baseNodeHandle);
                }
            } else {
                // destFile is explicitely specified. Let's just filter the node
                baseNodeHandle = IsmCreateObjectHandle (srcNode, NULL);
                if (baseNodeHandle) {
                    newBaseNode = IsmFilterObject (
                                    g_FileType | PLATFORM_SOURCE,
                                    baseNodeHandle,
                                    NULL,
                                    NULL,
                                    NULL
                                    );
                    if (newBaseNode) {
                        IsmCreateObjectStringsFromHandle (newBaseNode, &node, &tempStr);
                        nodeAlloc = TRUE;
                        MYASSERT (!tempStr);
                        IsmDestroyObjectString (tempStr);
                        IsmDestroyObjectHandle (newBaseNode);
                    } else {
                        node = IsmDuplicateString (srcNode);
                    }
                    IsmDestroyObjectHandle (baseNodeHandle);
                }
            }
        }

        if (!node) {
            if (destNode && (destNode [0] != 0)) {
                node = destNode;
            } else {
                node = srcNode;
            }
        }

        if (!file) {
            if (destFile && (destFile [0] != 0)) {
                file = destFile;
            } else {
                file = srcFile;
            }
        }

        if (!destSect || (destSect [0] == 0)) {
            destSect = srcSect;
        }

        if (!destKey || (destKey [0] == 0)) {
            destKey = srcKey;
        }

        destSectKey = JoinTextEx (NULL, destSect, destKey, TEXT("="), 0, NULL);

        destLeaf = JoinPaths (file, destSectKey);

        OutputData->NewObject.ObjectName = IsmCreateObjectHandle (node, destLeaf);

        FreePathString (destLeaf);
        destLeaf = NULL;
        FreeText (destSectKey);
        destSectKey = NULL;
    }
    __finally {
        IsmDestroyObjectString (srcNode);
        IsmDestroyObjectString (srcFile);
        IsmDestroyObjectString (baseNode);
        IsmDestroyObjectString (baseFile);
        IsmDestroyObjectString (destNode);
        IsmDestroyObjectString (destFile);
        if (fileAlloc) {
            IsmDestroyObjectString (file);
        }
        if (nodeAlloc) {
            IsmDestroyObjectString (node);
        }
    }

    return TRUE;
}


BOOL
WINAPI
FilterDelete (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    //
    // Mark the output data as deleted.  That will be sufficient to
    // cause the object to be deleted (even if it was also marked as
    // "save")
    //

    OutputData->Deleted = TRUE;

    return TRUE;
}


BOOL
WINAPI
FilterRegAutoFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    // NTRAID#NTBUG9-153275-2000/08/01-jimschm Static buffer size
    TCHAR newNode[MAX_PATH * 4];
    TCHAR newLeaf[MAX_PATH * 4];
    BOOL change = FALSE;

    //
    // Filter the object name
    //

    IsmCreateObjectStringsFromHandle (
        InputData->CurrentObject.ObjectName,
        &node,
        &leaf
        );

    if (node) {
        if (MappingSearchAndReplaceEx (
                g_RegNodeFilterMap,         // map handle
                node,                       // source string
                newNode,                    // dest buffer
                0,                          // source string bytes (0=unspecified)
                NULL,                       // dest bytes required
                ARRAYSIZE(newNode),         // dest buffer size
                0,                          // flags
                NULL,                       // extra data value
                NULL                        // end of string
                )) {
            IsmDestroyObjectString (node);
            node = newNode;
            change = TRUE;
        }
    }

    if (leaf) {
        if (MappingSearchAndReplaceEx (
                g_RegLeafFilterMap,
                leaf,
                newLeaf,
                0,
                NULL,
                ARRAYSIZE(newLeaf),
                0,
                NULL,
                NULL
                )) {
            IsmDestroyObjectString (leaf);
            leaf = newLeaf;
            change = TRUE;
        }
    }

    if (change) {
        OutputData->NewObject.ObjectName = IsmCreateObjectHandle (node, leaf);
    }

    if (node != newNode) {
        IsmDestroyObjectString (node);
    }

    if (leaf != newLeaf) {
        IsmDestroyObjectString (leaf);
    }

    return TRUE;
}

BOOL
WINAPI
FilterIniAutoFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    // This function will split the INI object, filter the INI file
    // so we know where it ends up, get section and key through the
    // mapping so they can be potentially changed and rebuild the
    // object name.

    PCTSTR srcNode = NULL;
    PCTSTR srcFile = NULL;
    PTSTR srcSect = NULL;
    PTSTR srcKey = NULL;
    PCTSTR newNode = NULL;
    PCTSTR newFile = NULL;
    PCTSTR newSect = NULL;
    PCTSTR newKey = NULL;
    // NTRAID#NTBUG9-153275-2000/08/01-jimschm Static buffer size
    TCHAR sectBuff [MAXINISIZE];
    TCHAR keyBuff [MAXINISIZE];
    MIG_OBJECTSTRINGHANDLE iniFile = NULL;
    MIG_OBJECTSTRINGHANDLE newIniFile = NULL;
    PCTSTR sectKey = NULL;
    PCTSTR newLeaf = NULL;
    BOOL orgDeleted = FALSE;
    BOOL orgReplaced = FALSE;
    BOOL change = FALSE;

    //
    // Filter the object name
    //

    IsmCreateObjectStringsFromHandle (
        InputData->CurrentObject.ObjectName,
        &srcNode,
        &srcFile
        );

    if (srcNode && srcFile) {
        srcSect = _tcschr (srcFile, TEXT('\\'));
        if (srcSect) {
            *srcSect = 0;
            srcSect ++;
            srcKey = _tcsrchr (srcSect, TEXT('='));
            if (srcKey) {
                *srcKey = 0;
                srcKey ++;
                // let's see if the section is replaced
                if (MappingSearchAndReplaceEx (
                        g_IniSectFilterMap,         // map handle
                        srcSect,                    // source string
                        sectBuff,                   // dest buffer
                        0,                          // source string bytes (0=unspecified)
                        NULL,                       // dest bytes required
                        ARRAYSIZE(sectBuff),        // dest buffer size
                        0,                          // flags
                        NULL,                       // extra data value
                        NULL                        // end of string
                        )) {
                    newSect = sectBuff;
                    change = TRUE;
                }
                // let's see if the key is replaced
                if (MappingSearchAndReplaceEx (
                        g_IniSectFilterMap,         // map handle
                        srcKey,                     // source string
                        keyBuff,                    // dest buffer
                        0,                          // source string bytes (0=unspecified)
                        NULL,                       // dest bytes required
                        ARRAYSIZE(keyBuff),         // dest buffer size
                        0,                          // flags
                        NULL,                       // extra data value
                        NULL                        // end of string
                        )) {
                    newKey = keyBuff;
                    change = TRUE;
                }

                iniFile = IsmCreateObjectHandle (srcNode, srcFile);
                if (iniFile) {
                    newIniFile = IsmFilterObject (
                                    g_FileType | PLATFORM_SOURCE,
                                    iniFile,
                                    NULL,
                                    &orgDeleted,
                                    &orgReplaced
                                    );
                    if (newIniFile) {
                        if (IsmCreateObjectStringsFromHandle (newIniFile, &newNode, &newFile)) {
                            change = TRUE;
                        }
                        IsmDestroyObjectHandle (newIniFile);
                    }
                    IsmDestroyObjectHandle (iniFile);
                }
            }
        }
    }

    if (change) {
        sectKey = JoinTextEx (NULL, newSect?newSect:srcSect, newKey?newKey:srcKey, TEXT("="), 0, NULL);
        if (sectKey) {
            newLeaf = JoinPaths (newFile?newFile:srcFile, sectKey);
            if (newLeaf) {
                OutputData->NewObject.ObjectName = IsmCreateObjectHandle (newNode?newNode:srcNode, newLeaf);
                FreePathString (newLeaf);
                newLeaf = NULL;
            }
            FreeText (sectKey);
            sectKey = NULL;
        }
    }

    IsmDestroyObjectString (srcNode);
    IsmDestroyObjectString (srcFile);
    if (newNode) {
        IsmDestroyObjectString (newNode);
        newNode = NULL;
    }
    if (newFile) {
        IsmDestroyObjectString (newFile);
        newFile = NULL;
    }

    return TRUE;
}

BOOL
pOpmFindFile (
    IN      PCTSTR FileName
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR node, leaf, leafPtr;
    BOOL result = FALSE;

    objectName = IsmCreateObjectHandle (FileName, NULL);
    if (objectName) {
        if (IsmGetObjectIdFromName (MIG_FILE_TYPE | PLATFORM_SOURCE, objectName, TRUE) != 0) {
            result = TRUE;
        }
        IsmDestroyObjectHandle (objectName);
    }
    if (!result) {
        node = DuplicateText (FileName);
        leaf = _tcsrchr (node, TEXT('\\'));
        if (leaf) {
            leafPtr = (PTSTR) leaf;
            leaf = _tcsinc (leaf);
            *leafPtr = 0;
            objectName = IsmCreateObjectHandle (node, leaf);
            if (objectName) {
                if (IsmGetObjectIdFromName (MIG_FILE_TYPE | PLATFORM_SOURCE, objectName, TRUE) != 0) {
                    result = TRUE;
                }
                IsmDestroyObjectHandle (objectName);
            }
            *leafPtr = TEXT('\\');
        }
        FreeText (node);
    }

    return result;
}

BOOL
pOpmSearchPath (
    IN      PCTSTR FileName,
    IN      DWORD BufferLength,
    OUT     PTSTR Buffer
    )
{
    return FALSE;
}

MIG_OBJECTSTRINGHANDLE
pSimpleTryHandle (
    IN      PCTSTR FullPath
    )
{
    PCTSTR buffer;
    PTSTR leafPtr, leaf;
    MIG_OBJECTSTRINGHANDLE source = NULL;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    PTSTR workingPath;
    PCTSTR sanitizedPath;
    BOOL orgDeleted = FALSE;
    BOOL orgReplaced = FALSE;
    PCTSTR saved = NULL;

    sanitizedPath = SanitizePath (FullPath);
    if (!sanitizedPath) {
        return NULL;
    }

    source = IsmCreateObjectHandle (sanitizedPath, NULL);
    if (source) {
        result = IsmFilterObject (
                    g_FileType | PLATFORM_SOURCE,
                    source,
                    NULL,
                    &orgDeleted,
                    &orgReplaced
                    );
        // we do not want replaced directories
        // since they can be false hits
        if (orgDeleted) {
            if (result) {
                saved = result;
                result = NULL;
            }
        }
        if (!result && !orgDeleted) {
            result = source;
        } else {
            IsmDestroyObjectHandle (source);
            source = NULL;
        }
    }

    if (result) {
        goto exit;
    }

    buffer = DuplicatePathString (sanitizedPath, 0);

    leaf = _tcsrchr (buffer, TEXT('\\'));

    if (leaf) {
        leafPtr = leaf;
        leaf = _tcsinc (leaf);
        *leafPtr = 0;
        source = IsmCreateObjectHandle (buffer, leaf);
        *leafPtr = TEXT('\\');
    }

    FreePathString (buffer);

    if (source) {
        result = IsmFilterObject (
                        g_FileType | PLATFORM_SOURCE,
                        source,
                        NULL,
                        &orgDeleted,
                        &orgReplaced
                        );
        if (!result && !orgDeleted) {
            result = source;
        } else {
            if (!result) {
                result = saved;
            }
            IsmDestroyObjectHandle (source);
            source = NULL;
        }
    }

    if (result != saved) {
        IsmDestroyObjectHandle (saved);
        saved = NULL;
    }

exit:
    FreePathString (sanitizedPath);
    return result;
}

MIG_OBJECTSTRINGHANDLE
pTryHandle (
    IN      PCTSTR FullPath,
    IN      PCTSTR Hint,
    OUT     PCTSTR *TrimmedResult
    )
{
    PATH_ENUM pathEnum;
    PCTSTR newPath;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    PCTSTR nativeName = NULL;
    PCTSTR lastSegPtr;

    if (TrimmedResult) {
        *TrimmedResult = NULL;
    }

    result = pSimpleTryHandle (FullPath);
    if (result || (!Hint)) {
        return result;
    }
    if (EnumFirstPathEx (&pathEnum, Hint, NULL, NULL, FALSE)) {
        do {
            newPath = JoinPaths (pathEnum.PtrCurrPath, FullPath);
            result = pSimpleTryHandle (newPath);
            if (result) {
                AbortPathEnum (&pathEnum);
                FreePathString (newPath);
                // now, if the initial FullPath did not have any wack in it
                // we will take the last segment of the result and put it
                // in TrimmedResult
                if (TrimmedResult && (!_tcschr (FullPath, TEXT('\\')))) {
                    nativeName = IsmGetNativeObjectName (g_FileType, result);
                    if (nativeName) {
                        lastSegPtr = _tcsrchr (nativeName, TEXT('\\'));
                        if (lastSegPtr) {
                            lastSegPtr = _tcsinc (lastSegPtr);
                            if (lastSegPtr) {
                                *TrimmedResult = DuplicatePathString (lastSegPtr, 0);
                            }
                        }
                    }
                }
                return result;
            }
            FreePathString (newPath);
        } while (EnumNextPath (&pathEnum));
    }
    AbortPathEnum (&pathEnum);
    return NULL;
}

BOOL
WINAPI
DoRegAutoFilter (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR leafPtr = NULL;
    PDWORD valueType;
    MIG_OBJECTSTRINGHANDLE source;
    MIG_OBJECTSTRINGHANDLE destination;
    PCTSTR leaf;
    TCHAR expandBuffer[4096];
    TCHAR hintBuffer[4096];
    PTSTR buffer;
    GROWBUFFER result = INIT_GROWBUFFER;
    GROWBUFFER cmdLineBuffer = INIT_GROWBUFFER;
    PCMDLINE cmdLine;
    UINT u;
    PCTSTR data, p, end;
    PCTSTR nativeDest;
    PCTSTR newData, oldData;
    BOOL parsable;
    BOOL replaced = FALSE;
    BOOL orgDeleted = FALSE;
    BOOL orgReplaced = FALSE;
    PCTSTR trimmedResult = NULL;
    BOOL newContent = TRUE;
    PCTSTR destResult = NULL;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {

        parsable = FALSE;
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);
        if (valueType) {
            if (*valueType == REG_EXPAND_SZ ||
                *valueType == REG_SZ
                ) {

                parsable = TRUE;
            }
        } else {
            parsable = IsmIsObjectHandleNodeOnly (SrcObjectName);
        }

        if (parsable) {

            data = (PTSTR) CurrentContent->MemoryContent.ContentBytes;
            end = (PCTSTR) (CurrentContent->MemoryContent.ContentBytes + CurrentContent->MemoryContent.ContentSize);

            while (data < end) {
                if (*data == 0) {
                    break;
                }

                data = _tcsinc (data);
            }

            if (data >= end) {
                parsable = FALSE;
            }
        }

        if (parsable) {

            data = (PTSTR) CurrentContent->MemoryContent.ContentBytes;

            if ((*valueType == REG_EXPAND_SZ) ||
                (*valueType == REG_SZ)
                ) {
                //
                // Expand the data
                //

                MappingSearchAndReplaceEx (
                    g_EnvMap,
                    data,
                    expandBuffer,
                    0,
                    NULL,
                    ARRAYSIZE(expandBuffer),
                    0,
                    NULL,
                    NULL
                    );

                data = expandBuffer;
            }

            *hintBuffer = 0;
            if (DestinationOperationData &&
                (DestinationOperationData->Type == BLOBTYPE_STRING) &&
                (DestinationOperationData->String)
                ) {
                MappingSearchAndReplaceEx (
                    g_EnvMap,
                    DestinationOperationData->String,
                    hintBuffer,
                    0,
                    NULL,
                    ARRAYSIZE(hintBuffer),
                    0,
                    NULL,
                    NULL
                    );
            }

            destination = pTryHandle (data, *hintBuffer?hintBuffer:NULL, &trimmedResult);

            if (destination) {
                replaced = TRUE;
                if (trimmedResult) {
                    GbAppendString (&result, trimmedResult);
                    FreePathString (trimmedResult);
                } else {
                    nativeDest = IsmGetNativeObjectName (g_FileType, destination);
                    GbAppendString (&result, nativeDest);
                    IsmReleaseMemory (nativeDest);
                }
            }

            // finally, if we failed we are going to assume it's a command line
            if (!replaced) {
                newData = DuplicatePathString (data, 0);
                cmdLine = ParseCmdLineEx (data, NULL, &pOpmFindFile, &pOpmSearchPath, &cmdLineBuffer);
                if (cmdLine) {

                    //
                    // Find the file referenced in the list or command line
                    //
                    for (u = 0 ; u < cmdLine->ArgCount ; u++) {
                        p = cmdLine->Args[u].CleanedUpArg;

                        // first we try it as is

                        destination = pTryHandle (p, *hintBuffer?hintBuffer:NULL, &trimmedResult);

                        // maybe we have something like /m:c:\foo.txt
                        // we need to go forward until we find a sequence of
                        // <alpha>:\<something>
                        if (!destination && p[0] && p[1]) {

                            while (p[2]) {
                                if (_istalpha ((CHARTYPE) _tcsnextc (p)) &&
                                    p[1] == TEXT(':') &&
                                    p[2] == TEXT('\\')
                                    ) {

                                    destination = pTryHandle (p, *hintBuffer?hintBuffer:NULL, &trimmedResult);

                                    if (destination) {
                                        break;
                                    }
                                }
                                p ++;
                            }
                        }
                        if (destination) {
                            replaced = TRUE;
                            if (trimmedResult) {
                                oldData = StringSearchAndReplace (newData, p, trimmedResult);
                                if (oldData) {
                                    FreePathString (newData);
                                    newData = oldData;
                                }
                                FreePathString (trimmedResult);
                            } else {
                                nativeDest = IsmGetNativeObjectName (g_FileType, destination);
                                oldData = StringSearchAndReplace (newData, p, nativeDest);
                                if (oldData) {
                                    FreePathString (newData);
                                    newData = oldData;
                                }
                                IsmReleaseMemory (nativeDest);
                            }
                            IsmDestroyObjectHandle (destination);
                            destination = NULL;
                        }
                    }
                }
                GbFree (&cmdLineBuffer);
                if (!replaced) {
                    if (newData) {
                        FreePathString (newData);
                    }
                } else {
                    if (newData) {
                        GbAppendString (&result, newData);
                        FreePathString (newData);
                    }
                }
            }

            if (destination) {
                IsmDestroyObjectHandle (destination);
                destination = NULL;
            }

            if (replaced && result.Buf) {
                // looks like we have new content
                // Let's do one more check. If this is a REG_EXPAND_SZ we will do our best to
                // keep the stuff unexpanded. So if the source string expanded on the destination
                // machine is the same as the destination string we won't do anything.
                newContent = TRUE;
                if (*valueType == REG_EXPAND_SZ) {
                    destResult = IsmExpandEnvironmentString (
                                    PLATFORM_DESTINATION,
                                    S_SYSENVVAR_GROUP,
                                    (PCTSTR) CurrentContent->MemoryContent.ContentBytes,
                                    NULL
                                    );
                    if (destResult && StringIMatch (destResult, (PCTSTR)result.Buf)) {
                        newContent = FALSE;
                    }
                    if (destResult) {
                        IsmReleaseMemory (destResult);
                        destResult = NULL;
                    }
                }
                if (newContent) {
                    NewContent->MemoryContent.ContentSize = SizeOfString ((PCTSTR)result.Buf);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                    CopyMemory ((PTSTR)NewContent->MemoryContent.ContentBytes, result.Buf, NewContent->MemoryContent.ContentSize);
                }
            }

            GbFree (&result);
        }
    }

    return TRUE;
}

BOOL
WINAPI
DoIniAutoFilter (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    // This function will get the content of an INI key and see if there is
    // a path there somewhere. If yes, it will attempt to find the new
    // location for the file and replace it in the INI key content.

    PTSTR leafPtr = NULL;
    PDWORD valueType;
    MIG_OBJECTSTRINGHANDLE source;
    MIG_OBJECTSTRINGHANDLE destination;
    PCTSTR leaf;
    TCHAR expandBuffer[4096];
    TCHAR hintBuffer[4096];
    PTSTR buffer;
    GROWBUFFER result = INIT_GROWBUFFER;
    GROWBUFFER cmdLineBuffer = INIT_GROWBUFFER;
    PCMDLINE cmdLine;
    UINT u;
    PCTSTR data, p, end;
    PCTSTR nativeDest;
    PCTSTR newData, oldData;
    BOOL parsable;
    BOOL replaced = FALSE;
    BOOL orgDeleted = FALSE;
    BOOL orgReplaced = FALSE;
    PCTSTR trimmedResult = NULL;
    BOOL newContent = TRUE;
    PCTSTR destResult = NULL;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {

        data = (PTSTR) CurrentContent->MemoryContent.ContentBytes;
        end = (PCTSTR) (CurrentContent->MemoryContent.ContentBytes + CurrentContent->MemoryContent.ContentSize);

        parsable = TRUE;

        while (data < end) {
            if (*data == 0) {
                break;
            }

            data = _tcsinc (data);
        }

        if (data >= end) {
            parsable = FALSE;
        }

        if (parsable) {

            data = (PTSTR) CurrentContent->MemoryContent.ContentBytes;

            MappingSearchAndReplaceEx (
                g_EnvMap,
                data,
                expandBuffer,
                0,
                NULL,
                ARRAYSIZE(expandBuffer),
                0,
                NULL,
                NULL
                );

            data = expandBuffer;

            *hintBuffer = 0;
            if (DestinationOperationData &&
                (DestinationOperationData->Type == BLOBTYPE_STRING) &&
                (DestinationOperationData->String)
                ) {
                MappingSearchAndReplaceEx (
                    g_EnvMap,
                    DestinationOperationData->String,
                    hintBuffer,
                    0,
                    NULL,
                    ARRAYSIZE(hintBuffer),
                    0,
                    NULL,
                    NULL
                    );
            }

            destination = pTryHandle (data, *hintBuffer?hintBuffer:NULL, &trimmedResult);

            if (destination) {
                replaced = TRUE;
                if (trimmedResult) {
                    GbAppendString (&result, trimmedResult);
                    FreePathString (trimmedResult);
                } else {
                    nativeDest = IsmGetNativeObjectName (g_FileType, destination);
                    GbAppendString (&result, nativeDest);
                    IsmReleaseMemory (nativeDest);
                }
            }

            // finally, if we failed we are going to assume it's a command line
            if (!replaced) {
                newData = DuplicatePathString (data, 0);
                cmdLine = ParseCmdLineEx (data, NULL, &pOpmFindFile, &pOpmSearchPath, &cmdLineBuffer);
                if (cmdLine) {

                    //
                    // Find the file referenced in the list or command line
                    //
                    for (u = 0 ; u < cmdLine->ArgCount ; u++) {
                        p = cmdLine->Args[u].CleanedUpArg;

                        // first we try it as is

                        destination = pTryHandle (p, *hintBuffer?hintBuffer:NULL, &trimmedResult);

                        // maybe we have something like /m:c:\foo.txt
                        // we need to go forward until we find a sequence of
                        // <alpha>:\<something>
                        if (!destination && p[0] && p[1]) {

                            while (p[2]) {
                                if (_istalpha ((CHARTYPE) _tcsnextc (p)) &&
                                    p[1] == TEXT(':') &&
                                    p[2] == TEXT('\\')
                                    ) {

                                    destination = pTryHandle (p, *hintBuffer?hintBuffer:NULL, &trimmedResult);

                                    if (destination) {
                                        break;
                                    }
                                }
                                p ++;
                            }
                        }
                        if (destination) {
                            replaced = TRUE;
                            if (trimmedResult) {
                                oldData = StringSearchAndReplace (newData, p, trimmedResult);
                                if (oldData) {
                                    FreePathString (newData);
                                    newData = oldData;
                                }
                                FreePathString (trimmedResult);
                            } else {
                                nativeDest = IsmGetNativeObjectName (g_FileType, destination);
                                oldData = StringSearchAndReplace (newData, p, nativeDest);
                                if (oldData) {
                                    FreePathString (newData);
                                    newData = oldData;
                                }
                                IsmReleaseMemory (nativeDest);
                            }
                            IsmDestroyObjectHandle (destination);
                            destination = NULL;
                        }
                    }
                }
                GbFree (&cmdLineBuffer);
                if (!replaced) {
                    if (newData) {
                        FreePathString (newData);
                    }
                } else {
                    if (newData) {
                        GbAppendString (&result, newData);
                        FreePathString (newData);
                    }
                }
            }

            if (destination) {
                IsmDestroyObjectHandle (destination);
                destination = NULL;
            }

            if (replaced && result.Buf) {
                // looks like we have new content
                // Let's do one more check. If the source string has environment variables in it,
                // we will do our best to keep the stuff unexpanded. So if the source string
                // expanded on the destination machine is the same as the destination string
                // we won't do anything.
                newContent = TRUE;
                destResult = IsmExpandEnvironmentString (
                                PLATFORM_DESTINATION,
                                S_SYSENVVAR_GROUP,
                                (PCTSTR) CurrentContent->MemoryContent.ContentBytes,
                                NULL
                                );
                if (destResult && StringIMatch (destResult, (PCTSTR)result.Buf)) {
                    newContent = FALSE;
                }
                if (destResult) {
                    IsmReleaseMemory (destResult);
                    destResult = NULL;
                }
                if (newContent) {
                    NewContent->MemoryContent.ContentSize = SizeOfString ((PCTSTR)result.Buf);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                    CopyMemory ((PTSTR)NewContent->MemoryContent.ContentBytes, result.Buf, NewContent->MemoryContent.ContentSize);
                }
            }

            GbFree (&result);
        }
    }

    return TRUE;
}

BOOL
WINAPI
DoFixDefaultIcon (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_PROPERTYDATAID propDataId;
    MIG_BLOBTYPE propDataType;
    UINT requiredSize;
    PDWORD valueType;
    PICON_GROUP iconGroup = NULL;
    ICON_SGROUP iconSGroup = {0, NULL};
    PTSTR iconLibPath = NULL;
    INT iconNumber = 0;
    PTSTR dataCopy;

    if (CurrentContent->ContentInFile) {
        return TRUE;
    }
    valueType = (PDWORD)(CurrentContent->Details.DetailsData);
    if (*valueType != REG_SZ && *valueType != REG_EXPAND_SZ) {
        return TRUE;
    }
    // let's see if we have our property attached
    propDataId = IsmGetPropertyFromObject (SrcObjectTypeId, SrcObjectName, g_DefaultIconData);
    if (!propDataId) {
        return TRUE;
    }
    if (!IsmGetPropertyData (propDataId, NULL, 0, &requiredSize, &propDataType)) {
        return TRUE;
    }
    iconSGroup.DataSize = requiredSize;
    iconSGroup.Data = IsmGetMemory (requiredSize);
    if (!IsmGetPropertyData (propDataId, (PBYTE)iconSGroup.Data, requiredSize, NULL, &propDataType)) {
        IsmReleaseMemory (iconSGroup.Data);
        return TRUE;
    }
    if (!iconSGroup.DataSize) {
        IsmReleaseMemory (iconSGroup.Data);
        return TRUE;
    }
    iconGroup = IcoDeSerializeIconGroup (&iconSGroup);
    if (!iconGroup) {
        IsmReleaseMemory (iconSGroup.Data);
        return TRUE;
    }
    if (IsmGetEnvironmentString (
            PLATFORM_DESTINATION,
            NULL,
            S_ENV_ICONLIB,
            NULL,
            0,
            &requiredSize
            )) {
        iconLibPath = IsmGetMemory (requiredSize);
        if (IsmGetEnvironmentString (
                PLATFORM_DESTINATION,
                NULL,
                S_ENV_ICONLIB,
                iconLibPath,
                requiredSize,
                NULL
                )) {
            if (IcoWriteIconGroupToPeFile (iconLibPath, iconGroup, NULL, &iconNumber)) {
                // finally we wrote the icon, fix the content and tell scanstate that
                // we iconlib was used
                dataCopy = IsmGetMemory (SizeOfString (iconLibPath) + sizeof (TCHAR) + 20 * sizeof (TCHAR));
                wsprintf (dataCopy, TEXT("%s,%d"), iconLibPath, iconNumber);
                NewContent->MemoryContent.ContentSize = SizeOfString (dataCopy);
                NewContent->MemoryContent.ContentBytes = (PBYTE) dataCopy;
                IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_SAVE_ICONLIB);
            }
        }
        IsmReleaseMemory (iconLibPath);
    }
    IcoReleaseIconGroup (iconGroup);
    IsmReleaseMemory (iconSGroup.Data);

    return TRUE;
}

BOOL
pDoesDestObjectExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR nativeName;
    BOOL result = FALSE;

    nativeName = IsmGetNativeObjectName (PLATFORM_DESTINATION | MIG_FILE_TYPE, ObjectName);
    if (nativeName) {
        if (IsmGetRealPlatform () == PLATFORM_DESTINATION) {
            result = DoesFileExist (nativeName);
        }
        IsmReleaseMemory (nativeName);
        nativeName = NULL;
    }

    return result;
}

BOOL
WINAPI
FilterFileAutoFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR node, nodeWack;
    PCTSTR leaf;
    // NTRAID#NTBUG9-153275-2000/08/01-jimschm Static buffer size
    TCHAR newNode[MAX_PATH * 4];
    TCHAR newLeaf[MAX_PATH * 4];
    BOOL fullChanged = FALSE;
    PCTSTR nativeName;
    PTSTR leafPtr;
    BOOL changed = FALSE;

    if (InputData &&
        InputData->OriginalObject.ObjectName &&
        InputData->CurrentObject.ObjectName &&
        (InputData->OriginalObject.ObjectName != InputData->CurrentObject.ObjectName)
        ) {
        // this was already modified. Let's not touch it.
        return TRUE;
    }

    //
    // Filter the object name
    //

    IsmCreateObjectStringsFromHandle (
        InputData->CurrentObject.ObjectName,
        &node,
        &leaf
        );

    /*
    // I am taking this out. The point is,
    // even if we are not restoring the file,
    // we should get the best guess as to where
    // this file would end up in case it would
    // get moved.
    if (NoRestoreObject && leaf) {
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
        return TRUE;
    }
    */

    if (node && leaf) {
        // let's do a trick here. Let's build the native name and
        // see if we can find an env replacement for the entire
        // path
        nativeName = IsmGetNativeObjectName (InputData->CurrentObject.ObjectTypeId, InputData->CurrentObject.ObjectName);
        if (nativeName) {
            if (MappingSearchAndReplaceEx (
                    g_FileNodeFilterMap,        // map handle
                    nativeName,                 // source string
                    newNode,                    // dest buffer
                    0,                          // source string bytes (0=unspecified)
                    NULL,                       // dest bytes required
                    ARRAYSIZE(newNode),         // dest buffer size
                    STRMAP_COMPLETE_MATCH_ONLY, // flags
                    NULL,                       // extra data value
                    NULL                        // end of string
                    )) {
                // we have a replacement. Let's split it into node and leaf
                leafPtr = _tcsrchr (newNode, TEXT('\\'));
                if (leafPtr) {
                    *leafPtr = 0;
                    leafPtr ++;
                    StringCopy (newLeaf, leafPtr);
                    IsmDestroyObjectString (node);
                    node = newNode;
                    IsmDestroyObjectString (leaf);
                    leaf = newLeaf;
                    fullChanged = TRUE;
                }
            }
            IsmReleaseMemory (nativeName);
            nativeName = NULL;
        }
    }

    if (!fullChanged && node) {
        nodeWack = JoinPaths (node, TEXT(""));
        if (MappingSearchAndReplaceEx (
                g_FileNodeFilterMap,            // map handle
                nodeWack,                   // source string
                newNode,                        // dest buffer
                0,                              // source string bytes (0=unspecified)
                NULL,                       // dest bytes required
                ARRAYSIZE(newNode),             // dest buffer size
                STRMAP_FIRST_CHAR_MUST_MATCH|
                    STRMAP_RETURN_AFTER_FIRST_REPLACE|
                    STRMAP_REQUIRE_WACK_OR_NUL, // flags
                NULL,                       // extra data value
                NULL                            // end of string
                )) {
            IsmDestroyObjectString (node);
            node = newNode;
            changed = TRUE;
        } else {
            if (MappingSearchAndReplaceEx (
                    g_FileNodeFilterMap,            // map handle
                    node,                       // source string
                    newNode,                        // dest buffer
                    0,                              // source string bytes (0=unspecified)
                    NULL,                       // dest bytes required
                    ARRAYSIZE(newNode),             // dest buffer size
                    STRMAP_FIRST_CHAR_MUST_MATCH|
                        STRMAP_RETURN_AFTER_FIRST_REPLACE|
                        STRMAP_REQUIRE_WACK_OR_NUL, // flags
                    NULL,                       // extra data value
                    NULL                            // end of string
                    )) {
                IsmDestroyObjectString (node);
                node = newNode;
                changed = TRUE;
            }
        }

        FreePathString (nodeWack);
        nodeWack = NULL;
    }

    if (!fullChanged && leaf) {
        if (MappingSearchAndReplaceEx (
                g_FileLeafFilterMap,
                leaf,
                newLeaf,
                0,
                NULL,
                ARRAYSIZE(newLeaf),
                0,
                NULL,
                NULL
                )) {
            IsmDestroyObjectString (leaf);
            leaf = newLeaf;
            changed = TRUE;
        }
    }

    if (fullChanged || changed) {
        OutputData->NewObject.ObjectName = IsmCreateObjectHandle (node, leaf);
    }
    OutputData->Replaced = (NoRestoreObject||OutputData->Deleted)?pDoesDestObjectExist (OutputData->NewObject.ObjectName):0;

    if (node != newNode) {
        IsmDestroyObjectString (node);
    }

    if (leaf != newLeaf) {
        IsmDestroyObjectString (leaf);
    }

    return TRUE;
}


PCTSTR
pProcessRenameExMacro (
    IN     PCTSTR Node,
    IN     PCTSTR Leaf,      OPTIONAL
    IN     BOOL ZeroBase
    )
{
    PCTSTR workingStr;
    PTSTR macroStartPtr = NULL;
    PTSTR macroEndPtr = NULL;
    PTSTR macroCopy = NULL;
    DWORD macroLength = 0;
    PTSTR macroParsePtr = NULL;
    TCHAR macroBuffer [MAX_PATH];
    HRESULT hr;
    MIG_OBJECTSTRINGHANDLE testHandle = NULL;

    UINT index;
    PTSTR newString = NULL;

    // If Leaf is supplied, we are working only on the Leaf
    workingStr = Leaf ? Leaf : Node;

    // Extract macro
    macroStartPtr = _tcschr (workingStr, S_RENAMEEX_START_CHAR);
    if (macroStartPtr) {
        macroEndPtr = _tcschr (macroStartPtr + 1, S_RENAMEEX_END_CHAR);
    }
    if (macroEndPtr) {
        macroCopy = DuplicateText (macroStartPtr + 1);
        macroCopy[macroEndPtr-macroStartPtr-1] = 0;
    }

    if (macroCopy) {
        // Build a possible destination
        if (ZeroBase) {
            index = 0;
        } else {
            index = 1;
        }

        do {
            if (newString) {
                FreeText (newString);
                newString = NULL;
            }
            IsmDestroyObjectHandle (testHandle);

            __try {
                hr = StringCbPrintf (macroBuffer, sizeof (macroBuffer), macroCopy, index);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                // something went wrong. The pattern might have been terribly wrong
                hr = S_FALSE;
            }
            if (hr != S_OK) {
                // something is wrong with the rename pattern. Let's just get out of here.
                break;
            }
            newString = AllocText (
                            (HALF_PTR) (macroStartPtr - workingStr) +
                            TcharCount (macroBuffer) +
                            TcharCount (macroEndPtr) +
                            1
                            );
            if (newString) {
                StringCopyTcharCount (newString, workingStr, (HALF_PTR) (macroStartPtr - workingStr) + 1);
                StringCat (newString, macroBuffer);
                StringCat (newString, macroEndPtr + 1);
            }

            if (Leaf) {
                testHandle = IsmCreateObjectHandle (Node, newString);
            } else {
                testHandle = IsmCreateObjectHandle (newString, NULL);
            }
            index++;
        } while (pDoesDifferentRegExist (testHandle) ||
                 HtFindString (g_RegCollisionDestTable, testHandle));

        if (testHandle) {
            IsmDestroyObjectHandle (testHandle);
        }
        FreeText (macroCopy);
    }

    if (!newString) {
        newString = DuplicateText (workingStr);
    }

    return newString;
}

BOOL
WINAPI
FilterRenameExFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR doNode = NULL;
    PCTSTR doLeaf = NULL;
    PCTSTR destNode = NULL;
    PCTSTR newNode = NULL;
    PCTSTR rootNode;
    PCTSTR destLeaf = NULL;
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;
    // NTRAID#NTBUG9-153274-2000/08/01-jimschm Static buffer size
    TCHAR newSrcNode[MAX_PATH * 4];
    TCHAR newSrcLeaf[MAX_PATH * 4];
    HASHITEM hashItem;
    MIG_OBJECTSTRINGHANDLE storeHandle;
    MIG_OBJECTSTRINGHANDLE testHandle;
    MIG_OBJECTSTRINGHANDLE nodeHandle;
    PTSTR ptr = NULL;
    PTSTR ptr2;
    PTSTR workingStr;
    BOOL fFoundMatch = FALSE;
    BOOL zeroBase;


    IsmCreateObjectStringsFromHandle (
        InputData->CurrentObject.ObjectName,
        &srcNode,
        &srcLeaf
        );

    if (srcNode) {
        if (MappingSearchAndReplaceEx (
                g_RegNodeFilterMap,
                srcNode,
                newSrcNode,
                0,
                NULL,
                ARRAYSIZE(newSrcNode),
                0,
                NULL,
                NULL
                )) {
            IsmDestroyObjectString (srcNode);
            srcNode = newSrcNode;
        }
    }

    if (srcLeaf) {
        if (MappingSearchAndReplaceEx (
                g_RegLeafFilterMap,
                srcLeaf,
                newSrcLeaf,
                0,
                NULL,
                ARRAYSIZE(newSrcLeaf),
                0,
                NULL,
                NULL
                )) {
            IsmDestroyObjectString (srcLeaf);
            srcLeaf = newSrcLeaf;
        }
    }

    if (HtFindStringEx (g_RegCollisionSrcTable, InputData->OriginalObject.ObjectName, (PVOID)(&hashItem), FALSE)) {
        // We've already renamed this object

        HtCopyStringData (g_RegCollisionDestTable, hashItem, (PVOID)(&testHandle));
        IsmCreateObjectStringsFromHandle (testHandle, &destNode, &destLeaf);

        // Do not free testHandle here because it is a pointer into the hash table data

        OutputData->NewObject.ObjectName = IsmCreateObjectHandle (destNode, destLeaf);
        IsmDestroyObjectString (destNode);
        IsmDestroyObjectString (destLeaf);
        destNode;
        destLeaf = NULL;
    } else {
        // We've never seen this object yet

        IsmCreateObjectStringsFromHandle (DestinationOperationData->String, &doNode, &doLeaf);

        // Pick a new node

        // First check to see if this object's node has already been processed
        workingStr = DuplicateText(srcNode);
        if (workingStr) {
            do {
                nodeHandle = IsmCreateObjectHandle (workingStr, NULL);
                if (HtFindStringEx (g_RegCollisionSrcTable, nodeHandle, (PVOID)(&hashItem), FALSE)) {

                    HtCopyStringData (g_RegCollisionDestTable, hashItem, (PVOID)(&testHandle));
                    IsmCreateObjectStringsFromHandle (testHandle, &rootNode, NULL);
                    // Do not free testHandle here because it is a pointer into the hash table data

                    if (ptr) {
                        // if ptr is valid it means we found a match for a subkey
                        *ptr = TEXT('\\');
                        newNode = JoinText(rootNode, ptr);
                    } else {
                        // if ptr is NULL, we found a match for the full keyname
                        newNode = DuplicateText(rootNode);
                    }
                    IsmDestroyObjectString(rootNode);
                    fFoundMatch = TRUE;
                } else {
                    ptr2 = ptr;
                    ptr = (PTSTR)FindLastWack (workingStr);
                    if (ptr2) {
                        *ptr2 = TEXT('\\');
                    }
                    if (ptr) {
                        *ptr = 0;
                    }
                }
                IsmDestroyObjectHandle(nodeHandle);
            } while (FALSE == fFoundMatch && ptr);
            FreeText(workingStr);
        }

        zeroBase = (SourceOperationData &&
                    SourceOperationData->Type == BLOBTYPE_BINARY &&
                    SourceOperationData->BinarySize == sizeof(PCBYTE) &&
                    (BOOL)SourceOperationData->BinaryData == TRUE);

        if (FALSE == fFoundMatch) {
            // Nope, let's process the node
            destNode = pProcessRenameExMacro (doNode, NULL, zeroBase);
            newNode = DuplicateText(destNode);
            IsmDestroyObjectHandle(destNode);
        }

        // Now process the leaf, if the original object had a leaf
        if (srcLeaf) {
            if (doLeaf) {
                destLeaf = pProcessRenameExMacro (newNode, doLeaf, zeroBase);
                IsmDestroyObjectString (doLeaf);
            }
        }
        IsmDestroyObjectString (doNode);

        // Add this in the collision table
        testHandle = IsmCreateObjectHandle (newNode, destLeaf ? destLeaf : srcLeaf);
        storeHandle = DuplicateText (testHandle);
        hashItem = HtAddStringEx (g_RegCollisionDestTable, storeHandle, &storeHandle, FALSE);
        HtAddStringEx (g_RegCollisionSrcTable, InputData->OriginalObject.ObjectName, &hashItem, FALSE);

        // Update the output
        OutputData->NewObject.ObjectName = testHandle;
    }

    if (srcNode != NULL) {
        IsmDestroyObjectString (srcNode);
    }
    if (srcLeaf != NULL) {
        IsmDestroyObjectString (srcLeaf);
    }
    if (destLeaf != NULL) {
        IsmDestroyObjectString (destLeaf);
    }
    if (newNode != NULL) {
        FreeText(newNode);
    }

    return TRUE;
}

BOOL
WINAPI
FilterRenameIniExFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    // we should never get here since there is no INF rule
    // that would trigger this filter

    MYASSERT(FALSE);

    // As we said, we should never get here. If we do however, we
    // will just continue
    return TRUE;
}

BOOL
WINAPI
FilterPartitionMove (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;

    IsmCreateObjectStringsFromHandle (DestinationOperationData->String, &node, &leaf);

    OutputData->NewObject.ObjectName = IsmCreateObjectHandle (node, leaf);

    IsmDestroyObjectString (node);
    IsmDestroyObjectString (leaf);

    return TRUE;
}

BOOL
WINAPI
DoDestAddObject (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PMIG_CONTENT finalContent;

    if (DestinationOperationData == NULL) {
        return TRUE;
    }
    if (DestinationOperationData->Type != BLOBTYPE_BINARY) {
        return TRUE;
    }
    if (DestinationOperationData->BinarySize != sizeof (MIG_CONTENT)) {
        return TRUE;
    }

    finalContent = (PMIG_CONTENT) DestinationOperationData->BinaryData;
    CopyMemory (NewContent, finalContent, sizeof (MIG_CONTENT));

    return TRUE;
}

VOID
OEWarning (
    VOID
    )
{
    ERRUSER_EXTRADATA extraData;

    if (TRUE == g_OERulesMigrated) {
        // Send warning to app
        extraData.Error = ERRUSER_WARNING_OERULES;
        extraData.ErrorArea = ERRUSER_AREA_RESTORE;
        extraData.ObjectTypeId = 0;
        extraData.ObjectName = NULL;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));

        // Add to log
        LOG ((LOG_WARNING, (PCSTR) MSG_OE_RULES));
    }
}



VOID
OutlookWarning (
    VOID
    )
{
    PCTSTR expandedPath;
    MIG_OBJECT_ENUM objectEnum;
    PCTSTR enumPattern;
    ERRUSER_EXTRADATA extraData;

    expandedPath = IsmExpandEnvironmentString (PLATFORM_SOURCE,
                                               S_SYSENVVAR_GROUP,
                                               TEXT("%CSIDL_APPDATA%\\Microsoft\\Outlook"),
                                               NULL);
    if (expandedPath) {
        enumPattern = IsmCreateSimpleObjectPattern (expandedPath, FALSE, TEXT("*.rwz"), TRUE);
        if (enumPattern) {
            if (IsmEnumFirstSourceObject (&objectEnum, g_FileType, enumPattern)) {
                // Send warning to app
                extraData.Error = ERRUSER_WARNING_OUTLOOKRULES;
                extraData.ErrorArea = ERRUSER_AREA_RESTORE;
                extraData.ObjectTypeId = 0;
                extraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&extraData));

                // Add to log
                LOG ((LOG_WARNING, (PCSTR) MSG_OUTLOOK_RULES));

                IsmAbortObjectEnum (&objectEnum);
            }
            IsmDestroyObjectHandle (enumPattern);
        }
        IsmReleaseMemory (expandedPath);
    }

}

VOID
WINAPI
ScriptOpmTerminate (
    VOID
    )
{
    //
    //  Temporary place to trigger setting refresh/upgrade
    //

    if (!IsmCheckCancel()) {
        OEFixLastUser();
        WABMerge();
        OE4MergeStoreFolder();
        OE5MergeStoreFolders();
        OEWarning();
        OutlookWarning();
    }

    TerminateRestoreCallback ();
    TerminateSpecialRename();
    TerminateSpecialConversion();

    // LEAK: need to loop through table and FreeText the extra data
    HtFree (g_RegCollisionDestTable);
    g_RegCollisionDestTable = NULL;

    HtFree (g_RegCollisionSrcTable);
    g_RegCollisionSrcTable = NULL;

    DestroyStringMapping (g_RegNodeFilterMap);
    g_RegNodeFilterMap = NULL;

    DestroyStringMapping (g_RegLeafFilterMap);
    g_RegLeafFilterMap = NULL;

    DestroyStringMapping (g_FileNodeFilterMap);
    g_FileNodeFilterMap = NULL;

    DestroyStringMapping (g_FileLeafFilterMap);
    g_FileLeafFilterMap = NULL;

    DestroyStringMapping (g_IniSectFilterMap);
    g_IniSectFilterMap = NULL;

    DestroyStringMapping (g_IniKeyFilterMap);
    g_IniKeyFilterMap = NULL;

    DestroyStringMapping (g_DestEnvMap);
    g_DestEnvMap = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\parse.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    parse.c

Abstract:

    Implements parsing of script entries.

Author:

    Jim Schmidt (jimschm) 02-Jun-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef BOOL (SCRIPTTYPE_ALLOC_FN)(
                IN OUT      PATTRIB_DATA AttribData     CALLER_INITIALIZED
                );
typedef SCRIPTTYPE_ALLOC_FN *PSCRIPTTYPE_ALLOC_FN;

typedef BOOL (SCRIPTTYPE_FREE_FN)(
                IN          PATTRIB_DATA AttribData     ZEROED
                );
typedef SCRIPTTYPE_FREE_FN *PSCRIPTTYPE_FREE_FN;

typedef struct {
    PCTSTR Tag;
    PSCRIPTTYPE_ALLOC_FN AllocFunction;
    PSCRIPTTYPE_FREE_FN FreeFunction;
} TAG_TO_SCRIPTTYPEFN, *PTAG_TO_SCRIPTTYPEFN;

//
// Globals
//

// None

//
// Macro expansion list
//

#define SCRIPT_TYPES                                                                \
    DEFMAC(Registry,    pAllocRegistryScriptType,       pFreeIsmObjectScriptType)   \
    DEFMAC(File,        pAllocFileScriptType,           pFreeIsmObjectScriptType)   \
    DEFMAC(Directory,   pAllocDirectoryScriptType,      pFreeIsmObjectScriptType)   \
    DEFMAC(Text,        pAllocTextScriptType,           pFreeTextScriptType)        \
    DEFMAC(System,      pAllocSystemScriptType,         pFreeSystemScriptType)      \
    DEFMAC(INIFile,     pAllocIniFileScriptType,        pFreeIniFileScriptType)     \

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

#define DEFMAC(tag,fnA,fnF)         SCRIPTTYPE_ALLOC_FN fnA; SCRIPTTYPE_FREE_FN fnF;

SCRIPT_TYPES

#undef DEFMAC


#define DEFMAC(tag,fnA,fnF)         {TEXT(#tag),fnA,fnF},

TAG_TO_SCRIPTTYPEFN g_TagToScriptTypeFn[] = {
    SCRIPT_TYPES
    {NULL, NULL, NULL}
};

#undef DEFMAC

//
// Code
//

MIG_OBJECTSTRINGHANDLE
MakeRegExBase (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    )
{
    MIG_OBJECTSTRINGHANDLE objectBase = NULL;
    PTSTR ptr;
    PTSTR nodeCopy = NULL;
    PCTSTR nodeBase = NULL;
    BOOL useLeaf = FALSE;


    if (Node) {
        ptr = _tcschr (Node, TEXT('\\'));
        if (!ptr) {
            return NULL;
        }

        if (StringIPrefix (Node, TEXT("HKR\\"))) {
            nodeCopy = JoinText (TEXT("HKCU"), ptr);
        } else {
            nodeCopy = DuplicateText (Node);
        }

        if (nodeCopy) {
            nodeBase = GetPatternBase (nodeCopy);

            if (nodeBase) {
                if (Leaf && !_tcschr (Leaf, TEXT('*'))) {
                    useLeaf = TRUE;
                }
                objectBase = IsmCreateObjectHandle (nodeBase, useLeaf ? Leaf : NULL);
                FreePathString (nodeBase);
            }
            FreeText (nodeCopy);
        }
    }

    return objectBase;
}

MIG_OBJECTSTRINGHANDLE
CreatePatternFromNodeLeaf (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    )
{
    MIG_OBJECTSTRINGHANDLE pattern;
    MIG_SEGMENTS nodeSegment;
    MIG_SEGMENTS leafSegment;
    PTSTR fixedNode = NULL;

    // let's do some trick for registry objects that start with HKR
    if (Node &&
        (StringIMatch (Node, S_HKR) ||
         StringIMatchTcharCount (Node, TEXT("HKR\\"), 4)
         )
        ) {
        fixedNode = JoinText (S_HKCU, Node + 3);
        nodeSegment.Segment = fixedNode;
    } else {
        nodeSegment.Segment = Node;
    }

    nodeSegment.IsPattern = TRUE;
    leafSegment.Segment = Leaf;
    leafSegment.IsPattern = TRUE;

    pattern  = IsmCreateObjectPattern (&nodeSegment, Node ? 1 : 0, &leafSegment, Leaf ? 1 : 0);

    FreeText (fixedNode);

    return pattern;
}

MIG_OBJECTSTRINGHANDLE
TurnRegStringIntoHandle (
    IN      PCTSTR String,
    IN      BOOL Pattern,
    OUT     PBOOL HadLeaf           OPTIONAL
    )

/*++

Routine Description:

  TurnRegStringIntoHandle converts the script's reg syntax into a cobra
  object.

Arguments:

  String  - Specifies the registry key and value in the script syntax.
            The string must be in the following format:

            <root>\<key>\* [<value>]

            Each part is optional.

            <root> specifies HKCU, HKR, HKLM or HKCC.

            <key> specifies a subkey (such as Software\Microsoft\Windows)

            * specifies all subkeys. If <value> is not specified, then all
                values and subvalues are also included.

            <value> specifies a specific value name


  Pattern - Specifies TRUE if the registry string can contain a pattern, or
            FALSE if it cannot.

  HadLeaf - Receives TRUE if String contains a leaf specification, FALSE
            otherwise

Return Value:

  A handle to a cobra object string, or NULL if parsing failed.

--*/

{
    PTSTR strCopy;
    PTSTR p;
    PTSTR value = NULL;
    PTSTR valueEnd;
    PTSTR key;
    PTSTR keyEnd;
    BOOL tree = FALSE;
    MIG_SEGMENTS nodeSegment[2];
    UINT nodeCount;
    MIG_SEGMENTS leafSegment;
    UINT leafCount;
    MIG_OBJECTSTRINGHANDLE handle;
    BOOL noSubKeys;
    BOOL noWildcardLeaf;
    PCTSTR fixedKey = NULL;

    MYASSERT (String);
    if (!String) {
        return NULL;
    }

    if (Pattern) {
        noSubKeys = FALSE;
        noWildcardLeaf = FALSE;
    } else {
        noSubKeys = TRUE;
        noWildcardLeaf = TRUE;
    }

    //
    // Inbound syntax is key\* [value]
    //

    strCopy = DuplicateText (String);
    if (!strCopy) {
        return NULL;
    }

    key = (PTSTR) SkipSpace (strCopy);
    if (!key) {
        FreeText (strCopy);
        return NULL;
    }

    if (*key == TEXT('[')) {
        //
        // This is a value-only case
        //

        value = _tcsinc (key);
        key = NULL;

    } else {
        //
        // This is a key-value case, or key-only case
        //

        p = _tcschr (key, TEXT('['));

        if (p) {
            //
            // Save start of value
            //
            value = _tcsinc (p);
        } else {
            //
            // No value
            //
            p = GetEndOfString (key);
        }

        keyEnd = p;

        //
        // Find the true end of the key
        //

        p = _tcsdec2 (key, p);
        MYASSERT (p);           // assert this is not a value-only case
        p = (PTSTR) SkipSpaceR (key, p);

        if (p) {
            keyEnd = _tcsinc (p);
        }

        //
        // Test for \* at the end
        //

        p = _tcsdec2 (key, keyEnd);
        MYASSERT (p);

        if (p && _tcsnextc (p) == TEXT('*')) {
            p = _tcsdec2 (key, p);
            if (p && _tcsnextc (p) == TEXT('\\')) {
                keyEnd = p;
                tree = (noSubKeys == FALSE);
            }
        }

        //
        // Trim the key
        //

        *keyEnd = 0;
    }

    //
    // Parse the value
    //

    if (value) {
        value = (PTSTR) SkipSpace (value);
        valueEnd = _tcschr (value, TEXT(']'));

        if (!valueEnd) {
            LOG ((LOG_ERROR, (PCSTR) MSG_INF_SYNTAX_ERROR, String));
            value = NULL;
        } else {
            //
            // Trim the space at the end of value
            //

            p = _tcsdec2 (value, valueEnd);
            if (p) {
                p = (PTSTR) SkipSpaceR (value, p);
                if (p) {
                    valueEnd = _tcsinc (p);
                }
            }

            *valueEnd = 0;
        }
    }

    //
    // Create parsed pattern. Start with the node.
    //

    nodeSegment[0].Segment = key;
    nodeSegment[0].IsPattern = FALSE;

    nodeSegment[1].Segment = TEXT("\\*");
    nodeSegment[1].IsPattern = TRUE;

    if (tree) {
        nodeCount = 2;
    } else {
        nodeCount = 1;
    }

    //
    // compute the leaf
    //

    if (value) {
        leafSegment.Segment = value;
        leafSegment.IsPattern = FALSE;
    } else {
        leafSegment.Segment = TEXT("*");
        leafSegment.IsPattern = TRUE;
    }

    if (noWildcardLeaf && !value) {
        leafCount = 0;
    } else {
        leafCount = 1;
    }

    if (nodeCount && key &&
        (StringIMatch (key, S_HKR) ||
         StringIMatchTcharCount (key, TEXT("HKR\\"), 4)
         )
        ) {
        fixedKey = JoinText (S_HKCU, key + 3);
        nodeSegment[0].Segment = fixedKey;
    }

    handle = IsmCreateObjectPattern (
                    nodeSegment,
                    nodeCount,
                    leafCount?&leafSegment:NULL,
                    leafCount
                    );

    FreeText (strCopy);
    FreeText (fixedKey);

    if (HadLeaf) {
        *HadLeaf = (value != NULL);
    }

    return handle;
}


PTSTR
pCopyToDest (
    IN      PTSTR Destination,          OPTIONAL
    IN      CHARTYPE Char,
    IN      PUINT CharNr
    )
{
    UINT len = 1;

#ifdef UNICODE

    if (Destination) {
        *Destination++ = Char;
    }

    (*CharNr) ++;
    return Destination;

#else

    if (IsCharLeadByte ((INT) Char)) {
        len ++;
    }

    if (Destination) {
        CopyMemory (Destination, &Char, len);
        Destination += len;
    }

    (*CharNr) += len;
    return Destination;

#endif

}


// 1->? (if node, no \ or ., if leaf, no .), 2->* (if node, no \ or ., if leaf, no .) 3->* (no \) 4->* (unlimited)
UINT
pGetMode (
    IN      PCTSTR Source,
    IN      BOOL NodePattern,
    IN      BOOL PatternAfterWack,
    IN      BOOL FirstChar
    )
{
    UINT ch;
    BOOL end = FALSE;
    UINT mode = 0;

    ch = _tcsnextc (Source);

    while (ch) {

        switch (ch) {

        case TEXT('?'):
            if (mode < 1) {
                mode = 1;
            }
            break;

        case TEXT('*'):
            if (NodePattern) {
                if (mode < 3) {
                    mode = 3;
                }
            } else {
                if (mode < 4) {
                    mode = 4;
                }
            }
            break;

        case TEXT('\\'):
            if (NodePattern) {
                if (mode < 2) {
                    mode = 2;
                }
            }
            end = TRUE;
            break;

        case TEXT('.'):
            if (mode < 2) {
                mode = 2;
            }
            end = TRUE;
            break;

        default:
            end = TRUE;
        }

        if (end) {
            break;
        }

        Source = _tcsinc (Source);
        ch = _tcsnextc (Source);
    }

    if (!ch) {
        if ((PatternAfterWack || NodePattern) && (mode == 3)) {
            mode = 4;
        }

        if (mode < 2) {
            mode = 2;
        }
    }

    if (FirstChar && (mode == 3)) {
        mode = 4;
    }

    return mode;
}


BOOL
pCopyPatternEx (
    IN      UINT Mode,
    IN      PCTSTR *Source,
    IN      PTSTR *Destination,
    IN      PUINT CharNr,
    IN      BOOL NodePattern
    )
{
    CHARTYPE ch;
    BOOL end = FALSE;
    INT numChars = 0;
    UINT chars;
    TCHAR buffer [MAX_PATH] = TEXT("");

    ch = (CHARTYPE) _tcsnextc (*Source);

    while (ch) {

        switch (ch) {

        case TEXT('*'):
            if (Mode == 1) {
                end = TRUE;
                break;
            }

            numChars = -1;
            break;

        case TEXT('?'):
            if (numChars >= 0) {
                numChars ++;
            }

            break;

        default:
            end = TRUE;
            break;
        }

        if (end) {
            break;
        }

        *Source = _tcsinc (*Source);
        ch = (CHARTYPE) _tcsnextc (*Source);
    }

    // 1->? (if node, no \ or ., if leaf, no .), 2->* (if node, no \ or ., if leaf, no .) 3->* (no \) 4->* (unlimited)
    switch (Mode) {

    case 1:
        if (NodePattern) {
            if (numChars > 0) {
                wsprintf (buffer, TEXT("?[%d:!(\\,.)]"), numChars);
            } else {
                wsprintf (buffer, TEXT("?[!(\\,.)]"));
            }
        } else {
            if (numChars > 0) {
                wsprintf (buffer, TEXT("?[%d:!(.)]"), numChars);
            } else {
                wsprintf (buffer, TEXT("?[!(.)]"));
            }
        }
        break;

    case 2:
        if (NodePattern) {
            if (numChars > 0) {
                wsprintf (buffer, TEXT("*[%d:!(\\,.)]"), numChars);
            } else {
                wsprintf (buffer, TEXT("*[!(\\,.)]"));
            }
        } else {
            if (numChars > 0) {
                wsprintf (buffer, TEXT("*[%d:!(.)]"), numChars);
            } else {
                wsprintf (buffer, TEXT("*[!(.)]"));
            }
        }
        break;

    case 3:
        if (numChars > 0) {
            wsprintf (buffer, TEXT("*[%d:!(\\)]"), numChars);
        } else {
            wsprintf (buffer, TEXT("*[!(\\)]"));
        }
        break;

    case 4:
        if (numChars > 0) {
            wsprintf (buffer, TEXT("*[%d:]"), numChars);
        } else {
            wsprintf (buffer, TEXT("*[]"));
        }
        break;

    default:
        MYASSERT (FALSE);
    }

    chars = TcharCount (buffer);
    if (CharNr) {
        *CharNr += chars;
    }

    if (Destination && *Destination) {
        StringCopy (*Destination, buffer);
        *Destination += chars;
    }

    return TRUE;
}


BOOL
pCopyPattern (
    IN      PCTSTR *Source,
    IN      PTSTR *Destination,
    IN      PUINT CharNr,
    IN      BOOL NodePattern,
    IN      BOOL PatternAfterWack,
    IN      BOOL FirstChar
    )
{
    // 1->? (if node, no \ or ., if leaf, no .), 2->* (if node, no \ or ., if leaf, no .) 3->* (no \) 4->* (unlimited)
    UINT mode = 0;
    PTSTR result = NULL;

    mode = pGetMode (*Source, NodePattern, PatternAfterWack, FirstChar);

    return pCopyPatternEx (mode, Source, Destination, CharNr, NodePattern);
}


BOOL
pFixPattern (
    IN      PCTSTR Source,
    OUT     PTSTR Destination,          OPTIONAL
    OUT     PUINT DestinationChars,     OPTIONAL
    IN      BOOL PatternsNotAllowed,
    IN      BOOL TruncateAtPattern,
    IN      BOOL NodePattern
    )
{
    UINT chars = 1;
    UINT lastChars = 0;
    PTSTR lastWack = NULL;
    BOOL end = FALSE;
    BOOL result = TRUE;
    BOOL patternAfterWack = FALSE;
    BOOL firstChar = TRUE;
    CHARTYPE ch;

    if (Destination) {
        *Destination = 0;
    }

    ch = (CHARTYPE) _tcsnextc (Source);
    while (ch) {

        switch (ch) {
        case TEXT('*'):
        case TEXT('?'):
            if (TruncateAtPattern) {
                if (lastWack) {
                    *lastWack = 0;
                    chars = lastChars;
                }
                end = TRUE;
            } else if (PatternsNotAllowed) {
                result = FALSE;
                Destination = pCopyToDest (Destination, TEXT('^'), &chars);
                Destination = pCopyToDest (Destination, ch, &chars);
                Source = _tcsinc (Source);
            } else {
                if (lastWack && (_tcsinc (lastWack) == Destination)) {
                    patternAfterWack = TRUE;
                } else {
                    patternAfterWack = FALSE;
                }
                pCopyPattern (&Source, Destination?&Destination:NULL, &chars, NodePattern, patternAfterWack, firstChar);
            }
            break;

        case TEXT('\020'):
        case TEXT('<'):
        case TEXT('>'):
        case TEXT(','):
        case TEXT('^'):
            Destination = pCopyToDest (Destination, TEXT('^'), &chars);
            Destination = pCopyToDest (Destination, ch, &chars);
            Source = _tcsinc (Source);
            break;

        case TEXT('\\'):
            if (NodePattern) {
                lastWack = Destination;
                lastChars = chars;
            }

            Destination = pCopyToDest (Destination, ch, &chars);
            Source = _tcsinc (Source);
            break;

        case TEXT('.'):
            if (!NodePattern) {
                lastWack = Destination;
                lastChars = chars;
            }

            Destination = pCopyToDest (Destination, ch, &chars);
            Source = _tcsinc (Source);
            break;

        default:
            Destination = pCopyToDest (Destination, ch, &chars);
            Source = _tcsinc (Source);
            break;
        }

        firstChar = FALSE;

        if (end) {
            break;
        }

        ch = (CHARTYPE) _tcsnextc (Source);
    }

    if (Destination) {
        *Destination = 0;
    }

    if (DestinationChars) {
        *DestinationChars = chars;
    }

    return result;
}


MIG_OBJECTSTRINGHANDLE
TurnFileStringIntoHandle (
    IN      PCTSTR String,
    IN      DWORD Flags
    )

/*++

Routine Description:

  TurnFileStringIntoHandle converts a file specification from the script
  syntax into a cobra object.

Arguments:

  String - Specifies the file string in the script syntax.
           The string must be in the following format:

           <directory>\<file>

           Both parts are optional. The Flags member indicates how String
           is parsed.

  Flags  - Specifies zero or more of the following flags:

                PFF_NO_PATTERNS_ALLOWED - String cannot contain any wildcard
                                          characters.

                PFF_COMPUTE_BASE - Returns the directory portion of the string,
                                   and truncates the directory at the first
                                   wildcard if necessary.  Truncation is done
                                   at the backslashes only.

                PFF_NO_SUBDIR_PATTERN - Do not include a trailing \*, even if
                                        it was specified in String.

                PFF_NO_LEAF_PATTERN - Do not include a * for the leaf when
                                      String does not contain a file name.
                                      If a file name is specified, include it.

                PFF_PATTERN_IS_DIR - String does not specify a file name.  It
                                     is a directory only. The leaf portion of
                                     the object string will be a *.

                PFF_NO_LEAF_AT_ALL - Will return an object string that has a
                                     node only, and no leaf specified at all.


Return Value:

  A cobra object handle, or NULL if conversion failed.

--*/

{
    PTSTR p;
    PTSTR fileCopy = NULL;
    MIG_SEGMENTS nodeSegment[2];
    MIG_SEGMENTS leafSegment;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    BOOL tree = FALSE;
    PTSTR file = NULL;
    UINT nodeCount;
    UINT leafCount;
    UINT charsInPattern;
    BOOL noPatternsAllowed;
    BOOL computeBaseNode;
    BOOL noSubDirPattern;
    BOOL noLeafPattern;
    BOOL forceLeafToStar;
    PCTSTR node;
    PCTSTR leaf = NULL;
    PTSTR fixedNode = NULL;
    PTSTR fixedLeaf = NULL;
    PTSTR tempCopy;
    BOOL patternError = FALSE;

    noPatternsAllowed = (Flags & PFF_NO_PATTERNS_ALLOWED) == PFF_NO_PATTERNS_ALLOWED;
    computeBaseNode = (Flags & PFF_COMPUTE_BASE) == PFF_COMPUTE_BASE;
    noSubDirPattern = (Flags & PFF_NO_SUBDIR_PATTERN) == PFF_NO_SUBDIR_PATTERN;
    noLeafPattern = (Flags & PFF_NO_LEAF_PATTERN) == PFF_NO_LEAF_PATTERN;
    forceLeafToStar = (Flags & PFF_PATTERN_IS_DIR) == PFF_PATTERN_IS_DIR;

    //
    // Divide pattern into node and leaf
    //

    tempCopy = DuplicateText (SkipSpace (String));
    p = (PTSTR) SkipSpaceR (tempCopy, NULL);
    if (p) {
        p = _tcsinc (p);
        *p = 0;
    }

    node = tempCopy;

    if (!forceLeafToStar) {
        p = (PTSTR) FindLastWack (tempCopy);

        if (p) {

            leaf = SkipSpace (p + 1);
            *p = 0;

            p = (PTSTR) SkipSpaceR (tempCopy, NULL);
            if (p) {
                p = _tcsinc (p);
                *p = 0;
            }

        } else {
            if (!_tcschr (tempCopy, TEXT(':'))) {
                node = NULL;
                leaf = tempCopy;
            }
        }
    }

    //
    // Convert all ? wildcard chars to be compatibile with NT's file system
    // Escape all [ characters that follow wildcards
    //

    if (node) {

        p = (PTSTR) GetEndOfString (node);
        p = _tcsdec2 (node, p);

        if (p) {
            if (_tcsnextc (p) == TEXT('*')) {
                tree = TRUE;

                p = _tcsdec2 (node, p);
                if (p && _tcsnextc (p) == TEXT('\\')) {
                    *p = 0;
                } else {
                    tree = FALSE;
                }
            }
        }

        if (!pFixPattern (
                node,
                NULL,
                &charsInPattern,
                noPatternsAllowed,
                computeBaseNode,
                TRUE
                )) {
            patternError = TRUE;
        }

        if (charsInPattern) {
            fixedNode = AllocText (charsInPattern + 1);

            pFixPattern (
                node,
                fixedNode,
                NULL,
                noPatternsAllowed,
                computeBaseNode,
                TRUE
                );
        }
    }

    if (leaf && !computeBaseNode) {

        if (!pFixPattern (
                leaf,
                NULL,
                &charsInPattern,
                noPatternsAllowed,
                FALSE,
                FALSE
                )) {
            patternError = TRUE;
        }

        if (charsInPattern) {
            fixedLeaf = AllocText (charsInPattern + 1);

            pFixPattern (
                leaf,
                fixedLeaf,
                NULL,
                noPatternsAllowed,
                FALSE,
                FALSE
                );
        }
    }

    FreeText (tempCopy);
    INVALID_POINTER (tempCopy);

    //
    // Create the pattern string. Start by preparing the node segments.
    //

    nodeSegment[0].Segment = fixedNode;
    nodeSegment[0].IsPattern = TRUE;            // normally FALSE, but because the pattern charset is
                                                // exclusive of the valid filename charset, we allow
                                                // patterns to be in the node

    nodeSegment[1].Segment = TEXT("\\*");
    nodeSegment[1].IsPattern = TRUE;

    if (!fixedNode) {
        nodeCount = 0;
    } else if (!tree || noSubDirPattern || noPatternsAllowed) {
        nodeCount = 1;      // just the node, not its subnodes
    } else {
        nodeCount = 2;      // the node and its subnodes
    }

    //
    // Prepare the leaf segments. We want all leaves, a specific leaf, or
    // no leaf at all.
    //

    leafSegment.Segment = fixedLeaf;
    leafSegment.IsPattern = TRUE;
    leafCount = 1;

    MYASSERT (!forceLeafToStar || !fixedLeaf);

    if (!fixedLeaf) {
        if (noLeafPattern || noPatternsAllowed) {
            leafCount = 0;
        } else {
            leafSegment.Segment = TEXT("*");
        }
    }

    if (nodeCount || leafCount) {

        if ((fixedNode && *fixedNode) || (fixedLeaf && *fixedLeaf)) {
            result = IsmCreateObjectPattern (
                            nodeCount ? nodeSegment : NULL,
                            nodeCount,
                            leafCount ? &leafSegment : NULL,
                            leafCount
                            );
        }
    }

    FreeText (fixedNode);
    FreeText (fixedLeaf);

    return result;
}

MIG_OBJECTSTRINGHANDLE
TurnIniSpecIntoHandle (
    IN      PCTSTR IniFile,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      BOOL NodePatternsAllowed,
    IN      BOOL LeafPatternsAllowed
    )

/*++

Routine Description:

  TurnIniSpecIntoHandle converts a ini file specification from the script
  syntax into a cobra object.

Arguments:

  IniFile- Specifies the ini file in the script syntax.
           The string must be a full INI file specification

  Section- Specifies the full section or the section pattern

  Key    - Specifies the full key or the key pattern

  PatternsAllowed - if not, the function will compute the base object

Return Value:

  A cobra object handle, or NULL if conversion failed.

--*/

{
    UINT charsInPattern = 0;
    PTSTR iniNode = NULL;
    PTSTR iniLeaf = NULL;
    PTSTR fixedIniNode = NULL;
    PTSTR fixedIniLeaf = NULL;
    PTSTR fixedSect = NULL;
    PTSTR fixedKey = NULL;
    PCTSTR sectKey = NULL;
    PCTSTR leaf = NULL;
    MIG_SEGMENTS nodePat[1];
    MIG_SEGMENTS leafPat[1];
    UINT nrSegNode = 0;
    UINT nrSegLeaf = 0;
    MIG_OBJECTSTRINGHANDLE result = NULL;

    if (IniFile) {
        iniNode = DuplicatePathString (IniFile, 0);
        if (!iniNode) {
            // out of memory?
            return NULL;
        }

        iniLeaf = _tcsrchr (iniNode, TEXT('\\'));
        if (iniLeaf) {
            *iniLeaf = 0;
            iniLeaf ++;
        } else {
            // this was only a leaf specification
            iniLeaf = iniNode;
            iniNode = NULL;
        }
    }

    if (iniNode) {
        // let's fix the iniNode.
        if (!pFixPattern (
                iniNode,
                NULL,
                &charsInPattern,
                !NodePatternsAllowed,
                !NodePatternsAllowed,
                TRUE
                )) {
            // something is wrong with this INI node specification.
            // The rule is likely invalid
            return NULL;
        }

        fixedIniNode = AllocText (charsInPattern + 1);
        if (!fixedIniNode) {
            return NULL;
        }

        if (!pFixPattern (
                iniNode,
                fixedIniNode,
                NULL,
                !NodePatternsAllowed,
                !NodePatternsAllowed,
                TRUE
                )) {
            return NULL;
        }
    }

    if (iniLeaf) {
        // let's fix the iniLeaf.
        if (!pFixPattern (
                iniLeaf,
                NULL,
                &charsInPattern,
                !LeafPatternsAllowed,
                !LeafPatternsAllowed,
                FALSE
                )) {
            // something is wrong with this INI dir specification.
            // The rule is likely invalid
            return NULL;
        }

        fixedIniLeaf = AllocText (charsInPattern + 1);
        if (!fixedIniLeaf) {
            return NULL;
        }

        if (!pFixPattern (
                iniLeaf,
                fixedIniLeaf,
                NULL,
                !LeafPatternsAllowed,
                !LeafPatternsAllowed,
                FALSE
                )) {
            return NULL;
        }
    }

    // now let's fix the section specification. If it contains any pattern and patterns
    // are not allowed we will leave it NULL
    if (Section) {
        if (pFixPattern (
                Section,
                NULL,
                &charsInPattern,
                !LeafPatternsAllowed,
                FALSE,
                FALSE
                )) {
            fixedSect = AllocText (charsInPattern + 1);
            if (fixedSect) {
                pFixPattern (
                    Section,
                    fixedSect,
                    NULL,
                    !LeafPatternsAllowed,
                    FALSE,
                    FALSE
                    );
            }
        }
    }

    // now let's fix the key specification. If it contains any pattern and patterns
    // are not allowed we will leave it NULL
    if (Key) {
        if (pFixPattern (
                Key,
                NULL,
                &charsInPattern,
                !LeafPatternsAllowed,
                FALSE,
                FALSE
                )) {
            fixedKey = AllocText (charsInPattern + 1);
            if (fixedKey) {
                pFixPattern (
                    Key,
                    fixedKey,
                    NULL,
                    !LeafPatternsAllowed,
                    FALSE,
                    FALSE
                    );
            }
        }
    }

    // finally let's build the object name
    sectKey = JoinTextEx (NULL, fixedSect?fixedSect:TEXT(""), (fixedSect && fixedKey)?fixedKey:TEXT(""), TEXT("="), 0, NULL);
    if (!sectKey) {
        // something went wrong, let's get out of here
        FreeText (fixedIniLeaf);
        FreeText (fixedIniNode);
        if (fixedSect) {
            FreeText (fixedSect);
            fixedSect = NULL;
        }
        if (fixedKey) {
            FreeText (fixedKey);
            fixedKey = NULL;
        }
        return NULL;
    }
    if (!LeafPatternsAllowed) {
        if (iniLeaf && fixedIniLeaf && StringIMatch (fixedIniLeaf, iniLeaf)) {
            leaf = JoinTextEx (NULL, fixedIniLeaf, sectKey, TEXT("\\"), 0, NULL);
        } else {
            leaf = JoinTextEx (NULL, TEXT(""), sectKey, TEXT("\\"), 0, NULL);
        }
    } else {
        if (fixedIniLeaf) {
            leaf = JoinTextEx (NULL, fixedIniLeaf, sectKey, TEXT("\\"), 0, NULL);
        } else {
            leaf = JoinTextEx (NULL, TEXT(""), sectKey, TEXT("\\"), 0, NULL);
        }
    }
    if (!leaf) {
        // something went wrong, let's get out of here
        FreeText (fixedIniLeaf);
        FreeText (fixedIniNode);
        FreeText (sectKey);
        if (fixedSect) {
            FreeText (fixedSect);
            fixedSect = NULL;
        }
        if (fixedKey) {
            FreeText (fixedKey);
            fixedKey = NULL;
        }
        return NULL;
    }

    nodePat [0].Segment = fixedIniNode?fixedIniNode:TEXT("");
    nodePat [0].IsPattern = TRUE;
    nrSegNode ++;
    leafPat [0].Segment = leaf;
    leafPat [0].IsPattern = TRUE;
    nrSegLeaf ++;
    result = IsmCreateObjectPattern (nodePat, nrSegNode, leafPat, nrSegLeaf);

    if (fixedIniLeaf) {
        FreeText (fixedIniLeaf);
        fixedIniLeaf = NULL;
    }
    if (fixedIniNode) {
        FreeText (fixedIniNode);
        fixedIniNode = NULL;
    }
    FreeText (sectKey);
    FreeText (leaf);
    if (fixedSect) {
        FreeText (fixedSect);
        fixedSect = NULL;
    }
    if (fixedKey) {
        FreeText (fixedKey);
        fixedKey = NULL;
    }

    if (iniNode) {
        FreePathString (iniNode);
        iniNode = NULL;
    } else {
        if (iniLeaf) {
            FreePathString (iniLeaf);
            iniLeaf = NULL;
        }
    }

    return result;
}

MIG_OBJECTSTRINGHANDLE
TurnCertSpecIntoHandle (
    IN      PCTSTR CertStore,
    IN      PCTSTR CertName,
    IN      BOOL PatternsAllowed
    )

/*++

Routine Description:

  TurnIniSpecIntoHandle converts a ini file specification from the script
  syntax into a cobra object.

Arguments:

  IniFile- Specifies the ini file in the script syntax.
           The string must be a full INI file specification

  Section- Specifies the full section or the section pattern

  Key    - Specifies the full key or the key pattern

  PatternsAllowed - if not, the function will compute the base object

Return Value:

  A cobra object handle, or NULL if conversion failed.

--*/

{
    UINT charsInPattern = 0;
    PTSTR fixedStore = NULL;
    PTSTR fixedName = NULL;
    PCTSTR leaf = NULL;
    MIG_OBJECTSTRINGHANDLE result = NULL;

    // let's fix the certificate store. We know that no patterns are allowed here,
    // so we will just return NULL if we detect some pattern
    if (!pFixPattern (
            CertStore,
            NULL,
            &charsInPattern,
            TRUE,
            TRUE,
            TRUE
            )) {
        // something is wrong with this store specification.
        // The rule is likely invalid
        return NULL;
    }

    if (charsInPattern != (TcharCount (CertStore) + 1)) {
        // something is wrong with this store specification.
        // The rule is likely invalid
        return NULL;
    }

    fixedStore = AllocText (charsInPattern + 1);

    pFixPattern (
        CertStore,
        fixedStore,
        NULL,
        TRUE,
        TRUE,
        TRUE
        );

    if (!StringIMatch (CertStore, fixedStore)) {
        // something is wrong with this store specification.
        // The rule is likely invalid
        return NULL;
    }

    FreeText (fixedStore);

    // now let's fix the certificate specification. If it contains any pattern and patterns
    // are not allowed we will leave it NULL
    if (CertName) {
        if (pFixPattern (
                CertName,
                NULL,
                &charsInPattern,
                !PatternsAllowed,
                FALSE,
                FALSE
                )) {
            fixedName = AllocText (charsInPattern + 1);
            if (fixedName) {
                pFixPattern (
                    CertName,
                    fixedName,
                    NULL,
                    !PatternsAllowed,
                    FALSE,
                    FALSE
                    );
            }
        }
    }

    result = IsmCreateSimpleObjectPattern (CertStore, FALSE, fixedName?fixedName:TEXT(""), TRUE);
    if (fixedName) {
        FreeText (fixedName);
        fixedName = NULL;
    }

    return result;
}

BOOL
pAllocRegistryScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    TCHAR expandBuffer[4096];
    MIG_CONTENT objectContent;
    DWORD type;
    DWORD size;
    MULTISZ_ENUM multiSzEnum;
    PTSTR ptr;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // try to create encoded string
    AttribData->ObjectTypeId = g_RegType;
    AttribData->ObjectName = TurnRegStringIntoHandle (
                                AttribData->ScriptSpecifiedObject,
                                FALSE,
                                NULL
                                );

    if (!AttribData->ObjectName) {
        if (GetLastError() == ERROR_SUCCESS) {
            SetLastError (ERROR_INVALID_DATA);
        }
        return FALSE;
    }

    // try to acqure the object
    if (IsmAcquireObject (
            AttribData->ObjectTypeId,
            AttribData->ObjectName,
            &objectContent
            )) {

        AttribData->ObjectContent = IsmGetMemory (sizeof (MIG_CONTENT));
        CopyMemory (AttribData->ObjectContent, &objectContent, sizeof (MIG_CONTENT));

        // finally, we want to prepare the return string
        if (!AttribData->ObjectContent->ContentInFile &&
            (AttribData->ObjectContent->Details.DetailsSize == sizeof (DWORD)) &&
            AttribData->ObjectContent->MemoryContent.ContentBytes
            ) {

            type = *((PDWORD) AttribData->ObjectContent->Details.DetailsData);

            switch (type) {
            case REG_SZ:
                size = SizeOfString ((PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes);
                AttribData->ReturnString = (PCTSTR) IsmGetMemory (size);
                StringCopy (
                    (PTSTR) AttribData->ReturnString,
                    (PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes
                    );
                break;
            case REG_EXPAND_SZ:
                // we need to expand the content. This will be the return string
                AttribData->ReturnString = IsmExpandEnvironmentString (
                                                AttribData->Platform,
                                                S_SYSENVVAR_GROUP,
                                                (PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes,
                                                NULL
                                                );
                if (!AttribData->ReturnString) {
                    AttribData->ReturnString = IsmDuplicateString ((PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes);
                }
                break;
            case REG_MULTI_SZ:
                size = SizeOfMultiSz ((PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes);
                AttribData->ReturnString = (PCTSTR) IsmGetMemory (size);
                ((PTSTR)AttribData->ReturnString) [0] = 0;
                if (EnumFirstMultiSz (&multiSzEnum, (PCTSTR) AttribData->ObjectContent->MemoryContent.ContentBytes)) {
                    do {
                        StringCat (
                            (PTSTR)AttribData->ReturnString,
                            multiSzEnum.CurrentString
                            );
                        StringCat (
                            (PTSTR)AttribData->ReturnString,
                            TEXT(";")
                            );
                    } while (EnumNextMultiSz (&multiSzEnum));
                }
                break;
            case REG_DWORD:
            case REG_DWORD_BIG_ENDIAN:
                AttribData->ReturnString = (PCTSTR) IsmGetMemory ((sizeof (DWORD) * 2 + 3) * sizeof (TCHAR));
                wsprintf (
                    (PTSTR) AttribData->ReturnString,
                    TEXT("0x%08X"),
                    *((PDWORD) AttribData->ObjectContent->MemoryContent.ContentBytes)
                    );
                break;
            default:
                AttribData->ReturnString = (PCTSTR) IsmGetMemory ((AttribData->ObjectContent->
                                                        MemoryContent.ContentSize * 3 *
                                                        sizeof (TCHAR)) + sizeof (TCHAR)
                                                        );
                ptr = (PTSTR) AttribData->ReturnString;
                *ptr = 0;
                size = 0;
                while (size < AttribData->ObjectContent->MemoryContent.ContentSize) {
                    wsprintf (ptr, TEXT("%02X"), *(AttribData->ObjectContent->MemoryContent.ContentBytes + size));
                    size ++;
                    ptr = GetEndOfString (ptr);
                    if (size < AttribData->ObjectContent->MemoryContent.ContentSize) {
                        StringCopy (ptr, TEXT(","));
                        ptr = GetEndOfString (ptr);
                    }
                }
            }
        } else if (IsmIsObjectHandleNodeOnly (AttribData->ObjectName)) {
            //
            // Node only case
            //

            AttribData->ReturnString = (PCTSTR) IsmGetMemory (sizeof (TCHAR));
            ptr = (PTSTR) AttribData->ReturnString;
            *ptr = 0;
        }
    }

    return TRUE;
}

BOOL
pAllocFileScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTSTRINGHANDLE objectNameLong;
    PCTSTR nativeNameLong;
    MIG_CONTENT objectContent;
    PCTSTR sanitizedPath = NULL;
    PCTSTR longFileName = NULL;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    sanitizedPath = SanitizePath (AttribData->ScriptSpecifiedObject);
    if (!sanitizedPath) {
        if (GetLastError() == ERROR_SUCCESS) {
            SetLastError (ERROR_INVALID_DATA);
        }
        return FALSE;
    }

    longFileName = sanitizedPath;

    // let's get the long file name for this. We need to call
    // ISM for this because we might be on the wrong platform
    objectName = TurnFileStringIntoHandle (
                    longFileName,
                    PFF_NO_LEAF_PATTERN
                    );
    if (objectName) {
        objectNameLong = IsmGetLongName (MIG_FILE_TYPE|AttribData->Platform, objectName);
        if (objectNameLong) {
            nativeNameLong = IsmGetNativeObjectName (MIG_FILE_TYPE|AttribData->Platform, objectNameLong);
            if (nativeNameLong) {
                longFileName = DuplicatePathString (nativeNameLong, 0);
                IsmReleaseMemory (nativeNameLong);
            }
            IsmDestroyObjectHandle (objectNameLong);
        }
        IsmDestroyObjectHandle (objectName);
    }

    // try to create encoded string
    AttribData->ObjectTypeId = g_FileType;
    AttribData->ObjectName = TurnFileStringIntoHandle (
                                longFileName,
                                PFF_NO_LEAF_PATTERN
                                );

    if (!AttribData->ObjectName) {
        if (longFileName != sanitizedPath) {
            FreePathString (longFileName);
            longFileName = NULL;
        }
        FreePathString (sanitizedPath);
        if (GetLastError() == ERROR_SUCCESS) {
            SetLastError (ERROR_INVALID_DATA);
        }
        return FALSE;
    }

    // try to acqure the object
    if (IsmAcquireObject (
            AttribData->ObjectTypeId,
            AttribData->ObjectName,
            &objectContent
            )) {

        AttribData->ObjectContent = IsmGetMemory (sizeof (MIG_CONTENT));
        CopyMemory (AttribData->ObjectContent, &objectContent, sizeof (MIG_CONTENT));

        AttribData->ReturnString = IsmGetMemory (SizeOfString (longFileName));
        StringCopy ((PTSTR) AttribData->ReturnString, longFileName);
    }

    if (longFileName != sanitizedPath) {
        FreePathString (longFileName);
        longFileName = NULL;
    }
    FreePathString (sanitizedPath);

    return TRUE;
}

BOOL
pAllocDirectoryScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_OBJECTSTRINGHANDLE objectNameLong;
    PCTSTR nativeNameLong;
    MIG_CONTENT objectContent;
    PCTSTR sanitizedPath;
    PCTSTR longFileName = NULL;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    sanitizedPath = SanitizePath (AttribData->ScriptSpecifiedObject);

    if (!sanitizedPath) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    longFileName = sanitizedPath;

    // let's get the long file name for this. We need to call
    // ISM for this because we might be on the wrong platform
    objectName = TurnFileStringIntoHandle (
                    sanitizedPath,
                    PFF_PATTERN_IS_DIR | PFF_NO_LEAF_AT_ALL
                    );
    if (objectName) {
        objectNameLong = IsmGetLongName (MIG_FILE_TYPE|AttribData->Platform, objectName);
        if (objectNameLong) {
            nativeNameLong = IsmGetNativeObjectName (MIG_FILE_TYPE|AttribData->Platform, objectNameLong);
            if (nativeNameLong) {
                longFileName = DuplicatePathString (nativeNameLong, 0);
                IsmReleaseMemory (nativeNameLong);
            }
            IsmDestroyObjectHandle (objectNameLong);
        }
        IsmDestroyObjectHandle (objectName);
    }

    // try to create encoded string
    AttribData->ObjectTypeId = g_FileType;
    AttribData->ObjectName = TurnFileStringIntoHandle (
                                sanitizedPath,
                                PFF_PATTERN_IS_DIR | PFF_NO_LEAF_AT_ALL
                                );

    if (!AttribData->ObjectName) {
        if (longFileName != sanitizedPath) {
            FreePathString (longFileName);
            longFileName = NULL;
        }
        FreePathString (sanitizedPath);
        if (GetLastError() == ERROR_SUCCESS) {
            SetLastError (ERROR_INVALID_DATA);
        }
        return FALSE;
    }

    // try to acqure the object
    if (IsmAcquireObject (
            AttribData->ObjectTypeId,
            AttribData->ObjectName,
            &objectContent
            )) {

        AttribData->ObjectContent = IsmGetMemory (sizeof (MIG_CONTENT));
        CopyMemory (AttribData->ObjectContent, &objectContent, sizeof (MIG_CONTENT));

        AttribData->ReturnString = IsmGetMemory (SizeOfString (longFileName));
        StringCopy ((PTSTR) AttribData->ReturnString, longFileName);
    }

    if (longFileName != sanitizedPath) {
        FreePathString (longFileName);
        longFileName = NULL;
    }
    FreePathString (sanitizedPath);

    return TRUE;
}

BOOL
pFreeIsmObjectScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (AttribData->ReturnString) {
        IsmReleaseMemory (AttribData->ReturnString);
        AttribData->ReturnString = NULL;
    }
    AttribData->ObjectTypeId = 0;
    if (AttribData->ObjectName) {
        IsmDestroyObjectHandle (AttribData->ObjectName);
        AttribData->ObjectName = NULL;
    }
    if (AttribData->ObjectContent) {
        IsmReleaseObject (AttribData->ObjectContent);
        IsmReleaseMemory (AttribData->ObjectContent);
        AttribData->ObjectContent = NULL;
    }
    return TRUE;
}

BOOL
pAllocTextScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    AttribData->ReturnString = IsmGetMemory (SizeOfString (AttribData->ScriptSpecifiedObject));
    StringCopy ((PTSTR) AttribData->ReturnString, AttribData->ScriptSpecifiedObject);

    return TRUE;
}

BOOL
pFreeTextScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (AttribData->ReturnString) {
        IsmReleaseMemory (AttribData->ReturnString);
        AttribData->ReturnString = NULL;
    }
    return TRUE;
}

BOOL
pAllocSystemScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    PTSTR specificSection = NULL;
    MIG_OSVERSIONINFO versionInfo;
    UINT tchars;
    BOOL detected = FALSE;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have some registry
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    if (!IsmGetOsVersionInfo (PLATFORM_SOURCE, &versionInfo)) {
        return FALSE;
    }

    tchars = 1;
    if (versionInfo.OsTypeName) {
        tchars += TcharCount (versionInfo.OsTypeName) + 1;
    }
    if (versionInfo.OsMajorVersionName) {
        tchars += TcharCount (versionInfo.OsMajorVersionName) + 1;
    }
    if (versionInfo.OsMinorVersionName) {
        tchars += TcharCount (versionInfo.OsMinorVersionName);
    }

    specificSection = AllocText (tchars);
    if (!specificSection) {
        return FALSE;
    }

    if (!detected && versionInfo.OsTypeName) {

        wsprintf (
            specificSection,
            TEXT("%s"),
            versionInfo.OsTypeName
            );
        if (StringIMatch (AttribData->ScriptSpecifiedObject, specificSection)) {
            detected = TRUE;
        }

        if (!detected && versionInfo.OsMajorVersionName) {

            wsprintf (
                specificSection,
                TEXT("%s.%s"),
                versionInfo.OsTypeName,
                versionInfo.OsMajorVersionName
                );
            if (StringIMatch (AttribData->ScriptSpecifiedObject, specificSection)) {
                detected = TRUE;
            }

            if (!detected && versionInfo.OsMinorVersionName) {
                wsprintf (
                    specificSection,
                    TEXT("%s.%s.%s"),
                    versionInfo.OsTypeName,
                    versionInfo.OsMajorVersionName,
                    versionInfo.OsMinorVersionName
                    );
                if (StringIMatch (AttribData->ScriptSpecifiedObject, specificSection)) {
                    detected = TRUE;
                }
            }
        }
    }

    if (detected) {
        AttribData->ReturnString = IsmGetMemory (SizeOfString (AttribData->ScriptSpecifiedObject));
        StringCopy ((PTSTR) AttribData->ReturnString, AttribData->ScriptSpecifiedObject);
    }

    FreeText (specificSection);
    specificSection = NULL;

    return TRUE;
}

BOOL
pFreeSystemScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (AttribData->ReturnString) {
        IsmReleaseMemory (AttribData->ReturnString);
        AttribData->ReturnString = NULL;
    }
    return TRUE;
}

BOOL
pAllocIniFileScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    PTSTR fileName = NULL;
    PTSTR sectName = NULL;
    PTSTR keyName  = NULL;
    PTSTR charPtr  = NULL;
    PTSTR result   = NULL;
    DWORD allocatedChars;
    DWORD chars;

    if (!AttribData) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // verify that we have something specified
    if (!AttribData->ScriptSpecifiedObject) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // Now, let's extract the INI file name, section and key
    fileName = DuplicatePathString (AttribData->ScriptSpecifiedObject, 0);
    if (!fileName) {
        return FALSE;
    }

    charPtr = _tcschr (fileName, TEXT('/'));
    if (charPtr) {
        sectName = _tcsinc (charPtr);
        *charPtr = 0;
        if (sectName) {
            charPtr = _tcschr (sectName, TEXT('/'));
            if (charPtr) {
                keyName = _tcsinc (charPtr);
                *charPtr = 0;
            }
        }
    }

    result = NULL;
    allocatedChars = 256;
    do {
        if (result) {
            FreePathString (result);
        }
        allocatedChars *= 2;
        result = AllocPathString (allocatedChars);
        if (!result) {
            return FALSE;
        }
        chars = GetPrivateProfileString (
                    sectName,
                    keyName,
                    TEXT(""),
                    result,
                    allocatedChars,
                    fileName
                    );
    } while (chars >= allocatedChars - 1);

    if (chars) {
        AttribData->ReturnString = IsmGetMemory (SizeOfString (result));
        StringCopy ((PTSTR) AttribData->ReturnString, result);
        FreePathString (result);
        result = NULL;
        return TRUE;
    }
    FreePathString (result);
    result = NULL;
    FreePathString (fileName);
    fileName = NULL;
    return FALSE;
}

BOOL
pFreeIniFileScriptType (
    IN OUT      PATTRIB_DATA AttribData
    )
{
    if (AttribData->ReturnString) {
        IsmReleaseMemory (AttribData->ReturnString);
        AttribData->ReturnString = NULL;
    }
    return TRUE;
}

BOOL
AllocScriptType (
    IN OUT      PATTRIB_DATA AttribData     CALLER_INITIALIZED
    )
{
    PTAG_TO_SCRIPTTYPEFN scriptFn = g_TagToScriptTypeFn;

    while (scriptFn->Tag) {
        if (StringIMatch (scriptFn->Tag, AttribData->ScriptSpecifiedType)) {
            break;
        }
        scriptFn ++;
    }
    if (scriptFn->Tag) {
        return (scriptFn->AllocFunction (AttribData));
    } else {
        return FALSE;
    }
}

BOOL
FreeScriptType (
    IN          PATTRIB_DATA AttribData     ZEROED
    )
{
    PTAG_TO_SCRIPTTYPEFN scriptFn = g_TagToScriptTypeFn;

    while (scriptFn->Tag) {
        if (StringIMatch (scriptFn->Tag, AttribData->ScriptSpecifiedType)) {
            break;
        }
        scriptFn ++;
    }
    if (scriptFn->Tag) {
        return (scriptFn->FreeFunction (AttribData));
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\regconv.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regconv.c

Abstract:

    Implements registry special conversion.

Author:

    Calin Negreanu (calinn) 5-May-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"
#include <wingdip.h>
#include <shlobjp.h>
#include <shlwapi.h>


//
// Strings
//

#define DBG_CONVERSION  "SpecialConversion"

//
// Constants
//

#define COLOR_MENU              4
#define COLOR_HIGHLIGHT         13
#define COLOR_BTNFACE           15
#define COLOR_BUTTONALTFACE     25
#define COLOR_HOTLIGHT          26
#define COLOR_GRADIENTACTIVECAPTION 27
#define COLOR_GRADIENTINACTIVECAPTION 28
#define COLOR_MENUHILIGHT       29
#define COLOR_MENUBAR           30

#define DISPLAY_BITMASK     0x00161E2F
#define MOUSE_BITMASK       0x0001E000

//
// Macros
//

#define pGetDestDwordValue(Key,Value) pGetDwordValue(Key, Value, PLATFORM_DESTINATION)
#define pGetSrcDwordValue(Key,Value) pGetDwordValue(Key, Value, PLATFORM_SOURCE)


//
// Types
//

typedef struct {
    SHORT lfHeight;
    SHORT lfWidth;
    SHORT lfEscapement;
    SHORT lfOrientation;
    SHORT lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    char lfFaceName[LF_FACESIZE];
} SHORT_LOGFONT, *PSHORT_LOGFONT;

//
// NT uses only UNICODE structures, and pads the members
// to 32-bit boundaries.
//

#define COLOR_MAX_V1 25
#define COLOR_MAX_V2 25
#define COLOR_MAX_V3 25
#define COLOR_MAX_V4 29
#define COLOR_MAX_NT 29     // this is a modified version 2 format, similar to 4

typedef struct {
    SHORT version;              // 2 for NT UNICODE
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_NT];
} SCHEMEDATA_NT, *PSCHEMEDATA_NT;

//
// Win95 uses NONCLIENTMETRICSA which has LOGFONTA members,
// but it uses a 16-bit LOGFONT as well.
//

#pragma pack(push)
#pragma pack(1)

typedef struct {
    SHORT version;              // 1 for Win95 ANSI
    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V1];
} SCHEMEDATA_V1, *PSCHEMEDATA_V1;

typedef struct {
    SHORT version;              // 1 for Win95 ANSI

    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V1A, *PSCHEMEDATA_V1A;

typedef struct {
    SHORT version;              // 2 for WinNT UNICODE with reduced color table
    WORD Dummy;
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_V2];
} SCHEMEDATA_V2, *PSCHEMEDATA_V2;

typedef struct {
    SHORT version;              // 3 for Win98 ANSI, 4 for portable format
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V3];
} SCHEMEDATA_V3, *PSCHEMEDATA_V3;

typedef struct {
    SHORT version;              // 4 for Win32 format (whatever that means)
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V4, *PSCHEMEDATA_V4;

#pragma pack(pop)

typedef struct
{
    UINT cbSize;
    SHELLSTATE ss;
} REGSHELLSTATE, *PREGSHELLSTATE;

//
// Globals
//

MIG_OPERATIONID g_ConvertToDwordOp;
MIG_OPERATIONID g_ConvertToStringOp;
DWORD g_IdentityCount = 0;
HASHTABLE g_IdentityDestTable;

//
// Macro expansion list
//

#define CONVERSION_FUNCTIONS        \
        DEFMAC(CONVERTTODWORD,          NULL,   EDIT.ConvertToDword,            pConvertToDwordCallback         )  \
        DEFMAC(CONVERTTOSTRING,         NULL,   EDIT.ConvertToString,           pConvertToStringCallback        )  \
        DEFMAC(CONVERTLOGFONT,          NULL,   EDIT.ConvertLogFont,            pConvertLogFontCallback         )  \
        DEFMAC(FONTDPICHANGE,           NULL,   EDIT.FontDPIChange,             pFontDPIChange                  )  \
        DEFMAC(FRAMEDPICHANGE,          NULL,   EDIT.FrameDPIChange,            pFrameDPIChange                 )  \
        DEFMAC(ANTIALIAS,               NULL,   EDIT.AntiAlias,                 pAntiAliasCallback              )  \
        DEFMAC(FIXACTIVEDESKTOP,        NULL,   EDIT.FixActiveDesktop,          pFixActiveDesktopCallback       )  \
        DEFMAC(CONVERTRECENTDOCSMRU,    NULL,   EDIT.ConvertRecentDocsMRU,      pConvertRecentDocsMRUCallback   )  \
        DEFMAC(CONVERTAPPEARANCESCHEME, NULL,   EDIT.ConvertAppearanceScheme,   pConvertAppearanceSchemeCallback)  \
        DEFMAC(CONVERTSCNSAVER,         NULL,   EDIT.ConvertScnSaver,           pConvertScnSaver                )  \
        DEFMAC(CONVERTOE4IAMACCTNAME,   NULL,   EDIT.ConvertOE4IAMAcctName,     pConvertOE4IAMAcctName          )  \
        DEFMAC(CONVERTOE5IAMACCTNAME,   NULL,   EDIT.ConvertOE5IAMAcctName,     pConvertOE5IAMAcctName          )  \
        DEFMAC(CONVERTIAMACCTNAME,      NULL,   EDIT.ConvertIAMAcctName,        pConvertIAMAcctName             )  \
        DEFMAC(CONVERTOMIACCOUNTNAME,   NULL,   EDIT.ConvertOMIAccountName,     pConvertOMIAccountName          )  \
        DEFMAC(CONVERTIDENTITYCOUNT,    NULL,   EDIT.ConvertIdentityCount,      pConvertIdentityCount           )  \
        DEFMAC(CONVERTIDENTITYINDEX,    NULL,   EDIT.ConvertIdentityIndex,      pConvertIdentityIndex           )  \
        DEFMAC(CONVERTIDENTITYUSERNAME, NULL,   EDIT.ConvertIdentityUsername,   pConvertIdentityUsername        )  \
        DEFMAC(CONVERTIDENTITYGUID,     NULL,   EDIT.ConvertIdentityGuid,       pConvertIdentityGuid            )  \
        DEFMAC(CONVERTOE5STATIONERY,    NULL,   Edit.ConvertOE5Stationery,      pConvertOE5Stationery           )  \
        DEFMAC(CONVERTSETDWORDTRUE,     NULL,   EDIT.ConvertSetDwordTrue,       pConvertSetDwordTrue            )  \
        DEFMAC(CONVERTSETDWORDFALSE,    NULL,   EDIT.ConvertSetDwordFalse,      pConvertSetDwordFalse           )  \
        DEFMAC(CONVERTPSTBLOB,          NULL,   EDIT.ConvertPSTBlob,            pConvertPSTBlob                 )  \
        DEFMAC(CONVERTOFFICELANGID,     NULL,   EDIT.ConvertOfficeLangId,       pConvertOfficeLangId            )  \
        DEFMAC(CONVERTOUTLOOKLANGID,    NULL,   EDIT.ConvertOutlookLangId,      pConvertOutlookLangId           )  \
        DEFMAC(CONVERTACCESSLANGID,     NULL,   EDIT.ConvertAccessLangId,       pConvertAccessLangId            )  \
        DEFMAC(CONVERTEXCELLANGID,      NULL,   EDIT.ConvertExcelLangId,        pConvertExcelLangId             )  \
        DEFMAC(CONVERTFRONTPAGELANGID,  NULL,   EDIT.ConvertFrontPageLangId,    pConvertFrontPageLangId         )  \
        DEFMAC(CONVERTPOWERPOINTLANGID, NULL,   EDIT.ConvertPowerPointLangId,   pConvertPowerPointLangId        )  \
        DEFMAC(CONVERTPUBLISHERLANGID,  NULL,   EDIT.ConvertPublisherLangId,    pConvertPublisherLangId         )  \
        DEFMAC(CONVERTWORDLANGID,       NULL,   EDIT.ConvertWordLangId,         pConvertWordLangId              )  \
        DEFMAC(CONVERTOFFICE2000LANGID, NULL,   EDIT.ConvertOffice2000LangId,   pConvertOffice2000LangId        )  \
        DEFMAC(MIGRATESOUNDSYSTRAY,     NULL,   EDIT.MigrateSoundSysTray,       pMigrateSoundSysTray            )  \
        DEFMAC(MIGRATEAPPEARANCEUPM,    NULL,   EDIT.MigrateAppearanceUPM,      pMigrateAppearanceUPM           )  \
        DEFMAC(MIGRATEMOUSEUPM,         NULL,   EDIT.MigrateMouseUPM,           pMigrateMouseUPM                )  \
        DEFMAC(MIGRATEOFFLINESYSTRAY,   NULL,   EDIT.MigrateOfflineSysTray,     pMigrateOfflineSysTray          )  \
        DEFMAC(MIGRATEDISPLAYSS,        NULL,   EDIT.MigrateDisplaySS,          pMigrateDisplaySS               )  \
        DEFMAC(MIGRATEDISPLAYCS,        NULL,   EDIT.MigrateDisplayCS,          pMigrateDisplayCS               )  \
        DEFMAC(MIGRATETASKBARSSPRESERVE,NULL,   EDIT.MigrateTaskBarSSPreserve,  pMigrateTaskBarSSPreserve       )  \
        DEFMAC(MIGRATETASKBARSSFORCE,   NULL,   EDIT.MigrateTaskBarSSForce,     pMigrateTaskBarSSForce          )  \
        DEFMAC(CONVERTSHOWIEONDESKTOP,  NULL,   EDIT.ConvertShowIEOnDesktop,    pConvertShowIEOnDesktop         )  \
        DEFMAC(MIGRATEACTIVEDESKTOP,    NULL,   EDIT.MigrateActiveDesktop,      pMigrateActiveDesktop           )  \


//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

//
// Declare special conversion operation apply callback functions
//
#define DEFMAC(ifn,ec,opn,opc) OPMAPPLYCALLBACK opc;
CONVERSION_FUNCTIONS
#undef DEFMAC

//
// This is the structure used for handling action functions
//
typedef struct {
    PCTSTR InfFunctionName;
    PSGMENUMERATIONCALLBACK EnumerationCallback;
    PCTSTR OperationName;
    MIG_OPERATIONID OperationId;
    POPMAPPLYCALLBACK OperationCallback;
} CONVERSION_STRUCT, *PCONVERSION_STRUCT;

//
// Declare a global array of conversion functions
//
#define DEFMAC(ifn,ec,opn,opc) {TEXT("\\")TEXT(#ifn),ec,TEXT(#opn),0,opc},
static CONVERSION_STRUCT g_ConversionFunctions[] = {
                              CONVERSION_FUNCTIONS
                              {NULL, NULL, NULL, 0, NULL}
                              };
#undef DEFMAC

//
// Code
//

BOOL
IsValidRegSz(
    IN      PCMIG_CONTENT ObjectContent
    )
{
    return ((!ObjectContent->ContentInFile) &&
            (ObjectContent->MemoryContent.ContentSize) &&
            (ObjectContent->MemoryContent.ContentBytes) &&
            (ObjectContent->Details.DetailsSize == sizeof (DWORD)) &&
            (ObjectContent->Details.DetailsData) &&
            ((*((PDWORD)ObjectContent->Details.DetailsData) == REG_SZ) ||
             (*((PDWORD)ObjectContent->Details.DetailsData) == REG_EXPAND_SZ)));
}

BOOL
IsValidRegType (
    IN      PCMIG_CONTENT CurrentContent,
    IN      DWORD RegType
    )
{
    return ((!CurrentContent->ContentInFile) &&
            (CurrentContent->Details.DetailsSize == sizeof (DWORD)) &&
            (CurrentContent->Details.DetailsData) &&
            (*((PDWORD)CurrentContent->Details.DetailsData) == RegType) &&
            (CurrentContent->MemoryContent.ContentSize) &&
            (CurrentContent->MemoryContent.ContentBytes));
}

DWORD
pGetDwordValue (
    IN      PTSTR Key,
    IN      PTSTR Value,
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    DWORD value = 0;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;

    objectName = IsmCreateObjectHandle (Key, Value);

    if (IsmAcquireObject (g_RegType | Platform, objectName, &objectContent)) {
        if (IsValidRegType(&objectContent, REG_DWORD)) {
            value = *(DWORD *)objectContent.MemoryContent.ContentBytes;
        }
        IsmReleaseObject (&objectContent);
    }
    IsmDestroyObjectHandle (objectName);

    return value;
}


VOID
pSetDwordValue (
    OUT     PMIG_CONTENT NewContent,
    IN      DWORD Value
    )
{
    NewContent->Details.DetailsSize = sizeof(DWORD);
    NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
    *((PDWORD)NewContent->Details.DetailsData) = REG_DWORD;
    NewContent->MemoryContent.ContentSize = sizeof (DWORD);
    NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof(DWORD));
    *((PDWORD)NewContent->MemoryContent.ContentBytes) = Value;
}


UINT
pDefaultEnumerationCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PCONVERSION_STRUCT p = (PCONVERSION_STRUCT)CallerArg;

    if (Data->IsLeaf) {
        IsmSetOperationOnObject (Data->ObjectTypeId, Data->ObjectName, p->OperationId, NULL, NULL);
    }
    return CALLBACK_ENUM_CONTINUE;
}

PCONVERSION_STRUCT
pGetConversionStruct (
    IN      PCTSTR FunctionName
    )
{
    PCONVERSION_STRUCT p = g_ConversionFunctions;
    INT i = 0;
    while (p->InfFunctionName != NULL) {
        if (StringIMatch (p->InfFunctionName, FunctionName)) {
            return p;
        }
        p++;
        i++;
    }
    return NULL;
}

VOID
InitSpecialConversion (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PCONVERSION_STRUCT p = g_ConversionFunctions;

    while (p->InfFunctionName) {
        p->OperationId = IsmRegisterOperation (p->OperationName, FALSE);
        if (Platform == PLATFORM_DESTINATION) {
            IsmRegisterOperationApplyCallback (p->OperationId, p->OperationCallback, TRUE);
        }
        p++;
    }

    g_IdentityDestTable = HtAllocWithData (sizeof (PTSTR));

    if (Platform == PLATFORM_DESTINATION) {
        // Read the starting Identity count
        g_IdentityCount = pGetDestDwordValue (TEXT("HKCU\\Identities"), TEXT("Identity Ordinal"));
    }
}

VOID
TerminateSpecialConversion (
    VOID
    )
{
    HtFree (g_IdentityDestTable);
    g_IdentityDestTable = NULL;

    OETerminate();
}

BOOL
pProcessDataConversionSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR pattern;
    ENCODEDSTRHANDLE encodedPattern = NULL;
    PCTSTR functionName;
    PCONVERSION_STRUCT functionStruct = NULL;
    BOOL result = FALSE;

    __try {
        if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                pattern = InfGetStringField (InfStruct, 0);

                if (!pattern) {
                    continue;
                }
                encodedPattern = TurnRegStringIntoHandle (pattern, TRUE, NULL);

                functionName = InfGetStringField (InfStruct, 1);

                if (functionName) {

                    functionStruct = pGetConversionStruct (functionName);

                    if (functionStruct) {
                        IsmHookEnumeration (
                            MIG_REGISTRY_TYPE,
                            encodedPattern,
                            functionStruct->EnumerationCallback?
                                functionStruct->EnumerationCallback:
                                pDefaultEnumerationCallback,
                            (ULONG_PTR)functionStruct,
                            functionStruct->InfFunctionName
                            );

                    } else {
                        LOG ((
                            LOG_ERROR,
                            (PCSTR) MSG_DATA_CONVERSION_BAD_FN,
                            functionName,
                            pattern
                            ));
                    }
                } else {
                    LOG ((LOG_ERROR, (PCSTR) MSG_DATA_CONVERSION_NO_FN, pattern));
                }

                IsmDestroyObjectHandle (encodedPattern);
                encodedPattern = NULL;
            } while (InfFindNextLine (InfStruct));
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (InfStruct);
    }

    return result;
}

BOOL
DoRegistrySpecialConversion (
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;

    b = pProcessDataConversionSection (&is, InfHandle, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (PLATFORM_SOURCE, &is, InfHandle, Section);

        if (osSpecificSection) {
            b = pProcessDataConversionSection (&is, InfHandle, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);
    return b;
}

BOOL
DoesDestRegExist (
    IN      MIG_OBJECTSTRINGHANDLE DestName,
    IN      DWORD RegType
    )
{
    BOOL result = FALSE;
    MIG_CONTENT content;

    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, DestName, &content)) {
        if (IsValidRegType(&content, RegType)) {
            result = TRUE;
        }
        IsmReleaseObject (&content);
    }

    return result;
}

BOOL
WINAPI
pConvertToDwordCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value = 0;
    BOOL converted = FALSE;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {
            converted = TRUE;
            if (CurrentContent->MemoryContent.ContentSize > 0) {
                value = _tcstoul ((PCTSTR)CurrentContent->MemoryContent.ContentBytes, NULL, 10);
            }
        } else if (*valueType == REG_BINARY ||
                   *valueType == REG_NONE ||
                   *valueType == REG_DWORD
                   ) {
            if (CurrentContent->MemoryContent.ContentSize == sizeof (DWORD)) {
                converted = TRUE;
                value = *((PDWORD)CurrentContent->MemoryContent.ContentBytes);
            }
        }
        if (converted) {
            pSetDwordValue (NewContent, value);
        }
    }

    return TRUE;
}

BOOL
WINAPI
pConvertToStringCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR result = NULL;
    PTSTR resultPtr;
    UINT i;
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_DWORD) {

            MYASSERT (CurrentContent->MemoryContent.ContentSize == sizeof (DWORD));

            if (CurrentContent->MemoryContent.ContentSize == sizeof (DWORD)) {

                converted = TRUE;
                convertedSize = 11 * sizeof (TCHAR); // DWORD takes no more than 11 characters
                result = IsmGetMemory (convertedSize);
                if (result) {
                    wsprintf (result, TEXT("%lu"), *((PDWORD)CurrentContent->MemoryContent.ContentBytes));
                    convertedSize = SizeOfString (result);
                }
            }

        } else if (*valueType == REG_BINARY) {

            converted = TRUE;
            convertedSize = (CurrentContent->MemoryContent.ContentSize?(CurrentContent->MemoryContent.ContentSize * 3):1) * sizeof (TCHAR);
            result = IsmGetMemory (convertedSize);
            if (result) {
                resultPtr = result;
                *resultPtr = 0;
                for (i = 0; i < CurrentContent->MemoryContent.ContentSize; i++) {
                    wsprintf (resultPtr, TEXT("%02X"), CurrentContent->MemoryContent.ContentBytes[i]);
                    resultPtr = GetEndOfString (resultPtr);
                    if (i < CurrentContent->MemoryContent.ContentSize - 1) {
                        _tcscat (resultPtr, TEXT(" "));
                        resultPtr = GetEndOfString (resultPtr);
                    }
                }
                convertedSize = SizeOfString (result);
            }
        }
        if (converted && convertedSize && result) {
            NewContent->Details.DetailsSize = sizeof (DWORD);
            NewContent->Details.DetailsData = IsmGetMemory (NewContent->Details.DetailsSize);
            *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = (PCBYTE) result;
        }
    }

    return TRUE;
}

VOID
pConvertShortLogFontWorker (
    PLOGFONTW plfDest,
    PSHORT_LOGFONT plfSrc
    )
{
    PCWSTR faceName;

    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;\
    faceName = ConvertAtoW (plfSrc->lfFaceName);
    StringCopyByteCountW (plfDest->lfFaceName, faceName, sizeof (plfDest->lfFaceName));
    FreeConvertedStr (faceName);
}

VOID
pConvertLogFontWorker (
    PLOGFONTW plfDest,
    PLOGFONTA plfSrc
    )
{
    PCWSTR faceName;

    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;\
    faceName = ConvertAtoW (plfSrc->lfFaceName);
    StringCopyByteCountW (plfDest->lfFaceName, faceName, sizeof (plfDest->lfFaceName));
    FreeConvertedStr (faceName);
}

VOID
pCopyLogFontWorker (
    PLOGFONTW plfDest,
    PLOGFONTW plfSrc
    )
{
    PCWSTR faceName;

    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;\
    StringCopyByteCountW (plfDest->lfFaceName, plfSrc->lfFaceName, sizeof (plfDest->lfFaceName));
}

BOOL
WINAPI
pConvertLogFontCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PLOGFONTW logFont = NULL;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {

            if (CurrentContent->MemoryContent.ContentSize == sizeof (SHORT_LOGFONT)) {

                converted = TRUE;
                convertedSize = sizeof (LOGFONTW);
                logFont = (PLOGFONTW) IsmGetMemory (convertedSize);
                ZeroMemory (logFont, sizeof (LOGFONTW));
                pConvertShortLogFontWorker (logFont, (PSHORT_LOGFONT)CurrentContent->MemoryContent.ContentBytes);
            }

            if (CurrentContent->MemoryContent.ContentSize == sizeof (LOGFONTA)) {

                converted = TRUE;
                convertedSize = sizeof (LOGFONTW);
                logFont = (PLOGFONTW) IsmGetMemory (convertedSize);
                ZeroMemory (logFont, sizeof (LOGFONTW));
                pConvertLogFontWorker (logFont, (PLOGFONTA)CurrentContent->MemoryContent.ContentBytes);
            }
        }

        if (converted && convertedSize && logFont) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = (PBYTE)logFont;
        }
    }

    return TRUE;
}

BOOL
pGetDPISettings (
    OUT     PDWORD SrcDPI,
    OUT     PDWORD DestDPI
    )
{
    PTSTR dpiStr = NULL;
    DWORD srcDPI = 96;
    DWORD destDPI = 96;
    DWORD sizeNeeded;

    if (IsmGetEnvironmentString (
            PLATFORM_SOURCE,
            S_SYSENVVAR_GROUP,
            S_ENV_APPLIED_DPI,
            NULL,
            0,
            &sizeNeeded
            )) {

        dpiStr = AllocPathString (sizeNeeded);
        if (dpiStr) {

            if (IsmGetEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    S_ENV_APPLIED_DPI,
                    dpiStr,
                    sizeNeeded,
                    NULL
                    )) {
                _stscanf (dpiStr, TEXT("%lx"), &(srcDPI));
            }
            FreePathString (dpiStr);
            dpiStr = NULL;
        }
    }

    if (IsmGetEnvironmentString (
            PLATFORM_DESTINATION,
            S_SYSENVVAR_GROUP,
            S_ENV_APPLIED_DPI,
            NULL,
            0,
            &sizeNeeded
            )) {

        dpiStr = AllocPathString (sizeNeeded);
        if (dpiStr) {

            if (IsmGetEnvironmentString (
                    PLATFORM_DESTINATION,
                    S_SYSENVVAR_GROUP,
                    S_ENV_APPLIED_DPI,
                    dpiStr,
                    sizeNeeded,
                    NULL
                    )) {
                _stscanf (dpiStr, TEXT("%lx"), &(destDPI));
            }
            FreePathString (dpiStr);
            dpiStr = NULL;
        }
    }

    if (SrcDPI) {
        *SrcDPI = srcDPI;
    }

    if (DestDPI) {
        *DestDPI = destDPI;
    }

    return TRUE;
}

BOOL
WINAPI
pFontDPIChange (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PDWORD valueType;
    DWORD srcDPI = 0;
    DWORD destDPI = 0;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {

            pGetDPISettings (&srcDPI, &destDPI);

            if (srcDPI && destDPI && (srcDPI != destDPI)) {

                if (CurrentContent->MemoryContent.ContentSize == sizeof (SHORT_LOGFONT)) {

                    PSHORT_LOGFONT result = IsmGetMemory (sizeof (SHORT_LOGFONT));
                    if (result) {
                        CopyMemory (result, (PSHORT_LOGFONT)CurrentContent->MemoryContent.ContentBytes, sizeof (SHORT_LOGFONT));

                        // now modify the size of the font if negative (device units)
                        if (result->lfHeight < 0) {
                            result->lfHeight = (SHORT)MulDiv (result->lfHeight, srcDPI, destDPI);
                            NewContent->MemoryContent.ContentSize = sizeof (SHORT_LOGFONT);
                            NewContent->MemoryContent.ContentBytes = (PBYTE)result;
                        } else {
                            IsmReleaseMemory (result);
                            result = NULL;
                        }
                    }
                }

                if (CurrentContent->MemoryContent.ContentSize == sizeof (LOGFONTA)) {

                    PLOGFONTA result = IsmGetMemory (sizeof (LOGFONTA));
                    if (result) {
                        CopyMemory (result, (PLOGFONTA)CurrentContent->MemoryContent.ContentBytes, sizeof (LOGFONTA));

                        // now modify the size of the font if negative (device units)
                        if (result->lfHeight < 0) {
                            result->lfHeight = MulDiv (result->lfHeight, srcDPI, destDPI);
                            NewContent->MemoryContent.ContentSize = sizeof (LOGFONTA);
                            NewContent->MemoryContent.ContentBytes = (PBYTE)result;
                        } else {
                            IsmReleaseMemory (result);
                            result = NULL;
                        }
                    }
                }

                if (CurrentContent->MemoryContent.ContentSize == sizeof (LOGFONTW)) {

                    PLOGFONTW result = IsmGetMemory (sizeof (LOGFONTW));
                    if (result) {
                        CopyMemory (result, (PLOGFONTW)CurrentContent->MemoryContent.ContentBytes, sizeof (LOGFONTW));

                        // now modify the size of the font if negative (device units)
                        if (result->lfHeight < 0) {
                            result->lfHeight = MulDiv (result->lfHeight, srcDPI, destDPI);
                            NewContent->MemoryContent.ContentSize = sizeof (LOGFONTW);
                            NewContent->MemoryContent.ContentBytes = (PBYTE)result;
                        } else {
                            IsmReleaseMemory (result);
                            result = NULL;
                        }
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pFrameDPIChange (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PDWORD valueType;
    DWORD srcDPI = 0;
    DWORD destDPI = 0;
    LONG value;
    PTSTR result = NULL;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {

            pGetDPISettings (&srcDPI, &destDPI);

            if (srcDPI && destDPI && (srcDPI != destDPI)) {

                // let's get the actual number store here (positive or negative)
                _stscanf ((PCTSTR)(CurrentContent->MemoryContent.ContentBytes), TEXT("%ld"), &(value));

                if (value < 0) {
                    // only adjust if negative (device units)
                    value = MulDiv (value, srcDPI, destDPI);
                    result = IsmGetMemory (sizeof (value) * 2 + 2);
                    wsprintf (result, TEXT("%ld"), value);
                    NewContent->MemoryContent.ContentSize = SizeOfString (result);
                    NewContent->MemoryContent.ContentBytes = (PBYTE)result;
                }
            }
        }
    }

    return TRUE;
}

VOID
pConvertNonClientMetrics (
    OUT     NONCLIENTMETRICSW *Dest,
    IN      NONCLIENTMETRICSA *Src
    )
{
    Dest->cbSize = sizeof (NONCLIENTMETRICSW);
    Dest->iBorderWidth = Src->iBorderWidth;
    Dest->iScrollWidth = Src->iScrollWidth;
    Dest->iScrollHeight = Src->iScrollHeight;
    Dest->iCaptionWidth = Src->iCaptionWidth;
    Dest->iCaptionHeight = Src->iCaptionHeight;
    Dest->iSmCaptionWidth = Src->iSmCaptionWidth;
    Dest->iSmCaptionHeight = Src->iSmCaptionHeight;
    Dest->iMenuWidth = Src->iMenuWidth;
    Dest->iMenuHeight = Src->iMenuHeight;

    pConvertLogFontWorker (&Dest->lfCaptionFont, &Src->lfCaptionFont);
    pConvertLogFontWorker (&Dest->lfSmCaptionFont, &Src->lfSmCaptionFont);
    pConvertLogFontWorker (&Dest->lfMenuFont, &Src->lfMenuFont);
    pConvertLogFontWorker (&Dest->lfStatusFont, &Src->lfStatusFont);
    pConvertLogFontWorker (&Dest->lfMessageFont, &Src->lfMessageFont);
}

VOID
pCopyNonClientMetrics (
    OUT     NONCLIENTMETRICSW *Dest,
    IN      NONCLIENTMETRICSW *Src
    )
{
    Dest->cbSize = sizeof (NONCLIENTMETRICSW);
    Dest->iBorderWidth = Src->iBorderWidth;
    Dest->iScrollWidth = Src->iScrollWidth;
    Dest->iScrollHeight = Src->iScrollHeight;
    Dest->iCaptionWidth = Src->iCaptionWidth;
    Dest->iCaptionHeight = Src->iCaptionHeight;
    Dest->iSmCaptionWidth = Src->iSmCaptionWidth;
    Dest->iSmCaptionHeight = Src->iSmCaptionHeight;
    Dest->iMenuWidth = Src->iMenuWidth;
    Dest->iMenuHeight = Src->iMenuHeight;

    pCopyLogFontWorker (&Dest->lfCaptionFont, &Src->lfCaptionFont);
    pCopyLogFontWorker (&Dest->lfSmCaptionFont, &Src->lfSmCaptionFont);
    pCopyLogFontWorker (&Dest->lfMenuFont, &Src->lfMenuFont);
    pCopyLogFontWorker (&Dest->lfStatusFont, &Src->lfStatusFont);
    pCopyLogFontWorker (&Dest->lfMessageFont, &Src->lfMessageFont);
}

#define S_SCHEMELOCATION    TEXT("HKCU\\Control Panel\\Appearance\\New Schemes")
#define S_SCHEMECURRENT     TEXT("HKCU\\Control Panel\\Appearance")
#define S_SCHEMELOCATIONT1  TEXT("HKCU\\Control Panel\\Appearance\\New Schemes\\Current Settings SaveAll\\Sizes\\0")
#define S_SCHEMELOCATIONT2  TEXT("HKCU\\Control Panel\\Appearance\\New Schemes\\Current Settings SaveNoVisualStyle\\Sizes\\0")
#define S_SCHEMECOLORS      TEXT("HKCU\\Control Panel\\Colors")
#define S_SCHEMEMETRICS     TEXT("HKCU\\Control Panel\\Desktop\\WindowMetrics")

BOOL
pFindWhistlerScheme (
    IN      PCTSTR SchemeName,
    OUT     PUINT SchemeNr,
    OUT     PUINT SchemeSize
    )
{
    BOOL result = FALSE;
    HKEY rootKey = NULL;
    HKEY schemeKey = NULL;
    HKEY sizeKey = NULL;
    HKEY currSizeKey = NULL;
    TCHAR schemeNrStr [MAX_PATH + 1];
    TCHAR schemeSizeStr [MAX_PATH + 1];
    PCTSTR subKeyStr = NULL;
    DWORD index = 0, index1 = 0;
    INT maxScheme = -1;
    INT currScheme = 0;
    LONG err, err1, err2;
    DWORD valueType = 0;
    DWORD valueDataSize = 0;
    PTSTR valueData = NULL;

    *SchemeNr = 0;
    *SchemeSize = 0;

    rootKey = OpenRegKeyStr (S_SCHEMELOCATION);
    if (rootKey) {
        index = 0;
        err = ERROR_SUCCESS;
        while (err == ERROR_SUCCESS) {
            err = RegEnumKey (rootKey, index, schemeNrStr, MAX_PATH + 1);
            if (err == ERROR_SUCCESS) {
                currScheme = _ttoi (schemeNrStr);
                if (currScheme > maxScheme) {
                    maxScheme = currScheme;
                }
                subKeyStr = JoinPaths (schemeNrStr, TEXT("Sizes"));
                if (subKeyStr) {
                    sizeKey = OpenRegKey (rootKey, subKeyStr);
                    if (sizeKey) {
                        index1 = 0;
                        err1 = ERROR_SUCCESS;
                        while (err1 == ERROR_SUCCESS) {
                            err1 = RegEnumKey (sizeKey, index1, schemeSizeStr, MAX_PATH + 1);
                            if (err1 == ERROR_SUCCESS) {
                                currSizeKey = OpenRegKey (sizeKey, schemeSizeStr);
                                if (currSizeKey) {
                                    err2 = RegQueryValueEx (
                                                currSizeKey,
                                                TEXT("LegacyName"),
                                                NULL,
                                                &valueType,
                                                NULL,
                                                &valueDataSize
                                                );
                                    if (((err2 == ERROR_SUCCESS) || (err2 == ERROR_MORE_DATA)) &&
                                        ((valueType == REG_SZ) || (valueType == REG_EXPAND_SZ)) &&
                                        valueDataSize
                                        ) {
                                        valueData = (PTSTR) IsmGetMemory (valueDataSize);
                                        err2 = RegQueryValueEx (
                                                    currSizeKey,
                                                    TEXT("LegacyName"),
                                                    NULL,
                                                    &valueType,
                                                    (PBYTE) valueData,
                                                    &valueDataSize
                                                    );
                                        if ((err2 == ERROR_SUCCESS) &&
                                            (StringIMatch (valueData, SchemeName))
                                            ) {
                                            *SchemeNr = _ttoi (schemeNrStr);
                                            *SchemeSize = _ttoi (schemeSizeStr);
                                            IsmReleaseMemory (valueData);
                                            valueData = NULL;
                                            CloseRegKey (currSizeKey);
                                            currSizeKey = NULL;
                                            CloseRegKey (sizeKey);
                                            sizeKey = NULL;
                                            FreePathString (subKeyStr);
                                            subKeyStr = NULL;
                                            result = TRUE;
                                            break;
                                        }
                                        IsmReleaseMemory (valueData);
                                        valueData = NULL;
                                    }
                                    CloseRegKey (currSizeKey);
                                    currSizeKey = NULL;
                                }
                            }
                            index1 ++;
                        }
                        if (result) {
                            break;
                        }
                        CloseRegKey (sizeKey);
                        sizeKey = NULL;
                    }
                    FreePathString (subKeyStr);
                    subKeyStr = NULL;
                }
                index ++;
            }
        }
        CloseRegKey (rootKey);
        rootKey = NULL;
    }

    if (!result) {
        *SchemeNr = maxScheme + 1;
    }

    return result;
}

DWORD
pConvertColor (
    IN      PCTSTR ColorStr
    )
{
    DWORD color = 0;
    PBYTE colorPtr;
    UINT index = 0;

    colorPtr = (PBYTE)&color;

    while (ColorStr && *ColorStr) {

        if (index >= 3) {
            return FALSE;
        }

        *colorPtr = (BYTE) _tcstoul ((PTSTR)ColorStr, &((PTSTR)ColorStr), 10);

        if (*ColorStr) {
            if (_tcsnextc (ColorStr) != ' ') {
                return FALSE;
            }

            ColorStr = _tcsinc (ColorStr);
        }

        colorPtr++;
        index++;
    }
    return color;
}

BOOL
pBuildSchemeColor (
    IN      PCTSTR SchemeDest,
    IN      PCTSTR SrcColorName,
    IN      PCTSTR AltSrcColorName,
    IN      PCTSTR AltSrcColorStr,
    IN      PCTSTR DestColorName
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    DWORD color;
    DWORD valueType;
    BOOL needExtraColor = FALSE;
    PCTSTR extraColorStr = NULL;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    valueType = REG_DWORD;
    destContent.MemoryContent.ContentSize = sizeof (DWORD);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&color);

    srcName = IsmCreateObjectHandle (S_SCHEMECOLORS, SrcColorName);
    if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
        if (IsValidRegSz(&srcContent)) {
            color = pConvertColor ((PCTSTR) srcContent.MemoryContent.ContentBytes);

            destName = IsmCreateObjectHandle (SchemeDest, DestColorName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
        }
        IsmReleaseObject (&srcContent);
    } else if (AltSrcColorName) {
        IsmDestroyObjectHandle (srcName);
        srcName = NULL;
        srcName = IsmCreateObjectHandle (S_SCHEMECOLORS, AltSrcColorName);
        if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
            if (IsValidRegSz(&srcContent)) {
                color = pConvertColor ((PCTSTR) srcContent.MemoryContent.ContentBytes);

                destName = IsmCreateObjectHandle (SchemeDest, DestColorName);
                IsmReplacePhysicalObject (destTypeId, destName, &destContent);
                IsmDestroyObjectHandle (destName);
                destName = NULL;
                needExtraColor = TRUE;
                extraColorStr = DuplicatePathString ((PCTSTR) srcContent.MemoryContent.ContentBytes, 0);
            }
            IsmReleaseObject (&srcContent);
        }
    } else if (AltSrcColorStr) {
        color = pConvertColor (AltSrcColorStr);

        destName = IsmCreateObjectHandle (SchemeDest, DestColorName);
        IsmReplacePhysicalObject (destTypeId, destName, &destContent);
        IsmDestroyObjectHandle (destName);
        destName = NULL;
        needExtraColor = TRUE;
        extraColorStr = DuplicatePathString (AltSrcColorStr, 0);
    }
    IsmDestroyObjectHandle (srcName);
    srcName = NULL;

    if (needExtraColor) {
        if (extraColorStr) {
            valueType = REG_SZ;
            destContent.MemoryContent.ContentSize = SizeOfString (extraColorStr);
            destContent.MemoryContent.ContentBytes = (PBYTE) extraColorStr;
            destName = IsmCreateObjectHandle (S_SCHEMECOLORS, SrcColorName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
            FreePathString (extraColorStr);
            extraColorStr = NULL;
        }
    }

    return TRUE;
}

LONGLONG
pConvertSize (
    IN      PCTSTR SizeStr
    )
{
    INT size = 0;

    size = _tcstoul ((PTSTR)SizeStr, &((PTSTR)SizeStr), 10);
    size = -(size);
    size /= 15;

    return size;
}

BOOL
pBuildSchemeSize (
    IN      PCTSTR SchemeDest,
    IN      PCTSTR SrcSizeName,
    IN      PCTSTR DestSizeName
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    LONGLONG size;
    DWORD valueType;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    valueType = REG_QWORD;
    destContent.MemoryContent.ContentSize = sizeof (LONGLONG);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&size);

    srcName = IsmCreateObjectHandle (S_SCHEMEMETRICS, SrcSizeName);
    if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
        if (IsValidRegSz(&srcContent)) {
            size = pConvertSize ((PCTSTR) srcContent.MemoryContent.ContentBytes);

            destName = IsmCreateObjectHandle (SchemeDest, DestSizeName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
        }
        IsmReleaseObject (&srcContent);
    }
    IsmDestroyObjectHandle (srcName);
    srcName = NULL;

    return TRUE;
}

BOOL
pBuildSchemeFont (
    IN      PCTSTR SchemeDest,
    IN      PCTSTR SrcSizeName,
    IN      PCTSTR DestSizeName
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    LOGFONTW destFont;
    DWORD valueType;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    ZeroMemory (&destFont, sizeof (LOGFONTW));

    valueType = REG_BINARY;
    destContent.MemoryContent.ContentSize = sizeof (LOGFONTW);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&destFont);

    srcName = IsmCreateObjectHandle (S_SCHEMEMETRICS, SrcSizeName);
    if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
        if (IsValidRegType (&srcContent, REG_BINARY)) {
            if (srcContent.MemoryContent.ContentSize == sizeof (SHORT_LOGFONT)) {
                pConvertShortLogFontWorker (&destFont, (PSHORT_LOGFONT) srcContent.MemoryContent.ContentBytes);
            } else if (srcContent.MemoryContent.ContentSize == sizeof (LOGFONTA)) {
                pConvertLogFontWorker (&destFont, (PLOGFONTA) srcContent.MemoryContent.ContentBytes);
            } else {
                CopyMemory (&destFont, srcContent.MemoryContent.ContentBytes, sizeof (LOGFONTW));
            }

            destName = IsmCreateObjectHandle (SchemeDest, DestSizeName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
        }
        IsmReleaseObject (&srcContent);
    }
    IsmDestroyObjectHandle (srcName);
    srcName = NULL;

    return TRUE;
}

BOOL
pBuildTempScheme (
    IN      PCTSTR SchemeDest
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    DWORD value;
    DWORD valueType;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    // first we build the Color #<nr> values

    pBuildSchemeColor (SchemeDest, TEXT("Scrollbar"), NULL, NULL, TEXT("Color #0"));
    pBuildSchemeColor (SchemeDest, TEXT("Background"), NULL, NULL, TEXT("Color #1"));
    pBuildSchemeColor (SchemeDest, TEXT("ActiveTitle"), NULL, NULL, TEXT("Color #2"));
    pBuildSchemeColor (SchemeDest, TEXT("InactiveTitle"), NULL, NULL, TEXT("Color #3"));
    pBuildSchemeColor (SchemeDest, TEXT("Menu"), NULL, NULL, TEXT("Color #4"));
    pBuildSchemeColor (SchemeDest, TEXT("Window"), NULL, NULL, TEXT("Color #5"));
    pBuildSchemeColor (SchemeDest, TEXT("WindowFrame"), NULL, NULL, TEXT("Color #6"));
    pBuildSchemeColor (SchemeDest, TEXT("MenuText"), NULL, NULL, TEXT("Color #7"));
    pBuildSchemeColor (SchemeDest, TEXT("WindowText"), NULL, NULL, TEXT("Color #8"));
    pBuildSchemeColor (SchemeDest, TEXT("TitleText"), NULL, NULL, TEXT("Color #9"));
    pBuildSchemeColor (SchemeDest, TEXT("ActiveBorder"), NULL, NULL, TEXT("Color #10"));
    pBuildSchemeColor (SchemeDest, TEXT("InactiveBorder"), NULL, NULL, TEXT("Color #11"));
    pBuildSchemeColor (SchemeDest, TEXT("AppWorkSpace"), NULL, NULL, TEXT("Color #12"));
    pBuildSchemeColor (SchemeDest, TEXT("Hilight"), NULL, NULL, TEXT("Color #13"));
    pBuildSchemeColor (SchemeDest, TEXT("HilightText"), NULL, NULL, TEXT("Color #14"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonFace"), NULL, NULL, TEXT("Color #15"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonShadow"), NULL, NULL, TEXT("Color #16"));
    pBuildSchemeColor (SchemeDest, TEXT("GrayText"), NULL, NULL, TEXT("Color #17"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonText"), NULL, NULL, TEXT("Color #18"));
    pBuildSchemeColor (SchemeDest, TEXT("InactiveTitleText"), NULL, NULL, TEXT("Color #19"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonHilight"), NULL, NULL, TEXT("Color #20"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonDkShadow"), NULL, NULL, TEXT("Color #21"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonLight"), NULL, NULL, TEXT("Color #22"));
    pBuildSchemeColor (SchemeDest, TEXT("InfoText"), NULL, NULL, TEXT("Color #23"));
    pBuildSchemeColor (SchemeDest, TEXT("InfoWindow"), NULL, NULL, TEXT("Color #24"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonAlternateFace"), NULL, TEXT("180 180 180"), TEXT("Color #25"));
    pBuildSchemeColor (SchemeDest, TEXT("HotTrackingColor"), NULL, TEXT("0 0 255"), TEXT("Color #26"));
    pBuildSchemeColor (SchemeDest, TEXT("GradientActiveTitle"), NULL, TEXT("16 132 208"), TEXT("Color #27"));
    pBuildSchemeColor (SchemeDest, TEXT("GradientInactiveTitle"), NULL, TEXT("181 181 181"), TEXT("Color #28"));
    pBuildSchemeColor (SchemeDest, TEXT("MenuHilight"), TEXT("Hilight"), NULL, TEXT("Color #29"));
    pBuildSchemeColor (SchemeDest, TEXT("MenuBar"), TEXT("Menu"), NULL, TEXT("Color #30"));

    // now we build the Size #<nr> values

    pBuildSchemeSize (SchemeDest, TEXT("BorderWidth"), TEXT("Size #0"));
    pBuildSchemeSize (SchemeDest, TEXT("ScrollWidth"), TEXT("Size #1"));
    pBuildSchemeSize (SchemeDest, TEXT("ScrollHeight"), TEXT("Size #2"));
    pBuildSchemeSize (SchemeDest, TEXT("CaptionWidth"), TEXT("Size #3"));
    pBuildSchemeSize (SchemeDest, TEXT("CaptionHeight"), TEXT("Size #4"));
    pBuildSchemeSize (SchemeDest, TEXT("SmCaptionWidth"), TEXT("Size #5"));
    pBuildSchemeSize (SchemeDest, TEXT("SmCaptionHeight"), TEXT("Size #6"));
    pBuildSchemeSize (SchemeDest, TEXT("MenuWidth"), TEXT("Size #7"));
    pBuildSchemeSize (SchemeDest, TEXT("MenuHeight"), TEXT("Size #8"));

    // finally build the Font #<nr> values

    pBuildSchemeFont (SchemeDest, TEXT("CaptionFont"), TEXT("Font #0"));
    pBuildSchemeFont (SchemeDest, TEXT("SmCaptionFont"), TEXT("Font #1"));
    pBuildSchemeFont (SchemeDest, TEXT("MenuFont"), TEXT("Font #2"));
    pBuildSchemeFont (SchemeDest, TEXT("IconFont"), TEXT("Font #3"));
    pBuildSchemeFont (SchemeDest, TEXT("StatusFont"), TEXT("Font #4"));
    pBuildSchemeFont (SchemeDest, TEXT("MessageFont"), TEXT("Font #5"));

    value = 0;
    valueType = REG_DWORD;
    destContent.MemoryContent.ContentSize = sizeof (DWORD);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&value);
    destName = IsmCreateObjectHandle (SchemeDest, TEXT("Contrast"));
    IsmReplacePhysicalObject (destTypeId, destName, &destContent);
    IsmDestroyObjectHandle (destName);
    destName = NULL;
    destName = IsmCreateObjectHandle (SchemeDest, TEXT("Flat Menus"));
    IsmReplacePhysicalObject (destTypeId, destName, &destContent);
    IsmDestroyObjectHandle (destName);
    destName = NULL;
    return TRUE;
}

BOOL
pUpdateSchemeData (
    IN      PCTSTR SchemeName,
    IN      UINT SchemeNr,
    IN      UINT SchemeSize
    )
{
    static BOOL firstTime = TRUE;
    BOOL current = FALSE;
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    TCHAR schemeNrStr [20];
    TCHAR schemeSizeStr [20];
    PCTSTR keyStr = NULL;
    DWORD valueType = REG_SZ;
    BOOL noCurrent = FALSE;

    // first let's see if this is the current scheme
    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    objectName = IsmCreateObjectHandle (S_SCHEMECURRENT, TEXT("Current"));
    if (IsmAcquireObject (objectTypeId, objectName, &objectContent)) {
        current = ((IsValidRegSz(&objectContent)) &&
                   (StringIMatch (SchemeName, (PCTSTR) objectContent.MemoryContent.ContentBytes))
                   );
        noCurrent = ((IsValidRegSz(&objectContent)) &&
                     (StringIMatch (TEXT(""), (PCTSTR) objectContent.MemoryContent.ContentBytes))
                     );
        IsmReleaseObject (&objectContent);
    } else {
        noCurrent = TRUE;
    }
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    if (noCurrent) {
        // we did not have a current scheme, so we had only a temporary scheme
        // First time when we encounter this we will attempt to fix it.
        if (firstTime) {
            // we will build HKR\Control Panel\Appearance\New Schemes\Current Settings SaveAll and
            // HKR\Control Panel\Appearance\New Schemes\Current Settings SaveNoVisualStyle from
            // HKR\Control Panel\Colors and HKR\Control Panel\Desktop\WindowMetrics

            // We need to be carefull since we are reading source machine information and we need to
            // convert it (especially font blobs).

            pBuildTempScheme (S_SCHEMELOCATIONT1);
            pBuildTempScheme (S_SCHEMELOCATIONT2);

            firstTime = FALSE;
        }
    }

    if (!current) {
        return TRUE;
    }

    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
    objectContent.ObjectTypeId = objectTypeId;
    objectContent.ContentInFile = FALSE;
    objectContent.MemoryContent.ContentSize = SizeOfString (SchemeName);
    objectContent.MemoryContent.ContentBytes = (PBYTE) SchemeName;
    objectContent.Details.DetailsSize = sizeof (DWORD);
    objectContent.Details.DetailsData = &valueType;

    objectName = IsmCreateObjectHandle (S_SCHEMECURRENT, TEXT("Current"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectName = IsmCreateObjectHandle (S_SCHEMECURRENT, TEXT("NewCurrent"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    _ultot (SchemeNr, schemeNrStr, 10);
    objectContent.MemoryContent.ContentSize = SizeOfString (schemeNrStr);
    objectContent.MemoryContent.ContentBytes = (PBYTE) schemeNrStr;
    objectName = IsmCreateObjectHandle (S_SCHEMELOCATION, TEXT("SelectedStyle"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    keyStr = JoinPaths (S_SCHEMELOCATION, schemeNrStr);
    _ultot (SchemeSize, schemeSizeStr, 10);
    objectContent.MemoryContent.ContentSize = SizeOfString (schemeSizeStr);
    objectContent.MemoryContent.ContentBytes = (PBYTE) schemeSizeStr;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("SelectedSize"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;
    FreePathString (keyStr);
    keyStr = NULL;

    // finally we need to copy the current scheme into
    // HKR\Control Panel\Appearance\New Schemes\Current Settings SaveAll and
    // HKR\Control Panel\Appearance\New Schemes\Current Settings SaveNoVisualStyle
    pBuildTempScheme (S_SCHEMELOCATIONT1);
    pBuildTempScheme (S_SCHEMELOCATIONT2);

    return TRUE;
}

BOOL
pCreateWhistlerScheme (
    IN      PCTSTR SchemeName,
    IN      PSCHEMEDATA_NT SchemeData,
    IN      UINT SchemeNr
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    DWORD valueType = 0;
    TCHAR schemeNrStr [20];
    TCHAR valueName [20];
    TCHAR normalStr [] = TEXT("Normal");
    PCTSTR keyStr = NULL;
    DWORD value = 0;
    DWORD index = 0;
    ULONGLONG qvalue = 0;

    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;
    ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
    objectContent.ObjectTypeId = objectTypeId;
    objectContent.ContentInFile = FALSE;
    objectContent.Details.DetailsSize = sizeof (DWORD);
    objectContent.Details.DetailsData = &valueType;

    _ultot (SchemeNr, schemeNrStr, 10);

    keyStr = JoinPathsInPoolEx ((NULL, S_SCHEMELOCATION, schemeNrStr, NULL));
    valueType = REG_SZ;
    objectContent.MemoryContent.ContentSize = SizeOfString (SchemeName);
    objectContent.MemoryContent.ContentBytes = (PBYTE) SchemeName;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("DisplayName"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    FreePathString (keyStr);
    keyStr = NULL;

    keyStr = JoinPathsInPoolEx ((NULL, S_SCHEMELOCATION, schemeNrStr, TEXT("Sizes\\0"), NULL));

    valueType = REG_SZ;

    objectContent.MemoryContent.ContentSize = SizeOfString (normalStr);
    objectContent.MemoryContent.ContentBytes = (PBYTE) normalStr;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("DisplayName"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentSize = SizeOfString (SchemeName);
    objectContent.MemoryContent.ContentBytes = (PBYTE) SchemeName;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("LegacyName"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    value = 0;
    valueType = REG_DWORD;
    objectContent.MemoryContent.ContentSize = sizeof (DWORD);
    objectContent.MemoryContent.ContentBytes = (PBYTE) (&value);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Contrast"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Flat Menus"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    // write Color #<nr> values
    objectContent.MemoryContent.ContentSize = sizeof (DWORD);
    objectContent.MemoryContent.ContentBytes = (PBYTE) (&value);
    for (index = 0; index < COLOR_MAX_NT; index ++) {
        value = SchemeData->rgb [index];
        wsprintf (valueName, TEXT("Color #%u"), index);
        objectName = IsmCreateObjectHandle (keyStr, valueName);
        IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
        IsmDestroyObjectHandle (objectName);
        objectName = NULL;
    }
    value = SchemeData->rgb [COLOR_HIGHLIGHT];
    wsprintf (valueName, TEXT("Color #%u"), COLOR_MENUHILIGHT);
    objectName = IsmCreateObjectHandle (keyStr, valueName);
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;
    value = SchemeData->rgb [COLOR_MENU];
    wsprintf (valueName, TEXT("Color #%u"), COLOR_MAX_NT + 1);
    objectName = IsmCreateObjectHandle (keyStr, valueName);
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    // now, let's write the sizes
    valueType = REG_QWORD;
    objectContent.MemoryContent.ContentSize = sizeof (ULONGLONG);
    objectContent.MemoryContent.ContentBytes = (PBYTE) (&qvalue);

    qvalue = SchemeData->ncm.iBorderWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #0"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iScrollWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #1"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iScrollHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #2"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iCaptionWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #3"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iCaptionHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #4"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iSmCaptionWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #5"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iSmCaptionHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #6"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iMenuWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #7"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iMenuHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #8"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    // finally, let's write the fonts
    valueType = REG_BINARY;
    objectContent.MemoryContent.ContentSize = sizeof (LOGFONTW);

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfCaptionFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #0"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfSmCaptionFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #1"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfMenuFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #2"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->lfIconTitle);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #3"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfStatusFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #4"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfMessageFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #5"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    FreePathString (keyStr);
    keyStr = NULL;

    return TRUE;
}

BOOL
pDoesNewSchemeKeyExist (
    VOID
    )
{
    BOOL result = FALSE;
    HKEY rootKey = NULL;

    rootKey = OpenRegKeyStr (S_SCHEMELOCATION);

    result = rootKey != NULL;

    if (rootKey) {
        CloseRegKey (rootKey);
    }

    return result;
}

BOOL
WINAPI
pConvertAppearanceSchemeCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PBYTE result = NULL;
    PDWORD valueType;
    SCHEMEDATA_NT sd_nt;
    PSCHEMEDATA_V1 psd_v1;
    PSCHEMEDATA_V2 psd_v2;
    PSCHEMEDATA_V3 psd_v3;
    PSCHEMEDATA_V4 psd_v4;
    PSCHEMEDATA_V1A psd_v1a;
    BOOL Copy3dValues = FALSE;
    PCTSTR node = NULL, leaf = NULL;
    UINT schemeNr = 0;
    UINT schemeSize = 0;

    //
    // Filter the data for any references to %windir%
    //

    ZeroMemory (&sd_nt, sizeof (SCHEMEDATA_NT));

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {
            if (CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V1) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V2) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V3) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V4) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V1A)
                ) {
                psd_v1 = (PSCHEMEDATA_V1)CurrentContent->MemoryContent.ContentBytes;
                if (psd_v1->version == 1 ||
                    psd_v1->version == 2 ||
                    psd_v1->version == 3 ||
                    psd_v1->version == 4
                    ) {
                    //
                    // this is a valid scheme and it has a supported version
                    //
                    //
                    // Convert the structure
                    //

                    if (psd_v1->version == 1) {
                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v1->ncm);
                        pConvertShortLogFontWorker (&sd_nt.lfIconTitle, &psd_v1->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v1->rgb,
                            min (sizeof (psd_v1->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 3 && CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V1A)) {

                        psd_v1a = (PSCHEMEDATA_V1A) psd_v1;

                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v1a->ncm);
                        pConvertShortLogFontWorker (&sd_nt.lfIconTitle, &psd_v1a->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v1a->rgb,
                            min (sizeof (psd_v1a->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 2 && CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V2)) {

                        psd_v2 = (PSCHEMEDATA_V2) psd_v1;

                        sd_nt.version = 2;
                        pCopyNonClientMetrics (&sd_nt.ncm, &psd_v2->ncm);
                        pCopyLogFontWorker (&sd_nt.lfIconTitle, &psd_v2->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v2->rgb,
                            min (sizeof (psd_v2->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 3 && CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V3)) {
                        psd_v3 = (PSCHEMEDATA_V3) psd_v1;

                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v3->ncm);
                        pConvertLogFontWorker (&sd_nt.lfIconTitle, &psd_v3->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v3->rgb,
                            min (sizeof (psd_v3->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 4) {
                        psd_v4 = (PSCHEMEDATA_V4) psd_v1;

                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v4->ncm);
                        pConvertLogFontWorker (&sd_nt.lfIconTitle, &psd_v4->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v4->rgb,
                            min (sizeof (psd_v4->rgb), sizeof (sd_nt.rgb))
                            );
                    }

                    if (Copy3dValues) {
                        //
                        // Make sure the NT structure has values for 3D colors
                        //

                        sd_nt.rgb[COLOR_BUTTONALTFACE] = sd_nt.rgb[COLOR_BTNFACE];
                        sd_nt.rgb[COLOR_HOTLIGHT] = sd_nt.rgb[COLOR_ACTIVECAPTION];
                        sd_nt.rgb[COLOR_GRADIENTACTIVECAPTION] = sd_nt.rgb[COLOR_ACTIVECAPTION];
                        sd_nt.rgb[COLOR_GRADIENTINACTIVECAPTION] = sd_nt.rgb[COLOR_INACTIVECAPTION];
                    }
                    converted = TRUE;
                    convertedSize = sizeof (sd_nt);
                    result = IsmGetMemory (convertedSize);
                    CopyMemory (result, &sd_nt, convertedSize);
                }
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = result;

        }

        if ((*valueType == REG_BINARY) &&
            (converted || (CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_NT))) &&
            (pDoesNewSchemeKeyExist ())
            ) {
            // now we need to do some extra work
            // Each scheme must be converted to the new Whistler format

            // First we look to see if the scheme that we just processed exists in new Whistler format
            // For this we enumerate the HKR\Control Panel\Appearance\New Schemes
            // and try to find the valuename "Legacy Name" that matches the value name of this scheme
            // If we find it, we only update HKR\Control Panel\Appearance [Current],
            // HKR\Control Panel\Appearance [NewCurrent], HKR\Control Panel\Appearance\New Schemes [SelectedStyle]
            // and HKR\Control Panel\Appearance\New Schemes\<Scheme Number> [SelectedSize].
            // If not, we create a new Whistler scheme and update the above 4 value names.

            if (IsmCreateObjectStringsFromHandle (SrcObjectName, &node, &leaf)) {
                if (leaf) {
                    if (pFindWhistlerScheme (leaf, &schemeNr, &schemeSize)) {
                        pUpdateSchemeData (leaf, schemeNr, schemeSize);
                    } else {
                        if (pCreateWhistlerScheme (
                                leaf,
                                converted?
                                    (PSCHEMEDATA_NT)NewContent->MemoryContent.ContentBytes:
                                    (PSCHEMEDATA_NT)CurrentContent->MemoryContent.ContentBytes,
                                schemeNr
                                )) {
                            pUpdateSchemeData (leaf, schemeNr, 0);
                        }
                    }
                }
                IsmDestroyObjectString (node);
                IsmDestroyObjectString (leaf);
            }
        }

    }

    return TRUE;
}

BOOL
WINAPI
pAntiAliasCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value = 0;
    BOOL converted = FALSE;
    PTSTR result = NULL;
    UINT convertedSize = 0;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {

            if (CurrentContent->MemoryContent.ContentSize > 0) {
                value = _tcstoul ((PCTSTR)CurrentContent->MemoryContent.ContentBytes, NULL, 10);
            }
            if (value > 0) {
                converted = TRUE;
                convertedSize = 11 * sizeof (TCHAR); // DWORD takes no more than 11 characters
                result = IsmGetMemory (convertedSize);
                wsprintf (result, TEXT("%d"), FE_AA_ON);
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = (PCBYTE) result;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pFixActiveDesktopCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    #define badBufferSize   16
    #define goodBufferSize  28
    const BYTE badBuffer[badBufferSize] =
                {0x10, 0x00, 0x00, 0x00,
                 0x01, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00};
    const BYTE goodBuffer[goodBufferSize] =
                {0x1C, 0x00, 0x00, 0x00,
                 0x20, 0x08, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x0A, 0x00, 0x00, 0x00};
    BOOL converted = FALSE;
    PBYTE result = NULL;
    UINT convertedSize = 0;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {

            if (CurrentContent->MemoryContent.ContentSize == badBufferSize) {
                if (TestBuffer (CurrentContent->MemoryContent.ContentBytes, badBuffer, badBufferSize)) {
                    converted = TRUE;
                    convertedSize = goodBufferSize;
                    result = IsmGetMemory (convertedSize);
                    CopyMemory (result, goodBuffer, convertedSize);
                }
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = result;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pConvertRecentDocsMRUCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    PBYTE result = NULL;
    UINT convertedSize = 0;
    PDWORD valueType;
    PCSTR str, structPtr;
    PCWSTR strW;
    UINT size, sizeW;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType == REG_BINARY) && (CurrentContent->MemoryContent.ContentSize)) {
            // The content of this is a NULL terminated string followed by some binary data.
            // We need to convert the string to unicode and add the existent
            // binary data
            str = (PCSTR)CurrentContent->MemoryContent.ContentBytes;
            __try {
                structPtr = GetEndOfStringA (str);
                structPtr = _mbsinc (structPtr);
                if (structPtr && (structPtr > str)) {
                    size = CurrentContent->MemoryContent.ContentSize - (UINT)(structPtr - str);
                    if (size == sizeof (WORD) + *((PWORD)structPtr)) {
                        converted = TRUE;
                        strW = ConvertAtoW (str);
                        sizeW = SizeOfStringW (strW);
                        convertedSize = sizeW + size;
                        result = IsmGetMemory (convertedSize);
                        CopyMemory (result, strW, sizeW);
                        CopyMemory (result + sizeW, structPtr, size);
                        FreeConvertedStr (strW);
                    }
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                // the structure was not well formed
                converted = FALSE;
                if (result) {
                    IsmReleaseMemory (result);
                }
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = result;
        }
    }

    return TRUE;
}

PCTSTR
pFindNewScreenSaver (
    IN      PCTSTR OldScreenSaver
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR newScrName;
    PCTSTR result = NULL;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (InfFindFirstLine (infHandle, TEXT("SCR Rename"), OldScreenSaver, &is)) {

            newScrName = InfGetStringField (&is, 1);
            if (newScrName) {
                result = DuplicatePathString (newScrName, 0);
            }
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            result = DuplicatePathString (OldScreenSaver, 0);
            return result;
        }

        __try {
            multiSz = AllocText (sizeNeeded);

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {

                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {

                        if (InfFindFirstLine (infHandle, TEXT("SCR Rename"), OldScreenSaver, &is)) {

                            newScrName = InfGetStringField (&is, 1);
                            if (newScrName) {
                                result = DuplicatePathString (newScrName, 0);
                                InfCloseInfFile (infHandle);
                                infHandle = INVALID_HANDLE_VALUE;
                                __leave;
                            }
                        }
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                    InfCloseInfFile (infHandle);
                    infHandle = INVALID_HANDLE_VALUE;
                } while (EnumNextMultiSz (&e));

            }
        }
        __finally {
            FreeText (multiSz);
        }
    }

    InfResetInfStruct (&is);

    if (!result) {
        result = DuplicatePathString (OldScreenSaver, 0);
    }
    return result;
}

BOOL
WINAPI
pConvertScnSaver (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PDWORD valueType;
    PCTSTR exePath = NULL;
    PTSTR exeName = NULL;
    PCTSTR exeNativeName = NULL;
    PCTSTR newExeName = NULL;
    PCTSTR expExePath = NULL;
    MIG_OBJECTSTRINGHANDLE sourceObjectName = NULL;
    MIG_OBJECTSTRINGHANDLE destObjectName = NULL;
    MIG_CONTENT destContent;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;
    BOOL migrateSrcReg = FALSE;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {

            //
            // Extract the source screen saver path from the reg value data
            //

            if (IsEmptyStr ((PCTSTR) CurrentContent->MemoryContent.ContentBytes)) {
                migrateSrcReg = TRUE;
            } else {
                // first we try to see if the source SCR exists on the destination
                // we have two steps :
                // 1. Filter the source and see if the destination exists
                // 2. Filter the source path, append the source file and see if the destination exists
                exePath = (PCTSTR) (CurrentContent->MemoryContent.ContentBytes);
                if (exePath) {
                    expExePath = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, exePath, NULL);
                    exeName = (PTSTR) FindLastWack (expExePath?expExePath:exePath);
                }

                if (exeName) {
                    *exeName++ = 0;

                    sourceObjectName = IsmCreateObjectHandle (expExePath?expExePath:exePath, exeName);

                    destObjectName = IsmFilterObject(
                                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                                            sourceObjectName,
                                            &destObjectTypeId,
                                            &deleted,
                                            &replaced
                                            );

                    migrateSrcReg = !deleted || replaced;

                    if (migrateSrcReg) {

                        migrateSrcReg = FALSE;

                        exeNativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, destObjectName?destObjectName:sourceObjectName);

                        if (exeNativeName) {
                            NewContent->MemoryContent.ContentSize = SizeOfString (exeNativeName);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            StringCopy ((PTSTR)NewContent->MemoryContent.ContentBytes, exeNativeName);
                            migrateSrcReg = TRUE;
                            IsmReleaseMemory (exeNativeName);
                        }

                        if (sourceObjectName) {
                            IsmDestroyObjectHandle (sourceObjectName);
                            sourceObjectName = NULL;
                        }

                        if (destObjectName) {
                            IsmDestroyObjectHandle (destObjectName);
                            destObjectName = NULL;
                        }
                    } else {

                        if (sourceObjectName) {
                            IsmDestroyObjectHandle (sourceObjectName);
                            sourceObjectName = NULL;
                        }

                        if (destObjectName) {
                            IsmDestroyObjectHandle (destObjectName);
                            destObjectName = NULL;
                        }

                        sourceObjectName = IsmCreateObjectHandle (expExePath?expExePath:exePath, NULL);

                        destObjectName = IsmFilterObject(
                                                MIG_FILE_TYPE | PLATFORM_SOURCE,
                                                sourceObjectName,
                                                &destObjectTypeId,
                                                &deleted,
                                                &replaced
                                                );

                        migrateSrcReg = !deleted || replaced;

                        if (migrateSrcReg) {

                            migrateSrcReg = FALSE;

                            //
                            // get the equivalent SCR file from the INF
                            //
                            newExeName = pFindNewScreenSaver (exeName);

                            if (newExeName) {

                                exeNativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, destObjectName?destObjectName:sourceObjectName);

                                if (destObjectName) {
                                    IsmDestroyObjectHandle (destObjectName);
                                    destObjectName = NULL;
                                }

                                if (exeNativeName) {

                                    destObjectName = IsmCreateObjectHandle (exeNativeName, newExeName);
                                    IsmReleaseMemory (exeNativeName);

                                    if (IsmAcquireObject (MIG_FILE_TYPE | PLATFORM_DESTINATION, destObjectName, &destContent)) {
                                        IsmReleaseObject (&destContent);
                                        exeNativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, destObjectName);
                                        if (exeNativeName) {
                                            NewContent->MemoryContent.ContentSize = SizeOfString (exeNativeName);
                                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                                            StringCopy ((PTSTR)NewContent->MemoryContent.ContentBytes, exeNativeName);
                                            migrateSrcReg = TRUE;
                                            IsmReleaseMemory (exeNativeName);
                                        }
                                    }

                                }
                                FreePathString (newExeName);
                            }
                        }

                        if (sourceObjectName) {
                            IsmDestroyObjectHandle (sourceObjectName);
                            sourceObjectName = NULL;
                        }

                        if (destObjectName) {
                            IsmDestroyObjectHandle (destObjectName);
                            destObjectName = NULL;
                        }
                    }
                }

                if (expExePath) {
                    IsmReleaseMemory (expExePath);
                    expExePath = NULL;
                }

            }

            //
            // If we should migrate the entry, then just leave everything
            // alone. If not, then we need to put the destination value in the
            // outbound content.
            //

            if (!migrateSrcReg) {
                MYASSERT (!(SrcObjectTypeId & PLATFORM_DESTINATION));

                destObjectName = IsmFilterObject(
                                        SrcObjectTypeId | PLATFORM_SOURCE,
                                        SrcObjectName,
                                        &destObjectTypeId,
                                        &deleted,
                                        NULL
                                        );

                if (!deleted) {

                    destObjectTypeId = SrcObjectTypeId & ~(PLATFORM_MASK);
                    destObjectTypeId |= PLATFORM_DESTINATION;

                    if (IsmAcquireObject (destObjectTypeId, destObjectName?destObjectName:SrcObjectName, &destContent)) {
                        NewContent->MemoryContent.ContentSize = destContent.MemoryContent.ContentSize;
                        NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                        CopyMemory ((PBYTE)NewContent->MemoryContent.ContentBytes, destContent.MemoryContent.ContentBytes, NewContent->MemoryContent.ContentSize);
                        IsmReleaseObject (&destContent);
                    }
                }

                IsmDestroyObjectHandle (destObjectName);
                INVALID_POINTER (destObjectName);
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pConvertIdentityCount(
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECTSTRINGHANDLE filteredName;
    DWORD value = 0;
    PTSTR node;
    PTSTR leaf;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {

        // Read the current Identity count
        value = pGetDestDwordValue (TEXT("HKCU\\Identities"), TEXT("Identity Ordinal"));

        // Add the number of new source identities
        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKCU\\Identities"),
                          TRUE,
                          TEXT("Username"),
                          FALSE);
        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
           do {
               if (IsmIsApplyObjectId (objectEnum.ObjectId)) {
                   IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
                   if (leaf && *leaf) {
                       // Check if we created this identity on the dest
                       filteredName = IsmFilterObject (g_RegType | PLATFORM_SOURCE,
                                                       objectEnum.ObjectName,
                                                       &destObjectTypeId,
                                                       &deleted,
                                                       &replaced);
                       if (filteredName) {
                           if (DoesDestRegExist(filteredName, REG_SZ) == FALSE) {
                               value++;
                           }
                           IsmDestroyObjectHandle(filteredName);
                       } else if (DoesDestRegExist(objectEnum.ObjectName, REG_SZ) == FALSE) {
                           value++;
                       }
                   }
                   IsmDestroyObjectString (node);
                   IsmDestroyObjectString (leaf);
               }
           } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);

        // Update the value with the new Identity count
        pSetDwordValue (NewContent, value);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertIdentityIndex(
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        IsmCreateObjectStringsFromHandle (SrcObjectName, &node, &leaf);
        if (node && !StringMatch(node, TEXT("HKCU\\Identities"))) {
            // Only set this identity's index if this is new on the dest
            if (DoesDestRegExist(SrcObjectName, REG_DWORD)) {
                IsmClearApplyOnObject((g_RegType & (~PLATFORM_MASK)) | PLATFORM_SOURCE, SrcObjectName);
            } else {
                pSetDwordValue (NewContent, g_IdentityCount);
                g_IdentityCount++;
            }
        }
        IsmDestroyObjectString(node);
        IsmDestroyObjectString(leaf);
    }
    return TRUE;
}


BOOL
pIsIdentityCollision (
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCTSTR OriginalUsername
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    BOOL retval = FALSE;

    // This function detects identity name collisions (i.e. 2 different "Main Identity"s)

    // Check if this already exists
    if (HtFindString (g_IdentityDestTable, OriginalUsername)) {
        return TRUE;
    }

    // Check for collisions on Destination
    enumPattern = IsmCreateSimpleObjectPattern (TEXT("HKCU\\Identities"),
                                                TRUE,
                                                TEXT("Username"),
                                                FALSE);
    if (IsmEnumFirstDestinationObject (&objectEnum, g_RegType, enumPattern)) {
       do {
           // don't collide with same identity on destination
           if (!StringIMatch (SrcObjectName, objectEnum.ObjectName)) {
               if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, objectEnum.ObjectName, &objectContent)) {
                   if (IsValidRegSz(&objectContent)) {
                       if (StringIMatch (OriginalUsername, (PCTSTR) objectContent.MemoryContent.ContentBytes)) {
                           retval = TRUE;
                           IsmReleaseObject (&objectContent);
                           IsmAbortObjectEnum (&objectEnum);
                           break;
                       }
                   }
                   IsmReleaseObject (&objectContent);
               }
           }
       } while (IsmEnumNextObject (&objectEnum));
    }

    IsmDestroyObjectHandle (enumPattern);

    return retval;
}

PTSTR
pCollideIdentityUsername (
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCTSTR OriginalUsername
    )
{
    PTSTR username = NULL;
    PTSTR tmpName;
    PTSTR testName = NULL;
    PTSTR openParen = NULL;
    PTSTR closeParen = NULL;
    PTSTR chr;
    TCHAR buff[20];
    UINT index = 1;
    BOOL replaceOk = TRUE;

    // This function handles identity name collisions.
    // For example, "Main Identity" becomes "Main Identity(2)"

    if (pIsIdentityCollision (SrcObjectName, OriginalUsername)) {
        tmpName = DuplicateText (OriginalUsername);

        // Check if name already has a (number) tacked on
        openParen = _tcsrchr (tmpName, TEXT('('));
        closeParen = _tcsrchr (tmpName, TEXT(')'));

        if (closeParen && openParen &&
            closeParen > openParen &&
            closeParen - openParen > 1) {
            // Make sure it's purely numerical
            for (chr = openParen+1; chr < closeParen; chr++) {
                if (!_istdigit (*chr)) {
                    replaceOk = FALSE;
                    break;
                }
            }
            if (replaceOk == TRUE) {
                if (_stscanf (openParen, TEXT("(%d)"), &index)) {
                    *openParen = 0;
                }
            }
        }

        // Loop until we find a non-colliding name
        do {
            IsmReleaseMemory (username);
            index++;

            wsprintf (buff, TEXT("(%d)"), index);
            username = IsmGetMemory (ByteCount (OriginalUsername) + ByteCount (buff) + 1);
            StringCopy (username, tmpName);
            StringCat (username, buff);
        } while (pIsIdentityCollision (SrcObjectName, username));

        FreeText (tmpName);

        // Put the new name in the hash tables
        HtAddStringEx (g_IdentityDestTable, username, &username, FALSE);
    } else {
        username = IsmGetMemory (ByteCount (OriginalUsername) + 1);
        StringCopy (username, OriginalUsername);
    }

    return username;
}

BOOL
WINAPI
pConvertIdentityGuid (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR newId;
    if (IsValidRegSz (CurrentContent)) {
        newId = OEGetRemappedId ((PCTSTR)CurrentContent->MemoryContent.ContentBytes);

        if (newId) {
            NewContent->Details.DetailsSize = sizeof(DWORD);
            NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;
            NewContent->MemoryContent.ContentSize = ByteCount (newId) + 1;
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
            StringCopy ((PTSTR)NewContent->MemoryContent.ContentBytes, newId);
            FreeText(newId);
        }
    }
    return TRUE;
}

BOOL
pConvertOE5Stationery (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    // Delete the destination's [Wide Stationery Name] value.
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    MIG_OBJECTSTRINGHANDLE filteredName;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;

    filteredName = IsmFilterObject (g_RegType | PLATFORM_SOURCE,
                                    SrcObjectName,
                                    &destObjectTypeId,
                                    &deleted,
                                    &replaced);
    if (filteredName) {
        IsmCreateObjectStringsFromHandle (filteredName, &node, &leaf);

        if (node) {
            destName = IsmCreateObjectHandle (node, TEXT("Wide Stationery Name"));
            IsmRemovePhysicalObject (g_RegType, destName);
            IsmDestroyObjectHandle(destName);

            destName = IsmCreateObjectHandle (node, TEXT("Stationery Name Converted"));
            IsmRemovePhysicalObject (g_RegType, destName);
            IsmDestroyObjectHandle(destName);

            IsmDestroyObjectString(node);
        }

        IsmDestroyObjectString(leaf);
        IsmDestroyObjectHandle(filteredName);
    }

    return TRUE;

}

BOOL
WINAPI
pConvertIdentityUsername (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegSz (OriginalContent)) {
        // Update the value with a potentially new username
        NewContent->Details.DetailsSize = sizeof(DWORD);
        NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
        *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;

        NewContent->MemoryContent.ContentBytes = (PBYTE) pCollideIdentityUsername (SrcObjectName, (PCTSTR) OriginalContent->MemoryContent.ContentBytes);
        NewContent->MemoryContent.ContentSize = ByteCount ((PCTSTR) NewContent->MemoryContent.ContentBytes) + 1;
    }
    return TRUE;
}

BOOL
WINAPI
pConvertSetDwordTrue (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegType (OriginalContent, REG_DWORD)) {
        pSetDwordValue (NewContent, 1);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertSetDwordFalse (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    if (IsValidRegType (OriginalContent, REG_DWORD)) {
        pSetDwordValue (NewContent, 0);
    }
    return TRUE;
}

BOOL
WINAPI
pConvertPSTBlob (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PCTSTR originalStr = NULL;
    PCSTR finalStr = NULL;
    PTSTR joinedStr = NULL;
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_OBJECTSTRINGHANDLE srcName = NULL;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;
    TCHAR *p = NULL;
    char *ptr;
    HALF_PTR oldSize;
    PCBYTE blob;

    if (IsValidRegType(OriginalContent, REG_BINARY)) {
        // Find the NULL before the PST filename
        blob = OriginalContent->MemoryContent.ContentBytes;
        ptr = (char *)(ULONG_PTR)((PBYTE)blob + OriginalContent->MemoryContent.ContentSize - 2);

        while ((ptr > blob) &&  (*ptr != 0)) {
            ptr--;
        }
        if (ptr <= blob) {
            // couldn't find it.. this isn't a PSTBlob
            return TRUE;
        }

        ptr++;

        oldSize = (HALF_PTR)(ptr - blob);
#ifdef UNICODE
        originalStr = ConvertAtoW(ptr);
#else
        originalStr = DuplicateText(ptr);
#endif

        if (originalStr) {
            p = (PTSTR)FindLastWack(originalStr);
            if (p) {
                *p = 0;
                srcName = IsmCreateObjectHandle (originalStr, p+1);

                if (srcName) {
                    filteredName = IsmFilterObject(MIG_FILE_TYPE | PLATFORM_SOURCE,
                                                   srcName,
                                                   &destObjectTypeId,
                                                   &deleted,
                                                   &replaced);
                    if (filteredName) {
                        IsmCreateObjectStringsFromHandle (filteredName, &node, &leaf);
                        IsmDestroyObjectHandle (filteredName);

                        joinedStr = JoinPaths (node, leaf);
                        if (joinedStr) {
#ifdef UNICODE
                            finalStr = ConvertWtoA(joinedStr);
#else
                            finalStr = DuplicateText(joinedStr);
#endif
                            FreePathString (joinedStr);
                        }
                        IsmDestroyObjectString (node);
                        IsmDestroyObjectString (leaf);
                    }
                    IsmDestroyObjectHandle (srcName);
                }
            }
#ifdef UNICODE
            FreeConvertedStr (originalStr);
#else
            FreeText(originalStr);
#endif
        }

        if (finalStr) {
            NewContent->Details.DetailsSize = sizeof(DWORD);
            NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->Details.DetailsData) = REG_BINARY;
            NewContent->MemoryContent.ContentSize = oldSize + ByteCountA(finalStr) + 1;
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
            CopyMemory ((PVOID)NewContent->MemoryContent.ContentBytes,
                        OriginalContent->MemoryContent.ContentBytes,
                        oldSize);
            CopyMemory ((PVOID)(NewContent->MemoryContent.ContentBytes + oldSize),
                        finalStr,
                        NewContent->MemoryContent.ContentSize);

#ifdef UNICODE
            FreeConvertedStr (finalStr);
#else
            FreeText(finalStr);
#endif
        }
    }

    return TRUE;
}

DWORD
pCountSourceSubKeys (
    IN      PTSTR RootKey
    )
{
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    DWORD value = 0;

    enumPattern = IsmCreateSimpleObjectPattern (RootKey,  TRUE, NULL, FALSE);
    if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
       do {
           if (IsmIsApplyObjectId (objectEnum.ObjectId)) {
               value++;
           }
       } while (IsmEnumNextObject (&objectEnum));
    }
    IsmDestroyObjectHandle (enumPattern);

    // We enumerated the root key too, which we don't want to count
    value--;

    return value;
}

BOOL
WINAPI
pConvertIAMAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTSTRINGHANDLE filteredName = NULL;
    MIG_CONTENT objectContent;
    PTSTR subKey;
    DWORD value = 1;
    PTSTR node;
    PTSTR leaf;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;

    // Only increment the base account count
    if (StrStrI(SrcObjectName, TEXT("\\Accounts\\"))) {
        return TRUE;
    }

    // Get the destination value where we are writing to
    filteredName = IsmFilterObject(g_RegType | PLATFORM_SOURCE,
                                   SrcObjectName,
                                   &destObjectTypeId,
                                   &deleted,
                                   &replaced);
    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION,
                          filteredName ? filteredName : SrcObjectName,
                          &objectContent)) {
        if (IsValidRegType(&objectContent, REG_DWORD)) {
            value = *objectContent.MemoryContent.ContentBytes;
            if (value == 0) {
                value = 1;
            }
        }
        IsmReleaseObject (&objectContent);
    }

    if (filteredName) {
        IsmDestroyObjectHandle (filteredName);
    }

    // Now increment the value by the number of accounts we are writing from the source
    IsmCreateObjectStringsFromHandle (SrcObjectName, &node, &leaf);
    if (node) {
        subKey = JoinText(node, TEXT("\\Accounts"));
        if (subKey) {
            value += pCountSourceSubKeys (subKey);
            pSetDwordValue (NewContent, value);
            FreeText(subKey);
        }
        IsmDestroyObjectString(node);
    }
    if (leaf) {
        IsmDestroyObjectString(leaf);
    }

    return TRUE;
}

BOOL
WINAPI
pConvertOE5IAMAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value = 1;
    PTSTR srcIdentity;
    PTSTR tmpText;
    PTSTR tmpNode;
    PTSTR newIdentity = NULL;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {

        // Starting value is always in this location

        // Extract the source's associated ID.
        srcIdentity = OEGetAssociatedId (PLATFORM_SOURCE);
        if (srcIdentity) {
            newIdentity = OEGetRemappedId(srcIdentity);
            if (newIdentity) {
                if (OEIsIdentityAssociated(newIdentity)) {

                    // Migrating IAM to IAM
                    value = pGetDestDwordValue (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager"),
                                                TEXT("Account Name"));
                    if (value == 0) {
                        value = 1;
                    }
                } else {

                    // Migrating IAM to ID
                    tmpText = JoinText(TEXT("HKCU\\Identities\\"),
                                       newIdentity);
                    if (tmpText) {
                        tmpNode = JoinText(tmpText,
                                           TEXT("\\Software\\Microsoft\\Internet Account Manager"));
                        if (tmpNode) {
                            value = pGetDestDwordValue (tmpNode, TEXT("Account Name"));
                            if (value == 0) {
                                value = 1;
                            }
                            FreeText(tmpNode);
                        }
                        FreeText(tmpText);
                    }
                }
                FreeText(newIdentity);
            }
            FreeText(srcIdentity);
        }
        value += pCountSourceSubKeys (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"));
        pSetDwordValue (NewContent, value);
    }

    return TRUE;
}

BOOL
WINAPI
pConvertOE4IAMAcctName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR tmpName = NULL;
    PTSTR defaultId = NULL;
    DWORD value = 0;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        // Check if destination has Default ID.  If so, we're going to merge into that Identity.
        defaultId = OEGetDefaultId(PLATFORM_DESTINATION);
        if (defaultId) {
            tmpName = JoinPathsInPoolEx ((
                            NULL,
                            TEXT("HKCU\\Identities"),
                            defaultId,
                            TEXT("Software\\Microsoft\\Internet Account Manager"),
                            NULL
                            ));
            FreeText(defaultId);
        }

        // First try to get the AccountName from the identity key
        if (tmpName != NULL) {
            value = pGetDestDwordValue (tmpName, TEXT("Account Name"));
        }

        // If not there, look in the common key
        // NOTE: This might be a bad assumption. Shouldn't we check if the dest id is associated?
        //       It doesn't matter too much.. the worst case is the value is supposed to be 0, but
        //       we set this number higher, which doesn't really affect anything.
        if (tmpName == NULL || value == 0) {
            value = pGetDestDwordValue (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager"),
                                        TEXT("Account Name"));
        }
        if (value == 0) {
            value = 1;
        }
        value += pCountSourceSubKeys (TEXT("HKCU\\Software\\Microsoft\\Internet Account Manager\\Accounts"));

        pSetDwordValue (NewContent, value);
    }

    if (tmpName != NULL) {
        FreePathString (tmpName);
    }

    return TRUE;
}



BOOL
WINAPI
pConvertOMIAccountName (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_CONTENT objectContent;
    DWORD value;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        value = pGetDestDwordValue (TEXT("HKCU\\Software\\Microsoft\\Office\\Outlook\\OMI Account Manager"),
                                    TEXT("Account Name"));
        value += pCountSourceSubKeys (TEXT("HKCU\\Software\\Microsoft\\Office\\Outlook\\OMI Account Manager\\Accounts"));
        pSetDwordValue (NewContent, value);
    }
    return TRUE;
}

BOOL
pConvertLangId (
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCTSTR OfficeApp
    )
{
    MIG_CONTENT objectContent;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    PTSTR node;
    PTSTR leaf;
    DWORD value;
    DWORD result = 0;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKLM\\Software\\Microsoft\\MS Setup (ACME)\\Table Files"),
                          TRUE,
                          NULL,
                          TRUE);

        if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, enumPattern)) {
            do {
                IsmCreateObjectStringsFromHandle (objectEnum.ObjectName, &node, &leaf);
                if (leaf && *leaf) {
                    if (StringIPrefix (leaf, TEXT("MS Office")) ||
                        StringIPrefix (leaf, OfficeApp)
                        ) {

                        result = _stscanf(leaf, TEXT("%*[^\\(](%d)"), &value);
                        // In Office installs, the Outlook entry may not have the (1033) piece,
                        // so we MUST check the result
                    }
                }
                IsmDestroyObjectString (node);
                IsmDestroyObjectString (leaf);

                if (result) {
                    IsmAbortObjectEnum (&objectEnum);
                    break;
                }
            } while (IsmEnumNextObject (&objectEnum));
        }
        IsmDestroyObjectHandle (enumPattern);

        if (result) {
            pSetDwordValue (NewContent, value);
        }
    }
    return TRUE;
}

BOOL
WINAPI
pConvertOfficeLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("MS Office"));
    return TRUE;
}

BOOL
WINAPI
pConvertOutlookLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Outlook"));
    return TRUE;
}

BOOL
WINAPI
pConvertAccessLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Access"));
    return TRUE;
}

BOOL
WINAPI
pConvertExcelLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Excel"));
    return TRUE;
}

BOOL
WINAPI
pConvertFrontPageLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft FrontPage"));
    return TRUE;
}

BOOL
WINAPI
pConvertPowerPointLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft PowerPoint"));
    return TRUE;
}

BOOL
WINAPI
pConvertPublisherLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Publisher"));
    return TRUE;
}

BOOL
WINAPI
pConvertWordLangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    pConvertLangId(CurrentContent, NewContent, TEXT("Microsoft Word"));
    return TRUE;
}

BOOL
WINAPI
pConvertOffice2000LangId (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {
        value = pGetSrcDwordValue (TEXT("HKCU\\Software\\Microsoft\\Office\\9.0\\Common\\LanguageResources"),
                                   TEXT("EXEMode"));
        pSetDwordValue (NewContent, value);
    }
    return TRUE;
}


BOOL
WINAPI
pMigrateSoundSysTray (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    DWORD tempValue;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_DWORD) &&
            (*valueType2 == REG_DWORD)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just move the "Show volume control" bit.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if (IsValidRegType(&destContent, REG_DWORD)) {
                            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            *((PDWORD)NewContent->MemoryContent.ContentBytes) = (*((PDWORD)destContent.MemoryContent.ContentBytes)) &~ 0x00000004;
                            tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & 0x00000004);
                            *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) &~ 0x00000004;
                tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & 0x00000004);
                *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateAppearanceUPM (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    DWORD tempValue;

    if (IsValidRegType (OriginalContent, REG_BINARY) &&
        IsValidRegType (CurrentContent, REG_BINARY)) {

        // if the object was not changed yet we need to read the destination object and then
        // just move the appropriate bits.

        if ((!CurrentContent->MemoryContent.ContentBytes) ||
            (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
            ) {
            // find out the destination object and read it
            newObjectName = IsmFilterObject (
                                SrcObjectTypeId,
                                SrcObjectName,
                                &newObjectTypeId,
                                &deleted,
                                &replaced
                                );
            if ((!deleted || replaced) &&
                ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                ) {

                if (IsmAcquireObject (
                        (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                        newObjectName?newObjectName:SrcObjectName,
                        &destContent
                        )) {

                    if (IsValidRegType(&destContent, REG_BINARY)) {
                        NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                        NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) = (*((PDWORD)destContent.MemoryContent.ContentBytes)) &~ DISPLAY_BITMASK;
                        tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & DISPLAY_BITMASK);
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
                    }

                    IsmReleaseObject (&destContent);
                }

                if (newObjectName) {
                    IsmDestroyObjectHandle (newObjectName);
                    newObjectName = NULL;
                }
            }
        } else {
            // just transfer the appropriate bits.
            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) &~ DISPLAY_BITMASK;
            tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & DISPLAY_BITMASK);
            *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateMouseUPM (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    DWORD tempValue;

    if (IsValidRegType (OriginalContent, REG_BINARY) &&
        IsValidRegType (CurrentContent, REG_BINARY)) {

        // if the object was not changed yet we need to read the destination object and then
        // just move the appropriate bits.

        if ((!CurrentContent->MemoryContent.ContentBytes) ||
            (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
            ) {
            // find out the destination object and read it
            newObjectName = IsmFilterObject (
                                SrcObjectTypeId,
                                SrcObjectName,
                                &newObjectTypeId,
                                &deleted,
                                &replaced
                                );
            if ((!deleted || replaced) &&
                ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                ) {

                if (IsmAcquireObject (
                        (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                        newObjectName?newObjectName:SrcObjectName,
                        &destContent
                        )) {

                    if (IsValidRegType (&destContent, REG_BINARY)) {
                        NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                        NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) = (*((PDWORD)destContent.MemoryContent.ContentBytes)) &~ MOUSE_BITMASK;
                        tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & MOUSE_BITMASK);
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
                    }

                    IsmReleaseObject (&destContent);
                }

                if (newObjectName) {
                    IsmDestroyObjectHandle (newObjectName);
                    newObjectName = NULL;
                }
            }
        } else {
            // just transfer the appropriate bits.
            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) &~ MOUSE_BITMASK;
            tempValue = ((*((PDWORD)OriginalContent->MemoryContent.ContentBytes)) & MOUSE_BITMASK);
            *((PDWORD)NewContent->MemoryContent.ContentBytes) |= tempValue;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateOfflineSysTray (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_DWORD) &&
            (*valueType2 == REG_DWORD)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just move the "Enable offline folders" bit.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if (IsValidRegType (&destContent, REG_DWORD)) {
                            NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                            *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)destContent.MemoryContent.ContentBytes);
                            if (*((PDWORD)OriginalContent->MemoryContent.ContentBytes) & 0x00000008) {
                                *((PDWORD)NewContent->MemoryContent.ContentBytes) |= 0x00000008;
                            } else {
                                *((PDWORD)NewContent->MemoryContent.ContentBytes) &= (~0x00000008);
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the "Enable offline folders" bit.
                NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof (DWORD));
                if (*((PDWORD)OriginalContent->MemoryContent.ContentBytes) & 0x00000008) {
                    *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) | 0x00000008;
                } else {
                    *((PDWORD)NewContent->MemoryContent.ContentBytes) = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) & (~0x00000008);
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateTaskBarSS (
    IN      BOOL Force,
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    BYTE defShellState [sizeof (REGSHELLSTATE)] =
        {0x24, 0x00, 0x00, 0x00,
         0x20, 0x28, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x01, 0x00, 0x00, 0x00,
         0x0D, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x02, 0x00, 0x00, 0x00};
    PREGSHELLSTATE shellState1 = NULL, shellState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the "fStartPanelOn" setting if present.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType (&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            if (Force) {
                                shellState2 = (REGSHELLSTATE *)NewContent->MemoryContent.ContentBytes;
                                shellState2->ss.fStartPanelOn = FALSE;
                            } else {
                                if (OriginalContent->MemoryContent.ContentSize == sizeof (REGSHELLSTATE)) {
                                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                    if (shellState1->ss.version == SHELLSTATEVERSION) {
                                        shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                                        shellState2->ss.fStartPanelOn = shellState1->ss.fStartPanelOn;
                                    }
                                }
                            }
                        }

                        IsmReleaseObject (&destContent);
                    } else {
                        if (Force) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                defShellState,
                                NewContent->MemoryContent.ContentSize
                                );
                            shellState2 = (REGSHELLSTATE *)NewContent->MemoryContent.ContentBytes;
                            shellState2->ss.fStartPanelOn = FALSE;
                        }
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                if (Force) {
                    NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                    CopyMemory (
                        (PBYTE)NewContent->MemoryContent.ContentBytes,
                        CurrentContent->MemoryContent.ContentBytes,
                        NewContent->MemoryContent.ContentSize
                        );
                    shellState2 = (REGSHELLSTATE *)NewContent->MemoryContent.ContentBytes;
                    shellState2->ss.fStartPanelOn = FALSE;
                } else {
                    // just transfer the "fStartPanelOn" setting if present.
                    if ((OriginalContent->MemoryContent.ContentSize == sizeof (REGSHELLSTATE)) &&
                        (CurrentContent->MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                        ) {
                        shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                        if (shellState1->ss.version == SHELLSTATEVERSION) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                CurrentContent->MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                            shellState2->ss.fStartPanelOn = shellState1->ss.fStartPanelOn;
                        }
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateTaskBarSSPreserve (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pMigrateTaskBarSS (
                FALSE,
                SrcObjectTypeId,
                SrcObjectName,
                OriginalContent,
                CurrentContent,
                NewContent,
                SourceOperationData,
                DestinationOperationData
                );
}

BOOL
WINAPI
pMigrateTaskBarSSForce (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    return pMigrateTaskBarSS (
                TRUE,
                SrcObjectTypeId,
                SrcObjectName,
                OriginalContent,
                CurrentContent,
                NewContent,
                SourceOperationData,
                DestinationOperationData
                );
}

BOOL
WINAPI
pConvertShowIEOnDesktop (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL dontShowIE = FALSE;
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    MIG_CONTENT destContent;
    BOOL deleted = TRUE, replaced = FALSE;

    if (IsValidRegType(CurrentContent, REG_DWORD)) {
        dontShowIE = *((PDWORD)CurrentContent->MemoryContent.ContentBytes) & 0x00100000;

        // find out the destination object and read it
        newObjectName = IsmFilterObject (
                            SrcObjectTypeId,
                            SrcObjectName,
                            &newObjectTypeId,
                            &deleted,
                            &replaced
                            );
        if ((!deleted || replaced) &&
            ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
            ) {

            if (IsmAcquireObject (
                    (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                    newObjectName?newObjectName:SrcObjectName,
                    &destContent
                    )) {

                if (IsValidRegType(&destContent, REG_DWORD)) {
                    NewContent->MemoryContent.ContentSize = sizeof (DWORD);
                    NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                    CopyMemory (
                        (PBYTE)NewContent->MemoryContent.ContentBytes,
                        destContent.MemoryContent.ContentBytes,
                        NewContent->MemoryContent.ContentSize
                        );

                    if (dontShowIE) {
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) |= 0x00100000;
                    } else {
                        *((PDWORD)NewContent->MemoryContent.ContentBytes) &= 0xFFEFFFFF;
                    }
                }

                IsmReleaseObject (&destContent);
            }

            if (newObjectName) {
                IsmDestroyObjectHandle (newObjectName);
                newObjectName = NULL;
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateActiveDesktop (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    PREGSHELLSTATE shellState1 = NULL, shellState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the meaningfull settings.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType(&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            if (OriginalContent->MemoryContent.ContentSize >= sizeof(UINT)+sizeof(SHELLSTATE_SIZE_WIN95)) {
                                shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                                shellState2->ss.fDesktopHTML= shellState1->ss.fDesktopHTML;
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the meaningfull settings.
                if (OriginalContent->MemoryContent.ContentSize >= sizeof(UINT)+sizeof(SHELLSTATE_SIZE_WIN95)) {
                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                    shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                    shellState2->ss.fDesktopHTML = shellState1->ss.fDesktopHTML;
                }
            }
        }
    }

    return TRUE;
}

BOOL
CreateDwordRegObject (
    IN      PCTSTR KeyStr,
    IN      PCTSTR ValueName,
    IN      DWORD Value
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    DWORD regType = REG_DWORD;
    BOOL result = FALSE;

    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;
    objectName = IsmCreateObjectHandle (KeyStr, ValueName);
    ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
    objectContent.ContentInFile = FALSE;
    objectContent.MemoryContent.ContentSize = sizeof (DWORD);
    objectContent.MemoryContent.ContentBytes = (PBYTE)&Value;
    objectContent.Details.DetailsSize = sizeof (DWORD);
    objectContent.Details.DetailsData = &regType;
    result = IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    return result;
}

BOOL
WINAPI
pMigrateDisplaySS (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    PREGSHELLSTATE shellState1 = NULL, shellState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the meaningfull settings.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType(&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (REGSHELLSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (REGSHELLSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );
                            if (OriginalContent->MemoryContent.ContentSize == sizeof(UINT)+SHELLSTATE_SIZE_WIN95) {
                                shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                CreateDwordRegObject (
                                    TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                    TEXT("Hidden"),
                                    shellState1->ss.fShowAllObjects?0x00000001:0x00000002
                                    );
                                CreateDwordRegObject (
                                    TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                    TEXT("HideFileExt"),
                                    shellState1->ss.fShowExtensions?0x00000000:0x00000001
                                    );
                                // on really old SHELLSTATE the "Show compressed folders" flag is in the place of fShowSysFiles
                                CreateDwordRegObject (
                                    TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                    TEXT("ShowCompColor"),
                                    shellState1->ss.fShowSysFiles?0x00000001:0x00000000
                                    );
                            }
                            if (OriginalContent->MemoryContent.ContentSize >= sizeof(UINT)+sizeof(SHELLSTATE_SIZE_WIN95)) {
                                shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                                shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                                // If fWebView is not ON on the source system, fDoubleClickInWebView can have random
                                // values.
                                if (shellState1->ss.fWebView) {
                                    shellState2->ss.fDoubleClickInWebView = shellState1->ss.fDoubleClickInWebView;
                                } else {
                                    shellState2->ss.fDoubleClickInWebView = TRUE;
                                }
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the meaningfull settings.
                if (OriginalContent->MemoryContent.ContentSize == sizeof(UINT)+SHELLSTATE_SIZE_WIN95) {
                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                    CreateDwordRegObject (
                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("Hidden"),
                        shellState1->ss.fShowAllObjects?0x00000001:0x00000002
                        );
                    CreateDwordRegObject (
                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("HideFileExt"),
                        shellState1->ss.fShowExtensions?0x00000000:0x00000001
                        );
                    // on really old SHELLSTATE the "Show compressed folders" flag is in the place of fShowSysFiles
                    CreateDwordRegObject (
                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("ShowCompColor"),
                        shellState1->ss.fShowSysFiles?0x00000001:0x00000000
                        );
                }
                if (OriginalContent->MemoryContent.ContentSize == sizeof(UINT)+sizeof(SHELLSTATE)) {
                    shellState1 = (PREGSHELLSTATE)OriginalContent->MemoryContent.ContentBytes;
                    shellState2 = (PREGSHELLSTATE)NewContent->MemoryContent.ContentBytes;
                    // If fWebView is not ON on the source system, fDoubleClickInWebView can have random
                    // values.
                    if (shellState1->ss.fWebView) {
                        shellState2->ss.fDoubleClickInWebView = shellState1->ss.fDoubleClickInWebView;
                    } else {
                        shellState2->ss.fDoubleClickInWebView = TRUE;
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pMigrateDisplayCS (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECTTYPEID newObjectTypeId;
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PDWORD valueType1, valueType2, valueType;
    BOOL deleted = TRUE, replaced = FALSE;
    MIG_CONTENT destContent;
    LPCABINETSTATE cabState1 = NULL, cabState2 = NULL;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (OriginalContent->Details.DetailsSize == sizeof (DWORD));
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType1 = (PDWORD)(OriginalContent->Details.DetailsData);
        valueType2 = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType1 == REG_BINARY) &&
            (*valueType2 == REG_BINARY)
            ) {

            // if the object was not changed yet we need to read the destination object and then
            // just transfer the meaningfull settings.

            if ((!CurrentContent->MemoryContent.ContentBytes) ||
                (CurrentContent->MemoryContent.ContentBytes == OriginalContent->MemoryContent.ContentBytes)
                ) {
                // find out the destination object and read it
                newObjectName = IsmFilterObject (
                                    SrcObjectTypeId,
                                    SrcObjectName,
                                    &newObjectTypeId,
                                    &deleted,
                                    &replaced
                                    );
                if ((!deleted || replaced) &&
                    ((newObjectTypeId & ~PLATFORM_MASK) == MIG_REGISTRY_TYPE)
                    ) {

                    if (IsmAcquireObject (
                            (newObjectTypeId & ~PLATFORM_MASK) | PLATFORM_DESTINATION,
                            newObjectName?newObjectName:SrcObjectName,
                            &destContent
                            )) {

                        if ((IsValidRegType (&destContent, REG_BINARY)) &&
                            (destContent.MemoryContent.ContentSize == sizeof (CABINETSTATE))
                            ) {
                            NewContent->MemoryContent.ContentSize = sizeof (CABINETSTATE);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            CopyMemory (
                                (PBYTE)NewContent->MemoryContent.ContentBytes,
                                destContent.MemoryContent.ContentBytes,
                                NewContent->MemoryContent.ContentSize
                                );

                            if (OriginalContent->MemoryContent.ContentSize == sizeof(CABINETSTATE)) {
                                cabState1 = (LPCABINETSTATE)OriginalContent->MemoryContent.ContentBytes;
                                cabState2 = (LPCABINETSTATE)NewContent->MemoryContent.ContentBytes;
                                if (cabState1->nVersion >= 2) {
                                    CopyMemory (
                                        (PBYTE)NewContent->MemoryContent.ContentBytes,
                                        OriginalContent->MemoryContent.ContentBytes,
                                        NewContent->MemoryContent.ContentSize
                                        );
                                } else {
                                    CreateDwordRegObject (
                                        TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CabinetState"),
                                        TEXT("FullPath"),
                                        cabState1->fFullPathTitle?0x00000001:0x00000000
                                        );
                                    cabState2->fNewWindowMode = cabState1->fNewWindowMode;
                                }
                            }
                        }

                        IsmReleaseObject (&destContent);
                    }

                    if (newObjectName) {
                        IsmDestroyObjectHandle (newObjectName);
                        newObjectName = NULL;
                    }
                }
            } else {
                // just transfer the meaningfull settings.
                if (OriginalContent->MemoryContent.ContentSize == sizeof(CABINETSTATE)) {
                    cabState1 = (LPCABINETSTATE)OriginalContent->MemoryContent.ContentBytes;
                    cabState2 = (LPCABINETSTATE)NewContent->MemoryContent.ContentBytes;
                    if (cabState1->nVersion < 2) {
                        CreateDwordRegObject (
                            TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CabinetState"),
                            TEXT("FullPath"),
                            cabState1->fFullPathTitle?0x00000001:0x00000000
                            );
                        cabState2->fNewWindowMode = cabState1->fNewWindowMode;
                    }
                }
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by v1.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\rules.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    rules.c

Abstract:

    Implements the "rule" algorithm that scores script patterns and keeps them
    in reverse-sorted order.

Author:

    Jim Schmidt (jimschm) 12-May-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct _TAG_RULE {
    PCTSTR ObjectBase;
    MIG_OBJECTSTRINGHANDLE ObjectPattern;
    POBSPARSEDPATTERN ParsedPattern;
    UINT Score;
    ACTIONGROUP ActionGroup;
    DWORD ActionFlags;
    ACTION_STRUCT ActionStruct;
    struct _TAG_RULE *NextRule;
} RULE, *PRULE;

typedef struct _TAG_CHAR_NODE {
    PRULE RuleList;
    WORD Char;
    WORD Flags;
    struct _TAG_CHAR_NODE *NextLevel;
    struct _TAG_CHAR_NODE *NextPeer;
} CHAR_NODE, *PCHAR_NODE;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    PRULE RuleList;
    PCHAR_NODE FirstLevel;
} TYPE_RULE, *PTYPE_RULE;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    TYPE_RULE TypeRule;
} TYPETORULE, *PTYPETORULE;

//
// Globals
//

GROWBUFFER g_TypeToIncRule  = INIT_GROWBUFFER;
GROWBUFFER g_TypeToPriRule  = INIT_GROWBUFFER;
GROWBUFFER g_TypeToCollRule = INIT_GROWBUFFER;
GROWBUFFER g_TypeRuleList   = INIT_GROWBUFFER;
PMHANDLE g_RulePool;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pAddRuleToTypeRule (
    IN      PTYPE_RULE TypeRule,
    IN      PRULE Rule
    )
{
    PCHAR_NODE node, currNode, prevNode;
    PTSTR objectBase;
    PCTSTR p;
    WORD w;
    BOOL found;

    if (Rule->ObjectBase) {
        currNode = TypeRule->FirstLevel;
        prevNode = currNode;
        objectBase = DuplicatePathString (Rule->ObjectBase, 0);
        CharLower (objectBase);
        p = objectBase;
        while (*p) {
            w = (WORD) _tcsnextc (p);
            p = _tcsinc (p);
            if (currNode) {
                if (currNode->Char == w) {
                    if (!*p) {
                        Rule->NextRule = currNode->RuleList;
                        currNode->RuleList = Rule;
                    }
                    prevNode = currNode;
                    currNode = currNode->NextLevel;
                } else {
                    found = FALSE;
                    while (!found && currNode->NextPeer) {
                        if (currNode->NextPeer->Char == w) {
                            if (!*p) {
                                Rule->NextRule = currNode->NextPeer->RuleList;
                                currNode->NextPeer->RuleList = Rule;
                            }
                            prevNode = currNode->NextPeer;
                            currNode = prevNode->NextLevel;
                            found = TRUE;
                            break;
                        }
                        currNode = currNode->NextPeer;
                    }
                    if (!found) {
                        node = PmGetMemory (g_RulePool, sizeof (CHAR_NODE));
                        ZeroMemory (node, sizeof (CHAR_NODE));
                        if (!*p) {
                            node->RuleList = Rule;
                        }
                        node->Char = w;
                        node->NextPeer = currNode->NextPeer;
                        currNode->NextPeer = node;
                        prevNode = node;
                        currNode = node->NextLevel;
                    }
                }
            } else {
                node = PmGetMemory (g_RulePool, sizeof (CHAR_NODE));
                ZeroMemory (node, sizeof (CHAR_NODE));
                if (!*p) {
                    node->RuleList = Rule;
                }
                node->Char = w;
                if (prevNode) {
                    prevNode->NextLevel = node;
                } else {
                    TypeRule->FirstLevel = node;
                }
                prevNode = node;
                currNode = prevNode->NextLevel;
            }
        }
        FreePathString (objectBase);
    } else {
        Rule->NextRule = TypeRule->RuleList;
        TypeRule->RuleList = Rule;
    }
    return TRUE;
}

UINT
pComputeSubScore (
    IN      BOOL ExcludeLastPatSeg,
    IN      PCTSTR String,
    IN      UINT WildcardScore,
    IN      UINT FixedCharScore,
    IN      UINT WackScoreBeforeWildcard,
    IN      UINT WackScoreAfterWildcard
    )
{
    PCTSTR p;
    BOOL skipExtendedPattern;
    UINT score = 0;
    BOOL patternEncountered = FALSE;
    CHARTYPE ch;
    UINT state = 0;
    UINT delScore = 0;

    for (p = String ; *p ; p = _tcsinc (p)) {

        skipExtendedPattern = FALSE;

        switch (_tcsnextc (p)) {

        case TEXT('*'):
            if (state == 1) {
                state = 2;
            }
            if (state == 2) {
                delScore += WildcardScore;
            }
            score += WildcardScore;
            skipExtendedPattern = TRUE;
            patternEncountered = TRUE;
            break;

        case TEXT('?'):
            if (state == 1) {
                state = 2;
            }
            if (state == 2) {
                delScore += WildcardScore;
            }
            score += WildcardScore;
            skipExtendedPattern = TRUE;
            patternEncountered = TRUE;
            break;

        case TEXT('\\'):
            state = 1;
            if (patternEncountered) {
                score += WackScoreAfterWildcard;
                delScore = WackScoreAfterWildcard;
            } else {
                score += WackScoreBeforeWildcard;
                delScore = WackScoreBeforeWildcard;
            }
            break;

        case TEXT(':'):
            //
            // Special case: if just a drive spec with no wacks,
            //               add the wack score
            //

            if (p[1] == 0) {
                score += WackScoreBeforeWildcard;
                break;
            }

            // fall through
        default:
            state = 0;
            delScore = 0;
            score += FixedCharScore;
            break;
        }

        if (skipExtendedPattern) {
            if (_tcsnextc (_tcsinc (p)) == TEXT('[')) {
                do {
                    p = _tcsinc (p);

                    ch = (CHARTYPE) _tcsnextc (p);
                    if (ch == TEXT('^')) {
                        p++;
                    }

                } while (ch != TEXT(']'));
            }
        }
    }

    if (ExcludeLastPatSeg) {
        if (score > delScore) {
            score -= delScore;
            if (delScore && score > 0) {
                score -= 1;
            }
        } else {
            score = 0;
        }
    }

    return score;
}

UINT
pComputeScore (
    IN      MIG_OBJECTSTRINGHANDLE EncodedString
    )
{
    PCTSTR node;
    PCTSTR leaf;
    UINT score = 0;

    IsmCreateObjectStringsFromHandle (EncodedString, &node, &leaf);

    if (node) {
        score += 1000 * pComputeSubScore (TRUE, node, 0, 10, 1000, 500);
    }

    if (leaf) {
        score += pComputeSubScore (FALSE, leaf, 0, 10, 0, 0);
    }

    IsmDestroyObjectString (node);
    IsmDestroyObjectString (leaf);

    return score;
}

PTYPE_RULE
pGetListForType (
    IN      PGROWBUFFER TypeToRule,
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )
{
    PTYPE_RULE pos;
    PTYPE_RULE end;

    ObjectTypeId &= ~(PLATFORM_MASK);

    pos = (PTYPE_RULE) TypeToRule->Buf;
    end = (PTYPE_RULE) (TypeToRule->Buf + TypeToRule->End);

    while (pos < end) {
        if (pos->ObjectTypeId == ObjectTypeId) {
            return pos;
        }
        pos++;
    }

    pos = (PTYPE_RULE) GbGrow (TypeToRule, sizeof (TYPE_RULE));

    ZeroMemory (pos, sizeof (TYPE_RULE));
    pos->ObjectTypeId = ObjectTypeId;

    return pos;
}

VOID
InitRules (
    VOID
    )
{
    g_RulePool = PmCreateNamedPoolEx ("Rule Data", 32768);
    PmDisableTracking (g_RulePool);
}

VOID
TerminateRules (
    VOID
    )
{
    GbFree (&g_TypeToIncRule);
    GbFree (&g_TypeToPriRule);
    GbFree (&g_TypeToCollRule);
    GbFree (&g_TypeRuleList);

    PmEmptyPool (g_RulePool);
    PmDestroyPool (g_RulePool);
    INVALID_POINTER (g_RulePool);
}

UINT
pGetActionWeight (
    IN      ACTIONGROUP ActionGroup
    )
{
    switch (ActionGroup) {
    case ACTIONGROUP_DEFAULTPRIORITY:
        return ACTIONWEIGHT_DEFAULTPRIORITY;
    case ACTIONGROUP_SPECIFICPRIORITY:
        return ACTIONWEIGHT_SPECIFICPRIORITY;
    case ACTIONGROUP_EXCLUDE:
        return ACTIONWEIGHT_EXCLUDE;
    case ACTIONGROUP_EXCLUDEEX:
        return ACTIONWEIGHT_EXCLUDEEX;
    case ACTIONGROUP_INCLUDE:
        return ACTIONWEIGHT_INCLUDE;
    case ACTIONGROUP_INCLUDEEX:
        return ACTIONWEIGHT_INCLUDEEX;
    case ACTIONGROUP_RENAME:
        return ACTIONWEIGHT_RENAME;
    case ACTIONGROUP_RENAMEEX:
        return ACTIONWEIGHT_RENAMEEX;
    case ACTIONGROUP_INCLUDERELEVANT:
        return ACTIONWEIGHT_INCLUDERELEVANT;
    case ACTIONGROUP_INCLUDERELEVANTEX:
        return ACTIONWEIGHT_INCLUDERELEVANTEX;
    case ACTIONGROUP_RENAMERELEVANT:
        return ACTIONWEIGHT_RENAMERELEVANT;
    case ACTIONGROUP_RENAMERELEVANTEX:
        return ACTIONWEIGHT_RENAMERELEVANTEX;
    case ACTIONGROUP_INCFILE:
        return ACTIONWEIGHT_INCFILE;
    case ACTIONGROUP_INCFILEEX:
        return ACTIONWEIGHT_INCFILEEX;
    case ACTIONGROUP_INCFOLDER:
        return ACTIONWEIGHT_INCFOLDER;
    case ACTIONGROUP_INCFOLDEREX:
        return ACTIONWEIGHT_INCFOLDEREX;
    case ACTIONGROUP_INCICON:
        return ACTIONWEIGHT_INCICON;
    case ACTIONGROUP_INCICONEX:
        return ACTIONWEIGHT_INCICONEX;
    case ACTIONGROUP_DELREGKEY:
        return ACTIONWEIGHT_DELREGKEY;
    default:
        return 0;
    }
}

BOOL
AddRuleEx (
    IN      MIG_OBJECTTYPEID Type,
    IN      MIG_OBJECTSTRINGHANDLE ObjectBase,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PACTION_STRUCT ActionStruct,            OPTIONAL
    IN      RULEGROUP RuleGroup
    )
{
    PTYPE_RULE typeRule;
    MIG_SEGMENTS nodeSegment;
    MIG_SEGMENTS leafSegment;
    PCTSTR ourEncodedString;
    PCTSTR node;
    PCTSTR leaf;
    PRULE rule;
    PGROWBUFFER ruleStruct;

    switch (RuleGroup) {

    case RULEGROUP_NORMAL:
        ruleStruct = &g_TypeToIncRule;
        break;

    case RULEGROUP_PRIORITY:
        ruleStruct = &g_TypeToPriRule;
        break;

    case RULEGROUP_COLLPATTERN:
        ruleStruct = &g_TypeToCollRule;
        break;
    }

    typeRule = pGetListForType (ruleStruct, Type);
    if (!typeRule) {
        return FALSE;
    }

    //
    // Make sure both node an leaf are specified
    //

    IsmCreateObjectStringsFromHandleEx (ObjectPattern, &node, &leaf, TRUE);

    nodeSegment.Segment = node ? node : TEXT("*");
    nodeSegment.IsPattern = TRUE;

    leafSegment.Segment = leaf ? leaf : TEXT("*");
    leafSegment.IsPattern = TRUE;

    ourEncodedString = IsmCreateObjectPattern (
                            &nodeSegment,
                            1,
                            &leafSegment,
                            1
                            );

    IsmDestroyObjectString (node);
    IsmDestroyObjectString (leaf);

    //
    // Insert the rule based on score
    //
    rule = PmGetMemory (g_RulePool, sizeof (RULE));
    ZeroMemory (rule, sizeof (RULE));
    if (ObjectBase) {
        IsmCreateObjectStringsFromHandle (ObjectBase, &node, &leaf);
        if (node) {
            rule->ObjectBase = PmDuplicateString (g_RulePool, node);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    rule->ObjectPattern = PmDuplicateString (g_RulePool, ourEncodedString);
    rule->ParsedPattern = ObsCreateParsedPatternEx (g_RulePool, ourEncodedString, FALSE);

    MYASSERT (rule->ParsedPattern);
    if (rule->ParsedPattern) {
        rule->Score = pComputeScore (ourEncodedString);
        rule->Score = rule->Score * 10 + pGetActionWeight (ActionGroup);
        rule->ActionGroup = ActionGroup;
        rule->ActionFlags = ActionFlags;
        if (ActionStruct) {
            if (ActionStruct->ObjectBase) {
                rule->ActionStruct.ObjectBase = PmDuplicateString (g_RulePool, ActionStruct->ObjectBase);
            }
            if (ActionStruct->ObjectDest) {
                rule->ActionStruct.ObjectDest = PmDuplicateString (g_RulePool, ActionStruct->ObjectDest);
            }
            if (ActionStruct->AddnlDest) {
                rule->ActionStruct.AddnlDest = PmDuplicateString (g_RulePool, ActionStruct->AddnlDest);
            }
            if (ActionStruct->ObjectHint) {
                rule->ActionStruct.ObjectHint = PmDuplicateString (g_RulePool, ActionStruct->ObjectHint);
            }
        }

        pAddRuleToTypeRule (typeRule, rule);
    } else {
        IsmCreateObjectStringsFromHandleEx (ourEncodedString, &node, &leaf, TRUE);
        LOG ((LOG_ERROR, (PCSTR) MSG_OBJECT_SPEC_ERROR, node, leaf));
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    IsmDestroyObjectHandle (ourEncodedString);

    return TRUE;
}

BOOL
QueryRuleEx (
    IN      MIG_OBJECTTYPEID Type,
    IN      MIG_OBJECTSTRINGHANDLE EncodedString,
    IN      PCTSTR ObjectNode,
    OUT     PACTIONGROUP ActionGroup,
    OUT     PDWORD ActionFlags,
    OUT     PACTION_STRUCT ActionStruct,                OPTIONAL
    IN      RULEGROUP RuleGroup
    )
{
    PTYPE_RULE typeRule;
    PCHAR_NODE charNode;
    PTSTR objectBase;
    PCTSTR p;
    WORD w;
    PRULE rule;
    PRULE foundRule;
    UINT maxScore;
    ACTIONGROUP initialAction = ACTIONGROUP_NONE;
    DWORD matchingFlags = 0;
    PGROWBUFFER ruleStruct;

    switch (RuleGroup) {

    case RULEGROUP_NORMAL:
        ruleStruct = &g_TypeToIncRule;
        break;

    case RULEGROUP_PRIORITY:
        ruleStruct = &g_TypeToPriRule;
        break;

    case RULEGROUP_COLLPATTERN:
        ruleStruct = &g_TypeToCollRule;
        break;
    }

    if (ActionStruct) {
        ZeroMemory (ActionStruct, sizeof (ACTION_STRUCT));
    }

    typeRule = pGetListForType (ruleStruct, Type);
    if (!typeRule) {
        return FALSE;
    }

    //
    // Let's walk the structure finding all possible rules and put them in a grow buffer
    // Later we'll examine the rules one by one. Note that the root rules always qualify
    //
    if (ObjectNode) {
        objectBase = DuplicatePathString (ObjectNode, 0);
        CharLower (objectBase);
    }
    g_TypeRuleList.End = 0;
    p = objectBase;
    if (p) {
        w = (WORD) _tcsnextc (p);
        charNode = typeRule->FirstLevel;
        while (charNode && *p) {
            if (charNode->Char == w) {
                if (charNode->RuleList) {
                    CopyMemory (GbGrow (&g_TypeRuleList, sizeof (PRULE)), &(charNode->RuleList), sizeof (PRULE));
                }
                charNode = charNode->NextLevel;
                p = _tcsinc (p);
                w = (WORD) _tcsnextc (p);
            } else {
                charNode = charNode->NextPeer;
            }
        }
    }
    maxScore = 0;
    foundRule = NULL;
    while (g_TypeRuleList.End) {
        CopyMemory (&rule, &(g_TypeRuleList.Buf[g_TypeRuleList.End - sizeof (PRULE)]), sizeof (PRULE));
        while (rule) {
            if (maxScore <= rule->Score) {
                if (IsmParsedPatternMatch ((MIG_PARSEDPATTERN)rule->ParsedPattern, Type, EncodedString)) {
                    if (foundRule && (maxScore == rule->Score)) {
                        if (initialAction == rule->ActionGroup) {
                            matchingFlags |= rule->ActionFlags;
                        }
                    } else {
                        foundRule = rule;
                        initialAction = foundRule->ActionGroup;
                        matchingFlags = foundRule->ActionFlags;
                        maxScore = rule->Score;
                    }
                }
            }
            rule = rule->NextRule;
        }
        g_TypeRuleList.End -= sizeof (PRULE);
    }
    rule = typeRule->RuleList;
    while (rule) {
        if (maxScore <= rule->Score) {
            if (IsmParsedPatternMatch ((MIG_PARSEDPATTERN)rule->ParsedPattern, Type, EncodedString)) {
                if (foundRule && (maxScore == rule->Score)) {
                    if (initialAction == rule->ActionGroup) {
                        matchingFlags |= rule->ActionFlags;
                    }
                } else {
                    foundRule = rule;
                    initialAction = foundRule->ActionGroup;
                    matchingFlags = foundRule->ActionFlags;
                    maxScore = rule->Score;
                }
            }
        }
        rule = rule->NextRule;
    }

    if (foundRule) {
        *ActionGroup = initialAction;
        *ActionFlags = matchingFlags;
        if (ActionStruct && (!ActionStruct->ObjectBase) && (foundRule->ActionStruct.ObjectBase)) {
            ActionStruct->ObjectBase = foundRule->ActionStruct.ObjectBase;
        }
        if (ActionStruct && (!ActionStruct->ObjectDest) && (foundRule->ActionStruct.ObjectDest)) {
            ActionStruct->ObjectDest = foundRule->ActionStruct.ObjectDest;
        }
        if (ActionStruct && (!ActionStruct->AddnlDest) && (foundRule->ActionStruct.AddnlDest)) {
            ActionStruct->AddnlDest = foundRule->ActionStruct.AddnlDest;
        }
        if (ActionStruct && (!ActionStruct->ObjectHint) && (foundRule->ActionStruct.ObjectHint)) {
            ActionStruct->ObjectHint = foundRule->ActionStruct.ObjectHint;
        }
    }

    FreePathString (objectBase);

    return (foundRule != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\restore.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    restore.c

Abstract:

    Implements object restore callbacks

Author:

    Calin Negreanu (calinn) 21-Nov-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_RESTORE  "RestoreCallbacks"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef BOOL(WINAPI SCRIPTRESTOREFUNCTION)(
                        IN      MIG_OBJECTTYPEID ObjectTypeId,
                        IN      MIG_OBJECTID ObjectId,
                        IN      MIG_OBJECTSTRINGHANDLE ObjectName,
                        IN      PCTSTR MultiSzData
                        );
typedef SCRIPTRESTOREFUNCTION *PSCRIPTRESTOREFUNCTION;

//
// This is the structure used for handling restore callback functions
//
typedef struct {
    PCTSTR InfFunctionName;
    PSCRIPTRESTOREFUNCTION RestoreCallback;
} RESTORE_STRUCT, *PRESTORE_STRUCT;

typedef struct _RESTOREDATA_STRUCT{
    POBSPARSEDPATTERN ParsedPattern;
    PCTSTR RestoreArgs;
    PRESTORE_STRUCT RestoreStruct;
    struct _RESTOREDATA_STRUCT *Next;
} RESTOREDATA_STRUCT, *PRESTOREDATA_STRUCT;

//
// Globals
//

PRESTOREDATA_STRUCT g_RestoreData = NULL;
PMHANDLE g_RestorePool;

//
// Macro expansion list
//

#define RESTORE_FUNCTIONS        \
        DEFMAC(NEVER,           pNever          )  \
        DEFMAC(SAMEREGVALUE,    pSameRegValue   )  \
        DEFMAC(EXISTSINHKLM,    pExistsInHKLM   )  \

//
// Private function prototypes
//

MIG_RESTORECALLBACK pRestoreCallback;

//
// Macro expansion definition
//

//
// Declare special conversion operation apply callback functions
//
#define DEFMAC(ifn,fn) SCRIPTRESTOREFUNCTION fn;
RESTORE_FUNCTIONS
#undef DEFMAC

//
// Declare a global array of conversion functions
//
#define DEFMAC(ifn,fn) {TEXT("\\")TEXT(#ifn),fn},
static RESTORE_STRUCT g_RestoreFunctions[] = {
                              RESTORE_FUNCTIONS
                              {NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//


PRESTORE_STRUCT
pGetRestoreStruct (
    IN      PCTSTR FunctionName
    )
{
    PRESTORE_STRUCT p = g_RestoreFunctions;
    INT i = 0;
    while (p->InfFunctionName != NULL) {
        if (StringIMatch (p->InfFunctionName, FunctionName)) {
            return p;
        }
        p++;
        i++;
    }
    return NULL;
}

BOOL
pParseRestoreInf (
    IN      HINF InfHandle
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    PCTSTR fnName;
    PCTSTR fnArgs;
    ENCODEDSTRHANDLE srcHandle = NULL;
    BOOL result = FALSE;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    PRESTOREDATA_STRUCT restoreData;

    __try {

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_RESTORE,
                NULL,
                0,
                &sizeNeeded
                )) {
            result = TRUE;
            __leave;
        }

        if (!GbGrow (&multiSz, sizeNeeded)) {
            __leave;
        }

        if (!IsmGetEnvironmentMultiSz (
                PLATFORM_SOURCE,
                NULL,
                S_ENV_DEST_RESTORE,
                (PTSTR) multiSz.Buf,
                multiSz.End,
                NULL
                )) {
            __leave;
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) multiSz.Buf)) {

            do {

                if (InfFindFirstLine (InfHandle, e.CurrentString, NULL, &is)) {
                    do {

                        if (IsmCheckCancel()) {
                            __leave;
                        }

                        pattern = InfGetStringField (&is, 0);

                        if (!pattern) {
                            LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_REG_SPEC));
                            continue;
                        }

                        srcHandle = TurnRegStringIntoHandle (pattern, TRUE, NULL);
                        if (!srcHandle) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                            continue;
                        }

                        fnName = InfGetStringField (&is, 1);
                        if (!fnName) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                            IsmDestroyObjectHandle (srcHandle);
                            srcHandle = NULL;
                            continue;
                        }

                        fnArgs = InfGetMultiSzField (&is, 2);

                        restoreData = PmGetMemory (g_RestorePool, sizeof (RESTOREDATA_STRUCT));
                        ZeroMemory (restoreData, sizeof (RESTOREDATA_STRUCT));
                        restoreData->ParsedPattern = ObsCreateParsedPatternEx (g_RestorePool, srcHandle, FALSE);
                        if (fnArgs) {
                            restoreData->RestoreArgs = PmDuplicateMultiSz (g_RestorePool, fnArgs);
                        }
                        if (fnName) {
                            restoreData->RestoreStruct = pGetRestoreStruct (fnName);
                        }
                        restoreData->Next = g_RestoreData;
                        g_RestoreData = restoreData;

                        IsmDestroyObjectHandle (srcHandle);
                        srcHandle = NULL;

                    } while (InfFindNextLine (&is));
                }
            } while (EnumNextMultiSz (&e));
        }

        result = TRUE;
    }
    __finally {

        GbFree (&multiSz);
        InfCleanUpInfStruct (&is);

    }

    return result;
}

BOOL
InitRestoreCallback (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = FALSE;

    g_RestorePool = PmCreateNamedPoolEx ("Restore Callback Data", 32768);
    PmDisableTracking (g_RestorePool);

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (pParseRestoreInf (infHandle)) {
            result = TRUE;
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {

                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseRestoreInf (infHandle)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            __leave;
                        }
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                    InfCloseInfFile (infHandle);
                    infHandle = INVALID_HANDLE_VALUE;
                } while (EnumNextMultiSz (&e));

            }

            result = TRUE;
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }

    IsmRegisterRestoreCallback (pRestoreCallback);

    return result;
}

VOID
TerminateRestoreCallback (
    VOID
    )
{
    if (g_RestorePool) {
        PmEmptyPool (g_RestorePool);
        PmDestroyPool (g_RestorePool);
        g_RestorePool = NULL;
    }
}

BOOL
pRestoreCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    BOOL result = TRUE;
    PRESTOREDATA_STRUCT p = g_RestoreData;

    if (ObjectTypeId & MIG_REGISTRY_TYPE) {
        while (p) {
            if (p->ParsedPattern) {
                if (IsmParsedPatternMatch ((MIG_PARSEDPATTERN)p->ParsedPattern, MIG_REGISTRY_TYPE, ObjectName)) {
                    if (p->RestoreStruct) {
                        if (p->RestoreStruct->RestoreCallback) {
                            if (!p->RestoreStruct->RestoreCallback (
                                                        ObjectTypeId,
                                                        ObjectId,
                                                        ObjectName,
                                                        p->RestoreArgs
                                                        )) {
                                result = FALSE;
                                break;
                            }
                        }
                    }
                }
            }
            p = p->Next;
        }
    }

    return result;
}

BOOL
pIsSameContent (
    IN      PMIG_CONTENT ContentSrc,
    IN      PMIG_CONTENT ContentDest
    )
{
    INT value1 = 0;
    INT value2 = 0;

    if (ContentSrc->ContentInFile) {
        return FALSE;
    }

    if (ContentDest->ContentInFile) {
        return FALSE;
    }

    if (ContentSrc->Details.DetailsSize != ContentDest->Details.DetailsSize) {
        return FALSE;
    }

    if (!TestBuffer (
            ContentSrc->Details.DetailsData,
            ContentDest->Details.DetailsData,
            ContentSrc->Details.DetailsSize
            )) {
        return FALSE;
    }

    if ((ContentSrc->MemoryContent.ContentSize == 0) &&
        (ContentDest->MemoryContent.ContentSize == 0)
        ) {
        // no content, just return TRUE
        return TRUE;
    }

    if ((ContentSrc->MemoryContent.ContentSize == ContentDest->MemoryContent.ContentSize) &&
        TestBuffer (
            ContentSrc->MemoryContent.ContentBytes,
            ContentDest->MemoryContent.ContentBytes,
            ContentSrc->MemoryContent.ContentSize
            )) {
        // same exact content
        return TRUE;
    }

    // we have an extra case, if the source and dest are strings but they are actually numbers
    // we will get the numbers and compare them
    if ((ContentSrc->Details.DetailsSize == sizeof (DWORD)) &&
        (ContentSrc->Details.DetailsData) &&
        (ContentDest->Details.DetailsData) &&
        ((*(PDWORD)ContentSrc->Details.DetailsData == REG_SZ) ||
         (*(PDWORD)ContentSrc->Details.DetailsData == REG_EXPAND_SZ)
         ) &&
        ((*(PDWORD)ContentDest->Details.DetailsData == REG_SZ) ||
         (*(PDWORD)ContentDest->Details.DetailsData == REG_EXPAND_SZ)
         ) &&
        (ContentSrc->MemoryContent.ContentBytes) &&
        (ContentDest->MemoryContent.ContentBytes)
        ) {
        value1 = _ttoi ((PCTSTR)ContentSrc->MemoryContent.ContentBytes);
        value2 = _ttoi ((PCTSTR)ContentDest->MemoryContent.ContentBytes);
        if ((value1 != 0) &&
            (value2 != 0) &&
            (value1 == value2)
            ) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
pSameRegValue (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR MultiSzData
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    BOOL hadLeaf = FALSE;
    BOOL existsSrc = FALSE;
    MIG_CONTENT contentSrc;
    BOOL existsDest = FALSE;
    MIG_CONTENT contentDest;
    BOOL result = TRUE;

    if (MultiSzData) {

        objectName = TurnRegStringIntoHandle (MultiSzData, FALSE, &hadLeaf);

        if (objectName) {

            existsSrc = IsmAcquireObjectEx (
                            MIG_REGISTRY_TYPE | PLATFORM_SOURCE,
                            objectName,
                            &contentSrc,
                            CONTENTTYPE_MEMORY,
                            0
                            );
            existsDest = IsmAcquireObjectEx (
                            MIG_REGISTRY_TYPE | PLATFORM_DESTINATION,
                            objectName,
                            &contentDest,
                            CONTENTTYPE_MEMORY,
                            0
                            );

            result = (existsSrc && existsDest) || (!existsSrc && !existsDest);

            if (hadLeaf && result && existsSrc && existsDest) {

                result = pIsSameContent (&contentSrc, &contentDest);

            }

            if (existsSrc) {
                IsmReleaseObject (&contentSrc);
            }
            if (existsDest) {
                IsmReleaseObject (&contentDest);
            }
        }
    }

    return result;
}

BOOL
pNever (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR MultiSzData
    )
{
    return FALSE;
}

BOOL
pExistsInHKLM (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR MultiSzData
    )
{
    MIG_OBJECTSTRINGHANDLE newObjectName;
    PCTSTR node, leaf, nodePtr, newNode;
    MIG_CONTENT content;
    BOOL result = TRUE;

    if (ObjectTypeId == (MIG_REGISTRY_TYPE | PLATFORM_SOURCE)) {
        if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

            if (node && StringIPrefix (node, TEXT("HKCU\\"))) {
                nodePtr = node + ARRAYSIZE (TEXT("HKCU"));
                newNode = JoinPathsInPoolEx ((
                                NULL,
                                TEXT("HKLM"),
                                MultiSzData?MultiSzData:nodePtr,
                                MultiSzData?nodePtr:NULL,
                                NULL
                                ));
                newObjectName = IsmCreateObjectHandle (newNode, leaf);
                if (newObjectName) {
                    result = !IsmAcquireObjectEx (
                                MIG_REGISTRY_TYPE | PLATFORM_DESTINATION,
                                newObjectName,
                                &content,
                                CONTENTTYPE_MEMORY,
                                0
                                );
                    if (!result) {
                        IsmReleaseObject (&content);
                    }
                    IsmDestroyObjectHandle (newObjectName);
                }
                FreePathString (newNode);
            }

            IsmDestroyObjectString (node);
            IsmDestroyObjectString (leaf);
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\sgmcallback.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sgmcallback.c

Abstract:

    Implements the callbacks that are queued in sgmqueue.c.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_SCRIPT  "Script"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

MIG_OBJECTSTRINGHANDLE
pSimpleTryHandle (
    IN      PCTSTR FullPath,
    IN      BOOL Recursive
    )
{
    DWORD attribs;
    PCTSTR buffer;
    PTSTR leafPtr, leaf;
    MIG_OBJECTSTRINGHANDLE result = NULL;
    MIG_OBJECTSTRINGHANDLE longResult = NULL;
    PTSTR workingPath;
    PCTSTR sanitizedPath;
    PCTSTR longPath;
    PCTSTR objNode = NULL, objLeaf = NULL;

    sanitizedPath = SanitizePath (FullPath);
    if (!sanitizedPath) {
        return NULL;
    }

    if (IsmGetRealPlatform () == PLATFORM_SOURCE) {
        attribs = GetFileAttributes (sanitizedPath);
    } else {
        attribs = INVALID_ATTRIBUTES;
    }

    if (attribs != INVALID_ATTRIBUTES) {

        longPath = BfGetLongFileName (sanitizedPath);
        if (!longPath) {
            longPath = sanitizedPath;
        }
        if (attribs & FILE_ATTRIBUTE_DIRECTORY) {
            if (Recursive) {
                workingPath = DuplicatePathString (longPath, 0);
                RemoveWackAtEnd (workingPath);
                result = IsmCreateSimpleObjectPattern (workingPath, TRUE, NULL, TRUE);
                FreePathString (workingPath);
            } else {
                result = IsmCreateObjectHandle (longPath, NULL);
            }
        } else {

            buffer = DuplicatePathString (longPath, 0);

            leaf = _tcsrchr (buffer, TEXT('\\'));

            if (leaf) {
                leafPtr = leaf;
                leaf = _tcsinc (leaf);
                *leafPtr = 0;
                result = IsmCreateObjectHandle (buffer, leaf);
            }

            FreePathString (buffer);
        }
        if (longPath != sanitizedPath) {
            FreePathString (longPath);
            longPath = NULL;
        }

    } else {

        result = IsmCreateObjectHandle (sanitizedPath, NULL);
        if (result) {

            longResult = IsmGetLongName (MIG_FILE_TYPE|PLATFORM_SOURCE, result);
            if (!longResult) {
                longResult = result;
            }

            if (IsmGetObjectIdFromName (g_FileType, longResult, TRUE)) {
                if (Recursive) {
                    if (IsmCreateObjectStringsFromHandle (longResult, &objNode, &objLeaf)) {
                        if (longResult != result) {
                            IsmDestroyObjectHandle (longResult);
                            longResult = NULL;
                        }
                        IsmDestroyObjectHandle (result);
                        result = IsmCreateSimpleObjectPattern (objNode, TRUE, NULL, TRUE);
                        IsmDestroyObjectString (objNode);
                        IsmDestroyObjectString (objLeaf);
                    }
                }
                return result;
            } else {
                if (longResult != result) {
                    IsmDestroyObjectHandle (longResult);
                    longResult = NULL;
                }
                IsmDestroyObjectHandle (result);
                result = NULL;
            }
        }

        if (!result) {
            buffer = DuplicatePathString (sanitizedPath, 0);

            leaf = _tcsrchr (buffer, TEXT('\\'));

            if (leaf) {
                leafPtr = leaf;
                leaf = _tcsinc (leaf);
                *leafPtr = 0;
                result = IsmCreateObjectHandle (buffer, leaf);
            }

            if (result) {

                longResult = IsmGetLongName (MIG_FILE_TYPE|PLATFORM_SOURCE, result);
                if (!longResult) {
                    longResult = result;
                }

                if (!IsmGetObjectIdFromName (g_FileType, longResult, TRUE)) {
                    if (longResult != result) {
                        IsmDestroyObjectHandle (longResult);
                        longResult = NULL;
                    }
                    IsmDestroyObjectHandle (result);
                    result = NULL;
                }
            }

            if (result != longResult) {
                IsmDestroyObjectHandle (result);
                result = longResult;
            }

            FreePathString (buffer);
        }
    }

    FreePathString (sanitizedPath);

    return result;
}

MIG_OBJECTSTRINGHANDLE
pTryHandle (
    IN      PCTSTR FullPath,
    IN      PCTSTR Hint,
    IN      BOOL Recursive,
    OUT     PBOOL HintUsed      OPTIONAL
    )
{
    PATH_ENUM pathEnum;
    PCTSTR newPath;
    MIG_OBJECTSTRINGHANDLE result = NULL;

    if (HintUsed) {
        *HintUsed = FALSE;
    }

    if (!(*FullPath)) {
        // nothing to do, not even the hint can help us
        return NULL;
    }

    result = pSimpleTryHandle (FullPath, Recursive);
    if (result || (!Hint)) {
        return result;
    }
    if (EnumFirstPathEx (&pathEnum, Hint, NULL, NULL, FALSE)) {
        do {
            newPath = JoinPaths (pathEnum.PtrCurrPath, FullPath);
            result = pSimpleTryHandle (newPath, Recursive);
            if (result) {
                AbortPathEnum (&pathEnum);
                FreePathString (newPath);
                if (HintUsed) {
                    *HintUsed = TRUE;
                }
                return result;
            }
            FreePathString (newPath);
        } while (EnumNextPath (&pathEnum));
    }
    AbortPathEnum (&pathEnum);
    return NULL;
}

BOOL
pOurFindFile (
    IN      PCTSTR FileName
    )
{
    DWORD attribs;
    PCTSTR buffer;
    PTSTR leafPtr, leaf;
    PTSTR workingPath;
    PCTSTR sanitizedPath;
    MIG_OBJECTSTRINGHANDLE test = NULL;
    BOOL result = FALSE;

    sanitizedPath = SanitizePath (FileName);

    if (sanitizedPath == NULL) {
        return FALSE;
    }

    if (IsmGetRealPlatform () == PLATFORM_SOURCE) {
        attribs = GetFileAttributes (sanitizedPath);
    } else {
        attribs = INVALID_ATTRIBUTES;
    }

    if (attribs != INVALID_ATTRIBUTES) {

        result = TRUE;

    } else {

        test = IsmCreateObjectHandle (sanitizedPath, NULL);

        if (IsmGetObjectIdFromName (g_FileType, test, TRUE)) {
            result = TRUE;
        }

        IsmDestroyObjectHandle (test);
        test = NULL;

        if (!result) {

            buffer = DuplicatePathString (sanitizedPath, 0);

            leaf = _tcsrchr (buffer, TEXT('\\'));

            if (leaf) {
                leafPtr = leaf;
                leaf = _tcsinc (leaf);
                *leafPtr = 0;
                test = IsmCreateObjectHandle (buffer, leaf);
            }

            if (test) {
                if (IsmGetObjectIdFromName (g_FileType, test, TRUE)) {
                    result = TRUE;
                }
                IsmDestroyObjectHandle (test);
                test = NULL;
            }

            FreePathString (buffer);
        }
    }

    FreePathString (sanitizedPath);

    return result;
}

BOOL
pOurSearchPath (
    IN      PCTSTR FileName,
    IN      DWORD BufferLength,
    OUT     PTSTR Buffer
    )
{
    TCHAR pathEnv[] = TEXT("%system%;%system16%;%windir%;%path%");
    PCTSTR pathExp = NULL;
    PCTSTR fileName = NULL;
    PATH_ENUM pathEnum;
    BOOL result = FALSE;

    pathExp = IsmExpandEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    pathEnv,
                    NULL
                    );
    if (pathExp) {
        if (EnumFirstPathEx (&pathEnum, pathExp, NULL, NULL, FALSE)) {
            do {
                fileName = JoinPaths (pathEnum.PtrCurrPath, FileName);
                result = pOurFindFile (fileName);
                if (result) {
                    StringCopyTcharCount (Buffer, fileName, BufferLength);
                    FreePathString (fileName);
                    AbortPathEnum (&pathEnum);
                    break;
                }
                FreePathString (fileName);
            } while (EnumNextPath (&pathEnum));
        }

        IsmReleaseMemory (pathExp);
        pathExp = NULL;
    }
    return result;
}

PCTSTR
pGetObjectNameForDebug (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    static TCHAR debugBuffer[2048];
    PCTSTR node, leaf;

    IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf);

    if (node && leaf) {
        wsprintf (debugBuffer, TEXT("[Node:%s Leaf:%s]"), node, leaf);
    } else if (node) {
        wsprintf (debugBuffer, TEXT("[Node:%s]"), node);
    } else if (leaf) {
        wsprintf (debugBuffer, TEXT("[Leaf:%s]"), leaf);
    } else {
        StringCopy (debugBuffer, TEXT("[nul]"));
    }

    return debugBuffer;
}

VOID
pSaveObjectAndFileItReferences (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PACTION_STRUCT RegActionStruct,
    IN      BOOL VcmMode,
    IN      BOOL Recursive
    )
{
    MIG_CONTENT content;
    GROWBUFFER cmdLineBuffer = INIT_GROWBUFFER;
    PCMDLINE cmdLine;
    PTSTR pathData;
    PCTSTR p;
    PCTSTR end;
    PCTSTR expandPath = NULL;
    PCTSTR expandHint = NULL;
    UINT u;
    BOOL foundFile = FALSE;
    PDWORD valueType;
    MIG_OBJECTSTRINGHANDLE handle;
    MIG_OBJECTSTRINGHANDLE nodeHandle;
    BOOL parsable;
    BOOL firstPass = TRUE;
    ACTION_STRUCT actionStruct;
    DWORD actionFlags;
    BOOL hintUsed = FALSE;
    MIG_BLOB blob;
    PCTSTR node, leaf, filePattern;

    //
    // Obtain the object data
    //

    if (IsmAcquireObjectEx (ObjectTypeId, ObjectName, &content, CONTENTTYPE_MEMORY, 4096)) {

        //
        // Parse the data for a file
        //

        pathData = (PTSTR) content.MemoryContent.ContentBytes;

        parsable = FALSE;

        if ((ObjectTypeId & (~PLATFORM_MASK)) == g_RegType) {
            valueType = (PDWORD)(content.Details.DetailsData);

            if (valueType) {
                if (*valueType == REG_EXPAND_SZ ||
                    *valueType == REG_SZ
                    ) {

                    parsable = TRUE;
                }
            } else {
                MYASSERT (IsmIsObjectHandleNodeOnly (ObjectName));
            }
        }

        if ((ObjectTypeId & (~PLATFORM_MASK)) == g_IniType) {
            parsable = TRUE;
        }

        if (parsable) {

            p = pathData;
            end = (PCTSTR) (content.MemoryContent.ContentBytes + content.MemoryContent.ContentSize);

            while (p < end) {
                if (*p == 0) {
                    break;
                }

                p = _tcsinc (p);
            }

            if (p >= end) {
                pathData = NULL;
            }

        } else {
            pathData = NULL;
        }


        if (pathData) {
            //
            // Expand the data
            //

            expandPath = IsmExpandEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                pathData,
                NULL
                );
            pathData = (PTSTR)expandPath;

            if (RegActionStruct && RegActionStruct->ObjectHint) {
                expandHint = IsmExpandEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    RegActionStruct->ObjectHint,
                    NULL
                    );
            }

            // first we try it as is
            handle = pTryHandle (pathData, expandHint, Recursive, &hintUsed);

            if (handle) {

                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                actionStruct.ObjectBase = handle;
                actionFlags = ACTION_PERSIST;

                if (RegActionStruct) {
                    actionStruct.ObjectDest = RegActionStruct->AddnlDest;
                }

                if (Recursive) {
                    // let's build the base handle but not from pathData,
                    // because we might have used the hint field. Let's just
                    // build it from the handle itself
                    if (IsmCreateObjectStringsFromHandle (handle, &node, &leaf)) {
                        filePattern = JoinPathsInPoolEx ((NULL, node, leaf, NULL));
                        if (filePattern) {
                            nodeHandle = TurnFileStringIntoHandle (
                                            filePattern,
                                            PFF_COMPUTE_BASE|
                                                PFF_NO_SUBDIR_PATTERN|
                                                PFF_NO_LEAF_AT_ALL
                                            );
                            if (nodeHandle) {
                                AddRule (
                                    g_FileType,
                                    nodeHandle,
                                    handle,
                                    ACTIONGROUP_INCFOLDER,
                                    actionFlags,
                                    &actionStruct
                                    );
                                IsmQueueEnumeration (
                                    g_FileType,
                                    nodeHandle,
                                    VcmMode ? GatherVirtualComputer : PrepareActions,
                                    0,
                                    NULL
                                    );
                                IsmQueueEnumeration (
                                    g_FileType,
                                    handle,
                                    VcmMode ? GatherVirtualComputer : PrepareActions,
                                    0,
                                    NULL
                                    );
                                IsmDestroyObjectHandle (nodeHandle);
                            } else {
                                // Out of memory?
                                LOG ((LOG_ERROR, (PCSTR)MSG_UNEXPECTED_ERROR));
                            }
                            FreePathString (filePattern);
                        } else {
                            // Out of memory?
                            LOG ((LOG_ERROR, (PCSTR)MSG_UNEXPECTED_ERROR));
                        }
                    } else {
                        // Out of memory?
                        LOG ((LOG_ERROR, (PCSTR)MSG_UNEXPECTED_ERROR));
                    }
                } else {
                    AddRule (
                        g_FileType,
                        handle,
                        handle,
                        ACTIONGROUP_INCFILE,
                        actionFlags,
                        &actionStruct
                        );
                    IsmQueueEnumeration (
                        g_FileType,
                        handle,
                        VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                }

                foundFile = TRUE;

                IsmDestroyObjectHandle (handle);

                if (hintUsed && expandHint) {
                    // we need to add extra data for the content fix operation
                    blob.Type = BLOBTYPE_STRING;
                    blob.String = expandHint;
                    if ((ObjectTypeId & (~PLATFORM_MASK)) == g_RegType) {
                        IsmSetOperationOnObject (
                            ObjectTypeId,
                            ObjectName,
                            g_RegAutoFilterOp,
                            NULL,
                            &blob
                            );
                    }
                    if ((ObjectTypeId & (~PLATFORM_MASK)) == g_IniType) {
                        IsmSetOperationOnObject (
                            ObjectTypeId,
                            ObjectName,
                            g_IniAutoFilterOp,
                            NULL,
                            &blob
                            );
                    }
                }

            } else {

                cmdLine = ParseCmdLineEx (pathData, NULL, pOurFindFile, pOurSearchPath, &cmdLineBuffer);

                if (cmdLine) {

                    //
                    // Find the file referenced in the list or command line
                    //
                    for (u = 0 ; u < cmdLine->ArgCount ; u++) {

                        p = cmdLine->Args[u].CleanedUpArg;

                        // first we try it as is
                        handle = pTryHandle (p, expandHint, Recursive, &hintUsed);

                        if (handle) {

                            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                            actionStruct.ObjectBase = handle;
                            actionFlags = ACTION_PERSIST;

                            if (RegActionStruct) {
                                actionStruct.ObjectDest = RegActionStruct->AddnlDest;
                            }

                            AddRule (
                                g_FileType,
                                handle,
                                handle,
                                ACTIONGROUP_INCFILE,
                                actionFlags,
                                &actionStruct
                                );

                            IsmQueueEnumeration (
                                g_FileType,
                                handle,
                                VcmMode ? GatherVirtualComputer : PrepareActions,
                                0,
                                NULL
                                );

                            foundFile = TRUE;

                            IsmDestroyObjectHandle (handle);

                            if (hintUsed && expandHint) {
                                // we need to add extra data for the content fix operation
                                blob.Type = BLOBTYPE_STRING;
                                blob.String = expandHint;
                                if ((ObjectTypeId & (~PLATFORM_MASK)) == g_RegType) {
                                    IsmSetOperationOnObject (
                                        ObjectTypeId,
                                        ObjectName,
                                        g_RegAutoFilterOp,
                                        NULL,
                                        &blob
                                        );
                                }
                                if ((ObjectTypeId & (~PLATFORM_MASK)) == g_IniType) {
                                    IsmSetOperationOnObject (
                                        ObjectTypeId,
                                        ObjectName,
                                        g_IniAutoFilterOp,
                                        NULL,
                                        &blob
                                        );
                                }
                            }

                        } else {

                            // maybe we have something like /m:c:\foo.txt
                            // we need to go forward until we find a sequence of
                            // <alpha>:\<something>
                            if (p[0] && p[1]) {

                                while (p[2]) {

                                    if (_istalpha ((CHARTYPE) _tcsnextc (p)) &&
                                        p[1] == TEXT(':') &&
                                        p[2] == TEXT('\\')
                                        ) {

                                        handle = pTryHandle (p, expandHint, Recursive, &hintUsed);

                                        if (handle) {

                                            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                                            actionStruct.ObjectBase = handle;
                                            actionFlags = ACTION_PERSIST;
                                            if (RegActionStruct) {
                                                actionStruct.ObjectDest = RegActionStruct->AddnlDest;
                                            }
                                            AddRule (
                                                g_FileType,
                                                handle,
                                                handle,
                                                ACTIONGROUP_INCFILE,
                                                actionFlags,
                                                &actionStruct
                                                );
                                            IsmQueueEnumeration (
                                                g_FileType,
                                                handle,
                                                VcmMode ? GatherVirtualComputer : PrepareActions,
                                                0,
                                                NULL
                                                );
                                            foundFile = TRUE;

                                            IsmDestroyObjectHandle (handle);

                                            if (hintUsed && expandHint) {
                                                // we need to add extra data for the content fix operation
                                                blob.Type = BLOBTYPE_STRING;
                                                blob.String = expandHint;
                                                if ((ObjectTypeId & (~PLATFORM_MASK)) == g_RegType) {
                                                    IsmSetOperationOnObject (
                                                        ObjectTypeId,
                                                        ObjectName,
                                                        g_RegAutoFilterOp,
                                                        NULL,
                                                        &blob
                                                        );
                                                }
                                                if ((ObjectTypeId & (~PLATFORM_MASK)) == g_IniType) {
                                                    IsmSetOperationOnObject (
                                                        ObjectTypeId,
                                                        ObjectName,
                                                        g_IniAutoFilterOp,
                                                        NULL,
                                                        &blob
                                                        );
                                                }
                                            }

                                            break;
                                        }
                                    }
                                    p ++;
                                }
                            }
                        }
                    }
                }
            }
        }

        //
        // We persist the registry object at all times
        //
        if (VcmMode) {
            IsmMakePersistentObject (ObjectTypeId, ObjectName);
        } else {
            IsmMakeApplyObject (ObjectTypeId, ObjectName);
        }
        if (!foundFile && !expandHint && pathData && _tcschr (pathData, TEXT('.')) && !_tcschr (pathData, TEXT('\\'))) {
            // we assume that the value is a file name by itself
            // If we are in VcmMode we are going to persist this
            // key and all files that have the name equal with
            // the value of this key
            if (VcmMode && pathData) {
                handle = IsmCreateSimpleObjectPattern (NULL, FALSE, pathData, FALSE);
                AddRule (
                    g_FileType,
                    handle,
                    handle,
                    ACTIONGROUP_INCFILE,
                    ACTION_PERSIST,
                    NULL
                    );

                DEBUGMSG ((
                    DBG_SCRIPT,
                    "RegFile %s triggered enumeration of entire file system because of %s",
                    pGetObjectNameForDebug (ObjectName),
                    pathData
                    ));

                QueueAllFiles (VcmMode);
                IsmHookEnumeration (
                    g_FileType,
                    handle,
                    GatherVirtualComputer,
                    0,
                    NULL
                    );
                IsmDestroyObjectHandle (handle);
            }
        }
        IsmReleaseObject (&content);

        if (expandPath) {
           IsmReleaseMemory (expandPath);
           expandPath = NULL;
        }
        if (expandHint) {
           IsmReleaseMemory (expandHint);
           expandHint = NULL;
        }
    }
    GbFree (&cmdLineBuffer);
}

VOID
pSaveObjectAndIconItReferences (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PACTION_STRUCT RegActionStruct,
    IN      BOOL VcmMode
    )
{
    MIG_CONTENT content;
    GROWBUFFER cmdLineBuffer = INIT_GROWBUFFER;
    PCMDLINE cmdLine;
    PTSTR pathData;
    BOOL parsable;
    PDWORD valueType;
    PCTSTR p;
    PCTSTR end;
    PCTSTR expandPath = NULL;
    PCTSTR expandHint = NULL;
    MIG_OBJECTSTRINGHANDLE handle;
    BOOL foundFile = FALSE;
    INT iconNumber = 0;
    PICON_GROUP iconGroup = NULL;
    ICON_SGROUP iconSGroup;
    PCTSTR iconResId = NULL;
    MIG_CONTENT iconContent;
    MIG_BLOB migBlob;

    //
    // Obtain the object data
    //

    if (IsmAcquireObjectEx (ObjectTypeId, ObjectName, &content, CONTENTTYPE_MEMORY, 4096)) {

        //
        // Parse the data for a file
        //

        pathData = (PTSTR) content.MemoryContent.ContentBytes;

        parsable = FALSE;

        if ((ObjectTypeId & (~PLATFORM_MASK)) == g_RegType) {
            valueType = (PDWORD)(content.Details.DetailsData);

            if (valueType) {
                if (*valueType == REG_EXPAND_SZ ||
                    *valueType == REG_SZ
                    ) {

                    parsable = TRUE;
                }
            } else {
                MYASSERT (IsmIsObjectHandleNodeOnly (ObjectName));
            }
        }

        if ((ObjectTypeId & (~PLATFORM_MASK)) == g_IniType) {
            parsable = TRUE;
        }

        if (parsable) {

            p = pathData;
            end = (PCTSTR) (content.MemoryContent.ContentBytes + content.MemoryContent.ContentSize);

            while (p < end) {
                if (*p == 0) {
                    break;
                }

                p = _tcsinc (p);
            }

            if (p >= end) {
                pathData = NULL;
            }

        } else {
            pathData = NULL;
        }


        if (pathData) {
            //
            // Expand the data
            //
            expandPath = IsmExpandEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                pathData,
                NULL
                );
            pathData = (PTSTR)expandPath;

            if (RegActionStruct && RegActionStruct->ObjectHint) {
                expandHint = IsmExpandEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    RegActionStruct->ObjectHint,
                    NULL
                    );
            }

            cmdLine = ParseCmdLineEx (pathData, TEXT(","), pOurFindFile, pOurSearchPath, &cmdLineBuffer);

            if (cmdLine) {
                // we only expect two args, the icon file name and the icon number
                if (cmdLine->ArgCount <= 2) {

                    p = cmdLine->Args[0].CleanedUpArg;

                    handle = pTryHandle (p, expandHint, FALSE, NULL);

                    if (handle) {

                        if (VcmMode) {
                            // we are just going to persist the object so we can look at it later
                            IsmMakePersistentObject (g_FileType, handle);
                        } else {
                            iconNumber = 0;
                            if (cmdLine->ArgCount == 2) {
                                // get the icon number
                                iconNumber = _ttoi (cmdLine->Args[1].CleanedUpArg);
                            }

                            // now acquire the object and extract the icon
                            if (IsmAcquireObjectEx (
                                    MIG_FILE_TYPE,
                                    handle,
                                    &iconContent,
                                    CONTENTTYPE_FILE,
                                    0
                                    )) {
                                if (iconNumber >= 0) {
                                    iconGroup = IcoExtractIconGroupByIndexFromFile (
                                                    iconContent.FileContent.ContentPath,
                                                    iconNumber,
                                                    NULL
                                                    );
                                } else {
                                    iconResId = (PCTSTR) (LONG_PTR) (-iconNumber);
                                    iconGroup = IcoExtractIconGroupFromFile (
                                                    iconContent.FileContent.ContentPath,
                                                    iconResId,
                                                    NULL
                                                    );
                                }
                                if (iconGroup) {
                                    if (IcoSerializeIconGroup (iconGroup, &iconSGroup)) {
                                        // save the icon data as a property
                                        migBlob.Type = BLOBTYPE_BINARY;
                                        migBlob.BinaryData = (PCBYTE)(iconSGroup.Data);
                                        migBlob.BinarySize = iconSGroup.DataSize;
                                        IsmAddPropertyToObject (ObjectTypeId, ObjectName, g_DefaultIconData, &migBlob);
                                        IcoReleaseIconSGroup (&iconSGroup);

                                        // now add the appropriate operation
                                        IsmSetOperationOnObject (
                                            ObjectTypeId,
                                            ObjectName,
                                            g_DefaultIconOp,
                                            NULL,
                                            NULL
                                            );

                                        foundFile = TRUE;
                                    }
                                    IcoReleaseIconGroup (iconGroup);
                                }
                                IsmReleaseObject (&iconContent);
                            }
                        }

                        IsmDestroyObjectHandle (handle);
                    }
                }
            }
            GbFree (&cmdLineBuffer);

            if (expandPath) {
                IsmReleaseMemory (expandPath);
                expandPath = NULL;
            }
            if (expandHint) {
                IsmReleaseMemory (expandHint);
                expandHint = NULL;
            }
        }

        //
        // We persist the registry object at all times
        //
        if (VcmMode) {
            IsmMakePersistentObject (ObjectTypeId, ObjectName);
        } else {
            if (foundFile) {
                IsmMakeApplyObject (ObjectTypeId, ObjectName);
            }
        }
        IsmReleaseObject (&content);
    }
}

UINT
GatherVirtualComputer (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    BOOL match;
    PCTSTR encodedNodeOnly;
    ACTION_STRUCT actionStruct;
    MIG_OBJECTID objectId = 0;

    //
    // Obtain the best rule for this object
    //

    match = QueryRule (
                Data->ObjectTypeId,
                Data->ObjectName,
                Data->ObjectNode,
                &actionGroup,
                &actionFlags,
                &actionStruct
                );

    if (!match && !Data->ObjectLeaf) {
        //
        // If this is a node only, try matching with an empty leaf
        //

        encodedNodeOnly = IsmCreateObjectHandle (Data->ObjectNode, TEXT(""));
        match = QueryRule (
                    Data->ObjectTypeId,
                    encodedNodeOnly,
                    Data->ObjectNode,
                    &actionGroup,
                    &actionFlags,
                    &actionStruct
                    );

        IsmDestroyObjectHandle (encodedNodeOnly);
    }

    if (match) {
        //
        // Mark all objects necessary for the rule to be processed.  We
        // will do the rule's action(s) on the right side.
        //

        if ((actionGroup == ACTIONGROUP_INCLUDE) ||
            (actionGroup == ACTIONGROUP_INCLUDEEX) ||
            (actionGroup == ACTIONGROUP_RENAME) ||
            (actionGroup == ACTIONGROUP_RENAMEEX) ||
            (actionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
            (actionGroup == ACTIONGROUP_INCLUDERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANT) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_INCFILE) ||
            (actionGroup == ACTIONGROUP_INCFILEEX) ||
            (actionGroup == ACTIONGROUP_INCFOLDER) ||
            (actionGroup == ACTIONGROUP_INCFOLDEREX) ||
            (actionGroup == ACTIONGROUP_INCICON) ||
            (actionGroup == ACTIONGROUP_INCICONEX)
            ) {

            objectId = IsmGetObjectIdFromName (Data->ObjectTypeId, Data->ObjectName, FALSE);

            if (objectId) {

                if (actionFlags & ACTION_PERSIST) {
                    if (!IsmIsAttributeSetOnObjectId (objectId, g_OsFileAttribute)) {
                        IsmMakePersistentObjectId (objectId);
                    }
                }

                if ((actionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
                    (actionGroup == ACTIONGROUP_RENAMERELEVANT)
                    ) {
                    IsmSetAttributeOnObjectId (objectId, g_CopyIfRelevantAttr);
                }

                if (actionFlags & ACTION_PERSIST_PATH_IN_DATA) {
                    pSaveObjectAndFileItReferences (Data->ObjectTypeId, Data->ObjectName, &actionStruct, TRUE, actionGroup == ACTIONGROUP_INCFOLDER);
                }
                if (actionFlags & ACTION_PERSIST_ICON_IN_DATA) {
                    pSaveObjectAndIconItReferences (Data->ObjectTypeId, Data->ObjectName, &actionStruct, TRUE);
                }
            }
        }
    }

    return CALLBACK_ENUM_CONTINUE;
}


MIG_DATAHANDLE
pGetDataHandleForSrc (
    IN      PCTSTR RenameSrc
    )
{
    MIG_DATAHANDLE dataHandle;
    MIG_BLOB blob;

    //
    // First check hash table to see if we have an ID
    //

    if (!HtFindStringEx (g_RenameSrcTable, RenameSrc, &dataHandle, FALSE)) {
        blob.Type = BLOBTYPE_STRING;
        blob.String = RenameSrc;
        dataHandle = IsmRegisterOperationData (&blob);

        HtAddStringEx (g_RenameSrcTable, RenameSrc, &dataHandle, FALSE);
    }

    return dataHandle;
}


MIG_DATAHANDLE
pGetDataHandleForDest (
    IN      PCTSTR RenameDest
    )
{
    MIG_DATAHANDLE dataHandle;
    MIG_BLOB blob;

    //
    // First check hash table to see if we have an ID
    //

    if (!HtFindStringEx (g_RenameDestTable, RenameDest, &dataHandle, FALSE)) {
        blob.Type = BLOBTYPE_STRING;
        blob.String = RenameDest;
        dataHandle = IsmRegisterOperationData (&blob);

        HtAddStringEx (g_RenameDestTable, RenameDest, &dataHandle, FALSE);
    }

    return dataHandle;
}


UINT
PrepareActions (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    BOOL match;
    PCTSTR encodedNodeOnly;
    MIG_DATAHANDLE srcDataHandle;
    MIG_DATAHANDLE destDataHandle;
    ACTION_STRUCT actionStruct;
    MIG_OBJECTID objectId = 0;

    //
    // Obtain the best rule for this object
    //

    match = QueryRule (
                Data->ObjectTypeId,
                Data->ObjectName,
                Data->ObjectNode,
                &actionGroup,
                &actionFlags,
                &actionStruct
                );

    if (!match && !Data->ObjectLeaf) {
        //
        // If this is a node only, try matching with an empty leaf
        //

        encodedNodeOnly = IsmCreateObjectHandle (Data->ObjectNode, TEXT(""));
        match = QueryRule (
                    Data->ObjectTypeId,
                    encodedNodeOnly,
                    Data->ObjectNode,
                    &actionGroup,
                    &actionFlags,
                    &actionStruct
                    );

        IsmDestroyObjectHandle (encodedNodeOnly);
    }

    if (match) {
        //
        // Mark the objects for the designated operations.
        //

        if ((actionGroup == ACTIONGROUP_INCLUDE) ||
            (actionGroup == ACTIONGROUP_INCLUDEEX) ||
            (actionGroup == ACTIONGROUP_RENAME) ||
            (actionGroup == ACTIONGROUP_RENAMEEX) ||
            (actionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
            (actionGroup == ACTIONGROUP_INCLUDERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANT) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_INCFILE) ||
            (actionGroup == ACTIONGROUP_INCFILEEX) ||
            (actionGroup == ACTIONGROUP_INCFOLDER) ||
            (actionGroup == ACTIONGROUP_INCFOLDEREX) ||
            (actionGroup == ACTIONGROUP_INCICON) ||
            (actionGroup == ACTIONGROUP_INCICONEX)
            ) {

            objectId = IsmGetObjectIdFromName (Data->ObjectTypeId, Data->ObjectName, FALSE);

            if (objectId) {

                if (actionFlags & ACTION_PERSIST) {
                    if (!IsmIsAttributeSetOnObjectId (objectId, g_OsFileAttribute)) {
                        IsmMakeApplyObjectId (objectId);
                    }
                }

                if ((actionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
                    (actionGroup == ACTIONGROUP_RENAMERELEVANT)
                    ) {
                    IsmSetAttributeOnObjectId (objectId, g_CopyIfRelevantAttr);
                }

                if (actionFlags & ACTION_PERSIST_PATH_IN_DATA) {
                    pSaveObjectAndFileItReferences (Data->ObjectTypeId, Data->ObjectName, &actionStruct, FALSE, actionGroup == ACTIONGROUP_INCFOLDER);
                }
                if (actionFlags & ACTION_PERSIST_ICON_IN_DATA) {
                    pSaveObjectAndIconItReferences (Data->ObjectTypeId, Data->ObjectName, &actionStruct, FALSE);
                }
            }
        }
        if ((actionGroup == ACTIONGROUP_RENAME) ||
            (actionGroup == ACTIONGROUP_RENAMEEX) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANT) ||
            (actionGroup == ACTIONGROUP_RENAMERELEVANTEX) ||
            (actionGroup == ACTIONGROUP_INCFILE) ||
            (actionGroup == ACTIONGROUP_INCFILEEX) ||
            (actionGroup == ACTIONGROUP_INCFOLDER) ||
            (actionGroup == ACTIONGROUP_INCFOLDEREX) ||
            (actionGroup == ACTIONGROUP_INCICON) ||
            (actionGroup == ACTIONGROUP_INCICONEX)
            ) {
            if (actionStruct.ObjectDest) {

                if (actionStruct.ObjectBase) {
                    srcDataHandle = pGetDataHandleForSrc (actionStruct.ObjectBase);
                } else {
                    srcDataHandle = 0;
                }

                destDataHandle = pGetDataHandleForDest (actionStruct.ObjectDest);

                if (!objectId) {
                    objectId = IsmGetObjectIdFromName (Data->ObjectTypeId, Data->ObjectName, FALSE);
                }

                if (objectId) {

                    if ((Data->ObjectTypeId & (~PLATFORM_MASK)) == g_FileType) {
                        if ((actionGroup == ACTIONGROUP_RENAMERELEVANTEX) ||
                            (actionGroup == ACTIONGROUP_RENAMEEX)
                            ) {
                            IsmSetOperationOnObjectId2 (
                                objectId,
                                g_RenameFileExOp,
                                srcDataHandle,
                                destDataHandle
                                );
                        } else {
                            IsmSetOperationOnObjectId2 (
                                objectId,
                                g_RenameFileOp,
                                srcDataHandle,
                                destDataHandle
                                );
                        }
                    } else {
                        if ((Data->ObjectTypeId & (~PLATFORM_MASK)) == g_IniType) {
                            IsmSetOperationOnObjectId2 (
                                objectId,
                                (actionGroup == ACTIONGROUP_RENAMEEX ? g_RenameIniExOp : g_RenameIniOp),
                                srcDataHandle,
                                destDataHandle
                                );
                        } else {
                            if ((actionGroup == ACTIONGROUP_INCFILEEX) ||
                                (actionGroup == ACTIONGROUP_INCFOLDEREX) ||
                                (actionGroup == ACTIONGROUP_INCICONEX) ||
                                (actionGroup == ACTIONGROUP_RENAMEEX)
                                ) {
                                IsmSetOperationOnObjectId2 (
                                    objectId,
                                    g_RenameExOp,
                                    srcDataHandle,
                                    destDataHandle
                                    );
                            } else {
                                IsmSetOperationOnObjectId2 (
                                    objectId,
                                    g_RenameOp,
                                    srcDataHandle,
                                    destDataHandle
                                    );
                            }
                        }
                    }
                }
            }
        }
    }

    return CALLBACK_ENUM_CONTINUE;
}


UINT
NulCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    return CALLBACK_ENUM_CONTINUE;
}


UINT
ObjectPriority (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    BOOL match;

    match = QueryRuleEx (
                Data->ObjectTypeId,
                Data->ObjectName,
                Data->ObjectNode,
                &actionGroup,
                &actionFlags,
                NULL,
                RULEGROUP_PRIORITY
                );

    if (match) {
        MYASSERT ((actionFlags == ACTION_PRIORITYSRC) || (actionFlags == ACTION_PRIORITYDEST));
        if (actionFlags == ACTION_PRIORITYSRC) {
            IsmClearAbandonObjectOnCollision (
                (Data->ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_SOURCE,
                Data->ObjectName
                );
            IsmAbandonObjectOnCollision (
                (Data->ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_DESTINATION,
                Data->ObjectName
                );
        } else {
            IsmAbandonObjectOnCollision (
                (Data->ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_SOURCE,
                Data->ObjectName
                );
            IsmClearAbandonObjectOnCollision (
                (Data->ObjectTypeId & (~PLATFORM_MASK)) | PLATFORM_DESTINATION,
                Data->ObjectName
                );
        }
    }
    return CALLBACK_ENUM_CONTINUE;
}

UINT
FileCollPattern (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    ACTION_STRUCT actionStruct;
    BOOL match;
    MIG_BLOB migBlob;

    match = QueryRuleEx (
                Data->ObjectTypeId,
                Data->ObjectName,
                Data->ObjectNode,
                &actionGroup,
                &actionFlags,
                &actionStruct,
                RULEGROUP_COLLPATTERN
                );

    if (match && (!(IsmIsObjectHandleNodeOnly (Data->ObjectName)))) {
        // Let's set a property on this file (we don't need this for nodes)
        migBlob.Type = BLOBTYPE_STRING;
        migBlob.String = actionStruct.ObjectHint;
        IsmAddPropertyToObject (Data->ObjectTypeId, Data->ObjectName, g_FileCollPatternData, &migBlob);
    }
    return CALLBACK_ENUM_CONTINUE;
}

UINT
LockPartition (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    IsmSetAttributeOnObject (Data->ObjectTypeId, Data->ObjectName, g_LockPartitionAttr);

    return CALLBACK_ENUM_CONTINUE;
}

UINT
ExcludeKeyIfValueExists (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PCTSTR srcNode = NULL;
    PCTSTR srcLeaf = NULL;

    // This function is only called for each registry key/value pair that
    // indicates we want to cause the exclusion of the entire key.

    IsmCreateObjectStringsFromHandle (Data->ObjectName, &srcNode, &srcLeaf);

    // This is also called for all keys (not including a value) so we need
    // to make sure a value is passed in

    if (srcLeaf && *srcLeaf) {
        // Exclude the srcNode
        HtAddString (g_DePersistTable, srcNode);
    }
    IsmDestroyObjectString (srcNode);
    IsmDestroyObjectString (srcLeaf);

    return CALLBACK_ENUM_CONTINUE;
}

BOOL
PostDelregKeyCallback (
    VOID
    )
{
    static BOOL called = FALSE;

    HASHTABLE_ENUM hashData;
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE pattern;

    if (called) {
        return TRUE;
    }

    // Enumerate all Excluded keys
    if (EnumFirstHashTableString (&hashData, g_DePersistTable)) {
        do {
            // Remove Persistence on the key
            pattern = IsmCreateObjectHandle (hashData.String, NULL);
            IsmClearPersistenceOnObject (g_RegType, pattern);
            IsmDestroyObjectHandle (pattern);

            // Enumerate each value in this key
            pattern = IsmCreateSimpleObjectPattern (hashData.String, TRUE, NULL, TRUE);
            if (IsmEnumFirstSourceObject (&objectEnum, g_RegType, pattern)) {
                do {
                    // Remove Persistence on each value
                    IsmClearPersistenceOnObject (objectEnum.ObjectTypeId, objectEnum.ObjectName);
                } while (IsmEnumNextObject (&objectEnum));
            }
            IsmDestroyObjectHandle (pattern);

        } while (EnumNextHashTableString (&hashData));
    }

    HtFree (g_DePersistTable);
    g_DePersistTable = NULL;

    called = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\sources.inc ===
!include ..\..\modules.mk

MINORCOMP=script

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\entry.c          \
    ..\v1.c             \
    ..\sgminit.c        \
    ..\sgmqueue.c       \
    ..\sgmcallback.c    \
    ..\sgmutil.c        \
    ..\script.rc        \
    ..\dgm.c            \
    ..\csm.c            \
    ..\opm.c            \
    ..\regconv.c        \
    ..\restore.c        \
    ..\rules.c          \
    ..\parse.c          \
    ..\app.c            \
    ..\attrib.c         \
    ..\etm.c            \
    ..\logmsg.mc        \
    ..\renregfn.c       \
    ..\oeutils.c        \
    ..\cert.c           \

DLLENTRY=_DllMainCRTStartup
LINKER_FLAGS=$(LINKER_FLAGS) -SWAPRUN:CD -SWAPRUN:NET
SUBSYSTEM_VERSION=4.00

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\memdb.lib        \
            $(COBRA_ROOT)\lib\$(O)\reg.lib          \
            $(COBRA_ROOT)\lib\$(O)\inf.lib          \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \
            $(COBRA_ROOT)\lib\$(O)\file.lib         \
            $(COBRA_ROOT)\lib\$(O)\icons.lib        \
            $(COBRA_ROOT)\lib\$(O)\modimage.lib     \
            $(COBRA_ROOT)\lib\$(O)\version.lib      \
            $(SDK_LIB_PATH)\rpcrt4.lib              \
            $(SDK_LIB_PATH)\shlwapi.lib             \

PRECOMPILED_INCLUDE=pch.h

DLLDEF=..\script.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\v1.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    v1.c

Abstract:

    Implements a module to meet the functionality of the version 1
    state save/apply tool.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_OPERATIONID g_DefaultIconOp;
MIG_PROPERTYID g_DefaultIconData;
MIG_PROPERTYID g_FileCollPatternData;
MIG_OPERATIONID g_RegAutoFilterOp;
MIG_OPERATIONID g_IniAutoFilterOp;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

EXPORT
BOOL
WINAPI
ModuleInitialize (
    VOID
    )
{
    UtInitialize (NULL);
    RegInitialize ();           // for user profile code
    FileEnumInitialize ();
    InfGlobalInit (FALSE);
    InitAppModule ();
    CertificatesInitialize ();
    return TRUE;
}

EXPORT
VOID
WINAPI
ModuleTerminate (
    VOID
    )
{
    if (g_RevEnvMap) {
        DestroyStringMapping (g_RevEnvMap);
    }
    if (g_EnvMap) {
        DestroyStringMapping (g_EnvMap);
    }
    if (g_UndefMap) {
        DestroyStringMapping (g_UndefMap);
    }
    if (g_V1Pool) {
        PmDestroyPool (g_V1Pool);
    }

    CertificatesTerminate ();
    TerminateAppModule ();

    InfGlobalInit (TRUE);
    FileEnumTerminate ();
    RegTerminate ();

    // UtTerminate must be last
    UtTerminate ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\sgmutil.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sgmutil.c

Abstract:

    Implements basic utilities used for source data gathering.

Author:

    Jim Schmidt (jimschm) 14-May-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_FOO     "Foo"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

#define USER_SHELL_FOLDERS                                       \
    DEFMAC(CSIDL_APPDATA, TEXT("AppData"), TEXT("CSIDL_APPDATA"))                       \
    DEFMAC(CSIDL_APPDATA, TEXT("AppData"), TEXT("APPDATA"))                             \
    DEFMAC(CSIDL_ADMINTOOLS, TEXT("Administrative Tools"), TEXT("CSIDL_ADMINTOOLS"))    \
    DEFMAC(CSIDL_ALTSTARTUP, TEXT("AltStartup"), TEXT("CSIDL_ALTSTARTUP"))              \
    DEFMAC(CSIDL_BITBUCKET, TEXT("RecycleBinFolder"), TEXT("CSIDL_BITBUCKET"))          \
    DEFMAC(CSIDL_CONTROLS, TEXT("ControlPanelFolder"), TEXT("CSIDL_CONTROLS"))          \
    DEFMAC(CSIDL_COOKIES, TEXT("Cookies"), TEXT("CSIDL_COOKIES"))                       \
    DEFMAC(CSIDL_DESKTOP, TEXT("Desktop"), TEXT("CSIDL_DESKTOP"))                       \
    DEFMAC(CSIDL_DESKTOPDIRECTORY, TEXT("Desktop"), TEXT("CSIDL_DESKTOPDIRECTORY"))     \
    DEFMAC(CSIDL_DRIVES, TEXT("DriveFolder"), TEXT("CSIDL_DRIVES"))                     \
    DEFMAC(CSIDL_FAVORITES, TEXT("Favorites"), TEXT("CSIDL_FAVORITES"))                 \
    DEFMAC(CSIDL_FONTS, TEXT("Fonts"), TEXT("CSIDL_FONTS"))                             \
    DEFMAC(CSIDL_HISTORY, TEXT("History"), TEXT("CSIDL_HISTORY"))                       \
    DEFMAC(CSIDL_INTERNET, TEXT("InternetFolder"), TEXT("CSIDL_INTERNET"))              \
    DEFMAC(CSIDL_INTERNET_CACHE, TEXT("Cache"), TEXT("CSIDL_INTERNET_CACHE"))           \
    DEFMAC(CSIDL_LOCAL_APPDATA, TEXT("Local AppData"), TEXT("CSIDL_LOCAL_APPDATA"))     \
    DEFMAC(CSIDL_MYPICTURES, TEXT("My Pictures"), TEXT("CSIDL_MYPICTURES"))             \
    DEFMAC(CSIDL_NETHOOD, TEXT("NetHood"), TEXT("CSIDL_NETHOOD"))                       \
    DEFMAC(CSIDL_NETWORK, TEXT("NetworkFolder"), TEXT("CSIDL_NETWORK"))                 \
    DEFMAC(CSIDL_PERSONAL, TEXT("Personal"), TEXT("CSIDL_PERSONAL"))                    \
    DEFMAC(CSIDL_PROFILE, TEXT("Profile"), TEXT("CSIDL_PROFILE"))                       \
    DEFMAC(CSIDL_PROGRAM_FILES, TEXT("ProgramFiles"), TEXT("CSIDL_PROGRAM_FILES"))      \
    DEFMAC(CSIDL_PROGRAM_FILES, TEXT("ProgramFiles"), TEXT("PROGRAMFILES"))             \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMON, TEXT("CommonProgramFiles"), TEXT("CSIDL_PROGRAM_FILES_COMMON"))  \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMON, TEXT("CommonProgramFiles"), TEXT("COMMONPROGRAMFILES"))  \
    DEFMAC(CSIDL_PROGRAMS, TEXT("Programs"), TEXT("CSIDL_PROGRAMS"))                    \
    DEFMAC(CSIDL_RECENT, TEXT("Recent"), TEXT("CSIDL_RECENT"))                          \
    DEFMAC(CSIDL_SENDTO, TEXT("SendTo"), TEXT("CSIDL_SENDTO"))                          \
    DEFMAC(CSIDL_STARTMENU, TEXT("Start Menu"), TEXT("CSIDL_STARTMENU"))                \
    DEFMAC(CSIDL_STARTUP, TEXT("Startup"), TEXT("CSIDL_STARTUP"))                       \
    DEFMAC(CSIDL_SYSTEM, TEXT("System"), TEXT("CSIDL_SYSTEM"))                          \
    DEFMAC(CSIDL_TEMPLATES, TEXT("Templates"), TEXT("CSIDL_TEMPLATES"))                 \
    DEFMAC(CSIDL_WINDOWS, TEXT("Windows"), TEXT("CSIDL_WINDOWS"))                       \
    DEFMAC(CSIDL_MYDOCUMENTS, TEXT("My Documents"), TEXT("CSIDL_MYDOCUMENTS"))          \
    DEFMAC(CSIDL_MYMUSIC, TEXT("My Music"), TEXT("CSIDL_MYMUSIC"))                      \
    DEFMAC(CSIDL_MYVIDEO, TEXT("My Video"), TEXT("CSIDL_MYVIDEO"))                      \
    DEFMAC(CSIDL_SYSTEMX86, TEXT("SystemX86"), TEXT("CSIDL_SYSTEMX86"))                 \
    DEFMAC(CSIDL_PROGRAM_FILESX86, TEXT("ProgramFilesX86"), TEXT("CSIDL_PROGRAM_FILESX86"))             \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMONX86, TEXT("CommonProgramFilesX86"), TEXT("CSIDL_PROGRAM_FILES_COMMONX86")) \
    DEFMAC(CSIDL_CONNECTIONS, TEXT("ConnectionsFolder"), TEXT("CSIDL_CONNECTIONS"))     \

#define COMMON_SHELL_FOLDERS    \
    DEFMAC(CSIDL_COMMON_ADMINTOOLS, TEXT("Common Administrative Tools"), TEXT("CSIDL_COMMON_ADMINTOOLS"))   \
    DEFMAC(CSIDL_COMMON_ALTSTARTUP, TEXT("Common AltStartup"), TEXT("CSIDL_COMMON_ALTSTARTUP"))             \
    DEFMAC(CSIDL_COMMON_APPDATA, TEXT("Common AppData"), TEXT("CSIDL_COMMON_APPDATA"))                      \
    DEFMAC(CSIDL_COMMON_DESKTOPDIRECTORY, TEXT("Common Desktop"), TEXT("CSIDL_COMMON_DESKTOPDIRECTORY"))    \
    DEFMAC(CSIDL_COMMON_DOCUMENTS, TEXT("Common Documents"), TEXT("CSIDL_COMMON_DOCUMENTS"))                \
    DEFMAC(CSIDL_COMMON_FAVORITES, TEXT("Common Favorites"), TEXT("CSIDL_COMMON_FAVORITES"))                \
    DEFMAC(CSIDL_COMMON_PROGRAMS, TEXT("Common Programs"), TEXT("CSIDL_COMMON_PROGRAMS"))                   \
    DEFMAC(CSIDL_COMMON_STARTMENU, TEXT("Common Start Menu"), TEXT("CSIDL_COMMON_STARTMENU"))               \
    DEFMAC(CSIDL_COMMON_STARTUP, TEXT("Common Startup"), TEXT("CSIDL_COMMON_STARTUP"))                      \
    DEFMAC(CSIDL_COMMON_TEMPLATES, TEXT("Common Templates"), TEXT("CSIDL_COMMON_TEMPLATES"))                \

#define ENVIRONMENT_VARIABLES                           \
    DEFMAC(TEXT("WINDIR"))                              \
    DEFMAC(TEXT("SYSTEMROOT"))                          \
    DEFMAC(TEXT("SYSTEM16"))                            \
    DEFMAC(TEXT("SYSTEM32"))                            \
    DEFMAC(TEXT("SYSTEM"))                              \
    DEFMAC(TEXT("ALLUSERSPROFILE"))                     \
    DEFMAC(TEXT("USERPROFILE"))                         \
    DEFMAC(TEXT("PROFILESFOLDER"))                      \
    DEFMAC(TEXT("APPDATA"))                             \
    DEFMAC(TEXT("CSIDL_APPDATA"))                       \
    DEFMAC(TEXT("CSIDL_ADMINTOOLS"))                    \
    DEFMAC(TEXT("CSIDL_ALTSTARTUP"))                    \
    DEFMAC(TEXT("CSIDL_BITBUCKET"))                     \
    DEFMAC(TEXT("CSIDL_COMMON_ADMINTOOLS"))             \
    DEFMAC(TEXT("CSIDL_COMMON_ALTSTARTUP"))             \
    DEFMAC(TEXT("CSIDL_COMMON_APPDATA"))                \
    DEFMAC(TEXT("CSIDL_COMMON_DESKTOPDIRECTORY"))       \
    DEFMAC(TEXT("CSIDL_COMMON_DOCUMENTS"))              \
    DEFMAC(TEXT("CSIDL_COMMON_FAVORITES"))              \
    DEFMAC(TEXT("CSIDL_COMMON_PROGRAMS"))               \
    DEFMAC(TEXT("CSIDL_COMMON_STARTMENU"))              \
    DEFMAC(TEXT("CSIDL_COMMON_STARTUP"))                \
    DEFMAC(TEXT("CSIDL_COMMON_TEMPLATES"))              \
    DEFMAC(TEXT("CSIDL_CONTROLS"))                      \
    DEFMAC(TEXT("CSIDL_COOKIES"))                       \
    DEFMAC(TEXT("CSIDL_DESKTOP"))                       \
    DEFMAC(TEXT("CSIDL_DESKTOPDIRECTORY"))              \
    DEFMAC(TEXT("CSIDL_DRIVES"))                        \
    DEFMAC(TEXT("CSIDL_FAVORITES"))                     \
    DEFMAC(TEXT("CSIDL_FONTS"))                         \
    DEFMAC(TEXT("CSIDL_HISTORY"))                       \
    DEFMAC(TEXT("CSIDL_INTERNET"))                      \
    DEFMAC(TEXT("CSIDL_INTERNET_CACHE"))                \
    DEFMAC(TEXT("CSIDL_LOCAL_APPDATA"))                 \
    DEFMAC(TEXT("CSIDL_MYPICTURES"))                    \
    DEFMAC(TEXT("CSIDL_NETHOOD"))                       \
    DEFMAC(TEXT("CSIDL_NETWORK"))                       \
    DEFMAC(TEXT("CSIDL_PERSONAL"))                      \
    DEFMAC(TEXT("CSIDL_PRINTERS"))                      \
    DEFMAC(TEXT("CSIDL_PRINTHOOD"))                     \
    DEFMAC(TEXT("CSIDL_PROFILE"))                       \
    DEFMAC(TEXT("CSIDL_PROGRAM_FILES"))                 \
    DEFMAC(TEXT("ProgramFiles"))                        \
    DEFMAC(TEXT("CSIDL_PROGRAM_FILES_COMMON"))          \
    DEFMAC(TEXT("CommonProgramFiles"))                  \
    DEFMAC(TEXT("CSIDL_PROGRAMS"))                      \
    DEFMAC(TEXT("CSIDL_RECENT"))                        \
    DEFMAC(TEXT("CSIDL_SENDTO"))                        \
    DEFMAC(TEXT("CSIDL_STARTMENU"))                     \
    DEFMAC(TEXT("CSIDL_STARTUP"))                       \
    DEFMAC(TEXT("CSIDL_SYSTEM"))                        \
    DEFMAC(TEXT("CSIDL_TEMPLATES"))                     \
    DEFMAC(TEXT("CSIDL_WINDOWS"))                       \
    DEFMAC(TEXT("CSIDL_MYDOCUMENTS"))                   \
    DEFMAC(TEXT("CSIDL_MYMUSIC"))                       \
    DEFMAC(TEXT("CSIDL_MYVIDEO"))                       \
    DEFMAC(TEXT("CSIDL_SYSTEMX86"))                     \
    DEFMAC(TEXT("CSIDL_PROGRAM_FILESX86"))              \
    DEFMAC(TEXT("CSIDL_PROGRAM_FILES_COMMONX86"))       \
    DEFMAC(TEXT("CSIDL_CONNECTIONS"))                   \
    DEFMAC(TEXT("TEMP"))                                \
    DEFMAC(TEXT("TMP"))                                 \

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

/*++

  The shell folder functions here are duplicates of the RAS code. This is not
  a good solution (we have two copies of the same code), but the designed
  solution requires engine scope support. Scopes are the mechanism in which
  major groups of data are separated from each other, such as the separation
  of multiple users. A scope provides properties that affect objects within
  the scope. For example, a user scope has properties such as domain name,
  profile path, sid, and so on.

  In order not to duplicate this code but still maintain modularity and system
  independence, a scope module is needed for users. So instead of the code
  below, the code would be something like

  property = IsmGetScopeProperty ("userprofile");

  This will be implemented if we want to (A) support multiple scopes, (B)
  eliminate physical system access in non-type modules, or (C) clean up this
  duplicated code.

--*/

typedef HRESULT (WINAPI SHGETFOLDERPATH)(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, PTSTR pszPath);
typedef SHGETFOLDERPATH * PSHGETFOLDERPATH;

HANDLE
pGetShFolderLib (
    VOID
    )
{
    static HANDLE lib;

    if (lib) {
        return lib;
    }

    lib = LoadLibrary (TEXT("shfolder.dll"));
    if (!lib) {
        LOG ((LOG_ERROR, (PCSTR) MSG_SHFOLDER_LOAD_ERROR));
    }

    return lib;
}

PTSTR
pFindSfPath (
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder
    )
{
    HKEY key;
    REGSAM prevMode;
    PCTSTR data;
    PCTSTR result = NULL;

    if (!result) {
        if (UserFolder) {
            prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
            key = OpenRegKeyStr (TEXT("HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"));
            SetRegOpenAccessMode (prevMode);
        } else {
            prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
            key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"));
            SetRegOpenAccessMode (prevMode);
        }

        if (key) {
            data = GetRegValueString (key, FolderStr);

            if (data) {
                result = DuplicatePathString (data, 0);
                FreeAlloc (data);
            }
            CloseRegKey (key);
        }
    }

    if (!result) {
        if (UserFolder) {
            prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
            key = OpenRegKeyStr (TEXT("HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"));
            SetRegOpenAccessMode (prevMode);
        } else {
            prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
            key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"));
            SetRegOpenAccessMode (prevMode);
        }

        if (key) {
            data = GetRegValueString (key, FolderStr);

            if (data) {
                result = DuplicatePathString (data, 0);
                FreeAlloc (data);
            }
            CloseRegKey (key);
        }
    }

    return (PTSTR) result;
}

PCTSTR
GetShellFolderPath (
    IN      INT Folder,
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder,
    OUT     PTSTR Buffer
    )
{
    HRESULT result;
    LPITEMIDLIST pidl = NULL;
    BOOL b = FALSE;
    LPMALLOC mallocFn = NULL;
    HANDLE lib;
    PSHGETFOLDERPATH shGetFolderPath = NULL;
    PCTSTR sfPath = NULL;
    PCTSTR expandedPath = NULL;
    PTSTR endPtr = NULL;
    TCHAR currUserProfile[MAX_TCHAR_PATH];
    MIG_USERDATA userData;

    result = SHGetMalloc (&mallocFn);
    if (result != S_OK) {
        return NULL;
    }

    if (FolderStr) {

        //
        // First try to find this in Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
        //
        sfPath = pFindSfPath (FolderStr, UserFolder);

        if (sfPath && *sfPath) {
            //
            // We found it.
            //
            StringCopyTcharCount (Buffer, sfPath, MAX_PATH);
            expandedPath = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, sfPath, NULL);
            FreePathString (sfPath);
            sfPath = NULL;
            if (expandedPath && *expandedPath) {
                StringCopyTcharCount (Buffer, expandedPath, MAX_PATH);
            }
            if (expandedPath) {
                IsmReleaseMemory (expandedPath);
            }

            if (IsmGetMappedUserData (&userData)) {
                // we have a mapped user, try to build it's default shell folder location
                GetUserProfileRootPath (currUserProfile);

                if (StringIMatch (currUserProfile, Buffer)) {
                    StringCopyTcharCount (Buffer, userData.UserProfileRoot, MAX_PATH);
                } else {
                    AppendWack (currUserProfile);

                    if (StringIMatchTcharCount (currUserProfile, Buffer, TcharCount (currUserProfile))) {

                        endPtr = Buffer + TcharCount (currUserProfile);
                        sfPath = JoinPaths (userData.UserProfileRoot, endPtr);
                        StringCopyTcharCount (Buffer, sfPath, MAX_PATH);
                        FreePathString (sfPath);
                    }
                }
            }

            return Buffer;
        }

        if (sfPath) {
            FreePathString (sfPath);
        }

        // we didn't find it yet, let's try shfolder.dll

        lib = pGetShFolderLib ();

        if (lib) {
#ifdef UNICODE
            (FARPROC) shGetFolderPath = GetProcAddress (lib, "SHGetFolderPathW");
#else
            (FARPROC) shGetFolderPath = GetProcAddress (lib, "SHGetFolderPathA");
#endif
            if (shGetFolderPath) {
                result = shGetFolderPath (NULL, Folder, NULL, 1, Buffer);
                if (result == S_OK) {
                    expandedPath = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, Buffer, NULL);
                    if (expandedPath && *expandedPath) {
                        StringCopyTcharCount (Buffer, expandedPath, MAX_PATH);
                    }
                    if (expandedPath) {
                        IsmReleaseMemory (expandedPath);
                        expandedPath = NULL;
                    }

                    if (IsmGetMappedUserData (&userData)) {
                        // we have a mapped user, try to build it's default shell folder location
                        GetUserProfileRootPath (currUserProfile);

                        if (StringIMatch (currUserProfile, Buffer)) {
                            StringCopyTcharCount (Buffer, userData.UserProfileRoot, MAX_PATH);
                        } else {
                            AppendWack (currUserProfile);

                            if (StringIMatchTcharCount (currUserProfile, Buffer, TcharCount (currUserProfile))) {

                                endPtr = Buffer + TcharCount (currUserProfile);
                                sfPath = JoinPaths (userData.UserProfileRoot, endPtr);
                                StringCopyTcharCount (Buffer, sfPath, MAX_PATH);
                                FreePathString (sfPath);
                            }
                        }

                        return Buffer;

                    } else {
                        // no mapped user, use the current user's path
                        result = shGetFolderPath (NULL, Folder, NULL, 0, Buffer);
                        if (result != S_OK) {
                            // no current path, use default one
                            result = shGetFolderPath (NULL, Folder, NULL, 1, Buffer);
                        }
                    }

                    if (result == S_OK) {
                        expandedPath = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, Buffer, NULL);
                        if (expandedPath && *expandedPath) {
                            StringCopyTcharCount (Buffer, expandedPath, MAX_PATH);
                        }
                        if (expandedPath) {
                            IsmReleaseMemory (expandedPath);
                            expandedPath = NULL;
                        }
                        return Buffer;
                    }
                }
            } else {
                result = SHGetSpecialFolderLocation (NULL, Folder, &pidl);
            }
        } else {
            result = SHGetSpecialFolderLocation (NULL, Folder, &pidl);
        }

        if (result == S_OK) {
            b = SHGetPathFromIDList (pidl, Buffer);
        } else {
            b = FALSE;
        }
    } else {

        result = SHGetSpecialFolderLocation (NULL, Folder, &pidl);

        if (result == S_OK) {
            b = SHGetPathFromIDList (pidl, Buffer);
        } else {
            b = FALSE;
        }
    }

    IMalloc_Free (mallocFn, pidl);

    if (!b && (Folder == CSIDL_PROGRAM_FILES)) {
        PCTSTR defProgramFiles = NULL;
        PTSTR buffPtr = NULL;

        // Special case for %ProgramFiles%.
        // This is a very important CSIDL, and some legacy OS's
        // like some NT4 don't detect it properly. We are going
        // to build it from %windir%
        if (GetWindowsDirectory (Buffer, MAX_PATH)) {
            // find the first wack
            buffPtr = _tcschr (Buffer, TEXT('\\'));
            if (buffPtr) {
                buffPtr = _tcsinc (buffPtr);
                if (buffPtr) {
                    defProgramFiles = GetStringResource (PROGRAM_FILES_PATH);
                    if (defProgramFiles) {
                        StringCopyTcharCount (buffPtr, defProgramFiles, MAX_PATH - 3);
                        FreeStringResource (defProgramFiles);
                        b = TRUE;
                    }
                }
            }
        }
    }

    if (!b && (Folder == CSIDL_PROGRAM_FILES_COMMON)) {
        PCTSTR defProgramFiles = NULL;
        PTSTR buffPtr = NULL;

        // Special case for %ProgramFiles%.
        // This is a very important CSIDL, and some legacy OS's
        // like some NT4 don't detect it properly. We are going
        // to build it from %windir%
        if (GetWindowsDirectory (Buffer, MAX_PATH)) {
            // find the first wack
            buffPtr = _tcschr (Buffer, TEXT('\\'));
            if (buffPtr) {
                buffPtr = _tcsinc (buffPtr);
                if (buffPtr) {
                    defProgramFiles = GetStringResource (PROGRAM_FILES_COMMON_PATH);
                    if (defProgramFiles) {
                        StringCopyTcharCount (buffPtr, defProgramFiles, MAX_PATH - 3);
                        FreeStringResource (defProgramFiles);
                        b = TRUE;
                    }
                }
            }
        }
    }

    return b ? Buffer : NULL;
}


PCTSTR
GetAllUsersProfilePath (
    OUT     PTSTR Buffer
    )
{
    HKEY key;
    REGSAM prevMode;
    PCTSTR data;
    PCTSTR expData;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
    key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"));
    SetRegOpenAccessMode (prevMode);

    if (key) {

        data = GetRegValueString (key, TEXT("ProfilesDirectory"));

        if (data) {
            expData = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, data, NULL);
            StringCopyByteCount (Buffer, expData, MAX_PATH);
            IsmReleaseMemory (expData);
            FreeAlloc (data);
        } else {
            GetWindowsDirectory (Buffer, MAX_PATH);
            StringCopy (AppendWack (Buffer), TEXT("Profiles"));
        }

        data = GetRegValueString (key, TEXT("AllUsersProfile"));

        if (data) {
            StringCopy (AppendWack (Buffer), data);
            FreeAlloc (data);
        } else {
            StringCopy (AppendWack (Buffer), TEXT("All Users"));
        }

        CloseRegKey (key);
        return Buffer;
    }

    GetWindowsDirectory (Buffer, MAX_PATH);
    return Buffer;
}

PCTSTR
GetProfilesFolderPath (
    OUT     PTSTR Buffer
    )
{
    HKEY key;
    REGSAM prevMode;
    PCTSTR data;
    PCTSTR expData;

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
    key = OpenRegKeyStr (TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"));
    SetRegOpenAccessMode (prevMode);

    if (key) {

        data = GetRegValueString (key, TEXT("ProfilesDirectory"));

        if (data) {
            expData = IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, data, NULL);
            StringCopyByteCount (Buffer, expData, MAX_PATH);
            IsmReleaseMemory (expData);
            FreeAlloc (data);
        } else {
            GetWindowsDirectory (Buffer, MAX_PATH);
            StringCopy (AppendWack (Buffer), TEXT("Profiles"));
        }

        CloseRegKey (key);
        return Buffer;
    }

    GetWindowsDirectory (Buffer, MAX_PATH);
    return Buffer;
}

PCTSTR
GetUserProfileRootPath (
    OUT     PTSTR Buffer
    )
{
    HKEY key;
    REGSAM prevMode;
    PDWORD data;
    DWORD size;

    //
    // For Win2k and higher, use the shell
    //

    if (GetShellFolderPath (CSIDL_PROFILE, NULL, FALSE, Buffer)) {
        return Buffer;
    }

    //
    // For NT 4, use the environment
    //

    if (GetEnvironmentVariable (TEXT("USERPROFILE"), Buffer, MAX_PATH)) {
        return Buffer;
    }

    //
    // For Win9x, are profiles enabled?  If so, return %windir%\profiles\%user%.
    // If not, return %windir%.
    //

    GetWindowsDirectory (Buffer, MAX_PATH);

    prevMode = SetRegOpenAccessMode (KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS);
    key = OpenRegKeyStr (TEXT("HKLM\\Network\\Logon"));
    SetRegOpenAccessMode (prevMode);
    if (key) {

        data = GetRegValueDword (key, TEXT("UserProfiles"));

        if (data && *data) {
            StringCat (Buffer, TEXT("\\Profiles\\"));

            size = MAX_PATH;
            GetUserName (GetEndOfString (Buffer), &size);

            FreeAlloc (data);
        }

        CloseRegKey (key);
    }

    return Buffer;
}


VOID
pSetEnvironmentVar (
    IN      PMAPSTRUCT Map,
    IN      PMAPSTRUCT UndefMap,            OPTIONAL
    IN      BOOL MapSourceToDest,
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableData             OPTIONAL
    )
{
    PTSTR encodedVariableName;
    TCHAR buffer[MAX_TCHAR_PATH];
    PCTSTR undefText;

    //
    // VariableData is NULL when VariableName is not present on the machine
    //

    if (MapSourceToDest) {

        //
        // MapSourceToDest tells us to map a source path (c:\windows) to
        // a destination path (d:\winnt).
        //

        if (VariableData) {
            if (IsmGetEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    VariableName,
                    buffer,
                    ARRAYSIZE(buffer),
                    NULL
                    )) {
                AddStringMappingPair (Map, buffer, VariableData);
            }
        }

        return;
    }

    //
    // MapSourceToDest is FALSE when we want to map environment variables
    // to the actual path.
    //

    encodedVariableName = AllocPathString (TcharCount (VariableName) + 3);
    if (encodedVariableName) {
        wsprintf (encodedVariableName, TEXT("%%%s%%"), VariableName);

        if (VariableData) {

            IsmSetEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, VariableName, VariableData);
            if (Map) {
                AddStringMappingPair (Map, encodedVariableName, VariableData);
            }

        } else if (UndefMap) {

            //
            // If no variable data, then put environment variable in the
            // "undefined" variable mapping
            //

            undefText = JoinTextEx (NULL, TEXT("--> "), TEXT(" <--"), encodedVariableName, 0, NULL);
            AddStringMappingPair (UndefMap, encodedVariableName, undefText);
            FreeText (undefText);
        }
        FreePathString (encodedVariableName);
    }
}


VOID
AddRemappingEnvVar (
    IN      PMAPSTRUCT Map,
    IN      PMAPSTRUCT ReMap,
    IN      PMAPSTRUCT UndefMap,            OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableData
    )
{
    pSetEnvironmentVar (Map, UndefMap, FALSE, VariableName, VariableData);
    pSetEnvironmentVar (ReMap, UndefMap, TRUE, VariableName, VariableData);
}


VOID
SetIsmEnvironmentFromPhysicalMachine (
    IN      PMAPSTRUCT Map,
    IN      BOOL MapSourceToDest,
    IN      PMAPSTRUCT UndefMap             OPTIONAL
    )
{
    TCHAR dir[MAX_TCHAR_PATH];
    PCTSTR path;
    PTSTR p;
    MIG_USERDATA userData;
    BOOL mappedUser = FALSE;

    mappedUser = IsmGetMappedUserData (&userData);

    //
    // Prepare ISM environment variables. The ones added last have the highest priority when
    // two or more variables map to the same path.
    //

    //
    // ...user profile
    //

    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("ALLUSERSPROFILE"), GetAllUsersProfilePath (dir));

    if (mappedUser) {
        pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("USERPROFILE"), userData.UserProfileRoot);
        p = _tcschr (userData.UserProfileRoot, TEXT('\\'));
        if (p) {
            pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("HOMEPATH"), p);
        }
    } else {
        GetUserProfileRootPath (dir);
        pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("USERPROFILE"), dir);
        p = _tcschr (dir, TEXT('\\'));
        if (p) {
            pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("HOMEPATH"), p);
        }
    }

    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("PROFILESFOLDER"), GetProfilesFolderPath (dir));

    //
    // ...temp dir
    //

    if (GetTempPath (MAX_PATH, dir)) {
        p = (PTSTR) FindLastWack (dir);
        if (p) {
            if (p[1] == 0) {
                *p = 0;
            }

            pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("TEMP"), dir);
            pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("TMP"), dir);
        }
    }

    //
    // ...windows directory env variable
    //

    GetWindowsDirectory (dir, ARRAYSIZE(dir));
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("WINDIR"), dir);
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("SYSTEMROOT"), dir);

    //
    // ...16-bit system directory. We invent SYSTEM16 and SYSTEM32 for use
    //    in scripts.
    //

    path = JoinPaths (dir, TEXT("system"));
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("SYSTEM16"), path);
    FreePathString (path);

    path = JoinPaths (dir, TEXT("system32"));
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("SYSTEM32"), path);
    FreePathString (path);

    //
    // ...platform-specific system directory
    //

    GetSystemDirectory (dir, ARRAYSIZE(dir));
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, TEXT("SYSTEM"), dir);

    //
    // ...shell folders -- we invent all variables with the CSIDL_ prefix
    //

#define DEFMAC(id,folder_str,var_name)              \
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, var_name, \
                        GetShellFolderPath (id, folder_str, TRUE, dir));

    USER_SHELL_FOLDERS

#undef DEFMAC


#define DEFMAC(id,folder_str,var_name)                  \
    pSetEnvironmentVar (Map, UndefMap, MapSourceToDest, var_name, \
                        GetShellFolderPath (id, folder_str, FALSE, dir));

    COMMON_SHELL_FOLDERS

#undef DEFMAC
}

VOID
pTransferEnvPath (
    IN      PCTSTR IsmVariableName,
    IN      PMAPSTRUCT DirectMap,
    IN      PMAPSTRUCT ReverseMap,
    IN      PMAPSTRUCT UndefMap
    )
{
    TCHAR dir[MAX_TCHAR_PATH];
    PTSTR encodedVariableName;
    PCTSTR undefText;

    encodedVariableName = AllocPathString (TcharCount (IsmVariableName) + 3);
    if (encodedVariableName) {
        wsprintf (encodedVariableName, TEXT("%%%s%%"), IsmVariableName);

        if (IsmGetEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, IsmVariableName, dir, sizeof(dir)/sizeof((dir)[0]), NULL)) {
            if (DirectMap) {
                AddStringMappingPair (DirectMap, encodedVariableName, dir);
            }
            if (ReverseMap) {
                AddStringMappingPair (ReverseMap, dir, encodedVariableName);
            }
        } else {
            undefText = JoinTextEx (NULL, TEXT("--> "), TEXT(" <--"), encodedVariableName, 0, NULL);
            if (UndefMap) {
                AddStringMappingPair (UndefMap, encodedVariableName, undefText);
            }
            FreeText (undefText);
        }
        FreePathString (encodedVariableName);
    }
}

VOID
SetIsmEnvironmentFromVirtualMachine (
    IN      PMAPSTRUCT DirectMap,
    IN      PMAPSTRUCT ReverseMap,
    IN      PMAPSTRUCT UndefMap
    )
{
    //
    // Need to transfer ISM environment into our string mapping
    //

#define DEFMAC(name)        pTransferEnvPath(name, DirectMap, ReverseMap, UndefMap);

    ENVIRONMENT_VARIABLES

#undef DEFMAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\sgmqueue.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sgmqueue.c

Abstract:

    Parses the v1 script, builds rules and queues enumeration callbacks.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v2app.h"
#include "v1p.h"

#define DBG_SCRIPT  "Script"

//
// Strings
//

// None

//
// Constants
//

// none

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

MIG_OPERATIONID g_RenameFileExOp;
MIG_OPERATIONID g_RenameFileOp;
MIG_OPERATIONID g_RenameExOp;
MIG_OPERATIONID g_RenameOp;
MIG_OPERATIONID g_RenameIniExOp;
MIG_OPERATIONID g_RenameIniOp;
BOOL g_VcmMode;
BOOL g_PreParse;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VCMPARSE ScriptVcmParse;
VCMQUEUEENUMERATION ScriptVcmQueueEnumeration;
SGMPARSE ScriptSgmParse;
SGMQUEUEENUMERATION ScriptSgmQueueEnumeration;

BOOL
pSelectFilesAndFolders (
    VOID
    );

BOOL
pParseAllInfs (
    IN      BOOL PreParse
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pCommonQueueEnumeration (
    IN      BOOL PreParse
    )
{
    MIG_OBJECTSTRINGHANDLE objectHandle;
    ACTION_STRUCT actionStruct;
    BOOL b = FALSE;

    //
    // INF-based inclusion/exclusion mechanism.  We are called first to pre-parse
    // the INF (to allow the UI to alter the results).  Then we are called to
    // queue the enumeration.
    //

    if (PreParse) {
        g_RenameFileExOp = IsmRegisterOperation (S_OPERATION_V1_FILEMOVEEX, TRUE);
        g_RenameFileOp = IsmRegisterOperation (S_OPERATION_V1_FILEMOVE, TRUE);
        g_RenameOp = IsmRegisterOperation (S_OPERATION_MOVE, FALSE);
        g_RenameIniOp = IsmRegisterOperation (S_OPERATION_INIMOVE, FALSE);
        g_DefaultIconOp = IsmRegisterOperation (S_OPERATION_DEFICON_FIXCONTENT, FALSE);
        g_DefaultIconData = IsmRegisterProperty (S_V1PROP_ICONDATA, FALSE);
        g_FileCollPatternData = IsmRegisterProperty (S_V1PROP_FILECOLLPATTERN, FALSE);
        g_RenameExOp = IsmRegisterOperation (S_OPERATION_ENHANCED_MOVE, FALSE);
        g_RenameIniExOp = IsmRegisterOperation (S_OPERATION_ENHANCED_INIMOVE, FALSE);
        g_RegAutoFilterOp = IsmRegisterOperation (S_OPERATION_REG_AUTO_FILTER, FALSE);
        g_IniAutoFilterOp = IsmRegisterOperation (S_OPERATION_INI_AUTO_FILTER, FALSE);

        return pParseAllInfs (TRUE);
    }

    //
    // Now queue enumeration
    //

    MYASSERT (g_RenameFileExOp);
    MYASSERT (g_RenameFileOp);
    MYASSERT (g_RenameOp);
    MYASSERT (g_RenameIniOp);
    MYASSERT (g_RegAutoFilterOp);
    MYASSERT (g_IniAutoFilterOp);

    //
    // From the sgm point of view, the v1 tool supports the following:
    //
    // - Optional transfer of the entire HKCU
    // - Optional transfer of the entire HKLM
    // - Optional transfer of all files except for OS files
    // - INF-based inclusion/exclusion mechanism
    // - Specialized migration of certain settings (RAS, printers)
    //
    // This SGM implements this functionality set.
    //

    __try {

        //
        // Component-based inclusion mechanism
        //

        if (!pSelectFilesAndFolders ()) {
            __leave;
        }

        //
        // INF-based inclusion/exclusion mechanism
        //

        if (!pParseAllInfs (FALSE)) {
            __leave;
        }

        //
        // If the /u was specified at the command line we want to suck and apply all HKR
        // like if we had a rule in the script: AddReg=HKR\*
        //
        if (IsmIsEnvironmentFlagSet (IsmGetRealPlatform(), NULL, S_ENV_HKCU_V1)) {

            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));

            objectHandle = TurnRegStringIntoHandle (TEXT("HKCU\\*"), TRUE, NULL);
            MYASSERT (objectHandle);

            actionStruct.ObjectBase = TurnRegStringIntoHandle (TEXT("HKCU\\*"), FALSE, NULL);
            MYASSERT (actionStruct.ObjectBase);

            //
            // Add this rule
            //

            if (AddRule (
                    g_RegType,
                    actionStruct.ObjectBase,
                    objectHandle,
                    ACTIONGROUP_INCLUDE,
                    ACTION_PERSIST,
                    &actionStruct
                    )) {

                AddRuleEx (
                    g_RegType,
                    actionStruct.ObjectBase,
                    objectHandle,
                    ACTIONGROUP_DEFAULTPRIORITY,
                    ACTION_PRIORITYDEST,
                    NULL,
                    RULEGROUP_PRIORITY
                    );

                IsmHookEnumeration (
                    g_RegType,
                    objectHandle,
                    ObjectPriority,
                    0,
                    NULL
                    );

                //
                // Queue enumeration for include patterns
                //

                IsmQueueEnumeration (
                    g_RegType,
                    objectHandle,
                    g_VcmMode ? GatherVirtualComputer : PrepareActions,
                    0,
                    NULL
                    );
            }
            IsmDestroyObjectHandle (objectHandle);
        }

        b = TRUE;

    }
    __finally {
    }

    return b;
}


VOID
QueueAllFiles (
    IN      BOOL VcmMode
    )
{
    static BOOL done = FALSE;
    DRIVE_ENUM driveEnum;
    PTSTR fixedDrives = NULL;
    DWORD sizeNeeded;
    PATH_ENUM pathEnum;
    MIG_OBJECTSTRINGHANDLE objectHandle;
    MIG_SEGMENTS nodeSeg[2];

    if (done) {
        return;
    }

    done = TRUE;

    if (VcmMode) {
        // Let's get all the fixed drives and put them into an
        // environment variable called "FIXED_DRIVES"
        if (EnumFirstDrive (&driveEnum, DRIVEENUM_FIXED)) {
            do {
                if (fixedDrives != NULL) {
                    fixedDrives = JoinTextEx (NULL, fixedDrives, driveEnum.DriveName, TEXT(";"), 0, NULL);
                } else {
                    fixedDrives = DuplicateText (driveEnum.DriveName);
                }
            } while (EnumNextDrive (&driveEnum));
        }
        MYASSERT (fixedDrives);
        if (fixedDrives) {
            IsmSetEnvironmentString (PLATFORM_SOURCE, NULL, S_FIXED_DRIVES, fixedDrives);
        }
    } else {
        // Let's get the fixed drives from the source machine
        if (IsmGetEnvironmentString (
                PLATFORM_SOURCE,
                NULL,
                S_FIXED_DRIVES,
                NULL,
                0,
                &sizeNeeded
                )) {

            fixedDrives = AllocText (sizeNeeded);
            if (fixedDrives) {

                IsmGetEnvironmentString (
                    PLATFORM_SOURCE,
                    NULL,
                    S_FIXED_DRIVES,
                    fixedDrives,
                    sizeNeeded,
                    NULL
                    );
            }
        }
    }

    if (fixedDrives) {
        // now enumerate the fixed drives and add queue an
        // enumeration for each of them.
        if (EnumFirstPathEx (&pathEnum, fixedDrives, NULL, NULL, FALSE)) {
            do {
                nodeSeg[0].Segment = JoinPaths (pathEnum.PtrCurrPath, TEXT("*"));
                nodeSeg[0].IsPattern = TRUE ;

                objectHandle = IsmCreateObjectPattern (nodeSeg, 1, ALL_PATTERN, 0);

                IsmQueueEnumeration (g_FileType, objectHandle, NulCallback, 0, NULL);
                IsmDestroyObjectHandle (objectHandle);
                FreePathString (nodeSeg[0].Segment);
            } while (EnumNextPath (&pathEnum));
        }
        AbortPathEnum (&pathEnum);
    }
}


VOID
pQueueAllReg (
    VOID
    )
{
    static BOOL done = FALSE;
    MIG_OBJECTSTRINGHANDLE objectHandle;
    MIG_SEGMENTS nodeSeg[2];
    MIG_PLATFORMTYPEID platform = IsmGetRealPlatform();

    if (done) {
        return;
    }

    done = TRUE;

    //
    // Optional transfer of entire HKCU
    //

    if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_HKCU_ON)) {

        nodeSeg[0].Segment = TEXT("HKCU\\");
        nodeSeg[0].IsPattern = FALSE;

        nodeSeg[1].Segment = TEXT("*");
        nodeSeg[1].IsPattern = TRUE;

        objectHandle = IsmCreateObjectPattern (nodeSeg, 2, ALL_PATTERN, 0);
        IsmQueueEnumeration (g_RegType, objectHandle, NulCallback, 0, NULL);
        IsmDestroyObjectHandle (objectHandle);
    }

    //
    // Optional transfer of entire HKLM
    //

    if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_HKLM_ON)) {

        nodeSeg[0].Segment = TEXT("HKLM\\");
        nodeSeg[0].IsPattern = FALSE;

        nodeSeg[1].Segment = TEXT("*");
        nodeSeg[1].IsPattern = TRUE;

        objectHandle = IsmCreateObjectPattern (nodeSeg, 2, ALL_PATTERN, 0);
        IsmQueueEnumeration (g_RegType, objectHandle, NulCallback, 0, NULL);
        IsmDestroyObjectHandle (objectHandle);
    }

}


BOOL
WINAPI
ScriptSgmParse (
    IN      PVOID Reserved
    )
{
    return pCommonQueueEnumeration (TRUE);
}


BOOL
WINAPI
ScriptSgmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    BOOL result;

    result = pCommonQueueEnumeration (FALSE);
    OEAddComplexRules();

    return result;
}


BOOL
WINAPI
ScriptVcmParse (
    IN      PVOID Reserved
    )
{
    g_VcmMode = TRUE;
    return pCommonQueueEnumeration (TRUE);
}


BOOL
WINAPI
ScriptVcmQueueEnumeration (
    IN      PVOID Reserved
    )
{
    g_VcmMode = TRUE;
    return pCommonQueueEnumeration (FALSE);
}


PCTSTR
pFixDestination (
    IN      PCTSTR Source,
    IN      PCTSTR Destination
    )
{
    PTSTR result = (PTSTR)Source;
    PTSTR tempPtr;
    PTSTR sKey;
    PTSTR sSubKey;
    PTSTR sValueName;
    PTSTR dKey;
    PTSTR dSubKey;
    PTSTR dValueName;
    UINT size;
    BOOL sTree = FALSE;

    sKey = DuplicatePathString (Source, 0);
    sValueName = _tcschr (sKey, TEXT('['));
    if (sValueName) {
        tempPtr = _tcschr (sValueName, TEXT(']'));
        if (tempPtr) {
            *tempPtr = 0;
        }
        tempPtr = sValueName;
        sValueName = _tcsinc (sValueName);
        *tempPtr = 0;
        tempPtr = _tcsdec2 (sKey, tempPtr);
        if (tempPtr) {
            if (_tcsnextc (tempPtr) == TEXT('\\')) {
                *tempPtr = 0;
            }
            if (_tcsnextc (tempPtr) == TEXT(' ')) {
                *tempPtr = 0;
            }
        }
    }
    sSubKey = _tcsrchr (sKey, TEXT('\\'));
    if (sSubKey) {
        tempPtr = _tcsinc (sSubKey);
        if (_tcsnextc (tempPtr) == TEXT('*')) {
            *sSubKey = 0;
            sTree = TRUE;
        }
    }
    sSubKey = _tcsrchr (sKey, TEXT('\\'));
    if (sSubKey) {
        tempPtr = sSubKey;
        sSubKey = _tcsinc (sSubKey);
        *tempPtr = 0;
    }

    dKey = DuplicatePathString (Destination, 0);
    dValueName = _tcschr (dKey, TEXT('['));
    if (dValueName) {
        tempPtr = _tcschr (dValueName, TEXT(']'));
        if (tempPtr) {
            *tempPtr = 0;
        }
        tempPtr = dValueName;
        dValueName = _tcsinc (dValueName);
        *tempPtr = 0;
        tempPtr = _tcsdec2 (dKey, tempPtr);
        if (tempPtr) {
            if (_tcsnextc (tempPtr) == TEXT('\\')) {
                *tempPtr = 0;
            }
            if (_tcsnextc (tempPtr) == TEXT(' ')) {
                *tempPtr = 0;
            }
        }
    }
    dSubKey = _tcsrchr (dKey, TEXT('\\'));
    if (dSubKey) {
        tempPtr = _tcsinc (dSubKey);
        if (_tcsnextc (tempPtr) == TEXT('*')) {
            *dSubKey = 0;
        }
    }
    dSubKey = _tcsrchr (dKey, TEXT('\\'));
    if (dSubKey) {
        tempPtr = dSubKey;
        dSubKey = _tcsinc (dSubKey);
        *tempPtr = 0;
    }
    if (!dSubKey) {
        dSubKey = dKey;
        dKey = NULL;
    }

    size = 0;

    if (dKey && *dKey) {
        size += TcharCount (dKey) + 1;
    } else if (sKey && *sKey) {
        size += TcharCount (sKey) + 1;
    }

    if (dSubKey && *dSubKey) {
        size += TcharCount (dSubKey) + 1;
    } else if (sSubKey && *sSubKey) {
        size += TcharCount (sSubKey) + 1;
    }

    if (dValueName && *dValueName) {
        size += TcharCount (dValueName) + ARRAYSIZE(TEXT(" []")) - 1;
    } else if (sValueName && *sValueName) {
        size += TcharCount (sValueName) + ARRAYSIZE(TEXT(" []")) - 1;
    }

    if (sTree) {
        size += ARRAYSIZE(TEXT("\\*")) - 1;
    }
    size += 1;

    result = AllocPathString (size);
    *result = 0;

    if (dKey && *dKey) {
        StringCat (result, dKey);
    } else if (sKey && *sKey) {
        StringCat (result, sKey);
    }

    if (dSubKey && *dSubKey) {
        StringCat (result, TEXT("\\"));
        StringCat (result, dSubKey);
    } else if (sSubKey && *sSubKey) {
        StringCat (result, TEXT("\\"));
        StringCat (result, sSubKey);
    }

    if (sTree) {
        StringCat (result, TEXT("\\*"));
    }

    if (dValueName && *dValueName) {
        StringCat (result, TEXT(" ["));
        StringCat (result, dValueName);
        StringCat (result, TEXT("]"));
    } else if (sValueName && *sValueName) {
        StringCat (result, TEXT(" ["));
        StringCat (result, sValueName);
        StringCat (result, TEXT("]"));
    }

    if (sKey) {
        FreePathString (sKey);
    }

    if (dKey) {
        FreePathString (dKey);
    } else if (dSubKey) {
        FreePathString (dSubKey);
    }

    return result;
}

BOOL
pParseRegEx (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application          OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR srcNode;
    PCTSTR srcLeaf;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    PCTSTR destNode;
    PCTSTR destLeaf;
    PCTSTR filesDest;
    PCTSTR newDest = NULL;
    ACTION_STRUCT actionStruct;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            __try {
                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));

                srcNode = InfGetStringField (&is, 1);
                srcLeaf = InfGetStringField (&is, 2);
                if (!srcNode && !srcLeaf) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_RENREGEX));
                    __leave;
                }

                // Validate rule
                if (!StringIMatchTcharCount (srcNode, S_HKLM, ARRAYSIZE(S_HKLM) - 1) &&
                    !StringIMatchTcharCount (srcNode, S_HKR, ARRAYSIZE(S_HKR) - 1) &&
                    !StringIMatchTcharCount (srcNode, S_HKCC, ARRAYSIZE(S_HKCC) - 1)
                    ) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_REGROOT, srcNode));
                    __leave;
                }

                srcHandle = CreatePatternFromNodeLeaf (srcNode, srcLeaf);
                if (!srcHandle) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, srcNode));
                    __leave;
                }

                actionStruct.ObjectBase = MakeRegExBase (srcNode, srcLeaf);
                if (!actionStruct.ObjectBase) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, srcNode));
                    __leave;
                }

                if (ActionGroup == ACTIONGROUP_RENAMEEX) {

                    destNode = InfGetStringField (&is, 3);
                    destLeaf = InfGetStringField (&is, 4);
                    if (!destNode && !destLeaf) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_MISSING_DEST, srcNode));
                        __leave;
                    }

                    actionStruct.ObjectDest = CreatePatternFromNodeLeaf (destNode, destLeaf);
                    if (!actionStruct.ObjectDest) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD_DEST, destNode));
                        __leave;
                    }
                }

                if (ActionGroup == ACTIONGROUP_INCFILEEX ||
                    ActionGroup == ACTIONGROUP_INCFOLDEREX ||
                    ActionGroup == ACTIONGROUP_INCICONEX
                    ) {

                    destNode = InfGetStringField (&is, 3);
                    destLeaf = InfGetStringField (&is, 4);
                    if (destNode && destLeaf &&
                        *destNode && *destLeaf) {
                        actionStruct.ObjectDest = CreatePatternFromNodeLeaf (destNode, destLeaf);
                        if (!actionStruct.ObjectDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD_DEST, destNode));
                            __leave;
                        }
                    }
                }

                if ((ActionGroup == ACTIONGROUP_INCFILEEX ||
                     ActionGroup == ACTIONGROUP_INCFOLDEREX ||
                     ActionGroup == ACTIONGROUP_INCICONEX
                     ) &&
                    ((ActionFlags & ACTION_PERSIST_PATH_IN_DATA) ||
                     (ActionFlags & ACTION_PERSIST_ICON_IN_DATA)
                     )
                    ) {

                    filesDest = InfGetStringField (&is, 5);

                    if (filesDest && *filesDest) {

                        newDest = SanitizePath (filesDest);

                        if (newDest) {
                            actionStruct.AddnlDest = TurnFileStringIntoHandle (
                                                            newDest,
                                                            PFF_COMPUTE_BASE|
                                                                PFF_NO_SUBDIR_PATTERN|
                                                                PFF_NO_PATTERNS_ALLOWED|
                                                                PFF_NO_LEAF_AT_ALL
                                                            );
                            FreePathString (newDest);
                            newDest = NULL;
                        }

                        if (!actionStruct.AddnlDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD_DEST, filesDest));
                        }
                    }

                    actionStruct.ObjectHint = InfGetStringField (&is, 6);
                    if (actionStruct.ObjectHint && !(*actionStruct.ObjectHint)) {
                        actionStruct.ObjectHint = NULL;
                    }
                }

                //
                // Add this rule
                //

                if (!AddRule (
                        g_RegType,
                        actionStruct.ObjectBase,
                        srcHandle,
                        ActionGroup,
                        ActionFlags,
                        &actionStruct
                        )) {
                    DEBUGMSG ((DBG_ERROR, "Error processing registry rules for %s", srcNode));
                }

                AddRuleEx (
                    g_RegType,
                    actionStruct.ObjectBase,
                    srcHandle,
                    ACTIONGROUP_DEFAULTPRIORITY,
                    ACTION_PRIORITYSRC,
                    NULL,
                    RULEGROUP_PRIORITY
                    );

                IsmHookEnumeration (
                    g_RegType,
                    srcHandle,
                    ObjectPriority,
                    0,
                    NULL
                    );

                //
                // Queue enumeration for include patterns
                //

                if ((ActionGroup == ACTIONGROUP_INCLUDEEX) ||
                    (ActionGroup == ACTIONGROUP_RENAMEEX) ||
                    (ActionGroup == ACTIONGROUP_INCFILEEX) ||
                    (ActionGroup == ACTIONGROUP_INCFOLDEREX) ||
                    (ActionGroup == ACTIONGROUP_INCICONEX)
                    ) {

                    if (IsmIsObjectHandleLeafOnly (srcHandle)) {
                        pQueueAllReg();
                        IsmHookEnumeration (
                            g_RegType,
                            srcHandle,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    } else {
                        IsmQueueEnumeration (
                            g_RegType,
                            srcHandle,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    }
                }

                if (ActionGroup == ACTIONGROUP_DELREGKEY) {
                    IsmHookEnumeration (g_RegType, srcHandle, ExcludeKeyIfValueExists, 0, NULL);
                    IsmRegisterTypePostEnumerationCallback (g_RegType, PostDelregKeyCallback, NULL);
                }
            }
            __finally {

                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectBase);
                actionStruct.ObjectBase = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectDest);
                actionStruct.ObjectDest = NULL;

                IsmDestroyObjectHandle (actionStruct.AddnlDest);
                actionStruct.AddnlDest = NULL;
            }

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_OR_MISSING_SECTION, Section));
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseReg (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      BOOL FixDestination,
    IN      PCTSTR Application          OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    PCTSTR destination;
    PCTSTR newDestination;
    PCTSTR filesDest;
    PCTSTR newDest = NULL;
    ACTION_STRUCT actionStruct;
    BOOL hadLeaf = FALSE;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            __try {
                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                srcHandle = NULL;

                pattern = InfGetStringField (&is, 0);

                if (!pattern) {
                    pattern = InfGetStringField (&is, 1);
                    if (!pattern) {
                        LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_RENREG));
                        __leave;
                    }
                }

                // Validate rule
                if (!StringIMatchTcharCount (pattern, S_HKLM, ARRAYSIZE(S_HKLM) - 1) &&
                    !StringIMatchTcharCount (pattern, S_HKR, ARRAYSIZE(S_HKR) - 1) &&
                    !StringIMatchTcharCount (pattern, S_HKCC, ARRAYSIZE(S_HKCC) - 1)
                    ) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_INVALID_REGROOT, pattern));
                    __leave;
                }

                srcHandle = TurnRegStringIntoHandle (pattern, TRUE, &hadLeaf);
                if (!srcHandle) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                    __leave;
                }

                actionStruct.ObjectBase = TurnRegStringIntoHandle (pattern, FALSE, NULL);
                if (!actionStruct.ObjectBase) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                    __leave;
                }

                if (ActionGroup == ACTIONGROUP_RENAME) {

                    destination = InfGetStringField (&is, 1);

                    if (destination && *destination) {

                        if (FixDestination) {
                            newDestination = pFixDestination (pattern, destination);
                        } else {
                            newDestination = destination;
                        }

                        actionStruct.ObjectDest = TurnRegStringIntoHandle (newDestination, FALSE, NULL);

                        if (newDestination != destination) {
                            FreePathString (newDestination);
                        }

                        if (!actionStruct.ObjectDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD_DEST, destination));
                            __leave;
                        }

                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_MISSING_DEST, pattern));
                        __leave;
                    }
                }

                if (ActionGroup == ACTIONGROUP_INCFILE ||
                    ActionGroup == ACTIONGROUP_INCFOLDER ||
                    ActionGroup == ACTIONGROUP_INCICON
                    ) {

                    destination = InfGetStringField (&is, 1);

                    if (destination && *destination) {

                        if (FixDestination) {
                            newDestination = pFixDestination (pattern, destination);
                        } else {
                            newDestination = destination;
                        }

                        actionStruct.ObjectDest = TurnRegStringIntoHandle (newDestination, FALSE, NULL);

                        if (newDestination != destination) {
                            FreePathString (newDestination);
                        }

                        if (!actionStruct.ObjectDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD_DEST, destination));
                            __leave;
                        }
                    }
                }

                if ((ActionGroup == ACTIONGROUP_INCFILE ||
                     ActionGroup == ACTIONGROUP_INCFOLDER ||
                     ActionGroup == ACTIONGROUP_INCICON
                     ) &&
                    ((ActionFlags & ACTION_PERSIST_PATH_IN_DATA) ||
                     (ActionFlags & ACTION_PERSIST_ICON_IN_DATA)
                     )
                    ) {

                    filesDest = InfGetStringField (&is, 2);

                    if (filesDest && *filesDest) {

                        newDest = SanitizePath (filesDest);

                        if (newDest) {
                            actionStruct.AddnlDest = TurnFileStringIntoHandle (
                                                            newDest,
                                                            PFF_COMPUTE_BASE|
                                                                PFF_NO_SUBDIR_PATTERN|
                                                                PFF_NO_PATTERNS_ALLOWED|
                                                                PFF_NO_LEAF_AT_ALL
                                                            );
                            FreePathString (newDest);
                            newDest = NULL;
                        }

                        if (!actionStruct.AddnlDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD_DEST, filesDest));
                        }
                    }

                    actionStruct.ObjectHint = InfGetStringField (&is, 3);
                    if (actionStruct.ObjectHint && !(*actionStruct.ObjectHint)) {
                        actionStruct.ObjectHint = NULL;
                    }
                }

                //
                // Add this rule
                //

                if (!AddRule (
                        g_RegType,
                        actionStruct.ObjectBase,
                        srcHandle,
                        ActionGroup,
                        ActionFlags,
                        &actionStruct
                        )) {
                    DEBUGMSG ((DBG_ERROR, "Error processing registry rules for %s", pattern));
                }

                AddRuleEx (
                    g_RegType,
                    actionStruct.ObjectBase,
                    srcHandle,
                    ACTIONGROUP_DEFAULTPRIORITY,
                    ACTION_PRIORITYSRC,
                    NULL,
                    RULEGROUP_PRIORITY
                    );

                IsmHookEnumeration (
                    g_RegType,
                    srcHandle,
                    ObjectPriority,
                    0,
                    NULL
                    );

                //
                // Queue enumeration for include patterns
                //

                if ((ActionGroup == ACTIONGROUP_INCLUDE) ||
                    (ActionGroup == ACTIONGROUP_RENAME) ||
                    (ActionGroup == ACTIONGROUP_INCFILE) ||
                    (ActionGroup == ACTIONGROUP_INCFOLDER) ||
                    (ActionGroup == ACTIONGROUP_INCICON)
                    ) {

                    if (IsmIsObjectHandleLeafOnly (srcHandle)) {
                        pQueueAllReg();
                        IsmHookEnumeration (
                            g_RegType,
                            srcHandle,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    } else {
                        if ((!hadLeaf) && actionStruct.ObjectBase) {
                            IsmQueueEnumeration (
                                g_RegType,
                                actionStruct.ObjectBase,
                                g_VcmMode ? GatherVirtualComputer : PrepareActions,
                                0,
                                NULL
                                );
                        }
                        IsmQueueEnumeration (
                            g_RegType,
                            srcHandle,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    }
                }

                if (ActionGroup == ACTIONGROUP_DELREGKEY) {
                    IsmHookEnumeration (g_RegType, srcHandle, ExcludeKeyIfValueExists, 0, NULL);
                    IsmRegisterTypePostEnumerationCallback (g_RegType, PostDelregKeyCallback, NULL);
                }
            }
            __finally {

                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectBase);
                actionStruct.ObjectBase = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectDest);
                actionStruct.ObjectDest = NULL;

                IsmDestroyObjectHandle (actionStruct.AddnlDest);
                actionStruct.AddnlDest = NULL;
            }

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_OR_MISSING_SECTION, Section));
    }

    InfCleanUpInfStruct (&is);

    return result;
}

BOOL
pParseIni (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application          OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR iniFile = NULL;
    TCHAR buffer [MAX_TCHAR_PATH * 2];
    PCTSTR newIniFile = NULL;
    BOOL expandResult = TRUE;
    PCTSTR sectPattern = NULL;
    PCTSTR keyPattern = NULL;
    PCTSTR destIniFile = NULL;
    PCTSTR newDestIniFile = NULL;
    PCTSTR destSect = NULL;
    PCTSTR destKey = NULL;
    PCTSTR filesDest = NULL;
    PCTSTR newFilesDest = NULL;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    MIG_OBJECTSTRINGHANDLE srcHandle1 = NULL;
    ACTION_STRUCT actionStruct;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            __try {
                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                srcHandle = NULL;

                iniFile = InfGetStringField (&is, 1);

                if (!iniFile) {
                    continue;
                }

                //
                // Expand environment variables in ini file specification
                //
                expandResult = AppSearchAndReplace (
                                    PLATFORM_SOURCE,
                                    Application,
                                    iniFile,
                                    buffer,
                                    ARRAYSIZE(buffer)
                                    );

                if (!expandResult) {
                    // the line contains at least one unexpandable env. variables
                    expandResult = AppCheckAndLogUndefVariables (
                                        PLATFORM_SOURCE,
                                        Application,
                                        iniFile
                                        );
                    if (expandResult) {
                        // the line contains known but undefined env. variables
                        continue;
                    }
                }

                //
                // Fix the ini file specification
                //
                newIniFile = SanitizePath (buffer);
                if(!newIniFile) {
                    continue;
                }

                // require full spec for the INI file
                if (!IsValidFileSpec (newIniFile)) {
                    if (expandResult) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, iniFile));
                    }
                    FreePathString (newIniFile);
                    newIniFile = NULL;
                    continue;
                }

                // let's get the section pattern. If nothing is specified we assume all
                sectPattern = InfGetStringField (&is, 2);
                if ((!sectPattern) || IsEmptyStr (sectPattern)) {
                    sectPattern = PmDuplicateString (is.PoolHandle, TEXT("*"));
                }

                // let's get the key pattern. If nothing is specified we assume all
                keyPattern = InfGetStringField (&is, 3);
                if (!keyPattern || IsEmptyStr (keyPattern)) {
                    keyPattern = PmDuplicateString (is.PoolHandle, TEXT("*"));
                }

                // let's build the object handle
                srcHandle = TurnIniSpecIntoHandle (
                                newIniFile,
                                sectPattern,
                                keyPattern,
                                TRUE,
                                TRUE
                                );

                // let's build the object handle (ignore node pattern if exists)
                srcHandle1 = TurnIniSpecIntoHandle (
                                newIniFile,
                                sectPattern,
                                keyPattern,
                                FALSE,
                                TRUE
                                );

                // now let's build the object base
                actionStruct.ObjectBase = TurnIniSpecIntoHandle (
                                                newIniFile,
                                                sectPattern,
                                                keyPattern,
                                                FALSE,
                                                FALSE
                                                );

                FreePathString (newIniFile);
                newIniFile = NULL;

                if (ActionGroup == ACTIONGROUP_RENAME ||
                    ActionGroup == ACTIONGROUP_INCFILE ||
                    ActionGroup == ACTIONGROUP_INCFOLDER ||
                    ActionGroup == ACTIONGROUP_INCICON
                    ) {

                    destIniFile = InfGetStringField (&is, 4);

                    if (destIniFile && (destIniFile [0] == 0)) {
                        // dest is unspecified
                        destIniFile = NULL;
                    }

                    if (destIniFile) {
                        newDestIniFile = SanitizePath (destIniFile);
                    } else {
                        newDestIniFile = NULL;
                    }

                    destSect = InfGetStringField (&is, 5);

                    destKey = InfGetStringField (&is, 6);

                    actionStruct.ObjectDest = TurnIniSpecIntoHandle (
                                                    newDestIniFile,
                                                    destSect,
                                                    destKey,
                                                    FALSE,
                                                    FALSE
                                                    );

                    if (newDestIniFile) {
                        FreePathString (newDestIniFile);
                        newDestIniFile = NULL;
                    }
                }

                if ((ActionGroup == ACTIONGROUP_INCFILE ||
                     ActionGroup == ACTIONGROUP_INCFOLDER ||
                     ActionGroup == ACTIONGROUP_INCICON
                     ) &&
                    ((ActionFlags & ACTION_PERSIST_PATH_IN_DATA) ||
                     (ActionFlags & ACTION_PERSIST_ICON_IN_DATA)
                     )
                    ) {

                    filesDest = InfGetStringField (&is, 7);

                    if (filesDest && *filesDest) {

                        newFilesDest = SanitizePath (filesDest);

                        if (newFilesDest) {
                            actionStruct.AddnlDest = TurnFileStringIntoHandle (
                                                            newFilesDest,
                                                            PFF_COMPUTE_BASE|
                                                                PFF_NO_SUBDIR_PATTERN|
                                                                PFF_NO_PATTERNS_ALLOWED|
                                                                PFF_NO_LEAF_AT_ALL
                                                            );
                            FreePathString (newFilesDest);
                            newFilesDest = NULL;
                        }

                        if (!actionStruct.AddnlDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD_DEST, filesDest));
                        }
                    }

                    actionStruct.ObjectHint = InfGetStringField (&is, 8);
                    if (actionStruct.ObjectHint && !(*actionStruct.ObjectHint)) {
                        actionStruct.ObjectHint = NULL;
                    }
                }

                //
                // Add this rule
                //

                if (!AddRule (
                        g_IniType,
                        actionStruct.ObjectBase,
                        srcHandle,
                        ActionGroup,
                        ActionFlags,
                        &actionStruct
                        )) {
                    DEBUGMSG ((DBG_ERROR, "Error processing INI files rules for %s", iniFile));
                }

                //
                // Queue enumeration for include patterns
                //

                if ((ActionGroup == ACTIONGROUP_INCLUDE) ||
                    (ActionGroup == ACTIONGROUP_RENAME) ||
                    (ActionGroup == ACTIONGROUP_INCFILE) ||
                    (ActionGroup == ACTIONGROUP_INCFOLDER) ||
                    (ActionGroup == ACTIONGROUP_INCICON)
                    ) {

                    if (!StringIMatch (srcHandle, srcHandle1)) {
                        IsmQueueEnumeration (
                            g_IniType,
                            srcHandle1,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    }

                    IsmQueueEnumeration (
                        g_IniType,
                        srcHandle,
                        g_VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                }
            }
            __finally {

                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;

                IsmDestroyObjectHandle (srcHandle1);
                srcHandle1 = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectBase);
                actionStruct.ObjectBase = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectDest);
                actionStruct.ObjectDest = NULL;

                IsmDestroyObjectHandle (actionStruct.AddnlDest);
                actionStruct.AddnlDest = NULL;
            }

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_OR_MISSING_SECTION, Section));
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseCertificates (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application          OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR certStore;
    TCHAR buffer [MAX_TCHAR_PATH * 2];
    PCTSTR newCertStore = NULL;
    BOOL expandResult = TRUE;
    PCTSTR certPattern;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    ACTION_STRUCT actionStruct;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            __try {
                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                srcHandle = NULL;

                certStore = InfGetStringField (&is, 1);

                if (!certStore) {
                    continue;
                }

                //
                // Expand environment variables in ini file specification
                //

                expandResult = AppSearchAndReplace (
                                    PLATFORM_SOURCE,
                                    Application,
                                    certStore,
                                    buffer,
                                    ARRAYSIZE(buffer)
                                    );

                if (!expandResult) {
                    // the line contains at least one unexpandable env. variables
                    expandResult = AppCheckAndLogUndefVariables (
                                        PLATFORM_SOURCE,
                                        Application,
                                        certStore
                                        );
                    if (expandResult) {
                        // the line contains known but undefined env. variables
                        continue;
                    }
                }

                if (IsValidFileSpec (buffer)) {
                    //
                    // Fix the potential file store specification
                    //
                    newCertStore = SanitizePath (buffer);
                    if(!newCertStore) {
                        continue;
                    }
                }

                // let's get the certificate pattern. If nothing is specified we assume all
                certPattern = InfGetStringField (&is, 2);
                if (!certPattern) {
                    certPattern = PmDuplicateString (is.PoolHandle, TEXT("*"));
                }

                // let's build the object handle
                srcHandle = TurnCertSpecIntoHandle (newCertStore?newCertStore:buffer, certPattern, TRUE);

                // now let's build the object base
                actionStruct.ObjectBase = TurnCertSpecIntoHandle (newCertStore?newCertStore:buffer, certPattern, FALSE);

                if (newCertStore) {
                    FreePathString (newCertStore);
                    newCertStore = NULL;
                }

                //
                // Add this rule
                //

                if (!AddRule (
                        g_CertType,
                        actionStruct.ObjectBase,
                        srcHandle,
                        ActionGroup,
                        ActionFlags,
                        &actionStruct
                        )) {
                    DEBUGMSG ((DBG_ERROR, "Error processing CERT rules for %s\\%s", newCertStore, certPattern));
                }

                //
                // Queue enumeration for include patterns
                //

                if (ActionGroup == ACTIONGROUP_INCLUDE) {

                    IsmQueueEnumeration (
                        g_CertType,
                        srcHandle,
                        g_VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                }
            }
            __finally {

                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectBase);
                actionStruct.ObjectBase = NULL;
            }

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_OR_MISSING_SECTION, Section));
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseFiles (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application              OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    PCTSTR newPattern = NULL;
    PCTSTR dirText;
    BOOL tree;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    PCTSTR destination;
    PCTSTR leafDest;
    TCHAR buffer1[MAX_TCHAR_PATH * 2];
    ACTION_STRUCT actionStruct;
    BOOL result = FALSE;
    PCTSTR msgNode;
    PCTSTR msgLeaf;
    PCTSTR newDest = NULL;
    BOOL expandResult = TRUE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {

            if (IsmCheckCancel()) {
                break;
            }

            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));

            dirText = InfGetStringField (&is, 0);
            pattern = InfGetStringField (&is, 1);

            if (!pattern) {
                continue;
            }

            //
            // Expand environment variables in pattern (the left-side file spec)
            //

            expandResult = AppSearchAndReplace (
                                PLATFORM_SOURCE,
                                Application,
                                pattern,
                                buffer1,
                                ARRAYSIZE(buffer1)
                                );

            if (!expandResult) {
                // the line contains at least one unexpandable env. variables
                expandResult = AppCheckAndLogUndefVariables (
                                    PLATFORM_SOURCE,
                                    Application,
                                    pattern
                                    );
                if (expandResult) {
                    // the line contains known but undefined env. variables
                    continue;
                }
            }

            //
            // Fix the pattern
            //

            newPattern = SanitizePath(buffer1);
            if(!newPattern) {
                continue;
            }

            //
            // Test for dir specification
            //

            if (dirText && StringIMatch (dirText, TEXT("Dir")) && !StringIMatch (pattern, TEXT("Dir"))) {
                tree = TRUE;
            } else {
                tree = FALSE;
            }

            // require full spec or leaf only
            if (!IsValidFileSpec (newPattern) && _tcschr (newPattern, TEXT('\\'))) {
                if (expandResult) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                }
                continue;
            }

            srcHandle = TurnFileStringIntoHandle (newPattern, tree ? PFF_PATTERN_IS_DIR : 0);

            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                continue;
            }

            actionStruct.ObjectBase = TurnFileStringIntoHandle (
                                            newPattern,
                                            PFF_COMPUTE_BASE|
                                                PFF_NO_SUBDIR_PATTERN|
                                                (tree?PFF_NO_LEAF_AT_ALL:PFF_NO_LEAF_PATTERN)
                                            );

            if (actionStruct.ObjectBase && !StringIMatch (actionStruct.ObjectBase, srcHandle)) {

                IsmCreateObjectStringsFromHandle (actionStruct.ObjectBase, &msgNode, &msgLeaf);
                MYASSERT (!msgLeaf);

                LOG ((LOG_INFORMATION, (PCSTR) MSG_FILE_MOVE_BASE_INFO, newPattern, msgNode));

                IsmDestroyObjectString (msgNode);
                IsmDestroyObjectString (msgLeaf);
            }

            if (ActionFlags & ACTION_PERSIST) {
                if (ActionGroup == ACTIONGROUP_INCLUDE ||
                    ActionGroup == ACTIONGROUP_INCLUDEEX ||
                    ActionGroup == ACTIONGROUP_RENAME ||
                    ActionGroup == ACTIONGROUP_RENAMEEX ||
                    ActionGroup == ACTIONGROUP_INCLUDERELEVANT ||
                    ActionGroup == ACTIONGROUP_INCLUDERELEVANTEX ||
                    ActionGroup == ACTIONGROUP_RENAMERELEVANT ||
                    ActionGroup == ACTIONGROUP_RENAMERELEVANTEX
                    ) {

                    //
                    // For the CopyFiles and CopyFilesFiltered sections, get the
                    // optional destination. If destination is specified, move
                    // all of the files into that destination.
                    //

                    destination = InfGetStringField (&is, 2);

                    if (destination && *destination) {

                        if (ActionGroup == ACTIONGROUP_INCLUDE) {
                            ActionGroup = ACTIONGROUP_RENAME;
                        }

                        if (ActionGroup == ACTIONGROUP_INCLUDEEX) {
                            ActionGroup = ACTIONGROUP_RENAMEEX;
                        }

                        if (ActionGroup == ACTIONGROUP_INCLUDERELEVANT) {
                            ActionGroup = ACTIONGROUP_RENAMERELEVANT;
                        }

                        if (ActionGroup == ACTIONGROUP_INCLUDERELEVANTEX) {
                            ActionGroup = ACTIONGROUP_RENAMERELEVANTEX;
                        }

                        newDest = SanitizePath (destination);

                        if (newDest) {
                            actionStruct.ObjectDest = TurnFileStringIntoHandle (
                                                            newDest,
                                                            PFF_COMPUTE_BASE|
                                                                PFF_NO_SUBDIR_PATTERN|
                                                                PFF_NO_PATTERNS_ALLOWED|
                                                                PFF_NO_LEAF_AT_ALL
                                                            );
                            FreePathString (newDest);
                            newDest = NULL;
                        }

                        if ((ActionGroup == ACTIONGROUP_RENAMEEX) ||
                            (ActionGroup == ACTIONGROUP_RENAMERELEVANTEX)
                            ) {
                            // we might have an extra field for the leaf name
                            leafDest = InfGetStringField (&is, 3);
                            if (leafDest && *leafDest) {
                                // we have to rebuild actionStruct.ObjectDest
                                IsmCreateObjectStringsFromHandle (actionStruct.ObjectDest, &msgNode, &msgLeaf);
                                IsmDestroyObjectHandle (actionStruct.ObjectDest);
                                actionStruct.ObjectDest = IsmCreateObjectHandle (msgNode, leafDest);
                                IsmDestroyObjectString (msgNode);
                                IsmDestroyObjectString (msgLeaf);
                            }
                        }

                        if (!actionStruct.ObjectDest) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD_DEST, destination));

                            IsmDestroyObjectHandle (srcHandle);
                            srcHandle = NULL;
                            continue;
                        }
                    }
                }
            }

            //
            // Add this rule
            //

            if (!AddRule (
                    g_FileType,
                    actionStruct.ObjectBase,
                    srcHandle,
                    ActionGroup,
                    ActionFlags,
                    &actionStruct
                    )) {
                DEBUGMSG ((DBG_ERROR, "Error processing file rules"));
                break;
            }

            //
            // Queue enumeration for include patterns
            //

            if ((ActionGroup == ACTIONGROUP_INCLUDE) ||
                (ActionGroup == ACTIONGROUP_INCLUDEEX) ||
                (ActionGroup == ACTIONGROUP_RENAME) ||
                (ActionGroup == ACTIONGROUP_RENAMEEX) ||
                (ActionGroup == ACTIONGROUP_INCLUDERELEVANT) ||
                (ActionGroup == ACTIONGROUP_INCLUDERELEVANTEX) ||
                (ActionGroup == ACTIONGROUP_RENAMERELEVANT) ||
                (ActionGroup == ACTIONGROUP_RENAMERELEVANTEX)
                ) {

                //
                // Queue the enumeration callback
                //

                if (IsmIsObjectHandleLeafOnly (srcHandle)) {

                    DEBUGMSG ((DBG_SCRIPT, "Pattern %s triggered enumeration of entire file system", pattern));

                    QueueAllFiles (g_VcmMode);
                    IsmHookEnumeration (
                        g_FileType,
                        srcHandle,
                        g_VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                } else {
                    if (tree && actionStruct.ObjectBase) {
                        IsmQueueEnumeration (
                            g_FileType,
                            actionStruct.ObjectBase,
                            g_VcmMode ? GatherVirtualComputer : PrepareActions,
                            0,
                            NULL
                            );
                    }
                    IsmQueueEnumeration (
                        g_FileType,
                        srcHandle,
                        g_VcmMode ? GatherVirtualComputer : PrepareActions,
                        0,
                        NULL
                        );
                }
            }

            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

            IsmDestroyObjectHandle (actionStruct.ObjectBase);
            actionStruct.ObjectBase = NULL;

            IsmDestroyObjectHandle (actionStruct.ObjectDest);
            actionStruct.ObjectDest = NULL;

            FreePathString(newPattern);

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseLockPartition (
    IN      HINF Inf,
    IN      PCTSTR Section
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            pattern = InfGetStringField (&is, 0);
            if (!pattern) {
                LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_FILE_SPEC));
                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;
                continue;
            }

            srcHandle = TurnFileStringIntoHandle (pattern, 0);
            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;
                continue;
            }

            IsmHookEnumeration (
                g_FileType,
                srcHandle,
                LockPartition,
                0,
                NULL
                );

            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

        } while (InfFindNextLine (&is));
        result = !IsmCheckCancel();
    }
    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseRegPriority (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application,             OPTIONAL
    IN      BOOL ExtendedPattern
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern = NULL;
    PCTSTR patternLeaf = NULL;
    PCTSTR baseNode = NULL;
    PCTSTR nodeCopy = NULL;
    PTSTR ptr;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    MIG_OBJECTSTRINGHANDLE baseHandle = NULL;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {

            if (IsmCheckCancel()) {
                break;
            }

            pattern = InfGetStringField (&is, 1);

            if (!pattern) {
                LOG ((LOG_WARNING, (PCSTR) MSG_EMPTY_RENREG));
                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;
                continue;
            }

            if (ExtendedPattern) {
                patternLeaf = InfGetStringField (&is, 2);
            }

            if (ExtendedPattern) {
                srcHandle = CreatePatternFromNodeLeaf (pattern, patternLeaf?patternLeaf:TEXT("*"));
            } else {
                srcHandle = TurnRegStringIntoHandle (pattern, TRUE, NULL);
            }
            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_REG_SPEC_BAD, pattern));
                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;
                continue;
            }

            if (ExtendedPattern) {
                ptr = _tcschr (pattern, TEXT('\\'));
                if (ptr) {
                    if (StringIPrefix (pattern, TEXT("HKR\\"))) {
                        nodeCopy = JoinText (TEXT("HKCU"), ptr);
                    } else {
                        nodeCopy = DuplicateText (pattern);
                    }
                    baseNode = GetPatternBase (nodeCopy);
                    if (baseNode) {
                        baseHandle = IsmCreateObjectHandle (baseNode, NULL);
                        FreePathString (baseNode);
                    }
                    FreeText (nodeCopy);
                }
            } else {
                baseHandle = TurnRegStringIntoHandle (pattern, FALSE, NULL);
            }

            AddRuleEx (
                g_RegType,
                baseHandle,
                srcHandle,
                ACTIONGROUP_SPECIFICPRIORITY,
                ActionFlags,
                NULL,
                RULEGROUP_PRIORITY
                );

            IsmHookEnumeration (
                g_RegType,
                srcHandle,
                ObjectPriority,
                0,
                NULL
                );

            IsmDestroyObjectHandle (baseHandle);
            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseIniPriority (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application              OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR iniFile = NULL;
    TCHAR buffer [MAX_TCHAR_PATH * 2];
    PCTSTR newIniFile = NULL;
    BOOL expandResult = TRUE;
    PCTSTR sectPattern = NULL;
    PCTSTR keyPattern = NULL;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    MIG_OBJECTSTRINGHANDLE baseHandle = NULL;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            __try {
                srcHandle = NULL;

                iniFile = InfGetStringField (&is, 1);

                if (!iniFile) {
                    continue;
                }

                //
                // Expand environment variables in ini file specification
                //
                expandResult = AppSearchAndReplace (
                                    PLATFORM_SOURCE,
                                    Application,
                                    iniFile,
                                    buffer,
                                    ARRAYSIZE(buffer)
                                    );

                if (!expandResult) {
                    // the line contains at least one unexpandable env. variables
                    expandResult = AppCheckAndLogUndefVariables (
                                        PLATFORM_SOURCE,
                                        Application,
                                        iniFile
                                        );
                    if (expandResult) {
                        // the line contains known but undefined env. variables
                        continue;
                    }
                }

                //
                // Fix the ini file specification
                //
                newIniFile = SanitizePath (buffer);
                if(!newIniFile) {
                    continue;
                }

                // require full spec for the INI dir
                if (!IsValidFileSpec (newIniFile)) {
                    if (expandResult) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, iniFile));
                    }
                    FreePathString (newIniFile);
                    newIniFile = NULL;
                    continue;
                }

                // let's get the section pattern. If nothing is specified we assume all
                sectPattern = InfGetStringField (&is, 2);
                if (!sectPattern) {
                    sectPattern = PmDuplicateString (is.PoolHandle, TEXT("*"));
                }

                // let's get the key pattern. If nothing is specified we assume all
                keyPattern = InfGetStringField (&is, 3);
                if (!keyPattern) {
                    keyPattern = PmDuplicateString (is.PoolHandle, TEXT("*"));
                }

                // let's build the object handle
                srcHandle = TurnIniSpecIntoHandle (
                                newIniFile,
                                sectPattern,
                                keyPattern,
                                TRUE,
                                TRUE
                                );

                // now let's build the object base
                baseHandle = TurnIniSpecIntoHandle (
                                    newIniFile,
                                    sectPattern,
                                    keyPattern,
                                    FALSE,
                                    FALSE
                                    );

                FreePathString (newIniFile);
                newIniFile = NULL;

                AddRuleEx (
                    g_IniType,
                    baseHandle,
                    srcHandle,
                    ACTIONGROUP_SPECIFICPRIORITY,
                    ActionFlags,
                    NULL,
                    RULEGROUP_PRIORITY
                    );

                IsmHookEnumeration (
                    g_IniType,
                    srcHandle,
                    ObjectPriority,
                    0,
                    NULL
                    );

            }
            __finally {

                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;

                IsmDestroyObjectHandle (baseHandle);
                baseHandle = NULL;
            }

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_OR_MISSING_SECTION, Section));
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseCertPriority (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application              OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR certStore;
    TCHAR buffer [MAX_TCHAR_PATH * 2];
    PCTSTR newCertStore = NULL;
    BOOL expandResult = TRUE;
    PCTSTR certPattern;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    ACTION_STRUCT actionStruct;
    BOOL result = FALSE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {
            if (IsmCheckCancel()) {
                break;
            }

            __try {
                ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
                srcHandle = NULL;

                certStore = InfGetStringField (&is, 1);

                if (!certStore) {
                    continue;
                }

                //
                // Expand environment variables in ini file specification
                //

                expandResult = AppSearchAndReplace (
                                    PLATFORM_SOURCE,
                                    Application,
                                    certStore,
                                    buffer,
                                    ARRAYSIZE(buffer)
                                    );

                if (!expandResult) {
                    // the line contains at least one unexpandable env. variables
                    expandResult = AppCheckAndLogUndefVariables (
                                        PLATFORM_SOURCE,
                                        Application,
                                        certStore
                                        );
                    if (expandResult) {
                        // the line contains known but undefined env. variables
                        continue;
                    }
                }

                if (IsValidFileSpec (buffer)) {
                    //
                    // Fix the potential file store specification
                    //
                    newCertStore = SanitizePath (buffer);
                    if(!newCertStore) {
                        continue;
                    }
                }

                // let's get the certificate pattern. If nothing is specified we assume all
                certPattern = InfGetStringField (&is, 2);
                if (!certPattern) {
                    certPattern = PmDuplicateString (is.PoolHandle, TEXT("*"));
                }

                // let's build the object handle
                srcHandle = TurnCertSpecIntoHandle (newCertStore?newCertStore:buffer, certPattern, TRUE);

                // now let's build the object base
                actionStruct.ObjectBase = TurnCertSpecIntoHandle (newCertStore?newCertStore:buffer, certPattern, FALSE);

                if (newCertStore) {
                    FreePathString (newCertStore);
                    newCertStore = NULL;
                }

                AddRuleEx (
                    g_CertType,
                    actionStruct.ObjectBase,
                    srcHandle,
                    ACTIONGROUP_SPECIFICPRIORITY,
                    ActionFlags,
                    NULL,
                    RULEGROUP_PRIORITY
                    );

                IsmHookEnumeration (
                    g_CertType,
                    srcHandle,
                    ObjectPriority,
                    0,
                    NULL
                    );

            }
            __finally {

                IsmDestroyObjectHandle (srcHandle);
                srcHandle = NULL;

                IsmDestroyObjectHandle (actionStruct.ObjectBase);
                actionStruct.ObjectBase = NULL;
            }

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    } else {
        LOG ((LOG_ERROR, (PCSTR) MSG_EMPTY_OR_MISSING_SECTION, Section));
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseFilePriority (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      DWORD ActionFlags,
    IN      PCTSTR Application              OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR newPattern = NULL;
    PCTSTR pattern;
    PCTSTR dirText;
    BOOL tree;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    MIG_OBJECTSTRINGHANDLE baseHandle = NULL;
    TCHAR buffer1[MAX_TCHAR_PATH * 2];
    BOOL result = FALSE;
    BOOL expandResult = TRUE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {

            if (IsmCheckCancel()) {
                break;
            }

            dirText = InfGetStringField (&is, 0);
            pattern = InfGetStringField (&is, 1);

            if (!pattern) {
                continue;
            }

            //
            // Expand environment variables in pattern (the left-side file spec)
            //

            expandResult = AppSearchAndReplace (
                                PLATFORM_SOURCE,
                                Application,
                                pattern,
                                buffer1,
                                ARRAYSIZE(buffer1)
                                );

            if (!expandResult) {
                // the line contains at least one unexpandable env. variables
                expandResult = AppCheckAndLogUndefVariables (
                                    PLATFORM_SOURCE,
                                    Application,
                                    pattern
                                    );
                if (expandResult) {
                    // the line contains known but undefined env. variables
                    continue;
                }
            }

            //
            // Fix the pattern
            //

            newPattern = SanitizePath(buffer1);
            if(!newPattern) {
                continue;
            }

            //
            // Test for dir specification
            //

            if (dirText && StringIMatch (dirText, TEXT("Dir"))) {
                tree = TRUE;
            } else {
                tree = FALSE;
            }

            // require full spec
            if (!IsValidFileSpec (newPattern)) {
                if (expandResult) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                }
                FreePathString (newPattern);
                newPattern = NULL;
                continue;
            }

            srcHandle = TurnFileStringIntoHandle (newPattern, tree ? PFF_PATTERN_IS_DIR : 0);

            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                FreePathString (newPattern);
                newPattern = NULL;
                continue;
            }

            baseHandle = TurnFileStringIntoHandle (
                            newPattern,
                            PFF_COMPUTE_BASE|
                            PFF_NO_SUBDIR_PATTERN|
                            (tree?PFF_NO_LEAF_AT_ALL:PFF_NO_LEAF_PATTERN)
                            );

            AddRuleEx (
                g_FileType,
                baseHandle,
                srcHandle,
                ACTIONGROUP_SPECIFICPRIORITY,
                ActionFlags,
                NULL,
                RULEGROUP_PRIORITY
                );

            IsmHookEnumeration (
                g_FileType,
                srcHandle,
                ObjectPriority,
                0,
                NULL
                );

            IsmDestroyObjectHandle (baseHandle);
            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

            FreePathString (newPattern);
            newPattern = NULL;

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseFileCollisionPattern (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      PCTSTR Application              OPTIONAL
    )
{
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR pattern;
    PCTSTR newPattern = NULL;
    PCTSTR dirText;
    BOOL tree;
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    PCTSTR collPattern;
    TCHAR buffer1[MAX_TCHAR_PATH * 2];
    ACTION_STRUCT actionStruct;
    BOOL result = FALSE;
    PCTSTR msgNode;
    PCTSTR msgLeaf;
    BOOL expandResult = TRUE;

    if (InfFindFirstLine (Inf, Section, NULL, &is)) {
        do {

            if (IsmCheckCancel()) {
                break;
            }

            ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));

            dirText = InfGetStringField (&is, 0);
            pattern = InfGetStringField (&is, 1);

            if (!pattern) {
                continue;
            }

            //
            // Expand environment variables in pattern (the left-side file spec)
            //

            expandResult = AppSearchAndReplace (
                                PLATFORM_SOURCE,
                                Application,
                                pattern,
                                buffer1,
                                ARRAYSIZE(buffer1)
                                );

            if (!expandResult) {
                // the line contains at least one unexpandable env. variables
                expandResult = AppCheckAndLogUndefVariables (
                                    PLATFORM_SOURCE,
                                    Application,
                                    pattern
                                    );
                if (expandResult) {
                    // the line contains known but undefined env. variables
                    continue;
                }
            }

            //
            // Fix the pattern
            //

            newPattern = SanitizePath(buffer1);
            if(!newPattern) {
                continue;
            }

            //
            // Test for dir specification
            //

            if (dirText && StringIMatch (dirText, TEXT("Dir")) && !StringIMatch (pattern, TEXT("Dir"))) {
                tree = TRUE;
            } else {
                tree = FALSE;
            }

            // require full spec or leaf only
            if (!IsValidFileSpec (newPattern) && _tcschr (newPattern, TEXT('\\'))) {
                if (expandResult) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                }
                continue;
            }

            srcHandle = TurnFileStringIntoHandle (newPattern, tree ? PFF_PATTERN_IS_DIR : 0);

            if (!srcHandle) {
                LOG ((LOG_ERROR, (PCSTR) MSG_FILE_SPEC_BAD, pattern));
                continue;
            }

            actionStruct.ObjectBase = TurnFileStringIntoHandle (
                                            newPattern,
                                            PFF_COMPUTE_BASE|
                                                PFF_NO_SUBDIR_PATTERN|
                                                (tree?PFF_NO_LEAF_AT_ALL:PFF_NO_LEAF_PATTERN)
                                            );

            collPattern = InfGetStringField (&is, 2);

            if ((!collPattern) || (!(*collPattern))) {
                // we have no collision pattern, let's get out
                continue;
            }

            actionStruct.ObjectHint = IsmDuplicateString (collPattern);

            //
            // Add this rule
            //

            if (!AddRuleEx (
                    g_FileType,
                    actionStruct.ObjectBase,
                    srcHandle,
                    ACTIONGROUP_FILECOLLPATTERN,
                    0,
                    &actionStruct,
                    RULEGROUP_COLLPATTERN
                    )) {
                DEBUGMSG ((DBG_ERROR, "Error processing file rules"));
                break;
            }

            //
            // Queue the enumeration callback
            //

            if (IsmIsObjectHandleLeafOnly (srcHandle)) {

                DEBUGMSG ((DBG_SCRIPT, "Pattern %s triggered enumeration of entire file system", pattern));

                IsmHookEnumeration (
                    g_FileType,
                    srcHandle,
                    FileCollPattern,
                    0,
                    NULL
                    );
            } else {
                if (tree && actionStruct.ObjectBase) {
                    IsmHookEnumeration (
                        g_FileType,
                        actionStruct.ObjectBase,
                        FileCollPattern,
                        0,
                        NULL
                        );
                }
                IsmHookEnumeration (
                    g_FileType,
                    srcHandle,
                    FileCollPattern,
                    0,
                    NULL
                    );
            }

            IsmDestroyObjectHandle (srcHandle);
            srcHandle = NULL;

            IsmDestroyObjectHandle (actionStruct.ObjectBase);
            actionStruct.ObjectBase = NULL;

            IsmReleaseMemory (actionStruct.ObjectHint);
            actionStruct.ObjectHint = NULL;

            FreePathString(newPattern);

        } while (InfFindNextLine (&is));

        result = !IsmCheckCancel();
    }

    InfCleanUpInfStruct (&is);

    return result;
}


BOOL
pParseOneInstruction (
    IN      HINF InfHandle,
    IN      PCTSTR Type,
    IN      PCTSTR SectionMultiSz,
    IN      PINFSTRUCT InfStruct,
    IN      PCTSTR Application          OPTIONAL
    )
{
    ACTIONGROUP actionGroup;
    DWORD actionFlags;
    MULTISZ_ENUM e;
    BOOL result = TRUE;
    MIG_PLATFORMTYPEID platform = IsmGetRealPlatform();

    //
    // First thing: look for nested sections
    //
    if (StringIMatch (Type, TEXT("ProcessSection"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {
            do {
                result = result & ParseOneApplication (
                                    PLATFORM_SOURCE,
                                    InfHandle,
                                    Application,
                                    FALSE,
                                    0,
                                    e.CurrentString,
                                    NULL,
                                    NULL,
                                    NULL
                                    );
            } while (EnumNextMultiSz (&e));
        }
        return result;
    }

    //
    // Parse registry sections
    //

    actionGroup = ACTIONGROUP_NONE;
    actionFlags = 0;

    if (StringIMatch (Type, TEXT("AddReg"))) {
        actionGroup = ACTIONGROUP_INCLUDE;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("RenReg"))) {
        actionGroup = ACTIONGROUP_RENAME;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("DelReg"))) {
        actionGroup = ACTIONGROUP_EXCLUDE;
        actionFlags = 0;
    } else if (StringIMatch (Type, TEXT("RegFile"))) {
        actionGroup = ACTIONGROUP_INCFILE;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("RegFolder"))) {
        actionGroup = ACTIONGROUP_INCFOLDER;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("RegIcon"))) {
        actionGroup = ACTIONGROUP_INCICON;
        actionFlags = ACTION_PERSIST_ICON_IN_DATA;
    } else if (StringIMatch (Type, TEXT("DelRegKey"))) {
        actionGroup = ACTIONGROUP_DELREGKEY;
        actionFlags = 0;
    }

    if (actionGroup != ACTIONGROUP_NONE) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseReg (
                        InfHandle,
                        e.CurrentString,
                        actionGroup,
                        actionFlags,
                        TRUE,
                        Application
                        )) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse INI sections
    //

    actionGroup = ACTIONGROUP_NONE;
    actionFlags = 0;

    if (StringIMatch (Type, TEXT("AddIni"))) {
        actionGroup = ACTIONGROUP_INCLUDE;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("RenIni"))) {
        actionGroup = ACTIONGROUP_RENAME;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("DelIni"))) {
        actionGroup = ACTIONGROUP_EXCLUDE;
        actionFlags = 0;
    } else if (StringIMatch (Type, TEXT("IniFile"))) {
        actionGroup = ACTIONGROUP_INCFILE;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("IniFolder"))) {
        actionGroup = ACTIONGROUP_INCFOLDER;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("IniIcon"))) {
        actionGroup = ACTIONGROUP_INCICON;
        actionFlags = ACTION_PERSIST_ICON_IN_DATA;
    }

    if (actionGroup != ACTIONGROUP_NONE) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseIni (
                        InfHandle,
                        e.CurrentString,
                        actionGroup,
                        actionFlags,
                        Application
                        )) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse file sections
    //

    if (StringIMatch (Type, TEXT("CopyFilesFiltered"))) {
        actionGroup = ACTIONGROUP_INCLUDERELEVANT;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("CopyFilesFilteredEx"))) {
        actionGroup = ACTIONGROUP_INCLUDERELEVANTEX;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("CopyFiles"))) {
        actionGroup = ACTIONGROUP_INCLUDE;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("CopyFilesEx"))) {
        actionGroup = ACTIONGROUP_INCLUDEEX;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("DelFiles"))) {
        actionGroup = ACTIONGROUP_EXCLUDE;
        actionFlags = 0;
    }

    if (actionGroup != ACTIONGROUP_NONE) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_ALL_FILES)) {
                    if (!pParseFiles (
                            InfHandle,
                            e.CurrentString,
                            actionGroup,
                            actionFlags,
                            Application
                            )) {
                        result = FALSE;
                        if (InfStruct) {
                            InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                        }
                        break;
                    }
                } else {
                    LOG ((
                        LOG_INFORMATION,
                        (PCSTR) MSG_IGNORING_FILE_SECTION,
                        e.CurrentString
                        ));
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse certificates sections
    //

    actionGroup = ACTIONGROUP_NONE;
    actionFlags = 0;

    if (StringIMatch (Type, TEXT("AddCertificates"))) {
        actionGroup = ACTIONGROUP_INCLUDE;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("DelCertificates"))) {
        actionGroup = ACTIONGROUP_EXCLUDE;
        actionFlags = 0;
    }

    if (actionGroup != ACTIONGROUP_NONE) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseCertificates (
                        InfHandle,
                        e.CurrentString,
                        actionGroup,
                        actionFlags,
                        Application
                        )) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse registry priority
    //

    if (StringIMatch (Type, TEXT("ForceDestRegEx"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseRegPriority (InfHandle, e.CurrentString, ACTION_PRIORITYDEST, Application, TRUE)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceDestReg"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseRegPriority (InfHandle, e.CurrentString, ACTION_PRIORITYDEST, Application, FALSE)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceSrcRegEx"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseRegPriority (InfHandle, e.CurrentString, ACTION_PRIORITYSRC, Application, TRUE)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceSrcReg"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseRegPriority (InfHandle, e.CurrentString, ACTION_PRIORITYSRC, Application, FALSE)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse INI priority
    //

    if (StringIMatch (Type, TEXT("ForceDestIni"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseIniPriority (InfHandle, e.CurrentString, ACTION_PRIORITYDEST, Application)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceSrcIni"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseIniPriority (InfHandle, e.CurrentString, ACTION_PRIORITYSRC, Application)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse certificates priority
    //

    if (StringIMatch (Type, TEXT("ForceDestCert"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseCertPriority (InfHandle, e.CurrentString, ACTION_PRIORITYDEST, Application)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceSrcCert"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseCertPriority (InfHandle, e.CurrentString, ACTION_PRIORITYSRC, Application)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse file collision rules (default is %s(%d).%s)
    //
    if (StringIMatch (Type, TEXT("FileCollisionPattern"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!pParseFileCollisionPattern (InfHandle, e.CurrentString, Application)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse restore callback rule
    //

    if (StringIMatch (Type, TEXT("RestoreCallback"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_RESTORE, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse destination rule
    //

    if (StringIMatch (Type, TEXT("DestDelReg"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_DELREG, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    if (StringIMatch (Type, TEXT("DestDelRegEx"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_DELREGEX, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse destination detect rules
    //

    if (StringIMatch (Type, TEXT("DestCheckDetect"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_CHECKDETECT, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse destination AddObject rule
    //

    if (StringIMatch (Type, TEXT("DestAddObject"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_DEST_ADDOBJECT, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse execute rule
    //

    if (StringIMatch (Type, TEXT("Execute"))) {
        if (!g_VcmMode) {
            if (EnumFirstMultiSz (&e, SectionMultiSz)) {

                do {
                    IsmAppendEnvironmentString (PLATFORM_SOURCE, NULL, S_ENV_SCRIPT_EXECUTE, e.CurrentString);
                } while (EnumNextMultiSz (&e));
            }
        }

        return result;
    }

    //
    // Parse file priority
    //

    if (StringIMatch (Type, TEXT("ForceDestFile"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_ALL_FILES)) {
                    if (!pParseFilePriority (InfHandle, e.CurrentString, ACTION_PRIORITYDEST, Application)) {
                        result = FALSE;
                        if (InfStruct) {
                            InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                        }
                        break;
                    }
                } else {
                    LOG ((
                        LOG_INFORMATION,
                        (PCSTR) MSG_IGNORING_FILE_SECTION,
                        e.CurrentString
                        ));
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }
    if (StringIMatch (Type, TEXT("ForceSrcFile"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (IsmIsEnvironmentFlagSet (platform, NULL, S_ENV_ALL_FILES)) {
                    if (!pParseFilePriority (InfHandle, e.CurrentString, ACTION_PRIORITYSRC, Application)) {
                        result = FALSE;
                        if (InfStruct) {
                            InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                        }
                        break;

                    }
                } else {
                    LOG ((
                        LOG_INFORMATION,
                        (PCSTR) MSG_IGNORING_FILE_SECTION,
                        e.CurrentString
                        ));
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse special conversion
    //

    if (StringIMatch (Type, TEXT("Conversion"))) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!DoRegistrySpecialConversion (InfHandle, e.CurrentString)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    if (StringIMatch (Type, TEXT("RenRegFn"))) {

        if (EnumFirstMultiSz (&e, SectionMultiSz)) {

            do {
                if (!DoRegistrySpecialRename (InfHandle, e.CurrentString)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }

            } while (EnumNextMultiSz (&e));
        }

        return result;
    }

    //
    // Parse enhanced renreg
    //

    actionGroup = ACTIONGROUP_NONE;
    actionFlags = 0;

    if (StringIMatch (Type, TEXT("AddRegEx"))) {
        actionGroup = ACTIONGROUP_INCLUDEEX;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("RenRegEx"))) {
        actionGroup = ACTIONGROUP_RENAMEEX;
        actionFlags = ACTION_PERSIST;
    } else if (StringIMatch (Type, TEXT("DelRegEx"))) {
        actionGroup = ACTIONGROUP_EXCLUDEEX;
        actionFlags = 0;
    } else if (StringIMatch (Type, TEXT("RegFileEx"))) {
        actionGroup = ACTIONGROUP_INCFILEEX;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("RegFolderEx"))) {
        actionGroup = ACTIONGROUP_INCFOLDEREX;
        actionFlags = ACTION_PERSIST_PATH_IN_DATA;
    } else if (StringIMatch (Type, TEXT("RegIconEx"))) {
        actionGroup = ACTIONGROUP_INCICONEX;
        actionFlags = ACTION_PERSIST_ICON_IN_DATA;
    }

    if (actionGroup != ACTIONGROUP_NONE) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {
            do {
                if (!pParseRegEx (InfHandle, e.CurrentString, actionGroup, actionFlags, Application)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }
            } while (EnumNextMultiSz (&e));
        }
        return result;
    }

    if (StringIMatch (Type, TEXT("LockPartition"))) {
        if (EnumFirstMultiSz (&e, SectionMultiSz)) {
            do {
                if (!pParseLockPartition (InfHandle, e.CurrentString)) {
                    result = FALSE;
                    if (InfStruct) {
                        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
                    }
                    break;
                }
            } while (EnumNextMultiSz (&e));
        }
        return result;
    }

    //
    // Unknown section type
    //

    LOG ((LOG_ERROR, (PCSTR) MSG_UNEXPECTED_SECTION_TYPE, Type));

    if (InfStruct) {
        InfLogContext (LOG_ERROR, InfHandle, InfStruct);
    }

    return FALSE;
}


BOOL
pParseInfInstructionsWorker (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Application,     OPTIONAL
    IN      PCTSTR Section
    )
{
    PCTSTR type;
    PCTSTR sections;
    GROWBUFFER multiSz = INIT_GROWBUFFER;
    BOOL result = TRUE;

    if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
        do {

            if (IsmCheckCancel()) {
                result = FALSE;
                break;
            }

            InfResetInfStruct (InfStruct);

            type = InfGetStringField (InfStruct, 0);
            sections = InfGetMultiSzField (InfStruct, 1);

            if (!type || !sections) {
                LOG ((LOG_WARNING, (PCSTR) MSG_BAD_INF_LINE, Section));
                InfLogContext (LOG_WARNING, InfHandle, InfStruct);
                continue;
            }

            result = pParseOneInstruction (InfHandle, type, sections, InfStruct, Application);

        } while (result && InfFindNextLine (InfStruct));
    }

    InfCleanUpInfStruct (InfStruct);

    GbFree (&multiSz);

    return result;
}


BOOL
ParseInfInstructions (
    IN      HINF InfHandle,
    IN      PCTSTR Application,     OPTIONAL
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PTSTR instrSection;

    b = pParseInfInstructionsWorker (&is, InfHandle, Application, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (PLATFORM_SOURCE, &is, InfHandle, Section);

        if (osSpecificSection) {
            b = pParseInfInstructionsWorker (&is, InfHandle, Application, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);

    return b;
}


BOOL
pParseInf (
    IN      HINF InfHandle,
    IN      BOOL PreParse
    )
{
    BOOL result = TRUE;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Process the application sections
    //

    if (!ParseApplications (PLATFORM_SOURCE, InfHandle, TEXT("Applications"), PreParse, MASTERGROUP_APP)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_APP_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process system settings
    //

    if (!ParseApplications (PLATFORM_SOURCE, InfHandle, TEXT("System Settings"), PreParse, MASTERGROUP_SYSTEM)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_SYSTEM_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process user settings
    //

    if (!ParseApplications (PLATFORM_SOURCE, InfHandle, TEXT("User Settings"), PreParse, MASTERGROUP_USER)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_USER_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process files and folders settings
    //

    if (!ProcessFilesAndFolders (InfHandle, TEXT("Files and Folders"), PreParse)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_FNF_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    //
    // Process the administrator script sections
    //

    if (!ParseApplications (PLATFORM_SOURCE, InfHandle, TEXT("Administrator Scripts"), PreParse, MASTERGROUP_SCRIPT)) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_SCRIPT_PARSE_FAILURE));
        IsmSetCancel();
        return FALSE;
    }

    return TRUE;
}


BOOL
pAddFileSpec (
    IN      PCTSTR Node,                OPTIONAL
    IN      PCTSTR Leaf,                OPTIONAL
    IN      BOOL IncludeSubDirs,
    IN      BOOL LeafIsPattern,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      BOOL DefaultPriority,
    IN      BOOL SrcPriority
    )
{
    MIG_OBJECTSTRINGHANDLE srcHandle = NULL;
    MIG_OBJECTSTRINGHANDLE srcBaseHandle = NULL;
    BOOL result = FALSE;
    ACTION_STRUCT actionStruct;

    __try {
        //
        // Build object string
        //

        MYASSERT (Node || Leaf);

        srcHandle = IsmCreateSimpleObjectPattern (Node, IncludeSubDirs, Leaf, LeafIsPattern);

        if (!srcHandle) {
            __leave;
        }

        if (Node) {
            srcBaseHandle = IsmCreateObjectHandle (Node, NULL);
        }

        //
        // Add this rule
        //

        ZeroMemory (&actionStruct, sizeof (ACTION_STRUCT));
        actionStruct.ObjectBase = srcBaseHandle;

        if (!AddRule (
                g_FileType,
                actionStruct.ObjectBase,
                srcHandle,
                ActionGroup,
                ActionFlags,
                &actionStruct
                )) {
            __leave;
        }

        if (!DefaultPriority) {

            AddRuleEx (
                g_FileType,
                actionStruct.ObjectBase,
                srcHandle,
                ACTIONGROUP_SPECIFICPRIORITY,
                SrcPriority?ACTION_PRIORITYSRC:ACTION_PRIORITYDEST,
                NULL,
                RULEGROUP_PRIORITY
                );

            IsmHookEnumeration (
                g_RegType,
                srcHandle,
                ObjectPriority,
                0,
                NULL
                );
        }

        //
        // Queue enumeration for include patterns
        //

        if (ActionGroup == ACTIONGROUP_INCLUDE) {

            if (IsmIsObjectHandleLeafOnly (srcHandle)) {

                DEBUGMSG ((
                    DBG_SCRIPT,
                    "File node %s leaf %s triggered enumeration of entire file system",
                    Node,
                    Leaf
                    ));

                QueueAllFiles (g_VcmMode);
                IsmHookEnumeration (
                    g_FileType,
                    srcHandle,
                    g_VcmMode ? GatherVirtualComputer : PrepareActions,
                    0,
                    NULL
                    );
            } else {
                IsmQueueEnumeration (
                    g_FileType,
                    srcHandle,
                    g_VcmMode ? GatherVirtualComputer : PrepareActions,
                    0,
                    NULL
                    );
            }
        }

        result = TRUE;
    }
    __finally {
        IsmDestroyObjectHandle (srcHandle);
        INVALID_POINTER (srcHandle);

        IsmDestroyObjectHandle (srcBaseHandle);
        INVALID_POINTER (srcBaseHandle);
    }

    return result;
}


BOOL
pParseFilesAndFolders (
    IN      UINT Group,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      BOOL HasNode,
    IN      BOOL HasLeaf,
    IN      BOOL HasPriority
    )
{
    MIG_COMPONENT_ENUM e;
    BOOL result = FALSE;
    PCTSTR node;
    PCTSTR leaf;
    PTSTR copyOfData = NULL;
    PTSTR p;
    BOOL defaultPriority = TRUE;
    BOOL srcPriority = FALSE;

    __try {
        //
        // Enumerate all the components
        //

        if (IsmEnumFirstComponent (&e, COMPONENTENUM_ENABLED|COMPONENTENUM_ALIASES, Group)) {
            do {
                //
                // Parse string into node/leaf format
                //

                if (e.MasterGroup != MASTERGROUP_FILES_AND_FOLDERS) {
                    continue;
                }

                copyOfData = DuplicateText (e.LocalizedAlias);

                node = copyOfData;
                leaf = NULL;

                if (HasNode && HasLeaf) {
                    p = (PTSTR) FindLastWack (copyOfData);
                    if (p) {
                        leaf = _tcsinc (p);
                        *p = 0;
                    }
                } else if (!HasNode) {
                    node = NULL;
                    leaf = JoinText (TEXT("*."), copyOfData);
                }

                //
                // Add rule
                //

                if (!pAddFileSpec (
                        node,
                        leaf,
                        (HasNode && (!HasLeaf)),
                        (HasNode && (!HasLeaf)) || (!HasNode),
                        ActionGroup,
                        ActionFlags,
                        defaultPriority,
                        srcPriority
                        )) {
                    IsmAbortComponentEnum (&e);
                    __leave;
                }

                if (!HasNode) {
                    FreeText (leaf);
                }

                FreeText (copyOfData);
                copyOfData = NULL;

            } while (IsmEnumNextComponent (&e));
        }

        result = TRUE;
    }
    __finally {
        FreeText (copyOfData);

        if (!result) {
            IsmAbortComponentEnum (&e);
        }
    }

    return result;
}


BOOL
pSelectFilesAndFolders (
    VOID
    )
{
    if (!pParseFilesAndFolders (
            COMPONENT_EXTENSION,
            ACTIONGROUP_INCLUDE,
            ACTION_PERSIST,
            FALSE,
            TRUE,
            TRUE
            )) {
        return FALSE;
    }

    if (!pParseFilesAndFolders (
            COMPONENT_FOLDER,
            ACTIONGROUP_INCLUDE,
            ACTION_PERSIST,
            TRUE,
            FALSE,
            TRUE
            )) {
        return FALSE;
    }

    if (!pParseFilesAndFolders (
            COMPONENT_FILE,
            ACTIONGROUP_INCLUDE,
            ACTION_PERSIST,
            TRUE,
            TRUE,
            TRUE
            )) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pParseAllInfs (
    IN      BOOL PreParse
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    BOOL result = FALSE;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (pParseInf (infHandle, PreParse)) {
            result = TRUE;
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            return TRUE;        // no INF files specified
        }

        __try {
            multiSz = AllocText (sizeNeeded);
            if (!multiSz) {
                __leave;
            }

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {

                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {
                        if (!pParseInf (infHandle, PreParse)) {
                            InfCloseInfFile (infHandle);
                            infHandle = INVALID_HANDLE_VALUE;
                            __leave;
                        }
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                    InfCloseInfFile (infHandle);
                    infHandle = INVALID_HANDLE_VALUE;
                } while (EnumNextMultiSz (&e));

            }

            result = TRUE;
        }
        __finally {
            if (multiSz) {
                FreeText (multiSz);
                multiSz = NULL;
            }
        }
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\sgminit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sgminit.c

Abstract:

    Implements the initialization/termination code for the data gather portion
    of scanstate v1 compatiblity.

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PMAPSTRUCT g_EnvMap;
PMAPSTRUCT g_UndefMap;
PMAPSTRUCT g_RevEnvMap;
HASHTABLE g_RenameSrcTable;
HASHTABLE g_RenameDestTable;
HASHTABLE g_DePersistTable;
PMHANDLE g_V1Pool;
MIG_OBJECTTYPEID g_FileType;
MIG_OBJECTTYPEID g_RegType;
MIG_OBJECTTYPEID g_IniType;
MIG_ATTRIBUTEID g_OsFileAttribute;
MIG_ATTRIBUTEID g_CopyIfRelevantAttr;
MIG_ATTRIBUTEID g_LockPartitionAttr;

//
// Macro expansion list
//



//
// Private function prototypes
//

VCMINITIALIZE ScriptVcmInitialize;
SGMINITIALIZE ScriptSgmInitialize;

BOOL
pParseAllInfs (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// Code
//

VOID
pPrepareIsmEnvironment (
    VOID
    )
{
    if (IsmGetRealPlatform() == PLATFORM_SOURCE) {
        SetIsmEnvironmentFromPhysicalMachine (g_EnvMap, FALSE, g_UndefMap);
    } else {
        // next call is just to set destination ISM environment with some of the CSIDL env variables
        SetIsmEnvironmentFromPhysicalMachine (NULL, FALSE, NULL);
        SetIsmEnvironmentFromVirtualMachine (g_EnvMap, g_RevEnvMap, g_UndefMap);
    }
}


BOOL
pInitGlobals (
    IN      PMIG_LOGCALLBACK LogCallback
    )
{
    BOOL result;

    LogReInit (NULL, NULL, NULL, (PLOGCALLBACK) LogCallback);

    g_V1Pool = PmCreateNamedPool ("v1 sgm");
    g_EnvMap = CreateStringMapping();
    g_UndefMap = CreateStringMapping();
    g_RevEnvMap = CreateStringMapping();

    g_FileType = MIG_FILE_TYPE;
    g_RegType = MIG_REGISTRY_TYPE;
    g_IniType = MIG_INI_TYPE;

    result = g_V1Pool && g_EnvMap && g_UndefMap && g_RevEnvMap;

    if (!result) {
        DEBUGMSG ((DBG_ERROR, "Unable to initialize gather module globals"));\
    }

    return result;
}


BOOL
pCommonInit (
    IN      PVOID Reserved,
    IN      BOOL VcmMode
    )
{
    g_OsFileAttribute = IsmRegisterAttribute (S_ATTRIBUTE_OSFILE, FALSE);
    g_CopyIfRelevantAttr = IsmRegisterAttribute (S_ATTRIBUTE_COPYIFRELEVANT, FALSE);
    g_LockPartitionAttr = IsmRegisterAttribute (S_ATTRIBUTE_PARTITIONLOCK, FALSE);

    g_DePersistTable = HtAlloc ();

    InitRules();

    //
    // Call special conversion entry point
    //
    InitSpecialConversion (PLATFORM_SOURCE);
    InitSpecialRename (PLATFORM_SOURCE);

    //
    // Save shell folder environment
    //

    pPrepareIsmEnvironment();

    return TRUE;
}


BOOL
pGetDomainUserName (
    OUT     PCTSTR *Domain,
    OUT     PCTSTR *User
    )
{
    TCHAR userName[256];
    TCHAR domainName[256];
    DWORD size;
    HANDLE token = NULL;
    BOOL b;
    PTOKEN_USER tokenInfo = NULL;
    BOOL result = FALSE;
    DWORD domainSize;
    SID_NAME_USE dontCare;
    MIG_OBJECTSTRINGHANDLE regObject;
    MIG_CONTENT regContent;

    *Domain = NULL;
    *User = NULL;

    //
    // Assert that this is the source platform. We access the system directly.
    //

    MYASSERT (IsmGetRealPlatform() == PLATFORM_SOURCE);

    __try {

        if (ISWIN9X()) {

            size = ARRAYSIZE(userName);
            if (!GetUserName (userName, &size)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_CANT_GET_USERNAME));
                __leave;
            }

            *User = DuplicateText (userName);

            regObject = IsmCreateObjectHandle (
                            TEXT("HKLM\\System\\CurrentControlSet\\Services\\MSNP32\\NetworkProvider"),
                            TEXT("AuthenticatingAgent")
                            );

            if (IsmAcquireObject (g_RegType, regObject, &regContent)) {
                if (!regContent.ContentInFile &&
                    regContent.MemoryContent.ContentBytes &&
                    regContent.Details.DetailsSize == sizeof (DWORD) &&
                    *((PDWORD) regContent.Details.DetailsData) == REG_SZ
                    ) {
                    *Domain = DuplicateText ((PCTSTR) regContent.MemoryContent.ContentBytes);
                }

                IsmReleaseObject (&regContent);
            }

            IsmDestroyObjectHandle (regObject);

        } else {
            if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
                LOG ((LOG_WARNING, (PCSTR) MSG_PROCESS_TOKEN_ERROR));
                __leave;
            }

            size = 0;

            GetTokenInformation (
                token,
                TokenUser,  // sdk enum value
                NULL,
                0,
                &size
                );

            if (size) {
                tokenInfo = (PTOKEN_USER) MemAllocUninit (size);

                b = GetTokenInformation (
                        token,
                        TokenUser,
                        tokenInfo,
                        size,
                        &size
                        );
            } else {
                b = FALSE;
            }

            if (!b) {
                LOG ((LOG_WARNING, (PCSTR) MSG_PROCESS_TOKEN_INFO_ERROR));
                __leave;
            }

            size = ARRAYSIZE (userName);
            domainSize = ARRAYSIZE (domainName);

            b = LookupAccountSid (
                    NULL,
                    tokenInfo->User.Sid,
                    userName,
                    &size,
                    domainName,
                    &domainSize,
                    &dontCare
                    );

            if (!b) {
                LOG ((LOG_WARNING, (PCSTR) MSG_SECURITY_ID_LOOKUP_ERROR));
                __leave;
            }

            *User = DuplicateText (userName);

            if (*domainName) {
                *Domain = DuplicateText (domainName);
            }
        }

        result = TRUE;

    }
    __finally {
        if (tokenInfo) {
            FreeAlloc (tokenInfo);
        }

        if (token) {
            CloseHandle (token);
        }
    }

    return result;
}


BOOL
WINAPI
ScriptSgmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TCHAR userName[256];
    TCHAR domainName[256];
    PCTSTR srcUserName;
    PCTSTR srcDomainName;

    if (!pInitGlobals (LogCallback)) {
        return FALSE;
    }

    g_RenameSrcTable = HtAllocWithData (sizeof (MIG_DATAHANDLE));
    g_RenameDestTable = HtAllocWithData (sizeof (MIG_DATAHANDLE));

    if (IsmGetRealPlatform() == PLATFORM_DESTINATION) {

        IsmGetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_USER_INFKEY, userName, sizeof (userName));

        if (!IsmGetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_DOMAIN_INFKEY, domainName, sizeof (domainName))) {
            if (IsmIsEnvironmentFlagSet (PLATFORM_DESTINATION, NULL, S_REQUIRE_DOMAIN_USER)) {
                //
                // NOTE: We could create the user account for the non-domain case.
                //

                IsmSetCancel();
                SetLastError (ERROR_INVALID_DOMAINNAME);
                LOG ((LOG_ERROR, (PCSTR) MSG_DOMAIN_REQUIRED));
                return FALSE;
            }
        } else {
            IsmSetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("USERDOMAIN"),
                domainName
                );
            AddStringMappingPair (g_EnvMap, TEXT("%DOMAINNAME%"), domainName);
        }

        IsmSetEnvironmentString (
            PLATFORM_SOURCE,
            S_SYSENVVAR_GROUP,
            TEXT("USERNAME"),
            userName
            );
        AddStringMappingPair (g_EnvMap, TEXT("%USERNAME%"), userName);

    } else {

        if (!pGetDomainUserName (&srcDomainName, &srcUserName)) {
            if (IsmIsEnvironmentFlagSet (PLATFORM_DESTINATION, NULL, S_REQUIRE_DOMAIN_USER)) {
                return FALSE;
            }
        } else {

            IsmSetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_USER_INFKEY, srcUserName);
            IsmSetEnvironmentString (
                PLATFORM_SOURCE,
                S_SYSENVVAR_GROUP,
                TEXT("USERNAME"),
                srcUserName
                );
            AddStringMappingPair (g_EnvMap, TEXT("%USERNAME%"), srcUserName);

            if (srcDomainName) {
                IsmSetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_DOMAIN_INFKEY, srcDomainName);
                IsmSetEnvironmentString (
                    PLATFORM_SOURCE,
                    S_SYSENVVAR_GROUP,
                    TEXT("USERDOMAIN"),
                    srcDomainName
                    );
                AddStringMappingPair (g_EnvMap, TEXT("%DOMAINNAME%"), srcDomainName);
            }

            FreeText (srcUserName);
            FreeText (srcDomainName);
        }
    }

    //
    // Parse the script and do the rest of the business
    //

    return pCommonInit (Reserved, FALSE);
}


VOID
pSaveRegDword (
    IN      PCTSTR InfKeyName,
    IN      PCTSTR Key,
    IN      PCTSTR Value
    )
{
    TCHAR buffer[32];
    MIG_OBJECTSTRINGHANDLE regObject;
    MIG_CONTENT regContent;

    regObject = IsmCreateObjectHandle (Key, Value);

    if (IsmAcquireObject (g_RegType, regObject, &regContent)) {
        if (!regContent.ContentInFile &&
            regContent.MemoryContent.ContentBytes &&
            regContent.Details.DetailsSize == sizeof (DWORD) &&
            *((PDWORD) regContent.Details.DetailsData) == REG_DWORD
            ) {
            wsprintf (buffer, TEXT("0x%08X"), *((PDWORD) regContent.MemoryContent.ContentBytes));
            IsmSetTransportVariable (PLATFORM_SOURCE, S_SOURCE_MACHINE_SECTION, InfKeyName, buffer);
        }

        IsmReleaseObject (&regContent);
    }

    IsmDestroyObjectHandle (regObject);
}


VOID
pSaveRegSz (
    IN      PCTSTR InfKeyName,
    IN      PCTSTR Key,
    IN      PCTSTR Value
    )
{
    MIG_OBJECTSTRINGHANDLE regObject;
    MIG_CONTENT regContent;

    regObject = IsmCreateObjectHandle (Key, Value);

    if (IsmAcquireObject (g_RegType, regObject, &regContent)) {
        if (!regContent.ContentInFile &&
            regContent.MemoryContent.ContentBytes &&
            regContent.Details.DetailsSize == sizeof (DWORD) &&
            *((PDWORD) regContent.Details.DetailsData) == REG_SZ
            ) {
            IsmSetTransportVariable (
                PLATFORM_SOURCE,
                S_SOURCE_MACHINE_SECTION,
                InfKeyName,
                (PCTSTR) regContent.MemoryContent.ContentBytes
                );
        }

        IsmReleaseObject (&regContent);
    }

    IsmDestroyObjectHandle (regObject);
}


BOOL
WINAPI
ScriptVcmInitialize (
    IN      PMIG_LOGCALLBACK LogCallback,
    IN      PVOID Reserved
    )
{
    TCHAR buffer[256];
    DWORD d;
    PCTSTR domainName;
    PCTSTR userName;

    if (!pInitGlobals (LogCallback)) {
        return FALSE;
    }

    //
    // Save all the basic settings via the transport string interface
    //

    // version
    d = GetVersion();
    wsprintf (buffer, TEXT("0x%08x"), d);
    IsmSetTransportVariable (PLATFORM_SOURCE, S_SOURCE_MACHINE_SECTION, S_VERSION_INFKEY, buffer);

    // code page
    d = (DWORD) GetACP();
    wsprintf (buffer, TEXT("0x%08x"), d);
    IsmSetTransportVariable (PLATFORM_SOURCE, S_SOURCE_MACHINE_SECTION, S_ACP_INFKEY, buffer);

    //
    // MACRO EXPANSION LIST -- generate the code necessary to save the settings
    //                         described in the macro expansion list in v1p.h
    //

#define DEFMAC(infname,key,value)   pSaveRegDword(TEXT(infname),TEXT(key),TEXT(value));

    STANDARD_DWORD_SETTINGS

#undef DEFMAC

#define DEFMAC(infname,key,value)   pSaveRegSz(TEXT(infname),TEXT(key),TEXT(value));

    STANDARD_STRING_SETTINGS

    if (ISWIN9X()) {
        STANDARD_STRING_SETTINGS_9X
    } else {
        STANDARD_STRING_SETTINGS_NT
    }

#undef DEFMAC

    //
    // Save the current user
    //

    if (!pGetDomainUserName (&domainName, &userName)) {
        return FALSE;
    }

    IsmSetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_USER_INFKEY, userName);
    IsmSetEnvironmentString (
        PLATFORM_SOURCE,
        S_SYSENVVAR_GROUP,
        TEXT("USERNAME"),
        userName
        );
    AddStringMappingPair (g_EnvMap, TEXT("%USERNAME%"), userName);

    if (domainName) {
        IsmSetTransportVariable (PLATFORM_SOURCE, S_USER_SECTION, S_DOMAIN_INFKEY, domainName);
        IsmSetEnvironmentString (
            PLATFORM_SOURCE,
            S_SYSENVVAR_GROUP,
            TEXT("USERDOMAIN"),
            domainName
            );
        AddStringMappingPair (g_EnvMap, TEXT("%DOMAINNAME%"), domainName);
    }

    FreeText (userName);
    FreeText (domainName);

    //
    // Parse the script and do the rest of the business
    //

    return pCommonInit (Reserved, TRUE);
}


VOID
WINAPI
ScriptTerminate (
    VOID
    )
{
    HtFree (g_RenameSrcTable);
    g_RenameSrcTable = NULL;

    HtFree (g_RenameDestTable);
    g_RenameDestTable = NULL;

    HtFree (g_DePersistTable);
    g_DePersistTable = NULL;

    TerminateRestoreCallback ();
    TerminateSpecialRename();
    TerminateSpecialConversion();
    TerminateRules();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\v1p.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    v1p.h

Abstract:

    Header file for shared types, macros, etc., common to all v1 source files.

Author:

    Jim Schmidt (jimschm) 14-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "logmsg.h"

//
// Strings
//

#define S_SOURCE_MACHINE_SECTION    TEXT("Source Machine")
#define S_VERSION_INFKEY            TEXT("version")
#define S_ACP_INFKEY                TEXT("acp")
#define S_USER_SECTION              TEXT("User")
#define S_USER_INFKEY               TEXT("User")
#define S_DOMAIN_INFKEY             TEXT("Domain")

#define S_HKCU                      TEXT("HKCU")
#define S_HKCC                      TEXT("HKCC")
#define S_HKLM                      TEXT("HKLM")
#define S_HKR                       TEXT("HKR")

#define S_V1PROP_ICONDATA           TEXT("V1.PROP.ICONDATA")
#define S_V1PROP_FILECOLLPATTERN    TEXT("V1.PROP.FILECOLLPATTERN")

#define S_OE_COMPONENT              TEXT("$Outlook Express")
#define S_OUTLOOK9798_COMPONENT     TEXT("$Microsoft Outlook 97 & 98")
#define S_OFFICE_COMPONENT          TEXT("$Microsoft Office")
#define S_OE4_APPDETECT             TEXT("Outlook Express.OutlookExpress4")
#define S_OE5_APPDETECT             TEXT("Outlook Express.OutlookExpress5")
#define S_OUTLOOK9798_APPDETECT     TEXT("Microsoft Outlook 97 & 98.Outlook98.97")
#define S_OFFICE9798_APPDETECT      TEXT("Microsoft Office.Microsoft Office 97")

#define S_FIXED_DRIVES              TEXT("FIXED_DRIVES")


//
// Constants
//

#define ACTION_PERSIST                  0x0001
#define ACTION_PERSIST_PATH_IN_DATA     0x0002
#define ACTION_PERSIST_ICON_IN_DATA     0x0004

#define ACTION_PRIORITYSRC              0x0001
#define ACTION_PRIORITYDEST             0x0002

typedef enum {
    ACTIONGROUP_NONE = 0,
    ACTIONGROUP_DEFAULTPRIORITY,
    ACTIONGROUP_SPECIFICPRIORITY,
    ACTIONGROUP_FILECOLLPATTERN,
    ACTIONGROUP_EXCLUDE,
    ACTIONGROUP_EXCLUDEEX,
    ACTIONGROUP_INCLUDE,
    ACTIONGROUP_INCLUDEEX,
    ACTIONGROUP_RENAME,
    ACTIONGROUP_RENAMEEX,
    ACTIONGROUP_INCLUDERELEVANT,
    ACTIONGROUP_INCLUDERELEVANTEX,
    ACTIONGROUP_RENAMERELEVANT,
    ACTIONGROUP_RENAMERELEVANTEX,
    ACTIONGROUP_INCFILE,
    ACTIONGROUP_INCFILEEX,
    ACTIONGROUP_INCFOLDER,
    ACTIONGROUP_INCFOLDEREX,
    ACTIONGROUP_INCICON,
    ACTIONGROUP_INCICONEX,
    ACTIONGROUP_DELREGKEY,
} ACTIONGROUP, *PACTIONGROUP;

#define ACTIONWEIGHT_EXCLUDE            0x00000001
#define ACTIONWEIGHT_EXCLUDEEX          0x00000002
#define ACTIONWEIGHT_DELREGKEY          0x00000003
#define ACTIONWEIGHT_INCLUDE            0x00000004
#define ACTIONWEIGHT_INCLUDEEX          0x00000005
#define ACTIONWEIGHT_RENAME             0x00000006
#define ACTIONWEIGHT_RENAMEEX           0x00000007
#define ACTIONWEIGHT_INCLUDERELEVANT    0x00000008
#define ACTIONWEIGHT_INCLUDERELEVANTEX  0x00000009
#define ACTIONWEIGHT_RENAMERELEVANT     0x0000000A
#define ACTIONWEIGHT_RENAMERELEVANTEX   0x0000000B
#define ACTIONWEIGHT_INCFILE            0x0000000C
#define ACTIONWEIGHT_INCFILEEX          0x0000000D
#define ACTIONWEIGHT_INCFOLDER          0x0000000E
#define ACTIONWEIGHT_INCFOLDEREX        0x0000000F
#define ACTIONWEIGHT_INCICON            0x00000010
#define ACTIONWEIGHT_INCICONEX          0x00000011

#define ACTIONWEIGHT_DEFAULTPRIORITY    0x00000001
#define ACTIONWEIGHT_SPECIFICPRIORITY   0x10000000

#define ACTIONWEIGHT_FILECOLLPATTERN    0x00000000

typedef enum {
    RULEGROUP_NORMAL = 0,
    RULEGROUP_PRIORITY,
    RULEGROUP_COLLPATTERN
} RULEGROUP;


#define PFF_NO_PATTERNS_ALLOWED             0x0001
#define PFF_COMPUTE_BASE                    0x0002
#define PFF_NO_SUBDIR_PATTERN               0x0004
#define PFF_NO_LEAF_PATTERN                 0x0008
#define PFF_PATTERN_IS_DIR                  0x0010

#define PFF_NO_LEAF_AT_ALL                  (PFF_NO_LEAF_PATTERN|PFF_PATTERN_IS_DIR)

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PMAPSTRUCT AppEnvMapSrc;
    PMAPSTRUCT AppEnvMapDest;
    PMAPSTRUCT UndefEnvMapSrc;
    PMAPSTRUCT UndefEnvMapDest;
} APP_SPECIFIC_DATA, *PAPP_SPECIFIC_DATA;

typedef struct {
    MIG_OBJECTSTRINGHANDLE ObjectBase;
    MIG_OBJECTSTRINGHANDLE ObjectDest;
    MIG_OBJECTSTRINGHANDLE AddnlDest;
    PCTSTR ObjectHint;
    PAPP_SPECIFIC_DATA AppSpecificData;
} ACTION_STRUCT, *PACTION_STRUCT;

typedef struct {
    MIG_PLATFORMTYPEID Platform;
    PCTSTR ScriptSpecifiedType;
    PCTSTR ScriptSpecifiedObject;
    PCTSTR ApplicationName;

    PCTSTR ReturnString;
    union {
        struct _TAG_ISM_OBJECT {
            MIG_OBJECTTYPEID ObjectTypeId;
            MIG_OBJECTSTRINGHANDLE ObjectName;
            PMIG_CONTENT ObjectContent;
        };

        struct _TAG_OBJECT {
            UINT DataSize;
            PCBYTE Data;
        };
    };
} ATTRIB_DATA, *PATTRIB_DATA;

ETMINITIALIZE ScriptEtmInitialize;
ETMPARSE ScriptEtmParse;
ETMTERMINATE ScriptEtmTerminate;

ETMINITIALIZE CertificatesEtmInitialize;
ETMTERMINATE CertificatesEtmTerminate;
ETMNEWUSERCREATED CertificatesEtmNewUserCreated;

VCMINITIALIZE ScriptVcmInitialize;
VCMPARSE ScriptVcmParse;
VCMQUEUEENUMERATION ScriptVcmQueueEnumeration;
VCMTERMINATE ScriptTerminate;

SGMINITIALIZE ScriptSgmInitialize;
SGMPARSE ScriptSgmParse;
SGMQUEUEENUMERATION ScriptSgmQueueEnumeration;

DGMINITIALIZE ScriptDgmInitialize;
DGMQUEUEENUMERATION ScriptDgmQueueEnumeration;
CSMINITIALIZE ScriptCsmInitialize;
CSMTERMINATE ScriptCsmTerminate;
CSMEXECUTE ScriptCsmExecute;
OPMINITIALIZE ScriptOpmInitialize;
OPMTERMINATE ScriptOpmTerminate;

//
// Globals
//

extern PMAPSTRUCT g_EnvMap;
extern PMAPSTRUCT g_UndefMap;
extern PMAPSTRUCT g_RevEnvMap;
extern HASHTABLE g_RenameSrcTable;
extern HASHTABLE g_RenameDestTable;
extern HASHTABLE g_DePersistTable;
extern PMHANDLE g_V1Pool;
extern MIG_OBJECTTYPEID g_FileType;
extern MIG_OBJECTTYPEID g_RegType;
extern MIG_OBJECTTYPEID g_IniType;
extern MIG_OBJECTTYPEID g_CertType;
extern MIG_OPERATIONID g_RenameOp;
extern MIG_OPERATIONID g_RenameIniOp;
extern MIG_OPERATIONID g_RenameFileExOp;
extern MIG_OPERATIONID g_RenameFileOp;
extern MIG_OPERATIONID g_DeleteOp;
extern MIG_OPERATIONID g_RenameExOp;
extern MIG_OPERATIONID g_RenameIniExOp;
extern MIG_ATTRIBUTEID g_OsFileAttribute;
extern MIG_ATTRIBUTEID g_CopyIfRelevantAttr;
extern MIG_ATTRIBUTEID g_LockPartitionAttr;
extern MIG_PROPERTYID g_DefaultIconData;
extern MIG_PROPERTYID g_FileCollPatternData;
extern MIG_OPERATIONID g_DefaultIconOp;
extern MIG_OPERATIONID g_DestAddObject;
extern MIG_OPERATIONID g_RegAutoFilterOp;
extern MIG_OPERATIONID g_IniAutoFilterOp;
extern BOOL g_PreParse;
extern PMAPSTRUCT g_DestEnvMap;
extern PMAPSTRUCT g_FileNodeFilterMap;
extern BOOL g_OERulesMigrated;
extern GROWLIST g_SectionStack;

//
// Macro expansion lists
//

#define STANDARD_DWORD_SETTINGS                     \


#define STANDARD_STRING_SETTINGS                    \
    DEFMAC("timezone", "hklm\\System\\CurrentControlSet\\Control\\TimeZoneInformation", "StandardName") \
    DEFMAC("locale", "hklm\\System\\CurrentControlSet\\Control\\Nls\\Locale", "")                       \

#define STANDARD_STRING_SETTINGS_9X                 \
    DEFMAC("fullname", "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion", "RegisteredOwner")         \
    DEFMAC("orgname", "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion", "RegisteredOrganization")   \

#define STANDARD_STRING_SETTINGS_NT                 \
    DEFMAC("fullname", "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "RegisteredOwner")      \
    DEFMAC("orgname", "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "RegisteredOrganization")\


//
// Public function prototypes
//

MIG_OBJECTSTRINGHANDLE
MakeRegExBase (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    );

MIG_OBJECTSTRINGHANDLE
CreatePatternFromNodeLeaf (
    IN      PCTSTR Node,
    IN      PCTSTR Leaf
    );

MIG_OBJECTSTRINGHANDLE
TurnRegStringIntoHandle (
    IN      PCTSTR String,
    IN      BOOL Pattern,
    OUT     PBOOL HadLeaf           OPTIONAL
    );

MIG_OBJECTSTRINGHANDLE
TurnFileStringIntoHandle (
    IN      PCTSTR String,
    IN      DWORD Flags
    );

MIG_OBJECTSTRINGHANDLE
TurnIniSpecIntoHandle (
    IN      PCTSTR IniFile,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      BOOL NodePatternsAllowed,
    IN      BOOL LeafPatternsAllowed
    );

MIG_OBJECTSTRINGHANDLE
TurnCertSpecIntoHandle (
    IN      PCTSTR CertStore,
    IN      PCTSTR CertName,
    IN      BOOL PatternsAllowed
    );

BOOL
AllocScriptType (
    IN OUT      PATTRIB_DATA AttribData     CALLER_INITIALIZED
    );

BOOL
FreeScriptType (
    IN          PATTRIB_DATA AttribData     ZEROED
    );

VOID
InitSpecialConversion (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
TerminateSpecialConversion (
    VOID
    );

VOID
InitSpecialRename (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
TerminateSpecialRename (
    VOID
    );

VOID
InitRules (
    VOID
    );

VOID
TerminateRules (
    VOID
    );

BOOL
AddRuleEx (
    IN      MIG_OBJECTTYPEID Type,
    IN      MIG_OBJECTSTRINGHANDLE ObjectBase,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      ACTIONGROUP ActionGroup,
    IN      DWORD ActionFlags,
    IN      PACTION_STRUCT ActionStruct,    OPTIONAL
    IN      RULEGROUP RuleGroup
    );

#define AddRule(t,b,p,g,f,s) AddRuleEx(t,b,p,g,f,s,RULEGROUP_NORMAL)

BOOL
QueryRuleEx (
    IN      MIG_OBJECTTYPEID Type,
    IN      MIG_OBJECTSTRINGHANDLE EncodedString,
    IN      PCTSTR ObjectNode,
    OUT     PACTIONGROUP ActionGroup,
    OUT     PDWORD ActionFlags,
    OUT     PACTION_STRUCT ActionStruct,    OPTIONAL
    IN      RULEGROUP RuleGroup
    );

#define QueryRule(t,e,n,g,f,s) QueryRuleEx(t,e,n,g,f,s,RULEGROUP_NORMAL)


//
// renregfn.c
//

BOOL
DoRegistrySpecialConversion (
    IN      HINF InfHandle,
    IN      PCTSTR Section
    );

BOOL
DoRegistrySpecialRename (
    IN      HINF InfHandle,
    IN      PCTSTR Section
    );

BOOL
AddSpecialRenameRule (
    IN      PCTSTR Pattern,
    IN      PCTSTR Function
);

//
// sgmutils.c
//

PCTSTR
GetShellFolderPath (
    IN      INT Folder,
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder,
    OUT     PTSTR Buffer
    );

PCTSTR
GetAllUsersProfilePath (
    OUT     PTSTR Buffer
    );

PCTSTR
GetUserProfileRootPath (
    OUT     PTSTR Buffer
    );

PCTSTR
IsValidUncPath (
    IN      PCTSTR Path
    );

BOOL
IsValidFileSpec (
    IN      PCTSTR FileSpec
    );

VOID
QueueAllFiles (
    IN      BOOL VcmMode
    );

VOID
AddRemappingEnvVar (
    IN      PMAPSTRUCT Map,
    IN      PMAPSTRUCT ReMap,
    IN      PMAPSTRUCT UndefMap,            OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableData
    );

VOID
SetIsmEnvironmentFromPhysicalMachine (
    IN      PMAPSTRUCT Map,
    IN      BOOL MapDestToSource,
    IN      PMAPSTRUCT UndefMap             OPTIONAL
    );

VOID
SetIsmEnvironmentFromVirtualMachine (
    IN      PMAPSTRUCT DirectMap,
    IN      PMAPSTRUCT ReverseMap,
    IN      PMAPSTRUCT UndefMap
    );

//
// app.c
//

PCTSTR
GetMostSpecificSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfFile,
    IN      PCTSTR BaseSection
    );

VOID
InitAppModule (
    VOID
    );

VOID
TerminateAppModule (
    VOID
    );

PAPP_SPECIFIC_DATA
FindAppSpecificData (
    IN      PCTSTR AppTag
    );

BOOL
AppCheckAndLogUndefVariables (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR UnexpandedString
    );

BOOL
AppSearchAndReplace (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Application,
    IN      PCTSTR UnexpandedString,
    OUT     PTSTR ExpandedString,
    IN      UINT ExpandedStringTchars
    );

BOOL
ParseOneApplication (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      BOOL PreParse,
    IN      UINT MasterGroup,
    IN      PCTSTR Application,
    IN      PCTSTR LocSection,
    IN      PCTSTR AliasType,
    IN      PCTSTR MultiSz
    );

BOOL
ParseApplications (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      BOOL PreParse,
    IN      UINT MasterGroup
    );

BOOL
ProcessFilesAndFolders (
    IN      HINF InfHandle,
    IN      PCTSTR Section,
    IN      BOOL PreParse
    );

BOOL
ParseAppDetectSection (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      HINF InfFile,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    );

//
// sgmcallback.c
//

MIG_OBJECTENUMCALLBACK GatherVirtualComputer;
MIG_OBJECTENUMCALLBACK PrepareActions;
MIG_OBJECTENUMCALLBACK NulCallback;
MIG_OBJECTENUMCALLBACK ObjectPriority;
MIG_OBJECTENUMCALLBACK FileCollPattern;
MIG_OBJECTENUMCALLBACK ExcludeKeyIfValueExists;
MIG_OBJECTENUMCALLBACK LockPartition;
MIG_POSTENUMCALLBACK PostDelregKeyCallback;

//
// sgmqueue.c
//

BOOL
ParseInfInstructions (
    IN      HINF InfHandle,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    );

BOOL
ParseTranslationSection (
    IN      HINF InfHandle,
    IN      PCTSTR Application,
    IN      PCTSTR Section
    );

//
// attrib.c
//

BOOL
TestAttributes (
    IN      PMHANDLE WorkPool,
    IN      PCTSTR ArgumentMultiSz,
    IN      PATTRIB_DATA AttribData
    );

//
// opm.c
//
BOOL
WINAPI
FilterRenameExFilter (
    IN      PCMIG_FILTERINPUT InputData,
    OUT     PMIG_FILTEROUTPUT OutputData,
    IN      BOOL NoRestoreObject,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    );

//
// regconv.c
//
BOOL
DoesDestRegExist (
    IN      MIG_OBJECTSTRINGHANDLE DestName,
    IN      DWORD RegType
    );

BOOL
IsValidRegSz (
    IN      PCMIG_CONTENT CurrentContent
    );

BOOL
IsValidRegType (
    IN      PCMIG_CONTENT CurrentContent,
    IN      DWORD RegType
    );

BOOL
CreateDwordRegObject (
    IN      PCTSTR KeyStr,
    IN      PCTSTR ValueName,
    IN      DWORD Value
    );

// oeutils.c

VOID
OETerminate (
    VOID
    );

BOOL
OEIsIdentityAssociated (
    IN      PTSTR IdStr
    );

BOOL
OEIAMAssociateId (
    IN      PTSTR SrcId
    );

PTSTR
OEGetRemappedId (
    IN      PCTSTR IdStr
    );

PTSTR
OEGetAssociatedId (
    IN      MIG_PLATFORMTYPEID Platform
    );

PTSTR
OEGetDefaultId (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
WABMerge (
    VOID
    );

VOID
OE5MergeStoreFolders (
    VOID
    );

VOID
OE4MergeStoreFolder (
    VOID
    );

BOOL
OE5RemapDefaultId (
    VOID
    );

BOOL
OEAddComplexRules (
    VOID
    );

PTSTR
OECreateFirstIdentity (
    VOID
    );

BOOL
OEInitializeIdentity (
    VOID
    );

BOOL
OEFixLastUser (
    VOID
    );


//
// restore.c
//
BOOL
InitRestoreCallback (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
TerminateRestoreCallback (
    VOID
    );

//
// cert.c
//
BOOL
CertificatesInitialize (
    VOID
    );

VOID
CertificatesTerminate (
    VOID
    );

//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\ansi\pch.h ===
#include "baseinc.h"
#include "allutils.h"
#include "ism.h"
#include "modules.h"
#include "..\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\vcm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    vcm.c

Abstract:

    Implements the script parser and virtual computer building code

Author:

    Jim Schmidt (jimschm) 12-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"

#define DBG_V1  "v1"

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\modules\script\oecheckin\regconv.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regconv.c

Abstract:

    Implements registry special conversion.

Author:

    Calin Negreanu (calinn) 5-May-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "v1p.h"
#include <wingdip.h>
#include <shlobjp.h>
#include <shlwapi.h>


//
// Strings
//

#define DBG_CONVERSION  "SpecialConversion"

//
// Constants
//

#define COLOR_MENU              4
#define COLOR_HIGHLIGHT         13
#define COLOR_BTNFACE           15
#define COLOR_BUTTONALTFACE     25
#define COLOR_HOTLIGHT          26
#define COLOR_GRADIENTACTIVECAPTION 27
#define COLOR_GRADIENTINACTIVECAPTION 28
#define COLOR_MENUHILIGHT       29
#define COLOR_MENUBAR           30

#define DISPLAY_BITMASK     0x00161E2F
#define MOUSE_BITMASK       0x0001E000

//
// Macros
//

#define pGetDestDwordValue(Key,Value) pGetDwordValue(Key, Value, PLATFORM_DESTINATION)
#define pGetSrcDwordValue(Key,Value) pGetDwordValue(Key, Value, PLATFORM_SOURCE)


//
// Types
//

typedef struct {
    SHORT lfHeight;
    SHORT lfWidth;
    SHORT lfEscapement;
    SHORT lfOrientation;
    SHORT lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    char lfFaceName[LF_FACESIZE];
} SHORT_LOGFONT, *PSHORT_LOGFONT;

//
// NT uses only UNICODE structures, and pads the members
// to 32-bit boundaries.
//

#define COLOR_MAX_V1 25
#define COLOR_MAX_V2 25
#define COLOR_MAX_V3 25
#define COLOR_MAX_V4 29
#define COLOR_MAX_NT 29     // this is a modified version 2 format, similar to 4

typedef struct {
    SHORT version;              // 2 for NT UNICODE
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_NT];
} SCHEMEDATA_NT, *PSCHEMEDATA_NT;

//
// Win95 uses NONCLIENTMETRICSA which has LOGFONTA members,
// but it uses a 16-bit LOGFONT as well.
//

#pragma pack(push)
#pragma pack(1)

typedef struct {
    SHORT version;              // 1 for Win95 ANSI
    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V1];
} SCHEMEDATA_V1, *PSCHEMEDATA_V1;

typedef struct {
    SHORT version;              // 1 for Win95 ANSI

    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V1A, *PSCHEMEDATA_V1A;

typedef struct {
    SHORT version;              // 2 for WinNT UNICODE with reduced color table
    WORD Dummy;
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_V2];
} SCHEMEDATA_V2, *PSCHEMEDATA_V2;

typedef struct {
    SHORT version;              // 3 for Win98 ANSI, 4 for portable format
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V3];
} SCHEMEDATA_V3, *PSCHEMEDATA_V3;

typedef struct {
    SHORT version;              // 4 for Win32 format (whatever that means)
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V4, *PSCHEMEDATA_V4;

#pragma pack(pop)

typedef struct
{
    UINT cbSize;
    SHELLSTATE ss;
} REGSHELLSTATE, *PREGSHELLSTATE;

typedef BOOL (STDMETHODCALLTYPE ISCOLLISION)(
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCTSTR OriginalName
    );
typedef ISCOLLISION FAR *LPISCOLLISION;

//
// Globals
//

MIG_OPERATIONID g_ConvertToDwordOp;
MIG_OPERATIONID g_ConvertToStringOp;
DWORD g_IdentityCount = 0;
HASHTABLE g_IdentityDestTable;
HASHTABLE g_AccountCollisionTable;

//
// Macro expansion list
//

#define CONVERSION_FUNCTIONS        \
        DEFMAC(CONVERTTODWORD,          NULL,   EDIT.ConvertToDword,            pConvertToDwordCallback         )  \
        DEFMAC(CONVERTTOSTRING,         NULL,   EDIT.ConvertToString,           pConvertToStringCallback        )  \
        DEFMAC(CONVERTLOGFONT,          NULL,   EDIT.ConvertLogFont,            pConvertLogFontCallback         )  \
        DEFMAC(ANTIALIAS,               NULL,   EDIT.AntiAlias,                 pAntiAliasCallback              )  \
        DEFMAC(FIXACTIVEDESKTOP,        NULL,   EDIT.FixActiveDesktop,          pFixActiveDesktopCallback       )  \
        DEFMAC(CONVERTRECENTDOCSMRU,    NULL,   EDIT.ConvertRecentDocsMRU,      pConvertRecentDocsMRUCallback   )  \
        DEFMAC(CONVERTAPPEARANCESCHEME, NULL,   EDIT.ConvertAppearanceScheme,   pConvertAppearanceSchemeCallback)  \
        DEFMAC(CONVERTSCNSAVER,         NULL,   EDIT.ConvertScnSaver,           pConvertScnSaver                )  \
        DEFMAC(CONVERTOE4IAMACCTNAME,   NULL,   EDIT.ConvertOE4IAMAcctName,     pConvertOE4IAMAcctName          )  \
        DEFMAC(CONVERTOE5IAMACCTNAME,   NULL,   EDIT.ConvertOE5IAMAcctName,     pConvertOE5IAMAcctName          )  \
        DEFMAC(CONVERTIAMACCTNAME,      NULL,   EDIT.ConvertIAMAcctName,        pConvertIAMAcctName             )  \
        DEFMAC(CONVERTCOLLIDEACCTNAME,  NULL,   EDIT.ConvertCollideAcctName,    pConvertCollideAcctName         )  \
        DEFMAC(CONVERTOMIACCOUNTNAME,   NULL,   EDIT.ConvertOMIAccountName,     pConvertOMIAccountName          )  \
        DEFMAC(CONVERTIDENTITYCOUNT,    NULL,   EDIT.ConvertIdentityCount,      pConvertIdentityCount           )  \
        DEFMAC(CONVERTIDENTITYINDEX,    NULL,   EDIT.ConvertIdentityIndex,      pConvertIdentityIndex           )  \
        DEFMAC(CONVERTIDENTITYUSERNAME, NULL,   EDIT.ConvertIdentityUsername,   pConvertIdentityUsername        )  \
        DEFMAC(CONVERTIDENTITYGUID,     NULL,   EDIT.ConvertIdentityGuid,       pConvertIdentityGuid            )  \
        DEFMAC(CONVERTOE5STATIONERY,    NULL,   Edit.ConvertOE5Stationery,      pConvertOE5Stationery           )  \
        DEFMAC(CONVERTSETDWORDTRUE,     NULL,   EDIT.ConvertSetDwordTrue,       pConvertSetDwordTrue            )  \
        DEFMAC(CONVERTSETDWORDFALSE,    NULL,   EDIT.ConvertSetDwordFalse,      pConvertSetDwordFalse           )  \
        DEFMAC(CONVERTPSTBLOB,          NULL,   EDIT.ConvertPSTBlob,            pConvertPSTBlob                 )  \
        DEFMAC(CONVERTOFFICELANGID,     NULL,   EDIT.ConvertOfficeLangId,       pConvertOfficeLangId            )  \
        DEFMAC(CONVERTOUTLOOKLANGID,    NULL,   EDIT.ConvertOutlookLangId,      pConvertOutlookLangId           )  \
        DEFMAC(CONVERTACCESSLANGID,     NULL,   EDIT.ConvertAccessLangId,       pConvertAccessLangId            )  \
        DEFMAC(CONVERTEXCELLANGID,      NULL,   EDIT.ConvertExcelLangId,        pConvertExcelLangId             )  \
        DEFMAC(CONVERTFRONTPAGELANGID,  NULL,   EDIT.ConvertFrontPageLangId,    pConvertFrontPageLangId         )  \
        DEFMAC(CONVERTPOWERPOINTLANGID, NULL,   EDIT.ConvertPowerPointLangId,   pConvertPowerPointLangId        )  \
        DEFMAC(CONVERTPUBLISHERLANGID,  NULL,   EDIT.ConvertPublisherLangId,    pConvertPublisherLangId         )  \
        DEFMAC(CONVERTWORDLANGID,       NULL,   EDIT.ConvertWordLangId,         pConvertWordLangId              )  \
        DEFMAC(CONVERTOFFICE2000LANGID, NULL,   EDIT.ConvertOffice2000LangId,   pConvertOffice2000LangId        )  \
        DEFMAC(MIGRATESOUNDSYSTRAY,     NULL,   EDIT.MigrateSoundSysTray,       pMigrateSoundSysTray            )  \
        DEFMAC(MIGRATEAPPEARANCEUPM,    NULL,   EDIT.MigrateAppearanceUPM,      pMigrateAppearanceUPM           )  \
        DEFMAC(MIGRATEMOUSEUPM,         NULL,   EDIT.MigrateMouseUPM,           pMigrateMouseUPM                )  \
        DEFMAC(MIGRATEOFFLINESYSTRAY,   NULL,   EDIT.MigrateOfflineSysTray,     pMigrateOfflineSysTray          )  \
        DEFMAC(MIGRATEDISPLAYSS,        NULL,   EDIT.MigrateDisplaySS,          pMigrateDisplaySS               )  \
        DEFMAC(MIGRATEDISPLAYCS,        NULL,   EDIT.MigrateDisplayCS,          pMigrateDisplayCS               )  \
        DEFMAC(MIGRATETASKBARSSPRESERVE,NULL,   EDIT.MigrateTaskBarSSPreserve,  pMigrateTaskBarSSPreserve       )  \
        DEFMAC(MIGRATETASKBARSSFORCE,   NULL,   EDIT.MigrateTaskBarSSForce,     pMigrateTaskBarSSForce          )  \
        DEFMAC(CONVERTSHOWIEONDESKTOP,  NULL,   EDIT.ConvertShowIEOnDesktop,    pConvertShowIEOnDesktop         )  \
        DEFMAC(MIGRATEACTIVEDESKTOP,    NULL,   EDIT.MigrateActiveDesktop,      pMigrateActiveDesktop           )  \


//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

//
// Declare special conversion operation apply callback functions
//
#define DEFMAC(ifn,ec,opn,opc) OPMAPPLYCALLBACK opc;
CONVERSION_FUNCTIONS
#undef DEFMAC

//
// This is the structure used for handling action functions
//
typedef struct {
    PCTSTR InfFunctionName;
    PSGMENUMERATIONCALLBACK EnumerationCallback;
    PCTSTR OperationName;
    MIG_OPERATIONID OperationId;
    POPMAPPLYCALLBACK OperationCallback;
} CONVERSION_STRUCT, *PCONVERSION_STRUCT;

//
// Declare a global array of conversion functions
//
#define DEFMAC(ifn,ec,opn,opc) {TEXT("\\")TEXT(#ifn),ec,TEXT(#opn),0,opc},
static CONVERSION_STRUCT g_ConversionFunctions[] = {
                              CONVERSION_FUNCTIONS
                              {NULL, NULL, NULL, 0, NULL}
                              };
#undef DEFMAC

//
// Code
//

BOOL
IsValidRegSz(
    IN      PCMIG_CONTENT ObjectContent
    )
{
    return ((!ObjectContent->ContentInFile) &&
            (ObjectContent->MemoryContent.ContentSize) &&
            (ObjectContent->MemoryContent.ContentBytes) &&
            (ObjectContent->Details.DetailsSize == sizeof (DWORD)) &&
            (ObjectContent->Details.DetailsData) &&
            ((*((PDWORD)ObjectContent->Details.DetailsData) == REG_SZ) ||
             (*((PDWORD)ObjectContent->Details.DetailsData) == REG_EXPAND_SZ)));
}

BOOL
IsValidRegType (
    IN      PCMIG_CONTENT CurrentContent,
    IN      DWORD RegType
    )
{
    return ((!CurrentContent->ContentInFile) &&
            (CurrentContent->Details.DetailsSize == sizeof (DWORD)) &&
            (CurrentContent->Details.DetailsData) &&
            (*((PDWORD)CurrentContent->Details.DetailsData) == RegType) &&
            (CurrentContent->MemoryContent.ContentSize) &&
            (CurrentContent->MemoryContent.ContentBytes));
}

DWORD
pGetDwordValue (
    IN      PTSTR Key,
    IN      PTSTR Value,
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    DWORD value = 0;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;

    objectName = IsmCreateObjectHandle (Key, Value);

    if (IsmAcquireObject (g_RegType | Platform, objectName, &objectContent)) {
        if (IsValidRegType(&objectContent, REG_DWORD)) {
            value = *(DWORD *)objectContent.MemoryContent.ContentBytes;
        }
        IsmReleaseObject (&objectContent);
    }
    IsmDestroyObjectHandle (objectName);

    return value;
}


VOID
pSetDwordValue (
    OUT     PMIG_CONTENT NewContent,
    IN      DWORD Value
    )
{
    NewContent->Details.DetailsSize = sizeof(DWORD);
    NewContent->Details.DetailsData = IsmGetMemory (sizeof (DWORD));
    *((PDWORD)NewContent->Details.DetailsData) = REG_DWORD;
    NewContent->MemoryContent.ContentSize = sizeof (DWORD);
    NewContent->MemoryContent.ContentBytes = IsmGetMemory (sizeof(DWORD));
    *((PDWORD)NewContent->MemoryContent.ContentBytes) = Value;
}


UINT
pDefaultEnumerationCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    PCONVERSION_STRUCT p = (PCONVERSION_STRUCT)CallerArg;

    if (Data->IsLeaf) {
        IsmSetOperationOnObject (Data->ObjectTypeId, Data->ObjectName, p->OperationId, NULL, NULL);
    }
    return CALLBACK_ENUM_CONTINUE;
}

PCONVERSION_STRUCT
pGetConversionStruct (
    IN      PCTSTR FunctionName
    )
{
    PCONVERSION_STRUCT p = g_ConversionFunctions;
    INT i = 0;
    while (p->InfFunctionName != NULL) {
        if (StringIMatch (p->InfFunctionName, FunctionName)) {
            return p;
        }
        p++;
        i++;
    }
    return NULL;
}

VOID
InitSpecialConversion (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PCONVERSION_STRUCT p = g_ConversionFunctions;

    while (p->InfFunctionName) {
        p->OperationId = IsmRegisterOperation (p->OperationName, FALSE);
        if (Platform == PLATFORM_DESTINATION) {
            IsmRegisterOperationApplyCallback (p->OperationId, p->OperationCallback, TRUE);
        }
        p++;
    }

    g_IdentityDestTable = HtAllocWithData (sizeof (PTSTR));
    g_AccountCollisionTable = HtAllocWithData (sizeof (PTSTR));

    if (Platform == PLATFORM_DESTINATION) {
        // Read the starting Identity count
        g_IdentityCount = pGetDestDwordValue (TEXT("HKCU\\Identities"), TEXT("Identity Ordinal"));
    }
}

VOID
TerminateSpecialConversion (
    VOID
    )
{
    HtFree (g_IdentityDestTable);
    g_IdentityDestTable = NULL;

    HtFree (g_AccountCollisionTable);
    g_AccountCollisionTable = NULL;

    OETerminate();
}

BOOL
pProcessDataConversionSection (
    IN      PINFSTRUCT InfStruct,
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR pattern;
    ENCODEDSTRHANDLE encodedPattern = NULL;
    PCTSTR functionName;
    PCONVERSION_STRUCT functionStruct = NULL;
    BOOL result = FALSE;

    __try {
        if (InfFindFirstLine (InfHandle, Section, NULL, InfStruct)) {
            do {

                if (IsmCheckCancel()) {
                    __leave;
                }

                pattern = InfGetStringField (InfStruct, 0);

                if (!pattern) {
                    continue;
                }
                encodedPattern = TurnRegStringIntoHandle (pattern, TRUE, NULL);

                functionName = InfGetStringField (InfStruct, 1);

                if (functionName) {

                    functionStruct = pGetConversionStruct (functionName);

                    if (functionStruct) {
                        IsmHookEnumeration (
                            MIG_REGISTRY_TYPE,
                            encodedPattern,
                            functionStruct->EnumerationCallback?
                                functionStruct->EnumerationCallback:
                                pDefaultEnumerationCallback,
                            (ULONG_PTR)functionStruct,
                            functionStruct->InfFunctionName
                            );

                    } else {
                        LOG ((
                            LOG_ERROR,
                            (PCSTR) MSG_DATA_CONVERSION_BAD_FN,
                            functionName,
                            pattern
                            ));
                    }
                } else {
                    LOG ((LOG_ERROR, (PCSTR) MSG_DATA_CONVERSION_NO_FN, pattern));
                }

                IsmDestroyObjectHandle (encodedPattern);
                encodedPattern = NULL;
            } while (InfFindNextLine (InfStruct));
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (InfStruct);
    }

    return result;
}

BOOL
DoRegistrySpecialConversion (
    IN      HINF InfHandle,
    IN      PCTSTR Section
    )
{
    PCTSTR osSpecificSection;
    BOOL b;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;

    b = pProcessDataConversionSection (&is, InfHandle, Section);

    if (b) {
        osSpecificSection = GetMostSpecificSection (PLATFORM_SOURCE, &is, InfHandle, Section);

        if (osSpecificSection) {
            b = pProcessDataConversionSection (&is, InfHandle, osSpecificSection);
            FreeText (osSpecificSection);
        }
    }

    InfCleanUpInfStruct (&is);
    return b;
}

BOOL
DoesDestRegExist (
    IN      MIG_OBJECTSTRINGHANDLE DestName,
    IN      DWORD RegType
    )
{
    BOOL result = FALSE;
    MIG_CONTENT content;

    if (IsmAcquireObject (g_RegType | PLATFORM_DESTINATION, DestName, &content)) {
        if (IsValidRegType(&content, RegType)) {
            result = TRUE;
        }
        IsmReleaseObject (&content);
    }

    return result;
}

BOOL
WINAPI
pConvertToDwordCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value = 0;
    BOOL converted = FALSE;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {
            converted = TRUE;
            if (CurrentContent->MemoryContent.ContentSize > 0) {
                value = _tcstoul ((PCTSTR)CurrentContent->MemoryContent.ContentBytes, NULL, 10);
            }
        } else if (*valueType == REG_BINARY ||
                   *valueType == REG_NONE ||
                   *valueType == REG_DWORD
                   ) {
            if (CurrentContent->MemoryContent.ContentSize == sizeof (DWORD)) {
                converted = TRUE;
                value = *((PDWORD)CurrentContent->MemoryContent.ContentBytes);
            }
        }
        if (converted) {
            pSetDwordValue (NewContent, value);
        }
    }

    return TRUE;
}

BOOL
WINAPI
pConvertToStringCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PTSTR result = NULL;
    PTSTR resultPtr;
    UINT i;
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_DWORD) {

            MYASSERT (CurrentContent->MemoryContent.ContentSize == sizeof (DWORD));

            if (CurrentContent->MemoryContent.ContentSize == sizeof (DWORD)) {

                converted = TRUE;
                convertedSize = 11 * sizeof (TCHAR); // DWORD takes no more than 11 characters
                result = IsmGetMemory (convertedSize);
                if (result) {
                    wsprintf (result, TEXT("%lu"), *((PDWORD)CurrentContent->MemoryContent.ContentBytes));
                    convertedSize = SizeOfString (result);
                }
            }

        } else if (*valueType == REG_BINARY) {

            converted = TRUE;
            convertedSize = (CurrentContent->MemoryContent.ContentSize?(CurrentContent->MemoryContent.ContentSize * 3):1) * sizeof (TCHAR);
            result = IsmGetMemory (convertedSize);
            if (result) {
                resultPtr = result;
                *resultPtr = 0;
                for (i = 0; i < CurrentContent->MemoryContent.ContentSize; i++) {
                    wsprintf (resultPtr, TEXT("%02X"), CurrentContent->MemoryContent.ContentBytes[i]);
                    resultPtr = GetEndOfString (resultPtr);
                    if (i < CurrentContent->MemoryContent.ContentSize - 1) {
                        _tcscat (resultPtr, TEXT(" "));
                        resultPtr = GetEndOfString (resultPtr);
                    }
                }
                convertedSize = SizeOfString (result);
            }
        }
        if (converted && convertedSize && result) {
            NewContent->Details.DetailsSize = sizeof (DWORD);
            NewContent->Details.DetailsData = IsmGetMemory (NewContent->Details.DetailsSize);
            *((PDWORD)NewContent->Details.DetailsData) = REG_SZ;
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = (PCBYTE) result;
        }
    }

    return TRUE;
}

VOID
pConvertShortLogFontWorker (
    PLOGFONTW plfDest,
    PSHORT_LOGFONT plfSrc
    )
{
    PCWSTR faceName;

    if (plfSrc->lfHeight > 0) {
        plfDest->lfHeight = 0xFFFFFFFF - plfSrc->lfHeight - ((plfSrc->lfHeight + 1) / 3) + 1;
    } else {
        plfDest->lfHeight = plfSrc->lfHeight;
    }
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;\
    faceName = ConvertAtoW (plfSrc->lfFaceName);
    StringCopyByteCountW (plfDest->lfFaceName, faceName, sizeof (plfDest->lfFaceName));
    FreeConvertedStr (faceName);
}

VOID
pConvertLogFontWorker (
    PLOGFONTW plfDest,
    PLOGFONTA plfSrc
    )
{
    PCWSTR faceName;

    if (plfSrc->lfHeight > 0) {
        plfDest->lfHeight = 0xFFFFFFFF - plfSrc->lfHeight + 1 + ((plfSrc->lfHeight + 1) / 3);
    } else {
        plfDest->lfHeight = plfSrc->lfHeight;
    }
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;\
    faceName = ConvertAtoW (plfSrc->lfFaceName);
    StringCopyByteCountW (plfDest->lfFaceName, faceName, sizeof (plfDest->lfFaceName));
    FreeConvertedStr (faceName);
}

VOID
pCopyLogFontWorker (
    PLOGFONTW plfDest,
    PLOGFONTW plfSrc
    )
{
    PCWSTR faceName;

    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;\
    StringCopyByteCountW (plfDest->lfFaceName, plfSrc->lfFaceName, sizeof (plfDest->lfFaceName));
}

BOOL
WINAPI
pConvertLogFontCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PLOGFONTW logFont = NULL;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {

            if (CurrentContent->MemoryContent.ContentSize == sizeof (SHORT_LOGFONT)) {

                converted = TRUE;
                convertedSize = sizeof (LOGFONTW);
                logFont = (PLOGFONTW) IsmGetMemory (convertedSize);
                ZeroMemory (logFont, sizeof (LOGFONTW));
                pConvertShortLogFontWorker (logFont, (PSHORT_LOGFONT)CurrentContent->MemoryContent.ContentBytes);
            }

            if (CurrentContent->MemoryContent.ContentSize == sizeof (LOGFONTA)) {

                converted = TRUE;
                convertedSize = sizeof (LOGFONTW);
                logFont = (PLOGFONTW) IsmGetMemory (convertedSize);
                ZeroMemory (logFont, sizeof (LOGFONTW));
                pConvertLogFontWorker (logFont, (PLOGFONTA)CurrentContent->MemoryContent.ContentBytes);
            }
        }

        if (converted && convertedSize && logFont) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = (PBYTE)logFont;
        }
    }

    return TRUE;
}

VOID
pConvertNonClientMetrics (
    OUT     NONCLIENTMETRICSW *Dest,
    IN      NONCLIENTMETRICSA *Src
    )
{
    Dest->cbSize = sizeof (NONCLIENTMETRICSW);
    Dest->iBorderWidth = Src->iBorderWidth;
    Dest->iScrollWidth = Src->iScrollWidth;
    Dest->iScrollHeight = Src->iScrollHeight;
    Dest->iCaptionWidth = Src->iCaptionWidth;
    Dest->iCaptionHeight = Src->iCaptionHeight;
    Dest->iSmCaptionWidth = Src->iSmCaptionWidth;
    Dest->iSmCaptionHeight = Src->iSmCaptionHeight;
    Dest->iMenuWidth = Src->iMenuWidth;
    Dest->iMenuHeight = Src->iMenuHeight;

    pConvertLogFontWorker (&Dest->lfCaptionFont, &Src->lfCaptionFont);
    pConvertLogFontWorker (&Dest->lfSmCaptionFont, &Src->lfSmCaptionFont);
    pConvertLogFontWorker (&Dest->lfMenuFont, &Src->lfMenuFont);
    pConvertLogFontWorker (&Dest->lfStatusFont, &Src->lfStatusFont);
    pConvertLogFontWorker (&Dest->lfMessageFont, &Src->lfMessageFont);
}

VOID
pCopyNonClientMetrics (
    OUT     NONCLIENTMETRICSW *Dest,
    IN      NONCLIENTMETRICSW *Src
    )
{
    Dest->cbSize = sizeof (NONCLIENTMETRICSW);
    Dest->iBorderWidth = Src->iBorderWidth;
    Dest->iScrollWidth = Src->iScrollWidth;
    Dest->iScrollHeight = Src->iScrollHeight;
    Dest->iCaptionWidth = Src->iCaptionWidth;
    Dest->iCaptionHeight = Src->iCaptionHeight;
    Dest->iSmCaptionWidth = Src->iSmCaptionWidth;
    Dest->iSmCaptionHeight = Src->iSmCaptionHeight;
    Dest->iMenuWidth = Src->iMenuWidth;
    Dest->iMenuHeight = Src->iMenuHeight;

    pCopyLogFontWorker (&Dest->lfCaptionFont, &Src->lfCaptionFont);
    pCopyLogFontWorker (&Dest->lfSmCaptionFont, &Src->lfSmCaptionFont);
    pCopyLogFontWorker (&Dest->lfMenuFont, &Src->lfMenuFont);
    pCopyLogFontWorker (&Dest->lfStatusFont, &Src->lfStatusFont);
    pCopyLogFontWorker (&Dest->lfMessageFont, &Src->lfMessageFont);
}

#define S_SCHEMELOCATION    TEXT("HKCU\\Control Panel\\Appearance\\New Schemes")
#define S_SCHEMECURRENT     TEXT("HKCU\\Control Panel\\Appearance")
#define S_SCHEMELOCATIONT1  TEXT("HKCU\\Control Panel\\Appearance\\New Schemes\\Current Settings SaveAll\\Sizes\\0")
#define S_SCHEMELOCATIONT2  TEXT("HKCU\\Control Panel\\Appearance\\New Schemes\\Current Settings SaveNoVisualStyle\\Sizes\\0")
#define S_SCHEMECOLORS      TEXT("HKCU\\Control Panel\\Colors")
#define S_SCHEMEMETRICS     TEXT("HKCU\\Control Panel\\Desktop\\WindowMetrics")

BOOL
pFindWhistlerScheme (
    IN      PCTSTR SchemeName,
    OUT     PUINT SchemeNr,
    OUT     PUINT SchemeSize
    )
{
    BOOL result = FALSE;
    HKEY rootKey = NULL;
    HKEY schemeKey = NULL;
    HKEY sizeKey = NULL;
    HKEY currSizeKey = NULL;
    TCHAR schemeNrStr [MAX_PATH + 1];
    TCHAR schemeSizeStr [MAX_PATH + 1];
    PCTSTR subKeyStr = NULL;
    DWORD index = 0, index1 = 0;
    INT maxScheme = -1;
    INT currScheme = 0;
    LONG err, err1, err2;
    DWORD valueType = 0;
    DWORD valueDataSize = 0;
    PTSTR valueData = NULL;

    *SchemeNr = 0;
    *SchemeSize = 0;

    rootKey = OpenRegKeyStr (S_SCHEMELOCATION);
    if (rootKey) {
        index = 0;
        err = ERROR_SUCCESS;
        while (err == ERROR_SUCCESS) {
            err = RegEnumKey (rootKey, index, schemeNrStr, MAX_PATH + 1);
            if (err == ERROR_SUCCESS) {
                currScheme = _ttoi (schemeNrStr);
                if (currScheme > maxScheme) {
                    maxScheme = currScheme;
                }
                subKeyStr = JoinPaths (schemeNrStr, TEXT("Sizes"));
                if (subKeyStr) {
                    sizeKey = OpenRegKey (rootKey, subKeyStr);
                    if (sizeKey) {
                        index1 = 0;
                        err1 = ERROR_SUCCESS;
                        while (err1 == ERROR_SUCCESS) {
                            err1 = RegEnumKey (sizeKey, index1, schemeSizeStr, MAX_PATH + 1);
                            if (err1 == ERROR_SUCCESS) {
                                currSizeKey = OpenRegKey (sizeKey, schemeSizeStr);
                                if (currSizeKey) {
                                    err2 = RegQueryValueEx (
                                                currSizeKey,
                                                TEXT("LegacyName"),
                                                NULL,
                                                &valueType,
                                                NULL,
                                                &valueDataSize
                                                );
                                    if (((err2 == ERROR_SUCCESS) || (err2 == ERROR_MORE_DATA)) &&
                                        ((valueType == REG_SZ) || (valueType == REG_EXPAND_SZ)) &&
                                        valueDataSize
                                        ) {
                                        valueData = (PTSTR) IsmGetMemory (valueDataSize);
                                        err2 = RegQueryValueEx (
                                                    currSizeKey,
                                                    TEXT("LegacyName"),
                                                    NULL,
                                                    &valueType,
                                                    (PBYTE) valueData,
                                                    &valueDataSize
                                                    );
                                        if ((err2 == ERROR_SUCCESS) &&
                                            (StringIMatch (valueData, SchemeName))
                                            ) {
                                            *SchemeNr = _ttoi (schemeNrStr);
                                            *SchemeSize = _ttoi (schemeSizeStr);
                                            IsmReleaseMemory (valueData);
                                            valueData = NULL;
                                            CloseRegKey (currSizeKey);
                                            currSizeKey = NULL;
                                            CloseRegKey (sizeKey);
                                            sizeKey = NULL;
                                            FreePathString (subKeyStr);
                                            subKeyStr = NULL;
                                            result = TRUE;
                                            break;
                                        }
                                        IsmReleaseMemory (valueData);
                                        valueData = NULL;
                                    }
                                    CloseRegKey (currSizeKey);
                                    currSizeKey = NULL;
                                }
                            }
                            index1 ++;
                        }
                        if (result) {
                            break;
                        }
                        CloseRegKey (sizeKey);
                        sizeKey = NULL;
                    }
                    FreePathString (subKeyStr);
                    subKeyStr = NULL;
                }
                index ++;
            }
        }
        CloseRegKey (rootKey);
        rootKey = NULL;
    }

    if (!result) {
        *SchemeNr = maxScheme + 1;
    }

    return result;
}

DWORD
pConvertColor (
    IN      PCTSTR ColorStr
    )
{
    DWORD color = 0;
    PBYTE colorPtr;
    UINT index = 0;

    colorPtr = (PBYTE)&color;

    while (ColorStr && *ColorStr) {

        if (index >= 3) {
            return FALSE;
        }

        *colorPtr = (BYTE) _tcstoul ((PTSTR)ColorStr, &((PTSTR)ColorStr), 10);

        if (*ColorStr) {
            if (_tcsnextc (ColorStr) != ' ') {
                return FALSE;
            }

            ColorStr = _tcsinc (ColorStr);
        }

        colorPtr++;
        index++;
    }
    return color;
}

BOOL
pBuildSchemeColor (
    IN      PCTSTR SchemeDest,
    IN      PCTSTR SrcColorName,
    IN      PCTSTR AltSrcColorName,
    IN      PCTSTR AltSrcColorStr,
    IN      PCTSTR DestColorName
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    DWORD color;
    DWORD valueType;
    BOOL needExtraColor = FALSE;
    PCTSTR extraColorStr = NULL;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    valueType = REG_DWORD;
    destContent.MemoryContent.ContentSize = sizeof (DWORD);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&color);

    srcName = IsmCreateObjectHandle (S_SCHEMECOLORS, SrcColorName);
    if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
        if (IsValidRegSz(&srcContent)) {
            color = pConvertColor ((PCTSTR) srcContent.MemoryContent.ContentBytes);

            destName = IsmCreateObjectHandle (SchemeDest, DestColorName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
        }
        IsmReleaseObject (&srcContent);
    } else if (AltSrcColorName) {
        IsmDestroyObjectHandle (srcName);
        srcName = NULL;
        srcName = IsmCreateObjectHandle (S_SCHEMECOLORS, AltSrcColorName);
        if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
            if (IsValidRegSz(&srcContent)) {
                color = pConvertColor ((PCTSTR) srcContent.MemoryContent.ContentBytes);

                destName = IsmCreateObjectHandle (SchemeDest, DestColorName);
                IsmReplacePhysicalObject (destTypeId, destName, &destContent);
                IsmDestroyObjectHandle (destName);
                destName = NULL;
                needExtraColor = TRUE;
                extraColorStr = DuplicatePathString ((PCTSTR) srcContent.MemoryContent.ContentBytes, 0);
            }
            IsmReleaseObject (&srcContent);
        }
    } else if (AltSrcColorStr) {
        color = pConvertColor (AltSrcColorStr);

        destName = IsmCreateObjectHandle (SchemeDest, DestColorName);
        IsmReplacePhysicalObject (destTypeId, destName, &destContent);
        IsmDestroyObjectHandle (destName);
        destName = NULL;
        needExtraColor = TRUE;
        extraColorStr = DuplicatePathString (AltSrcColorStr, 0);
    }
    IsmDestroyObjectHandle (srcName);
    srcName = NULL;

    if (needExtraColor) {
        if (extraColorStr) {
            valueType = REG_SZ;
            destContent.MemoryContent.ContentSize = SizeOfString (extraColorStr);
            destContent.MemoryContent.ContentBytes = (PBYTE) extraColorStr;
            destName = IsmCreateObjectHandle (S_SCHEMECOLORS, SrcColorName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
            FreePathString (extraColorStr);
            extraColorStr = NULL;
        }
    }

    return TRUE;
}

LONGLONG
pConvertSize (
    IN      PCTSTR SizeStr
    )
{
    INT size = 0;

    size = _tcstoul ((PTSTR)SizeStr, &((PTSTR)SizeStr), 10);
    size = -(size);
    size /= 15;

    return size;
}

BOOL
pBuildSchemeSize (
    IN      PCTSTR SchemeDest,
    IN      PCTSTR SrcSizeName,
    IN      PCTSTR DestSizeName
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    LONGLONG size;
    DWORD valueType;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    valueType = REG_QWORD;
    destContent.MemoryContent.ContentSize = sizeof (LONGLONG);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&size);

    srcName = IsmCreateObjectHandle (S_SCHEMEMETRICS, SrcSizeName);
    if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
        if (IsValidRegSz(&srcContent)) {
            size = pConvertSize ((PCTSTR) srcContent.MemoryContent.ContentBytes);

            destName = IsmCreateObjectHandle (SchemeDest, DestSizeName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
        }
        IsmReleaseObject (&srcContent);
    }
    IsmDestroyObjectHandle (srcName);
    srcName = NULL;

    return TRUE;
}

BOOL
pBuildSchemeFont (
    IN      PCTSTR SchemeDest,
    IN      PCTSTR SrcSizeName,
    IN      PCTSTR DestSizeName
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    LOGFONTW destFont;
    DWORD valueType;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    ZeroMemory (&destFont, sizeof (LOGFONTW));

    valueType = REG_BINARY;
    destContent.MemoryContent.ContentSize = sizeof (LOGFONTW);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&destFont);

    srcName = IsmCreateObjectHandle (S_SCHEMEMETRICS, SrcSizeName);
    if (IsmAcquireObject (srcTypeId, srcName, &srcContent)) {
        if (IsValidRegType (&srcContent, REG_BINARY)) {
            if (srcContent.MemoryContent.ContentSize == sizeof (SHORT_LOGFONT)) {
                pConvertShortLogFontWorker (&destFont, (PSHORT_LOGFONT) srcContent.MemoryContent.ContentBytes);
            } else if (srcContent.MemoryContent.ContentSize == sizeof (LOGFONTA)) {
                pConvertLogFontWorker (&destFont, (PLOGFONTA) srcContent.MemoryContent.ContentBytes);
            } else {
                CopyMemory (&destFont, srcContent.MemoryContent.ContentBytes, sizeof (LOGFONTW));
            }

            destName = IsmCreateObjectHandle (SchemeDest, DestSizeName);
            IsmReplacePhysicalObject (destTypeId, destName, &destContent);
            IsmDestroyObjectHandle (destName);
            destName = NULL;
        }
        IsmReleaseObject (&srcContent);
    }
    IsmDestroyObjectHandle (srcName);
    srcName = NULL;

    return TRUE;
}

BOOL
pBuildTempScheme (
    IN      PCTSTR SchemeDest
    )
{
    MIG_OBJECTTYPEID srcTypeId;
    MIG_OBJECTSTRINGHANDLE srcName;
    MIG_CONTENT srcContent;
    MIG_OBJECTTYPEID destTypeId;
    MIG_OBJECTSTRINGHANDLE destName;
    MIG_CONTENT destContent;
    DWORD value;
    DWORD valueType;

    srcTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    destTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&destContent, sizeof (MIG_CONTENT));
    destContent.ObjectTypeId = destTypeId;
    destContent.ContentInFile = FALSE;
    destContent.Details.DetailsSize = sizeof (DWORD);
    destContent.Details.DetailsData = &valueType;

    // first we build the Color #<nr> values

    pBuildSchemeColor (SchemeDest, TEXT("Scrollbar"), NULL, NULL, TEXT("Color #0"));
    pBuildSchemeColor (SchemeDest, TEXT("Background"), NULL, NULL, TEXT("Color #1"));
    pBuildSchemeColor (SchemeDest, TEXT("ActiveTitle"), NULL, NULL, TEXT("Color #2"));
    pBuildSchemeColor (SchemeDest, TEXT("InactiveTitle"), NULL, NULL, TEXT("Color #3"));
    pBuildSchemeColor (SchemeDest, TEXT("Menu"), NULL, NULL, TEXT("Color #4"));
    pBuildSchemeColor (SchemeDest, TEXT("Window"), NULL, NULL, TEXT("Color #5"));
    pBuildSchemeColor (SchemeDest, TEXT("WindowFrame"), NULL, NULL, TEXT("Color #6"));
    pBuildSchemeColor (SchemeDest, TEXT("MenuText"), NULL, NULL, TEXT("Color #7"));
    pBuildSchemeColor (SchemeDest, TEXT("WindowText"), NULL, NULL, TEXT("Color #8"));
    pBuildSchemeColor (SchemeDest, TEXT("TitleText"), NULL, NULL, TEXT("Color #9"));
    pBuildSchemeColor (SchemeDest, TEXT("ActiveBorder"), NULL, NULL, TEXT("Color #10"));
    pBuildSchemeColor (SchemeDest, TEXT("InactiveBorder"), NULL, NULL, TEXT("Color #11"));
    pBuildSchemeColor (SchemeDest, TEXT("AppWorkSpace"), NULL, NULL, TEXT("Color #12"));
    pBuildSchemeColor (SchemeDest, TEXT("Hilight"), NULL, NULL, TEXT("Color #13"));
    pBuildSchemeColor (SchemeDest, TEXT("HilightText"), NULL, NULL, TEXT("Color #14"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonFace"), NULL, NULL, TEXT("Color #15"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonShadow"), NULL, NULL, TEXT("Color #16"));
    pBuildSchemeColor (SchemeDest, TEXT("GrayText"), NULL, NULL, TEXT("Color #17"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonText"), NULL, NULL, TEXT("Color #18"));
    pBuildSchemeColor (SchemeDest, TEXT("InactiveTitleText"), NULL, NULL, TEXT("Color #19"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonHilight"), NULL, NULL, TEXT("Color #20"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonDkShadow"), NULL, NULL, TEXT("Color #21"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonLight"), NULL, NULL, TEXT("Color #22"));
    pBuildSchemeColor (SchemeDest, TEXT("InfoText"), NULL, NULL, TEXT("Color #23"));
    pBuildSchemeColor (SchemeDest, TEXT("InfoWindow"), NULL, NULL, TEXT("Color #24"));
    pBuildSchemeColor (SchemeDest, TEXT("ButtonAlternateFace"), NULL, TEXT("180 180 180"), TEXT("Color #25"));
    pBuildSchemeColor (SchemeDest, TEXT("HotTrackingColor"), NULL, TEXT("0 0 255"), TEXT("Color #26"));
    pBuildSchemeColor (SchemeDest, TEXT("GradientActiveTitle"), NULL, TEXT("16 132 208"), TEXT("Color #27"));
    pBuildSchemeColor (SchemeDest, TEXT("GradientInactiveTitle"), NULL, TEXT("181 181 181"), TEXT("Color #28"));
    pBuildSchemeColor (SchemeDest, TEXT("MenuHilight"), TEXT("Hilight"), NULL, TEXT("Color #29"));
    pBuildSchemeColor (SchemeDest, TEXT("MenuBar"), TEXT("Menu"), NULL, TEXT("Color #30"));

    // now we build the Size #<nr> values

    pBuildSchemeSize (SchemeDest, TEXT("BorderWidth"), TEXT("Size #0"));
    pBuildSchemeSize (SchemeDest, TEXT("ScrollWidth"), TEXT("Size #1"));
    pBuildSchemeSize (SchemeDest, TEXT("ScrollHeight"), TEXT("Size #2"));
    pBuildSchemeSize (SchemeDest, TEXT("CaptionWidth"), TEXT("Size #3"));
    pBuildSchemeSize (SchemeDest, TEXT("CaptionHeight"), TEXT("Size #4"));
    pBuildSchemeSize (SchemeDest, TEXT("SmCaptionWidth"), TEXT("Size #5"));
    pBuildSchemeSize (SchemeDest, TEXT("SmCaptionHeight"), TEXT("Size #6"));
    pBuildSchemeSize (SchemeDest, TEXT("MenuWidth"), TEXT("Size #7"));
    pBuildSchemeSize (SchemeDest, TEXT("MenuHeight"), TEXT("Size #8"));

    // finally build the Font #<nr> values

    pBuildSchemeFont (SchemeDest, TEXT("CaptionFont"), TEXT("Font #0"));
    pBuildSchemeFont (SchemeDest, TEXT("SmCaptionFont"), TEXT("Font #1"));
    pBuildSchemeFont (SchemeDest, TEXT("MenuFont"), TEXT("Font #2"));
    pBuildSchemeFont (SchemeDest, TEXT("IconFont"), TEXT("Font #3"));
    pBuildSchemeFont (SchemeDest, TEXT("StatusFont"), TEXT("Font #4"));
    pBuildSchemeFont (SchemeDest, TEXT("MessageFont"), TEXT("Font #5"));

    value = 0;
    valueType = REG_DWORD;
    destContent.MemoryContent.ContentSize = sizeof (DWORD);
    destContent.MemoryContent.ContentBytes = (PBYTE) (&value);
    destName = IsmCreateObjectHandle (SchemeDest, TEXT("Contrast"));
    IsmReplacePhysicalObject (destTypeId, destName, &destContent);
    IsmDestroyObjectHandle (destName);
    destName = NULL;
    destName = IsmCreateObjectHandle (SchemeDest, TEXT("Flat Menus"));
    IsmReplacePhysicalObject (destTypeId, destName, &destContent);
    IsmDestroyObjectHandle (destName);
    destName = NULL;
    return TRUE;
}

BOOL
pUpdateSchemeData (
    IN      PCTSTR SchemeName,
    IN      UINT SchemeNr,
    IN      UINT SchemeSize
    )
{
    static BOOL firstTime = TRUE;
    BOOL current = FALSE;
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    TCHAR schemeNrStr [20];
    TCHAR schemeSizeStr [20];
    PCTSTR keyStr = NULL;
    DWORD valueType = REG_SZ;
    BOOL noCurrent = FALSE;

    // first let's see if this is the current scheme
    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_SOURCE;
    objectName = IsmCreateObjectHandle (S_SCHEMECURRENT, TEXT("Current"));
    if (IsmAcquireObject (objectTypeId, objectName, &objectContent)) {
        current = ((IsValidRegSz(&objectContent)) &&
                   (StringIMatch (SchemeName, (PCTSTR) objectContent.MemoryContent.ContentBytes))
                   );
        noCurrent = ((IsValidRegSz(&objectContent)) &&
                     (StringIMatch (TEXT(""), (PCTSTR) objectContent.MemoryContent.ContentBytes))
                     );
        IsmReleaseObject (&objectContent);
    } else {
        noCurrent = TRUE;
    }
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    if (noCurrent) {
        // we did not have a current scheme, so we had only a temporary scheme
        // First time when we encounter this we will attempt to fix it.
        if (firstTime) {
            // we will build HKR\Control Panel\Appearance\New Schemes\Current Settings SaveAll and
            // HKR\Control Panel\Appearance\New Schemes\Current Settings SaveNoVisualStyle from
            // HKR\Control Panel\Colors and HKR\Control Panel\Desktop\WindowMetrics

            // We need to be carefull since we are reading source machine information and we need to
            // convert it (especially font blobs).

            pBuildTempScheme (S_SCHEMELOCATIONT1);
            pBuildTempScheme (S_SCHEMELOCATIONT2);

            firstTime = FALSE;
        }
    }

    if (!current) {
        return TRUE;
    }

    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;

    ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
    objectContent.ObjectTypeId = objectTypeId;
    objectContent.ContentInFile = FALSE;
    objectContent.MemoryContent.ContentSize = SizeOfString (SchemeName);
    objectContent.MemoryContent.ContentBytes = (PBYTE) SchemeName;
    objectContent.Details.DetailsSize = sizeof (DWORD);
    objectContent.Details.DetailsData = &valueType;

    objectName = IsmCreateObjectHandle (S_SCHEMECURRENT, TEXT("Current"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectName = IsmCreateObjectHandle (S_SCHEMECURRENT, TEXT("NewCurrent"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    _ultot (SchemeNr, schemeNrStr, 10);
    objectContent.MemoryContent.ContentSize = SizeOfString (schemeNrStr);
    objectContent.MemoryContent.ContentBytes = (PBYTE) schemeNrStr;
    objectName = IsmCreateObjectHandle (S_SCHEMELOCATION, TEXT("SelectedStyle"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    keyStr = JoinPaths (S_SCHEMELOCATION, schemeNrStr);
    _ultot (SchemeSize, schemeSizeStr, 10);
    objectContent.MemoryContent.ContentSize = SizeOfString (schemeSizeStr);
    objectContent.MemoryContent.ContentBytes = (PBYTE) schemeSizeStr;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("SelectedSize"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;
    FreePathString (keyStr);
    keyStr = NULL;

    // finally we need to copy the current scheme into
    // HKR\Control Panel\Appearance\New Schemes\Current Settings SaveAll and
    // HKR\Control Panel\Appearance\New Schemes\Current Settings SaveNoVisualStyle
    pBuildTempScheme (S_SCHEMELOCATIONT1);
    pBuildTempScheme (S_SCHEMELOCATIONT2);

    return TRUE;
}

BOOL
pCreateWhistlerScheme (
    IN      PCTSTR SchemeName,
    IN      PSCHEMEDATA_NT SchemeData,
    IN      UINT SchemeNr
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    MIG_OBJECTSTRINGHANDLE objectName;
    MIG_CONTENT objectContent;
    DWORD valueType = 0;
    TCHAR schemeNrStr [20];
    TCHAR valueName [20];
    TCHAR normalStr [] = TEXT("Normal");
    PCTSTR keyStr = NULL;
    DWORD value = 0;
    DWORD index = 0;
    ULONGLONG qvalue = 0;

    objectTypeId = MIG_REGISTRY_TYPE | PLATFORM_DESTINATION;
    ZeroMemory (&objectContent, sizeof (MIG_CONTENT));
    objectContent.ObjectTypeId = objectTypeId;
    objectContent.ContentInFile = FALSE;
    objectContent.Details.DetailsSize = sizeof (DWORD);
    objectContent.Details.DetailsData = &valueType;

    _ultot (SchemeNr, schemeNrStr, 10);

    keyStr = JoinPathsInPoolEx ((NULL, S_SCHEMELOCATION, schemeNrStr, NULL));
    valueType = REG_SZ;
    objectContent.MemoryContent.ContentSize = SizeOfString (SchemeName);
    objectContent.MemoryContent.ContentBytes = (PBYTE) SchemeName;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("DisplayName"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    FreePathString (keyStr);
    keyStr = NULL;

    keyStr = JoinPathsInPoolEx ((NULL, S_SCHEMELOCATION, schemeNrStr, TEXT("Sizes\\0"), NULL));

    valueType = REG_SZ;

    objectContent.MemoryContent.ContentSize = SizeOfString (normalStr);
    objectContent.MemoryContent.ContentBytes = (PBYTE) normalStr;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("DisplayName"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentSize = SizeOfString (SchemeName);
    objectContent.MemoryContent.ContentBytes = (PBYTE) SchemeName;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("LegacyName"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    value = 0;
    valueType = REG_DWORD;
    objectContent.MemoryContent.ContentSize = sizeof (DWORD);
    objectContent.MemoryContent.ContentBytes = (PBYTE) (&value);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Contrast"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Flat Menus"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    // write Color #<nr> values
    objectContent.MemoryContent.ContentSize = sizeof (DWORD);
    objectContent.MemoryContent.ContentBytes = (PBYTE) (&value);
    for (index = 0; index < COLOR_MAX_NT; index ++) {
        value = SchemeData->rgb [index];
        wsprintf (valueName, TEXT("Color #%u"), index);
        objectName = IsmCreateObjectHandle (keyStr, valueName);
        IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
        IsmDestroyObjectHandle (objectName);
        objectName = NULL;
    }
    value = SchemeData->rgb [COLOR_HIGHLIGHT];
    wsprintf (valueName, TEXT("Color #%u"), COLOR_MENUHILIGHT);
    objectName = IsmCreateObjectHandle (keyStr, valueName);
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;
    value = SchemeData->rgb [COLOR_MENU];
    wsprintf (valueName, TEXT("Color #%u"), COLOR_MAX_NT + 1);
    objectName = IsmCreateObjectHandle (keyStr, valueName);
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    // now, let's write the sizes
    valueType = REG_QWORD;
    objectContent.MemoryContent.ContentSize = sizeof (ULONGLONG);
    objectContent.MemoryContent.ContentBytes = (PBYTE) (&qvalue);

    qvalue = SchemeData->ncm.iBorderWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #0"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iScrollWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #1"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iScrollHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #2"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iCaptionWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #3"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iCaptionHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #4"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iSmCaptionWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #5"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iSmCaptionHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #6"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iMenuWidth;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #7"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    qvalue = SchemeData->ncm.iMenuHeight;
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Size #8"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    // finally, let's write the fonts
    valueType = REG_BINARY;
    objectContent.MemoryContent.ContentSize = sizeof (LOGFONTW);

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfCaptionFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #0"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfSmCaptionFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #1"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfMenuFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #2"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->lfIconTitle);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #3"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfStatusFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #4"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    objectContent.MemoryContent.ContentBytes = (PBYTE) (&SchemeData->ncm.lfMessageFont);
    objectName = IsmCreateObjectHandle (keyStr, TEXT("Font #5"));
    IsmReplacePhysicalObject (objectTypeId, objectName, &objectContent);
    IsmDestroyObjectHandle (objectName);
    objectName = NULL;

    FreePathString (keyStr);
    keyStr = NULL;

    return TRUE;
}

BOOL
pDoesNewSchemeKeyExist (
    VOID
    )
{
    BOOL result = FALSE;
    HKEY rootKey = NULL;

    rootKey = OpenRegKeyStr (S_SCHEMELOCATION);

    result = rootKey != NULL;

    if (rootKey) {
        CloseRegKey (rootKey);
    }

    return result;
}

BOOL
WINAPI
pConvertAppearanceSchemeCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    UINT convertedSize = 0;
    PBYTE result = NULL;
    PDWORD valueType;
    SCHEMEDATA_NT sd_nt;
    PSCHEMEDATA_V1 psd_v1;
    PSCHEMEDATA_V2 psd_v2;
    PSCHEMEDATA_V3 psd_v3;
    PSCHEMEDATA_V4 psd_v4;
    PSCHEMEDATA_V1A psd_v1a;
    BOOL Copy3dValues = FALSE;
    PCTSTR node = NULL, leaf = NULL;
    UINT schemeNr = 0;
    UINT schemeSize = 0;

    //
    // Filter the data for any references to %windir%
    //

    ZeroMemory (&sd_nt, sizeof (SCHEMEDATA_NT));

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {
            if (CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V1) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V2) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V3) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V4) ||
                CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V1A)
                ) {
                psd_v1 = (PSCHEMEDATA_V1)CurrentContent->MemoryContent.ContentBytes;
                if (psd_v1->version == 1 ||
                    psd_v1->version == 2 ||
                    psd_v1->version == 3 ||
                    psd_v1->version == 4
                    ) {
                    //
                    // this is a valid scheme and it has a supported version
                    //
                    //
                    // Convert the structure
                    //

                    if (psd_v1->version == 1) {
                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v1->ncm);
                        pConvertShortLogFontWorker (&sd_nt.lfIconTitle, &psd_v1->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v1->rgb,
                            min (sizeof (psd_v1->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 3 && CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V1A)) {

                        psd_v1a = (PSCHEMEDATA_V1A) psd_v1;

                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v1a->ncm);
                        pConvertShortLogFontWorker (&sd_nt.lfIconTitle, &psd_v1a->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v1a->rgb,
                            min (sizeof (psd_v1a->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 2 && CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V2)) {

                        psd_v2 = (PSCHEMEDATA_V2) psd_v1;

                        sd_nt.version = 2;
                        pCopyNonClientMetrics (&sd_nt.ncm, &psd_v2->ncm);
                        pCopyLogFontWorker (&sd_nt.lfIconTitle, &psd_v2->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v2->rgb,
                            min (sizeof (psd_v2->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 3 && CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_V3)) {
                        psd_v3 = (PSCHEMEDATA_V3) psd_v1;

                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v3->ncm);
                        pConvertLogFontWorker (&sd_nt.lfIconTitle, &psd_v3->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v3->rgb,
                            min (sizeof (psd_v3->rgb), sizeof (sd_nt.rgb))
                            );

                        Copy3dValues = TRUE;

                    } else if (psd_v1->version == 4) {
                        psd_v4 = (PSCHEMEDATA_V4) psd_v1;

                        sd_nt.version = 2;
                        pConvertNonClientMetrics (&sd_nt.ncm, &psd_v4->ncm);
                        pConvertLogFontWorker (&sd_nt.lfIconTitle, &psd_v4->lfIconTitle);

                        ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
                        CopyMemory (
                            &sd_nt.rgb,
                            &psd_v4->rgb,
                            min (sizeof (psd_v4->rgb), sizeof (sd_nt.rgb))
                            );
                    }

                    if (Copy3dValues) {
                        //
                        // Make sure the NT structure has values for 3D colors
                        //

                        sd_nt.rgb[COLOR_BUTTONALTFACE] = sd_nt.rgb[COLOR_BTNFACE];
                        sd_nt.rgb[COLOR_HOTLIGHT] = sd_nt.rgb[COLOR_ACTIVECAPTION];
                        sd_nt.rgb[COLOR_GRADIENTACTIVECAPTION] = sd_nt.rgb[COLOR_ACTIVECAPTION];
                        sd_nt.rgb[COLOR_GRADIENTINACTIVECAPTION] = sd_nt.rgb[COLOR_INACTIVECAPTION];
                    }
                    converted = TRUE;
                    convertedSize = sizeof (sd_nt);
                    result = IsmGetMemory (convertedSize);
                    CopyMemory (result, &sd_nt, convertedSize);
                }
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = result;

        }

        if ((*valueType == REG_BINARY) &&
            (converted || (CurrentContent->MemoryContent.ContentSize == sizeof (SCHEMEDATA_NT))) &&
            (pDoesNewSchemeKeyExist ())
            ) {
            // now we need to do some extra work
            // Each scheme must be converted to the new Whistler format

            // First we look to see if the scheme that we just processed exists in new Whistler format
            // For this we enumerate the HKR\Control Panel\Appearance\New Schemes
            // and try to find the valuename "Legacy Name" that matches the value name of this scheme
            // If we find it, we only update HKR\Control Panel\Appearance [Current],
            // HKR\Control Panel\Appearance [NewCurrent], HKR\Control Panel\Appearance\New Schemes [SelectedStyle]
            // and HKR\Control Panel\Appearance\New Schemes\<Scheme Number> [SelectedSize].
            // If not, we create a new Whistler scheme and update the above 4 value names.

            if (IsmCreateObjectStringsFromHandle (SrcObjectName, &node, &leaf)) {
                if (leaf) {
                    if (pFindWhistlerScheme (leaf, &schemeNr, &schemeSize)) {
                        pUpdateSchemeData (leaf, schemeNr, schemeSize);
                    } else {
                        if (pCreateWhistlerScheme (
                                leaf,
                                converted?
                                    (PSCHEMEDATA_NT)NewContent->MemoryContent.ContentBytes:
                                    (PSCHEMEDATA_NT)CurrentContent->MemoryContent.ContentBytes,
                                schemeNr
                                )) {
                            pUpdateSchemeData (leaf, schemeNr, 0);
                        }
                    }
                }
                IsmDestroyObjectString (node);
                IsmDestroyObjectString (leaf);
            }
        }

    }

    return TRUE;
}

BOOL
WINAPI
pAntiAliasCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    DWORD value = 0;
    BOOL converted = FALSE;
    PTSTR result = NULL;
    UINT convertedSize = 0;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {

            if (CurrentContent->MemoryContent.ContentSize > 0) {
                value = _tcstoul ((PCTSTR)CurrentContent->MemoryContent.ContentBytes, NULL, 10);
            }
            if (value > 0) {
                converted = TRUE;
                convertedSize = 11 * sizeof (TCHAR); // DWORD takes no more than 11 characters
                result = IsmGetMemory (convertedSize);
                wsprintf (result, TEXT("%d"), FE_AA_ON);
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = (PCBYTE) result;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pFixActiveDesktopCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    #define badBufferSize   16
    #define goodBufferSize  28
    const BYTE badBuffer[badBufferSize] =
                {0x10, 0x00, 0x00, 0x00,
                 0x01, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00};
    const BYTE goodBuffer[goodBufferSize] =
                {0x1C, 0x00, 0x00, 0x00,
                 0x20, 0x08, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x00, 0x00, 0x00, 0x00,
                 0x0A, 0x00, 0x00, 0x00};
    BOOL converted = FALSE;
    PBYTE result = NULL;
    UINT convertedSize = 0;
    PDWORD valueType;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_BINARY) {

            if (CurrentContent->MemoryContent.ContentSize == badBufferSize) {
                if (TestBuffer (CurrentContent->MemoryContent.ContentBytes, badBuffer, badBufferSize)) {
                    converted = TRUE;
                    convertedSize = goodBufferSize;
                    result = IsmGetMemory (convertedSize);
                    CopyMemory (result, goodBuffer, convertedSize);
                }
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = result;
        }
    }

    return TRUE;
}

BOOL
WINAPI
pConvertRecentDocsMRUCallback (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    BOOL converted = FALSE;
    PBYTE result = NULL;
    UINT convertedSize = 0;
    PDWORD valueType;
    PCSTR str, structPtr;
    PCWSTR strW;
    UINT size, sizeW;

    //
    // Filter the data for any references to %windir%
    //

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if ((*valueType == REG_BINARY) && (CurrentContent->MemoryContent.ContentSize)) {
            // The content of this is a NULL terminated string followed by some binary data.
            // We need to convert the string to unicode and add the existent
            // binary data
            str = (PCSTR)CurrentContent->MemoryContent.ContentBytes;
            __try {
                structPtr = GetEndOfStringA (str);
                structPtr = _mbsinc (structPtr);
                if (structPtr && (structPtr > str)) {
                    size = CurrentContent->MemoryContent.ContentSize - (UINT)(structPtr - str);
                    if (size == sizeof (WORD) + *((PWORD)structPtr)) {
                        converted = TRUE;
                        strW = ConvertAtoW (str);
                        sizeW = SizeOfStringW (strW);
                        convertedSize = sizeW + size;
                        result = IsmGetMemory (convertedSize);
                        CopyMemory (result, strW, sizeW);
                        CopyMemory (result + sizeW, structPtr, size);
                        FreeConvertedStr (strW);
                    }
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                // the structure was not well formed
                converted = FALSE;
                if (result) {
                    IsmReleaseMemory (result);
                }
            }
        }

        if (converted && convertedSize && result) {
            NewContent->MemoryContent.ContentSize = convertedSize;
            NewContent->MemoryContent.ContentBytes = result;
        }
    }

    return TRUE;
}

PCTSTR
pFindNewScreenSaver (
    IN      PCTSTR OldScreenSaver
    )
{
    PTSTR multiSz = NULL;
    MULTISZ_ENUM e;
    UINT sizeNeeded;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_TYPE dataType;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PCTSTR newScrName;
    PCTSTR result = NULL;

    if (IsmGetEnvironmentValue (
            IsmGetRealPlatform (),
            NULL,
            S_GLOBAL_INF_HANDLE,
            (PBYTE)(&infHandle),
            sizeof (HINF),
            &sizeNeeded,
            &dataType
            ) &&
        (sizeNeeded == sizeof (HINF)) &&
        (dataType == ENVENTRY_BINARY)
        ) {

        if (InfFindFirstLine (infHandle, TEXT("SCR Rename"), OldScreenSaver, &is)) {

            newScrName = InfGetStringField (&is, 1);
            if (newScrName) {
                result = DuplicatePathString (newScrName, 0);
            }
        }

        InfNameHandle (infHandle, NULL, FALSE);

    } else {

        if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, NULL, 0, &sizeNeeded, NULL)) {
            result = DuplicatePathString (OldScreenSaver, 0);
            return result;
        }

        __try {
            multiSz = AllocText (sizeNeeded);

            if (!IsmGetEnvironmentValue (IsmGetRealPlatform (), NULL, S_INF_FILE_MULTISZ, (PBYTE) multiSz, sizeNeeded, NULL, NULL)) {
                __leave;
            }

            if (EnumFirstMultiSz (&e, multiSz)) {

                do {

                    infHandle = InfOpenInfFile (e.CurrentString);
                    if (infHandle != INVALID_HANDLE_VALUE) {

                        if (InfFindFirstLine (infHandle, TEXT("SCR Rename"), OldScreenSaver, &is)) {

                            newScrName = InfGetStringField (&is, 1);
                            if (newScrName) {
                                result = DuplicatePathString (newScrName, 0);
                                InfCloseInfFile (infHandle);
                                infHandle = INVALID_HANDLE_VALUE;
                                __leave;
                            }
                        }
                    } else {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_INF, e.CurrentString));
                    }
                    InfCloseInfFile (infHandle);
                    infHandle = INVALID_HANDLE_VALUE;
                } while (EnumNextMultiSz (&e));

            }
        }
        __finally {
            FreeText (multiSz);
        }
    }

    InfResetInfStruct (&is);

    if (!result) {
        result = DuplicatePathString (OldScreenSaver, 0);
    }
    return result;
}

BOOL
WINAPI
pConvertScnSaver (
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    PDWORD valueType;
    PCTSTR exePath = NULL;
    PTSTR exeName = NULL;
    PCTSTR exeNativeName = NULL;
    PCTSTR newExeName = NULL;
    PCTSTR expExePath = NULL;
    MIG_OBJECTSTRINGHANDLE sourceObjectName = NULL;
    MIG_OBJECTSTRINGHANDLE destObjectName = NULL;
    MIG_CONTENT destContent;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;
    BOOL migrateSrcReg = FALSE;

    if (!CurrentContent->ContentInFile) {
        MYASSERT (CurrentContent->Details.DetailsSize == sizeof (DWORD));
        valueType = (PDWORD)(CurrentContent->Details.DetailsData);

        if (*valueType == REG_SZ) {

            //
            // Extract the source screen saver path from the reg value data
            //

            if (IsEmptyStr ((PCTSTR) CurrentContent->MemoryContent.ContentBytes)) {
                migrateSrcReg = TRUE;
            } else {
                // first we try to see if the source SCR exists on the destination
                // we have two steps :
                // 1. Filter the source and see if the destination exists
                // 2. Filter the source path, append the source file and see if the destination exists
                exePath = (PCTSTR) (CurrentContent->MemoryContent.ContentBytes);
                if (exePath) {
                    expExePath = IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, exePath, NULL);
                    exeName = (PTSTR) FindLastWack (expExePath?expExePath:exePath);
                }

                if (exeName) {
                    *exeName++ = 0;

                    sourceObjectName = IsmCreateObjectHandle (expExePath?expExePath:exePath, exeName);

                    destObjectName = IsmFilterObject(
                                            MIG_FILE_TYPE | PLATFORM_SOURCE,
                                            sourceObjectName,
                                            &destObjectTypeId,
                                            &deleted,
                                            &replaced
                                            );

                    migrateSrcReg = !deleted || replaced;

                    if (migrateSrcReg) {

                        migrateSrcReg = FALSE;

                        exeNativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, destObjectName?destObjectName:sourceObjectName);

                        if (exeNativeName) {
                            NewContent->MemoryContent.ContentSize = SizeOfString (exeNativeName);
                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                            StringCopy ((PTSTR)NewContent->MemoryContent.ContentBytes, exeNativeName);
                            migrateSrcReg = TRUE;
                            IsmReleaseMemory (exeNativeName);
                        }

                        if (sourceObjectName) {
                            IsmDestroyObjectHandle (sourceObjectName);
                            sourceObjectName = NULL;
                        }

                        if (destObjectName) {
                            IsmDestroyObjectHandle (destObjectName);
                            destObjectName = NULL;
                        }
                    } else {

                        if (sourceObjectName) {
                            IsmDestroyObjectHandle (sourceObjectName);
                            sourceObjectName = NULL;
                        }

                        if (destObjectName) {
                            IsmDestroyObjectHandle (destObjectName);
                            destObjectName = NULL;
                        }

                        sourceObjectName = IsmCreateObjectHandle (expExePath?expExePath:exePath, NULL);

                        destObjectName = IsmFilterObject(
                                                MIG_FILE_TYPE | PLATFORM_SOURCE,
                                                sourceObjectName,
                                                &destObjectTypeId,
                                                &deleted,
                                                &replaced
                                                );

                        migrateSrcReg = !deleted || replaced;

                        if (migrateSrcReg) {

                            migrateSrcReg = FALSE;

                            //
                            // get the equivalent SCR file from the INF
                            //
                            newExeName = pFindNewScreenSaver (exeName);

                            if (newExeName) {

                                exeNativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, destObjectName?destObjectName:sourceObjectName);

                                if (destObjectName) {
                                    IsmDestroyObjectHandle (destObjectName);
                                    destObjectName = NULL;
                                }

                                if (exeNativeName) {

                                    destObjectName = IsmCreateObjectHandle (exeNativeName, newExeName);
                                    IsmReleaseMemory (exeNativeName);

                                    if (IsmAcquireObject (MIG_FILE_TYPE | PLATFORM_DESTINATION, destObjectName, &destContent)) {
                                        IsmReleaseObject (&destContent);
                                        exeNativeName = IsmGetNativeObjectName (MIG_FILE_TYPE, destObjectName);
                                        if (exeNativeName) {
                                            NewContent->MemoryContent.ContentSize = SizeOfString (exeNativeName);
                                            NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                                            StringCopy ((PTSTR)NewContent->MemoryContent.ContentBytes, exeNativeName);
                                            migrateSrcReg = TRUE;
                                            IsmReleaseMemory (exeNativeName);
                                        }
                                    }

                                }
                                FreePathString (newExeName);
                            }
                        }

                        if (sourceObjectName) {
                            IsmDestroyObjectHandle (sourceObjectName);
                            sourceObjectName = NULL;
                        }

                        if (destObjectName) {
                            IsmDestroyObjectHandle (destObjectName);
                            destObjectName = NULL;
                        }
                    }
                }

                if (expExePath) {
                    IsmReleaseMemory (expExePath);
                    expExePath = NULL;
                }

            }

            //
            // If we should migrate the entry, then just leave everything
            // alone. If not, then we need to put the destination value in the
            // outbound content.
            //

            if (!migrateSrcReg) {
                MYASSERT (!(SrcObjectTypeId & PLATFORM_DESTINATION));

                destObjectName = IsmFilterObject(
                                        SrcObjectTypeId | PLATFORM_SOURCE,
                                        SrcObjectName,
                                        &destObjectTypeId,
                                        &deleted,
                                        NULL
                                        );

                if (!deleted) {

                    destObjectTypeId = SrcObjectTypeId & ~(PLATFORM_MASK);
                    destObjectTypeId |= PLATFORM_DESTINATION;

                    if (IsmAcquireObject (destObjectTypeId, destObjectName?destObjectName:SrcObjectName, &destContent)) {
                        NewContent->MemoryContent.ContentSize = destContent.MemoryContent.ContentSize;
                        NewContent->MemoryContent.ContentBytes = IsmGetMemory (NewContent->MemoryContent.ContentSize);
                        CopyMemory ((PBYTE)NewContent->MemoryContent.ContentBytes, destContent.MemoryContent.ContentBytes, NewContent->MemoryContent.ContentSize);
                        IsmReleaseObject (&destContent);
                    }
                }

                IsmDestroyObjectHandle (destObjectName);
                INVALID_POINTER (destObjectName);
            }
        }
    }

    return TRUE;
}

BOOL
WINAPI
pConvertIdentityCount(
    IN      MIG_OBJECTTYPEID SrcObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE SrcObjectName,
    IN      PCMIG_CONTENT OriginalContent,
    IN      PCMIG_CONTENT CurrentContent,
    OUT     PMIG_CONTENT NewContent,
    IN      PCMIG_BLOB SourceOperationData,             OPTIONAL
    IN      PCMIG_BLOB DestinationOperationData         OPTIONAL
    )
{
    MIG_OBJECT_ENUM objectEnum;
    MIG_OBJECTSTRINGHANDLE enumPattern;
    MIG_OBJECTSTRINGHANDLE filteredName;
    DWORD value = 0;
    PTSTR node;
    PTSTR leaf;
    MIG_OBJECTTYPEID destObjectTypeId;
    BOOL deleted;
    BOOL replaced;

    if (IsValidRegType (CurrentContent, REG_DWORD)) {

        // Read the current Identity count
        value = pGetDestDwordValue (TEXT("HKCU\\Identities"), TEXT("Identity Ordinal"));

        // Add the number of new source identities
        enumPattern = IsmCreateSimpleObjectPattern (
                          TEXT("HKCU\\Identities"),
                          TRUE,
                          TEXT("Username"),
                          FALSE