jectSink __RPC_FAR* __RPC_FAR* ppHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR* __RPC_FAR *ppObject,
    IWbemCallResult __RPC_FAR* __RPC_FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	HRESULT hr = S_OK;
	SetStructuredExceptionHandler seh;
	GetObjectTaskObject *t_AsyncEvent = NULL;

	try
	{
		if (pHandler == NULL)
		{
			hr = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			hr = WbemCoImpersonateClient();
#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
	CViewProvServ::sm_debugLog->Write (  

		_T("\r\n")
	) ;

	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("CViewProvServ::GetObjectAsync ()")
	) ;
) 

			if (SUCCEEDED(hr))
			{
			/*
			 * Create Asynchronous GetObjectByPath object
			 */
				t_AsyncEvent = new GetObjectTaskObject ( this , ObjectPath , lFlags , pHandler , pCtx, NULL, NULL ) ;
				t_AsyncEvent->GetObject();

				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;

				WbemCoRevertToSelf();
			}
			else
			{
				hr = WBEM_E_ACCESS_DENIED;
			}

DebugOut1( 
	CViewProvServ::sm_debugLog->WriteW (  

		L"Returning from CViewProvServ::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
		ObjectPath ,
		hr 
	) ;
)

		}
	}
	catch(Structured_Exception e_SE)
	{
		hr = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->CleanUpObjSinks(TRUE);
			t_AsyncEvent->Release();
		}
	}
	catch(Structured_Exception e_SE)
	{
		hr = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_UNEXPECTED;
	}

	return hr ;
}

HRESULT CViewProvServ :: PutClass ( 
		
	IWbemClassObject __RPC_FAR* pClass , 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemCallResult __RPC_FAR* __RPC_FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: PutClassAsync ( 
		
	IWbemClassObject __RPC_FAR* pClass, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

 HRESULT CViewProvServ :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemCallResult __RPC_FAR* __RPC_FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

SCODE CViewProvServ :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext __RPC_FAR* pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: PutInstance (

    IWbemClassObject __RPC_FAR *pInstance,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
	IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: PutInstanceAsync ( 
		
	IWbemClassObject __RPC_FAR* pInstance, 
	long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;
	SetStructuredExceptionHandler seh;
	PutInstanceTaskObject *t_AsyncEvent = NULL;

	try
	{
		if (pHandler == NULL)
		{
			t_Result = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			t_Result = WbemCoImpersonateClient();
#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
	CViewProvServ::sm_debugLog->Write (  

		_T("\r\n")
	) ;

	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("CViewProvServ::PutInstanceAsync ()")
	) ;
) 

			if (SUCCEEDED(t_Result))
			{
				/*
				 * Create Asynchronous GetObjectByPath object
				 */

				t_AsyncEvent = new PutInstanceTaskObject ( this , pInstance , lFlags , pHandler , pCtx ) ;
				t_AsyncEvent->PutInstance();

				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;

				WbemCoRevertToSelf();
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}

DebugOut1( 
	CViewProvServ::sm_debugLog->WriteFileAndLine (  

		_T(__FILE__),__LINE__,
		_T("Returning from CViewProvServ::PutInstanceAsync with Result = (%lx)"),
		t_Result 
	) ;
)
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->Release();
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	return t_Result ;
}

HRESULT CViewProvServ :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CViewProvServ :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: CreateInstanceEnum ( 

	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: CreateInstanceEnumAsync (

 	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink __RPC_FAR* pHandler 

) 
{
	HRESULT t_Result = S_OK ;
	SetStructuredExceptionHandler seh;
	ExecQueryTaskObject *t_AsyncEvent = NULL;
	BSTR Query = NULL;

	try
	{
		if (pHandler == NULL)
		{
			t_Result = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			t_Result = WbemCoImpersonateClient();
#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
	CViewProvServ::sm_debugLog->Write (  

		_T("\r\n")
	) ;


	CViewProvServ::sm_debugLog->WriteW (  

		L"CViewProvServ::CreateInstanceEnumAsync ( (%s) )" ,
		Class
	) ;
)

			if (SUCCEEDED(t_Result))
			{
				/*
				 * Create Synchronous Enum Instance object
				 */
				Query = SysAllocStringLen(NULL, 33 + (wcslen(Class) * 2));

				if (Query == NULL)
				{
					throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
				}

				wcscpy(Query, ENUM_INST_QUERY_START);
				wcscat(Query, Class);
				wcscat(Query, ENUM_INST_QUERY_MID);
				wcscat(Query, Class);
				wcscat(Query, END_QUOTE);

				t_AsyncEvent = new ExecQueryTaskObject ( this , WBEM_QUERY_LANGUAGE_SQL1 , Query , lFlags , pHandler , pCtx ) ;
				t_AsyncEvent->ExecQuery();

				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;
				SysFreeString(Query);

				WbemCoRevertToSelf();
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}
DebugOut1( 
	CViewProvServ::sm_debugLog->WriteW (  

		L"Returning from CViewProvServ::CreateInstanceEnumAsync ( (%s),(%s) ) with Result = (%lx)" ,
		Class,
		Query,
		t_Result 
	) ;
)
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->CleanUpObjSinks(TRUE);
			t_AsyncEvent->Release();
			SysFreeString(Query);
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	return t_Result ;
}

HRESULT CViewProvServ :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CViewProvServ :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext __RPC_FAR* pCtx,
	IWbemObjectSink __RPC_FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;
	SetStructuredExceptionHandler seh;
	ExecQueryTaskObject *t_AsyncEvent = NULL;

	try
	{
		if (pHandler == NULL)
		{
			t_Result = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			t_Result = WbemCoImpersonateClient();

#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
		CViewProvServ::sm_debugLog->Write (  

			_T("\r\n")
		) ;


		CViewProvServ::sm_debugLog->WriteW (  

			L"CViewProvServ::ExecQueryAsync ( (%s),(%s) )" ,
			QueryFormat ,
			Query
		) ;
)

			if (SUCCEEDED(t_Result))
			{
				/*
				 * Create Synchronous Enum Instance object
				 */
				pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);

				t_AsyncEvent = new ExecQueryTaskObject ( this , QueryFormat , Query , lFlags , pHandler , pCtx ) ;
				t_AsyncEvent->ExecQuery();

				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;

				WbemCoRevertToSelf();
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}

DebugOut1( 
		CViewProvServ::sm_debugLog->WriteW (  

			L"Returning from CViewProvServ::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)" , 
			QueryFormat ,
			Query ,
			t_Result 
		) ;
)

		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->CleanUpObjSinks(TRUE);
			t_AsyncEvent->Release();
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	return t_Result ;
}

HRESULT CViewProvServ :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CViewProvServ :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CViewProvServ :: ExecMethod( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
    IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CViewProvServ :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
	IWbemObjectSink __RPC_FAR *pResponseHandler
) 
{
	HRESULT t_Result = S_OK ;
	SetStructuredExceptionHandler seh;
	ExecMethodTaskObject *t_AsyncEvent = NULL;

	try
	{
		if (pResponseHandler == NULL)
		{
			t_Result = WBEM_E_INVALID_PARAMETER;
		}
		else
		{
			t_Result = WbemCoImpersonateClient();
#ifdef UNICODE
#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
	VPGetUserName();
#endif
#endif

DebugOut1( 
		CViewProvServ::sm_debugLog->Write (  

			_T("\r\n")
		) ;

		CViewProvServ::sm_debugLog->WriteFileAndLine (  

			_T(__FILE__),__LINE__,
			_T("CViewProvServ::ExecMethodAsync ()") 
		) ;
)
 
			if (SUCCEEDED(t_Result))
			{
				/*
				 * Create Asynchronous GetObjectByPath object
				 */
				t_AsyncEvent = new ExecMethodTaskObject ( this , ObjectPath , MethodName ,
																		lFlags , pInParams , pResponseHandler , pCtx ) ;
				t_AsyncEvent->ExecMethod();


				t_AsyncEvent->Release();
				t_AsyncEvent = NULL;

				WbemCoRevertToSelf();
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED;
			}

DebugOut1( 
		CViewProvServ::sm_debugLog->WriteW (  

			L"Returning from CViewProvServ::ExecMethodAsync ( (%s) ) with Result = (%lx)" ,
			ObjectPath ,
			t_Result 
		) ;
)
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	try
	{
		if (t_AsyncEvent != NULL)
		{
			t_AsyncEvent->Release();
		}
	}
	catch(Structured_Exception e_SE)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		t_Result = WBEM_E_UNEXPECTED;
	}

	return t_Result ;
}

        
HRESULT CViewProvServ :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
	SetStructuredExceptionHandler seh;

	try
	{
DebugOut1( 

		CViewProvServ::sm_debugLog->Write (  

			_T("\r\n")
		) ;

		CViewProvServ::sm_debugLog->WriteFileAndLine (  

			_T(__FILE__),__LINE__,
			_T("CViewProvServ::Initialize ")
		) ;
)
		if ((pCIMOM == NULL) || (pInitSink == NULL) || (pszNamespace == NULL))
		{
			return WBEM_E_INVALID_PARAMETER;
		}

#ifndef UNICODE
		if (pszUser == NULL)
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		m_UserName = SysAllocString(pszUser);
#endif
		m_Server = pCIMOM ;
		m_Server->AddRef () ;
		m_NamespacePath.SetNamespacePath ( pszNamespace ) ;
		pInitSink->SetStatus ( WBEM_S_INITIALIZED , 0 ) ;	

DebugOut1( 

		CViewProvServ::sm_debugLog->WriteFileAndLine (  

			_T(__FILE__),__LINE__,
			_T("Returning From CImpPropProv::Initialize () ")
		) ;
)
	
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}

	return WBEM_NO_ERROR ;
}

HRESULT STDMETHODCALLTYPE CViewProvServ::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vpsinks.cpp ===
//***************************************************************************

//

//  VPSINKS.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the sinks implementations

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

extern CRITICAL_SECTION g_CriticalSection;


CWbemClassObjectWithIndex :: CWbemClassObjectWithIndex(DWORD a_indx, IWbemClassObject *a_pObj)
: m_pObject(NULL), m_ReferenceCount(0), m_nsindex(a_indx)
{
	if (a_pObj)
	{
		a_pObj->AddRef();
		m_pObject = a_pObj;
	}
}

CWbemClassObjectWithIndex :: ~CWbemClassObjectWithIndex()
{
	if (m_pObject)
	{
		m_pObject->Release();
	}
}

ULONG CWbemClassObjectWithIndex :: AddRef ()
{
    return InterlockedIncrement(&m_ReferenceCount);
}

ULONG CWbemClassObjectWithIndex :: Release ()
{
	ULONG t_Ref;

	if ( (t_Ref = InterlockedDecrement(&m_ReferenceCount)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

CObjectSinkResults::CObjectSinkResults(WbemTaskObject* parent, DWORD index)
{
	m_ReferenceCount = 0;
	m_index = index;
	m_bSet = FALSE;
	m_hr = 0;
	m_parent = parent;
	m_parent->AddRef();
	m_ObjArray.SetSize(0, 10); //grow by 10s
}

CObjectSinkResults::~CObjectSinkResults()
{
	if (m_parent != NULL)
	{
		m_parent->Release();
	}

	m_ObjArray.RemoveAll();
}

ULONG CObjectSinkResults::AddRef()
{
    return InterlockedIncrement(&m_ReferenceCount);
}

ULONG CObjectSinkResults::Release()
{
	LONG t_Ref;

	if ( (t_Ref = InterlockedDecrement(&m_ReferenceCount)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

void CObjectSinkResults::SetStatus(HRESULT hr, CViewProvObjectSink *pSnk)
{
	if (m_CriticalSection.Lock())
	{
		if (SUCCEEDED(m_hr))
		{
			m_hr = hr;
		}

		RemoveSink(pSnk);
		m_bSet = TRUE;

		if (m_parent != NULL)
		{
			m_parent->SetStatus(hr, m_index);
		}

		m_CriticalSection.Unlock();
	}
}

void CObjectSinkResults::SetSink(CViewProvObjectSink *pSnk)
{
	if (m_CriticalSection.Lock())
	{
		m_realSnks.AddTail(pSnk);
		m_CriticalSection.Unlock();
	}
}

BOOL CObjectSinkResults::RemoveSink(CViewProvObjectSink *pSnk)
{
	BOOL retVal = FALSE;

	if (m_CriticalSection.Lock())
	{
		POSITION t_pos = m_realSnks.GetHeadPosition();

		while (t_pos)
		{
			POSITION t_badPos = t_pos;
			CViewProvObjectSink * t_pSnk = m_realSnks.GetNext(t_pos);

			if (pSnk == t_pSnk)
			{
				m_realSnks.RemoveAt(t_badPos);
				retVal = TRUE;
				break;
			}
		}

		m_CriticalSection.Unlock();
	}

	return retVal;
}

void CObjectSinkResults::Disconnect()
{
//can't call disconnect when locked, since this calls CancelAsyncCall
	CList<CViewProvObjectSink*,CViewProvObjectSink*> t_realSnks;

	if (m_CriticalSection.Lock())
	{
		while (m_realSnks.GetCount() > 0)
		{
			CViewProvObjectSink* t_pSnk = m_realSnks.RemoveTail();

			if (t_pSnk)
			{
				t_pSnk->AddRef();
				t_realSnks.AddTail(t_pSnk);
			}
		}

		if (m_parent != NULL)
		{
			m_parent->Release();
			m_parent = NULL;
		}

		m_CriticalSection.Unlock();
	}

	while (t_realSnks.GetCount() > 0)
	{
		CViewProvObjectSink* t_pSnk = t_realSnks.RemoveTail();

		if (t_pSnk)
		{
			t_pSnk->Disconnect();
			t_pSnk->Release();
		}
	}
}

HRESULT CObjectSinkResults::Indicate(LONG count, IWbemClassObject** ppObjArray, DWORD a_indx)
{
	HRESULT hr = WBEM_NO_ERROR;

	if ( (count > 0) && m_CriticalSection.Lock() )
	{
		if (m_parent != NULL)
		{
			m_parent->SetResultReceived();

			for (LONG x = 0; x < count; x++)
			{
				if (ppObjArray[x] != NULL)
				{
					CWbemClassObjectWithIndex *t_clsWrap = new CWbemClassObjectWithIndex(a_indx, ppObjArray[x]);
					t_clsWrap->AddRef();
					m_ObjArray.Add(t_clsWrap);
				}
				else
				{
					hr = WBEM_E_INVALID_PARAMETER;
				}
			}
		}
		else
		{
			hr = WBEM_E_CALL_CANCELLED;
		}

		m_CriticalSection.Unlock();
	}
	else
	{
		if (count < 0)
		{
			hr = WBEM_E_INVALID_PARAMETER;
		}
	}

	return hr;
}

CViewProvObjectSink::CViewProvObjectSink(CObjectSinkResults* parent, CWbemServerWrap *pServ, DWORD a_indx)
:m_parent(NULL), m_ServWrap(NULL), m_nsindex(a_indx)
{
	EnterCriticalSection(&g_CriticalSection);
	CViewProvClassFactory :: objectsInProgress++;
	LeaveCriticalSection(&g_CriticalSection);
	m_ReferenceCount = 0;
	m_parent = parent;
	m_parent->AddRef();
	m_parent->SetSink(this);
	m_ServWrap = pServ;
	m_ServWrap->AddRef();
	m_RemoteSink = NULL;
	m_DoCancel = TRUE;
}

CViewProvObjectSink::~CViewProvObjectSink()
{
	if (m_parent != NULL)
	{
		//set status has not been called so call it...
		m_parent->SetStatus(WBEM_E_FAILED, this);
		m_parent->Release();
	}

	if (m_ServWrap != NULL)
	{
		m_ServWrap->Release();
	}

	if (m_RemoteSink != NULL)
	{
		m_RemoteSink->Release();
	}

	EnterCriticalSection(&g_CriticalSection);	
	CViewProvClassFactory :: objectsInProgress--;
	LeaveCriticalSection(&g_CriticalSection);
}

STDMETHODIMP CViewProvObjectSink::QueryInterface (REFIID refIID, LPVOID FAR * ppV)
{
	if (ppV == NULL)
	{
		return E_INVALIDARG;
	}

	*ppV = NULL ;

	if ( refIID == IID_IUnknown )
	{
		*ppV = ( IWbemObjectSink* ) this ;
	}
	else if ( refIID == IID_IWbemObjectSink )
	{
		*ppV = ( IWbemObjectSink* ) this ;		
	}

	if ( *ppV )
	{
		( ( LPUNKNOWN ) *ppV )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG)  CViewProvObjectSink::AddRef()
{
    return InterlockedIncrement(&m_ReferenceCount);
}

STDMETHODIMP_(ULONG)  CViewProvObjectSink::Release()
{
	LONG t_Ref;

	if ( (t_Ref = InterlockedDecrement(&m_ReferenceCount)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

HRESULT CViewProvObjectSink::Indicate(LONG count, IWbemClassObject** ppObjArray)
{
	HRESULT hr = WBEM_NO_ERROR;

	if (m_lock.Lock())
	{
		if (m_parent != NULL)
		{
			hr = m_parent->Indicate(count, ppObjArray, m_nsindex);
		}

		m_lock.Unlock();
	}
	
	return hr;
}

HRESULT CViewProvObjectSink::SetStatus(LONG lFlags, HRESULT hr, BSTR bStr, IWbemClassObject* pObj)
{
	if (m_lock.Lock())
	{
		if (m_parent != NULL)
		{
			m_parent->SetStatus(hr, this);
			m_parent->Release();
			m_parent = NULL;

			DisAssociate();
			m_DoCancel = FALSE;
		}

		m_lock.Unlock();
	}

	return WBEM_NO_ERROR;
}

void CViewProvObjectSink::Disconnect()
{
	BOOL doCancel = FALSE;

	if (m_lock.Lock())
	{
		if (m_DoCancel)
		{
			doCancel = TRUE;
			m_DoCancel = FALSE;

			if (m_parent != NULL)
			{
				m_parent->Release();
				m_parent = NULL;
			}
		}

		m_lock.Unlock();
	}

	if (doCancel)
	{
		if (m_ServWrap != NULL)
		{
			IWbemServices *ptmpServ = m_ServWrap->GetServerOrProxy();

			if (ptmpServ)
			{
				if (m_RemoteSink != NULL)
				{
					ptmpServ->CancelAsyncCall(this);
				}
				else
				{
					ptmpServ->CancelAsyncCall(m_RemoteSink);
					DisAssociate();			
				}

				m_ServWrap->ReturnServerOrProxy(ptmpServ);
			}

			m_ServWrap->Release();
			m_ServWrap = NULL;
		}
	}
}

IWbemObjectSink* CViewProvObjectSink::Associate()
{
	IUnsecuredApartment* pUA = NULL;

	if ( SUCCEEDED(CViewProvServ::GetUnsecApp(&pUA)) )
	{
		IUnknown* pUnk = NULL;
		
		if ( SUCCEEDED(pUA->CreateObjectStub(this, &pUnk)) )
		{
			if ( FAILED(pUnk->QueryInterface(IID_IWbemObjectSink, (void **)&m_RemoteSink)) )
			{
				pUnk = NULL;
			}

			pUnk->Release();
		}

		pUA->Release();
	}

	return m_RemoteSink;
}

void CViewProvObjectSink::DisAssociate()
{
	if (m_RemoteSink != NULL)
	{
		m_RemoteSink->Release();
		m_RemoteSink = NULL;
	}
		
	if (m_lock.Lock())
	{
		if (m_parent != NULL)
		{
			m_parent->Release();
			m_parent = NULL;
		}

		m_lock.Unlock();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\ansi\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vptasks.cpp ===
//***************************************************************************

//

//  VPTASKS.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the common methods taskobject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************

//need the following three lines
//to get the security stuff to work
#include "precomp.h"

#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

extern BOOL bAreWeLocal(WCHAR* pServerMachine);

#ifdef VP_BUILD_AS_EXE
HRESULT EnableAllPrivileges(BOOL bProcess)
{
    // Open thread token
    // =================

    HANDLE hToken = NULL;
	BOOL bRes = FALSE;

	if (bProcess)
	{
		bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken); 
	}
	else
	{
		bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken);
	}

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;

    // Get the privileges
    // ==================

    DWORD dwLen;
    TOKEN_USER tu;
	memset(&tu,0,sizeof(TOKEN_USER));
    bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);
    
    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
    {
        CloseHandle(hToken);
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen, 
                                &dwLen);
    if(!bRes)
    {
        CloseHandle(hToken);
        delete [] pBuffer;
        return WBEM_E_ACCESS_DENIED;
    }

    // Iterate through all the privileges and enable them all
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
    }

    // Store the information back into the token
    // =========================================

    bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
    delete [] pBuffer;
    CloseHandle(hToken);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;
    else
        return WBEM_S_NO_ERROR;
}

#endif

#ifdef UNICODE
HRESULT GetCurrentSecuritySettings(DWORD *pdwAuthnSvc, DWORD *pdwAuthzSvc,
								   DWORD *pdwAuthLevel, DWORD *pdwImpLevel,
								   DWORD *pdwCapabilities)
{
	HRESULT hr = WBEM_E_FAILED;
    IServerSecurity * pss = NULL;
    hr = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pss);

#if 0
	DWORD dwBuffSz = 1024;
	wchar_t strBuff[1024];
	GetUserName(strBuff, &dwBuffSz);
#endif

    if(S_OK == hr)
    {
        pss->QueryBlanket(pdwAuthnSvc, pdwAuthzSvc, NULL, 
                pdwAuthLevel, NULL, NULL, pdwCapabilities);
        pss->Release();
    }
	else
	{
		if (SUCCEEDED(hr))
		{
			hr = WBEM_E_FAILED;
		}
	}

	if (SUCCEEDED(hr))
	{
		DWORD dwVersion = GetVersion();

		if (dwVersion < 0x80000000)
		{
			if ( 4 < (DWORD)(LOBYTE(LOWORD(dwVersion))) )
			{
				//we're on win2k force static cloaking...
				*pdwCapabilities = EOAC_STATIC_CLOAKING;
			}
		}

		//get implevel...
		HANDLE hThreadTok = NULL;
		hr = WBEM_E_FAILED;

		if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok) )
		{
			DWORD dwBytesReturned = 0;
			DWORD dwThreadImpLevel = 0;

			if (GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwThreadImpLevel,
										sizeof(DWORD), &dwBytesReturned)) 
			{
				hr = WBEM_NO_ERROR;

				switch(dwThreadImpLevel)
				{
					case SecurityAnonymous:
					{
						*pdwImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
					}
					break;

					case SecurityIdentification:
					{
						*pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
					}
					break;

					case SecurityImpersonation:
					{
						*pdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
					}
					break;

					case SecurityDelegation:
					{
						*pdwImpLevel = RPC_C_IMP_LEVEL_DELEGATE;
					}
					break;
					
					default:
					{
						hr = WBEM_E_FAILED;
					}
				}

#ifdef VP_BUILD_AS_EXE
				if (*pdwImpLevel < RPC_C_IMP_LEVEL_IMPERSONATE)
				{
					*pdwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
				}
#endif
			}

			CloseHandle(hThreadTok);
		}
	}
    
	return hr;
}
#endif

HRESULT SetSecurityLevelAndCloaking(IUnknown* pInterface, const wchar_t* prncpl)
{
#ifdef UNICODE

	//first get current security info then set it on the proxy...
    DWORD dwAuthnSvc = 0;
    DWORD dwAuthzSvc = 0;
    DWORD dwAuthLevel = 0;
    DWORD dwImpLevel = 0;
    DWORD dwCapabilities = 0;

	HRESULT hr = GetCurrentSecuritySettings(&dwAuthnSvc, &dwAuthzSvc, &dwAuthLevel, &dwImpLevel, &dwCapabilities);

	if (SUCCEEDED(hr))
	{
#ifdef VP_BUILD_AS_EXE
		EnableAllPrivileges(FALSE);
#endif
		DWORD dwVersion = GetVersion();
		OLECHAR *t_pname = NULL;

		if (dwVersion < 0x80000000)
		{
			if ( 4 < (DWORD)(LOBYTE(LOWORD(dwVersion))) )
			{
				//we're on win2k force COLE_DEFAULT_PRINCIPAL...
				t_pname = COLE_DEFAULT_PRINCIPAL;

				if ((dwImpLevel > 3) && (prncpl != COLE_DEFAULT_PRINCIPAL))
				{
					dwAuthnSvc = RPC_C_AUTHN_GSS_KERBEROS;
				}
			}
		}

		hr = WbemSetProxyBlanket(pInterface,
							dwAuthnSvc,//16 
							dwAuthzSvc,//RPC_C_AUTHZ_NONE 
							t_pname, //prncpl,
							dwAuthLevel, //RPC_C_AUTHN_LEVEL_CONNECT
							dwImpLevel, //RPC_C_IMP_LEVEL_IMPERSONATE
							NULL,
							dwCapabilities); //0x20

		//there is no IClientSecurity, we must be running inproc!
		if (hr == E_NOINTERFACE)
		{
			hr = S_OK;
		}

#if 0
		if (SUCCEEDED(hr))
		{
			IClientSecurity *t_pCliSec = NULL;
			HRESULT t_hr = pInterface->QueryInterface(IID_IClientSecurity, (void **) &t_pCliSec);

			if (SUCCEEDED(t_hr))
			{
				DWORD t_AuthnSvc = 0;
				DWORD t_AuthzSvc = 0;
				wchar_t *t_pServerPrincName = NULL;
				DWORD t_AuthnLevel = 0;
				DWORD t_ImpLevel = 0;
				DWORD t_Capabilities = 0;
				t_hr = t_pCliSec->QueryBlanket(pInterface, &t_AuthnSvc,
												&t_AuthzSvc, &t_pServerPrincName,
												&t_AuthnLevel, &t_ImpLevel,
												NULL, &t_Capabilities);

				if (SUCCEEDED(t_hr))
				{
					if (t_pServerPrincName)
					{
						CoTaskMemFree(t_pServerPrincName);
					}
				}

				t_pCliSec->Release();
			}
		}
#endif
	}
#else
	HRESULT hr = WBEM_NO_ERROR;
#endif

    return hr;
}

BOOL IsInObjectPath(ParsedObjectPath *a_ParsedObjectPath, const wchar_t *a_key)
{
	if ( (!a_ParsedObjectPath->IsInstance()) || (a_ParsedObjectPath->m_bSingletonObj) || (a_ParsedObjectPath->m_paKeys == NULL) )
	{
		return FALSE;
	}

	for (int x = 0; x < a_ParsedObjectPath->m_dwNumKeys; x++)
	{
		if ((a_ParsedObjectPath->m_paKeys[x]->m_pName != NULL)
			&& (_wcsicmp(a_key, a_ParsedObjectPath->m_paKeys[x]->m_pName) == 0))
		{
			return TRUE;
		}
	}

	return FALSE;
}

//returns TRUE if VARIANTs are equal
BOOL CompareKeyValueVariants(const VARIANT &a_v1, const VARIANT &a_v2)
{
	BOOL retVal = FALSE;

	if (a_v1.vt == a_v2.vt)
	{
		switch (a_v1.vt)
		{
            case VT_BSTR:
			{
                retVal = (_wcsicmp(a_v1.bstrVal, a_v2.bstrVal) == 0);
                break;
			}

            case VT_I4:
			{
                retVal = (a_v1.lVal == a_v2.lVal);
                break;
			}

            case VT_I2:
			{
                retVal = (a_v1.iVal == a_v2.iVal);
                break;
			}

            case VT_UI1:
			{
                retVal = (a_v1.bVal == a_v2.bVal);
                break;
			}

            case VT_BOOL:
			{
                retVal = (V_BOOL(&a_v1) == V_BOOL(&a_v2));
                break;
			}
			
			default:
			{
			}
		}
	}

	return retVal;
}

//this function assumes class 1 is derived from class2 or vice versa
//returns TRUE if paths are equal
BOOL CompareInstPaths(const wchar_t *a_path1, const wchar_t *a_path2)
{
	BOOL retVal = FALSE;

	if ((a_path1 == NULL) || (a_path2 == NULL))
	{
		return retVal;
	}

	CObjectPathParser t_objectPathParser;
	wchar_t* t_objPath1 = UnicodeStringDuplicate(a_path1);
	wchar_t* t_objPath2 = UnicodeStringDuplicate(a_path2);
	ParsedObjectPath *t_parsedpath1 = NULL;
	ParsedObjectPath *t_parsedpath2 = NULL;

	if ( (t_objectPathParser.Parse(t_objPath1, &t_parsedpath1) == 0) &&
		(t_objectPathParser.Parse(t_objPath2, &t_parsedpath2) == 0) &&
		t_parsedpath1->IsInstance() && t_parsedpath2->IsInstance())
	{
		if (t_parsedpath1->m_dwNumKeys == t_parsedpath2->m_dwNumKeys)
		{
			retVal = TRUE;

			//single properties
			if ((t_parsedpath1->m_dwNumKeys == 1) &&
				((t_parsedpath1->m_paKeys[0]->m_pName == NULL) || (t_parsedpath2->m_paKeys[0]->m_pName == NULL)))
			{
				//compare the values...
				retVal = CompareKeyValueVariants(t_parsedpath1->m_paKeys[0]->m_vValue,
													t_parsedpath2->m_paKeys[0]->m_vValue);
			}
			else
			{
				//any property mismatch set retVal FALSE!
				for (DWORD i = 0; retVal && (i < t_parsedpath1->m_dwNumKeys); i++)
				{
					retVal = FALSE;

					if(t_parsedpath1->m_paKeys[i]->m_pName == NULL)
					{
						break;
					}

					for (DWORD j = 0; j < t_parsedpath2->m_dwNumKeys; j++)
					{
						if(t_parsedpath2->m_paKeys[j]->m_pName == NULL)
						{
							break;
						}

						if (_wcsicmp(t_parsedpath1->m_paKeys[i]->m_pName, t_parsedpath2->m_paKeys[j]->m_pName) == 0)
						{
							//compare the values...
							retVal = CompareKeyValueVariants(t_parsedpath1->m_paKeys[i]->m_vValue,
																t_parsedpath2->m_paKeys[j]->m_vValue);
						}
					}
				}
			}
		}
	}

	delete [] t_objPath1;
	delete [] t_objPath2;

	if (t_parsedpath1 != NULL)
	{
		delete t_parsedpath1;
	}

	if (t_parsedpath2 != NULL)
	{
		delete t_parsedpath2;
	}

	return retVal;
}

WbemTaskObject :: WbemTaskObject (

	CViewProvServ *a_Provider ,
	IWbemObjectSink *a_NotificationHandler ,
	ULONG a_OperationFlag ,
	IWbemContext *a_Ctx,
	IWbemServices *a_Serv,
	CWbemServerWrap *a_ServerWrap

) :m_OperationFlag ( a_OperationFlag ) ,
	m_Provider ( NULL ) ,
	m_NotificationHandler ( NULL ) ,
	m_Ctx ( NULL ) ,
	m_ClassObject ( NULL ),
	m_RPNPostFilter( NULL),
	m_ClassName(NULL),
	m_Ref ( 1 ),
	m_iQueriesAnswered ( 0 ),
	m_iQueriesAsked ( 0 ), 
	m_StatusHandle(NULL),
	m_bAssoc ( FALSE ),
	m_bSingleton ( FALSE ),
	m_Serv ( NULL ),
	m_bIndicate ( TRUE ) ,
	m_ResultReceived ( FALSE ),
	m_ServerWrap (NULL)
{
	m_Provider = a_Provider ;
	m_Provider->AddRef () ;

	m_Serv = a_Serv;

	if (m_Serv != NULL)
	{
		m_Serv->AddRef();
	}

	m_ServerWrap = a_ServerWrap;

	if (m_ServerWrap != NULL)
	{
		m_ServerWrap->AddRef();
	}

	if ((m_Serv == NULL) && (m_ServerWrap == NULL))
	{
		m_Serv = m_Provider->GetServer();
	}


	m_NotificationHandler = a_NotificationHandler ;
	m_NotificationHandler->AddRef () ;

	if (a_Ctx)
	{
		m_Ctx = a_Ctx ;
		m_Ctx->AddRef () ;
	}
}

WbemTaskObject :: ~WbemTaskObject ()
{
	if (m_NotificationHandler)
	{
		m_NotificationHandler->Release () ;
	}

	if (m_Ctx)
	{
		m_Ctx->Release () ;
	}

	if (m_ClassName)
	{
		SysFreeString(m_ClassName);
	}

	if ( m_ClassObject )
	{
		m_ClassObject->Release () ;
	}

	if (m_Serv != NULL)
	{
		m_Serv->Release();
	}

	if (m_ServerWrap != NULL)
	{
		m_ServerWrap->Release();
	}

	int isrc = m_SourceArray.GetSize();
	int ins = m_NSpaceArray.GetSize();
	int i = isrc;

	if (isrc > ins)
	{
		i = ins;

		for (int x = ins; x < isrc; x++)
		{
			delete m_SourceArray[x];
		}
	}
	else if (isrc < ins)
	{
		for (int x = isrc; x < ins; x++)
		{
			delete m_NSpaceArray[x];
		}
	}

	for (int x = 0; x < i; x++)
	{
		delete m_SourceArray[x];
		delete m_NSpaceArray[x];
	}

	m_SourceArray.RemoveAll();
	m_NSpaceArray.RemoveAll();

	for (x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if (m_ObjSinkArray[x] != NULL)
		{
			m_ObjSinkArray[x]->Release();
		}
	}

	m_ObjSinkArray.RemoveAll();
	m_ClassToIndexMap.RemoveAll();
	m_EnumerateClasses.RemoveAll();
	
	//this decrements objectsinprogress so MUST be done LAST!!
	if (m_Provider)
		m_Provider->Release ();
}

WbemProvErrorObject &WbemTaskObject :: GetErrorObject ()
{
	return m_ErrorObject ; 
}	

BOOL WbemTaskObject :: SetClass(const wchar_t* a_Class)
{
	m_ClassName = SysAllocString(a_Class);
	BOOL ret = GetClassObject(m_Serv, m_ClassName, &m_ClassObject, &m_ServerWrap);
	return ret;
}

BOOL WbemTaskObject :: GetClassObject ( IWbemServices* pServ, BSTR a_Class, IWbemClassObject** ppClass, CWbemServerWrap **a_pServWrap)
{

	if ((NULL == a_Class) || (NULL == ppClass) ||
		((NULL == pServ) && ((NULL == a_pServWrap) || (NULL == (*a_pServWrap))))
		)
	{
		return FALSE;
	}
	else
	{
		*ppClass = NULL;
	}

	HRESULT t_Result = WBEM_E_FAILED;

	if (*a_pServWrap)
	{
		IWbemServices *ptmpServ = (*a_pServWrap)->GetServerOrProxy();

		if (ptmpServ)
		{
			t_Result = ptmpServ->GetObject(a_Class, 0, m_Ctx, ppClass,	NULL);

			if ( FAILED(t_Result) && (HRESULT_FACILITY(t_Result) != FACILITY_ITF) && (*a_pServWrap)->IsRemote())
			{
				if ( SUCCEEDED(UpdateConnection(a_pServWrap, &ptmpServ)) )
				{
					if (ptmpServ)
					{
						t_Result = ptmpServ->GetObject(a_Class, 0, m_Ctx, ppClass,	NULL);
					}
				}
			}

			if (ptmpServ)
			{
				(*a_pServWrap)->ReturnServerOrProxy(ptmpServ);
			}
		}
	}
	else
	{
		t_Result = pServ->GetObject(a_Class, 0, m_Ctx, ppClass,	NULL);
	}

	if (FAILED(t_Result))
	{
		*ppClass = NULL;
		return FALSE;
	}

	return TRUE;
}


BOOL WbemTaskObject :: GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;
	IWbemClassObject *t_ErrorObject = NULL ;

	BOOL t_Status = TRUE ;

	WbemProvErrorObject t_ErrorStatusObject ;
	if ( t_NotificationClassObject = m_Provider->GetExtendedNotificationObject ( t_ErrorStatusObject, m_Ctx ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;

			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , &t_Variant , 0 ) ;
			VariantClear ( &t_Variant ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = m_ErrorObject.GetStatus () ;

				t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSCODE , 0 , &t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( m_ErrorObject.GetMessage () ) 
					{
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

						t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , &t_Variant , 0 ) ;
						VariantClear ( &t_Variant ) ;

						if ( ! SUCCEEDED ( t_Result ) )
						{
							(*a_NotifyObject)->Release () ;
							t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
						}
					}
				}
				else
				{
					(*a_NotifyObject)->Release () ;
					t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
			}

			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
		}
	}
	else
	{
		t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
	}

	return t_Status ;
}

BOOL WbemTaskObject :: GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;
	BOOL t_Status = TRUE ;
	WbemProvErrorObject t_ErrorStatusObject ;

	if ( t_NotificationClassObject = m_Provider->GetNotificationObject ( t_ErrorStatusObject, m_Ctx ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;
			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;
			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , &t_Variant , 0 ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_ErrorObject.GetMessage () ) 
				{
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;
					t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , &t_Variant , 0 ) ;
					VariantClear ( &t_Variant ) ;

					if ( ! SUCCEEDED ( t_Result ) )
					{
						t_Status = FALSE ;
						(*a_NotifyObject)->Release () ;
						(*a_NotifyObject)=NULL ;
					}
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				(*a_NotifyObject)=NULL ;
				t_Status = FALSE ;
			}

			VariantClear ( &t_Variant ) ;
			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}

BOOL WbemTaskObject :: ParseAndProcessClassQualifiers(WbemProvErrorObject &a_ErrorObject,
													  ParsedObjectPath *a_ParsedObjectPath,
													  CMap<CStringW, LPCWSTR, int, int> *parentMap)
{
	if (m_ClassObject == NULL)
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Failed to get class object representing this class." ) ;
		return FALSE;
	}
	
	IWbemQualifierSet *pQuals = NULL;

	if ( FAILED(m_ClassObject->GetQualifierSet(&pQuals)) )
	{
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Failed to get qualifiers for this class." ) ;
		return FALSE;
	}

	VARIANT v;
	VariantInit(&v);
	BOOL bUnion = FALSE;
	BOOL retVal = TRUE;

	if (SUCCEEDED(pQuals->Get(VIEW_QUAL_PROVIDER, 0, &v, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			m_ProviderName = v.bstrVal;
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Provider qualifier is incorrect for this class." ) ;
		}
	}
	else
	{
		retVal = FALSE;
		a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Provider qualifier should be present for this class." ) ;
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_FILTER, 0, &v, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			CTextLexSource querySource(v.bstrVal);
			SQL1_Parser sqlParser(&querySource);
			
			if (SQL1_Parser::SUCCESS == sqlParser.Parse(&m_RPNPostFilter))
			{
				if (_wcsicmp(m_ClassName, m_RPNPostFilter->bsClassName) == 0)
				{
					if (m_RPNPostFilter->nNumberOfProperties != 0)
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"PostJoinFilter qualifier may not limit the properties returned." ) ;
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"PostJoinFilter qualifier does not match this class." ) ;
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to parse PostJoinFilter qualifier." ) ;
			}
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"PostJoinFilter qualifier should be a single WQL string." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_JOIN, 0, &v, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			retVal = m_JoinOnArray.Set(v.bstrVal);

			if (!retVal)
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to parse JoinOn qualifier." ) ;
			}
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"JoinOn qualifier should be a single string." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_UNION, 0, &v, NULL)) )
	{
		if (v.vt == VT_BOOL)
		{
			bUnion = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Union qualifier should be a boolean." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_ASSOC, 0, &v, NULL)) )
	{
		if (v.vt == VT_BOOL)
		{
			m_bAssoc = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Association qualifier should be a boolean." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_SNGLTN, 0, &v, NULL)) )
	{
		if (v.vt == VT_BOOL)
		{
			m_bSingleton = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Singleton qualifier should be a boolean." ) ;
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_ENUM_CLASS, 0, &v, NULL)) )
	{
		if (v.vt == VT_BSTR)
		{
			m_EnumerateClasses.SetAt(v.bstrVal, 0);
		}
		else if (v.vt == (VT_BSTR | VT_ARRAY))
		{
			if (SafeArrayGetDim(v.parray) == 1)
			{
				LONG count = v.parray->rgsabound[0].cElements;
				BSTR HUGEP *pbstr;

				if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
				{
					for (LONG x = 0; x < count; x++)
					{
						m_EnumerateClasses.SetAt(pbstr[x], 0);
					}

					SafeArrayUnaccessData(v.parray);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Failed to access EnumerateClasses array.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"EnumerateClasses array qualifier has incorrect dimensions.");
			}
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
			a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
			a_ErrorObject.SetMessage (L"EnumerateClasses qualifier should be an array of strings.");
		}
	}

	VariantClear(&v);
	VariantInit(&v);

	if (retVal &&
		((bUnion && !m_bAssoc && !m_JoinOnArray.IsValid()) ||
		(!bUnion && m_bAssoc && !m_JoinOnArray.IsValid()) ||
		(!bUnion && !m_bAssoc && m_JoinOnArray.IsValid())))
	{
		if (m_JoinOnArray.IsValid())
		{
			if (!m_JoinOnArray.ValidateJoin())
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Join validation failed");
			}
		}

		if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_SOURCES, 0, &v, NULL)) )
		{
			if (v.vt == VT_BSTR)
			{
				CSourceQualifierItem* srcItem = new CSourceQualifierItem(v.bstrVal);
				
				if (srcItem->IsValid())
				{
					int indx = m_SourceArray.Add(srcItem);
					m_ClassToIndexMap.SetAt(srcItem->GetClassName(), indx);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Invalid source query.");
					delete srcItem;
				}
			}
			else if (v.vt == (VT_BSTR | VT_ARRAY))
			{
				if (SafeArrayGetDim(v.parray) == 1)
				{
					LONG count = v.parray->rgsabound[0].cElements;
					BSTR HUGEP *pbstr;

					if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
					{
						for (LONG x = 0; x < count; x++)
						{
							CSourceQualifierItem* srcItem = new CSourceQualifierItem(pbstr[x]);
							
							if (srcItem->IsValid())
							{
								int indx = m_SourceArray.Add(srcItem);
								m_ClassToIndexMap.SetAt(srcItem->GetClassName(), indx);
							}
							else
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
								a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
								a_ErrorObject.SetMessage (L"Invalid source query.");
								delete srcItem;
								break;
							}
						}

						SafeArrayUnaccessData(v.parray);
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
						a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
						a_ErrorObject.SetMessage (L"Invalid source array qualifier.");
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Invalid source array qualifier dimensions.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Invalid source array qualifier type.");
			}
		}
		else
		{
			if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Source array qualifier not found.");
			}
		}

		VariantClear(&v);
		VariantInit(&v);

		if (retVal && SUCCEEDED(pQuals->Get(VIEW_QUAL_NAMESPACES, 0, &v, NULL)) )
		{
			if (v.vt == VT_BSTR)
			{
				CNSpaceQualifierItem* nsItem = new CNSpaceQualifierItem(v.bstrVal);

				if (nsItem->IsValid())
				{
					m_NSpaceArray.Add(nsItem);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Invalid Namespace in namespaces array.");
					delete nsItem;
				}
			}
			else if (v.vt == (VT_BSTR | VT_ARRAY))
			{
				if (SafeArrayGetDim(v.parray) == 1)
				{
					LONG count = v.parray->rgsabound[0].cElements;
					BSTR HUGEP *pbstr;

					if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
					{
						for (LONG x = 0; x < count; x++)
						{
							CNSpaceQualifierItem* nsItem = new CNSpaceQualifierItem(pbstr[x]);

							if (nsItem->IsValid())
							{
								m_NSpaceArray.Add(nsItem);
							}
							else
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
								a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
								a_ErrorObject.SetMessage (L"Invalid Namespace in namespaces array qualifier.");
								delete nsItem;
								break;
							}
						}

						SafeArrayUnaccessData(v.parray);
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
						a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
						a_ErrorObject.SetMessage (L"Failed to access Namespace array qualifier.");
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Namespace array qualifier has invalid dimensions.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Namespace array qualifier has invalid type.");
			}
		}
		else
		{
			if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Namespace array qualifier not found.");
			}
		}

		VariantClear(&v);

		if (retVal && (m_NSpaceArray.GetSize() != m_SourceArray.GetSize()))
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
			a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
			a_ErrorObject.SetMessage (L"Namespace array qualifier does not match source array qualifier size.");
		}

		if (retVal && m_bAssoc && m_SourceArray.GetSize() != 1)
		{
			if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Association views may only have a single source.");
			}
		}
	}
	else
	{
		if (retVal)
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
			a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
			a_ErrorObject.SetMessage (L"ONE class qualifier out of \"JoinOn\", \"Union\" or \"Association\" MUST be specified.");
		}
	}

	pQuals->Release();

	//connect and get classes!
	if (retVal)
	{
		IWbemClassObject*** arrayOfArrayOfObjs = new IWbemClassObject**[m_NSpaceArray.GetSize()];

		for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
		{
			UINT nsCount = m_NSpaceArray[x]->GetCount();
			CWbemServerWrap** servArray = new CWbemServerWrap*[nsCount];
			IWbemClassObject** classArray = new IWbemClassObject*[nsCount];
			IWbemClassObject* classObj = NULL;
			CStringW* pathArray = m_NSpaceArray[x]->GetNamespacePaths();

			for (UINT i = 0; i < nsCount; i++)
			{
				classArray[i] = NULL;

				if ( FAILED(Connect(pathArray[i], &(servArray[i]))) )
				{
					servArray[i] = NULL;
				}
				else if (servArray[i] != NULL)
				{
					if (GetClassObject(NULL, m_SourceArray[x]->GetClassName(), &classArray[i], &servArray[i])
						&& (classObj == NULL))
					{
						classObj = classArray[i];
					}
				}
			}

			if (NULL != classObj)
			{
				m_SourceArray[x]->SetClassObject(classObj);
			}
			
			arrayOfArrayOfObjs[x] = classArray;
			m_NSpaceArray[x]->SetServerPtrs(servArray);
		}

		//check properties and keys
		SAFEARRAY* pNames = NULL;
		DWORD dwKeyCount = 0;
		BOOL bKeysOK = TRUE;

		if (retVal && SUCCEEDED(m_ClassObject->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &pNames)) )
		{
			if (SafeArrayGetDim(pNames) == 1)
			{
				LONG arraylen = pNames->rgsabound[0].cElements;
				BSTR HUGEP *pbstr;

				if ( SUCCEEDED(SafeArrayAccessData(pNames, (void HUGEP**)&pbstr)) )
				{
					for (LONG i = 0; retVal && (i < arraylen); i++)
					{
						IWbemQualifierSet* pPropQuals = NULL;

						if ( SUCCEEDED(m_ClassObject->GetPropertyQualifierSet(pbstr[i], &pPropQuals)) )
						{
							BOOL bHidden = FALSE;
							BOOL bKey = FALSE;
							CIMTYPE ct = 0;

							if ( SUCCEEDED(pPropQuals->Get(VIEW_QUAL_HIDDEN, 0, &v, NULL)) )
							{
								if (v.vt == VT_BOOL)
								{
									bHidden = (v.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
								}
								else
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Hidden qualifier should be boolean.");
								}
							}

							VariantInit(&v);

							if ( SUCCEEDED(pPropQuals->Get(VIEW_QUAL_KEY, 0, &v, NULL)) )
							{
								if (v.vt == VT_BOOL)
								{
									if (v.boolVal == VARIANT_TRUE)
									{
										bKey = TRUE;
										dwKeyCount++;

										if (bKeysOK && (a_ParsedObjectPath != NULL))
										{
											bKeysOK = IsInObjectPath(a_ParsedObjectPath, pbstr[i]);

											if ((!bKeysOK) && (dwKeyCount > 1))
											{
												retVal = FALSE;
												a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_PARAMETER);
												a_ErrorObject.SetWbemStatus (WBEM_E_INVALID_OBJECT_PATH);
												a_ErrorObject.SetMessage (L"Keys of class do not match those  in the object path passed.");
											}
										}
									}
									else
									{
										bKey = FALSE;
									}
								}
								else
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Key qualifier should be boolean.");
								}
							}

							VariantClear(&v);
							CStringW refStr;
							BOOL bDirect = FALSE;

							if ( SUCCEEDED(m_ClassObject->Get(pbstr[i], 0, NULL, &ct, NULL)) )
							{
								if (ct == CIM_REFERENCE)
								{
									VariantInit(&v);

									if ( SUCCEEDED(pPropQuals->Get(VIEW_QUAL_TYPE, 0, &v, NULL)) )
									{
										if (v.vt == VT_BSTR)
										{
											//bstrVal is either "ref" OR ref:classname
											wchar_t* tmp = v.bstrVal;
											tmp += 4;

											if (*tmp != '\0')
											{
												refStr = tmp;
											}
											
											VARIANT vDirect;
											VariantInit(&vDirect);

											if ( SUCCEEDED(pPropQuals->Get(VIEW_QUAL_DIRECT, 0, &vDirect, NULL)) )
											{
												if (vDirect.vt == VT_BOOL)
												{
													bDirect = (vDirect.boolVal == VARIANT_TRUE) ? TRUE : FALSE;
												}
												else
												{
													retVal = FALSE;
													a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
													a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
													a_ErrorObject.SetMessage (L"Direct qualifier should be boolean");
												}

												VariantClear(&vDirect);
											}
										}
										else
										{
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
											a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
											a_ErrorObject.SetMessage (L"Cimtype qualifier should be a string");
										}

										VariantClear(&v);
									}
									else
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
										a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
										a_ErrorObject.SetMessage (L"Failed to get the property type from the  class definition");
									}
								}
							}
							else
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
								a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
								a_ErrorObject.SetMessage (L"Failed to get a property type from the  class definition");
							}

							VariantInit(&v);

							if ( retVal && SUCCEEDED(pPropQuals->Get(VIEW_QUAL_PROPERTY, 0, &v, NULL)) )
							{
								CPropertyQualifierItem* propItem = new CPropertyQualifierItem(pbstr[i], bHidden, bKey, ct, refStr, bDirect);

								if (v.vt == VT_BSTR)
								{
									if (1 != m_SourceArray.GetSize())
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
										a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
										a_ErrorObject.SetMessage (L"Property sources qualifier array size does not match source list.");
									}
									else
									{
										CStringW t_propNameEntry(v.bstrVal);
										t_propNameEntry.TrimLeft();
										t_propNameEntry.TrimRight();

										if (t_propNameEntry.IsEmpty())
										{
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
											a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
											a_ErrorObject.SetMessage (L"Property sources qualifier must name at least one source property.");
										}
										else
										{
											propItem->m_SrcPropertyNames.Add(t_propNameEntry);
										}
									}
								}
								else if (v.vt == (VT_BSTR | VT_ARRAY))
								{
									if (SafeArrayGetDim(v.parray) == 1)
									{
										LONG count = v.parray->rgsabound[0].cElements;
										BSTR HUGEP *pPropbstr;

										if (count != m_SourceArray.GetSize())
										{
											retVal = FALSE;
											a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
											a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
											a_ErrorObject.SetMessage (L"Property sources qualifier array size does not match source list.");
										}
										else
										{
											if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pPropbstr)) )
											{
												BOOL bNoName = TRUE;

												for (LONG x = 0; retVal && (x < count); x++)
												{
													if ((pPropbstr[x] != NULL) && (*(pPropbstr[x]) != L'\0'))
													{
														IWbemClassObject* t_srcObj = m_SourceArray[x]->GetClassObject();

														if (t_srcObj != NULL)
														{
															CIMTYPE src_ct;

															if (SUCCEEDED(t_srcObj->Get(pPropbstr[x], 0, NULL, &src_ct, NULL)))
															{
																if (src_ct != ct)
																{
																	retVal = FALSE;
																	a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
																	a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
																	a_ErrorObject.SetMessage (L"Source property type does not match view class.");
																}
															}
															else
															{
																retVal = FALSE;
																a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
																a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
																a_ErrorObject.SetMessage (L"Source property not found in source class.");
															}

															t_srcObj->Release();
														}

													}

													CStringW t_propNameEntry(pPropbstr[x]);
													t_propNameEntry.TrimLeft();
													t_propNameEntry.TrimRight();
													propItem->m_SrcPropertyNames.Add(t_propNameEntry);

													if (bNoName && !t_propNameEntry.IsEmpty())
													{
														bNoName = FALSE;
													}
												}

												if (bNoName)
												{
													retVal = FALSE;
													a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
													a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
													a_ErrorObject.SetMessage (L"Property sources qualifier must name at least one source property.");
												}

												SafeArrayUnaccessData(v.parray);
											}
											else
											{
												retVal = FALSE;
												a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
												a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
												a_ErrorObject.SetMessage (L"Property sources qualifier array has incorrect dimensions.");
											}
										}
									}
									else
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
										a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
										a_ErrorObject.SetMessage (L"Failed to access property sources array qualifier.");
									}
								}
								else
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Property sources qualifier has incorrect type.");
								}

								VariantClear(&v);
								m_PropertyMap.SetAt(pbstr[i], propItem);
							}
							else
							{
								if (retVal)
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
									a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
									a_ErrorObject.SetMessage (L"Failed to get property sources qualifier.");
								}
							}

							pPropQuals->Release();
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
							a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
							a_ErrorObject.SetMessage (L"Failed to access property qualifiers.");
						}
					}

					SafeArrayUnaccessData(pNames);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"Could not access class property names array.");
				}
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Class property names array has invalid dimensions.");
			}

			SafeArrayDestroy(pNames);
		}
		else
		{
			if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
				a_ErrorObject.SetMessage (L"Failed to get class property names.");
			}
		}

		if (retVal)
		{
			if (a_ParsedObjectPath != NULL)
			{
				if (bKeysOK)
				{
					if (dwKeyCount != a_ParsedObjectPath->m_dwNumKeys)
					{
						retVal = FALSE;
					}
				}
				else
				{
					if ((dwKeyCount != 1) || (a_ParsedObjectPath->m_dwNumKeys != 1) || (a_ParsedObjectPath->m_paKeys[0]->m_pName != NULL))
					{
						retVal = FALSE;
					}
				}

				if (!retVal)
				{
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_PARAMETER);
					a_ErrorObject.SetWbemStatus (WBEM_E_INVALID_OBJECT_PATH);
					a_ErrorObject.SetMessage (L"Keys of class do not match those in the object path passed.");
				}
			}
		}

		//final verifications
		//===================

		if (retVal)
		{
			//make sure all enumeration classes exist
			POSITION pos = m_EnumerateClasses.GetStartPosition();

			while (pos)
			{
				int val;
				CStringW tmpStr;
				m_EnumerateClasses.GetNextAssoc(pos, tmpStr, val);

				if (!m_ClassToIndexMap.Lookup(tmpStr, val))
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"EnumerateClasses qualifier contains an entry not found in the source list.");
					break;
				}
			}
		}

		if (retVal)
		{
			if (m_EnumerateClasses.GetCount() == m_SourceArray.GetSize())
			{
				//pointless qualifier if all classes mentioned
				m_EnumerateClasses.RemoveAll();
			}

			if (m_JoinOnArray.IsValid())
			{
				if (!ValidateJoin())
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
					a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
					a_ErrorObject.SetMessage (L"JoinOn qualifier is semantically invalid.");
				}
			}
#if 0
			else
			{
				//check all union and assoc source keys are view
				//keys this is done in ValidateClassDependencies
				//since both checks need to loop through the arrays
				//of class objects
			}
#endif
		}

		//must delete each sub-array in ValidateClassDependencies
		//as well as release all the ClassObjects!!
		if (retVal)
		{
			if (!ValidateClassDependencies(arrayOfArrayOfObjs, parentMap))
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS);
				a_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
		
				if (m_JoinOnArray.IsValid())
				{
					a_ErrorObject.SetMessage (L"Loop in provided classes detected.");
				}
				else
				{
					a_ErrorObject.SetMessage (L"Loop in provided classes detected or key mismatch between view and source class.");
				}
			}
		}
		else
		{
			for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
			{
				UINT nsCount = m_NSpaceArray[x]->GetCount();

				for (UINT i = 0; i < nsCount; i++)
				{
					if (arrayOfArrayOfObjs[x][i] != NULL)
					{
						arrayOfArrayOfObjs[x][i]->Release();
					}
				}

				delete [] arrayOfArrayOfObjs[x];
			}
		}

		delete [] arrayOfArrayOfObjs;
	}

	return retVal;
}

//takes an object path to a view class and translates it
//to the object path of the source instance requested and optionally
//returns the object.
BSTR WbemTaskObject::MapFromView(BSTR path, const wchar_t* src, IWbemClassObject** pInst, BOOL bAllprops)
{
	BSTR retVal = NULL;

	if (path == NULL)
	{
		return retVal;
	}

	CObjectPathParser objectPathParser;
	wchar_t* objPath = UnicodeStringDuplicate(path);
	ParsedObjectPath *parsedObjectPath = NULL;

	if (objectPathParser.Parse(objPath, &parsedObjectPath) == 0)
	{
		wchar_t* tmp = parsedObjectPath->GetNamespacePart();
		CWbemServerWrap *pServ = NULL;

		if (tmp != NULL)
		{
			BOOL bServOK = TRUE;

			if (parsedObjectPath->m_pServer != NULL)
			{
				if (wcscmp(parsedObjectPath->m_pServer, L".") != 0)
				{
					bServOK = FALSE;
					VARIANT v;

					if ( SUCCEEDED(m_ClassObject->Get(WBEM_PROPERTY_SERVER, 0, &v, NULL, NULL)))
					{
						if ((v.vt == VT_BSTR) && (_wcsicmp(v.bstrVal, parsedObjectPath->m_pServer) == 0))
						{
							bServOK = TRUE;
						}
					}
					
					VariantClear(&v);
				}
			}

			if (bServOK)
			{
				wchar_t* tmppath = m_Provider->GetNamespacePath()->GetNamespacePath();

				if (tmppath != NULL)
				{
					if (_wcsicmp(tmppath, tmp) == 0)
					{
						Connect(tmppath, &pServ);
					}

					delete [] tmppath;
				}
			}

			delete [] tmp;
		}
		else
		{
			wchar_t* tmppath = m_Provider->GetNamespacePath()->GetNamespacePath();

			if (tmppath != NULL)
			{
				Connect(tmppath, &pServ);
				delete [] tmppath;
			}
		}

		if (pServ != NULL)
		{
			GetObjectTaskObject *t_AsyncEvent = new GetObjectTaskObject (m_Provider, 
														path, 0, m_NotificationHandler, m_Ctx,
														NULL, pServ);
			IWbemClassObject* pInstObj = NULL;

			if (t_AsyncEvent->GetSourceObject(src, &pInstObj, bAllprops) && pInstObj != NULL)
			{
				VARIANT v;

				if (SUCCEEDED(pInstObj->Get(WBEM_PROPERTY_PATH, 0, &v, NULL, NULL)) )
				{
					if (v.vt == VT_BSTR)
					{
						retVal = SysAllocString(v.bstrVal);

						if (pInst != NULL)
						{
							pInstObj->AddRef();
							*pInst = pInstObj;
						}
					}
				}

				VariantClear(&v);
				pInstObj->Release();
			}

			t_AsyncEvent->Release();
			pServ->Release();
		}
	}

	delete [] objPath;

	if (parsedObjectPath != NULL)
	{
		delete parsedObjectPath;
	}

	return retVal;
}

//takes an object path to a source and translates it
//to the object path of the view instance requested.
BSTR WbemTaskObject::MapToView(BSTR path, const wchar_t* src, CWbemServerWrap **a_ns)
{
	BSTR retVal = NULL;
	wchar_t* tmppath = m_Provider->GetNamespacePath()->GetNamespacePath();
	CWbemServerWrap *pServ = NULL;

	if (tmppath != NULL)
	{
		Connect(tmppath, &pServ);
		delete [] tmppath;
	}

	if (pServ != NULL)
	{
		BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);

		if (queryLBStr == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		BSTR queryBStr = SysAllocStringLen(NULL, 45 + wcslen(src));

		if (queryBStr == NULL)
		{
			throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
		}

		wcscpy(queryBStr, META_CLASS_QUERY_START);
		wcscat(queryBStr, src);
		wcscat(queryBStr, END_QUOTE);
		IWbemContext * t_pCtx = m_Ctx;

		if (pServ->IsRemote())
		{
			t_pCtx = NULL; //don't use context for remote calls
		}

		IWbemServices *ptmpServ = pServ->GetServerOrProxy();

		if (ptmpServ)
		{
			IEnumWbemClassObject *t_pEnum = NULL;
			HRESULT t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);

			if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && pServ->IsRemote())
			{
				if ( SUCCEEDED(UpdateConnection(&pServ, &ptmpServ)) )
				{
					if (ptmpServ)
					{
						t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);
					}
				}
			}

			if (ptmpServ)
			{
				pServ->ReturnServerOrProxy(ptmpServ);
			}			

			if (SUCCEEDED(t_hr))
			{
				if (pServ->IsRemote())
				{
					t_hr = SetSecurityLevelAndCloaking(t_pEnum, pServ->GetPrincipal());
				}
				
				if (SUCCEEDED(t_hr))
				{
					//now use the enumerator and see if there is a result...
					ULONG t_count = 0;
					IWbemClassObject* t_pClsObj = NULL;
					BOOL t_bContinueEnum = TRUE;

					//test each class in the derivation chain...
					while (t_bContinueEnum && (S_OK == t_pEnum->Next(WBEM_INFINITE, 1, &t_pClsObj, &t_count)) )
					{
						if (t_pClsObj)
						{
							//get the class name and use the helper object...
							VARIANT vCls;
							VariantInit(&vCls);

							if ( SUCCEEDED(t_pClsObj->Get(WBEM_PROPERTY_CLASS, 0, &vCls, NULL, NULL)) ) 
							{
								if (vCls.vt == VT_BSTR)
								{
									//do this for src and all classes derived from src...
									//====================================================
									HelperTaskObject* validationObj = new HelperTaskObject(m_Provider,
																							vCls.bstrVal,
																							0,
																							m_NotificationHandler,
																							m_Ctx,
																							NULL,
																							NULL,
																							pServ);
									IWbemClassObject* pInst = NULL;

									try
									{
										if (validationObj->GetViewObject(path, &pInst, a_ns))
										{
											VARIANT v;

											if (SUCCEEDED(pInst->Get(WBEM_PROPERTY_PATH, 0, &v, NULL, NULL)) )
											{
												if (v.vt == VT_BSTR)
												{
													if (retVal == NULL)
													{
														retVal = SysAllocString(v.bstrVal);
													}
													else
													{
														//make sure they are the
														//same object else fail
														//TO DO: Use the most derived instance
														//too expensive for little gain since
														//traversal will still get correct instance
														//==========================================
														if (!CompareInstPaths(retVal, v.bstrVal))
														{
															SysFreeString(retVal);
															retVal = NULL;
															//ambiguous results, quit!
															t_bContinueEnum = FALSE;
														}

													}
												}
											}

											VariantClear(&v);
											pInst->Release();
										}
									}
									catch (...)
									{
										validationObj->Release();
										VariantClear(&vCls);
										t_pClsObj->Release();
										t_pEnum->Release();
										pServ->Release();
										SysFreeString(queryLBStr);
										SysFreeString(queryBStr);
										throw;
									}

									validationObj->Release();
								}

								VariantClear(&vCls);
							}

							t_pClsObj->Release();
							t_pClsObj = NULL;
						}

						t_count = 0;
					}
				}

				t_pEnum->Release();
			}
		}

		SysFreeString(queryLBStr);
		SysFreeString(queryBStr);

		if (pServ)
		{
			pServ->Release();
		}
	}

	return retVal;
}


//takes a reference and maps to the "real world" or to a view
//------------------------------------------------------------
BOOL WbemTaskObject::TransposeReference(CPropertyQualifierItem* pItm,
										VARIANT vSrc, VARIANT* pvDst,
										BOOL bMapToView, CWbemServerWrap **a_ns)
{
//make sure reference normalisation/non-normalisation is OK.
//Done the best I can.....
//==========================================================
	if (pvDst != NULL)
	{
		VariantInit(pvDst);
	}
	else
	{
		return FALSE;
	}

	if (vSrc.vt != VT_BSTR)
	{
		return FALSE;
	}

	BOOL retVal = FALSE;

	//associations are the only classes that this
	//method gets called for, therefore, only a
	//single source class to interrogate!
	//=============================================
	IWbemClassObject* pCls = m_SourceArray[0]->GetClassObject();

	if (pCls != NULL)
	{
		CIMTYPE ct;
		//associations are the only classes that this
		//method gets called for, therefore, only a
		//single source class to interrogate!
		//=============================================
		BSTR strClass = pItm->m_SrcPropertyNames[0].AllocSysString();

		if ( SUCCEEDED(pCls->Get(strClass, 0, NULL, &ct, NULL)) )
		{
			if (ct == CIM_REFERENCE)
			{
				IWbemQualifierSet* pQuals = NULL;

				if ( SUCCEEDED(pCls->GetPropertyQualifierSet(strClass, &pQuals)) )
				{
					VARIANT v;

					if ( SUCCEEDED(pQuals->Get(VIEW_QUAL_TYPE, 0, &v, NULL)) )
					{
						if (v.vt == VT_BSTR)
						{
							//bstrVal is either "ref" OR ref:classname
							wchar_t* tmp = v.bstrVal;
							tmp += 4;

							if (*tmp != '\0')
							{
								if (!pItm->GetReferenceClass().IsEmpty())
								{
									if (pItm->IsDirect())
									{
										if (FAILED(VariantCopy(pvDst, &vSrc)))
                                        {
                                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                                        }
										retVal = TRUE;
									}
									else
									{
										if (bMapToView)
										{
											BSTR refStr = MapToView(vSrc.bstrVal, pItm->GetReferenceClass(), a_ns);

											if (refStr != NULL)
											{
												pvDst->vt = VT_BSTR;
												pvDst->bstrVal = refStr;
												retVal = TRUE;
											}
										}
										else
										{
											//map reference back to source class
											BSTR refStr = MapFromView(vSrc.bstrVal, tmp);

											if (refStr != NULL)
											{
												pvDst->vt = VT_BSTR;
												pvDst->bstrVal = refStr;
												retVal = TRUE;
											}
										}
									}
								}
							}
							else
							{
								if (pItm->GetReferenceClass().IsEmpty())
								{
									if (FAILED(VariantCopy(pvDst, &vSrc)))
                                    {
                                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                                    }
									retVal = TRUE;
								}
							}
						}

						VariantClear(&v);
					}

					pQuals->Release();
				}

			}
		}

		SysFreeString(strClass);
		pCls->Release();
	}

	return retVal;
}

//Must release all ClassObjects and free all sub-arrays
//=====================================================
BOOL WbemTaskObject::ValidateClassDependencies(IWbemClassObject*** arrayofArrayOfObjs, CMap<CStringW, LPCWSTR, int, int>* parentMap)
{
	CMap<CStringW, LPCWSTR, int, int> namespaceClassMap;
	
	if (parentMap != NULL)
	{
		POSITION pos = parentMap->GetStartPosition();

		while (pos)
		{
			CStringW tmpStr;
			int tmpInt;
			parentMap->GetNextAssoc(pos, tmpStr, tmpInt);
			namespaceClassMap.SetAt(tmpStr, tmpInt);
		}
	}

	BOOL retVal = TRUE;
	VARIANT v;
	VariantInit(&v);
	
	if (SUCCEEDED(m_ClassObject->Get(WBEM_PROPERTY_PATH, 0, &v, NULL, NULL)) )
	{
		if (v.vt != VT_BSTR)
		{
			retVal = FALSE;
		}
		else
		{
			int dummyInt;

			if (namespaceClassMap.Lookup(v.bstrVal, dummyInt))
			{
				retVal = FALSE;
			}
			else
			{
				namespaceClassMap.SetAt(v.bstrVal, 0);
			}
		}
	}
	else
	{
		retVal = FALSE;
	}

	VariantClear(&v);

	for (int x = 0; x < m_NSpaceArray.GetSize(); x++)
	{
		UINT nsCount = m_NSpaceArray[x]->GetCount();

		for (UINT i = 0; i < nsCount; i++)
		{
			if (arrayofArrayOfObjs[x][i] != NULL)
			{
				IWbemQualifierSet* pQuals = NULL;

				if (retVal && SUCCEEDED(arrayofArrayOfObjs[x][i]->GetQualifierSet(&pQuals)) )
				{
					VariantInit(&v);

					if (SUCCEEDED(pQuals->Get(VIEW_QUAL_PROVIDER, 0, &v, NULL)) )
					{
						if (v.vt == VT_BSTR)
						{
							if (m_ProviderName.CompareNoCase(v.bstrVal) == 0)
							{
								VariantClear(&v);
								VariantInit(&v);

								if ( SUCCEEDED(arrayofArrayOfObjs[x][i]->Get(WBEM_PROPERTY_PATH, 0, &v, NULL, NULL)) )
								{
									if (v.vt == VT_BSTR)
									{
										HelperTaskObject* validationObj = new HelperTaskObject(m_Provider, 
											v.bstrVal, 0, m_NotificationHandler, m_Ctx,
											NULL,
											m_NSpaceArray[x]->GetServerPtrs()[i]->GetPrincipal(),
											m_NSpaceArray[x]->GetServerPtrs()[i]);

										try
										{
											retVal = validationObj->Validate(&namespaceClassMap);
										}
										catch (...)
										{
											validationObj->Release();
											throw;
										}

										validationObj->Release();
									}
									else
									{
										retVal = FALSE;
									}
								}
								else
								{
									retVal = FALSE;
								}

								VariantClear(&v);
							}
						}
						else
						{
							retVal = FALSE;
						}
					}

					VariantClear(&v);
					pQuals->Release();
				}
				else
				{
					retVal = FALSE;
				}
				
				//Check union, assoc key properties here
				SAFEARRAY* pNames = NULL;

				if (retVal && !m_JoinOnArray.IsValid())
				{
					if ( SUCCEEDED(arrayofArrayOfObjs[x][i]->GetNames(NULL, WBEM_FLAG_KEYS_ONLY, NULL, &pNames)) )
					{
						if (SafeArrayGetDim(pNames) == 1)
						{
							LONG arraylen = pNames->rgsabound[0].cElements;
							BSTR HUGEP *pbstr;

							if ( SUCCEEDED(SafeArrayAccessData(pNames, (void HUGEP**)&pbstr)) )
							{
								for (LONG i = 0; retVal && (i < arraylen); i++)
								{
									//find pbstr[i] as a key in the view class
									//as the xth property name ('cos we're checking the
									//xth source class) in the property arrays
									//of m_PropertyMap...
									retVal = FALSE;
									POSITION pos = m_PropertyMap.GetStartPosition();
									
									while (pos)
									{
										CPropertyQualifierItem* pItm;
										CStringW itmName;
										m_PropertyMap.GetNextAssoc(pos, itmName, pItm);
									
										if (pItm->IsKey() && (_wcsicmp(pbstr[i], pItm->m_SrcPropertyNames[x]) == 0) )
										{
											retVal = TRUE;
											break;
										}
									}
								}

								SafeArrayUnaccessData(pNames);
							}
							else
							{
								retVal = FALSE;
							}
						}
						else
						{
							retVal = FALSE;
						}

						SafeArrayDestroy(pNames);
					}
					else
					{
						retVal = FALSE;
					}
				}

				arrayofArrayOfObjs[x][i]->Release();
			}
		}

		delete [] arrayofArrayOfObjs[x];
	}

	namespaceClassMap.RemoveAll();
	return retVal;
}

LONG WbemTaskObject::AddRef()
{
    return InterlockedIncrement(&m_Ref);
}

LONG WbemTaskObject::Release()
{
	LONG t_Ref;

	if ( (t_Ref = InterlockedDecrement(&m_Ref)) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

HRESULT WbemTaskObject :: UpdateConnection(CWbemServerWrap **a_pServ, IWbemServices **a_proxy)
{
	HRESULT retVal = WBEM_NO_ERROR;

#ifdef UNICODE
	if ((*a_pServ)->IsRemote())
	{
		if ((*a_pServ)->ProxyBelongsTo(*a_proxy))
		{
			retVal = Connect((*a_pServ)->GetPath(), a_pServ, TRUE);
		}

		(*a_proxy)->Release();

		if ( SUCCEEDED(retVal) && (*a_pServ) )
		{
			*a_proxy = (*a_pServ)->GetServerOrProxy();
		}
		else
		{
			*a_proxy = NULL;
		}
	}
#endif

	return retVal;
}

HRESULT WbemTaskObject :: Connect(const wchar_t* path, CWbemServerWrap** ppServ, BOOL a_bUpdate)
{
//this function must lock the critsec and unlock it in a balnaced way
//and must also not be locked when calling back into CIMOM...

	if (ppServ == NULL)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
	else
	{
		if (!a_bUpdate)
		{
			*ppServ = NULL;
		}
	}

	if ((m_Provider->sm_ConnectionMade == NULL) || !m_Provider->sm_ServerMap.Lock())
	{
		return WBEM_E_UNEXPECTED;
	}

	//possibility of deadlock if ObjectsInProgress == 0 at this point!
	//therefore Connect should never be called by an object which hasn't
	//previously incremented ObjectsInProgress!!!

	BOOL bFound = FALSE;

	if (!a_bUpdate && !m_Provider->sm_ServerMap.IsEmpty() && 
			m_Provider->sm_ServerMap.Lookup(path, *ppServ) )
	{
		(*ppServ)->AddRef();
		bFound = TRUE;
	}

	HRESULT hr = WBEM_NO_ERROR;

	if (!bFound)
	{
		//check the map of outstanding connections...
		int dummyInt = 0;

		if (!m_Provider->sm_OutStandingConnections.IsEmpty() && 
			m_Provider->sm_OutStandingConnections.Lookup(path, dummyInt) ) 
		{
			bFound = TRUE;
		}
		else
		{
			m_Provider->sm_OutStandingConnections[path] = 0;
		}

		m_Provider->sm_ServerMap.Unlock();
		BOOL t_bWait = TRUE;

		while (bFound && t_bWait)
		{
			DWORD dwWait = WbemWaitForSingleObject(m_Provider->sm_ConnectionMade, VP_CONNECTION_TIMEOUT);

			if (dwWait ==  WAIT_OBJECT_0)
			{
				if (m_Provider->sm_ServerMap.Lock())
				{
					if (!m_Provider->sm_OutStandingConnections.IsEmpty() && 
						m_Provider->sm_OutStandingConnections.Lookup(path, dummyInt) )
					{
						ResetEvent(m_Provider->sm_ConnectionMade);
					}
					else
					{
						//no longer outstanding!
						t_bWait = FALSE;;
					}

					m_Provider->sm_ServerMap.Unlock();
				}
				else
				{
					//error
					hr = WBEM_E_FAILED;
					bFound = FALSE;
				}
			}
			else
			{
				//error
				hr = WBEM_E_FAILED;
				bFound = FALSE;
			}
		}

		if (SUCCEEDED (hr))
		{
			if (bFound)
			{
				if (a_bUpdate)
				{
					//another thread did the update on this clear this pointer
					//chances is are it is the same one and use the one in the map
					(*ppServ)->Release();
					*ppServ = NULL;
				}

				if (m_Provider->sm_ServerMap.Lock())
				{
					if ( !m_Provider->sm_ServerMap.IsEmpty() && 
							m_Provider->sm_ServerMap.Lookup(path, *ppServ) )
					{
						(*ppServ)->AddRef();
					}
					else
					{
						//it just failed in another thread 
						//don't try it again this time....
						hr = WBEM_E_FAILED;
					}

					m_Provider->sm_ServerMap.Unlock();
				}
				else
				{
					hr = WBEM_E_FAILED;
				}
			}
			else
			{
				BSTR bstrPath = SysAllocString(path);

				//calling back into winmgmt cannot have a lock...
				hr = DoConnectServer(bstrPath, ppServ, a_bUpdate);
				SysFreeString(bstrPath);

				if (FAILED(hr))
				{
					if (a_bUpdate)
					{
						//we failed to update, remove the item from the map
						if (m_Provider->sm_ServerMap.Lock())
						{
							m_Provider->sm_ServerMap.RemoveKey(path);
							m_Provider->sm_ServerMap.Unlock();
						}

						(*ppServ)->Release();
					}

					*ppServ = NULL;
				}
				else
				{
					if (m_Provider->sm_ServerMap.Lock())
					{
						if (!a_bUpdate)
						{
							(*ppServ)->AddRef();
							m_Provider->sm_ServerMap[path] = *ppServ;
						}
						else
						{
							//has the object been removed in another thread
							CWbemServerWrap *t_pSrvInMap = NULL;

							if (m_Provider->sm_ServerMap.IsEmpty() || 
								!m_Provider->sm_ServerMap.Lookup(path, t_pSrvInMap))
							{
								(*ppServ)->AddRef();
								m_Provider->sm_ServerMap[path] = *ppServ;
							}
						}

						m_Provider->sm_ServerMap.Unlock();
					}
					else
					{
						(*ppServ)->Release();
						*ppServ = NULL;
						hr = WBEM_E_FAILED;
					}
				}

				if (m_Provider->sm_ServerMap.Lock())
				{
					m_Provider->sm_OutStandingConnections.RemoveKey(path);
					SetEvent(m_Provider->sm_ConnectionMade);
					m_Provider->sm_ServerMap.Unlock();
				}
			}
		}
		else
		{
			if (a_bUpdate)
			{
				//we failed to update, remove the item from the map
				if (m_Provider->sm_ServerMap.Lock())
				{
					m_Provider->sm_ServerMap.RemoveKey(path);
					m_Provider->sm_ServerMap.Unlock();
				}

				(*ppServ)->Release();
				*ppServ = NULL;
			}
		}
	}
	else
	{
		m_Provider->sm_ServerMap.Unlock();
	}

	return hr;
}

//Remote connections for NT4+ only,
//Delegation connections for NT5 only.
HRESULT WbemTaskObject :: DoConnectServer (BSTR bstrPath, CWbemServerWrap **a_ppServ, BOOL a_bUpdate)
{
    WCHAR wszMachine[MAX_PATH];
	wszMachine[0] = L'\0';

    // Determine if it is local
	if (bstrPath != NULL)
	{
		if ( (wcslen(bstrPath) > 4) && (bstrPath[0] == L'\\') && (bstrPath[1] == L'\\') )
		{
			WCHAR *t_ServerMachine = &bstrPath[2];

			while (*t_ServerMachine)
			{
				if ( L'\\' == *t_ServerMachine )
				{
					break ;
				}

				t_ServerMachine++;
			}

			if ((*t_ServerMachine != L'\\') || (t_ServerMachine == &bstrPath[2]))
			{
				return WBEM_E_FAILED;
			}

			*t_ServerMachine = L'\0';
			wcscpy(wszMachine, &bstrPath[2]);
			*t_ServerMachine = L'\\';
		}
	}

	BOOL t_Local = bAreWeLocal ( wszMachine ) ;
	IWbemServices* pServ = NULL;
	HRESULT retVal = WBEM_NO_ERROR;
	wchar_t *prncpl = NULL;

	if (!t_Local)
	{
		//Are we on NT5?
		DWORD dwVersion = GetVersion();

		if (dwVersion < 0x80000000)
		{
#ifdef UNICODE
			// we are on Windows 2000+
			if ( 5 <= (DWORD)(LOBYTE(LOWORD(dwVersion))) )
			{
				if (a_bUpdate)
				{
						prncpl = new wchar_t[wcslen((*a_ppServ)->GetPrincipal()) + 1];
						wcscpy(prncpl, (*a_ppServ)->GetPrincipal());
				}
				else
				{
					// set up the security structures for a remote connection
					// Setup the authentication structures
					HINSTANCE t_LibraryInstance = LoadLibrary ( CONST_NETAPI_LIBRARY ) ;

					if ( t_LibraryInstance ) 
					{
						NETAPI_PROC_DsGetDcName t_DsGetDcNameW = ( NETAPI_PROC_DsGetDcName ) GetProcAddress ( t_LibraryInstance , CONST_NETAPI_DSPROC ) ;
						NETAPI_PROC_NetApiBufferFree t_NetApiBufferFree = ( NETAPI_PROC_NetApiBufferFree ) GetProcAddress ( t_LibraryInstance , CONST_NETAPI_NETPROC ) ;

						if ( t_DsGetDcNameW && t_NetApiBufferFree ) 
						{
							//get the principal name
							PDOMAIN_CONTROLLER_INFO pDomInfo = NULL;
							DWORD dwRet = t_DsGetDcNameW ((const wchar_t*)wszMachine, NULL, NULL, NULL, 0, &pDomInfo);

							if (dwRet == NO_ERROR)
							{
								if (pDomInfo->DomainName != NULL)
								{
									prncpl = new wchar_t[wcslen(pDomInfo->DomainName) + wcslen(wszMachine) + 2];
									wcscpy(prncpl, pDomInfo->DomainName);
									wcscat(prncpl, L"\\");
									wcscat(prncpl, wszMachine);
								}

								t_NetApiBufferFree ((void*)pDomInfo);
							}
						}

						FreeLibrary ( t_LibraryInstance ) ;
					}
				}

				//just try the machine name for the principal
				if (prncpl == NULL)
				{
					prncpl = new wchar_t[wcslen(wszMachine) + 1];
					wcscpy(prncpl, wszMachine);
				}

				if (prncpl != NULL)
				{
					COAUTHIDENTITY authident;
					memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
					authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

					COSERVERINFO si;
					si.pwszName = wszMachine;
					si.dwReserved1 = 0;
					si.dwReserved2 = 0;
					si.pAuthInfo = NULL;

					COAUTHINFO ai;
					si.pAuthInfo = &ai;

					ai.pwszServerPrincName = prncpl;
					ai.pAuthIdentityData = NULL;

					retVal = GetCurrentSecuritySettings(&ai.dwAuthnSvc, &ai.dwAuthzSvc,
														&ai.dwAuthnLevel, &ai.dwImpersonationLevel,
														&ai.dwCapabilities);


					//ai.dwAuthnSvc = 16;
					//ai.dwAuthzSvc = RPC_C_AUTHZ_NONE ;
					//ai.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
					//ai.dwImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE;
					//ai.dwCapabilities = 0X20;

					if (SUCCEEDED(retVal))
					{
						retVal = CoCreateForConnectServer(bstrPath, &si, &authident, &pServ);
					}
				}
				else
				{
					retVal = WBEM_E_FAILED;
				}
			}
			else
#endif //UNICODE
			{
				retVal = WBEM_E_FAILED;
			}
		}
		else
		{
			retVal = WBEM_E_FAILED;
		}
	}
	else
	{
		retVal = LocalConnectServer(bstrPath, &pServ);
	}

	if (SUCCEEDED(retVal) && pServ != NULL)
	{
		if (!a_bUpdate)
		{
			*a_ppServ = new CWbemServerWrap(pServ, prncpl, bstrPath);
			(*a_ppServ)->AddRef();
		}
		else
		{
			(*a_ppServ)->SetMainServer(pServ);
		}

		pServ->Release();
	}
	else
	{
		if (!a_bUpdate)
		{
			*a_ppServ = NULL;
		}
	}

	if (prncpl != NULL)
	{
		delete [] prncpl;
	}

    return retVal;
}

#ifdef UNICODE
HRESULT WbemTaskObject :: CoCreateForConnectServer(BSTR bstrPath, COSERVERINFO* psi, COAUTHIDENTITY* pauthid, IWbemServices** ppServ)
{
	MULTI_QI   mqi;
	mqi.pIID = &IID_IWbemLevel1Login;
	mqi.pItf = 0;
	mqi.hr = 0;

	//delegation doesn't really work with CoCreateInstance....
	DWORD dwImp = psi->pAuthInfo->dwImpersonationLevel;

	if (dwImp > RPC_C_IMP_LEVEL_IMPERSONATE)
	{
		psi->pAuthInfo->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
	}


	HRESULT retVal = g_pfnCoCreateInstanceEx (

		CLSID_WbemLevel1Login,
		NULL,
		CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
		psi ,
		1,
		&mqi
	);

	psi->pAuthInfo->dwImpersonationLevel = dwImp;

	if ( retVal == S_OK )
	{
		IWbemLevel1Login* t_pLevel1 = (IWbemLevel1Login*) mqi.pItf ;

		// If remote, do the security negotiation

		if (psi)
		{
			retVal = SetSecurityLevelAndCloaking(t_pLevel1, psi->pAuthInfo->pwszServerPrincName);
		}
		
		if(retVal == S_OK)
		{
			//use null context for remote cimoms...
			retVal = t_pLevel1->NTLMLogin(bstrPath, 0, 0, 0, ppServ); 

			if(retVal == S_OK)
			{
				if (psi)
				{
					retVal = SetSecurityLevelAndCloaking(*ppServ, psi->pAuthInfo->pwszServerPrincName);

					if (retVal != S_OK)
					{
						(*ppServ)->Release();
						(*ppServ) = NULL;
					}
				}
			}
		}

		t_pLevel1->Release();
	}
	else
	{
		retVal = WBEM_E_FAILED;
	}

	return retVal;
}
#endif //UNICODE

HRESULT WbemTaskObject :: LocalConnectServer(BSTR bstrPath, IWbemServices** ppServ)
{
	IWbemLocator *pLoc = NULL;

	HRESULT retVal = m_Provider->GetLocator(&pLoc);

	if (SUCCEEDED (retVal))
	{
#ifdef UNICODE
		retVal = pLoc->ConnectServer(bstrPath, NULL, NULL, NULL, 0, NULL, m_Ctx, ppServ);
#else
		retVal = pLoc->ConnectServer(bstrPath, m_Provider->GetUserName(), NULL, NULL, 0, NULL, m_Ctx, ppServ);
#endif
		pLoc->Release();
	}

	if (SUCCEEDED(retVal))
	{
		retVal = SetSecurityLevelAndCloaking(*ppServ, COLE_DEFAULT_PRINCIPAL);

		if (FAILED(retVal))
		{
			(*ppServ)->Release();
			*ppServ = NULL;
		}
	}

	return retVal;
}

void WbemTaskObject::SetResultReceived()
{
	if (m_ArrayLock.Lock())
	{
		m_ResultReceived = TRUE;
		m_ArrayLock.Unlock();
	}
}

void WbemTaskObject::SetStatus(HRESULT hr, DWORD index)
{
	if (m_ArrayLock.Lock())
	{
		m_ResultReceived = TRUE;
		m_iQueriesAnswered++;
		
		if (m_iQueriesAsked == m_iQueriesAnswered)
		{
			SetEvent(m_StatusHandle);
		}

		m_ArrayLock.Unlock();
	}
}

void WbemTaskObject::CleanUpObjSinks(BOOL a_bDisconnect)
{
	for (int x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if (m_ObjSinkArray[x] != NULL)
		{
			if (a_bDisconnect)
			{
				m_ObjSinkArray[x]->Disconnect();
			}

			m_ObjSinkArray[x]->Release();
		}
	}

	m_ObjSinkArray.RemoveAll();
}

DWORD WbemTaskObject::GetIndexList(const wchar_t* a_src, DWORD** a_pdwArray)
{
	if (NULL == a_pdwArray)
	{
		return 0;
	}

	DWORD retVal = 0;
	
	for (DWORD i = 0; i < m_SourceArray.GetSize(); i++)
	{
		BOOL t_bAdd = FALSE;
		
		if (_wcsicmp(m_SourceArray[i]->GetClassName(), a_src) == 0)
		{
			//try classname match...
			//=======================
			t_bAdd = TRUE;
		}
		else
		{
			//try parentclass match...
			//========================
			IWbemClassObject *t_pCls = m_SourceArray[i]->GetClassObject();

			if (t_pCls)
			{
				VARIANT v;
				VariantInit(&v);
			
				if ( SUCCEEDED(t_pCls->Get(WBEM_PROPERTY_DERIVATION, 0, &v, NULL, NULL)) )
				{
					if (v.vt == VT_BSTR)
					{
						if (_wcsicmp(v.bstrVal, a_src) == 0)
						{
							t_bAdd = TRUE;
						}
					}
					else if (v.vt == (VT_ARRAY | VT_BSTR))
					{
						if (SafeArrayGetDim(v.parray) == 1)
						{
							LONG count = v.parray->rgsabound[0].cElements;
							BSTR HUGEP *pbstr;

							if ( SUCCEEDED(SafeArrayAccessData(v.parray, (void HUGEP**)&pbstr)) )
							{
								for (LONG x = 0; x < count; x++)
								{
									if (_wcsicmp(pbstr[x], a_src) == 0)
									{
										t_bAdd = TRUE;
										break;
									}
								}

								SafeArrayUnaccessData(v.parray);
							}
						}
					}

					VariantClear(&v);
				}
				
				t_pCls->Release();
			}
		}

		if (!t_bAdd)
		{
			//try derived class match...i.e. execute the query...
			//select * from meta_class where __this isa "classname" AND __class = "a_src"
			//======================================================================================
			CWbemServerWrap** nsPtrs = m_NSpaceArray[i]->GetServerPtrs();

			for (DWORD j = 0; j < m_NSpaceArray[i]->GetCount(); j++)
			{
				if (nsPtrs[j] != NULL)
				{
					BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);

					if (queryLBStr == NULL)
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}

					BSTR queryBStr = SysAllocStringLen(NULL, 61 + wcslen(m_SourceArray[i]->GetClassName()) + wcslen(a_src));

					if (queryBStr == NULL)
					{
						throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
					}

					wcscpy(queryBStr, META_CLASS_QUERY_START);
					wcscat(queryBStr, m_SourceArray[i]->GetClassName());
					wcscat(queryBStr, META_CLASS_QUERY_MID);
					wcscat(queryBStr, a_src);
					wcscat(queryBStr, END_QUOTE);
					IWbemContext * t_pCtx = m_Ctx;

					if (nsPtrs[j]->IsRemote())
					{
						t_pCtx = NULL; //don't use context for remote calls
					}

					IWbemServices *ptmpServ = nsPtrs[j]->GetServerOrProxy();

					if (ptmpServ)
					{
						IEnumWbemClassObject *t_pEnum = NULL;
						HRESULT t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);

						if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && nsPtrs[j]->IsRemote())
						{
							if ( SUCCEEDED(UpdateConnection(&(nsPtrs[j]), &ptmpServ)) )
							{
								if (ptmpServ)
								{
									t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);
								}
							}
						}

						if (ptmpServ)
						{
							nsPtrs[j]->ReturnServerOrProxy(ptmpServ);
						}			

						if (SUCCEEDED(t_hr))
						{
							if (nsPtrs[j]->IsRemote())
							{
								t_hr = SetSecurityLevelAndCloaking(t_pEnum, nsPtrs[j]->GetPrincipal());
							}
							
							if (SUCCEEDED(t_hr))
							{
								//now use the enumerator and see if there is a result...
								IWbemClassObject* t_pClsObj = NULL;
								ULONG t_count = 0;

								//test that a class was returned...
								if ( S_OK == t_pEnum->Next(WBEM_INFINITE, 1, &t_pClsObj, &t_count) )
								{
									if (t_pClsObj)
									{
										t_bAdd = TRUE;
										t_pClsObj->Release();
									}
								}
							}

							t_pEnum->Release();
						}
					}
					
					//only check one namespace, class defns should match
					break;
				}
			}
		}

		if (t_bAdd)
		{
			if (*a_pdwArray == NULL)
			{
				*a_pdwArray = new DWORD[m_SourceArray.GetSize() - i];
			}

			(*a_pdwArray)[retVal] = i;
			retVal++;
		}
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vptasksh.cpp ===
//***************************************************************************

//

//  VPTASKSH.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the helper taskobject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

extern HRESULT SetSecurityLevelAndCloaking(IUnknown* pInterface, const wchar_t* prncpl);
extern BOOL bAreWeLocal(WCHAR* pServerMachine);


HelperTaskObject::HelperTaskObject(CViewProvServ *a_Provider, 
	const wchar_t *a_ObjectPath, ULONG a_Flag, IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *pCtx, IWbemServices* a_Serv, const wchar_t* prncpl,
	CWbemServerWrap* a_ServWrap)
: WbemTaskObject (a_Provider, a_NotificationHandler, a_Flag, pCtx, a_Serv, a_ServWrap),
	m_ObjectPath(NULL),
	m_ParsedObjectPath(NULL),
	m_principal(NULL)
{
	if (prncpl)
	{
		m_principal = UnicodeStringDuplicate(prncpl);
	}

	m_ObjectPath = UnicodeStringDuplicate(a_ObjectPath);
}

HelperTaskObject::~HelperTaskObject ()
{
	if (m_ObjectPath != NULL)
	{
		delete [] m_ObjectPath;
	}

	if (NULL != m_ParsedObjectPath)
	{
		delete m_ParsedObjectPath;
	}

	if (m_principal)
	{
		delete [] m_principal;
	}
}

BOOL HelperTaskObject::Validate(CMap<CStringW, LPCWSTR, int, int>* parentMap)
{
	CObjectPathParser objectPathParser;
	BOOL t_Status = ! objectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		t_Status = SetClass(m_ParsedObjectPath->m_pClass) ;

		if ( t_Status )
		{
			t_Status = ParseAndProcessClassQualifiers(m_ErrorObject, NULL, parentMap);
		}
	}

	return t_Status;
}

//Get the view object given the namespace and object path of the source and the namespace
BOOL HelperTaskObject::DoQuery(ParsedObjectPath* parsedObjectPath, IWbemClassObject** pInst, int indx)
{
	if (pInst == NULL)
	{
		return FALSE;
	}
	else
	{
		*pInst = NULL;
	}

	BOOL retVal = TRUE;

	//Create the query string
	SQL_LEVEL_1_RPN_EXPRESSION tmpRPN;
	tmpRPN.bsClassName = SysAllocString(m_ClassName);

	//need enough tokens to handle association work-around serverpath or dotpath or relpath
	SQL_LEVEL_1_TOKEN* tokArray = new SQL_LEVEL_1_TOKEN[(parsedObjectPath->m_dwNumKeys) * 6];

	DWORD dwToks = 0;

	for (int i = 0; retVal && (i < parsedObjectPath->m_dwNumKeys); i++)
	{	
		POSITION pos = m_PropertyMap.GetStartPosition();

		while (retVal && pos)
		{
			CStringW key;
			CPropertyQualifierItem* propItem;
			m_PropertyMap.GetNextAssoc(pos, key, propItem);

			if (!propItem->m_SrcPropertyNames[indx].IsEmpty())
			{
				if (propItem->m_SrcPropertyNames[indx].CompareNoCase(parsedObjectPath->m_paKeys[i]->m_pName) == 0)
				{
					tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
					tokArray[dwToks].nOperator = SQL_LEVEL_1_TOKEN::OP_EQUAL;
					tokArray[dwToks].pPropertyName = propItem->GetViewPropertyName().AllocSysString();
					
					if (m_bAssoc && (propItem->GetCimType() == CIM_REFERENCE))
					{
						retVal = TransposeReference(propItem, parsedObjectPath->m_paKeys[i]->m_vValue,
														&(tokArray[dwToks].vConstValue), TRUE, &m_ServerWrap);

						if (retVal)
						{
							//add the extra tokens if neccessary
							//for the association work-around
							wchar_t *t_pChar = tokArray[dwToks].vConstValue.bstrVal;

							//must be \\server\namespace and not \\.\namespace or relpath
							if ( (*t_pChar == L'\\') && (*(t_pChar+1) == L'\\') && (*(t_pChar+2) != L'.') )
							{
								//add the dotted version
								tokArray[dwToks + 1] = tokArray[dwToks++];
								t_pChar = tokArray[dwToks].vConstValue.bstrVal + 2;
								
								while (*t_pChar != L'\\')
								{
									t_pChar++;
								}

								--t_pChar;
								*t_pChar = L'.';
								--t_pChar;
								*t_pChar = L'\\';
								--t_pChar;
								*t_pChar = L'\\';
								BSTR t_strtmp = SysAllocString(t_pChar);
								VariantClear(&(tokArray[dwToks].vConstValue));
								VariantInit(&(tokArray[dwToks].vConstValue));
								tokArray[dwToks].vConstValue.vt = VT_BSTR;
								tokArray[dwToks].vConstValue.bstrVal = t_strtmp;
								dwToks++;
								tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;

								//add the relpath version
								tokArray[dwToks + 1] = tokArray[dwToks - 1];
								dwToks++;
								t_pChar = tokArray[dwToks].vConstValue.bstrVal + 4;
								
								while (*t_pChar != L':')
								{
									t_pChar++;
								}

								//exclude the ':'
								t_pChar++;
								t_strtmp = SysAllocString(t_pChar);
								VariantClear(&(tokArray[dwToks].vConstValue));
								VariantInit(&(tokArray[dwToks].vConstValue));
								tokArray[dwToks].vConstValue.vt = VT_BSTR;
								tokArray[dwToks].vConstValue.bstrVal = t_strtmp;
								dwToks++;
								tokArray[dwToks].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
							}
						}
					}
					else
					{
						VariantInit(&(tokArray[dwToks].vConstValue));

                        if (FAILED(VariantCopy(&(tokArray[dwToks].vConstValue),
								&(parsedObjectPath->m_paKeys[i]->m_vValue))))
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
					}

					//after every key add an AND
					//except if this is the first key since there is no where clause
					dwToks++;

					if (i != 0)
					{
						tokArray[dwToks++].nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;				
					}
				}
			}
		}
	}

	BSTR queryStr = NULL;

	if ( retVal && ((dwToks > 0) || (parsedObjectPath->m_dwNumKeys == 0)) )
	{
		CStringW qStr = GetStringFromRPN(&tmpRPN, dwToks, tokArray);
		queryStr = qStr.AllocSysString();
	}

	retVal = FALSE;

	if (queryStr != NULL)
	{
		//ExecQuery and test the results
		IEnumWbemClassObject *pEnum = NULL;
		HRESULT t_hr = WBEM_E_FAILED;
		BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);

		if (m_ServerWrap)
		{
			IWbemContext * t_pCtx = m_Ctx;

			if (m_principal != NULL)
			{
				t_pCtx = NULL; //don't use context for remote calls
			}

			IWbemServices *ptmpServ = m_ServerWrap->GetServerOrProxy();

			if (ptmpServ)
			{
				t_hr = ptmpServ->ExecQuery(queryLBStr, queryStr, 0, t_pCtx, &pEnum);
			}

			if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) && m_ServerWrap->IsRemote())
			{
				if ( SUCCEEDED(UpdateConnection(&m_ServerWrap, &ptmpServ)) )
				{
					if (ptmpServ)
					{
						t_hr = ptmpServ->ExecQuery(queryLBStr, queryStr, 0, t_pCtx, &pEnum);
					}
				}
			}

			if (ptmpServ)
			{
				m_ServerWrap->ReturnServerOrProxy(ptmpServ);
			}
		}

		if (SUCCEEDED(t_hr))
		{
			//set cloaking if remote
			//============================
			if ((m_principal == NULL) || ((m_principal != NULL) &&
				(S_OK == SetSecurityLevelAndCloaking(pEnum, m_principal))) )
			{
				if ( (m_principal != NULL) ||
					((m_principal == NULL) && SUCCEEDED(SetSecurityLevelAndCloaking(pEnum, COLE_DEFAULT_PRINCIPAL))) )
				{
					ULONG uCount = 0;
					IWbemClassObject* pObjs[2];
					pObjs[0] = NULL;
					pObjs[1] = NULL;

					//must be exactly one result...
					if ( SUCCEEDED(pEnum->Next(WBEM_INFINITE, 2, pObjs, &uCount)) )
					{
						//There should only be one result
						if (uCount == 1)
						{
							if (pObjs[0] != NULL)
							{
								*pInst = pObjs[0];
								retVal = TRUE;
							}
							else
							{
								if (pObjs[1] != NULL)
								{
									(pObjs[1])->Release();
								}
							}
						}
						else
						{
							if (pObjs[1] != NULL)
							{
								pObjs[1]->Release();

								if (pObjs[0] != NULL)
								{
									pObjs[0]->Release();
								}
							}
						}
					}
				}
			}

			pEnum->Release();
		}

		SysFreeString(queryLBStr);
	}

	delete [] tokArray;

	if (queryStr != NULL)
	{
		SysFreeString(queryStr);
	}

	return retVal;
}

//Get a view object given a source path
BOOL HelperTaskObject::GetViewObject(const wchar_t* path, IWbemClassObject** pInst, CWbemServerWrap **a_ns)
{
	if ((pInst == NULL) || (path == NULL) || (a_ns == NULL) || (*a_ns == NULL))
	{
		return FALSE;
	}
	else
	{
		*pInst = NULL;
	}

	CObjectPathParser objectPathParser;
	wchar_t* tmpPath = UnicodeStringDuplicate(path);
	ParsedObjectPath* parsedObjectPath = NULL;
	BOOL retVal = !objectPathParser.Parse(tmpPath, &parsedObjectPath);

	if (retVal && !parsedObjectPath->IsInstance())
	{
		retVal = FALSE;
	}

	if (retVal)
	{
		retVal = FALSE;

		if (Validate(NULL))
		{
			//try for all possible classes in namespaces that match 
			//and return as soon as the first view instance is found...
			//==========================================================
			for (DWORD i = 0; (i < m_NSpaceArray.GetSize()) && (*pInst == NULL); i++)
			{
				CWbemServerWrap** t_pSrvs = m_NSpaceArray[i]->GetServerPtrs();
				CStringW* t_pathArray = m_NSpaceArray[i]->GetNamespacePaths();

				for (DWORD j = 0; (j < m_NSpaceArray[i]->GetCount()) && (*pInst == NULL); j++)
				{
					if (t_pSrvs[j] == NULL)
					{
						continue;
					}

					BOOL t_bCont = FALSE;

					//check that the servers match
					//=============================
					if ((parsedObjectPath->m_pServer == NULL) || (_wcsicmp(parsedObjectPath->m_pServer, L".") == 0))
					{
						if ((*a_ns)->IsRemote() && t_pSrvs[j]->IsRemote() &&
							(_wcsicmp((*a_ns)->GetPrincipal(), t_pSrvs[j]->GetPrincipal()) == 0))
						{
							t_bCont = TRUE;
						}
						else if (!(*a_ns)->IsRemote() && !t_pSrvs[j]->IsRemote())
						{
							t_bCont = TRUE;
						}
					}
					else
					{
						BOOL t_Local = bAreWeLocal(parsedObjectPath->m_pServer);
						
						if (t_Local  && !t_pSrvs[j]->IsRemote())
						{
							t_bCont = TRUE;
						}
						else
						{
							if (t_pSrvs[j]->IsRemote())
							{
								if (_wcsicmp(t_pSrvs[j]->GetPrincipal(), parsedObjectPath->m_pServer) == 0)
								{
									t_bCont = TRUE;
								}
								else 
								{
									DWORD t_len1 = wcslen(parsedObjectPath->m_pServer);
									DWORD t_len2 = wcslen(t_pSrvs[j]->GetPrincipal());

									if ((t_len2 > 0) && (t_len1 > 0) && (t_len1 < t_len2))
									{
										//machine.domain
										if ((_wcsnicmp(t_pSrvs[j]->GetPrincipal(), parsedObjectPath->m_pServer, t_len1) == 0) &&
										(((const wchar_t*)t_pSrvs[j]->GetPrincipal())[t_len1] == L'.'))
										{
											t_bCont = TRUE;
										}
										else
										{
											//could be the principal is domain\machine
											wchar_t *slash = wcschr(t_pSrvs[j]->GetPrincipal(), L'\\');

											if ((slash != NULL) && (_wcsicmp(parsedObjectPath->m_pServer, (slash+1)) == 0))
											{
												t_bCont = TRUE;
											}
										}
									}
								}
							}
						}
					}
					
					//check the namespace paths now
					//==============================
					if (t_bCont)
					{
						wchar_t *t_ns1 = parsedObjectPath->GetNamespacePart();
						BOOL t_bDel = TRUE;
						
						if (t_ns1 == NULL)
						{
							t_ns1 = (*a_ns)->GetPath();
							t_bDel = FALSE;
						}

						wchar_t *t_ns2 = t_pSrvs[j]->GetPath();

						if (!t_ns1 || !t_ns2)
						{
							t_bCont = FALSE;
						}
						else
						{
							//normalise...NOTE: no error checking since connection worked or parser worked
							//=============================================================================
							if (*t_ns1 == L'\\')
							{
								//skip the next slash
								t_ns1 += 2;
								
								while (*t_ns1 != L'\\')
								{
									t_ns1++;
								}

								t_ns1++;
							}

							if (*t_ns2 == L'\\')
							{
								//skip the next slash
								t_ns2 += 2;
								
								while (*t_ns2 != L'\\')
								{
									t_ns2++;
								}

								t_ns2++;
							}

							if (_wcsicmp(t_ns1, t_ns2) != 0)
							{
								t_bCont = FALSE;
							}
						}

						if (t_bDel && (t_ns1 != NULL))
						{
							delete [] t_ns1;
						}

						if (t_bCont)
						{
							//check that the class matches
							//=============================
							if (_wcsicmp(parsedObjectPath->m_pClass, m_SourceArray[i]->GetClassName()) == 0)
							{
								retVal = DoQuery(parsedObjectPath, pInst, j);
								break;
							}
							else
							{
								//uh-oh try classes derived from the source, i.e. do the query...
								//select * from meta_class where __this isa "m_SourceArray[i]->GetClassName()"
								// and __class = "parsedObjectPath->m_pClass"
								BSTR queryLBStr = SysAllocString(WBEM_QUERY_LANGUAGE_SQL1);

								if (queryLBStr == NULL)
								{
									throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
								}

								BSTR queryBStr = SysAllocStringLen(NULL,
									61 + wcslen(m_SourceArray[i]->GetClassName()) +
									wcslen(parsedObjectPath->m_pClass));

								if (queryBStr == NULL)
								{
									throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
								}

								wcscpy(queryBStr, META_CLASS_QUERY_START);
								wcscat(queryBStr, m_SourceArray[i]->GetClassName());
								wcscat(queryBStr, META_CLASS_QUERY_MID);
								wcscat(queryBStr, parsedObjectPath->m_pClass);
								wcscat(queryBStr, END_QUOTE);
								IWbemContext * t_pCtx = m_Ctx;

								if (t_pSrvs[j]->IsRemote())
								{
									t_pCtx = NULL; //don't use context for remote calls
								}

								IWbemServices *ptmpServ = t_pSrvs[j]->GetServerOrProxy();

								if (ptmpServ)
								{
									IEnumWbemClassObject *t_pEnum = NULL;
									HRESULT t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0, t_pCtx, &t_pEnum);

									if ( FAILED(t_hr) && (HRESULT_FACILITY(t_hr) != FACILITY_ITF) &&
										t_pSrvs[j]->IsRemote())
									{
										if ( SUCCEEDED(UpdateConnection(&(t_pSrvs[j]), &ptmpServ)) )
										{
											if (ptmpServ)
											{
												t_hr = ptmpServ->ExecQuery(queryLBStr, queryBStr, 0,
																			t_pCtx, &t_pEnum);
											}
										}
									}

									if (ptmpServ)
									{
										t_pSrvs[j]->ReturnServerOrProxy(ptmpServ);
									}			

									if (SUCCEEDED(t_hr))
									{
										if (t_pSrvs[j]->IsRemote())
										{
											t_hr = SetSecurityLevelAndCloaking(t_pEnum,
																				t_pSrvs[j]->GetPrincipal());
										}
										
										if (SUCCEEDED(t_hr))
										{
											//now use the enumerator and see if there is a result...
											IWbemClassObject* t_pClsObj = NULL;
											ULONG t_count = 0;

											//test each class in the derivation chain...
											if ( S_OK == t_pEnum->Next(WBEM_INFINITE, 1, &t_pClsObj, &t_count) )
											{
												if (t_pClsObj)
												{
													retVal = DoQuery(parsedObjectPath, pInst, j);
													t_pClsObj->Release();
												}
											}
										}

										t_pEnum->Release();
									}
								}
							}
						}
					}
				}
			}
		}
	}

	delete [] tmpPath;

	if (parsedObjectPath != NULL)
	{
		delete parsedObjectPath;
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\include\vpcfac.h ===
//***************************************************************************

//

//  VPCFAC.H

//

//  Module: WBEM VIEW PROVIDER

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPCFAC_H
#define _VIEW_PROV_VPCFAC_H

/////////////////////////////////////////////////////////////////////////
// This class is the class factory for the event provider.

class CViewProvClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CViewProvClassFactory () ;
    ~CViewProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members
    STDMETHODIMP LockServer ( BOOL ) ;
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * );

};

#endif //_VIEW_PROV_VPCFAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vptasksu.cpp ===
//***************************************************************************

//

//  VPTASKSU.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the union methods taskobject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//need the following three lines
//to get the security stuff to work
#include "precomp.h"

#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

BOOL WbemTaskObject::CreateAndIndicateUnions(WbemProvErrorObject &a_ErrorObject, int index)
{
	BOOL retVal = TRUE;

	if (index != -1)
	{
		retVal = CreateAndIndicate(a_ErrorObject, m_ObjSinkArray[index]);

		for (int x = 0; x < m_ObjSinkArray.GetSize(); x++)
		{
			if (m_ObjSinkArray[x] != NULL)
			{
				m_ObjSinkArray[x]->Release();
			}
		}
	}
	else
	{
		for (int x = 0; x < m_ObjSinkArray.GetSize(); x++)
		{
			if ((m_ObjSinkArray[x] != NULL) && SUCCEEDED(m_ObjSinkArray[x]->GetResult()))
			{
				BOOL t_bRes = CreateAndIndicate(a_ErrorObject, m_ObjSinkArray[x]);
				retVal = retVal && t_bRes;
			}
			else if (retVal)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"A source query failed." );
			}

			if (m_ObjSinkArray[x] != NULL)
			{
				m_ObjSinkArray[x]->Release();
			}
		}
	}

	m_ObjSinkArray.RemoveAll();
	return retVal;
}

//for unions and associations
BOOL WbemTaskObject::CreateAndIndicate(WbemProvErrorObject &a_ErrorObject, CObjectSinkResults* pSrcs)
{
	BOOL retVal = TRUE;

	for (int x = 0; x < pSrcs->m_ObjArray.GetSize(); x++)
	{
		BOOL bIndicate = TRUE;
		IWbemClassObject* srcObj = pSrcs->m_ObjArray[x]->GetWrappedObject();
		IWbemClassObject* viewObj = NULL;
		
		if ( SUCCEEDED(m_ClassObject->SpawnInstance(0, &viewObj)) )
		{
			POSITION propPos = m_PropertyMap.GetStartPosition();

			while ((propPos != NULL) && bIndicate)
			{
				CStringW propName;
				CPropertyQualifierItem* propProps;
				m_PropertyMap.GetNextAssoc(propPos, propName, propProps);
				VARIANT v;
				CIMTYPE c;

				if (propProps->m_SrcPropertyNames[pSrcs->GetIndex()].IsEmpty())
				{
					if (propProps->IsKey())
					{
						if (retVal)
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Failed to set key value for union view instance." );
						}

						bIndicate = FALSE;
					}

				}
				else
				{
					if ( SUCCEEDED(srcObj->Get(propProps->m_SrcPropertyNames[pSrcs->GetIndex()], 0, &v, &c, NULL)) )
					{
						if (((v.vt == VT_NULL) || (v.vt == VT_EMPTY)) && propProps->IsKey())
						{
							if (retVal)
							{
								retVal = FALSE;
							}

							bIndicate = FALSE;
						}
						else
						{
							//transpose reference if necessary
							//=================================
							BOOL bPut = TRUE;

							if (m_bAssoc && (propProps->GetCimType() == CIM_REFERENCE))
							{
								VARIANT vTmp;
								DWORD dwNSIndx = pSrcs->m_ObjArray[x]->GetIndex();
								CWbemServerWrap** pSrvs = m_NSpaceArray[pSrcs->GetIndex()]->GetServerPtrs();

								if (TransposeReference(propProps, v, &vTmp, TRUE, &pSrvs[dwNSIndx]))
								{
									VariantClear(&v);
									VariantInit(&v);

                                    if (FAILED(VariantCopy(&v, &vTmp)))
                                    {
                                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                                    }
								}
								else
								{
									if (propProps->IsKey())
									{
										if (retVal)
										{
											retVal = FALSE;
										}

										bIndicate = FALSE;
									}

									bPut = FALSE;
								}
								
								VariantClear(&vTmp);
							}

							if (bPut && FAILED(viewObj->Put(propName, 0, &v, c)) )
							{
								if (retVal)
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
									a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_ErrorObject.SetMessage ( L"Failed to put property" );
								}

								if (propProps->IsKey())
								{
									bIndicate = FALSE;
								}
							}
						}

						VariantClear(&v);
					}
					else
					{
						if (retVal)
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Failed to get property from Source." ) ;
						}
					}
				}
			}

			if (bIndicate && m_bIndicate)
			{
				m_NotificationHandler->Indicate(1, &viewObj);
			}

			viewObj->Release();
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"WBEM API FAILURE:- Failed to spawn an instance of the view class." ) ;
			break;
		}
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\include\vpdefs.h ===
//***************************************************************************

//

//  VPDEFS.H

//

//  Module: WBEM VIEW PROVIDER

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPDEFS_H
#define _VIEW_PROV_VPDEFS_H

#define VP_QUERY_TIMEOUT		3600000	//1 hour timeout
#define VP_CONNECTION_TIMEOUT	1200000	//20 minute timeout

#define HKEYCLASSES					_T("SOFTWARE\\Classes\\")
#define WBEM_CLASS_EXTENDEDSTATUS	L"__ExtendedStatus" 
#define WBEM_QUERY_LANGUAGE_SQL1	L"WQL"

#define WBEM_PROPERTY_CLASS				L"__CLASS"
#define WBEM_PROPERTY_SCLASS			L"__SUPERCLASS"
#define WBEM_PROPERTY_DERIVATION		L"__DERIVATION"
#define WBEM_PROPERTY_RELPATH			L"__RELPATH"
#define WBEM_PROPERTY_NSPACE			L"__NAMESPACE"
#define WBEM_PROPERTY_PATH				L"__PATH"
#define WBEM_PROPERTY_SERVER			L"__SERVER"
#define WBEM_PROPERTY_STATUSCODE		L"StatusCode"
#define WBEM_PROPERTY_PROVSTATUSCODE	L"ProvStatusCode"
#define WBEM_PROPERTY_PROVSTATUSMESSAGE	L"Description"

#define ENUM_INST_QUERY_START	L"select * from "
#define ENUM_INST_QUERY_MID		L" where __CLASS = \""

#define META_CLASS_QUERY_START	L"select * from meta_class where __this isa \""
#define META_CLASS_QUERY_MID	L"\" AND __class = \""

#define END_QUOTE		L"\""
#define NS_DELIMIT		L"::"

//Qualifiers
#define VIEW_QUAL_SOURCES		L"ViewSources"
#define VIEW_QUAL_NAMESPACES	L"ViewSpaces"
#define VIEW_QUAL_UNION			L"Union"
#define VIEW_QUAL_JOIN			L"JoinOn"
#define VIEW_QUAL_PROVIDER		L"provider"
#define VIEW_QUAL_PROPERTY		L"PropertySources"
#define VIEW_QUAL_METHOD		L"MethodSource"
#define VIEW_QUAL_FILTER		L"PostJoinFilter"
#define VIEW_QUAL_ENUM_CLASS	L"EnumerateClasses"
#define VIEW_QUAL_HIDDEN		L"HiddenDefault"
#define VIEW_QUAL_KEY			L"Key"
#define VIEW_QUAL_ASSOC			L"Association"
#define VIEW_QUAL_SNGLTN		L"Singleton"
#define VIEW_QUAL_TYPE			L"Cimtype"
#define VIEW_QUAL_STATIC		L"Static"
#define VIEW_QUAL_DIRECT		L"Direct"


//Default key values
#define VIEW_KEY_BOOL_VAL		VARIANT_FALSE
#define VIEW_KEY_NUMBER_VAL		0
#define VIEW_KEY_64_VAL			L"0"
#define VIEW_KEY_STRING_VAL		L"DefaultUnionValue"
#define VIEW_KEY_DATE_VAL		L"20000101000000.000000+000"

#define MAX_QUERIES			32

// {AA70DDF4-E11C-11d1-ABB0-00C04FD9159E}
DEFINE_GUID(CLSID_CViewProviderClassFactory, 
0xaa70ddf4, 0xe11c, 0x11d1, 0xab, 0xb0, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);


class CFreeBuff
{
private:

	void *m_buff;

public:

		CFreeBuff(void *buff) : m_buff(buff) {}

	void SetBuff(void *buff) { m_buff = buff; } 
	
		~CFreeBuff() { free (m_buff); }
};

#endif //_VIEW_PROV_VPDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vptasksj.cpp ===
//***************************************************************************

//

//  VPTASKSJ.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the join methods for taskobject implementation

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>

#include <wbemtime.h>

BOOL CompareSimplePropertyValues(VARIANT* v1, VARIANT* v2, CIMTYPE ct)
{
	BOOL retVal = FALSE;

	if (v1->vt == v2->vt)
	{
		switch (ct)
		{
			case CIM_BOOLEAN:
			{
				if (VT_BOOL == v1->vt)
				{
					if (v1->boolVal == v2->boolVal)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_UINT8:
			{
				if (VT_UI1 == v1->vt)
				{
					if (v1->bVal == v2->bVal)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_SINT16:
			case CIM_CHAR16:
			case CIM_SINT8:
			{
				if (VT_I2 == v1->vt)
				{
					if (v1->iVal == v2->iVal)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_UINT32:
			case CIM_SINT32:
			case CIM_UINT16:
			{
				if (VT_I4 == v1->vt)
				{
					if (v1->lVal == v2->lVal)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_REFERENCE:
			//TO DO:
			//references should be normalised for equality checks.
			//should do this once CIMOM does...

			case CIM_STRING:
			case CIM_SINT64:
			case CIM_UINT64:
			{
				if (VT_BSTR == v1->vt)
				{
					if (0 == _wcsicmp(v1->bstrVal,v2->bstrVal))
					{
						retVal = TRUE;
					}
				}
			}
			break;

			case CIM_DATETIME:
			{
				if (VT_BSTR == v1->vt)
				{
					WBEMTime t1(v1->bstrVal);
					WBEMTime t2(v2->bstrVal);

					if (t1 == t2)
					{
						retVal = TRUE;
					}
				}
			}
			break;

			default:
			{
				//unsupported by this function
			}
		}
	}

	return retVal;
}

//Validate:
//1) All classes mentioned in join exist.
//2) All properties mentioned in join map to view class properties
//3) All classes mentioned in sources are mentioned in join
//4) Any != operator is not applied to two properties which map to the same view property
//5) All clauses have different classes being checked
BOOL WbemTaskObject::ValidateJoin()
{
	//3) check all sources mentioned in join
	//this check with (1) will do the trick
	if (m_JoinOnArray.m_AllClasses.GetCount() != m_SourceArray.GetSize())
	{
		return FALSE;
	}

	//1) check all join classes exist
	POSITION pos = m_JoinOnArray.m_AllClasses.GetStartPosition();

	while (pos)
	{
		int val;
		CStringW tmpStr;
		m_JoinOnArray.m_AllClasses.GetNextAssoc(pos, tmpStr, val);

		if (!m_ClassToIndexMap.Lookup(tmpStr, val))
		{
			return FALSE;
		}
	}

	wchar_t** classA = m_JoinOnArray.GetAClasses();
	wchar_t** propsA = m_JoinOnArray.GetAProperties();
	wchar_t** classB = m_JoinOnArray.GetBClasses();
	wchar_t** propsB = m_JoinOnArray.GetBProperties();
	UINT* ops = m_JoinOnArray.GetOperators();

	//(2), (4) and (5) validations
	//=============================
	for (int x = 0; x < m_JoinOnArray.GetCount(); x++)
	{
		if (_wcsicmp(classA[x], classB[x]) == 0)
		{
			return FALSE;
		}

		int indexA;

		if (m_ClassToIndexMap.Lookup(classA[x], indexA))
		{
			int indexB;

			if (m_ClassToIndexMap.Lookup(classB[x], indexB))
			{
				POSITION pos = m_PropertyMap.GetStartPosition();
				CStringW propA;
				CStringW propB;

				while (pos)
				{
					CStringW key;
					CPropertyQualifierItem* pItem;
					m_PropertyMap.GetNextAssoc(pos, key, pItem);

					if (pItem->m_SrcPropertyNames[indexA].CompareNoCase(propsA[x]) == 0)
					{
						propA = key;

						if (!propB.IsEmpty())
						{
							break;
						}
					}
					
					if (pItem->m_SrcPropertyNames[indexB].CompareNoCase(propsB[x]) == 0)
					{
						propB = key;

						if (!propA.IsEmpty())
						{
							break;
						}
					}
				}

				//check both properties exist (2)
				if (propA.IsEmpty() || propB.IsEmpty())
				{
					return FALSE;
				}

				//validate expression (4)
				if (ops[x] == CJoinOnQualifierArray::NOT_EQUALS_OPERATOR && (propA.CompareNoCase(propB) == 0))
				{
					return FALSE;
				}
			}
			else
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
	}

	return TRUE;
}

#ifdef VP_PERFORMANT_JOINS

//should not compile with compiler flag set til I'm ready

BOOL WbemTaskObject::CreateAndIndicateJoinsPerf(WbemProvErrorObject &a_ErrorObject, BOOL a_bSingle)
{
	BOOL retVal = TRUE;

	//check all queries were asked...
	if (m_ObjSinkArray.GetSize() != m_SourceArray.GetSize())
	{
		retVal = FALSE;
		a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"A source query failed or was not executed therefore a join could not be created." );
	}

	//check we got results from all queries...
	for (UINT x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if ((m_ObjSinkArray[x] == NULL) || FAILED(m_ObjSinkArray[x]->GetResult()) || !m_ObjSinkArray[x]->m_ObjArray.GetSize())
		{
			if (!a_bSingle)
			{
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"A source query failed or returned no instances." );
			}

			retVal = FALSE;
			break;
		}
	}

	//perform the join of all results...
	if (retVal)
	{
		CMap<CStringW, LPCWSTR, int, int> t_JoinedClasses;
		CList<IWbemClassObject*, IWbemClassObject*> t_ResultObjs; 
		retVal = JoinTwoColumns(a_ErrorObject, t_JoinedClasses, t_ResultObjs);
		wchar_t** t_clsA = m_JoinOnArray.GetAClasses();
		wchar_t** t_clsB = m_JoinOnArray.GetBClasses();
		wchar_t** t_prpsA = m_JoinOnArray.GetAProperties();
		wchar_t** t_prpsB = m_JoinOnArray.GetBProperties();

		while ( retVal && (t_JoinedClasses.GetCount() != m_SourceArray.GetSize()) )
		{
			DWORD t_column = m_SourceArray.GetSize() + 1;
			CList <int, int> t_IndexArray;
			wchar_t *t_classname = NULL;

			//find a column not already joined that can be joined now...
			for (x = 0; x < m_JoinOnArray.GetCount(); x++)
			{
				if (!m_JoinOnArray.m_bDone[x])
				{
					int dummyInt = 0;

					if (t_classname == NULL)
					{
						if (t_JoinedClasses.Lookup(t_clsA[x], dummyInt))
						{
							if (!m_ClassToIndexMap.Lookup(t_clsB[x], (int &)t_column))
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"An unexpected error ocurred performing the join." );
							}

							t_classname = t_clsB[x];
							t_JoinedClasses.SetAt(t_classname, 0);
							m_JoinOnArray.m_bDone[x] = TRUE;
							t_IndexArray.AddTail(x);

							//want all clauses the same way around...
							t_clsB[x] = t_clsA[x];
							t_clsA[x] = t_classname;
							wchar_t *t_tmpStr = t_prpsA[x];
							t_prpsA[x] = t_prpsB[x];
							t_prpsB[x] = t_tmpStr;
						}
						else if (t_JoinedClasses.Lookup(t_clsB[x], dummyInt))
						{
							if (!m_ClassToIndexMap.Lookup(t_clsA[x], (int &)t_column))
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"An unexpected error ocurred performing the join." );
							}

							t_classname = t_clsA[x];
							t_JoinedClasses.SetAt(t_classname, 0);
							m_JoinOnArray.m_bDone[x] = TRUE;
							t_IndexArray.AddTail(x);
						}
					}
					else
					{
						//find all clauses which can be evaluated now...
						if ((_wcsicmp(t_classname, t_clsA[x]) == 0) && (t_JoinedClasses.Lookup(t_clsB[x], dummyInt)))
						{
							t_IndexArray.AddTail(x);
							m_JoinOnArray.m_bDone[x] = TRUE;
						}
						else if ((_wcsicmp(t_classname, t_clsB[x]) == 0) && (t_JoinedClasses.Lookup(t_clsA[x], dummyInt)))
						{
							//want the clauses in the same order for simpler evaluation later...
							wchar_t *t_tmpStr =  t_clsA[x];
							t_clsA[x] = t_clsB[x];
							t_clsB[x] = t_tmpStr;
							t_tmpStr =  t_prpsA[x];
							t_prpsA[x] = t_prpsB[x];
							t_prpsB[x] = t_tmpStr;
							t_IndexArray.AddTail(x);
							m_JoinOnArray.m_bDone[x] = TRUE;
						}
					}
				}
			}

			if (t_column == m_SourceArray.GetSize() + 1)
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to perform join." );
			}
			else
			{
				retVal = AddColumnToJoin(a_ErrorObject, t_JoinedClasses, t_ResultObjs, t_column, t_IndexArray);
				t_IndexArray.RemoveAll();
			}
		}

		if (retVal)
		{
			if (m_bIndicate)
			{
				POSITION t_pos = t_ResultObjs.GetHeadPosition();
				BOOL t_bIndicated = FALSE;

				while (t_pos)
				{
					IWbemClassObject *t_Obj = t_ResultObjs.GetNext(t_pos);

					if (t_Obj)
					{
						if (PostFilter(t_Obj))
						{
							if (a_bSingle && t_bIndicated)
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_TOOMANYRESULTSRETURNED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"Too many view instances can be created." ) ;
								break;
							}
							else
							{
								m_NotificationHandler->Indicate(1, &t_Obj);
								t_bIndicated = TRUE;
							}
						}
					}
				}
			}
		}

		t_ResultObjs.RemoveAll();
	}

	//clean up...
	for (x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if (m_ObjSinkArray[x] != NULL)
		{
			m_ObjSinkArray[x]->Release();
		}
	}

	m_ObjSinkArray.RemoveAll();

	return retVal;
}

BOOL WbemTaskObject::JoinItem(WbemProvErrorObject &a_ErrorObject,
						IWbemClassObject *a_Obj1, IWbemClassObject *a_vObj,
						IWbemClassObject *a_resObj, CList <int, int> &a_IndexArray,
						DWORD a_indx1)
{
	BOOL retVal = TRUE;
	wchar_t** t_clsA = m_JoinOnArray.GetAClasses();
	wchar_t** t_clsB = m_JoinOnArray.GetBClasses();
	UINT* t_ops = m_JoinOnArray.GetOperators();
	wchar_t** t_prpsA = m_JoinOnArray.GetAProperties();
	wchar_t** t_prpsB = m_JoinOnArray.GetBProperties();
	VARIANT t_vA;
	VariantInit(&t_vA);
	CIMTYPE t_cA;
	POSITION t_pos = a_IndexArray.GetHeadPosition();

	while (t_pos && retVal)
	{
		int t_index = a_IndexArray.GetNext(t_pos);

		//get the propertyname in the view...
		int t_srcindxA = 0;
		int t_srcindxB = 0;
		
		if (m_ClassToIndexMap.Lookup(t_clsB[t_index], t_srcindxB) && m_ClassToIndexMap.Lookup(t_clsA[t_index], t_srcindxA))
		{
			//find t_prpsB[t_index] and get the view property name...
			POSITION t_propPos = m_PropertyMap.GetStartPosition();
			CStringW t_propName;

			while (t_propPos != NULL)
			{
				CPropertyQualifierItem *t_propProps;
				m_PropertyMap.GetNextAssoc(t_propPos, t_propName, t_propProps);

				if (!t_propProps->m_SrcPropertyNames[t_srcindxB].IsEmpty() && 
					!t_propProps->m_SrcPropertyNames[t_srcindxA].IsEmpty() &&
					(_wcsicmp(t_propProps->m_SrcPropertyNames[t_srcindxB], t_prpsB[t_index]) == 0) &&
					(_wcsicmp(t_propProps->m_SrcPropertyNames[t_srcindxA], t_prpsA[t_index]) == 0))
				{
					break;
				}
				else
				{
					t_propName.Empty();
				}
			}

			if (!t_propName.IsEmpty() &&  SUCCEEDED(a_Obj1->Get(t_prpsA[t_index], 0, &t_vA, &t_cA, NULL)) )
			{
				VARIANT t_vB;
				VariantInit(&t_vB);
				CIMTYPE t_cB;

				if ( SUCCEEDED(a_vObj->Get(t_propName, 0, &t_vB, &t_cB, NULL)) )
				{
					if (t_cA == t_cB)
					{
						if (t_ops[t_index] == CJoinOnQualifierArray::EQUALS_OPERATOR)
						{
							retVal = CompareSimplePropertyValues(&t_vA, &t_vB, t_cA);
						}
						else //NOT_EQUALS
						{
							retVal = !CompareSimplePropertyValues(&t_vA, &t_vB, t_cA);
						}
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Join properties have different CIM types." ) ;
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
				}

				VariantClear(&t_vA);
				VariantClear(&t_vB);
				VariantInit(&t_vA);
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
			}
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Failed to find source property in view class." ) ;
		}
	}

	VariantClear(&t_vA);

	if (retVal)
	{
		//copy properties from sources to result
		POSITION t_propPos = m_PropertyMap.GetStartPosition();

		while ((t_propPos != NULL) && retVal)
		{
			CStringW t_propName;
			CPropertyQualifierItem *t_propProps;
			m_PropertyMap.GetNextAssoc(t_propPos, t_propName, t_propProps);
			
			if (!t_propProps->m_SrcPropertyNames[a_indx1].IsEmpty())
			{
				VARIANT t_v;
				VariantInit(&t_v);
				CIMTYPE t_c;

				if ( SUCCEEDED(a_Obj1->Get(t_propProps->m_SrcPropertyNames[a_indx1], 0, &t_v, &t_c, NULL)) )
				{
					if (((t_v.vt == VT_NULL) || (t_v.vt == VT_EMPTY)) && t_propProps->IsKey())
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"View key value in source instance is NULL" );
					}
					else
					{
						if ( FAILED(a_resObj->Put(t_propName, 0, &t_v, t_c)) )
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Failed to put property" );
						}
					}

					VariantClear(&t_v);
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Failed to get property from Source." ) ;
				}
			}
			else
			{
				continue;
			}
		}
	}

	return retVal;
}


BOOL WbemTaskObject::JoinTwoItems(WbemProvErrorObject &a_ErrorObject,
								IWbemClassObject *a_Obj1, IWbemClassObject *a_Obj2,
								IWbemClassObject *a_resObj, CList <int, int> &a_IndexArray,
								DWORD a_indx1, DWORD a_indx2)
{
	BOOL retVal = TRUE;
	wchar_t** t_clsA = m_JoinOnArray.GetAClasses();
	wchar_t** t_clsB = m_JoinOnArray.GetBClasses();
	UINT* t_ops = m_JoinOnArray.GetOperators();
	wchar_t** t_prpsA = m_JoinOnArray.GetAProperties();
	wchar_t** t_prpsB = m_JoinOnArray.GetBProperties();
	VARIANT t_vA;
	CIMTYPE t_cA;
	POSITION t_pos = a_IndexArray.GetHeadPosition();

	while (t_pos && retVal)
	{
		int t_index = a_IndexArray.GetNext(t_pos);

		if ( SUCCEEDED(a_Obj1->Get(t_prpsA[t_index], 0, &t_vA, &t_cA, NULL)) )
		{
			VARIANT t_vB;
			CIMTYPE t_cB;

			if ( SUCCEEDED(a_Obj2->Get(t_prpsB[t_index], 0, &t_vB, &t_cB, NULL)) )
			{
				if (t_cA == t_cB)
				{
					if (t_ops[t_index] == CJoinOnQualifierArray::EQUALS_OPERATOR)
					{
						retVal = CompareSimplePropertyValues(&t_vA, &t_vB, t_cA);
					}
					else //NOT_EQUALS
					{
						retVal = !CompareSimplePropertyValues(&t_vA, &t_vB, t_cA);
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Join properties have different CIM types." ) ;
				}

				VariantClear(&t_vB);
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
			}

			VariantClear(&t_vA);
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
		}
	}

	if (retVal)
	{
		//copy properties from sources to result
		POSITION t_propPos = m_PropertyMap.GetStartPosition();

		while ((t_propPos != NULL) && retVal)
		{
			CStringW t_propName;
			CPropertyQualifierItem *t_propProps;
			m_PropertyMap.GetNextAssoc(t_propPos, t_propName, t_propProps);
			IWbemClassObject *t_src_Obj = NULL;
			DWORD t_index = 0;
			
			if (!t_propProps->m_SrcPropertyNames[a_indx1].IsEmpty())
			{
				t_src_Obj = a_Obj1;
				t_index = a_indx1;
			}
			else if (!t_propProps->m_SrcPropertyNames[a_indx2].IsEmpty())
			{
				t_src_Obj = a_Obj2;
				t_index = a_indx2;
			}
			else
			{
				continue;
			}

			VARIANT t_v;
			VariantInit(&t_v);
			CIMTYPE t_c;

			if ( SUCCEEDED(t_src_Obj->Get(t_propProps->m_SrcPropertyNames[t_index], 0, &t_v, &t_c, NULL)) )
			{
				if (((t_v.vt == VT_NULL) || (t_v.vt == VT_EMPTY)) && t_propProps->IsKey())
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"View key value in source instance is NULL" );
				}
				else
				{
					if ( FAILED(a_resObj->Put(t_propName, 0, &t_v, t_c)) )
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to put property" );
					}
				}

				VariantClear(&t_v);
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to get property from Source." ) ;
			}
		}
	}

	return retVal;
}

BOOL WbemTaskObject::JoinTwoColumns(WbemProvErrorObject &a_ErrorObject,
						CMap<CStringW, LPCWSTR, int, int> &a_JoinedClasses,
						CList<IWbemClassObject*, IWbemClassObject*> &a_ResultObjs)
{
	BOOL retVal = TRUE;
	wchar_t** t_clsA = m_JoinOnArray.GetAClasses();
	wchar_t** t_clsB = m_JoinOnArray.GetBClasses();
	wchar_t** t_prpsA = m_JoinOnArray.GetAProperties();
	wchar_t** t_prpsB = m_JoinOnArray.GetBProperties();
	UINT* t_ops = m_JoinOnArray.GetOperators();
	int t_indexA;
	int t_indexB;
	CList <int, int> t_IndexArray;
	t_IndexArray.AddTail(0);
	m_JoinOnArray.m_bDone[0] = TRUE;

	for (int x = 1; x < m_JoinOnArray.GetCount(); x++)
	{
		//find all clauses which can be evaluated now...
		if ((_wcsicmp(t_clsA[0], t_clsA[x]) == 0) && (_wcsicmp(t_clsB[0], t_clsB[x]) == 0))
		{
			t_IndexArray.AddTail(x);
			m_JoinOnArray.m_bDone[x] = TRUE;
		}
		else if ((_wcsicmp(t_clsB[0], t_clsA[x]) == 0) && (_wcsicmp(t_clsA[0], t_clsB[x]) == 0))
		{
			//want the clauses in the same order for simpler evaluation later...
			wchar_t *t_tmp =  t_clsA[x];
			t_clsA[x] = t_clsB[x];
			t_clsB[x] = t_tmp;
			t_tmp =  t_prpsA[x];
			t_prpsA[x] = t_prpsB[x];
			t_prpsB[x] = t_tmp;
			t_IndexArray.AddTail(x);
			m_JoinOnArray.m_bDone[x] = TRUE;
		}
	}

	a_JoinedClasses.SetAt(t_clsA[0], 0);
	a_JoinedClasses.SetAt(t_clsB[0], 0);
	m_ClassToIndexMap.Lookup(t_clsA[0], t_indexA);
	m_ClassToIndexMap.Lookup(t_clsB[0], t_indexB);

	for (int i = 0; retVal && (i < m_ObjSinkArray[t_indexA]->m_ObjArray.GetSize()); i++) 
	{
		if (m_ObjSinkArray[t_indexA]->m_ObjArray[i])
		{
			for (int j = 0; retVal && (j < m_ObjSinkArray[t_indexB]->m_ObjArray.GetSize()); j++)
			{
				if (m_ObjSinkArray[t_indexB]->m_ObjArray[j])
				{
					IWbemClassObject* t_viewObj = NULL;
					
					if ( SUCCEEDED(m_ClassObject->SpawnInstance(0, &t_viewObj)) )
					{
						if (JoinTwoItems(a_ErrorObject, m_ObjSinkArray[t_indexA]->m_ObjArray[i]->GetWrappedObject(),
										m_ObjSinkArray[t_indexB]->m_ObjArray[j]->GetWrappedObject(),
										t_viewObj, t_IndexArray, t_indexA, t_indexB))
						{
							a_ResultObjs.AddTail(t_viewObj);
						}
						else
						{
							t_viewObj->Release();
						}
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"An error occured when spawning an instance of the view class." );
					}
				}
			}

			m_ObjSinkArray[t_indexA]->m_ObjArray[i]->Release();
			m_ObjSinkArray[t_indexA]->m_ObjArray[i] = NULL;
		}
	}

	m_ObjSinkArray[t_indexB]->m_ObjArray.RemoveAll();

	return retVal;
}

BOOL WbemTaskObject::AddColumnToJoin(WbemProvErrorObject &a_ErrorObject,
						CMap<CStringW, LPCWSTR, int, int> &a_JoinedClasses,
						CList<IWbemClassObject*, IWbemClassObject*> &a_ResultObjs,
						DWORD a_Index, CList <int, int> &a_IndexArray)
{
	BOOL retVal = TRUE;
	CList<IWbemClassObject*, IWbemClassObject*> t_AddedResultObjs;

	for (int i = 0; retVal && (i < m_ObjSinkArray[a_Index]->m_ObjArray.GetSize()); i++) 
	{
		if (m_ObjSinkArray[a_Index]->m_ObjArray[i])
		{
			POSITION t_pos = a_ResultObjs.GetHeadPosition();

			while (retVal && t_pos)
			{
				IWbemClassObject *t_vSrc = a_ResultObjs.GetNext(t_pos);

				if (t_vSrc)
				{
					IWbemClassObject* t_viewObj = NULL;
					
					if ( SUCCEEDED(t_vSrc->Clone(&t_viewObj)) )
					{
						if (JoinItem(a_ErrorObject, m_ObjSinkArray[a_Index]->m_ObjArray[i]->GetWrappedObject(),
										t_vSrc,	t_viewObj, a_IndexArray, a_Index))
						{
							t_AddedResultObjs.AddTail(t_viewObj);
						}
						else
						{
							t_viewObj->Release();
						}
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"An error occured when spawning an instance of the view class." );
					}
				}
			}

			m_ObjSinkArray[a_Index]->m_ObjArray[i]->Release();
			m_ObjSinkArray[a_Index]->m_ObjArray[i] = NULL;
		}
	}

	//don't need partial join any longer
	a_ResultObjs.RemoveAll();

	//copy the new result set to the result list
	//filter if this is the last time here...
	if (retVal)
	{
		POSITION t_pos = t_AddedResultObjs.GetHeadPosition();

		while (t_pos)
		{
			IWbemClassObject *t_vobj = a_ResultObjs.GetNext(t_pos);

			if (t_vobj)
			{
				t_vobj->AddRef();
				a_ResultObjs.AddTail(t_vobj);
			}
		}
	}

	t_AddedResultObjs.RemoveAll();
	return retVal;
}

#else //VP_PERFORMANT_JOINS

BOOL WbemTaskObject::CreateAndIndicateJoins(WbemProvErrorObject &a_ErrorObject, BOOL a_bSingle)
{
	BOOL retVal = TRUE;
	UINT isize = 1;

	if (m_ObjSinkArray.GetSize() != m_SourceArray.GetSize())
	{
		retVal = FALSE;
		a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"A source query failed or was not executed therefore a join could not be created." );
	}

	//calculate the size of the results
	for (UINT x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if ((m_ObjSinkArray[x] == NULL) || FAILED(m_ObjSinkArray[x]->GetResult()) || !m_ObjSinkArray[x]->m_ObjArray.GetSize())
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"A source query failed or returned no instances." );
			break;
		}

		if ((0xFFFFFFFF/isize) >= m_ObjSinkArray[x]->m_ObjArray.GetSize())
		{
			isize = isize * m_ObjSinkArray[x]->m_ObjArray.GetSize();
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Too many possible combinations for join. Provider not capable." );
		}
	}

	if (retVal)
	{
		IWbemClassObject** objs = new IWbemClassObject*[m_ObjSinkArray.GetSize()];
		IWbemClassObject* res_obj = NULL;
		int num_res_objs = 0;

		for (UINT i = 0; i < isize; i++)
		{
			UINT t_iDenom = 1;

			for (x = 0; x < m_ObjSinkArray.GetSize(); x++)
			{
				UINT isz = m_ObjSinkArray[x]->m_ObjArray.GetSize();
				objs[x] = m_ObjSinkArray[x]->m_ObjArray[(i/t_iDenom) % isz];
				t_iDenom = t_iDenom * isz;
			}

			BOOL t_bRes = CreateAndIndicate(a_ErrorObject, objs, &res_obj);
			retVal = retVal && t_bRes;

			if (res_obj != NULL)
			{
				num_res_objs++;

				if (a_bSingle)
				{
					if (num_res_objs > 1)
					{
						res_obj->Release();
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_TOOMANYRESULTSRETURNED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Too many view instances can be created." ) ;
						break;
					}
				}
				else
				{
					if (m_bIndicate)
					{
						m_NotificationHandler->Indicate(1, &res_obj);
						res_obj->Release();
						res_obj = NULL;
					}
				}
			}
		}

		if (a_bSingle)
		{
			if (num_res_objs == 1)
			{
				if (m_bIndicate)
				{
					m_NotificationHandler->Indicate(1, &res_obj);
				}

				res_obj->Release();
			}
		}

		delete [] objs;
	}

	for (x = 0; x < m_ObjSinkArray.GetSize(); x++)
	{
		if (m_ObjSinkArray[x] != NULL)
		{
			m_ObjSinkArray[x]->Release();
		}
	}

	m_ObjSinkArray.RemoveAll();

	return retVal;
}

//for joins
BOOL WbemTaskObject::CreateAndIndicate(WbemProvErrorObject &a_ErrorObject, IWbemClassObject ** pSrcs, IWbemClassObject **pOut)
{
	BOOL retVal = TRUE;
	wchar_t** clsA = m_JoinOnArray.GetAClasses();
	wchar_t** clsB = m_JoinOnArray.GetBClasses();
	wchar_t** prpsA = m_JoinOnArray.GetAProperties();
	wchar_t** prpsB = m_JoinOnArray.GetBProperties();
	UINT* ops = m_JoinOnArray.GetOperators();

	for (int x = 0; retVal && (x < m_JoinOnArray.GetCount()); x++)
	{
		int iA;
		int iB;

		m_ClassToIndexMap.Lookup(clsA[x], iA);
		m_ClassToIndexMap.Lookup(clsB[x], iB);

		VARIANT vA;
		CIMTYPE cA;

		if ( SUCCEEDED(pSrcs[iA]->Get(prpsA[x], 0, &vA, &cA, NULL)) )
		{
			VARIANT vB;
			CIMTYPE cB;

			if ( SUCCEEDED(pSrcs[iB]->Get(prpsB[x], 0, &vB, &cB, NULL)) )
			{
				if (cA == cB)
				{
					if (ops[x] == CJoinOnQualifierArray::EQUALS_OPERATOR)
					{
						retVal = CompareSimplePropertyValues(&vA, &vB, cA);
					}
					else //NOT_EQUALS
					{
						retVal = !CompareSimplePropertyValues(&vA, &vB, cA);
					}
				}
				else
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Join properties have different CIM types." ) ;
				}

				VariantClear(&vB);
			}
			else
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
			}

			VariantClear(&vA);
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"Failed to get join property from Source." ) ;
		}
	}

	if (retVal)
	{
		BOOL bIndicate = TRUE;
		IWbemClassObject* viewObj = NULL;
		
		if ( SUCCEEDED(m_ClassObject->SpawnInstance(0, &viewObj)) )
		{
			POSITION propPos = m_PropertyMap.GetStartPosition();

			while ((propPos != NULL) && bIndicate)
			{
				CStringW propName;
				CPropertyQualifierItem* propProps;
				m_PropertyMap.GetNextAssoc(propPos, propName, propProps);
				VARIANT v;
				BOOL bSetProp = FALSE;
				CIMTYPE c;
				
				for (int x = 0; !bSetProp && (x < propProps->m_SrcPropertyNames.GetSize()); x++)
				{
					if (!propProps->m_SrcPropertyNames[x].IsEmpty())
					{
						bSetProp =  TRUE;

						if ( SUCCEEDED(pSrcs[x]->Get(propProps->m_SrcPropertyNames[x], 0, &v, &c, NULL)) )
						{
							if (((v.vt == VT_NULL) || (v.vt == VT_EMPTY)) && propProps->IsKey())
							{
								if (retVal)
								{
									retVal = FALSE;
									a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
									a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_ErrorObject.SetMessage ( L"View key value in source instance is NULL" );
								}

								bIndicate = FALSE;
							}
							else
							{
								if ( FAILED(viewObj->Put(propName, 0, &v, c)) )
								{
									if (retVal)
									{
										retVal = FALSE;
										a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_ErrorObject.SetMessage ( L"Failed to put property" );
									}

									if (propProps->IsKey())
									{
										bIndicate = FALSE;
									}
								}
							}

							VariantClear(&v);
						}
						else
						{
							if (retVal)
							{
								retVal = FALSE;
								a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
								a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_ErrorObject.SetMessage ( L"Failed to get property from Source." ) ;
							}
						}
					}
				}
			}

			if (bIndicate)
			{
				retVal = PostFilter(viewObj);

				if (retVal)
				{
					viewObj->AddRef();
					*pOut = viewObj;
				}
			}

			viewObj->Release();
		}
		else
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_ErrorObject.SetMessage ( L"WBEM API FAILURE:- Failed to spawn an instance of the view class." ) ;
		}
	}

	return retVal;
}

#endif //VP_PERFORMANT_JOINS

BOOL WbemTaskObject::PostFilter(IWbemClassObject* a_pObj)
{
	BOOL retVal = TRUE;

	if ( (m_RPNPostFilter != NULL) && (m_RPNPostFilter->nNumTokens != 0) )
	{
		BOOL* t_bStack = new BOOL[m_RPNPostFilter->nNumTokens];
		DWORD t_bCnt = 0;

		for (int i = 0; retVal && (i < m_RPNPostFilter->nNumTokens); i++)
		{
			switch (m_RPNPostFilter->pArrayOfTokens[i].nTokenType)
			{
			case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
				{
					t_bStack[t_bCnt] = EvaluateToken(a_pObj, m_RPNPostFilter->pArrayOfTokens[i]);
					t_bCnt++;
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_AND:
				{
					if (t_bCnt > 1)
					{
						t_bStack[t_bCnt - 2] = t_bStack[t_bCnt - 1] && t_bStack[t_bCnt - 2];
						t_bCnt--;
					}
					else
					{
						retVal = FALSE;
					}
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_OR:
				{
					if (t_bCnt > 1)
					{
						t_bStack[t_bCnt - 2] = t_bStack[t_bCnt - 1] || t_bStack[t_bCnt - 2];
						t_bCnt--;
					}
					else
					{
						retVal = FALSE;
					}
				}
				break;

				case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
				{
					if (t_bCnt > 0)
					{
						t_bStack[t_bCnt - 1] = !t_bStack[t_bCnt - 1];
					}
				}
				break;

				default:
				{
				}
				break;
			}
		}

		if (retVal)
		{
			retVal = t_bStack[t_bCnt - 1];
		}

		delete [] t_bStack;
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\include\vpquals.h ===
//***************************************************************************

//

//  VPQUALS.H

//

//  Module: WBEM VIEW PROVIDER

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPQUALS_H
#define _VIEW_PROV_VPQUALS_H

//forward definition
class CWbemServerWrap;

CStringW GetStringFromRPN(SQL_LEVEL_1_RPN_EXPRESSION* pRPN, DWORD num_extra,
						 SQL_LEVEL_1_TOKEN* pExtraTokens, BOOL bAllprops = FALSE);

template <> inline BOOL AFXAPI CompareElements<CStringW, LPCWSTR>(const CStringW* pElement1, const LPCWSTR* pElement2)
{
	//return TRUE if equal
	return (pElement1->CompareNoCase(*pElement2) == 0);
}


template <> inline UINT AFXAPI HashKey <LPCWSTR> (LPCWSTR key)
{
	CStringW tmp(key);
	tmp.MakeUpper();
	return HashKeyLPCWSTR((const WCHAR*)tmp);
}

class CSourceQualifierItem : public CObject
{
private:

	CStringW						m_QueryStr;
	SQL_LEVEL_1_RPN_EXPRESSION*	m_RPNExpr;
	IWbemClassObject*			m_pClassObj;
	BOOL						m_isValid;

public:

	//Constructor
		CSourceQualifierItem(wchar_t* qry, IWbemClassObject* obj = NULL);

	//set methods may be called after instance creation
	void SetClassObject(IWbemClassObject* pObj);

	//retrieval of stored members
	BOOL						IsValid() { return m_isValid; }
	SQL_LEVEL_1_RPN_EXPRESSION* GetRPNExpression() { return m_RPNExpr; }
	IWbemClassObject*			GetClassObject();
	CStringW						GetQueryStr() { return m_QueryStr; }
	BSTR						GetClassName();

	//Destructor
		~CSourceQualifierItem();
};


class CNSpaceQualifierItem : public CObject
{
private:

	CWbemServerWrap**	m_ServObjs;
	CStringW*		m_NSPaths;
	UINT			m_Count;
	BOOL			m_Valid;

	void Parse(const wchar_t* ns_path);

public:

	//Constructor
		CNSpaceQualifierItem(const wchar_t* ns_path);

	//set members
	void			SetServerPtrs(CWbemServerWrap** pServs) { m_ServObjs = pServs; }
		
	//retrieval of members
	CWbemServerWrap**	GetServerPtrs() { return m_ServObjs; }
	UINT				GetCount() { return m_Count; }
	CStringW*			GetNamespacePaths() { return m_NSPaths; }
	BOOL				IsValid() { return m_Valid; }

	//Destructor
		~CNSpaceQualifierItem();

};

class CPropertyQualifierItem
{
private:

	CStringW		m_ViewPropertyName;
	BOOL			m_HiddenDefault;
	BOOL			m_bKey;
	CIMTYPE			m_CimType;
	CStringW		m_RefTo;
	BOOL			m_bDirect;

public:

	//public members
	CArray<CStringW, LPCWSTR> m_SrcPropertyNames;

	//Constructor
		CPropertyQualifierItem(const wchar_t* prop, BOOL bHD, BOOL bKy, CIMTYPE ct, CStringW rfto, BOOL bDt);

	//retrieval methods
	CStringW	GetViewPropertyName() { return m_ViewPropertyName; }
	BOOL	IsHiddenDefault() { return m_HiddenDefault; }
	BOOL	IsKey() { return m_bKey; }
	BOOL	IsDirect() { return m_bDirect; }
	CIMTYPE	GetCimType() { return m_CimType; }
	CStringW	GetReferenceClass() { return m_RefTo; }

	//Destructor
		~CPropertyQualifierItem();

};

class CJoinOnQualifierArray
{
private:

	UINT		m_Count;
	wchar_t*	m_Buff;
	wchar_t**	m_AClasses;
	wchar_t**	m_AProps;
	wchar_t**	m_BClasses;
	wchar_t**	m_BProps;
	UINT*		m_Ops;
	BOOL		m_Valid;

	void		Parse(const wchar_t* qualStr);
	wchar_t*	SkipSpace(wchar_t*& src);
	wchar_t*	SkipToSpecial(wchar_t*& src);
	wchar_t*	GetClassStr(wchar_t*& src);
	wchar_t*	GetPropertyStrAndOperator(wchar_t*& src, UINT& op);
	wchar_t*	GetPropertyStr(wchar_t*& src);
	BOOL		StripAnd(wchar_t*& src);


public:

	//possible operators
	enum{NO_OPERATOR = 0, EQUALS_OPERATOR = 1, NOT_EQUALS_OPERATOR = 2};
	CMap<CStringW, LPCWSTR, int, int> m_AllClasses;
	BOOL*		m_bDone;

	//Constructor
		CJoinOnQualifierArray();

	BOOL		Set(const wchar_t* jStr);
	UINT		GetCount() { return m_Count; }
	wchar_t**	GetAClasses() { return m_AClasses; }
	wchar_t**	GetAProperties() { return m_AProps; }
	wchar_t**	GetBClasses() { return m_BClasses; }
	wchar_t**	GetBProperties() { return m_BProps; }
	UINT*		GetOperators() { return m_Ops; }
	BOOL		IsValid() { return m_Valid; }
	BOOL		ValidateJoin();

	//Destructor
		~CJoinOnQualifierArray();
	
};

template <> inline void AFXAPI  DestructElements<CPropertyQualifierItem*> (CPropertyQualifierItem** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			delete ((CPropertyQualifierItem*)(ptr_e[i]));
		}
	}
}


#endif //_VIEW_PROV_VPQUALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\include\vpserv.h ===
//***************************************************************************

//

//  VPSERV.H

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains the WBEM services interfaces

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPSERV_H
#define _VIEW_PROV_VPSERV_H

typedef 
enum tag_WBEMPROVSTATUS
{

	WBEM_PROV_NO_ERROR							= 0,
	WBEM_PROV_S_NO_ERROR							= 0,
	WBEM_PROV_S_NO_MORE_DATA						= 0x40001,
	WBEM_PROV_S_ALREADY_EXISTS					= WBEM_PROV_S_NO_MORE_DATA + 1,
	WBEM_PROV_S_NOT_FOUND						= WBEM_PROV_S_ALREADY_EXISTS + 1,
	WBEM_PROV_S_RESET_TO_DEFAULT					= WBEM_PROV_S_NOT_FOUND + 1,
	WBEM_PROV_E_FAILED							= 0x80041001,
	WBEM_PROV_E_NOT_FOUND						= WBEM_PROV_E_FAILED + 1,
	WBEM_PROV_E_ACCESS_DENIED					= WBEM_PROV_E_NOT_FOUND + 1,
	WBEM_PROV_E_PROVIDER_FAILURE					= WBEM_PROV_E_ACCESS_DENIED + 1,
	WBEM_PROV_E_TYPE_MISMATCH					= WBEM_PROV_E_PROVIDER_FAILURE + 1,
	WBEM_PROV_E_OUT_OF_MEMORY					= WBEM_PROV_E_TYPE_MISMATCH + 1,
	WBEM_PROV_E_INVALID_CONTEXT					= WBEM_PROV_E_OUT_OF_MEMORY + 1,
	WBEM_PROV_E_INVALID_PARAMETER				= WBEM_PROV_E_INVALID_CONTEXT + 1,
	WBEM_PROV_E_NOT_AVAILABLE					= WBEM_PROV_E_INVALID_PARAMETER + 1,
	WBEM_PROV_E_CRITICAL_ERROR					= WBEM_PROV_E_NOT_AVAILABLE + 1,
	WBEM_PROV_E_INVALID_STREAM					= WBEM_PROV_E_CRITICAL_ERROR + 1,
	WBEM_PROV_E_NOT_SUPPORTED					= WBEM_PROV_E_INVALID_STREAM + 1,
	WBEM_PROV_E_INVALID_SUPERCLASS				= WBEM_PROV_E_NOT_SUPPORTED + 1,
	WBEM_PROV_E_INVALID_NAMESPACE				= WBEM_PROV_E_INVALID_SUPERCLASS + 1,
	WBEM_PROV_E_INVALID_OBJECT					= WBEM_PROV_E_INVALID_NAMESPACE + 1,
	WBEM_PROV_E_INVALID_CLASS					= WBEM_PROV_E_INVALID_OBJECT + 1,
	WBEM_PROV_E_PROVIDER_NOT_FOUND				= WBEM_PROV_E_INVALID_CLASS + 1,
	WBEM_PROV_E_INVALID_PROVIDER_REGISTRATION	= WBEM_PROV_E_PROVIDER_NOT_FOUND + 1,
	WBEM_PROV_E_PROVIDER_LOAD_FAILURE			= WBEM_PROV_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_PROV_E_INITIALIZATION_FAILURE			= WBEM_PROV_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_PROV_E_TRANSPORT_FAILURE				= WBEM_PROV_E_INITIALIZATION_FAILURE + 1,
	WBEM_PROV_E_INVALID_OPERATION				= WBEM_PROV_E_TRANSPORT_FAILURE + 1,
	WBEM_PROV_E_INVALID_QUERY					= WBEM_PROV_E_INVALID_OPERATION + 1,
	WBEM_PROV_E_INVALID_QUERY_TYPE				= WBEM_PROV_E_INVALID_QUERY + 1,
	WBEM_PROV_E_ALREADY_EXISTS					= WBEM_PROV_E_INVALID_QUERY_TYPE + 1,
	WBEM_PROV_E_OVERRIDE_NOT_ALLOWED				= WBEM_PROV_E_ALREADY_EXISTS + 1,
	WBEM_PROV_E_PROPAGATED_QUALIFIER				= WBEM_PROV_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_PROV_E_UNEXPECTED						= WBEM_PROV_E_PROPAGATED_QUALIFIER + 1,
	WBEM_PROV_E_ILLEGAL_OPERATION				= WBEM_PROV_E_UNEXPECTED + 1,
	WBEM_PROV_E_CANNOT_BE_KEY					= WBEM_PROV_E_ILLEGAL_OPERATION + 1,
	WBEM_PROV_E_INCOMPLETE_CLASS					= WBEM_PROV_E_CANNOT_BE_KEY + 1,
	WBEM_PROV_E_INVALID_SYNTAX					= WBEM_PROV_E_INCOMPLETE_CLASS + 1,
	WBEM_PROV_E_NONDECORATED_OBJECT				= WBEM_PROV_E_INVALID_SYNTAX + 1,
	WBEM_PROV_E_READ_ONLY						= WBEM_PROV_E_NONDECORATED_OBJECT + 1,
	WBEM_PROV_E_PROVIDER_NOT_CAPABLE				= WBEM_PROV_E_READ_ONLY + 1,
	WBEM_PROV_E_CLASS_HAS_CHILDREN				= WBEM_PROV_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_PROV_E_CLASS_HAS_INSTANCES				= WBEM_PROV_E_CLASS_HAS_CHILDREN + 1 ,

	// Added

	WBEM_PROV_E_INVALID_PROPERTY					= WBEM_PROV_E_CLASS_HAS_INSTANCES + 1 ,
	WBEM_PROV_E_INVALID_QUALIFIER				= WBEM_PROV_E_INVALID_PROPERTY + 1 ,
	WBEM_PROV_E_INVALID_PATH						= WBEM_PROV_E_INVALID_QUALIFIER + 1 ,
	WBEM_PROV_E_INVALID_PATHKEYPARAMETER			= WBEM_PROV_E_INVALID_PATH + 1 ,
	WBEM_PROV_E_MISSINGPATHKEYPARAMETER 			= WBEM_PROV_E_INVALID_PATHKEYPARAMETER + 1 ,	
	WBEM_PROV_E_INVALID_KEYORDERING				= WBEM_PROV_E_MISSINGPATHKEYPARAMETER + 1 ,	
	WBEM_PROV_E_DUPLICATEPATHKEYPARAMETER		= WBEM_PROV_E_INVALID_KEYORDERING + 1 ,
	WBEM_PROV_E_MISSINGKEY						= WBEM_PROV_E_DUPLICATEPATHKEYPARAMETER + 1 ,
	WBEM_PROV_E_INVALID_TRANSPORT				= WBEM_PROV_E_MISSINGKEY + 1 ,
	WBEM_PROV_E_INVALID_TRANSPORTCONTEXT			= WBEM_PROV_E_INVALID_TRANSPORT + 1 ,
	WBEM_PROV_E_TRANSPORT_ERROR					= WBEM_PROV_E_INVALID_TRANSPORTCONTEXT + 1 ,
	WBEM_PROV_E_TRANSPORT_NO_RESPONSE			= WBEM_PROV_E_TRANSPORT_ERROR + 1 ,
	WBEM_PROV_E_NOWRITABLEPROPERTIES				= WBEM_PROV_E_TRANSPORT_NO_RESPONSE + 1 ,
	WBEM_PROV_E_NOREADABLEPROPERTIES				= WBEM_PROV_E_NOWRITABLEPROPERTIES + 1 , 
	WBEM_PROV_E_TOOMANYRESULTSRETURNED				= WBEM_PROV_E_NOREADABLEPROPERTIES + 1 

} WBEMPROVSTATUS;

wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) ;
wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix ) ;

class CWbemProxyServerWrap
{
public:

	BOOL m_InUse;
	IWbemServices *m_Proxy;

	CWbemProxyServerWrap(IWbemServices *a_Proxy) : m_Proxy(NULL), m_InUse(FALSE) {m_Proxy = a_Proxy;}
	CWbemProxyServerWrap() : m_Proxy(NULL), m_InUse(FALSE) {}
};

template <> inline void AFXAPI DestructElements<CWbemProxyServerWrap> (CWbemProxyServerWrap* ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i].m_Proxy != NULL)
		{
			ptr_e[i].m_Proxy->Release();
		}
	}
}

class CWbemServerWrap
{
private:

	LONG m_ref;
	CList<CWbemProxyServerWrap, CWbemProxyServerWrap &> m_ProxyPool;
	IWbemServices *m_MainServ;
	wchar_t *m_Principal;
	BSTR m_Path;
	CCriticalSection m_Lock;

public:

		CWbemServerWrap(IWbemServices *pServ, const wchar_t* prncpl, const wchar_t* path);
	
	ULONG	AddRef();
	ULONG	Release();

	BOOL			IsRemote() { return m_Principal != NULL; }
	const wchar_t*	GetPrincipal() { return m_Principal; }
	BSTR			GetPath() { return m_Path; }
	IWbemServices*	GetServerOrProxy();
	void			ReturnServerOrProxy(IWbemServices *a_pServ);
	void			SetMainServer(IWbemServices *a_pServ);
	BOOL			ProxyBelongsTo(IWbemServices *a_proxy);

		~CWbemServerWrap();
};

template <> inline void AFXAPI  DestructElements<CWbemServerWrap*> (CWbemServerWrap** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			ptr_e[i]->Release();
		}
	}
}

template <> inline void AFXAPI  DestructElements<IWbemServices*> (IWbemServices** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			ptr_e[i]->Release();
		}
	}
}

class CIWbemServMap : public CMap<CStringW, LPCWSTR, CWbemServerWrap*, CWbemServerWrap*>
{
private:

	CCriticalSection m_Lock;


public:

	BOOL Lock() { return m_Lock.Lock(); }
	void EmptyMap();
	BOOL Unlock() { return m_Lock.Unlock(); }
};

class WbemProvErrorObject 
{
private:

	wchar_t *m_provErrorMessage ;
	WBEMPROVSTATUS m_provErrorStatus ;
	WBEMSTATUS m_wbemErrorStatus ;

protected:
public:

	WbemProvErrorObject () : m_provErrorMessage ( NULL ) , m_wbemErrorStatus ( WBEM_NO_ERROR ) , m_provErrorStatus ( WBEM_PROV_NO_ERROR ) {} ;
	virtual ~WbemProvErrorObject () { delete [] m_provErrorMessage ; } ;

	void SetStatus ( WBEMPROVSTATUS a_provErrorStatus )
	{
		m_provErrorStatus = a_provErrorStatus ;
	} ;

	void SetWbemStatus ( WBEMSTATUS a_wbemErrorStatus ) 
	{
		m_wbemErrorStatus = a_wbemErrorStatus ;
	} ;

	void SetMessage ( wchar_t *a_provErrorMessage )
	{
		delete [] m_provErrorMessage ;
		m_provErrorMessage = UnicodeStringDuplicate ( a_provErrorMessage ) ;
	} ;

	wchar_t *GetMessage () { return m_provErrorMessage ; } ;
	WBEMPROVSTATUS GetStatus () { return m_provErrorStatus ; } ;
	WBEMSTATUS GetWbemStatus () { return m_wbemErrorStatus ; } ;
} ;

class CViewProvServ : public IWbemServices, public IWbemProviderInit
{
private:

	BOOL m_Initialised ;
	LONG m_ReferenceCount ;         //Object reference count

	CCriticalSection m_criticalSection ;

	WbemNamespacePath m_NamespacePath ;
	wchar_t *m_Namespace ;

	IWbemServices *m_Server ;

	wchar_t *m_localeId ;
	BSTR m_UserName;


	BOOL m_GetNotifyCalled ;
	BOOL m_GetExtendedNotifyCalled ;
	IWbemClassObject *m_NotificationClassObject ;
	IWbemClassObject *m_ExtendedNotificationClassObject ;

protected:
public:

	static ProvDebugLog*	sm_debugLog;
	static IUnsecuredApartment* sm_UnsecApp;

	CIWbemServMap	sm_ServerMap;
	IWbemLocator*	sm_Locator;
	CMap<CStringW, LPCWSTR, int, int> sm_OutStandingConnections;
	HANDLE sm_ConnectionMade;

	CViewProvServ () ;
    ~CViewProvServ () ;

	// Implementation
	HRESULT GetLocator(IWbemLocator** ppLoc);

	static HRESULT GetUnsecApp(IUnsecuredApartment** ppLoc);

	IWbemServices *GetServer () ;

	WbemNamespacePath *GetNamespacePath () { return & m_NamespacePath ; }

	wchar_t *GetNamespace () ;
	void SetNamespace ( wchar_t *a_Namespace ) ;

#ifndef UNICODE	
	BSTR GetUserName() {return m_UserName;}
#endif

	void SetLocaleId ( wchar_t *a_localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	BOOL CreateExtendedNotificationObject ( 

		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	BOOL CreateNotificationObject ( 

		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	IWbemClassObject *GetNotificationObject (
		
		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	IWbemClassObject *GetExtendedNotificationObject (
		
		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);
        
} ;

#define DebugOut8(a) { \
\
	if ( CViewProvServ::sm_debugLog && CViewProvServ::sm_debugLog->GetLogging() && (CViewProvServ::sm_debugLog->GetLevel() & 8) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugOut4(a) { \
\
	if ( CViewProvServ::sm_debugLog && CViewProvServ::sm_debugLog->GetLogging() && (CViewProvServ::sm_debugLog->GetLevel() & 4) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugOut2(a) { \
\
	if ( CViewProvServ::sm_debugLog && CViewProvServ::sm_debugLog->GetLogging() && (CViewProvServ::sm_debugLog->GetLevel() & 2) ) \
	{ \
		{a ; } \
	} \
} 


#define DebugOut1(a) { \
\
	if ( CViewProvServ::sm_debugLog && CViewProvServ::sm_debugLog->GetLogging() && (CViewProvServ::sm_debugLog->GetLevel() & 1 ) ) \
	{ \
		{a ; } \
	} \
} 


#endif //_VIEW_PROV_VPSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\vp_core_qengine.cpp ===
//***************************************************************************

//

//  VP_CORE_QENGINE.CPP

//

//  Module: WBEM VIEW PROVIDER

//

//  Purpose: Contains taskobject implementation copied from winmgmt core code

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <provcoll.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>

#include <dsgetdc.h>
#include <lmcons.h>

#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <vpdefs.h>
#include <vpcfac.h>
#include <vpquals.h>
#include <vpserv.h>
#include <vptasks.h>
#include <wbemtime.h>


//======================================================
//ReadI64, ReadUI64 and bAreWeLocal "stolen" from 
//Core's common\genutil.cpp. Used without modification.
//======================================================

BOOL ReadI64(LPCWSTR wsz, __int64& ri64)
{
    __int64 i64 = 0;
    const WCHAR* pwc = wsz;

    int nSign = 1;
    if(*pwc == L'-')
    {
        nSign = -1;
        pwc++;
    }
        
    while(i64 >= 0 && i64 < 0x7FFFFFFFFFFFFFFF / 8 && 
            *pwc >= L'0' && *pwc <= L'9')
    {
        i64 = i64 * 10 + (*pwc - L'0');
        pwc++;
    }

    if(*pwc)
        return FALSE;

    if(i64 < 0)
    {
        // Special case --- largest negative number
        // ========================================

        if(nSign == -1 && i64 == (__int64)0x8000000000000000)
        {
            ri64 = i64;
            return TRUE;
        }
        
        return FALSE;
    }

    ri64 = i64 * nSign;
    return TRUE;
}

BOOL ReadUI64(LPCWSTR wsz, unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return FALSE;

        pwc++;
    }

    if(*pwc)
    {
        return FALSE;
    }

    rui64 = ui64;
    return TRUE;
}

BOOL bAreWeLocal(WCHAR * pServerMachine)
{
	BOOL bRet = FALSE;
	if((pServerMachine == NULL) || (*pServerMachine == L'\0'))
		return TRUE;
	if(!_wcsicmp(pServerMachine,L"."))
		return TRUE;

	TCHAR tcMyName[MAX_PATH];
	DWORD dwSize = MAX_PATH;
	if(!GetComputerName(tcMyName,&dwSize))
		return FALSE;

#ifdef UNICODE
	bRet = !_wcsicmp(tcMyName,pServerMachine);
#else
	WCHAR wWide[MAX_PATH];
	mbstowcs(wWide, tcMyName, MAX_PATH-1);
	bRet = !_wcsicmp(wWide,pServerMachine);
#endif
	return bRet;
}


//============================================================
//This class has been created as a Variant garbage collector
//to mimick the use of a garbage collector in EvaluateToken.
//============================================================

class CVariantClear
{
private:
	VARIANT* m_variant;
public:
	CVariantClear(VARIANT* v) {m_variant = v;}
	~CVariantClear() { VariantClear(m_variant); }
};


//==================================================================
//EvaluateToken "stolen" from core's coredll\qengine.cpp and 
//modified so as not to return INVALID, or use the core's
//QL_LEVEL_1_TOKEN or the core's method of normalising a reference.
//==================================================================

BOOL WbemTaskObject::EvaluateToken(
	IWbemClassObject *pTestObj,
	SQL_LEVEL_1_TOKEN &Tok
	)
{
	VARIANT PropVal;
	VariantInit(&PropVal);
	
	
	//Use the garbage collector class
	//===============================

	CVariantClear clv(&PropVal);

	CIMTYPE cimType;
	HRESULT hRes;

	
	// Special-case 'this'
	// ===================

	if(_wcsicmp(Tok.pPropertyName, L"__THIS") == 0)
	{
		cimType = CIM_OBJECT;
		V_VT(&PropVal) = VT_UNKNOWN;
		hRes = pTestObj->QueryInterface(IID_IWbemClassObject,
											(void**)&V_UNKNOWN(&PropVal));
	}
	else
	{
		hRes = pTestObj->Get(Tok.pPropertyName, 0, &PropVal, &cimType, NULL);
	}

	if (FAILED(hRes))
		return FALSE;

	
	// Handle NULLs
	// ============

	if(V_VT(&PropVal) == VT_NULL)
	{
		if(V_VT(&Tok.vConstValue) == VT_NULL)
		{
			if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
				return TRUE;
			else if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
				return FALSE;
			else
				return FALSE;	//INVALID;
		}
		else
		{
			if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
				return FALSE;
			else if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
				return TRUE;
			else
				return FALSE;	//INVALID;
		}
	}
	else if(V_VT(&Tok.vConstValue) == VT_NULL)
	{
		if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)
			return FALSE;
		else if(Tok.nOperator == SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
			return TRUE;
		else
			return FALSE;	//INVALID;
	}

	// Handle references
	// =================

	if(cimType == CIM_REFERENCE)
	{
		// This is a reference. The only operators allowed are = and !=
		// ============================================================

		//Use the local normalisation method, not core's....
#if 0
		LPWSTR va = CQueryEngine::NormalizePath(V_BSTR(&PropVal), pNs);
		LPWSTR vb = CQueryEngine::NormalizePath(V_BSTR(&Tok.vConstValue), pNs);
#else
		LPWSTR va = NULL;
		LPWSTR vb = NULL;

		if (m_ServerWrap == NULL)
		{
			CWbemServerWrap *t_SWrap = new CWbemServerWrap(m_Serv, NULL, NULL);
			t_SWrap->AddRef();
			va = NormalisePath(V_BSTR(&PropVal), &t_SWrap);

			if (t_SWrap)
			{
				vb = NormalisePath(V_BSTR(&Tok.vConstValue), &t_SWrap);
			}

			if (t_SWrap)
			{
				t_SWrap->Release();
			}
		}
		else
		{
			if (m_ServerWrap)
			{
				va = NormalisePath(V_BSTR(&PropVal), &m_ServerWrap);

				if (m_ServerWrap)
				{
					vb = NormalisePath(V_BSTR(&Tok.vConstValue), &m_ServerWrap);
				}
			}
		}
#endif

		if(va == NULL || vb == NULL)
		{
			return FALSE;	//INVALID;
		}

		int nRet;
		switch (Tok.nOperator)
		{
		case SQL_LEVEL_1_TOKEN::OP_EQUAL:
			nRet = (_wcsicmp(va,vb) == 0);
			break;
		case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
			nRet = (_wcsicmp(va, vb) != 0);
			break;
		default:
			nRet = FALSE;	//INVALID;
			break;
		}

		delete [] va;
		delete [] vb;

		return nRet;
	}


	// Check if ISA is used
	// ====================

//ISA operators not identified by the SQL parser the provider has...
//===================================================================
#if 0

	if(Tok.nOperator == QL1_OPERATOR_ISA ||
	   Tok.nOperator == QL1_OPERATOR_ISNOTA ||
	   Tok.nOperator == QL1_OPERATOR_INV_ISA ||
	   Tok.nOperator == QL1_OPERATOR_INV_ISNOTA)
	{
		// Account for inversion
		// =====================

		VARIANT* pv1;
		VARIANT* pv2;
		int bNeedDerived;

		if(Tok.nOperator == QL1_OPERATOR_ISA ||
		   Tok.nOperator == QL1_OPERATOR_ISNOTA)
		{
			pv2 = &Tok.vConstValue;
			pv1 = &PropVal;
			bNeedDerived = (Tok.nOperator == QL1_OPERATOR_ISA);
		}
		else
		{
			pv1 = &Tok.vConstValue;
			pv2 = &PropVal;
			bNeedDerived = (Tok.nOperator == QL1_OPERATOR_INV_ISA);
		}

		// The second argument has to be a string
		// ======================================

		if(V_VT(pv2) != VT_BSTR)
		{
			return INVALID;
		}

		BSTR strParentClass = V_BSTR(pv2);

		// The first argument has to be an object or a string
		// ==================================================

		BOOL bDerived;
		if(V_VT(pv1) == VT_EMBEDDED_OBJECT)
		{
			IWbemClassObject* pObj = (IWbemClassObject*)V_EMBEDDED_OBJECT(pv1);
			bDerived = (pObj->InheritsFrom(strParentClass) == WBEM_S_NO_ERROR);
		}
		else if(V_VT(pv1) == VT_BSTR)
		{
			// TBD
			// ===

			return INVALID;
		}
		else
		{
			return INVALID;
		}

		// Now that we have bDerived, see if it matches the requirement
		// ============================================================

		if(bDerived == bNeedDerived)
			return TRUE;
		else
			return FALSE;

	}
#endif

	// Perform UINT32 workaround
	// =========================

	if((cimType == CIM_UINT32) && (V_VT(&PropVal) == VT_I4))
	{
		DWORD dwVal = (DWORD)V_I4(&PropVal);
		WCHAR wszVal[20];
		swprintf(wszVal, L"%lu", dwVal);
		V_VT(&PropVal) = VT_BSTR;
		V_BSTR(&PropVal) = SysAllocString(wszVal);
	}

	if(((cimType == CIM_SINT64) ||
			 (cimType == CIM_UINT64) ||
			 (cimType == CIM_UINT32)) &&
		(V_VT(&Tok.vConstValue) != VT_NULL) && (V_VT(&PropVal) != VT_NULL))
	{
		// We have a 64-bit comparison where both sides are present.
		// =========================================================

		hRes = VariantChangeType(&Tok.vConstValue, &Tok.vConstValue, 0,
									VT_BSTR);
		if(FAILED(hRes))
		{
			return FALSE;	//INVALID;
		}

		if(cimType == CIM_UINT64)
		{
			unsigned __int64 ui64Prop, ui64Const;

			if(!ReadUI64(V_BSTR(&PropVal), ui64Prop))
				return FALSE;	//INVALID;

			if(!ReadUI64(V_BSTR(&Tok.vConstValue), ui64Const))
				return FALSE;	//INVALID;

			switch (Tok.nOperator)
			{
				case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (ui64Prop == ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
					return (ui64Prop != ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
					return (ui64Prop >= ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
					return (ui64Prop <= ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
					return (ui64Prop < ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
					return (ui64Prop > ui64Const);
				case SQL_LEVEL_1_TOKEN::OP_LIKE: return (ui64Prop == ui64Const);
			}
			return FALSE;	//INVALID;
		}
		else
		{
			__int64 i64Prop, i64Const;

			if(!ReadI64(V_BSTR(&PropVal), i64Prop))
				return FALSE;	//INVALID;

			if(!ReadI64(V_BSTR(&Tok.vConstValue), i64Const))
				return FALSE;	//INVALID;

			switch (Tok.nOperator)
			{
				case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
				case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
					return (i64Prop != i64Const);
				case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
					return (i64Prop >= i64Const);
				case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
					return (i64Prop <= i64Const);
				case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
					return (i64Prop < i64Const);
				case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
					return (i64Prop > i64Const);
				case SQL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
			}
			return FALSE;	//INVALID;
		}
	}

	if((cimType == CIM_CHAR16) &&
		(V_VT(&Tok.vConstValue) == VT_BSTR) && (V_VT(&PropVal) != VT_NULL))
	{
		// Coerce strings correctly
		// ========================

		BSTR str = V_BSTR(&Tok.vConstValue);
		if(wcslen(str) != 1)
			return FALSE;	//INVALID;

		short va = V_I2(&PropVal);
		short vb = str[0];

		switch (Tok.nOperator)
		{
			case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
			case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
			case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
			case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
			case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
			case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
			case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
		}

		return FALSE;	//INVALID;
	}

	if((cimType == CIM_DATETIME) &&
			(V_VT(&Tok.vConstValue) == VT_BSTR) && (V_VT(&PropVal) == VT_BSTR))
	{
		WBEMTime tConst(Tok.vConstValue.bstrVal);
		WBEMTime tProp(PropVal.bstrVal);

		__int64 i64Const = tConst.GetTime();
		__int64 i64Prop = tProp.GetTime();

		if ((i64Const == INVALID_TIME) || (i64Prop == INVALID_TIME))
		{
			return FALSE;	//INVALID;
		}

		switch (Tok.nOperator)
		{
			case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
			case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
				return (i64Prop != i64Const);
			case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
				return (i64Prop >= i64Const);
			case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
				return (i64Prop <= i64Const);
			case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
				return (i64Prop < i64Const);
			case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
				return (i64Prop > i64Const);
			case SQL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
		}
	}

	// Coerce types to match.
	// ======================

	VARIANT ConstVal;
	VariantInit(&ConstVal);

	if (FAILED(VariantCopy(&ConstVal, &Tok.vConstValue)))
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

	if(V_VT(&Tok.vConstValue) != VT_NULL && V_VT(&PropVal) != VT_NULL)
	{
		hRes = VariantChangeType(&ConstVal, &ConstVal, 0, V_VT(&PropVal));
		if(FAILED(hRes))
		{
			return FALSE;	//INVALID;
		}
	}

	switch (V_VT(&ConstVal))
	{
		case VT_NULL:
			return FALSE;	//INVALID; // handled above

		case VT_I4:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				LONG va = V_I4(&PropVal);
				LONG vb = V_I4(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_I2:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				short va = V_I2(&PropVal);
				short vb = V_I2(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_UI1:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				BYTE va = V_I1(&PropVal);
				BYTE vb = V_I1(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_BSTR:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				LPWSTR va = (LPWSTR) V_BSTR(&PropVal);
				LPWSTR vb = (LPWSTR) V_BSTR(&ConstVal);

				int retCode = 0;
				BOOL bDidIt = TRUE;

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL:
						retCode = ( _wcsicmp(va,vb) == 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
						retCode = (_wcsicmp(va, vb) != 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
						retCode = (_wcsicmp(va, vb) >= 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
						retCode = (_wcsicmp(va, vb) <= 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN:
						retCode = (_wcsicmp(va, vb) < 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN:
						retCode = (_wcsicmp(va, vb) > 0);
						break;
					case SQL_LEVEL_1_TOKEN::OP_LIKE:
						retCode = (_wcsicmp(va,vb) == 0);
						break;
					default:
						bDidIt = FALSE;
						break;
				}
				VariantClear(&ConstVal);
				if (bDidIt)
				{
					return retCode;
				}
			}
			break;

		case VT_R8:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				double va = V_R8(&PropVal);
				double vb = V_R8(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_R4:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				float va = V_R4(&PropVal);
				float vb = V_R4(&ConstVal);

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;

		case VT_BOOL:
			{
				if(V_VT(&PropVal) == VT_NULL)
					return FALSE;	//INVALID;

				VARIANT_BOOL va = V_BOOL(&PropVal);
				if(va != VARIANT_FALSE) va = VARIANT_TRUE;
				VARIANT_BOOL vb = V_BOOL(&ConstVal);
				if(vb != VARIANT_FALSE) vb = VARIANT_TRUE;

				switch (Tok.nOperator)
				{
					case SQL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
					case SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
					case SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return FALSE;	//INVALID;
					case SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return FALSE;	//INVALID;
					case SQL_LEVEL_1_TOKEN::OP_LESSTHAN: return FALSE;	//INVALID;
					case SQL_LEVEL_1_TOKEN::OP_GREATERTHAN: return FALSE;	//INVALID;
					case SQL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
				}
			}
			break;
	}

	return FALSE;
}


//=============================================
//NormalisePath replaces core's version, This 
//returns the full path including server name.
//=============================================

wchar_t* WbemTaskObject::NormalisePath(wchar_t *wszObjectPath, CWbemServerWrap **pNSWrap)
{
	CObjectPathParser objPathparser;
	ParsedObjectPath* pParsedPath;

	if ( (objPathparser.Parse(wszObjectPath, &pParsedPath) != CObjectPathParser::NoError) ||
		(!pParsedPath->IsObject()) )
	{
		return NULL;
	}

	if(pParsedPath->m_pClass == NULL)
	{
		return NULL;
	}

	// Start off with the server and namespace part

	CStringW wsNormal(L"\\\\");

	if(bAreWeLocal(pParsedPath->m_pServer))
	{
		wsNormal += L".";
	}
	else
	{
		wsNormal += pParsedPath->m_pServer;
	}

	wsNormal += L"\\";
	LPWSTR pPath = pParsedPath->GetNamespacePart();
	BOOL bGetNS = FALSE;
	CWbemServerWrap *pServ = NULL;

	if(pPath)
	{
		wsNormal += pPath;
		Connect(pPath, &pServ);
	}
	else
	{
		bGetNS = TRUE;
	}

	if (pPath != NULL)
	{
		delete [] pPath;
	}

	// Find the parent that defined the key
	// ====================================

	//ConfigMgr::GetDbPtr()->FindKeyRoot(pNs->GetNamespaceId(), pParsedPath->m_pClass, &pRootClass);
	
	wchar_t *nsPath = NULL;
	wchar_t *pRootClass = NULL;
	
	if (pServ)
	{
		pRootClass = GetClassWithKeyDefn(&pServ, pParsedPath->m_pClass, bGetNS, &nsPath);

		if (pServ)
		{
			pServ->Release();
		}
	}
	else
	{
		pRootClass = GetClassWithKeyDefn(pNSWrap, pParsedPath->m_pClass, bGetNS, &nsPath);
	}

	if(pRootClass != NULL)
	{
		if (bGetNS)
		{
			wsNormal += nsPath;
			delete [] nsPath;
		}

		wsNormal += L":";
		wsNormal += pRootClass;
	}
	else
	{
		delete [] pParsedPath;
		return NULL;
	}

	// Convert this part to upper-case
	// ===============================

	wsNormal.MakeUpper();

	LPWSTR wszKey = pParsedPath->GetKeyString();
	wsNormal += L"=";
	wsNormal += wszKey;
	delete [] wszKey;
	delete [] pParsedPath;
	delete [] pRootClass;
	wchar_t* retVal = new wchar_t[wsNormal.GetLength() + 1];
	wcscpy(retVal, wsNormal);
	return retVal;
}

//===================================================================
//GetClassWithKeyDefn replaces core's version of FindKeyRoot. This 
//returns the class name that contains the key definitions and 
//optionally the path of the namespaces that the class is contained.
//===================================================================

wchar_t* WbemTaskObject::GetClassWithKeyDefn(
	CWbemServerWrap **pNS,
	BSTR classname,
	BOOL bGetNS,
	wchar_t **nsPath,
	BOOL bCheckSingleton
)
{
	if (bGetNS)
	{
		if (nsPath == NULL)
		{
			return NULL;
		}
		else
		{
			*nsPath = NULL;
		}
	}

	wchar_t *retVal = NULL;
	IWbemClassObject *pObj = NULL;

	IWbemServices *ptmpServ = (*pNS)->GetServerOrProxy();
	HRESULT hr = WBEM_E_FAILED;

	if (ptmpServ)
	{
		hr = ptmpServ->GetObject(classname, 0, m_Ctx, &pObj, NULL);

		if ( FAILED(hr) && (HRESULT_FACILITY(hr) != FACILITY_ITF) && (*pNS)->IsRemote())
		{
			if ( SUCCEEDED(UpdateConnection(pNS, &ptmpServ)) )
			{
				if (ptmpServ)
				{
					hr = ptmpServ->GetObject(classname, 0, m_Ctx, &pObj, NULL);
				}
			}
		}

		if (ptmpServ)
		{
			(*pNS)->ReturnServerOrProxy(ptmpServ);
		}
	}

	if ( SUCCEEDED(hr) )
	{
		BOOL bContinue = TRUE;
		VARIANT v;

		if (bGetNS)
		{
			VariantInit(&v);
			bContinue = FALSE;

			if ( SUCCEEDED(pObj->Get(WBEM_PROPERTY_NSPACE, 0, &v, NULL, NULL)) )
			{
				if (v.vt == VT_BSTR)
				{
					*nsPath = UnicodeStringDuplicate(v.bstrVal);
					bContinue = TRUE;
				}
			}

			VariantClear(&v);
		}

		if (bContinue && bCheckSingleton)
		{
			IWbemQualifierSet *pQuals = NULL;
			bContinue = FALSE;

			if ( SUCCEEDED(pObj->GetQualifierSet(&pQuals)) )
			{
				VariantInit(&v);

				if (SUCCEEDED(pQuals->Get(VIEW_QUAL_SNGLTN, 0, &v, NULL)) )
				{
					if (v.vt == VT_BOOL)
					{
						if (v.boolVal == VARIANT_TRUE)
						{
							retVal = UnicodeStringDuplicate(classname);
						}
					}
				}
				else
				{
					bContinue = TRUE;
				}

				VariantClear(&v);
				pQuals->Release();
			}
		}

		if (bContinue)
		{
			SAFEARRAY *t_pArray = NULL;

			if ( SUCCEEDED(pObj->GetNames(NULL, WBEM_FLAG_KEYS_ONLY | WBEM_FLAG_LOCAL_ONLY,
											NULL, &t_pArray)) )
			{
				if (SafeArrayGetDim(t_pArray) == 1)
				{
					if (0 == t_pArray->rgsabound[0].cElements)
					{
						VariantInit(&v);
						bContinue = FALSE;

						if ( SUCCEEDED(pObj->Get(WBEM_PROPERTY_SCLASS, 0, &v, NULL, NULL)) )
						{
							if (v.vt == VT_BSTR)
							{
								retVal = GetClassWithKeyDefn(pNS, v.bstrVal, FALSE, NULL, FALSE);
							}
						}

						VariantClear(&v);
					}
					else
					{
						retVal = UnicodeStringDuplicate(classname);
					}
				}

				SafeArrayDestroy(t_pArray);
			}
		}

		pObj->Release();
	}
	
	if ((retVal == NULL) && bGetNS && (*nsPath != NULL))
	{
		delete [] *nsPath;
		*nsPath = NULL;
	}

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\viewprovider\include\vptasks.h ===
//***************************************************************************

//

//  VPTASKS.H

//

//  Module: 

//

//  Purpose: Defines tasks that IWbemServices needs to perform.

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _VIEW_PROV_VPTASKS_H
#define _VIEW_PROV_VPTASKS_H

#define WBEM_TASKSTATE_START				0x0
#define WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE	0x100000
#define WBEM_TASKSTATE_ASYNCHRONOUSABORT	0x100001

#define CONST_NETAPI_LIBRARY _T("netapi32.dll")
#define CONST_NETAPI_DSPROC ("DsGetDcNameW")
#define CONST_NETAPI_NETPROC ("NetApiBufferFree")

typedef DWORD ( WINAPI *NETAPI_PROC_DsGetDcName ) (

    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
) ;

typedef NET_API_STATUS ( NET_API_FUNCTION *NETAPI_PROC_NetApiBufferFree ) (

    IN LPVOID Buffer
) ;



class WbemTaskObject;
class CObjectSinkResults;

class CViewProvObjectSink : public IWbemObjectSink
{
private:
	
	LONG m_ReferenceCount;         //Object reference count
	CObjectSinkResults *m_parent;
	CCriticalSection m_lock;
	CWbemServerWrap *m_ServWrap;
	IWbemObjectSink *m_RemoteSink;
	BOOL m_DoCancel;
	DWORD m_nsindex;

public:

	//Constructor
		CViewProvObjectSink(CObjectSinkResults* parent, CWbemServerWrap *pServ, DWORD a_indx);

	//Non-delegating object IUnknown

    STDMETHODIMP			QueryInterface (REFIID refIID, LPVOID FAR * ppV);
    STDMETHODIMP_(ULONG) 	AddRef ();
    STDMETHODIMP_(ULONG) 	Release ();

    //IWbemObjectSink methods
	HRESULT STDMETHODCALLTYPE	Indicate(LONG count, IWbemClassObject** ppObjArray);
	HRESULT STDMETHODCALLTYPE	SetStatus(LONG lFlags, HRESULT hr, BSTR bStr, IWbemClassObject* pObj);

	//implementation
	void				Disconnect();
	void				DisAssociate();
	IWbemObjectSink*	Associate();

	//Destructor
		~CViewProvObjectSink();

};

template <> inline void AFXAPI  DestructElements<IWbemClassObject*> (IWbemClassObject** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			ptr_e[i]->Release();
		}
	}
}

class CWbemClassObjectWithIndex
{
private:
	LONG m_ReferenceCount;
	DWORD m_nsindex;
	IWbemClassObject *m_pObject;

public:
    
		CWbemClassObjectWithIndex(DWORD a_indx, IWbemClassObject *a_pObj);

	ULONG	AddRef();
    ULONG	Release();
	DWORD	GetIndex() { return m_nsindex; }
	IWbemClassObject * GetWrappedObject() { return m_pObject; }

		~CWbemClassObjectWithIndex();
};

template <> inline void AFXAPI  DestructElements<CWbemClassObjectWithIndex*> (CWbemClassObjectWithIndex** ptr_e, int x)
{
	for (int i = 0; i < x; i++)
	{
		if (ptr_e[i] != NULL)
		{
			ptr_e[i]->Release();
		}
	}
}

class CObjectSinkResults : public CObject
{
private:

	CList<CViewProvObjectSink *, CViewProvObjectSink *> m_realSnks;
	CCriticalSection m_CriticalSection;
	WbemTaskObject *m_parent;
	DWORD m_index;
	HRESULT m_hr;
	BOOL m_bSet;
	LONG m_ReferenceCount;

public:
	 
	CArray<CWbemClassObjectWithIndex*, CWbemClassObjectWithIndex*> m_ObjArray;
	DWORD	GetIndex() { return m_index; }
	BOOL	IsSet() { return m_bSet; }
	HRESULT	GetResult() { return m_hr; }
	void	Disconnect();
	BOOL	RemoveSink(CViewProvObjectSink *pSnk);
	void	SetSink(CViewProvObjectSink *pSnk);
	void	SetStatus(HRESULT hr, CViewProvObjectSink *pSnk);
	HRESULT	Indicate(LONG count, IWbemClassObject** ppObjArray, DWORD a_indx);
    ULONG	AddRef ();
    ULONG	Release ();


	CObjectSinkResults(WbemTaskObject* parent, DWORD index);
	~CObjectSinkResults();
};

class WbemTaskObject
{
private:
protected:

	WbemProvErrorObject m_ErrorObject ;

	ULONG m_OperationFlag;
	IWbemClassObject *m_ClassObject;
	IWbemObjectSink *m_NotificationHandler;
	IWbemContext *m_Ctx;
	CViewProvServ *m_Provider;
	CTypedPtrArray<CObArray, CSourceQualifierItem*> m_SourceArray;
	CMap<CStringW, LPCWSTR, int, int> m_ClassToIndexMap;
	CTypedPtrArray<CObArray, CNSpaceQualifierItem*> m_NSpaceArray;
	CMap<CStringW, LPCWSTR, CPropertyQualifierItem*, CPropertyQualifierItem*> m_PropertyMap;
	CMap<CStringW, LPCWSTR, int, int> m_EnumerateClasses;
	CJoinOnQualifierArray m_JoinOnArray;
	SQL_LEVEL_1_RPN_EXPRESSION*	m_RPNPostFilter;
	BSTR m_ClassName;
	CStringW m_ProviderName;
	LONG m_Ref;
	CTypedPtrArray<CObArray, CObjectSinkResults*> m_ObjSinkArray;
	CCriticalSection m_ArrayLock;
	int m_iQueriesAsked;
	int m_iQueriesAnswered;
	BOOL m_bAssoc;
	BOOL m_bSingleton;
	HANDLE m_StatusHandle;
	IWbemServices *m_Serv;
	CWbemServerWrap *m_ServerWrap;
	BOOL m_bIndicate;
	BOOL m_ResultReceived;


protected:

	void SetRequestHandle ( ULONG a_RequestHandle ) ;
	BOOL GetRequestHandle () ;
	BOOL GetClassObject (IWbemServices* pServ, BSTR a_Class, IWbemClassObject** ppClass, CWbemServerWrap **a_pServ = NULL) ;
	BOOL SetClass (const wchar_t* a_Class) ;
	BOOL GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL ParseAndProcessClassQualifiers (WbemProvErrorObject &a_ErrorObject,
											ParsedObjectPath *a_ParsedObjectPath = NULL,
											CMap<CStringW, LPCWSTR, int, int>* parentMap = NULL);
#ifdef VP_PERFORMANT_JOINS
	BOOL CreateAndIndicateJoinsPerf(WbemProvErrorObject &a_ErrorObject, BOOL a_bSingle);
	BOOL JoinTwoColumns(WbemProvErrorObject &a_ErrorObject,
						CMap<CStringW, LPCWSTR, int, int> &a_JoinedClasses,
						CList<IWbemClassObject*, IWbemClassObject*> &a_ResultObjs);
	BOOL AddColumnToJoin(WbemProvErrorObject &a_ErrorObject,
						CMap<CStringW, LPCWSTR, int, int> &a_JoinedClasses,
						CList<IWbemClassObject*, IWbemClassObject*> &a_ResultObjs,
						DWORD a_Index,
						CList <int, int> &a_IndexArray);
	BOOL JoinTwoItems(WbemProvErrorObject &a_ErrorObject,
						IWbemClassObject *a_Obj1,
						IWbemClassObject *a_Obj2,
						IWbemClassObject *a_resObj,
						CList <int, int> &a_IndexArray,
						DWORD a_indx1, DWORD a_indx2);
	BOOL JoinItem(WbemProvErrorObject &a_ErrorObject,
						IWbemClassObject *a_Obj1,
						IWbemClassObject *a_vObj,
						IWbemClassObject *a_resObj,
						CList <int, int> &a_IndexArray,
						DWORD a_indx1);
#else
	BOOL CreateAndIndicateJoins(WbemProvErrorObject &a_ErrorObject, BOOL a_bSingle);
	BOOL CreateAndIndicate(WbemProvErrorObject &a_ErrorObject, IWbemClassObject **pSrcs, IWbemClassObject **pOut);
#endif

	BOOL CreateAndIndicateUnions(WbemProvErrorObject &a_ErrorObject, int index = -1);
	BOOL CreateAndIndicate(WbemProvErrorObject &a_ErrorObject, CObjectSinkResults *pSrcs);
#if 0
	BOOL SetDefaultUnionKeyValue(wchar_t* propstr, IWbemClassObject* pObj);
#endif
	BOOL ValidateClassDependencies(IWbemClassObject*** arrayofArrayOfObjs, CMap<CStringW, LPCWSTR, int, int>* parentMap);
	BOOL ValidateJoin();
	BOOL TransposeReference(CPropertyQualifierItem* pItm, VARIANT vSrc, VARIANT* pvDst, BOOL bMapToView, CWbemServerWrap **a_ns);
	BSTR MapFromView(BSTR path, const wchar_t* src, IWbemClassObject** pInst = NULL, BOOL bAllprops = FALSE);
	BSTR MapToView(BSTR path, const wchar_t* src, CWbemServerWrap **a_ns);
	BOOL EvaluateToken(IWbemClassObject *pTestObj, SQL_LEVEL_1_TOKEN &Tok);
	BOOL PostFilter(IWbemClassObject* a_pObj);
	HRESULT	Connect(const wchar_t* path, CWbemServerWrap** ppServ, BOOL a_bUpdate = FALSE);
	HRESULT UpdateConnection(CWbemServerWrap **a_pServ, IWbemServices **a_proxy);
	HRESULT DoConnectServer(BSTR bstrPath, CWbemServerWrap **a_ppServ, BOOL a_bUpdate);
	HRESULT LocalConnectServer(BSTR bstrPath, IWbemServices** ppServ);
#ifdef UNICODE
	HRESULT CoCreateForConnectServer(BSTR bstrPath, COSERVERINFO* psi, COAUTHIDENTITY* pauthid, IWbemServices** ppServ);
#endif

	wchar_t* NormalisePath(wchar_t *wszObjectPath, CWbemServerWrap **pNSWrap);
	wchar_t* GetClassWithKeyDefn(CWbemServerWrap **pNS, BSTR classname, BOOL bGetNS, wchar_t **nsPath, BOOL bCheckSingleton = TRUE);
	DWORD GetIndexList(const wchar_t* a_src, DWORD** a_pdwArray);

public:

	WbemTaskObject ( 

		CViewProvServ *a_Provider ,
		IWbemObjectSink *a_NotificationHandler ,
		ULONG a_OperationFlag ,
		IWbemContext *a_Ctx ,
		IWbemServices* a_Serv = NULL,
		CWbemServerWrap *a_ServWrap = NULL
	) ;

	LONG	AddRef();
	LONG	Release();
	WbemProvErrorObject &GetErrorObject();
	void	CleanUpObjSinks(BOOL a_bDisconnect = FALSE);
	virtual void SetStatus(HRESULT hr, DWORD index);
	void	SetResultReceived();

	virtual ~WbemTaskObject();


} ;

class HelperTaskObject : public WbemTaskObject
{
private:
	wchar_t *m_ObjectPath ;
	ParsedObjectPath *m_ParsedObjectPath ;
	wchar_t* m_principal ;

	BOOL DoQuery(ParsedObjectPath* parsedObjectPath, IWbemClassObject** pInst, int indx);

public:

		HelperTaskObject(
			CViewProvServ *a_Provider , 
			const wchar_t *a_ObjectPath , 
			ULONG a_Flag , 
			IWbemObjectSink *a_NotificationHandler,
			IWbemContext *pCtx,
			IWbemServices* a_Serv,
			const wchar_t* prncpl,
			CWbemServerWrap* a_ServWrap
		);

	BOOL Validate(CMap<CStringW, LPCWSTR, int, int>* parentMap);
	BOOL GetViewObject(const wchar_t* path, IWbemClassObject** pInst, CWbemServerWrap **a_ns);

		~HelperTaskObject();

};

class GetObjectTaskObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	ParsedObjectPath *m_ParsedObjectPath ;

protected:

	BOOL	PerformGet(WbemProvErrorObject &a_ErrorObject, IWbemClassObject** pInst = NULL, const wchar_t* src = NULL, BOOL bAllprops = FALSE);
	BOOL	PerformQueries(WbemProvErrorObject &a_ErrorObject, BOOL bAllprops);
	BOOL	ProcessResults(WbemProvErrorObject &a_ErrorObject, IWbemClassObject** pInst, const wchar_t* src);

public:

	GetObjectTaskObject ( 
		CViewProvServ *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler,
		IWbemContext *pCtx,
		IWbemServices* a_Serv,
		CWbemServerWrap *a_ServerWrap
		);

	BOOL	GetObject();
	BOOL	GetSourceObject(const wchar_t* src, IWbemClassObject** pInst, BOOL bAllprops);

	~GetObjectTaskObject();

} ;


class ExecMethodTaskObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Method ;
	ParsedObjectPath *m_ParsedObjectPath ;
	IWbemClassObject* m_InParamObject;
	IWbemClassObject* m_OutParamObject;

protected:

	BOOL CompareMethods(WbemProvErrorObject &a_ErrorObject,
						LONG &a_Index,
						CStringW &a_SrcMethodName,
						BOOL &a_bStatic);

	BOOL PerformMethod(WbemProvErrorObject &a_ErrorObject,
						LONG a_Index,
						CStringW a_SrcMethodName,
						BOOL a_bStatic);

public:

	ExecMethodTaskObject ( 

		CViewProvServ *a_Provider , 
		wchar_t *a_ObjectPath ,
		wchar_t *a_MethodName,
		ULONG a_Flag ,
		IWbemClassObject *a_InParams ,		
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	);

	BOOL ExecMethod();

	~ExecMethodTaskObject();
} ;


class PutInstanceTaskObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_InstObject ;

protected:

	BOOL PerformPut(WbemProvErrorObject &a_ErrorObject);

public:

	PutInstanceTaskObject ( 

		CViewProvServ *a_Provider , 
		IWbemClassObject *a_Inst , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	);

	BOOL PutInstance();

	~PutInstanceTaskObject();
} ;

class ExecQueryTaskObject : public WbemTaskObject
{
private:

	wchar_t *m_QueryFormat ; 
	wchar_t *m_Query ;
	wchar_t *m_Class ;

	SQL_LEVEL_1_RPN_EXPRESSION *m_RPNExpression ;

protected:

	BOOL	PerformQuery(WbemProvErrorObject &a_ErrorObject);
	BOOL	PerformEnumQueries(WbemProvErrorObject &a_ErrorObject);
	BOOL	PerformSelectQueries(WbemProvErrorObject &a_ErrorObject, BOOL &bWait);
	BOOL	ProcessResults(WbemProvErrorObject &a_ErrorObject);
	void	ModifySourceQueriesForUserQuery();
	void	ModifySourceQueriesWithEnumResults();

public:

	ExecQueryTaskObject ( 

		CViewProvServ *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	);

	BOOL	ExecQuery();

		~ExecQueryTaskObject();
} ;

#endif //_VIEW_PROV_VPTASKS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\globals.h ===
////////////////////////////////////////////////////////////////////

//

//  globals.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

#include <WDMSHELL.h>
#include <wchar.h>
#include <flexarry.h>
#include <provexpt.h>


typedef LPVOID * PPVOID;
#define PUT_INSTANCE 1
#define CREATE_INSTANCE_ENUM 2


// {0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC}
DEFINE_GUID(CLSID_WMIEventProvider, 0x725c3cb, 0xfefb, 0x11d0, 0x99, 0xf9, 0x0, 0xc0, 0x4f, 0xc2, 0xf8, 0xec);

// {D2D588B5-D081-11d0-99E0-00C04FC2F8EC}
DEFINE_GUID(CLSID_WMIProvider,0xd2d588b5, 0xd081, 0x11d0, 0x99, 0xe0, 0x0, 0xc0, 0x4f, 0xc2, 0xf8, 0xec);

// {35B78F79-B973-48c8-A045-CAEC732A35D5}
DEFINE_GUID(CLSID_WMIHiPerfProvider,0x35b78f79, 0xb973, 0x48c8, 0xa0, 0x45, 0xca, 0xec, 0x73, 0x2a, 0x35, 0xd5);

#include "wdmperf.h"
#include "classfac.h"
#include "wmiprov.h"
#include "wmievent.h"
#include "wmimof.h"

//===============================================================
// These variables keep track of when the module can be unloaded
//===============================================================

extern long g_cObj;
extern long g_cLock;
extern long glInits;
extern CWMIEvent *  g_pBinaryMofEvent;
extern CCriticalSection g_EventCs;

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Common functions regarding binary mof processing & security
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT SetupLocalEvents();
void DeleteLocalEvents();
void ProcessAllBinaryMofs(CHandleMap * pMap, IWbemServices __RPC_FAR *pNamespace,IWbemContext __RPC_FAR *pCtx,BOOL bProcessMofs = TRUE);
HRESULT CheckImpersonationLevelAndVerifyInternalEvents(BOOL);



#define STANDARD_CATCH      catch(Structured_Exception e_SE) {  hr = E_UNEXPECTED;  } \
                            catch(Heap_Exception e_HE)       {  hr = E_OUTOFMEMORY; } \
                            catch(...)                       {  hr = WBEM_E_UNEXPECTED;   }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\classfac.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WMI_CPROVFACTORY_HEADER
#define _WMI_CPROVFACTORY_HEADER

typedef void** PPVOID;
////////////////////////////////////////////////////////////////////
//
// This class is the class factory for CWMI_Prov objects.
//
////////////////////////////////////////////////////////////////////

class CProvFactory : public IClassFactory 
{

    protected:
        ULONG           m_cRef;
        CLSID m_ClsId;

    public:
        CProvFactory(const CLSID & ClsId);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
        STDMETHODIMP         LockServer(BOOL);
};

typedef CProvFactory *PCProvFactory;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\main.cpp ===
////////////////////////////////////////////////////////////////////////////////////////

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////////////////////
#include "globals.h"
#include <objbase.h>
#include <locale.h>
#include "classfac.h"
#include <stdio.h>
#include <tchar.h>
#include "wmiprov.h"

extern BOOL APIENTRY DllMain (HINSTANCE hinstDLL,DWORD fdwReason, LPVOID lpReserved) ;

DWORD g_InstanceRegister = 0 ;
DWORD g_EventRegister = 0 ;

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

BOOL s_Exiting = FALSE ;

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	long t_rc = 0 ;

	switch ( a_message )
	{
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"WDM Provider" ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	ShowWindow ( t_HWnd, SW_SHOW ) ;
//	ShowWindow ( t_HWnd, SW_HIDE ) ;

	return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
	CoUninitialize () ;
	DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;

        if ( s_Exiting ) 
            return ;
	}
}

HRESULT UninitComServer ()
{
	if ( g_InstanceRegister )
		CoRevokeClassObject ( g_InstanceRegister );

	CoUninitialize () ;

	return S_OK ;
}

HRESULT InitInstanceProvider ()
{
	IUnknown *t_ClassFactory = new CProvFactory(CLSID_WMIProvider);

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject ( CLSID_WMIProvider ,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_InstanceRegister
	);

	return t_Result ;
}

HRESULT InitEventProvider ()
{
    IUnknown *t_ClassFactory = new CProvFactory(CLSID_WMIEventProvider);

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (CLSID_WMIEventProvider,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_EventRegister
	);

	return t_Result ;
}

HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0, 
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel, 
			NULL, 
			EOAC_NONE, 
			0
		);

		if ( FAILED ( t_Result ) ) 
		{
			CoUninitialize () ;
			return t_Result ;
		}

	}

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitInstanceProvider () ;

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitEventProvider () ;

	if ( FAILED ( t_Result ) )
	{
		UninitComServer () ;
	}

	return t_Result  ;
}

HRESULT Process ()
{
#if 1
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
#else
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTITY ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE ;
#endif

	HRESULT t_Result = InitComServer ( t_ImpersonationLevel , t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WindowsDispatch () ;
		UninitComServer () ;
	}

	return t_Result ;
}

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;
		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllRegisterServer () ;
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllUnregisterServer () ;
			}
		}
	}

	return t_Exit ;
}

int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
	BOOL t_Status = DllMain (

		hInstance, 
		DLL_PROCESS_ATTACH , 
		NULL
	) ;

	BOOL t_Exit = ParseCommandLine () ;
	if ( ! t_Exit ) 
	{
		HWND hWnd = WindowsStart ( hInstance ) ;

		HRESULT t_Result = Process () ;

		WindowsStop ( hWnd ) ;
	}

	t_Status = DllMain (

		hInstance, 
		DLL_PROCESS_DETACH , 
		NULL
	) ;

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <Allocator.h>
#include <HashTable.h>

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\maindll.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////

//

//  MAINDLL.CPP

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <initguid.h>
#include <locale.h>
#include "wdmdefs.h"
#include <stdio.h>
#include <tchar.h>

HMODULE ghModule;
CWMIEvent *  g_pBinaryMofEvent = NULL;
CCriticalSection * g_pEventCs = NULL;      // Shared between all CWMIEvent instances to protect the global list
CCriticalSection * g_pSharedLocalEventsCs = NULL;
CCriticalSection * g_pListCs = NULL;   
//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    SetStructuredExceptionHandler seh;

    BOOL fRc = TRUE;

    try
    {
        switch( ulReason )
        {
            case DLL_PROCESS_DETACH:

                if( g_pListCs )
                {
        	        g_pListCs->Delete();
                    delete g_pListCs;
                    g_pListCs = NULL;
                }

                if( g_pEventCs )
                {
        	        g_pEventCs->Delete();
                    delete g_pEventCs;
                    g_pEventCs = NULL;
                }

				if( g_pSharedLocalEventsCs )
				{
					g_pSharedLocalEventsCs->Delete();
					delete g_pSharedLocalEventsCs;
					g_pSharedLocalEventsCs = NULL;
				}
                break;

            case DLL_PROCESS_ATTACH:			
                g_pSharedLocalEventsCs = new CCriticalSection();
                if( g_pSharedLocalEventsCs )
                {
    		        g_pSharedLocalEventsCs->Init();
					g_pEventCs = new CCriticalSection();
					if( g_pEventCs )
					{
    					g_pEventCs->Init();

						g_pListCs = new CCriticalSection();
						if( g_pListCs )
						{
							g_pListCs->Init();
						}
						else
						{
							fRc = FALSE;
						}
					}
					else
					{
						fRc = FALSE;
					}
				}
				else
				{
					fRc = FALSE;
				}

 			    ghModule = hInstance;
			    if (!DisableThreadLibraryCalls(ghModule))
				{
					TranslateAndLog( L"DisableThreadLibraryCalls failed" );
				}
                break;
       }
    }
    catch(Structured_Exception e_SE)
    {
        fRc = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        fRc = FALSE;
    }
    catch(...)
    {
        fRc = FALSE;
    }

    return fRc;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr =  CLASS_E_CLASSNOTAVAILABLE ;
    CProvFactory *pFactory = NULL;
    SetStructuredExceptionHandler seh;

    try
    {
        //============================================================================
        //  Verify the caller is asking for our type of object.
        //============================================================================
        if((CLSID_WMIProvider != rclsid) &&  (CLSID_WMIEventProvider != rclsid) && (CLSID_WMIHiPerfProvider != rclsid) )
        {
            hr = E_FAIL;
        }
        else{
            //============================================================================
            // Check that we can provide the interface.
            //============================================================================
            if (IID_IUnknown != riid && IID_IClassFactory != riid)
            {
                hr = E_NOINTERFACE;
            }
            else{					

                //============================================================================
                // Get a new class factory.
                //============================================================================
                try
				{
					hr = S_OK;
    	            pFactory=new CProvFactory(rclsid);
                    if (NULL==pFactory)
                    {
                        hr = E_OUTOFMEMORY;
                    }	
                }
				catch(...)
				{
					hr = WBEM_E_UNEXPECTED;
				}

                //============================================================================
                // Verify we can get an instance.
                //============================================================================
                if( SUCCEEDED(hr))
                {
                    hr = pFactory->QueryInterface(riid, ppv);
                    if (FAILED(hr))
                    {
                        SAFE_DELETE_PTR(pFactory);
                    }
					else
					{
						// If this is the first object created then call 
						// SetupLocalEvents to register for WMI events
						if(g_cObj == 1)
						{
							if(FAILED(hr = SetupLocalEvents()))
							{
								SAFE_DELETE_PTR(pFactory);
							}
						}
					}

                }
            }
        }
    }
    STANDARD_CATCH

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
/////////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc = S_FALSE;

    //============================================================================
    // It is OK to unload if there are no objects or locks on the 
    // class factory.
    //============================================================================
    
   if (0L==g_cObj && 0L==g_cLock)
   {
		sc = S_OK;
		DeleteLocalEvents();
		glInits = -1;
   }
   return sc;
}


// Convert the given string to TCHAR string
void ConvertToTCHAR(WCHAR *pStrIn , TCHAR *& pOut)
{
    CAnsiUnicode XLate;
	#ifndef UNICODE
							XLate.UnicodeToAnsi(pStrIn,pOut);
	#else
							pOut = pStrIn;
	#endif
}

// Delete the string if allocated. Memory is 
// allocated only if the system ANSI
void SafeDeleteTStr(TCHAR *& pStr)
{
	#ifndef UNICODE
								SAFE_DELETE_ARRAY(pStr);
	#else
								pStr = NULL;
	#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// CreateKey
//
// Purpose: Function to create a key
//
// Return:  NOERROR if registration successful, error otherwise.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CreateKey(TCHAR * szCLSID, TCHAR * szName)
{
    HKEY hKey1, hKey2;
    HRESULT hr = S_OK;

#ifdef LOCALSERVER

    HKEY hKey;
	TCHAR szProviderCLSIDAppID[128];

	_stprintf(szProviderCLSIDAppID, _T("SOFTWARE\\CLASSES\\APPID\\%s"),szName);

	hr = RegCreateKey(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID, &hKey);
    if( ERROR_SUCCESS == hr )
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)szName, (_tcsclen(szName) + 1) * sizeof(TCHAR));
    	CloseHandle(hKey);
    }

#endif


    if( ERROR_SUCCESS == hr )
    {
        hr = RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1);
        if( ERROR_SUCCESS == hr )
        {
            DWORD dwLen;
            dwLen = (_tcsclen(szName)+1) * sizeof(TCHAR);
            hr = RegSetValueEx(hKey1, NULL, 0, REG_SZ, (CONST BYTE *)szName, dwLen);
            if( ERROR_SUCCESS == hr )
            {

#ifdef LOCALSERVER
                hr = RegCreateKey(hKey1, _T("LocalServer32"), &hKey2);
#else
                hr = RegCreateKey(hKey1, _T("InprocServer32"), &hKey2);
#endif

                if( ERROR_SUCCESS == hr )
                {
                    TCHAR szModule[MAX_PATH];

                    GetModuleFileName(ghModule, szModule,  MAX_PATH);
                    dwLen = (_tcsclen(szModule)+1) * sizeof(TCHAR);
                    hr = RegSetValueEx(hKey2, NULL, 0, REG_SZ, (CONST BYTE *)szModule, dwLen );
                    if( ERROR_SUCCESS == hr )
                    {
                        dwLen = (_tcsclen(_T("Both"))+1) * sizeof(TCHAR);
                        hr = RegSetValueEx(hKey2, _T("ThreadingModel"), 0, REG_SZ,(CONST BYTE *)_T("Both"), dwLen);
                    }
                    CloseHandle(hKey2);
                }
            }
            CloseHandle(hKey1);
        }
    }

    return hr;
    
}
/////////////////////////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer(void)
{   
    WCHAR wcID[128];
    TCHAR * pID = NULL;
    TCHAR szCLSID[128];
    HRESULT hr = WBEM_E_FAILED;
    
    SetStructuredExceptionHandler seh;

    try{
        //==============================================
        // Create keys for WDM Instance Provider.
        //==============================================
        StringFromGUID2(CLSID_WMIProvider, wcID, 128);


		ConvertToTCHAR(wcID,pID);

	    if( pID )
        {
		    _stprintf(szCLSID, _T("CLSID\\%s"),pID);

			SafeDeleteTStr(pID);
			
		    hr = CreateKey(szCLSID,_T("WDM Instance Provider"));
            if( ERROR_SUCCESS == hr )
            {
                //==============================================
                // Create keys for WDM Event Provider.
                //==============================================
                StringFromGUID2(CLSID_WMIEventProvider, wcID, 128);
				ConvertToTCHAR(wcID,pID);
	            if( pID )
                {
                    _stprintf(szCLSID,_T("CLSID\\%s"),pID);

					SafeDeleteTStr(pID);

		            hr = CreateKey(szCLSID,_T("WDM Event Provider"));
					if( ERROR_SUCCESS == hr )
					{
						//==============================================
						// Create keys for WDM Event Provider.
						//==============================================
						StringFromGUID2(CLSID_WMIHiPerfProvider, wcID, 128);
						ConvertToTCHAR(wcID,pID);
						if( pID )
						{
							_stprintf(szCLSID,_T("CLSID\\%s"),pID);
							SafeDeleteTStr(pID);
							hr = CreateKey(szCLSID,_T("WDM HiPerf Provider"));
						}
					}
	            }
            }
        }
    }
    STANDARD_CATCH


    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////
//
// DeleteKey
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//
/////////////////////////////////////////////////////////////////////////////////////
HRESULT DeleteKey(TCHAR * pCLSID, TCHAR * pID)
{
    HKEY hKey;
	HRESULT hr = S_OK;


#ifdef LOCALSERVER

	TCHAR szTmp[MAX_PATH];
	_stprintf(szTmp, _T("SOFTWARE\\CLASSES\\APPID\\%s"),pID);

	//Delete entries under APPID

	hr = RegDeleteKey(HKEY_LOCAL_MACHINE, szTmp);
    if( ERROR_SUCCESS == hr )
    {
        _stprintf(szTemp,_T("%s\\LocalServer32"),pCLSID);
	    hr = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);
    }

#endif
    hr = RegOpenKey(HKEY_CLASSES_ROOT, pCLSID, &hKey);
    if(NO_ERROR == hr)
    {
        hr = RegDeleteKey(hKey,_T("InprocServer32"));
        CloseHandle(hKey);
    }


    hr = RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID"), &hKey);
    if(NO_ERROR == hr)
    {
        hr = RegDeleteKey(hKey,pID);
        CloseHandle(hKey);
    }


    return hr;
}
/////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
    WCHAR      wcID[128];
	TCHAR	*  pId = NULL;
    TCHAR      strCLSID[MAX_PATH];
    HRESULT hr = WBEM_E_FAILED;

    try
    {
        //===============================================
        // Delete the WMI Instance Provider
        //===============================================
        StringFromGUID2(CLSID_WMIProvider, wcID, 128);
		ConvertToTCHAR(wcID , pId);
        _stprintf(strCLSID, _T("CLSID\\%s"),pId);
        hr = DeleteKey(strCLSID, pId);
		SafeDeleteTStr(pId);

        if( ERROR_SUCCESS == hr )
        {
            //==========================================
            // Delete the WMI Event Provider
            //==========================================
            StringFromGUID2(CLSID_WMIEventProvider, wcID, 128);
			ConvertToTCHAR(wcID , pId);
            _stprintf(strCLSID, _T("CLSID\\%s"),pId);
            hr = DeleteKey(strCLSID,pId);
			SafeDeleteTStr(pId);
			if( ERROR_SUCCESS == hr )
			{
				//==========================================
				// Delete the WMI Event Provider
				//==========================================
				StringFromGUID2(CLSID_WMIHiPerfProvider, wcID, 128);
				ConvertToTCHAR(wcID , pId);
				_stprintf(strCLSID, _T("CLSID\\%s"),pId);
				hr = DeleteKey(strCLSID,pId);
				SafeDeleteTStr(pId);
			}
        }
    }
    STANDARD_CATCH

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\classfac.cpp ===
////////////////////////////////////////////////////////////////////////////////////////

//

//  CLASSFAC.CPP

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "wdmdefs.h"
////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor 
//  
////////////////////////////////////////////////////////////////////////////////////////
CProvFactory::CProvFactory(const CLSID & ClsId)
{
    m_cRef=0L;
    InterlockedIncrement((LONG *) &g_cObj);
    m_ClsId = ClsId;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////
CProvFactory::~CProvFactory(void)
{
    InterlockedDecrement((LONG *) &g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Standard Ole routines needed for all interfaces
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv=this;
    }

    if (NULL!=*ppv)
    {
        AddRef();
        hr = NOERROR;
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return InterlockedIncrement((long*)&m_cRef);
}
/////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
	ULONG cRef = InterlockedDecrement( (long*) &m_cRef);
	if ( !cRef ){
		delete this;
		return 0;
	}
	return cRef;
}
////////////////////////////////////////////////////////////////////////////////////////
//
// Instantiates an object returning an interface pointer.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, PPVOID ppvObj)
{
    HRESULT   hr = E_OUTOFMEMORY;
    IUnknown* pObj = NULL;

    *ppvObj=NULL;

    //==================================================================
    // This object doesnt support aggregation.
    //==================================================================

    if (NULL!=pUnkOuter)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else
    {
        //==============================================================
        //Create the object passing function to notify on destruction.
        //==============================================================
        if (m_ClsId == CLSID_WMIProvider)
        {
            try
			{
		        pObj = (IWbemServices *) new CWMI_Prov;
            }
			catch(...)
			{
				hr = WBEM_E_UNEXPECTED;
			}
        }
        else if (m_ClsId == CLSID_WMIEventProvider)
        {
            try
			{
    		    pObj = (IWbemEventProvider *) new CWMIEventProvider(WMIEVENT);
            }
			catch(...)
			{
				hr = WBEM_E_UNEXPECTED;
			}
        }
        else if (m_ClsId == CLSID_WMIHiPerfProvider)
        {
            try
			{
    		    pObj = (IWbemEventProvider *) new CWMIHiPerfProvider;
            }
			catch(...)
			{
				hr = WBEM_E_UNEXPECTED;
			}
        }
        if(pObj)
        {
            hr = pObj->QueryInterface(riid, ppvObj);
	    }

    }

    //===================================================================
    //Kill the object if initial creation or Init failed.
    //===================================================================
    if (FAILED(hr))
    {
		if( pObj )
		{
			SAFE_DELETE_PTR(pObj);
		}
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\wdmdefs.h ===
////////////////////////////////////////////////////////////////////

//

//  wdmdefs.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////

#ifndef _WDMDEFS_H_
#define _WDMDEFS_H_


// {0725C3CB-FEFB-11d0-99F9-00C04FC2F8EC}
DEFINE_GUID(CLSID_WMIEventProvider, 0x725c3cb, 0xfefb, 0x11d0, 0x99, 0xf9, 0x0, 0xc0, 0x4f, 0xc2, 0xf8, 0xec);

// {D2D588B5-D081-11d0-99E0-00C04FC2F8EC}
DEFINE_GUID(CLSID_WMIProvider,0xd2d588b5, 0xd081, 0x11d0, 0x99, 0xe0, 0x0, 0xc0, 0x4f, 0xc2, 0xf8, 0xec);

// {35B78F79-B973-48c8-A045-CAEC732A35D5}
DEFINE_GUID(CLSID_WMIHiPerfProvider,0x35b78f79, 0xb973, 0x48c8, 0xa0, 0x45, 0xca, 0xec, 0x73, 0x2a, 0x35, 0xd5);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\wdmperf.h ===
//////////////////////////////////////////////////////////////////////////////////////////////

//

//	WDMPerf.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////

#ifndef __WBEM_WMI_HIPERF_PROVIDER__H_
#define __WBEM_WMI_HIPERF_PROVIDER__H_

class CWMI_Prov;
//////////////////////////////////////////////////////////////
//
//	Constants and globals
//	
//////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	CRefresher
//
//	The refresher maintains an object and an enumerator cache. When an enumerator is added to the refrehser
//  it is added to the enumerator cache, and the index of the array is passed back as a unique ID.  
//  The refresher creates a cache of all instances during its initialization.  When an object 
//	is added to the refresher, a mapping to the object is created between the unique ID and the index of 
//  the object in the cache.  This allows the objects to be reused and facilitates the management of objects 
//  that have been added multiple times.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

class CRefresher : public IWbemRefresher
{
    private:
	    //===================================================
        // COM reference counter & other stuff...
	    //===================================================
        long                m_lRef;

	    //===================================================
        // The list of instances for this refresher, which
        // are clones of the provider's master list
	    //===================================================
        CHiPerfHandleMap    m_HiPerfHandleMap;
	    //===================================================
	    // The parent provider
	    //===================================================
	    CWMI_Prov*   m_pProvider;

    public:

	    CRefresher(CWMI_Prov* pProvider);
	    virtual ~CRefresher();

        CHiPerfHandleMap * HiPerfHandleMap() { return &m_HiPerfHandleMap;}
	    //===================================================
	    // COM methods
	    //===================================================

	    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
	    STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

	    STDMETHODIMP Refresh(/* [in] */ long lFlags);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\wdmperf.cpp ===
////////////////////////////////////////////////////////////////////////////////////////

//

//	WDMPerf.cpp

//

//	Module:	WMI WDM high performance provider

//

//	This file includes the provider and refresher code.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#if defined(_AMD64_) || defined(_IA64_)
ULONG Hash ( const LONG a_Arg ) {return a_Arg;}
#include <Allocator.cpp>
#endif

////////////////////////////////////////////////////////////////////////////////////////
//
//	CRefresher
//
////////////////////////////////////////////////////////////////////////////////////////
CRefresher::CRefresher(CWMI_Prov* pProvider) 
{
    m_lRef = 0;
	// ===========================================================
	// Retain a copy of the provider
	// ===========================================================
	m_pProvider = pProvider;
	if (m_pProvider)
    {
		m_pProvider->AddRef();
    }
	// ===========================================================
	// Increment the global COM object counter
	// ===========================================================

	InterlockedIncrement(&g_cObj);
}
////////////////////////////////////////////////////////////////////////////////////////

CRefresher::~CRefresher()
{
    
    // ===========================================================
	// Release the provider
	// ===========================================================
    if (m_pProvider){
		m_pProvider->Release();
    }

	// ===========================================================
	// Decrement the global COM object counter
	// ===========================================================

	InterlockedDecrement(&g_cObj);
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	Standard COM mterface
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CRefresher::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    if (riid == IID_IUnknown)
    {
        *ppv = (LPVOID)(IUnknown*)this;
    }
	else if (riid == IID_IWbemRefresher)
    {
		*ppv = (LPVOID)(IWbemRefresher*)this;
    }

    if( *ppv )
    {
   	    AddRef();
        hr = S_OK;
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//	Standard COM AddRef
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CRefresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}
////////////////////////////////////////////////////////////////////////////////////////
//
//	Standard COM Release
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CRefresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        delete this;
    }
    return lRef;
}

////////////////////////////////////////////////////////////////////////////////////////
//**************************************************************************************
//
//  Externally called
//
//**************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
//
//  Executed to refresh a set of instances bound to the particular refresher.
//
//	In most situations the instance data, such as counter values and 
//	the set of current instances within any existing enumerators, would 
//	be updated whenever Refresh was called.  
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CRefresher::Refresh(/* [in] */ long lFlags)
{
	HRESULT	hr = WBEM_NO_ERROR;
	IWbemObjectAccess* pObj = NULL;
    SetStructuredExceptionHandler seh;
    CWMIHiPerfShell WMI(TRUE);
 
	try
    {	
	    // ================================================================
	    // Updates all instances that have been added to the refresher, and
        // updates their counter values
	    // ================================================================
        hr = WMI.Initialize(TRUE,WMIGUID_QUERY,m_pProvider->HandleMapPtr(),NULL,m_pProvider->ServicesPtr(),NULL,NULL);
        if( SUCCEEDED(hr))
        {
            WMI.SetHiPerfHandleMap(&m_HiPerfHandleMap);
            hr = WMI.RefreshCompleteList();
        }
	}
    STANDARD_CATCH

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called whenever a complete, fresh list of instances for a given class is required.   
//
//  The objects are constructed and sent back to the caller through the sink.  
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		wszClass		- The class name for which instances are required.
//		lFlags			- Reserved.
//		pCtx			- The user-supplied context (not used here).
//		pSink			- The sink to which to deliver the objects.  The objects
//							can be delivered synchronously through the duration
//							of this call or asynchronously (assuming we
//							had a separate thread).  A IWbemObjectSink::SetStatus
//							call is required at the end of the sequence.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::QueryInstances(  IWbemServices __RPC_FAR *pNamespace,
                                                WCHAR __RPC_FAR *wcsClass, long lFlags,
                                                IWbemContext __RPC_FAR *pCtx, IWbemObjectSink __RPC_FAR *pHandler )
{
    //  Since we have implemented a IWbemServices interface, this code lives in CreateInstanceEnum instead
   	return E_NOTIMPL;
}    
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  Not used.
//		lFlags			- Reserved.
//		ppRefresher		- Receives the requested refresher.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::CreateRefresher( IWbemServices __RPC_FAR *pNamespace, long lFlags,
                                         IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher )
{
   	HRESULT hr = WBEM_E_FAILED;
    CWMIHiPerfShell WMI(TRUE);
    SetStructuredExceptionHandler seh;
    if (pNamespace == 0 || ppRefresher == 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
   	// =========================================================
    // Construct and initialize a new empty refresher
   	// =========================================================
    try
    {
        hr = WMI.Initialize(TRUE,WMIGUID_QUERY,&m_HandleMap,NULL,pNamespace,NULL,NULL);
        if( SUCCEEDED(hr))
        {
	        CRefresher* pNewRefresher = new CRefresher(this);

            if( pNewRefresher )
            {
   	            // =========================================================
                // Follow COM rules and AddRef() the thing before sending it 
                // back
   	            // =========================================================
                pNewRefresher->AddRef();
                *ppRefresher = pNewRefresher;
                hr = WBEM_NO_ERROR;
            }
        }
    }
    STANDARD_CATCH

    return hr;
   
}

////////////////////////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to include an object in a refresher.
//
//	Note that the object returned in ppRefreshable is a clone of the 
//	actual instance maintained by the provider.  If refreshers shared
//	a copy of the same instance, then a refresh call on one of the 
//	refreshers would impact the state of both refreshers.  This would 
//	break the refresher rules.	Instances in a refresher are only 
//	allowed to be updated when 'Refresh' is called.
//     
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace in WINMGMT.
//		pTemplate		- A pointer to a copy of the object which is to be
//							added.  This object itself cannot be used, as
//							it not owned locally.        
//		pRefresher		- The refresher to which to add the object.
//		lFlags			- Not used.
//		pContext		- Not used here.
//		ppRefreshable	- A pointer to the internal object which was added
//							to the refresher.
//		plId			- The Object Id (for identification during removal).        
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::CreateRefreshableObject( IWbemServices __RPC_FAR *pNamespace,
                                                 IWbemObjectAccess __RPC_FAR *pAccess,
                                                 IWbemRefresher __RPC_FAR *pRefresher,
                                                 long lFlags,
                                                 IWbemContext __RPC_FAR *pCtx,
                                                 IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
                                                 long __RPC_FAR *plId )
{
   	HRESULT hr = WBEM_E_FAILED;
    CWMIHiPerfShell WMI(FALSE);
    SetStructuredExceptionHandler seh;

    if (pNamespace == 0 || pAccess == 0 || pRefresher == 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
	// =========================================================
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
	// =========================================================
    try
    { 
#if defined(_AMD64_) || defined(_IA64_)
		if (m_HashTable == NULL)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
#endif
		{
			hr = WMI.Initialize(TRUE,WMIGUID_QUERY,&m_HandleMap,NULL,pNamespace,NULL,pCtx);
    
			if( SUCCEEDED(hr))
			{
				CRefresher *pOurRefresher = (CRefresher *) pRefresher;

				if( pOurRefresher )
				{
    				// =================================================
    				// Add the object to the refresher. The ID is set by 
					// AddObject
					// =================================================
					WMI.SetHiPerfHandleMap(pOurRefresher->HiPerfHandleMap());
					ULONG_PTR realId = 0;
					hr = WMI.AddAccessObjectToRefresher(pAccess,ppRefreshable, &realId);
#if defined(_AMD64_) || defined(_IA64_)
					if (SUCCEEDED(hr))
					{
						CCritical_SectionWrapper csw(&m_CS);
						
						if (csw.IsLocked())
						{
							*plId = m_ID;
							m_ID++;

							if (e_StatusCode_Success != m_HashTable->Insert (*plId, realId))
							{
								hr = WBEM_E_FAILED;
							}
						}
						else
						{
							hr = WBEM_E_FAILED;
						}
					}
#else
					*plId = realId;
#endif
				}
			}
		}
    }
    STANDARD_CATCH
    return hr;
   
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called when an enumerator is being added to a refresher.  The 
//	enumerator will obtain a fresh set of instances of the specified 
//	class every time that refresh is called.
//     
//	wszClass must be examined to determine which class the enumerator 
//	is being assigned.
//
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		wszClass		- The class name for the requested enumerator.
//		pRefresher		- The refresher object for which we will add the enumerator
//		lFlags			- Reserved.
//		pContext		- Not used here.
//		pHiPerfEnum		- The enumerator to add to the refresher.
//		plId			- A provider specified ID for the enumerator.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::CreateRefreshableEnum( IWbemServices* pNamespace, 
                                               LPCWSTR wcsClass,
                                               IWbemRefresher* pRefresher,
	                                           long lFlags, IWbemContext* pCtx,
	                                           IWbemHiPerfEnum* pHiPerfEnum, long* plId )
{
   	HRESULT hr = WBEM_E_FAILED;
    SetStructuredExceptionHandler seh;

    if( !pHiPerfEnum || wcsClass == NULL || (wcslen(wcsClass) == 0))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	CWMIHiPerfShell WMI(FALSE);
    
	// ===========================================================
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
	// ===========================================================
    try
    {
#if defined(_AMD64_) || defined(_IA64_)
		if (m_HashTable == NULL)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else
#endif
		{
			hr = WMI.Initialize(TRUE,WMIGUID_QUERY,&m_HandleMap,(WCHAR*)wcsClass,pNamespace,NULL,pCtx);
			if( SUCCEEDED(hr))
			{
				ULONG_PTR realId = 0;
				CRefresher *pOurRefresher = (CRefresher *) pRefresher;

				if( pOurRefresher )
				{
    				// ===========================================================
					// Add the enumerator to the refresher  
					// ===========================================================
					WMI.SetHiPerfHandleMap(pOurRefresher->HiPerfHandleMap());
					hr = WMI.AddEnumeratorObjectToRefresher(pHiPerfEnum,&realId);
#if defined(_AMD64_) || defined(_IA64_)
					if (SUCCEEDED(hr))
					{
						CCritical_SectionWrapper csw(&m_CS);
						
						if (csw.IsLocked())
						{
							*plId = m_ID;
							m_ID++;

							if (e_StatusCode_Success != m_HashTable->Insert (*plId, realId))
							{
								hr = WBEM_E_FAILED;
							}
						}
						else
						{
							hr = WBEM_E_FAILED;
						}
					}
#else
					*plId = realId;
#endif
				}
				if(SUCCEEDED(hr))
				{
					if(FAILED(hr = WMI.RefreshCompleteList()))
					{
						// This function is called before as RemoveObjectFromHandleMap
						// deletes the member variables and resets the pointers
						WMI.RemoveObjectFromHandleMap(realId);
						*plId = 0;
					}
				}
				
			}
		}
    }
    STANDARD_CATCH

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//		pRefresher			- The refresher object from which we are to remove the 
//                            perf object.
//		lId					- The ID of the object.
//		lFlags				- Not used.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::StopRefreshing( IWbemRefresher __RPC_FAR *pInRefresher, long lId, long lFlags )
{
   	HRESULT hr = WBEM_S_NO_ERROR;
    CWMIHiPerfShell WMI(TRUE);
    SetStructuredExceptionHandler seh;

	// ===========================================================
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
	// ===========================================================
    try
    {
#if defined(_AMD64_) || defined(_IA64_)
		ULONG_PTR realId = 0;

		if (m_HashTable != NULL)
		{
			CCritical_SectionWrapper csw(&m_CS);
			
			if (csw.IsLocked())
			{
				if (e_StatusCode_Success != m_HashTable->Find (lId, realId))
				{
					hr = WBEM_E_FAILED;
				}
				else
				{
					m_HashTable->Delete (lId) ;
				}
			}
			else
			{
				hr = WBEM_E_FAILED;
			}
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
#else
		ULONG_PTR realId = lId;
#endif

		if (SUCCEEDED(hr))
		{
			hr = WMI.Initialize(TRUE,WMIGUID_QUERY,&m_HandleMap,NULL,m_pIWbemServices,NULL, NULL);
			if( SUCCEEDED(hr))
			{
				CRefresher *pRefresher = (CRefresher *) pInRefresher;
				WMI.SetHiPerfHandleMap(pRefresher->HiPerfHandleMap());

				if(FAILED(hr))
				{
					// This function is called before as RemoveObjectFromHandleMap
					// deletes the member variables and resets the pointers
				}
				else
				{
					hr = WMI.RemoveObjectFromHandleMap(realId);
				}
			}
		}
    }
    STANDARD_CATCH

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////
//
//  Called when a request is made to provide all instances currently being managed by 
//  the provider in the specified namespace.
//     
//  Parameters:
//		pNamespace		- A pointer to the relevant namespace.  
//		lNumObjects		- The number of instances being returned.
//		apObj			- The array of instances being returned.
//		lFlags			- Reserved.
//		pContext		- Not used here.
//
////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::GetObjects( IWbemServices* pNamespace, long lNumObjects,
	                                IWbemObjectAccess** apObj, long lFlags,
                                    IWbemContext* pCtx)
{
    //  Since we have implemented a IWbemServices interface, this code lives in CreateInstanceEnum instead
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\wmievent.cpp ===
/////////////////////////////////////////////////////////////////////////////////////

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include <aclapi.h>  
#include <groupsforuser.h>
#include <sql_1.h>
#include <flexq.h>
static CFlexArray   g_apRequests;   // Shared between all CWMIEvent instances to provide a master event list
extern CCriticalSection * g_pEventCs; 
extern CCriticalSection * g_pListCs; 

////////////////////////////////////////////////////////////////////////////////////////////////
class CFlexQueueEx : public CFlexQueue
{
	public:

		void ResetQueue() 
		{
			delete [] m_ppData;
			m_ppData = NULL;
			m_nSize = m_nHeadIndex = m_nTailIndex = 0;
		}

};

CFlexQueueEx Q;

////////////////////////////////////////////////////////////////////////////////////////////////
void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
	PWNODE_HEADER * pEventHeader = NULL;

	{
		CAutoBlock block (g_pListCs);
		// Create a queue
		pEventHeader = new PWNODE_HEADER;
		if( pEventHeader )
		{
		    *pEventHeader = WnodeHeader;
			Q.Enqueue(pEventHeader);
		}
	}

    while( TRUE )
    {
		//scope the use of the critsec...
		{
			CAutoBlock block( g_pListCs );
	
			if( Q.GetQueueSize() == 0 )
			{
				Q.ResetQueue();
				break;
			}

			pEventHeader = (PWNODE_HEADER *) Q.Dequeue();
			if (pEventHeader == 0)
				break;
		}
		CWMIEvent * p = (CWMIEvent* ) Context;
		p->WMIEventCallback(*pEventHeader);
    }

}
/////////////////////////////////////////////////////////////////////
void CWMIEvent::SetEventHandler(IWbemObjectSink __RPC_FAR * pHandler) 
{ 
    CAutoBlock Block(g_pEventCs);

	if( m_pEventHandler )
	{
		m_pEventHandler->Release();
	}

    m_pEventHandler = pHandler; 
	if( m_pEventHandler )
    {
		m_pEventHandler->AddRef(); 
	}
}
/////////////////////////////////////////////////////////////////////
void CWMIEvent::SetEventServices(IWbemServices __RPC_FAR * pServices) 
{ 
    CAutoBlock Block(g_pEventCs);

	if( m_pEventServices )
	{
		m_pEventServices->Release();
	}
    m_pEventServices = pServices; 
	if( m_pEventServices )
    {
		m_pEventServices->AddRef(); 
	}
}
/////////////////////////////////////////////////////////////////////
void CWMIEvent::SetEventContext(IWbemContext __RPC_FAR * pCtx) 
{ 
    CAutoBlock Block(g_pEventCs);

	if( m_pEventCtx )
	{
		m_pEventCtx->Release();
	}
    m_pEventCtx = pCtx; 
	if( m_pEventCtx )
    {
		m_pEventCtx->AddRef(); 
	}
}

////////////////////////////////////////////////////////////////////////
CWMIEvent::CWMIEvent(int nType)  
{
    m_nType = nType;
    m_lRef = 0;
    m_pEventHandler = NULL;
    m_pEventServices = NULL;
    m_pEventCtx = NULL;

    if( m_nType != INTERNAL_EVENT )
    {
        InterlockedIncrement(&g_cObj);
    }

    m_fReadyForInternalEvents = FALSE;

}
////////////////////////////////////////////////////////////////////////
CWMIEvent::~CWMIEvent()
{
    SAFE_RELEASE_PTR( m_pEventHandler );
    SAFE_RELEASE_PTR( m_pEventServices );
    SAFE_RELEASE_PTR( m_pEventCtx );

    if( m_nType != INTERNAL_EVENT )
    {
        InterlockedDecrement(&g_cObj);
    }
}

void CWMIEvent::ReleaseAllPointers()
{

    IWbemObjectSink    * pHandler	= NULL;
	IWbemServices      * pServices	= NULL;
	IWbemContext      * pCtx		= NULL;

	{
		CAutoBlock Block(g_pEventCs);
		pHandler	= m_pEventHandler;
		pServices	= m_pEventServices;
		pCtx		= m_pEventCtx;

		m_pEventCtx		= NULL;
		m_pEventServices	= NULL;
		m_pEventHandler	= NULL;
	}


    SAFE_RELEASE_PTR( pHandler );
    SAFE_RELEASE_PTR( pServices );
    SAFE_RELEASE_PTR( pCtx );
}

////////////////////////////////////////////////////////////////////////
HRESULT CWMIEvent::DeleteAllLeftOverEvents()
{
    HRESULT hr = WBEM_E_FAILED;

	RevertToSelf();

    CWMIStandardShell WMI;

	if( SUCCEEDED(WMI.Initialize(NULL,FALSE,&m_HandleMap,TRUE,WMIGUID_NOTIFICATION|WMIGUID_QUERY,m_pEventServices,m_pEventHandler,m_pEventCtx)))
	{

        CAutoBlock Block(g_pEventCs);
            // =====================================================
            // Remove all requests with this Id
            // =====================================================
            for( int i = 0; i  <  g_apRequests.Size(); i++ )
            {

                WMIEventRequest* pReq = (WMIEventRequest*) g_apRequests[i];
        
	            ULONG_PTR uRc =(ULONG_PTR)this;
                //===============================================
                //  Cancel the Event registration, if it fails...
                //  so what,we are leaving anyway, so delete all
                //===============================================
                WMI.CancelWMIEventRegistration(pReq->gGuid,uRc);
                delete pReq;
            }
            g_apRequests.Empty();
            hr = S_OK;
	}
    return hr;
}

////////////////////////////////////////////////////////////////////////
BOOL CWMIEvent::RegisterForInternalEvents( )
{
    BOOL fRc = FALSE;

    if( m_fReadyForInternalEvents )
    {

        if( SUCCEEDED(RegisterForRequestedEvent(BINARY_MOF_ID,RUNTIME_BINARY_MOFS_ADDED,MOF_ADDED)))
        {
            if( SUCCEEDED(RegisterForRequestedEvent(BINARY_MOF_ID,RUNTIME_BINARY_MOFS_DELETED,MOF_DELETED)))
            {
                fRc = TRUE;
            }
        }
    }
    return fRc;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIEvent::RemoveWMIEvent(DWORD dwId)
{
    HRESULT hr = S_OK;

    if( m_nType == WMIEVENT )
    {
        hr = CheckImpersonationLevelAndVerifyInternalEvents(FALSE);
    }
	else
    {
		RevertToSelf();
	}

    if( SUCCEEDED(hr))
    {
        CWMIStandardShell WMI;

		if( SUCCEEDED(WMI.Initialize(NULL,FALSE,&m_HandleMap,TRUE,WMIGUID_NOTIFICATION|WMIGUID_QUERY,m_pEventServices,m_pEventHandler,m_pEventCtx)))
		{
			CAutoBlock Block(g_pEventCs);

				// ================================
				// Remove all requests with this Id
				// ================================
				int nSize =  g_apRequests.Size();
				int i = 0;

				while( i  < nSize )
				{
					WMIEventRequest* pReq = (WMIEventRequest*) g_apRequests[i];
					if(pReq->dwId == dwId)
					{
						// Inform WMI we don't want this anymore as 
						// long as there are no more these guids in 
						// the list, there might be more than one
						// event consumer registered.
						// =========================================
						if( NoMoreEventConsumersRegistered( pReq->gGuid ) == 1)
						{
							ULONG_PTR uRc =(ULONG_PTR)this;
 							WMI.CancelWMIEventRegistration(pReq->gGuid,uRc);
						}
						g_apRequests.RemoveAt(i);
						delete pReq;
						nSize =  g_apRequests.Size();
					}
					else
					{
						i++;
					}
				}
		}

    }

    CheckImpersonationLevelAndVerifyInternalEvents(FALSE);
    return WBEM_S_NO_ERROR;
}

////////////////////////////////////////////////////////////////////////
HRESULT CWMIEvent::DeleteBinaryMofResourceEvent()
{
    CAutoBlock Block(g_pEventCs);

        RevertToSelf();
  
 	    CWMIStandardShell WMI;
		if( SUCCEEDED(WMI.Initialize(NULL,FALSE,&m_HandleMap,TRUE,WMIGUID_NOTIFICATION|WMIGUID_QUERY,m_pEventServices,m_pEventHandler,m_pEventCtx)))
		{

			// Remove all requests with this Id
			// ================================
			int nSize = g_apRequests.Size();
			int i = 0;

			while( i < nSize ){

				WMIEventRequest* pReq = (WMIEventRequest*) g_apRequests[i];

				if( ( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,pReq->gGuid)) ||
					( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_REMOVED_GUID,pReq->gGuid))){

					ULONG_PTR uRc =(ULONG_PTR)this;
 					WMI.CancelWMIEventRegistration(pReq->gGuid,uRc);
					g_apRequests.RemoveAt(i);
					delete pReq;

					nSize = g_apRequests.Size();
				}
				else{
					i++;
				}
			}
			CheckImpersonationLevelAndVerifyInternalEvents(FALSE);
		}
    return WBEM_S_NO_ERROR;
}

////////////////////////////////////////////////////////////////////////
int CWMIEvent::NoMoreEventConsumersRegistered(GUID gGuid)
{
 CAutoBlock Block(g_pEventCs);

	int nTotalNumberOfRegisteredEventConsumers = 0;
	WMIEventRequest * pEvent;

    for(int i = 0; i < g_apRequests.Size(); i++)
	{
        pEvent = (WMIEventRequest *) g_apRequests.GetAt(i);
        if( pEvent->gGuid == gGuid)
		{
            nTotalNumberOfRegisteredEventConsumers++;
        }

    }
	return nTotalNumberOfRegisteredEventConsumers;

}
////////////////////////////////////////////////////////////////////////
BOOL CWMIEvent::IsGuidInListIfSoGetCorrectContext(GUID gGuid, WMIEventRequest *& pEvent )
{
 CAutoBlock Block(g_pEventCs);

    for( int i = 0; i < g_apRequests.Size(); i++ )
	{
     
        pEvent = (WMIEventRequest *) g_apRequests.GetAt(i);
        if( pEvent->gGuid == gGuid){
            return TRUE;
        }
    }
	pEvent = NULL;
    return FALSE;
}
////////////////////////////////////////////////////////////////////////
BOOL CWMIEvent::IsGuidInList(WCHAR * wcsGuid, WMIEventRequest *& pEvent)
{
 CAutoBlock Block(g_pEventCs);
  
	BOOL fRc = FALSE;

    int Size = g_apRequests.Size();

    for(int i =0 ; i < Size; i++ ){

        pEvent = (WMIEventRequest *) g_apRequests.GetAt(i);

		if( (_wcsicmp(pEvent->wcsGuid,wcsGuid)) == 0 ){
            fRc = TRUE;
            break;
        }
    }
    
    return fRc;

}

////////////////////////////////////////////////////////////////////////
HRESULT CWMIEvent::RegisterForRequestedEvent( DWORD dwId,  WCHAR * wcsClass, WORD wType)
{
    BOOL fRegistered = FALSE;
    CWMIStandardShell WMI;
    HRESULT hr = WBEM_E_ACCESS_DENIED;
	BOOL fInternalEvent = TRUE;
	if( wType == STANDARD_EVENT	)
	{
		fInternalEvent = FALSE;
	}

	if( SUCCEEDED(WMI.Initialize(wcsClass, fInternalEvent, &m_HandleMap,TRUE,WMIGUID_NOTIFICATION|WMIGUID_QUERY,m_pEventServices,m_pEventHandler,m_pEventCtx)))
	{

		if( m_nType == WMIEVENT ){
			hr = CheckImpersonationLevelAndVerifyInternalEvents(FALSE);
		}
		else
		{
			RevertToSelf();
			hr = S_OK;
		}

		if( SUCCEEDED(hr) )
		{
			WCHAR wcsGuid[128];
        
			hr = WMI.SetGuidForEvent( wType,wcsGuid );
			if( SUCCEEDED(hr)){

				WMIEventRequest * pAlreadyRegisteredEvent;

				//===========================================================
				//  Keep a record of this guy, see if it is already registered
				//  if it is/isn't we call WDM with different flags
				//===========================================================
				fRegistered = IsGuidInList( wcsGuid, pAlreadyRegisteredEvent );
				
				//===========================================================
				//  Register for the requested event
				//===========================================================
				ULONG_PTR uRc =(ULONG_PTR)this;
 
				CLSID Guid;
				hr = WMI.RegisterWMIEvent(wcsGuid,uRc,Guid,fRegistered);
				if( SUCCEEDED(hr) &&  !fRegistered)
				{
					//=======================================================
					//  If we succeeded, then add it to our list of events we
					//  are watching
					//=======================================================
					WMIEventRequest * pEvent = new WMIEventRequest;
					pEvent->gGuid = Guid;
					pEvent->dwId = dwId;
					pEvent->fHardCoded = wType;
					wcscpy( pEvent->wcsGuid,wcsGuid);
            		pEvent->SetClassName(wcsClass);
					pEvent->AddPtrs(m_pEventHandler,m_pEventServices,m_pEventCtx);

					g_apRequests.Add(pEvent);
				}
			}
		}
		CheckImpersonationLevelAndVerifyInternalEvents(FALSE);
	}
    return hr;
}

////////////////////////////////////////////////////////////////////////
CWMIEventProvider::CWMIEventProvider(int nType) : CWMIEvent(nType)
{
    m_hResyncEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	ERRORTRACE((THISPROVIDER,"Event Provider constructed\n"));

}
////////////////////////////////////////////////////////////////////////
CWMIEventProvider::~CWMIEventProvider()
{
	ERRORTRACE((THISPROVIDER,"Event Provider denstructed\n"));

}

////////////////////////////////////////////////////////////////////////

STDMETHODIMP CWMIEventProvider::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

	if(riid == IID_IUnknown)
	{
        *ppv = this;
	}
	else
    if(riid == IID_IWbemEventProvider)
    {
        *ppv = (IWbemEventProvider*)this;
    }
    else if(riid == IID_IWbemEventProviderQuerySink)
    {
        *ppv = (IWbemEventProviderQuerySink*)this;
    }
    else if (IsEqualIID(riid, IID_IWbemProviderInit)) 
    {
        *ppv = (IWbemProviderInit *) this ;
    }
    else if (IsEqualIID(riid, IID_IWbemEventProviderSecurity)) 
    {
        *ppv = (IWbemEventProviderSecurity *) this ;
    }

    if( *ppv)
    {
        AddRef();
        hr = S_OK;
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE CWMIEventProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}
////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE CWMIEventProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);

    if(lRef == 0){
	    //**********************************************
		// reference count is zero, delete this object.
	    // and do all of the cleanup for this user,
		//**********************************************
    	delete this ;
    }
    return lRef;
}
/////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMIEventProvider::Initialize(LPWSTR wszUser, long lFlags, 
                                LPWSTR wszNamespace,
                                LPWSTR wszLocale, 
                                IWbemServices* pNamespace, 
                                IWbemContext* pCtx,
                                IWbemProviderInitSink* pSink)
{
    IWbemClassObject * pWMIClass = NULL;

    HRESULT hres = pNamespace->GetObject(WMI_EVENT_CLASS, 0, NULL, &pWMIClass, NULL);

    CAutoBlock Block(g_pEventCs);

    	// ptr initialization routines
	    SetEventServices(pNamespace);
	    SetEventContext(pCtx);

    pSink->SetStatus(hres, 0);
	SAFE_RELEASE_PTR(pWMIClass);
    return hres;
}

////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMIEventProvider::ProvideEvents(IWbemObjectSink __RPC_FAR *pSink,long lFlags)
{
    CAutoBlock Block(g_pEventCs);
	SetEventHandler(pSink);

    // ===============================================================================
    // Make sure any request added before this was called gets the updated handler
    // PROVIDING it isn't the binary mof guid
    // ===============================================================================
    for(int i = 0; i < g_apRequests.Size(); i++)
	{
        WMIEventRequest* pReq = (WMIEventRequest*) g_apRequests[i];
        if(!pReq->pHandler)
		{
            if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,pReq->gGuid))
			{
            }
            else
			{
				if( !pReq->pHandler )
				{
					pReq->pHandler = pSink;
				}
            }

        }
    }

    return S_OK;
}
////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMIEventProvider::NewQuery( DWORD dwId, WBEM_WSTR wszLanguage, WBEM_WSTR wszQuery)
{
   HRESULT hRes = WBEM_S_NO_ERROR;

   if (_wcsicmp(wszLanguage, L"WQL") != 0) 
   {
      hRes = WBEM_E_INVALID_QUERY_TYPE;
   }
   if( hRes == WBEM_S_NO_ERROR )
   {
		// Parse the query
		// Construct the lex source
		// ========================
	    CTextLexSource Source(wszQuery);
		// Use the lex source to set up for parser
		// =======================================
		SQL1_Parser QueryParser(&Source);

		SQL_LEVEL_1_RPN_EXPRESSION * pParse;
		int ParseRetValue = QueryParser.Parse(&pParse);
		if( SQL1_Parser::SUCCESS != ParseRetValue) {
			hRes = WBEM_E_INVALID_QUERY;
		}
		else{
		    //Set the class
			if( pParse ){
				hRes = RegisterForRequestedEvent(dwId,pParse->bsClassName,STANDARD_EVENT);
				delete pParse;
			}
		}
	}
	
    return hRes;
}
////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMIEventProvider::CancelQuery(DWORD dwId)
{
    return RemoveWMIEvent(dwId);
}
////////////////////////////////////////////////////////////////////////

STDMETHODIMP CWMIEventProvider::AccessCheck(WBEM_CWSTR wszLanguage,   
											WBEM_CWSTR wszQuery, 
											long lSidLength,
											const BYTE* aSid)
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;

	//=======================================================
	//  Check platform
	//=======================================================
    if(!IsNT())
        return WBEM_S_FALSE;

	//=======================================================
	//  Check query language
	//=======================================================
	if (_wcsicmp(wszLanguage, L"WQL") != 0) {
		return WBEM_E_INVALID_QUERY_TYPE;
	}

	//=======================================================
	//  If the PSid is NULL, then check impersonation level
	//  as usual - based on the thread
	//=======================================================

    PSID pSid = (PSID)aSid;
    HANDLE hToken = NULL;
    if(pSid == NULL){
	    //=================================================
	    //  if this is the INTERNAL_EVENT class, then we
		//  do not want the local events set up again.
		//=================================================
        BOOL VerifyLocalEventsAreSetup = TRUE;

		if( m_nType == INTERNAL_EVENT ){
			VerifyLocalEventsAreSetup = FALSE;
		}

	    hr = CheckImpersonationLevelAndVerifyInternalEvents(VerifyLocalEventsAreSetup);
    }
	else{
 		//=======================================================
		// Parse the query
		//=======================================================
		CTextLexSource Source(wszQuery);

		//=======================================================
		// Use the lex source to set up for parser
		//=======================================================
		SQL1_Parser QueryParser(&Source);

		SQL_LEVEL_1_RPN_EXPRESSION * pParse;

		int ParseRetValue = QueryParser.Parse(&pParse);
		if( SQL1_Parser::SUCCESS != ParseRetValue) {
			return WBEM_E_INVALID_QUERY;
		}
		else{
			if( pParse ){

				CWMIStandardShell WMI;
				if( SUCCEEDED(WMI.Initialize(pParse->bsClassName,FALSE,&m_HandleMap,TRUE,WMIGUID_NOTIFICATION|WMIGUID_QUERY,m_pEventServices,m_pEventHandler,m_pEventCtx)))
				{
    				CLSID * pGuid;

					pGuid = WMI.GuidPtr();
             		if(pGuid != NULL)
					{  
						//========================================
						// Get the ACL
						//========================================
						PACL pDacl;
						PSECURITY_DESCRIPTOR psd = NULL;
						SE_OBJECT_TYPE ObjectType = SE_WMIGUID_OBJECT;
                    
						hr = WBEM_E_ACCESS_DENIED;

						WCHAR * GuidName = NULL;

						hr = UuidToString(pGuid, &GuidName);
						if (hr == RPC_S_OK)
						{
							hr = S_OK;
							DWORD dwRc = GetNamedSecurityInfo(GuidName,ObjectType,DACL_SECURITY_INFORMATION,NULL,NULL,&pDacl, NULL, &psd );
							if( dwRc != ERROR_SUCCESS )
							{
								ERRORTRACE((THISPROVIDER, "GetNamedSecurityInfo returned %ld.\n", dwRc ));
								hr = WBEM_E_ACCESS_DENIED;
							}
						}
						if( GuidName )
						{
							RpcStringFree(&GuidName);
						}
            			if(SUCCEEDED(hr))
						{
							//====================================
							// This is our own ACL walker
							//====================================
     
							DWORD dwAccessMask;
							NTSTATUS st = GetAccessMask((PSID)pSid, pDacl, &dwAccessMask);
							if(st)
							{
								ERRORTRACE((THISPROVIDER, "WDM event provider unable "
											"to retrieve access mask for the creator of "
											"registration %S: NT status %d.\n"
											"Registration disabled\n", wszQuery,st));
								return WBEM_E_FAILED;
							}

    						if((dwAccessMask & WMIGUID_QUERY) == 0)
							{
	    						hr = WBEM_E_ACCESS_DENIED;
		    				}
			    			else
							{
				    			hr = S_OK;
								m_nType = PERMANENT_EVENT;
							}
						}
						if( psd != NULL)
						{
							AccFree( psd );
						}
					}
					delete pParse;
				}
			}
						
		}
	}
    return hr;
}
////////////////////////////////////////////////////////////////////////
void CWMIEvent::WMIEventCallback(PWNODE_HEADER WnodeHeader)
{
        LPGUID EventGuid = &WnodeHeader->Guid;	    

		ERRORTRACE((THISPROVIDER,"Received Event\n"));
	    //=======================================================
	    //  We only support WNODE_FLAG_ALL_DATA and 
	    //  WNODE_FLAG_SINGLE_INSTANCE
	    //
	    //  Parse thru whatever it is and send it off to HMOM
	    //=======================================================
	    if( WnodeHeader )
		{
            HRESULT hr;
	        WMIEventRequest * pEvent;
            //===========================================================
            //  Make sure it is an event we want
            //===========================================================
			if( IsGuidInListIfSoGetCorrectContext( *EventGuid,pEvent))
			{

        		CWMIStandardShell WMI;
				//=======================================================
				//  See if a binary mof event is being added or deleted
				//=======================================================
				WORD wBinaryMofType = 0;
				BOOL fInternalEvent = FALSE;
				if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,WnodeHeader->Guid))
				{
					fInternalEvent = TRUE;
					wBinaryMofType = MOF_ADDED;
				}
				else if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_REMOVED_GUID,WnodeHeader->Guid))
				{
					fInternalEvent = TRUE;
					wBinaryMofType = MOF_DELETED;
				}
				if( SUCCEEDED(WMI.Initialize(pEvent->pwcsClass,fInternalEvent,&m_HandleMap,TRUE,WMIGUID_QUERY|WMIGUID_NOTIFICATION,pEvent->pServices,pEvent->pHandler,pEvent->pCtx)))
				{
					//=======================================================
					//  If it was, then process it, otherwise go on... :)
					//=======================================================
					WMI.ProcessEvent(wBinaryMofType,WnodeHeader);

				}
			}
	    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\wmievent.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef __WBEM_WMI_EVENT_PROVIDER__H_
#define __WBEM_WMI_EVENT_PROVIDER__H_

#define WMIEVENT 1

#define WMI_EVENT_CLASS L"WMIEvent"
#define BINARY_MOF_ID   0

/////////////////////////////////////////////////////////////////////////////////////////////

class CWMIEvent 
{
    protected:
        long m_lRef;
    	IWbemObjectSink __RPC_FAR   * m_pEventHandler;
	    IWbemServices __RPC_FAR     * m_pEventServices;
	    IWbemContext __RPC_FAR      * m_pEventCtx;
        CHandleMap                  m_HandleMap;
        int                         m_nType;
        BOOL                        m_fReadyForInternalEvents;
 
    public:

        CWMIEvent(int nType);
        ~CWMIEvent();
		
		void ReleaseAllPointers();

        inline void ReadyForInternalEvents(BOOL fFlag ) { m_fReadyForInternalEvents = fFlag; }

        BOOL IsGuidInListIfSoGetCorrectContext(GUID gGuid, WMIEventRequest *& pEvent );
        BOOL IsGuidInList(WCHAR *Guids, WMIEventRequest *& pEvent);
        BOOL RegisterForInternalEvents( );

        HRESULT RegisterForRequestedEvent(DWORD dwId, WCHAR * wcsClasss, WORD wType);
        HRESULT RemoveWMIEvent(DWORD dwId);
		HRESULT DeleteBinaryMofResourceEvent();
        HRESULT DeleteAllLeftOverEvents();

        int NoMoreEventConsumersRegistered(GUID gGuid);

        void WMIEventCallback(PWNODE_HEADER WnodeHeader);
        void SetEventHandler(IWbemObjectSink __RPC_FAR * pHandler);
        void SetEventServices(IWbemServices __RPC_FAR * pServices);
        void SetEventContext(IWbemContext __RPC_FAR * pCtx);

        inline IWbemServices  __RPC_FAR * GetServices()	{return m_pEventServices;}
        inline IWbemContext __RPC_FAR * GetContext()	{return m_pEventCtx;}
};

class CWMIEventProvider : public CWMIEvent, public IWbemEventProvider,  public IWbemEventProviderQuerySink, public IWbemProviderInit, public IWbemEventProviderSecurity
{
    private:
        HANDLE  m_hResyncEvent;
        
    public:
        STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        STDMETHOD(NewQuery)(DWORD dwId, WBEM_WSTR wszLanguage, WBEM_WSTR wszQuery);
        STDMETHOD(CancelQuery)(DWORD dwId);
        STDMETHOD(ProvideEvents)( IWbemObjectSink __RPC_FAR *pSink,long lFlags);
		STDMETHOD (Initialize)(LPWSTR wszUser, long lFlags, 
								LPWSTR wszNamespace,
								LPWSTR wszLocale, IWbemServices* pNamespace, IWbemContext* pCtx,
								IWbemProviderInitSink* pSink);

        STDMETHOD(AccessCheck)(WBEM_CWSTR wszLanguage, WBEM_CWSTR wszQuery, long lSidLength, const BYTE* aSid);

        CWMIEventProvider(int nType);
        ~CWMIEventProvider() ;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\wmiprov.h ===
////////////////////////////////////////////////////////////////////

//

//  WMIProv.h

//

//  Purpose: Include file for the WMI_Provider

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//	history:
//		05/16/97	jennymc		updated
//
////////////////////////////////////////////////////////////////////

#ifndef _WMIPROV_H_
#define _WMIPROV_H_

class CRefresher;
class CRefCacheElement;
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Provider interfaces are provided by objects of this class
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

class CCritical_SectionWrapper
{
private:

	CRITICAL_SECTION *m_cs;

public:
	
	CCritical_SectionWrapper( CRITICAL_SECTION * cs): m_cs (NULL)
	{
		if (cs)
		{
			try
			{
				EnterCriticalSection(cs);
				m_cs = cs;
			}
			catch(...)
			{
			}
		}
	}

	~CCritical_SectionWrapper()
	{
		if (m_cs)
		{
			try
			{
				LeaveCriticalSection(m_cs);
			}
			catch(...)
			{
			}
		}
	}

	BOOL IsLocked () { return (m_cs != NULL); }
};
 
class CWMI_Prov : public IWbemServices, public IWbemProviderInit,public IWbemHiPerfProvider
{

	protected:
        long                    m_cRef;
        IWbemServices         * m_pIWbemServices;
        CHandleMap              m_HandleMap;
        CHiPerfHandleMap        m_HiPerfHandleMap;

#if defined(_AMD64_) || defined(_IA64_)
		CRITICAL_SECTION m_CS;
		WmiAllocator *m_Allocator ;
		WmiHashTable <LONG, ULONG_PTR, 17> *m_HashTable; 
		LONG m_ID;
#endif

    public:

        inline CHiPerfHandleMap      * HandleMapPtr()        { return &m_HiPerfHandleMap; }
        inline IWbemServices         * ServicesPtr()         { return m_pIWbemServices;}
		enum{
			SUCCESS = 0,
			FAILURE = 1,
			NO_DATA_AVAILABLE = 2,
			DATA_AVAILABLE
		};


        CWMI_Prov();
        ~CWMI_Prov(void);

		//=======================================================
        // Non-delegating object IUnknown
		//=======================================================

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		//=======================================================
        //IWbemServices supported interfaces
		//=======================================================
        STDMETHOD(OpenNamespace) (
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
		STDMETHOD(Initialize)( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);
			
        STDMETHOD(GetObjectAsync)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        STDMETHOD(CreateInstanceEnumAsync)(
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        STDMETHOD(PutInstanceAsync)(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

		//========================================================
        //	IWbemServices unsupported interfaces
		//========================================================
        STDMETHOD(GetTypeInfoCount)	(THIS_ UINT * pctinfo) 
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(GetTypeInfo)		(THIS_ UINT itinfo, LCID lcid, ITypeInfo * * pptinfo) 
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(GetIDsOfNames)	(THIS_  REFIID riid, OLECHAR * * rgszNames, UINT cNames,LCID lcid, DISPID * rgdispid) 
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(Invoke)			(THIS_   DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,   UINT * puArgErr) 
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(CreateInstanceEnum)( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(GetObject)(            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(PutClassAsync)(            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(CreateClassEnum)(/* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
			{ return E_NOTIMPL;}

        STDMETHOD(CreateClassEnumAsync)( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return E_NOTIMPL;}

        STDMETHOD(PutInstance)	 (
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(DeleteInstance)( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(DeleteInstanceAsync)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecQuery)(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecQueryAsync)(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

        STDMETHOD(CancelAsyncRequest)(THIS_ long lAsyncRequestHandle)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(CancelAsyncCall)(THIS_ IWbemObjectSink __RPC_FAR *pSink)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(QueryObjectSink)(THIS_ /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(PutClass)(    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(DeleteClass)(            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(DeleteClassAsync)(    /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecNotificationQuery)(
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
            			{ return WBEM_E_NOT_SUPPORTED;}


        STDMETHOD(ExecMethod)(
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
            			{ return WBEM_E_NOT_SUPPORTED;}

        STDMETHOD(ExecMethodAsync)(    /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


        //==========================================================
	    // IWbemHiPerfProvider COM interfaces
        //==========================================================

	    STDMETHOD(QueryInstances)( IWbemServices __RPC_FAR *pNamespace, WCHAR __RPC_FAR *wszClass,
		                             long lFlags, IWbemContext __RPC_FAR *pCtx, IWbemObjectSink __RPC_FAR *pSink );
    
	    STDMETHOD(CreateRefresher)( IWbemServices __RPC_FAR *pNamespace, long lFlags, IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher );
    
	    STDMETHOD(CreateRefreshableObject)( IWbemServices __RPC_FAR *pNamespace, IWbemObjectAccess __RPC_FAR *pTemplate,
		                                      IWbemRefresher __RPC_FAR *pRefresher, long lFlags,
		                                      IWbemContext __RPC_FAR *pContext, IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
		                                      long __RPC_FAR *plId );
    
	    STDMETHOD(StopRefreshing)( IWbemRefresher __RPC_FAR *pRefresher, long lId, long lFlags );

	    STDMETHOD(CreateRefreshableEnum)( IWbemServices* pNamespace, LPCWSTR wszClass, IWbemRefresher* pRefresher,
		                                    long lFlags, IWbemContext* pContext, IWbemHiPerfEnum* pHiPerfEnum, long* plId);

	    STDMETHOD(GetObjects)( IWbemServices* pNamespace, long lNumObjects, IWbemObjectAccess** apObj,
                                 long lFlags, IWbemContext* pContext);

};


class CWMIHiPerfProvider : public CWMI_Prov
{
		STDMETHOD(Initialize)( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\joprocess.cpp ===
/******************************************************************

Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 

   JOProcess.CPP -- WMI provider class implementation
  
******************************************************************/

#include "precomp.h"
#if NTONLY >= 5


#include "JOProcess.h"

CJOProcess MyCJOProcess(
               PROVIDER_NAME_WIN32NAMEDJOBOBJECTPROCESS, 
               IDS_CimWin32Namespace);


CJOProcess::CJOProcess( 
    LPCWSTR setName, 
    LPCWSTR pszNameSpace /*=NULL*/)
:	Provider(setName, pszNameSpace)
{
}


CJOProcess::~CJOProcess()
{
}


HRESULT CJOProcess::GetObject( 
    CInstance* pInstance, 
    long lFlags /*= 0L*/ )
{
    return FindSingleInstance(pInstance);
}


HRESULT CJOProcess::EnumerateInstances(
    MethodContext* pMethodContext, 
    long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    hr = Enumerate(pMethodContext);

    return hr;
}


// We will only optimize for the
// case where a specific job was
// specified.
HRESULT CJOProcess::ExecQuery(
    MethodContext *pMethodContext, 
    CFrameworkQuery& Query, 
    long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    std::vector<_bstr_t> rgJOs;
    DWORD dwJOsCount = 0L;
    Query.GetValuesForProp(L"Collection", rgJOs);
    dwJOsCount = rgJOs.size();

    if(dwJOsCount > 0)
    {
        CInstancePtr pInstJO;
        CHString chstrPath;

        for(DWORD x = 0; x < dwJOsCount; x++)
        {
            // First we see if the specified JO exists.
            chstrPath.Format(
                L"\\\\.\\%s:%s", 
                IDS_CimWin32Namespace, 
                (LPCWSTR)rgJOs[x]);

            hr = CWbemProviderGlue::GetInstanceKeysByPath(
                     chstrPath, 
                     &pInstJO, 
                     pMethodContext);

            if (SUCCEEDED(hr))
            {
                // Ok, the JO exists.  Enumerate its processes...
                // rgJOs[x] contains something like
                // Win32_NamedJobObject.CollectionID="myjob", 
                // from which I want just the myjob part.
                CHString chstrInstKey;
                if(GetInstKey(
                       CHString((LPCWSTR)rgJOs[x]),
                       chstrInstKey))
                {
                    hr = EnumerateProcsInJob(
                             chstrInstKey, 
                             pMethodContext);

                    if (FAILED(hr))
                    {
                        break;
                    }
                }
                else
                {
                    return WBEM_E_INVALID_PARAMETER;
                }
            }
        }
    }

    else
    {
       hr = Enumerate(pMethodContext);
    }

    return hr;
}




HRESULT CJOProcess::PutInstance(
    const CInstance &Instance, 
    long lFlags)
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    MethodContext *pMethodContext = Instance.GetMethodContext();
	long lCreateFlags = lFlags & 3;

    // Decide how to proceed based on the value of lFlags:
    // (we want to support PutInstance in all cases except
    // where the client asked to update the instance).
    if(lCreateFlags != WBEM_FLAG_UPDATE_ONLY)
    {
        // The caller only wants to create an instance that doesn't exist.
        if((hr = FindSingleInstance(
                &Instance)) == WBEM_E_NOT_FOUND)
        {
            // The association instance does not already exist, so create it...
            // First see that the job object instance exists...
            CHString chstrJOPath;
            Instance.GetCHString(L"Collection", chstrJOPath);
            CInstancePtr pJOInst;

            hr = CWbemProviderGlue::GetInstanceKeysByPath(
                     chstrJOPath, 
                     &pJOInst, 
                     pMethodContext);

            if (SUCCEEDED(hr))
            {
                // Confirm that the process exists...
                CHString chstrProcPath;
                Instance.GetCHString(L"Member", chstrProcPath);
                CInstancePtr pProcInst;

                hr = CWbemProviderGlue::GetInstanceKeysByPath(
                         chstrProcPath, 
                         &pProcInst, 
                         pMethodContext);
                
                if(SUCCEEDED(hr))
                {
                    hr = Create(pJOInst, pProcInst);
                }
            }
        }
    }
    
    return hr;
}





/*****************************************************************************
*
*  FUNCTION    :    CJOProcess::FindSingleInstance
*
*  DESCRIPTION :    Internal helper function used to locate a single job
*                   object.
*
*  INPUTS      :    A pointer to a CInstance containing the instance we are
*                   attempting to locate and fill values for.
*
*  RETURNS     :    A valid HRESULT 
*
*****************************************************************************/
HRESULT CJOProcess::FindSingleInstance(
    const CInstance* pInstance)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(!pInstance)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    MethodContext* pMethodContext = pInstance->GetMethodContext();
    CHString chstrCollection;
    CHString chstrMember;
    
    // Find out which JO and which process are specified...
    pInstance->GetCHString(L"Collection", chstrCollection);
    pInstance->GetCHString(L"Member", chstrMember);
    CHString chstrCollectionID;
    CHString chstrProcessHandle;
    CInstancePtr cinstJO;
    CInstancePtr cinstProcess;

    if(GetInstKey(chstrCollection, chstrCollectionID) &&
       GetInstKey(chstrMember, chstrProcessHandle))
    {
        // See if the specified job exists...            
        hr = CWbemProviderGlue::GetInstanceKeysByPath(
                 chstrCollection,
                 &cinstJO,
                 pMethodContext);

        if(SUCCEEDED(hr))
        {
            // See if the specified process exists...
            hr = CWbemProviderGlue::GetInstanceKeysByPath(
                     chstrMember,
                     &cinstProcess,
                     pMethodContext);
        }

        if(SUCCEEDED(hr))
        {
            // The endpoints exist.  Is the specified
            // process part of the specified job though?
            CHString chstrProcessID;
            DWORD dwProcessID;

            if(cinstProcess->GetCHString(L"Handle", chstrProcessID))
            {
                dwProcessID = _wtoi(chstrProcessID);
                
                SmartCloseHandle hJob;

                CHString chstrUndecoratedJOName;

                UndecorateJOName(
                    chstrCollectionID,
                    chstrUndecoratedJOName);

                hJob = ::OpenJobObject(
                           MAXIMUM_ALLOWED,
                           FALSE,
                           chstrUndecoratedJOName);
                       
                if(hJob != NULL)
                {
                    PBYTE pbBuff = NULL;
                    long lSize = 0L;
                    bool fGotProcList = false;
                    DWORD dwLen = 0L;

                    try
                    {
                        lSize = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + (5 * sizeof(ULONG_PTR));
                        pbBuff = new BYTE[lSize];

                        if(pbBuff)
                        {
                            fGotProcList = ::QueryInformationJobObject(
                                hJob,
                                JobObjectBasicProcessIdList,
                                pbBuff,
                                lSize,
                                &dwLen);

                            if(!fGotProcList)
                            {
                                // need to grow the buffer...
                                lSize = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + 
                                    (((JOBOBJECT_BASIC_PROCESS_ID_LIST*)pbBuff)->NumberOfAssignedProcesses - 1)*sizeof(ULONG_PTR);

                                delete pbBuff;

                                pbBuff = new BYTE[lSize];
                    
                                if(pbBuff)
                                {
                                    fGotProcList = ::QueryInformationJobObject(
                                        hJob,
                                        JobObjectBasicProcessIdList,
                                        pbBuff,
                                        lSize,
                                        &dwLen);
                                }
                                else
                                {
                                    hr = WBEM_E_OUT_OF_MEMORY;
                                }
                            }

                            if(fGotProcList)
                            {
                                PJOBOBJECT_BASIC_PROCESS_ID_LIST pjobpl = 
                                    static_cast<PJOBOBJECT_BASIC_PROCESS_ID_LIST>(
                                    static_cast<PVOID>(pbBuff));
                        
                                bool fExists = false;

                                for(long m = 0; 
                                    m < pjobpl->NumberOfProcessIdsInList && !fExists; 
                                    m++)
                                {
                                    if(dwProcessID == pjobpl->ProcessIdList[m])
                                    {
                                        fExists = true;
                                    }
                                }
                
                                // If the process wasn't in the job,
                                // we didn't find an instance of the
                                // requested association, even though
                                // the endpoints may have existed.
                                if(!fExists)
                                {
                                    hr = WBEM_E_NOT_FOUND;
                                }
                            }
                            else
                            {
                                hr = WinErrorToWBEMhResult(::GetLastError());
                            }

                            delete pbBuff; 
		                    pbBuff = NULL;
                        }
                        else
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                    catch(...)
                    {
                        if(pbBuff != NULL)
                        {
                            delete pbBuff; pbBuff = NULL;
                        }
                        throw;
                    }
                }
                else
                {
                    hr = WinErrorToWBEMhResult(::GetLastError());
                }
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        } 
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}



/*****************************************************************************
*
*  FUNCTION    :    CJOProcess::Create
*
*  DESCRIPTION :    Internal helper function used to add a process to a job.
*
*  INPUTS      :    A pointer to the JO instance to add the proc to, and
*                   a pointer to the proc instance to add
*
*  RETURNS     :    A valid HRESULT. 
*
*****************************************************************************/
HRESULT CJOProcess::Create(
    const CInstance &JOInstance,
    const CInstance &ProcInstance)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHString chstrJOID;
    CHString chstrProcHandle;

    // JO to add the proc to...
    JOInstance.GetCHString(L"CollectionID", chstrJOID);

    // Proc to add to the job...
    ProcInstance.GetCHString(L"Handle", chstrProcHandle);
    DWORD dwProcID = _wtol(chstrProcHandle);

    // Do the add
    SmartCloseHandle hJob;

    CHString chstrUndecoratedJOName;

    UndecorateJOName(
        chstrJOID,
        chstrUndecoratedJOName);

    hJob = ::OpenJobObject(
               MAXIMUM_ALLOWED,
               FALSE,
               chstrUndecoratedJOName);
               
    if(hJob != NULL)
    {
        SmartCloseHandle hProc;
        hProc = ::OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    dwProcID);
        
        if(hProc != NULL)
        {
            if(!::AssignProcessToJobObject(
                   hJob,
                   hProc))
            {
                hr = MAKE_SCODE(
                         SEVERITY_ERROR, 
                         FACILITY_WIN32, 
                         GetLastError());
            }
        }
    }
    
    return hr;
}




/*****************************************************************************
*
*  FUNCTION    :    CJOProcess::Enumerate
*
*  DESCRIPTION :    Internal helper function used to enumerate instances of
*                   this class.  All instances are enumerated, but only the
*                   properties specified are obtained.
*
*  INPUTS      :    A pointer to a the MethodContext for the call.
*                   A DWORD specifying which properties are requested.
*
*  RETURNS     :    A valid HRESULT
*
*****************************************************************************/
HRESULT CJOProcess::Enumerate(
    MethodContext *pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRefPointerCollection<CInstance> JOList;

    hr = CWbemProviderGlue::GetInstancesByQuery(
             L"SELECT CollectionID FROM Win32_NamedJobObject",
             &JOList,
             pMethodContext,
             IDS_CimWin32Namespace);

    if(SUCCEEDED(hr))
    {
        REFPTRCOLLECTION_POSITION pos;

        // Initialize the enum
        if(JOList.BeginEnum(pos))
        {
            // Set some vars
            CHString chstrJOID;
            CInstancePtr pJOInst;

            while(pJOInst = JOList.GetNext(pos))
            {
                pJOInst->GetCHString(
                    L"CollectionID", 
                    chstrJOID);

                hr = EnumerateProcsInJob(
                         chstrJOID, 
                         pMethodContext);
            }
        }
    }

    return hr;
}

HRESULT CJOProcess::EnumerateProcsInJob(
    LPCWSTR wstrJobID, 
    MethodContext *pMethodContext)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    SmartCloseHandle hJob;

    CHString chstrUndecoratedJOName;

    UndecorateJOName(
        wstrJobID,
        chstrUndecoratedJOName);

    hJob = ::OpenJobObject(
               MAXIMUM_ALLOWED,
               FALSE,
               chstrUndecoratedJOName);
               
    if(hJob != NULL)
    {
        PBYTE pbBuff = NULL;
        long lSize = 0L;
        bool fGotProcList = false;
        DWORD dwLen = 0L;

        try
        {
            lSize = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + (5 * sizeof(ULONG_PTR));
            pbBuff = new BYTE[lSize];

            if(pbBuff)
            {
                fGotProcList = ::QueryInformationJobObject(
                    hJob,
                    JobObjectBasicProcessIdList,
                    pbBuff,
                    lSize,
                    &dwLen);

                if(!fGotProcList)
                {
                    // need to grow the buffer...
                    lSize = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + 
                        (((JOBOBJECT_BASIC_PROCESS_ID_LIST*)pbBuff)->NumberOfAssignedProcesses - 1)*sizeof(ULONG_PTR);

                    delete pbBuff;

                    pbBuff = new BYTE[lSize];
                    
                    if(pbBuff)
                    {
                        fGotProcList = ::QueryInformationJobObject(
                            hJob,
                            JobObjectBasicProcessIdList,
                            pbBuff,
                            lSize,
                            &dwLen);
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }

                if(fGotProcList)
                {
                    PJOBOBJECT_BASIC_PROCESS_ID_LIST pjobpl = 
                        static_cast<PJOBOBJECT_BASIC_PROCESS_ID_LIST>(
                        static_cast<PVOID>(pbBuff));
                    for(long m = 0; 
                        m < pjobpl->NumberOfProcessIdsInList; 
                        m++)
                    {
                        // Create association inst for each
                        // proc in the job...
                        CInstancePtr pInstance(CreateNewInstance(pMethodContext), 
                                               false);

                        // Set the endpoints...
                        CHString chstrEscaped;

                        DecorateJOName(chstrUndecoratedJOName, chstrEscaped);
                        EscapeBackslashes(chstrEscaped, chstrEscaped);
                        EscapeQuotes(chstrEscaped, chstrEscaped);

                        CHString chstrTmp;
                        chstrTmp.Format(L"\\\\.\\%s:Win32_NamedJobObject.CollectionID=\"%s\"", 
                            IDS_CimWin32Namespace, 
                            (LPCWSTR)chstrEscaped);

                        pInstance->SetCHString(L"Collection", chstrTmp);
            
            
                        CHString chstrHandle;
                        chstrHandle.Format(L"%d", pjobpl->ProcessIdList[m]);
                        chstrTmp.Format(L"\\\\.\\%s:Win32_Process.Handle=\"%s\"", 
                            IDS_CimWin32Namespace, 
                            (LPCWSTR) chstrHandle);

                        pInstance->SetCHString(L"Member", chstrTmp);


				        if (SUCCEEDED(hr))
				        {
					        hr = pInstance->Commit();
				        }
                    }
                }
                else
                {
                    hr = WinErrorToWBEMhResult(::GetLastError());
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
        catch(...)
        {
            if(pbBuff != NULL)
            {
                delete pbBuff; pbBuff = NULL;
            }
            throw;
        }

		delete pbBuff; 
		pbBuff = NULL;
    }
    else
    {
        hr = WinErrorToWBEMhResult(::GetLastError());
    }

    return hr;
}


bool CJOProcess::GetInstKey(
            CHString& chstrInstPath, 
            CHString& chstrKeyName)
{
    // the object path is specified in
    // the first arg.  It should at a 
    // minimum always contain an '=' sign,
    // after which, in quotes is the 
    // object key.
    bool fRet = false;
    CHString chstrTmp;
    LONG lPos = chstrInstPath.Find(L'=');
    if(lPos != -1)
    {
        chstrTmp = chstrInstPath.Mid(lPos + 1);
        // Remove quotes...
        if(chstrTmp.Left(1) == L"\"")
        {
            chstrTmp = chstrTmp.Mid(1);
            if(chstrTmp.Right(1) == L"\"")
            {
                chstrTmp = chstrTmp.Left(chstrTmp.GetLength() - 1);
                chstrKeyName = chstrTmp;
                fRet = true;
            }
        }
    }

    return fRet;
}



// Takes a decorated job object name and
// undecorates it.  Decorated job object names
// have a backslash preceeding any character
// that should be uppercase once undecorated.
// 
// Due to the way CIMOM handles backslashes,
// we will get capital letters preceeded by
// two, not just one, backslashes.  Hence, we
// must strip them both.
//
// According to the decoration scheme, the
// following are both lower case: 'A' and 'a',
// while the following are both upper case:
// '\a' and '\A'.
//
void CJOProcess::UndecorateJOName(
    LPCWSTR wstrDecoratedName,
    CHString& chstrUndecoratedJOName)
{
    if(wstrDecoratedName != NULL &&
        *wstrDecoratedName != L'\0')
    {
        LPWSTR wstrDecoratedNameLower = NULL;

        try
        {
            wstrDecoratedNameLower = new WCHAR[wcslen(wstrDecoratedName)+1];

            if(wstrDecoratedNameLower)
            {
                wcscpy(wstrDecoratedNameLower, wstrDecoratedName);
                _wcslwr(wstrDecoratedNameLower);

                WCHAR* p3 = chstrUndecoratedJOName.GetBuffer(
                    wcslen(wstrDecoratedNameLower) + 1);

                const WCHAR* p1 = wstrDecoratedNameLower;
                const WCHAR* p2 = p1 + 1;

                while(*p1 != L'\0')
                {
                    if(*p1 == L'\\')
                    {
                        if(*p2 != NULL)
                        {
                            // Might have any number of
                            // backslashes back to back,
                            // which we will treat as
                            // being the same as one
                            // backslash - i.e., we will
                            // skip over the backslash(s)
                            // and copy over the following
                            // letter.
                            while(*p2 == L'\\')
                            {
                                p2++;
                            };
                    
                            *p3 = towupper(*p2);
                            p3++;

                            p1 = p2 + 1;
                            if(*p1 != L'\0')
                            {
                                p2 = p1 + 1;
                            }
                        }
                        else
                        {
                            p1++;
                        }
                    }
                    else
                    {
                        *p3 = *p1;
                        p3++;

                        p1 = p2;
                        if(*p1 != L'\0')
                        {
                            p2 = p1 + 1;
                        }
                    }
                }
        
                *p3 = NULL;

                chstrUndecoratedJOName.ReleaseBuffer();

                delete wstrDecoratedNameLower;
                wstrDecoratedNameLower = NULL;
            }
        }
        catch(...)
        {
            if(wstrDecoratedNameLower)
            {
                delete wstrDecoratedNameLower;
                wstrDecoratedNameLower = NULL;
            }
            throw;
        }
    }
}


// Does the inverse of the above function.
// However, here, we only need to put in one
// backslash before each uppercase letter.
// CIMOM will add the second backslash.
void CJOProcess::DecorateJOName(
    LPCWSTR wstrUndecoratedName,
    CHString& chstrDecoratedJOName)
{
    if(wstrUndecoratedName != NULL &&
        *wstrUndecoratedName != L'\0')
    {
        // Worst case is that we will have
        // a decorated string twice as long
        // as the undecorated string (happens
        // is every character in the undecorated
        // string is a capital letter).
        WCHAR* p3 = chstrDecoratedJOName.GetBuffer(
            2 * (wcslen(wstrUndecoratedName) + 1));

        const WCHAR* p1 = wstrUndecoratedName;

        while(*p1 != L'\0')
        {
            if(iswupper(*p1))
            {
                // Add in a backslash...
                *p3 = L'\\';
                p3++;

                // Add in the character...
                *p3 = *p1;
                
                p3++;
                p1++;
            }
            else
            {
                // Add in the character...
                *p3 = *p1;
                
                p3++;
                p1++;
            }
        }

        *p3 = NULL;
        
        chstrDecoratedJOName.ReleaseBuffer();

        // What if we had a job called Job,
        // and someone specified it in the
        // object path as "Job" instead of
        // "\Job"?  We DON'T want to find it
        // in such a case, because this would
        // appear to not be adhering to our
        // own convention.  Hence, we 
        // lowercase the incoming string.
        chstrDecoratedJOName.MakeLower();
    }
}


#endif   // #if NTONLY >= 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\wdmprovider\wmiprov.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  WMIProv.CPP
//
//  Module: WMI Provider class methods
//
//  Purpose: Provider class definition.  An object of this class is
//           created by the class factory for each connection.
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////
#include "precomp.h"

long glInits = -1;
long glEventsRegistered = -1;
long glProvObj			= 0;

extern CWMIEvent *  g_pBinaryMofEvent;

extern CCriticalSection * g_pSharedLocalEventsCs;
        
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void VerifyLocalEventsAreRegistered()
{
    if( InterlockedIncrement(&glEventsRegistered) == 1 )
    {
        if( g_pBinaryMofEvent )
        {
            if( !g_pBinaryMofEvent->RegisterForInternalEvents())
            {
                glEventsRegistered = 0; // start over again next time
            }
			else
			{
			    ERRORTRACE((THISPROVIDER,"Successfully Registered for Mof Events\n"));
			}
        }
    }
    ERRORTRACE((THISPROVIDER,"Local Events Verified called, glEventsRegistered: %ld\n", glEventsRegistered));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT SetupLocalEvents()
{
	HRESULT hr = S_OK;
	CAutoBlock Block(g_pSharedLocalEventsCs);

		if( g_pBinaryMofEvent == NULL )
		{
			g_pBinaryMofEvent = (CWMIEvent *)new CWMIEvent(INTERNAL_EVENT);  // This is the global guy that catches events of new drivers being added at runtime.
			if(g_pBinaryMofEvent)
			{
				glEventsRegistered = 0;
				VerifyLocalEventsAreRegistered();
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void DeleteLocalEvents()
{
	CAutoBlock Block(g_pSharedLocalEventsCs);

        if( g_pBinaryMofEvent )
		{
            g_pBinaryMofEvent->DeleteAllLeftOverEvents();
            g_pBinaryMofEvent->DeleteBinaryMofResourceEvent();
			g_pBinaryMofEvent->ReleaseAllPointers();
            SAFE_DELETE_PTR(g_pBinaryMofEvent);
            glEventsRegistered = -1;
			ERRORTRACE((THISPROVIDER,"No longer registered for Mof events\n"));        
		}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ProcessAllBinaryMofs(CHandleMap * pMap, IWbemServices __RPC_FAR *pNamespace,IWbemContext __RPC_FAR *pCtx,BOOL bProcessMofs)
{
	CWMIBinMof Mof;
	
	if( SUCCEEDED( Mof.Initialize(pMap,TRUE,WMIGUID_EXECUTE|WMIGUID_QUERY,pNamespace,NULL,pCtx)))
	{

		RevertToSelf();

		if(bProcessMofs)
		{
			Mof.ProcessListOfWMIBinaryMofsFromWMI();
		}

		//==============================================================
		//  Register for hardcoded event to be notified of WMI updates
		//  make it a member var, so it stays around for the life
		//  of the provider
		//==============================================================
		if( g_pBinaryMofEvent )
		{
			CAutoBlock Block(g_pSharedLocalEventsCs);
			g_pBinaryMofEvent->SetEventServices(pNamespace);
			g_pBinaryMofEvent->SetEventContext(pCtx);
			g_pBinaryMofEvent->ReadyForInternalEvents(TRUE);
			VerifyLocalEventsAreRegistered();
		}
	}
	CheckImpersonationLevelAndVerifyInternalEvents(FALSE);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*********************************************************************
//  Check the impersonation level
//*********************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CheckImpersonationLevelAndVerifyInternalEvents(BOOL fVerifyLocalEvents)
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;
	HANDLE hThreadTok;

    if (IsNT())
    {
		if( GetUserThreadToken(&hThreadTok) )
        {
	        DWORD dwImp, dwBytesReturned;
	        if (GetTokenInformation( hThreadTok, TokenImpersonationLevel, &dwImp, sizeof(DWORD), &dwBytesReturned)){

                if( fVerifyLocalEvents )
                {
					if( glEventsRegistered < 2 )
					{
						VerifyLocalEventsAreRegistered();
					}
                }
            
                // Is the impersonation level Impersonate?
                if ((dwImp == SecurityImpersonation) || ( dwImp == SecurityDelegation) )
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = WBEM_E_ACCESS_DENIED;
                    ERRORTRACE((THISPROVIDER,IDS_ImpersonationFailed));
                }
            }
            else
            {
                hr = WBEM_E_FAILED;
                ERRORTRACE((THISPROVIDER,IDS_ImpersonationFailed));
            }

            // Done with this handle
            CloseHandle(hThreadTok);
        }
     
    }
    else
    {
        // let win9X in...
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}
////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////
HRESULT CWMI_Prov::PutInstanceAsync(IWbemClassObject __RPC_FAR * pIWbemClassObject, 
							   long lFlags, 
                               IWbemContext __RPC_FAR *pCtx,
                               IWbemObjectSink __RPC_FAR *pHandler )
{
	HRESULT	   hr = WBEM_E_FAILED;
    SetStructuredExceptionHandler seh;

    if(pIWbemClassObject == NULL || pHandler == NULL )
    {
	    return WBEM_E_INVALID_PARAMETER;
    }

	//===========================================================
	// Get the class name
	//===========================================================
    CVARIANT vName;
	hr = pIWbemClassObject->Get(L"__CLASS", 0, &vName, NULL, NULL);		
	if( SUCCEEDED(hr))
	{
	    CWMIStandardShell WMI;
		if( SUCCEEDED(WMI.Initialize(vName.GetStr(),FALSE,&m_HandleMap,TRUE,WMIGUID_SET|WMIGUID_QUERY,m_pIWbemServices,pHandler,pCtx)))
		{
			if (SUCCEEDED(hr = CheckImpersonationLevelAndVerifyInternalEvents(TRUE)))
			{
	   			//=======================================================
				//  If there is not a context object, then we know we are 
				//  supposed to put the whole thing, otherwise we are 
				//  supposed to put only the properties specified.
    			//=======================================================
    			try
				{    
    				if( !pCtx )
					{
	      				hr = WMI.FillInAndSubmitWMIDataBlob(pIWbemClassObject,PUT_WHOLE_INSTANCE,vName);
					}
					else
					{
	           			//===================================================
						// If we have a ctx object and the __PUT_EXTENSIONS
						// property is not specified, then we know we are
						// supposed to put the whole thing
        				//===================================================
						CVARIANT vPut;

						if( SUCCEEDED(pCtx->GetValue(L"__PUT_EXT_PROPERTIES", 0, &vPut)))
						{		
			      			hr = WMI.FillInAndSubmitWMIDataBlob(pIWbemClassObject,PUT_PROPERTIES_IN_LIST_ONLY,vPut);
						}
						else
						{
    	      				hr = WMI.FillInAndSubmitWMIDataBlob(pIWbemClassObject,PUT_WHOLE_INSTANCE,vPut);
						}
					}
				}
				STANDARD_CATCH
			}
		}
		hr = WMI.SetErrorMessage(hr);
	}

    return hr;
}

////////////////////////////////////////////////////////////////////
//******************************************************************
//
//   PUBLIC FUNCTIONS
//
//******************************************************************
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
// CWMI_Prov::CWMI_Prov
//
////////////////////////////////////////////////////////////////////
CWMI_Prov::CWMI_Prov()
{
#if defined(_AMD64_) || defined(_IA64_)
	m_Allocator = NULL;
	m_HashTable = NULL;
	m_ID = 0;

	try
	{
		InitializeCriticalSection(&m_CS);
		WmiAllocator t_Allocator ;

		WmiStatusCode t_StatusCode = t_Allocator.New (
			( void ** ) & m_Allocator ,
			sizeof ( WmiAllocator ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			:: new ( ( void * ) m_Allocator ) WmiAllocator ;

			t_StatusCode = m_Allocator->Initialize () ;

			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Allocator.Delete ( ( void * ) m_Allocator	) ;
				m_Allocator = NULL;
				DeleteCriticalSection(&m_CS);
			}
			else
			{
				m_HashTable = ::new WmiHashTable <LONG, ULONG_PTR, 17> ( *m_Allocator ) ;
				t_StatusCode = m_HashTable->Initialize () ;
				
				if ( t_StatusCode != e_StatusCode_Success )
				{
					m_HashTable->UnInitialize () ;
					::delete m_HashTable;
					m_HashTable = NULL;
					m_Allocator->UnInitialize ();
					t_Allocator.Delete ( ( void * ) m_Allocator	) ;
					m_Allocator = NULL;
					DeleteCriticalSection(&m_CS);
				}
			}
		}
		else
		{
			m_Allocator = NULL;
			DeleteCriticalSection(&m_CS);
		}

	}
	catch (...)
	{
	}
#endif

    m_cRef=0;
    m_pIWbemServices = NULL;
    InterlockedIncrement(&g_cObj);
	InterlockedIncrement(&glProvObj);
	ERRORTRACE((THISPROVIDER,"Instance Provider constructed\n"));
}

////////////////////////////////////////////////////////////////////
//
// CWMI_Prov::~CWMI_Prov
//
////////////////////////////////////////////////////////////////////
CWMI_Prov::~CWMI_Prov(void)
{
    SAFE_RELEASE_PTR( m_pIWbemServices );

    InterlockedDecrement(&g_cObj);
	if(InterlockedDecrement(&glProvObj) == 0)
	{
		glInits = -1;
	}
	ERRORTRACE((THISPROVIDER,"Instance Provider destructed\n"));
	

#if defined(_AMD64_) || defined(_IA64_)
	if (m_HashTable)
	{
		WmiAllocator t_Allocator ;
		m_HashTable->UnInitialize () ;
		::delete m_HashTable;
		m_HashTable = NULL;
		m_Allocator->UnInitialize ();
		t_Allocator.Delete ( ( void * ) m_Allocator	) ;
		m_Allocator = NULL;
		DeleteCriticalSection(&m_CS);
	}
#endif
}
////////////////////////////////////////////////////////////////////
//
//  QueryInterface
//
////////////////////////////////////////////////////////////////////
STDMETHODIMP CWMI_Prov::QueryInterface(REFIID riid, PPVOID ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown)) 
    {
        *ppvObj =(IWbemServices *) this ;
    }
    else if (IsEqualIID(riid, IID_IWbemServices)) 
    {
        *ppvObj =(IWbemServices *) this ;
    }
    else if (IsEqualIID(riid, IID_IWbemProviderInit)) 
    {
        *ppvObj = (IWbemProviderInit *) this ;
    }
    else if(riid == IID_IWbemProviderInit)
    {
        *ppvObj = (LPVOID)(IWbemProviderInit*)this;
    }
	else if (riid == IID_IWbemHiPerfProvider)
    {
		*ppvObj = (LPVOID)(IWbemHiPerfProvider*)this;
    }

    if(*ppvObj) 
    {
        AddRef();
        hr = NOERROR;
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMI_Prov::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{

    if(pNamespace == NULL){
        return WBEM_E_INVALID_PARAMETER;
	}
	//===============================================

    m_pIWbemServices = pNamespace;
	m_pIWbemServices->AddRef();

    if( InterlockedIncrement(&glInits) == 0 )
	{
        ProcessAllBinaryMofs(&m_HandleMap, pNamespace, pCtx);
    }
	pInitSink->SetStatus(WBEM_S_NO_ERROR, 0);
	return WBEM_S_NO_ERROR;
}
//////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CWMI_Prov::AddRef(void)
{
    return InterlockedIncrement((long*)&m_cRef);
}

STDMETHODIMP_(ULONG) CWMI_Prov::Release(void)
{
	ULONG cRef = InterlockedDecrement( (long*) &m_cRef);
	if ( !cRef ){
		delete this;
		return 0;
	}
	return cRef;
}

////////////////////////////////////////////////////////////////////
//
// CWMI_Prov::OpenNamespace
//
////////////////////////////////////////////////////////////////////
HRESULT CWMI_Prov::OpenNamespace(
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

////////////////////////////////////////////////////////////////////
//
// CWMI_Prov::CreateInstanceEnumAsync
//
// Purpose:  Asynchronously enumerates the instances of the 
//			 given class.  
//
////////////////////////////////////////////////////////////////
HRESULT CWMI_Prov::CreateInstanceEnumAsync(BSTR wcsClass, 
										   long lFlags, 
                                           IWbemContext __RPC_FAR *pCtx,
				 						   IWbemObjectSink __RPC_FAR * pHandler) 
{
	HRESULT hr = WBEM_E_FAILED;
    SetStructuredExceptionHandler seh;
    CWMIStandardShell WMI;
	if( SUCCEEDED(WMI.Initialize(wcsClass,FALSE,&m_HandleMap,TRUE,WMIGUID_QUERY,m_pIWbemServices,pHandler,pCtx)))
	{

		if (SUCCEEDED(hr = CheckImpersonationLevelAndVerifyInternalEvents(TRUE)))
		{
			//============================================================
			//  Init and get the WMI Data block
			//============================================================
			if( pHandler != NULL ) 
			{
				//============================================================
				//  Parse through all of it
				//============================================================
				try
				{	
					hr = WMI.ProcessAllInstances();
				}
				STANDARD_CATCH
			}
		}
		WMI.SetErrorMessage(hr);
	}
    return hr;
}
//***************************************************************************
HRESULT CWMI_Prov::ExecQueryAsync( BSTR QueryLanguage,
                                   BSTR Query,
                                   long lFlags,
                                   IWbemContext __RPC_FAR *pCtx,
                                   IWbemObjectSink __RPC_FAR *pHandler)
{
    WCHAR wcsClass[_MAX_PATH+2];
    HRESULT hr = WBEM_E_FAILED;
    SetStructuredExceptionHandler seh;
    BOOL fRc = FALSE;

   	//============================================================
	// Do a check of arguments and make sure we have pointers 
   	//============================================================
    if( pHandler == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	try
    {
		//============================================================
		//  Get the properties and class to get
		//============================================================
		fRc = GetParsedPropertiesAndClass(Query,wcsClass);
	}
    STANDARD_CATCH

    CWMIStandardShell WMI;
	if( SUCCEEDED(WMI.Initialize(wcsClass,FALSE,&m_HandleMap,TRUE,WMIGUID_NOTIFICATION|WMIGUID_QUERY,m_pIWbemServices,pHandler,pCtx)))
	{
		if( fRc )
		{
    		hr = CheckImpersonationLevelAndVerifyInternalEvents(TRUE);
		}
		hr = WMI.SetErrorMessage(hr);
    }
    return hr;
}
//***************************************************************************
//
// CWMI_Prov::GetObjectAsync
//
// Purpose:  Asynchronously creates an instance given a particular path value.
//
// NOTE 1:  If there is an instance name in the returned WNODE, then this is a
//			dynamic instance.  You can tell because the pWNSI->OffsetInstanceName
//			field will not be blank.  If this is the case, then the name will not
//			be contained within the datablock, but must instead be retrieved
//			from the WNODE.  See NOTE 1, below.
//
//***************************************************************************

HRESULT CWMI_Prov::GetObjectAsync(BSTR ObjectPath, long lFlags, 
                                  IWbemContext __RPC_FAR *pCtx, 
                                  IWbemObjectSink __RPC_FAR * pHandler )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    SetStructuredExceptionHandler seh;
    WCHAR wcsClass[_MAX_PATH*2];
    WCHAR wcsInstance[_MAX_PATH*2];
    //============================================================
    // Do a check of arguments and make sure we have pointers 
    //============================================================
    if(ObjectPath == NULL || pHandler == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

 	try
	{
		memset(wcsClass,NULL,_MAX_PATH*2);
		//============================================================
		//  Get the path and instance name
		//============================================================
		hr = GetParsedPath( ObjectPath,wcsClass,wcsInstance,m_pIWbemServices );
	}
	STANDARD_CATCH

	if( SUCCEEDED(hr) )
	{
		if (SUCCEEDED(hr = CheckImpersonationLevelAndVerifyInternalEvents(TRUE)))
		{
			try
			{
 			   CWMIStandardShell WMI;
	  		   if( SUCCEEDED(WMI.Initialize(wcsClass,FALSE,&m_HandleMap,TRUE,WMIGUID_QUERY,m_pIWbemServices,pHandler,pCtx)))
			   {
					//============================================================
					//  Get the WMI Block
    				//============================================================
    				hr = WMI.ProcessSingleInstance(wcsInstance);
					hr = WMI.SetErrorMessage(hr);
				}
			}
			STANDARD_CATCH
		}
	}
    return hr;
}
/************************************************************************
*                                                                       *      
*CWMIMethod::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation                     *
************************************************************************/
STDMETHODIMP CWMI_Prov::ExecMethodAsync(BSTR ObjectPath, 
										BSTR MethodName, 
										long lFlags, 
										IWbemContext __RPC_FAR * pCtx, 
										IWbemClassObject __RPC_FAR * pIWbemClassObject, 
										IWbemObjectSink __RPC_FAR * pHandler)
{
    CVARIANT vName;
    HRESULT hr = WBEM_E_FAILED;
    IWbemClassObject * pClass = NULL; //This is an IWbemClassObject.
    WCHAR wcsClass[_MAX_PATH*2];
    WCHAR wcsInstance[_MAX_PATH*2];
    SetStructuredExceptionHandler seh;
	try
    {    
		//============================================================
		//  Get the path and instance name and check to make sure it
		//  is valid
		//============================================================
		hr = GetParsedPath( ObjectPath,wcsClass,wcsInstance ,m_pIWbemServices);
	}
    STANDARD_CATCH


    CWMIStandardShell WMI;
	
	if( SUCCEEDED(WMI.Initialize(wcsClass,FALSE,&m_HandleMap,TRUE,WMIGUID_EXECUTE|WMIGUID_QUERY,m_pIWbemServices,pHandler,pCtx)))
	{
		if (SUCCEEDED(hr = CheckImpersonationLevelAndVerifyInternalEvents(TRUE)))
        {
			//================================================================	
			//  We are ok, so proceed
			//================================================================	
			hr = m_pIWbemServices->GetObject(wcsClass, 0, pCtx, &pClass, NULL);
			if( SUCCEEDED(hr) )
            {
				//==========================================================
				//  Now, get the list of Input and Output parameters
				//==========================================================
                IWbemClassObject * pOutClass = NULL; //This is an IWbemClassObject.
                IWbemClassObject * pInClass = NULL; //This is an IWbemClassObject.

				hr = pClass->GetMethod(MethodName, 0, &pInClass, &pOutClass);
				if( SUCCEEDED(hr) )
                {
                    try
                    {
    				    hr = WMI.ExecuteMethod( wcsInstance, MethodName,pClass, pIWbemClassObject,pInClass, pOutClass);
                    }
                    STANDARD_CATCH
				}
                SAFE_RELEASE_PTR( pOutClass );
                SAFE_RELEASE_PTR( pInClass );
                SAFE_RELEASE_PTR( pClass );
			}
        }
		hr = WMI.SetErrorMessage(hr);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfProvider::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink)
{

    if(pNamespace == NULL){
        return WBEM_E_INVALID_PARAMETER;
	}
	//===============================================

    m_pIWbemServices = pNamespace;
	m_pIWbemServices->AddRef();

    if( InterlockedIncrement(&glInits) == 0 )
	{
        ProcessAllBinaryMofs(&m_HandleMap, pNamespace, pCtx,FALSE);
    }
	pInitSink->SetStatus(WBEM_S_NO_ERROR, 0);
	return WBEM_S_NO_ERROR;
}
////////////////////////////////////////////////////////////////////
//******************************************************************
//
//   PRIVATE FUNCTIONS
//
//******************************************************************
////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\joprocess.h ===
/******************************************************************

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

   JOProcess.H -- WMI provider class definition

   Description: 
   
*******************************************************************/

#if NTONLY >= 5


#pragma once

#define PROVIDER_NAME_WIN32NAMEDJOBOBJECTPROCESS L"Win32_NamedJobObjectProcess"

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));


class CJOProcess : public Provider 
{
    public:
        // Constructor/destructor
        //=======================

        CJOProcess(
            LPCWSTR lpwszClassName, 
            LPCWSTR lpwszNameSpace);
        
        virtual ~CJOProcess();

    protected:

        // Reading Functions
        //============================
        virtual HRESULT ExecQuery(
            MethodContext *pMethodContext, 
            CFrameworkQuery& Query, 
            long lFlags);

        virtual HRESULT GetObject( 
            CInstance* pInstance, 
            long lFlags /*= 0L*/ );

        virtual HRESULT EnumerateInstances(
            MethodContext* pMethodContext, 
            long lFlags);


        
        // Writing Functions
        //============================
        virtual HRESULT PutInstance(
            const CInstance& Instance, 
            long lFlags = 0L);


    private:

        HRESULT FindSingleInstance(
            const CInstance* pInstance);

        HRESULT Create(
            const CInstance &JOInstance,
            const CInstance &ProcInstance);

        bool GetInstKey(
            CHString& chstrCollection, 
            CHString& chstrCollectionID);

        HRESULT Enumerate(
            MethodContext *pMethodContext);

        HRESULT EnumerateProcsInJob(
            LPCWSTR wstrJobID, 
            MethodContext *pMethodContext);

        void UndecorateJOName(
            LPCWSTR wstrDecoratedName,
            CHString& chstrUndecoratedJOName);

        void DecorateJOName(
            LPCWSTR wstrUndecoratedName,
            CHString& chstrDecoratedJOName);


};

#endif // #if NTONLY >= 5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
//
//  Module: WBEM Framework Instance provider
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <dllunreg.h>
#include <DllCommon.h>
#include <initguid.h>
#include "FactoryRouter.h"
#include "ResourceManager.h"
#include "timerqueue.h"
#include <shutdownevent.h>
#include <volumechange.h>

HMODULE ghModule;

// {04788120-12C2-498d-83C1-A7D92E677AC6}
DEFINE_GUID(CLSID_CimWinProviderA, 
0x4788120, 0x12c2, 0x498d, 0x83, 0xc1, 0xa7, 0xd9, 0x2e, 0x67, 0x7a, 0xc6);
// {A3E41207-BE04-492a-AFF0-19E880FF7545}
DEFINE_GUID(CLSID_ShutdownEventProvider, 
0xa3e41207, 0xbe04, 0x492a, 0xaf, 0xf0, 0x19, 0xe8, 0x80, 0xff, 0x75, 0x45);
// {E2CBCB87-9C07-4523-A78F-061499C83987}
DEFINE_GUID(CLSID_VolumeChangeEventProvider, 
0xe2cbcb87, 0x9c07, 0x4523, 0xa7, 0x8f, 0x6, 0x14, 0x99, 0xc8, 0x39, 0x87);


#define PROVIDER_NAME L"WMIPCIMA"

//====================================================================================
// initialize class globals
//====================================================================================
CFactoryRouterData     g_FactoryRouterData;
CShutdownEventFactory* gp_ShutdownEventFactory = NULL;
CVolumeChangeFactory*  gp_VolumeChangeFactory = NULL;

CTimerQueue CTimerQueue :: s_TimerQueue ;
CResourceManager CResourceManager::sm_TheResourceManager ;

//Count number of objects and number of locks.
long g_cLock = 0;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;

    try
    {
        if ( CLSID_CimWinProviderA == rclsid )
        {
            hr = CommonGetClassObject(riid, ppv, PROVIDER_NAME, g_cLock);
        }
        else
        {
            hr = g_FactoryRouterData.DllGetClassObject( rclsid, riid, ppv ) ;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow()
{
    SCODE sc = S_FALSE;

    try
    {
        // It is OK to unload if there are no locks on the
        // class factory and the framework allows us to go.
        if (g_FactoryRouterData.DllCanUnloadNow())
        {
            sc = CommonCanUnloadNow(PROVIDER_NAME, g_cLock);
        }

        if ( sc == S_OK )
        {
            CTimerQueue::s_TimerQueue.OnShutDown();
            CResourceManager::sm_TheResourceManager.ForcibleCleanUp () ;

#ifdef WIN9XONLY
            HoldSingleCim32NetPtr::FreeCim32NetApiPtr() ;
#endif
        }
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = RegisterServer( _T("WBEM Framework Instance Provider CIMA"), CLSID_CimWinProviderA ) ;
        if( NOERROR == t_status )
        {
            t_status = g_FactoryRouterData.DllRegisterServer() ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT t_status = S_OK;

    try
    {
        t_status = UnregisterServer( CLSID_CimWinProviderA ) ;
        if( NOERROR == t_status )
        {
            t_status = g_FactoryRouterData.DllUnregisterServer() ;
        }
    }
    catch ( ... )
    {
        t_status = E_OUTOFMEMORY;
    }

    return t_status ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL InitializeEventFactories(void)
{
	BOOL fRet = FALSE;

	gp_ShutdownEventFactory = new CShutdownEventFactory( CLSID_ShutdownEventProvider,SHUTDOWN_EVENT_CLASS ) ;
	if( gp_ShutdownEventFactory )
	{
		gp_VolumeChangeFactory = new CVolumeChangeFactory( CLSID_VolumeChangeEventProvider,VOLUME_CHANGE_EVENT ) ;
		if( gp_VolumeChangeFactory )
		{
			fRet = TRUE;
		}
	}
	return fRet;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
void CleanupEventFactories(void)
{
	if( gp_ShutdownEventFactory )
	{
		delete gp_ShutdownEventFactory;
		gp_ShutdownEventFactory = NULL;
	}
	if( gp_VolumeChangeFactory )
	{
		delete gp_VolumeChangeFactory;
		gp_VolumeChangeFactory = NULL;
	}
}
//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are
//          initialized and terminated, or upon calls to the LoadLibrary
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain( HINSTANCE hInstDLL,  // handle to DLL module
                       DWORD fdwReason,     // reason for calling function
                       LPVOID lpReserved )  // reserved
{
    BOOL bRet = TRUE;

    try
    {
		LogMessage2( L"%s  -> DllMain", PROVIDER_NAME);

		// Perform actions based on the reason for calling.
		switch( fdwReason )
		{
			case DLL_PROCESS_ATTACH:
			{
				bRet = CommonProcessAttach(PROVIDER_NAME, g_cLock, hInstDLL);
				if( bRet )
				{
					bRet = InitializeEventFactories();
				}
			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
			}
			break;

			case DLL_PROCESS_DETACH:
			{
					CleanupEventFactories();
					// Perform any necessary cleanup.
					LogMessage( L"DLL_PROCESS_DETACH" );
			}
			break;
		}
    }
    catch ( ... )
    {
		bRet = FALSE;
    }

    return bRet;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\precomp.h ===
#pragma message("Precompiling header...")


#include <fwcommon.h>
#include <brodcast.h>
#include "dllutils.h"
#include <smartptr.h>
#include "strings.h"
#include "ConfgMgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\ntdomain.cpp ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  NtDomain.cpp
//
//  Purpose: Nt domain discovery property set provider
//
//***************************************************************************

#include "precomp.h"
#include <frqueryex.h>

#include "wbemnetapi32.h"
#include <dsgetdc.h>

#include "NtDomain.h"

#define MAX_PROPS			CWin32_NtDomain::e_End_Property_Marker
#define MAX_PROP_IN_BYTES	MAX_PROPS/8 + 1

#define _tobit( a ) ( 1 << a )

#define DOMAIN_PREPEND L"Domain: "
#define DOMAIN_PREPEND_SIZE sizeof(DOMAIN_PREPEND)/sizeof(WCHAR) - 1

// into strings.cpp
LPCWSTR IDS_DomainControllerName		= L"DomainControllerName" ;
LPCWSTR IDS_DomainControllerAddress		= L"DomainControllerAddress" ;
LPCWSTR IDS_DomainControllerAddressType = L"DomainControllerAddressType" ;
LPCWSTR IDS_DomainGuid					= L"DomainGuid" ;
LPCWSTR IDS_DomainName					= L"DomainName" ;
LPCWSTR IDS_DnsForestName				= L"DnsForestName" ;
LPCWSTR IDS_DS_PDC_Flag					= L"DSPrimaryDomainControllerFlag" ;
LPCWSTR IDS_DS_Writable_Flag			= L"DSWritableFlag" ;
LPCWSTR IDS_DS_GC_Flag					= L"DSGlobalCatalogFlag" ;
LPCWSTR IDS_DS_DS_Flag					= L"DSDirectoryServiceFlag" ;
LPCWSTR IDS_DS_KDC_Flag					= L"DSKerberosDistributionCenterFlag" ;
LPCWSTR IDS_DS_Timeserv_Flag			= L"DSTimeServiceFlag" ;
LPCWSTR IDS_DS_DNS_Controller_Flag		= L"DSDnsControllerFlag" ;
LPCWSTR IDS_DS_DNS_Domain_Flag			= L"DSDnsDomainFlag" ;
LPCWSTR IDS_DS_DNS_Forest_Flag			= L"DSDnsForestFlag" ;
LPCWSTR IDS_DcSiteName					= L"DcSiteName" ;
LPCWSTR IDS_ClientSiteName				= L"ClientSiteName" ;

// Property set declaration
//=========================
CWin32_NtDomain s_Win32_NtDomain( PROPSET_NAME_NTDOMAIN , IDS_CimWin32Namespace ) ;


/*****************************************************************************
 *
 *  FUNCTION    : CWin32_NtDomain::CWin32_NtDomain
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32_NtDomain::CWin32_NtDomain (

LPCWSTR a_Name,
LPCWSTR a_Namespace
)
: Provider(a_Name, a_Namespace)
{
	SetPropertyTable() ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_NtDomain::~CWin32_NtDomain
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 *****************************************************************************/

CWin32_NtDomain :: ~CWin32_NtDomain()
{
}

//
void CWin32_NtDomain::SetPropertyTable()
{
	// property set names for query optimization
	m_pProps.SetSize( MAX_PROPS ) ;

	// Win32_NtDomain
	m_pProps[e_DomainControllerName]		=(LPVOID) IDS_DomainControllerName;
	m_pProps[e_DomainControllerAddress]		=(LPVOID) IDS_DomainControllerAddress;
	m_pProps[e_DomainControllerAddressType]	=(LPVOID) IDS_DomainControllerAddressType;
	m_pProps[e_DomainGuid]					=(LPVOID) IDS_DomainGuid;
	m_pProps[e_DomainName]					=(LPVOID) IDS_DomainName;
	m_pProps[e_DnsForestName]				=(LPVOID) IDS_DnsForestName;
	m_pProps[e_DS_PDC_Flag]					=(LPVOID) IDS_DS_PDC_Flag;
	m_pProps[e_DS_Writable_Flag]			=(LPVOID) IDS_DS_Writable_Flag;
	m_pProps[e_DS_GC_Flag]					=(LPVOID) IDS_DS_GC_Flag;
	m_pProps[e_DS_DS_Flag]					=(LPVOID) IDS_DS_DS_Flag;
	m_pProps[e_DS_KDC_Flag]					=(LPVOID) IDS_DS_KDC_Flag;
	m_pProps[e_DS_Timeserv_Flag]			=(LPVOID) IDS_DS_Timeserv_Flag;
	m_pProps[e_DS_DNS_Controller_Flag]		=(LPVOID) IDS_DS_DNS_Controller_Flag;
	m_pProps[e_DS_DNS_Domain_Flag]			=(LPVOID) IDS_DS_DNS_Domain_Flag;
	m_pProps[e_DS_DNS_Forest_Flag]			=(LPVOID) IDS_DS_DNS_Forest_Flag;
	m_pProps[e_DcSiteName]					=(LPVOID) IDS_DcSiteName;
	m_pProps[e_ClientSiteName]				=(LPVOID) IDS_ClientSiteName;

	// CIM_System
    m_pProps[e_CreationClassName]			=(LPVOID) IDS_CreationClassName;
	m_pProps[e_Name]						=(LPVOID) IDS_Name; // key, override from CIM_ManagedSystemElement
	m_pProps[e_NameFormat]					=(LPVOID) IDS_NameFormat;
	m_pProps[e_PrimaryOwnerContact]			=(LPVOID) IDS_PrimaryOwnerContact;
	m_pProps[e_PrimaryOwnerName]			=(LPVOID) IDS_PrimaryOwnerName;
	m_pProps[e_Roles]						=(LPVOID) IDS_Roles;

	// CIM_ManagedSystemElement
	m_pProps[e_Caption]						=(LPVOID) IDS_Caption;
	m_pProps[e_Description]					=(LPVOID) IDS_Description;
	m_pProps[e_InstallDate]					=(LPVOID) IDS_InstallDate;
	m_pProps[e_Status]						=(LPVOID) IDS_Status;
}


////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_NtDomain::GetObject
//
//  Inputs:     CInstance*      pInstance - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The calling function will commit the instance.
//
////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32_NtDomain::GetObject(

CInstance *a_pInstance,
long a_Flags,
CFrameworkQuery &a_rQuery
)
{
	return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
HRESULT CWin32_NtDomain::GetObject(

CInstance *a_pInstance,
long a_Flags,
CFrameworkQuery &a_rQuery
)
{
	HRESULT					t_hResult = WBEM_E_NOT_FOUND ;
	CHString				t_chsDomainName ;
	CHString				t_chsDomainKey ;
	DWORD					t_dwBits ;
	CFrameworkQueryEx		*t_pQuery2 ;
	std::vector<_bstr_t>	t_vectorTrustList ;
	CNetAPI32				t_NetAPI ;

	if( ERROR_SUCCESS != t_NetAPI.Init() )
	{
		return WBEM_E_FAILED ;
	}

	// the key
	a_pInstance->GetCHString( IDS_Name, t_chsDomainKey ) ;

	// NTD: begins the key -- this keeps this class from colliding
	// other CIM_System based classes
	if( 0 == _wcsnicmp(t_chsDomainKey, DOMAIN_PREPEND, DOMAIN_PREPEND_SIZE ) )
	{
		t_chsDomainName = t_chsDomainKey.Mid( DOMAIN_PREPEND_SIZE ) ;
	}
	else
	{
		return WBEM_E_NOT_FOUND ;
	}

	// test resultant key
	if( t_chsDomainName.IsEmpty() )
	{
		return WBEM_E_NOT_FOUND ;
	}

	// secure trusted domain list for key validation
	t_NetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;

	for( UINT t_u = 0L; t_u < t_vectorTrustList.size(); t_u++ )
	{
		if( 0 == _wcsicmp( t_vectorTrustList[t_u], bstr_t( t_chsDomainName ) ) )
		{
			// properties required
			t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_rQuery ) ;
			t_pQuery2->GetPropertyBitMask( m_pProps, &t_dwBits ) ;

  			t_hResult = GetDomainInfo(	t_NetAPI,
										bstr_t( t_chsDomainName ),
										a_pInstance,
										t_dwBits ) ;

			if( WBEM_E_NOT_FOUND == t_hResult )
			{
				// We have instantiated the domain. Couldn't obtain info though...
				t_hResult = WBEM_S_PARTIAL_RESULTS ;
			}
			break;
		}
	}

	return t_hResult ;
}
#endif
////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32_NtDomain::EnumerateInstances
//
//  Inputs:     MethodContext*  a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
HRESULT CWin32_NtDomain::EnumerateInstances(

MethodContext *a_pMethodContext,
long a_Flags
)
{
	return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
HRESULT CWin32_NtDomain::EnumerateInstances(

MethodContext *a_pMethodContext,
long a_Flags
)
{
	CNetAPI32	t_NetAPI ;

	if( ERROR_SUCCESS != t_NetAPI.Init() )
	{
		return WBEM_E_FAILED ;
	}

	// Property mask -- include all
	DWORD t_dwBits = 0xffffffff;

	return EnumerateInstances(	a_pMethodContext,
								a_Flags,
								t_NetAPI,
								t_dwBits ) ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CWin32_NtDomain::ExecQuery
 *
 *  DESCRIPTION : Query optimizer
 *
 *  INPUTS      :
 *
 *  OUTPUTS     :
 *
 *  RETURNS     :
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
#ifdef WIN9XONLY
HRESULT CWin32_NtDomain::ExecQuery(

MethodContext *a_pMethodContext,
CFrameworkQuery &a_rQuery,
long a_lFlags
)
{
	return WBEM_S_NO_ERROR;
}
#endif

#ifdef NTONLY
HRESULT CWin32_NtDomain::ExecQuery(

MethodContext *a_pMethodContext,
CFrameworkQuery &a_rQuery,
long a_lFlags
)
{
    HRESULT					t_hResult			= WBEM_S_NO_ERROR ;
	HRESULT					t_hPartialResult	= WBEM_S_NO_ERROR ;
	DWORD					t_dwBits ;
	CFrameworkQueryEx		*t_pQuery2 ;
	std::vector<_bstr_t>	t_vectorReqDomains ;
	std::vector<_bstr_t>	t_vectorTrustList;
	CNetAPI32				t_NetAPI ;
	CHString				t_chsDomainPrepend( DOMAIN_PREPEND ) ;

	if( ERROR_SUCCESS != t_NetAPI.Init() )
	{
		return WBEM_E_FAILED ;
	}

	// properties required
	t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_rQuery ) ;
	t_pQuery2->GetPropertyBitMask( m_pProps, &t_dwBits ) ;

	// keys supplied
	a_rQuery.GetValuesForProp( IDS_Name, t_vectorReqDomains ) ;

	// Note: the primary key has prepended chars to distinquish
	//		 these instances from other CIM_System instances.
	//
	if( t_vectorReqDomains.size() )
	{
		// strip prepended characters
		for( int t_y = 0; t_y < t_vectorReqDomains.size(); t_y++ )
		{
			if( DOMAIN_PREPEND_SIZE < t_vectorReqDomains[t_y].length() )
			{
				// match on prepend?
				if( _wcsnicmp( (wchar_t*)t_vectorReqDomains[t_y],
										DOMAIN_PREPEND,
										DOMAIN_PREPEND_SIZE ) )
				{
					t_vectorReqDomains[t_y] = ( (wchar_t*)t_vectorReqDomains[t_y] +
												DOMAIN_PREPEND_SIZE ) ;
				}
			}
			else
			{
				// does not contain the class prepend
				t_vectorReqDomains.erase( t_vectorReqDomains.begin() + t_y ) ;
                t_y--;
			}
		}
	}

	// If the primary key is not specified
	// then try for the alternate non key query.
	//
	// This is a requirement for assocation support
	// via CBinding as the linkage there is to DomainName
	if( !t_vectorReqDomains.size() )
	{
		a_rQuery.GetValuesForProp( IDS_DomainName, t_vectorReqDomains ) ;
	}

	// General enum if query is ambigious
	if( !t_vectorReqDomains.size() )
	{
		t_hResult = EnumerateInstances( a_pMethodContext,
										a_lFlags,
										t_NetAPI,
										t_dwBits ) ;
	}
	else
	{
		// smart ptr
		CInstancePtr t_pInst ;

		// secure trusted domain list
		t_NetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;

		// by query list
		for ( UINT t_uD = 0; t_uD < t_vectorReqDomains.size(); t_uD++ )
		{
			// by Domain trust list
			for( UINT t_uT = 0L; t_uT < t_vectorTrustList.size(); t_uT++ )
			{
				// Trust to request match
				if( 0 == _wcsicmp( t_vectorTrustList[t_uT], t_vectorReqDomains[t_uD] ) )
				{
					t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

					t_hResult = GetDomainInfo(	t_NetAPI,
												t_vectorReqDomains[t_uD],
												t_pInst,
												t_dwBits ) ;

					if( SUCCEEDED( t_hResult ) )
					{
						// the key
						t_pInst->SetCHString( IDS_Name, t_chsDomainPrepend +
														(wchar_t*)t_vectorReqDomains[t_uD] ) ;

						t_hResult = t_pInst->Commit() ;
					}
					else if( WBEM_E_NOT_FOUND == t_hResult )
					{
						// We have instantiated the domain. Couldn't obtain info though...
						t_pInst->SetCHString( IDS_Name, t_chsDomainPrepend +
														(wchar_t*)t_vectorReqDomains[t_uD] ) ;

						t_hResult = t_pInst->Commit() ;

						t_hPartialResult = WBEM_S_PARTIAL_RESULTS ;
					}

					break ;
				}
			}

			if( FAILED( t_hResult ) )
			{
				break ;
			}
		}
	}

    return ( WBEM_S_NO_ERROR != t_hResult ) ? t_hResult : t_hPartialResult ;
}
#endif

//
#ifdef NTONLY
HRESULT CWin32_NtDomain::EnumerateInstances(

MethodContext	*a_pMethodContext,
long			a_Flags,
CNetAPI32		&a_rNetAPI,
DWORD			a_dwProps
)
{
	HRESULT					t_hResult			= WBEM_S_NO_ERROR ;
	HRESULT					t_hPartialResult	= WBEM_S_NO_ERROR ;
	std::vector<_bstr_t>	t_vectorTrustList;

	CHString				t_chsDomainPrepend( DOMAIN_PREPEND ) ;

	// smart ptr
	CInstancePtr t_pInst ;

	// secure trusted domain list
	a_rNetAPI.GetTrustedDomainsNT( t_vectorTrustList ) ;

	for( UINT t_u = 0L; t_u < t_vectorTrustList.size(); t_u++ )
	{
		t_pInst.Attach( CreateNewInstance( a_pMethodContext ) ) ;

		t_hResult = GetDomainInfo(	a_rNetAPI,
									t_vectorTrustList[ t_u ],
									t_pInst,
									a_dwProps ) ;

		if( SUCCEEDED( t_hResult ) )
		{
			// the key
			t_pInst->SetCHString( IDS_Name, t_chsDomainPrepend +
											(wchar_t*)t_vectorTrustList[t_u] ) ;

			t_hResult = t_pInst->Commit() ;
		}
		else if( WBEM_E_NOT_FOUND == t_hResult )
		{
			// the key. We have instantiated the domain. Couldn't obtain info though...
			t_pInst->SetCHString( IDS_Name, t_chsDomainPrepend +
											(wchar_t*)t_vectorTrustList[t_u] ) ;

			t_hResult = t_pInst->Commit() ;

			t_hPartialResult = WBEM_S_PARTIAL_RESULTS ;
		}
		else
		{
			break ;
		}
	}

	return ( WBEM_S_NO_ERROR != t_hResult ) ? t_hResult : t_hPartialResult ;
}
#endif

//
#ifdef NTONLY
HRESULT CWin32_NtDomain::GetDomainInfo(

CNetAPI32	&a_rNetAPI,
bstr_t		&a_bstrDomainName,
CInstance	*a_pInst,
DWORD		a_dwProps
)
{
	HRESULT	t_hResult = WBEM_S_NO_ERROR ;

	if( a_bstrDomainName.length() )
	{
		ULONG					t_uFlags = 0L ;
		DOMAIN_CONTROLLER_INFO *t_pDCInfo = NULL ;
		DWORD					t_dwNetApiResult = 0 ;

		try
        {
			// avoid the NetAPI call if not needed
			if( a_dwProps & (

				_tobit( e_DomainControllerName )	|
				_tobit( e_DomainControllerAddress )	|
				_tobit( e_DomainControllerAddressType ) |
				_tobit( e_DomainGuid )	|
				_tobit( e_DomainName )	|
				_tobit( e_DnsForestName )	|
				_tobit( e_DS_PDC_Flag )	|
				_tobit( e_DS_Writable_Flag )	|
				_tobit( e_DS_GC_Flag )	|
				_tobit( e_DS_DS_Flag )	|
				_tobit( e_DS_KDC_Flag )	|
				_tobit( e_DS_Timeserv_Flag )	|
				_tobit( e_DS_DNS_Controller_Flag )	|
				_tobit( e_DS_DNS_Domain_Flag )	|
				_tobit( e_DS_DNS_Forest_Flag )	|
				_tobit( e_DcSiteName )	|
				_tobit( e_ClientSiteName ) ) )
			{
				// if requesting domain IP
				if( a_dwProps & _tobit( e_DomainControllerAddress ) )
				{
					t_uFlags |= DS_IP_REQUIRED ;
				}

				t_dwNetApiResult = a_rNetAPI.DsGetDcName(
										NULL,
										(wchar_t*)a_bstrDomainName,
										NULL,
										NULL,
										t_uFlags,
										&t_pDCInfo ) ;


				// force it if not cached
				if( NO_ERROR != t_dwNetApiResult )
				{
					t_uFlags |= DS_FORCE_REDISCOVERY ;

					t_dwNetApiResult = a_rNetAPI.DsGetDcName(
										NULL,
										(wchar_t*)a_bstrDomainName,
										NULL,
										NULL,
										t_uFlags,
										&t_pDCInfo ) ;
				}

				if( ( NO_ERROR == t_dwNetApiResult ) && t_pDCInfo )
				{
					// DomainControllerName
					if( a_dwProps & _tobit( e_DomainControllerName ) )
					{
						if( t_pDCInfo->DomainControllerName )
						{
							a_pInst->SetWCHARSplat(	IDS_DomainControllerName,
													t_pDCInfo->DomainControllerName ) ;
						}
					}

					// DomainControllerAddress
					if( a_dwProps & _tobit( e_DomainControllerAddress ) )
					{
						if( t_pDCInfo->DomainControllerAddress )
						{
							a_pInst->SetWCHARSplat(	IDS_DomainControllerAddress,
													t_pDCInfo->DomainControllerAddress ) ;
						}

						// DomainControllerAddressType, dependent on DS_IP_REQUIRED request
						if( a_dwProps & _tobit( e_DomainControllerAddressType ) )
						{
							a_pInst->SetDWORD(	IDS_DomainControllerAddressType,
												t_pDCInfo->DomainControllerAddressType ) ;
						}
					}

					// DomainGuid
					if( a_dwProps & _tobit( e_DomainGuid ) )
					{
						GUID	t_NullGuid ;
						memset( &t_NullGuid, 0, sizeof( t_NullGuid ) ) ;

						if( !IsEqualGUID( t_NullGuid, t_pDCInfo->DomainGuid ) )
						{
							WCHAR t_cGuid[ 128 ] ;

							StringFromGUID2( t_pDCInfo->DomainGuid, t_cGuid, sizeof( t_cGuid ) / sizeof (WCHAR) ) ;

							a_pInst->SetWCHARSplat(	IDS_DomainGuid,
													t_cGuid ) ;
						}
					}

					// DomainName
					if( a_dwProps & _tobit( e_DomainName ) )
					{
						if( t_pDCInfo->DomainName )
						{
							a_pInst->SetWCHARSplat(	IDS_DomainName,
													t_pDCInfo->DomainName ) ;
						}
					}

					// DnsForestName
					if( a_dwProps & _tobit( e_DnsForestName ) )
					{
						if( t_pDCInfo->DnsForestName )
						{
							a_pInst->SetWCHARSplat(	IDS_DnsForestName,
													t_pDCInfo->DnsForestName ) ;
						}
					}

					// DSPrimaryDomainControllerFlag
					if( a_dwProps & _tobit( e_DS_PDC_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_PDC_Flag,
											(bool)(t_pDCInfo->Flags & DS_PDC_FLAG) ) ;
					}

					// DSWritableFlag
					if( a_dwProps & _tobit( e_DS_Writable_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_Writable_Flag,
											(bool)(t_pDCInfo->Flags & DS_WRITABLE_FLAG) ) ;
					}

					// DSGlobalCatalogFlag
					if( a_dwProps & _tobit( e_DS_GC_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_GC_Flag,
											(bool)(t_pDCInfo->Flags & DS_GC_FLAG) ) ;
					}

					// DSDirectoryServiceFlag
					if( a_dwProps & _tobit( e_DS_DS_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_DS_Flag,
											(bool)(t_pDCInfo->Flags & DS_DS_FLAG) ) ;
					}

					// DSKerberosDistributionCenterFlag
					if( a_dwProps & _tobit( e_DS_KDC_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_KDC_Flag,
											(bool)(t_pDCInfo->Flags & DS_KDC_FLAG) ) ;
					}

					// DSTimeServiceFlag
					if( a_dwProps & _tobit( e_DS_Timeserv_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_Timeserv_Flag,
											(bool)(t_pDCInfo->Flags & DS_TIMESERV_FLAG) ) ;
					}

					// DSDnsControllerFlag
					if( a_dwProps & _tobit( e_DS_DNS_Controller_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_DNS_Controller_Flag,
											(bool)(t_pDCInfo->Flags & DS_DNS_CONTROLLER_FLAG) ) ;
					}

					// DSDnsDomainFlag
					if( a_dwProps & _tobit( e_DS_DNS_Domain_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_DNS_Domain_Flag,
											(bool)(t_pDCInfo->Flags & DS_DNS_DOMAIN_FLAG) ) ;
					}

					// DSDnsForestFlag
					if( a_dwProps & _tobit( e_DS_DNS_Forest_Flag ) )
					{
						a_pInst->Setbool(	IDS_DS_DNS_Forest_Flag,
											(bool)(t_pDCInfo->Flags & DS_DNS_FOREST_FLAG) ) ;
					}

					// DcSiteName
					if( a_dwProps & _tobit( e_DcSiteName ) )
					{
						if( t_pDCInfo->DcSiteName )
						{
							a_pInst->SetWCHARSplat(	IDS_DcSiteName,
													t_pDCInfo->DcSiteName ) ;
						}
					}

					// ClientSiteName
					if( a_dwProps & _tobit( e_ClientSiteName ) )
					{
						if( t_pDCInfo->ClientSiteName )
						{
							a_pInst->SetWCHARSplat(	IDS_ClientSiteName,
													t_pDCInfo->ClientSiteName ) ;
						}
					}

					t_hResult = WBEM_S_NO_ERROR ;

				}
				else if( ERROR_NOT_ENOUGH_MEMORY == t_dwNetApiResult )
				{
					t_hResult = WBEM_E_OUT_OF_MEMORY ;
				}
				else
				{
					t_hResult = WBEM_E_NOT_FOUND ;
				}
			}

			// CIM_System follows

			// CreationClassName
			if( a_dwProps & _tobit( e_CreationClassName ) )
			{
				a_pInst->SetWCHARSplat(	IDS_CreationClassName,
										PROPSET_NAME_NTDOMAIN ) ;
			}

			// CIM_System::Name is the key

			// TODO:
			// e_NameFormat, IDS_NameFormat
			// e_PrimaryOwnerContact, IDS_PrimaryOwnerContact
			// e_PrimaryOwnerName, IDS_PrimaryOwnerName
			// e_Roles, IDS_Roles


			// CIM_ManagedSystemElement follows

			// Caption
			if( a_dwProps & _tobit( e_Caption ) )
			{
				// REVIEW:
				a_pInst->SetWCHARSplat(	IDS_Caption,
										(wchar_t*)a_bstrDomainName ) ;
			}

			// Description
			if( a_dwProps & _tobit( e_Description ) )
			{
				// REVIEW:
				a_pInst->SetWCHARSplat(	IDS_Description,
										(wchar_t*)a_bstrDomainName ) ;
			}

			// Status
			if( a_dwProps & _tobit( e_Status ) )
			{
				if( NO_ERROR == t_dwNetApiResult )
				{
					// REVIEW:
					a_pInst->SetCHString ( IDS_Status , IDS_STATUS_OK ) ;
				}
				else
				{
					// REVIEW:
					a_pInst->SetCHString ( IDS_Status , IDS_STATUS_Unknown ) ;
				}
			}

			// TODO:
			//	e_InstallDate, IDS_InstallDate
		}
		catch(...)
		{
			if( t_pDCInfo )
			{
				a_rNetAPI.NetApiBufferFree( t_pDCInfo ) ;
			}

			throw;
		}

		if( t_pDCInfo )
		{
			a_rNetAPI.NetApiBufferFree( t_pDCInfo ) ;
			t_pDCInfo = NULL ;
		}
	}
	else	// NULL domain
	{
		t_hResult = WBEM_E_NOT_FOUND ;
	}

	return t_hResult ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\ntdomain.h ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  NtDomain.h
//
//  Purpose: Nt domain discovery property set provider
//
//***************************************************************************

#ifndef _NTDOMAIN_H
#define _NTDOMAIN_H

// into strings.h
extern LPCWSTR IDS_DomainControllerName;
extern LPCWSTR IDS_DomainControllerAddress;
extern LPCWSTR IDS_DomainControllerAddressType;
extern LPCWSTR IDS_DomainGuid;
extern LPCWSTR IDS_DomainName;
extern LPCWSTR IDS_DnsForestName;
extern LPCWSTR IDS_DS_PDC_Flag;
extern LPCWSTR IDS_DS_WRITABLE_Flag;
extern LPCWSTR IDS_DS_GC_Flag;
extern LPCWSTR IDS_DS_DS_Flag;
extern LPCWSTR IDS_DS_KDC_Flag;
extern LPCWSTR IDS_DS_TIMESERV_Flag;
extern LPCWSTR IDS_DS_DNS_CONTROLLER_Flag;
extern LPCWSTR IDS_DS_DNS_DOMAIN_Flag;
extern LPCWSTR IDS_DS_DNS_FOREST_Flag;
extern LPCWSTR IDS_DcSiteName;
extern LPCWSTR IDS_ClientSiteName;

//==================================
#define  PROPSET_NAME_NTDOMAIN L"Win32_NTDomain"


// PROPERTY SET
//=============
class CWin32_NtDomain: public Provider
{
private:
      
	// property names 
    CHPtrArray m_pProps ;

	void SetPropertyTable() ;

	HRESULT GetDomainInfo(

		CNetAPI32	&a_NetAPI, 
		bstr_t		&a_bstrDomainName, 
		CInstance	*a_pInst,
		DWORD		a_dwProps 
	) ;

	HRESULT EnumerateInstances(

		MethodContext	*a_pMethodContext,
		long			a_Flags,
		CNetAPI32		&a_rNetAPI, 
		DWORD			a_dwProps
	) ;


public:

    // Constructor/destructor
    //=======================

    CWin32_NtDomain( LPCWSTR a_Name, LPCWSTR a_Namespace ) ;
   ~CWin32_NtDomain() ;

    // Functions that provide properties with current values
    //======================================================

    HRESULT GetObject ( 
		
		CInstance *a_Instance,
		long a_Flags,
		CFrameworkQuery &a_rQuery
	) ;

    HRESULT EnumerateInstances ( 

		MethodContext *a_pMethodContext, 
		long a_Flags = 0L 
	) ;


	HRESULT ExecQuery ( 

		MethodContext *a_pMethodContext, 
		CFrameworkQuery &a_rQuery, 
		long a_Flags = 0L
	) ;


	// Property offset defines
	enum ePropertyIDs { 
		e_DomainControllerName,			// Win32_NtDomain
		e_DomainControllerAddress,
		e_DomainControllerAddressType,
		e_DomainGuid,
		e_DomainName,
		e_DnsForestName,
		e_DS_PDC_Flag,
		e_DS_Writable_Flag,
		e_DS_GC_Flag,
		e_DS_DS_Flag,
		e_DS_KDC_Flag,
		e_DS_Timeserv_Flag,
		e_DS_DNS_Controller_Flag,
		e_DS_DNS_Domain_Flag,
		e_DS_DNS_Forest_Flag,
		e_DcSiteName,
		e_ClientSiteName,
		e_CreationClassName,			// CIM_System
		e_Name,							/* override from CIM_ManagedSystemElement */
		e_NameFormat,
		e_PrimaryOwnerContact,
		e_PrimaryOwnerName,
		e_Roles,
		e_Caption,						// CIM_ManagedSystemElement
		e_Description,
		e_InstallDate,
		e_Status,
		e_End_Property_Marker,			// end marker
		e_32bit = 32					// gens compiler error if additions to this set >= 32 
	};
};

#endif // _NTDOMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\shutdownevent.cpp ===
//=================================================================

//

// PowerManagement.cpp -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "ShutdownEvent.h"
#include <cnvmacros.h>

DWORD	g_dwLogoffMarker = 0 ;
DWORD	g_dwShutdownMarker = 0 ;

//=================================================================
//
// CFactoryRouter
//
// provides for registration and instance creation  
//
//
//=================================================================
// Implements a PowerEventProvider
IUnknown * CShutdownEventFactory::CreateInstance (

REFIID a_riid ,
LPVOID FAR *a_ppvObject
)
{
	return static_cast<IWbemProviderInit *>(new CShutdownEvent) ;
}



//=================================================================
//
// CShutdownEvent
//
// provides for eventing of power management events  
//
//
//=================================================================
//

// CWmiProviderInit needs the class name
BSTR CShutdownEvent::GetClassName()
{
	return SysAllocString(SHUTDOWN_EVENT_CLASS);
}


// CWmiEventProvider signals us to begin providing for events
void CShutdownEvent::ProvideEvents()
{
	if (!m_bRegistered)
	{
		m_bRegistered = TRUE;
		CWinMsgEvent::RegisterForMessage( WM_ENDSESSION ) ;
	}
}


// CWinMsgEvent signals that a message event has arrived
void CShutdownEvent::WinMsgEvent(
			
IN	HWND a_hWnd,
IN	UINT a_message,
IN	WPARAM a_wParam,
IN	LPARAM	a_lParam,
OUT E_ReturnAction &a_eRetAction,
OUT LRESULT &a_lResult
)
{
	switch ( a_message ) 
	{
		case WM_ENDSESSION: 
		{
			BOOL	t_HandleMessage = FALSE ;	
			DWORD	t_dwTicks = GetTickCount() ; 

			// we will get a number of these... 
			// pace the events 30 sec apart.   

			if( ENDSESSION_LOGOFF & a_lParam )	// logoff
			{
				// don't resignal if the minimum time between events
				// have not passed.  
				if( 30000 < t_dwTicks - g_dwLogoffMarker )
				{
					g_dwLogoffMarker = t_dwTicks ;			
					t_HandleMessage = TRUE ;
				}		
			}
			else // shutdown
			{
				// don't resignal if the minimum time between events
				// have not passed.  
				if( 30000 < t_dwTicks - g_dwShutdownMarker )
				{
					g_dwShutdownMarker = t_dwTicks ;
					t_HandleMessage = TRUE ;
				}
			}
		
			if( t_HandleMessage )
			{
				HandleEvent( a_message, a_wParam, a_lParam ) ;
			}			
			break ;
		}
	}
} 

//
void CShutdownEvent::HandleEvent( 

UINT a_message,
WPARAM a_wParam,
LPARAM	a_lParam 
)
{
	BOOL t_Pause = FALSE ;

	IWbemObjectSinkPtr t_pHandler(CEventProvider::GetHandler(), false);
	IWbemClassObjectPtr t_pClass(CEventProvider::GetClass(), false); 

	if( t_pClass != NULL && t_pHandler != NULL )
	{
    	IWbemClassObjectPtr t_pInst;

		if( SUCCEEDED( t_pClass->SpawnInstance( 0L, &t_pInst ) ) )
		{
			VARIANT t_varEvent ;
			VariantInit( &t_varEvent ) ;

			t_varEvent.vt	= VT_I4 ;
			
			if( ENDSESSION_LOGOFF & a_lParam )
			{
				t_varEvent.lVal = 0 ; // logoff	
			}
			else
			{
				t_varEvent.lVal = 1 ; // shutdown	
			}
		
			if ( SUCCEEDED( t_pInst->Put( L"Type", 0, &t_varEvent, CIM_UINT32 ) ) )
			{
				// Get the current computer name
                CHString t_sComputerName;
                DWORD    t_dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;
                
                fGetComputerName( t_sComputerName.GetBuffer( t_dwBufferLength ), &t_dwBufferLength ) ;
                t_sComputerName.ReleaseBuffer();
				
				variant_t t_vName( t_sComputerName ) ;

				if ( SUCCEEDED( t_pInst->Put( L"MachineName", 0, &t_vName, NULL ) ) )
				{
                    IWbemClassObject *p2 = t_pInst;
			        t_pHandler->Indicate ( 1, &p2 ) ;

					t_Pause = TRUE ;
				}
			}

			VariantClear ( &t_varEvent ) ;
		}
	}
	if( t_Pause )
	{
		// allow WMI some time to process this event 
		//Sleep( 3500 ) ; 
	}
}

//
BOOL CShutdownEvent::fGetComputerName(LPWSTR lpwcsBuffer, LPDWORD nSize)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return GetComputerNameW(lpwcsBuffer, nSize);
    }
    else
    {
        char lpBuffer[_MAX_PATH];
        
        BOOL bRet = GetComputerNameA(lpBuffer, nSize);

        // If the call worked
        if (bRet)
        {
			bool t_ConversionFailure = false ;
            WCHAR *pName = NULL ;
            ANSISTRINGTOWCS(lpBuffer, pName , t_ConversionFailure );
			if ( ! t_ConversionFailure )
			{
				if ( pName )
				{
					wcscpy(lpwcsBuffer, pName);
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			else
			{
				SetLastError(ERROR_NO_UNICODE_TRANSLATION);
				return FALSE ;
			}
        }

        return bRet;

    }
}

void CShutdownEvent::OnFinalRelease()
{
    if (m_bRegistered)
	{
		CWinMsgEvent::UnRegisterMessage( WM_ENDSESSION ) ;
	}

    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\physicalmedia.cpp ===
/******************************************************************

   PhysicalMedia.CPP -- WMI provider class implementation



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

******************************************************************/


#include "Precomp.h"

#include <devioctl.h>
#include <ntddscsi.h>
#include <ntdddisk.h>

#include "PhysicalMedia.h"


CPhysicalMedia MyPhysicalMediaSettings ( 

	PROVIDER_NAME_PHYSICALMEDIA, 
	L"root\\cimv2"
) ;

/*****************************************************************************
 *
 *  FUNCTION    :   CPhysicalMedia::CPhysicalMedia
 *
 *  DESCRIPTION :   Constructor
 *
 *****************************************************************************/

CPhysicalMedia :: CPhysicalMedia (

	LPCWSTR lpwszName, 
	LPCWSTR lpwszNameSpace

) : Provider ( lpwszName , lpwszNameSpace )
{	
}

/*****************************************************************************
 *
 *  FUNCTION    :   CPhysicalMedia::~CPhysicalMedia
 *
 *  DESCRIPTION :   Destructor
 *
 *****************************************************************************/

CPhysicalMedia :: ~CPhysicalMedia ()
{
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*****************************************************************************/

HRESULT CPhysicalMedia :: EnumerateInstances (

	MethodContext *pMethodContext, 
	long lFlags
)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	hRes = Enumerate ( pMethodContext );

	return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key properties for the
*                   class. 
*
*****************************************************************************/

HRESULT CPhysicalMedia :: GetObject (

	CInstance *pInstance, 
	long lFlags ,
	CFrameworkQuery &Query
)
{
#if NTONLY
    HRESULT hRes = WBEM_S_NO_ERROR;
	CHString t_DriveName;

	if ( pInstance->GetCHString ( TAG, t_DriveName ) )
	{
		BOOL bFound = FALSE;
		int uPos;
		//Find the drive number
		for ( WCHAR ch = L'0'; ch <= L'9'; ch++ )
		{
			uPos = t_DriveName.Find ( ch );
			if ( uPos != -1 )
			{
				bFound= TRUE;
				break;
			}
		}

		if ( bFound )
		{
			DWORD dwAccess;
#if  NTONLY >= 5
	dwAccess = GENERIC_READ | GENERIC_WRITE;
#else
    dwAccess = GENERIC_READ;
#endif 
			int len = t_DriveName.GetLength();
			CHString t_DriveNo ( t_DriveName.Right ( len - uPos ));
			BYTE bDriveNo = ( BYTE )_wtoi ( (LPCTSTR)t_DriveNo );

			SmartCloseHandle hDiskHandle = CreateFile (

				t_DriveName.GetBuffer(0),
				dwAccess, 
				FILE_SHARE_READ | FILE_SHARE_WRITE, 
				NULL, 
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL, 
				NULL 
			) ;

			DWORD dwErr = GetLastError () ;

			if ( hDiskHandle != INVALID_HANDLE_VALUE ) 
			{
				CHString t_SerialNumber;
				hRes = GetSmartVersion ( hDiskHandle, bDriveNo, t_SerialNumber );

				if ( SUCCEEDED ( hRes ) && (t_SerialNumber.GetLength() > 0) )
				{
        			pInstance->SetCHString ( SERIALNUMBER, t_SerialNumber );
                }
                else
                {
					hRes = GetSCSIVersion(
                        hDiskHandle,
                        bDriveNo,
                        t_SerialNumber);

                    if(SUCCEEDED(hRes))
				    {
        			    pInstance->SetCHString(SERIALNUMBER, t_SerialNumber);
                    }
                    else
                    {
                        hRes = WBEM_E_NOT_FOUND;
                    }
				}
			}
			else
			{
				hRes = WBEM_E_NOT_FOUND;
			}
		}
		else
		{
			hRes = WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		hRes = WBEM_E_INVALID_PARAMETER;
	}

	return hRes;
#else
	return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetObject
*
*  DESCRIPTION :    Enumerates all the Instances 
*
*****************************************************************************/
HRESULT CPhysicalMedia::Enumerate(

	MethodContext *pMethodContext 
)
{
    HRESULT	hRes = WBEM_S_NO_ERROR;

#ifdef NTONLY
	WCHAR wszDiskSpec [ 30 ] ;

	for ( BYTE bIndex = 0 ; bIndex < 32 ; bIndex ++ )
	{
        swprintf ( wszDiskSpec , L"\\\\.\\PHYSICALDRIVE%lu" , ( USHORT )bIndex ) ;

		CInstancePtr pInstance ( CreateNewInstance ( pMethodContext ) , false ) ;

		if ( SUCCEEDED (GetPhysDiskInfoNT ( pInstance, wszDiskSpec, bIndex )  ) )
		{
			hRes = pInstance->Commit (  ) ;
		}
	}
#else
	return  WBEM_E_NOT_SUPPORTED;
#endif
    return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetPhysDiskInfoNT
*
*  DESCRIPTION :    Gets the serial Id
*
*****************************************************************************/
HRESULT CPhysicalMedia::GetPhysDiskInfoNT (

	CInstance *pInstance,
    LPCWSTR lpwszDiskSpec,
    BYTE bIndex
)
{
#ifdef NTONLY
	HRESULT hRes = WBEM_E_NOT_FOUND ;
	DWORD dwAccess;
#if  NTONLY >= 5
	dwAccess = GENERIC_READ | GENERIC_WRITE;
#else
    dwAccess = GENERIC_READ;
#endif 

	// Get handle to physical drive
	//=============================
    pInstance->SetCHString ( TAG , lpwszDiskSpec) ;

	SmartCloseHandle hDiskHandle = CreateFile (

		lpwszDiskSpec,
		dwAccess, 
		FILE_SHARE_READ | FILE_SHARE_WRITE, 
		NULL, 
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL, 
		NULL 
	) ;

	if ( hDiskHandle != INVALID_HANDLE_VALUE ) 
	{
		CHString t_SerialNumber;
		hRes = GetSmartVersion ( hDiskHandle, bIndex, t_SerialNumber );

		if ( SUCCEEDED ( hRes ) && (t_SerialNumber.GetLength() > 0))
		{
			pInstance->SetCHString ( SERIALNUMBER, t_SerialNumber );
		}
        else
        {
            hRes = GetSCSIVersion(
                hDiskHandle,
                bIndex,
                t_SerialNumber);

            if ( SUCCEEDED ( hRes ) && (t_SerialNumber.GetLength() > 0))
            {
                pInstance->SetCHString(SERIALNUMBER, t_SerialNumber);    
            }
        }
	}

  	return ( hRes );
#else
	return WBEM_E_NOT_SUPPORTED;
#endif
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetIdentifyData
*
*  DESCRIPTION :   Gets the Serial Number
*
*****************************************************************************/
HRESULT CPhysicalMedia::GetIdentifyData( HANDLE hDrive, BYTE bDriveNumber, BYTE bDfpDriveMap, BYTE bIDCmd, CHString &t_SerialNumber )
{
	HRESULT hRes = WBEM_S_NO_ERROR;

   SENDCMDINPARAMS      inputParams;
   BYTE					outputParams[sizeof(SENDCMDOUTPARAMS) - 1 + IDENTIFY_BUFFER_SIZE];
   ULONG                bytesReturned;
   BOOL                 success = TRUE;

   ZeroMemory(&inputParams, sizeof(SENDCMDINPARAMS));
   ZeroMemory(&outputParams, sizeof(outputParams));
       
   // Build register structure to enable smart functionality.       
   inputParams.irDriveRegs.bFeaturesReg     = 0;
   inputParams.irDriveRegs.bSectorCountReg  = 1;
   inputParams.irDriveRegs.bSectorNumberReg = 1;
   inputParams.irDriveRegs.bCylLowReg       = 0;
   inputParams.irDriveRegs.bCylHighReg      = 0;
   inputParams.irDriveRegs.bDriveHeadReg    = 0xA0 | (( bDriveNumber & 1) << 4);
   inputParams.irDriveRegs.bCommandReg      = bIDCmd;

   inputParams.bDriveNumber = bDriveNumber;
   inputParams.cBufferSize = IDENTIFY_BUFFER_SIZE;

   success = DeviceIoControl (hDrive, 
                         SMART_RCV_DRIVE_DATA,
                         (LPVOID)&inputParams,
                         sizeof(SENDCMDINPARAMS) - 1,
                         (LPVOID) &outputParams,
                         sizeof(SENDCMDOUTPARAMS) - 1 + IDENTIFY_BUFFER_SIZE,
                         &bytesReturned,
                         NULL);

	if ( success )
	{	

		PIDSECTOR pids = (PIDSECTOR) ((PSENDCMDOUTPARAMS)&outputParams)->bBuffer;
		ChangeByteOrder( pids->sSerialNumber, 
			sizeof pids->sSerialNumber);

    	CHAR	sSerialNumber[21];
        memset(sSerialNumber, 0, sizeof(sSerialNumber));
        memcpy(sSerialNumber, pids->sSerialNumber, sizeof(pids->sSerialNumber));

		t_SerialNumber = sSerialNumber;

	}	

	if ( GetLastError() != 0 )
	{
		hRes = WBEM_E_FAILED;
	}

   return hRes;
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::EnableSmart
*
*  DESCRIPTION :    Enables Smart IOCTL
*
*****************************************************************************/

HRESULT CPhysicalMedia::EnableSmart( HANDLE hDrive, BYTE bDriveNum, BYTE & bDfpDriveMap )
{

   SENDCMDINPARAMS  inputParams;
   SENDCMDOUTPARAMS outputParams;
   ULONG            bytesReturned;
   BOOL             success = TRUE;

   ZeroMemory(&inputParams, sizeof(SENDCMDINPARAMS));
   ZeroMemory(&outputParams, sizeof(SENDCMDOUTPARAMS));

   //
   // Build register structure to enable smart functionality.
   //

   inputParams.irDriveRegs.bFeaturesReg     = ENABLE_SMART;
   inputParams.irDriveRegs.bSectorCountReg  = 1;
   inputParams.irDriveRegs.bSectorNumberReg = 1;
   inputParams.irDriveRegs.bCylLowReg       = SMART_CYL_LOW;
   inputParams.irDriveRegs.bCylHighReg      = SMART_CYL_HI;

   //set DRV to Master or Slave
   inputParams.irDriveRegs.bDriveHeadReg    = 0xA0 | ((bDriveNum & 1) << 4);
   inputParams.irDriveRegs.bCommandReg      = SMART_CMD;
   inputParams.bDriveNumber = bDriveNum;

   success = DeviceIoControl ( hDrive,
                         SMART_SEND_DRIVE_COMMAND,
                         &inputParams,
                         sizeof(SENDCMDINPARAMS) - 1 ,
                         &outputParams,
                         sizeof(SENDCMDOUTPARAMS) - 1,
                         &bytesReturned,
                         NULL);

   if ( success )
   {
	   bDfpDriveMap |= (1 << bDriveNum);
   }

   HRESULT hRes = WBEM_S_NO_ERROR;

   if ( GetLastError() != ERROR_SUCCESS )
   {
	   hRes  = WBEM_E_FAILED;
   }

   return ( hRes );
}

/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetSmartVersion
*
*  DESCRIPTION :    Gets a Smart Version
*
*****************************************************************************/
HRESULT CPhysicalMedia::GetSmartVersion(
               
	HANDLE Handle,
	BYTE bDriveNumber,
	CHString &a_SerialNumber
)
{
   GETVERSIONINPARAMS versionIn;
   ULONG bytesReturned;

   HRESULT hRes = WBEM_S_NO_ERROR;
   ZeroMemory(&versionIn, sizeof(GETVERSIONINPARAMS));

   //
   // Send the IOCTL to retrieve the version information.
   //

   BOOL bSuccess = DeviceIoControl (Handle,
                         SMART_GET_VERSION,
                         NULL,
                         0,
                         &versionIn,
                         sizeof(GETVERSIONINPARAMS),
                         &bytesReturned,
                         NULL);

   if ( bSuccess )
   {
		// If there is a IDE device at number "i" issue commands
		// to the device.
		//
		if (versionIn.bIDEDeviceMap >> bDriveNumber & 1)
		{
			//
			// Try to enable SMART so we can tell if a drive supports it.
			// Ignore ATAPI devices.
			//

			if (!(versionIn.bIDEDeviceMap >> bDriveNumber & 0x10))
			{
				BYTE bDfpDriveMap;
				hRes = EnableSmart( Handle, bDriveNumber, bDfpDriveMap );
				if ( SUCCEEDED ( hRes ) )
				{
					BYTE bIDCmd;

					bIDCmd = (versionIn.bIDEDeviceMap >> bDriveNumber & 0x10) ? IDE_ATAPI_ID : IDE_ID_FUNCTION;

					hRes = GetIdentifyData( Handle, bDriveNumber, bDfpDriveMap, bIDCmd, a_SerialNumber );
					if ( GetLastError () != ERROR_SUCCESS )
					{
					   hRes = WBEM_E_FAILED;
					}
				}

			}
		}
   }


   return hRes;
}


/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::GetSCSIVersion
*
*  DESCRIPTION :    Gets a Smart Version
*
*****************************************************************************/
HRESULT CPhysicalMedia::GetSCSIVersion(
	HANDLE h,
	BYTE bDriveNumber,
	CHString &a_SerialNumber)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    PSTORAGE_DEVICE_DESCRIPTOR psdd = NULL;
    STORAGE_PROPERTY_QUERY spq;

    ULONG ulBytesReturned = 0L;

    spq.PropertyId = StorageDeviceProperty;
    spq.QueryType = PropertyStandardQuery;
    spq.AdditionalParameters[0] = 0;

    try
    {
        psdd = (PSTORAGE_DEVICE_DESCRIPTOR) new BYTE[sizeof(STORAGE_DEVICE_DESCRIPTOR) + 2048];

        if(psdd)
        {
            ZeroMemory(psdd, sizeof(STORAGE_DEVICE_DESCRIPTOR) + 2048);
            // Send the IOCTL to retrieve the serial number information.
            BOOL fSuccess = DeviceIoControl(
                h,
                IOCTL_STORAGE_QUERY_PROPERTY,
                &spq,
                sizeof(STORAGE_PROPERTY_QUERY),
                psdd,
                sizeof(STORAGE_DEVICE_DESCRIPTOR) + 2046,
                &ulBytesReturned,
                NULL);

            if(fSuccess)
            {
                if(ulBytesReturned > 0 && psdd->SerialNumberOffset != 0 && psdd->SerialNumberOffset != -1)
                {
	                LPBYTE lpBaseAddres = (LPBYTE) psdd;
	                LPBYTE lpSerialNumber =  lpBaseAddres + psdd->SerialNumberOffset;

                    if(*lpSerialNumber)
                    {
                        a_SerialNumber = (LPSTR)lpSerialNumber;
                    }
                }
            }
            else
            {
                hr = WinErrorToWBEMhResult(::GetLastError());
            }

            delete psdd;
            psdd = NULL;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    catch(...)
    {
        if(psdd)
        {
            delete psdd;
            psdd = NULL;
        }
    }
    
   return hr;
}


/*****************************************************************************
*
*  FUNCTION    :    CPhysicalMedia::ChangeByteOrder
*
*  DESCRIPTION :    Changes the byte order for extracting the Serial Number 
*					for Smart IOCTL
*
*****************************************************************************/
void CPhysicalMedia::ChangeByteOrder(char *szString, USHORT uscStrSize)
{

	USHORT	i;
	char temp;

	for (i = 0; i < uscStrSize; i+=2)
	{
		temp = szString[i];
		szString[i] = szString[i+1];
		szString[i+1] = temp;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\shutdownevent.h ===
//=================================================================

//

// PowerManagement.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   03/31/99	a-peterc        Created
//
//=================================================================

#ifndef _WMI_SHUTDOWN_EVENT_PROVIDER_H
#define _WMI_SHUTDOWN_EVENT_PROVIDER_H

#include "FactoryRouter.h"
#include "EventProvider.h"
#include "WinMsgEvent.h"


#define SHUTDOWN_EVENT_CLASS L"Win32_ComputerShutdownEvent"

//
class CShutdownEventFactory :	public CFactoryRouter 
{
	private:
	protected:
	public:

		CShutdownEventFactory( REFGUID a_rClsId, LPCWSTR a_pClassName )
			: CFactoryRouter( a_rClsId, a_pClassName ) {} ;

		~CShutdownEventFactory() {};

		// implementation of abstract CProviderClassFactory
		virtual IUnknown * CreateInstance (

			REFIID a_riid ,
			LPVOID FAR *a_ppvObject
			) ;	
};

//
class CShutdownEvent : 
	public CEventProvider, 
	public CWinMsgEvent
{
	private:
		void HandleEvent( 
							UINT a_message,
							WPARAM a_wParam,
							LPARAM	a_lParam  ) ;

		BOOL m_bRegistered;
	
	protected:
	public:

		CShutdownEvent() : m_bRegistered( FALSE ) {};
		~CShutdownEvent() {};

		// implementation of abstract CWinMsgEvent
		virtual void WinMsgEvent(
			
			IN	HWND a_hWnd,
			IN	UINT a_message,
			IN	WPARAM a_wParam,
			IN	LPARAM	a_lParam,
			OUT E_ReturnAction &a_eRetAction,
			OUT LRESULT &a_lResult
			) ;

		// implementation of abstract CEventProvider
		virtual void ProvideEvents() ;

		// implementation of abstract CEventProvider
        void OnFinalRelease();

		// implementation of class name retrieval for CEventProvider
		virtual BSTR GetClassName() ;

		BOOL fGetComputerName( LPWSTR lpwcsBuffer, LPDWORD nSize ) ;
	
};

#endif // _WMI_SHUTDOWN_EVENT_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\physicalmedia.h ===
/******************************************************************



   PhysicalMedia.H -- WMI provider class definition



Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

*******************************************************************/

#ifndef  _CPHYSICALMEDIA_H_
#define  _CPHYSICALMEDIA_H_

#define PROVIDER_NAME_PHYSICALMEDIA		 L"Win32_PhysicalMedia"

#define ERROR_CLASSPATH					 L"\\\\.\\root\\cimv2:__ExtendedStatus"

#define TAG							   L"Tag"
#define SERIALNUMBER				   L"SerialNumber"
//
// Valid values for the bCommandReg member of IDEREGS.
//
#define	IDE_ATAPI_ID				0xA1	// Returns ID sector for ATAPI.
#define	IDE_ID_FUNCTION				0xEC	// Returns ID sector for ATA.
#define	IDE_EXECUTE_SMART_FUNCTION	0xB0	// Performs SMART cmd.
											// Requires valid bFeaturesReg,
#if(_WIN32_WINNT >= 0x0400)
#define IOCTL_DISK_CONTROLLER_NUMBER    CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS)
// IOCTL support for SMART drive fault prediction.
#define SMART_GET_VERSION               CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS)
#define SMART_SEND_DRIVE_COMMAND        CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define SMART_RCV_DRIVE_DATA            CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#endif /* _WIN32_WINNT >= 0x0400 */											// bCylLowReg, and bCylHighReg

//---------------------------------------------------------------------
// The following struct defines the interesting part of the IDENTIFY
// buffer:
//---------------------------------------------------------------------
typedef struct _IDSECTOR {
	USHORT	wGenConfig;
	USHORT	wNumCyls;
	USHORT	wReserved;
	USHORT	wNumHeads;
	USHORT	wBytesPerTrack;
	USHORT	wBytesPerSector;
	USHORT	wSectorsPerTrack;
	USHORT	wVendorUnique[3];
	CHAR	sSerialNumber[20];
	USHORT	wBufferType;
	USHORT	wBufferSize;
	USHORT	wECCSize;
	CHAR	sFirmwareRev[8];
	CHAR	sModelNumber[40];
	USHORT	wMoreVendorUnique;
	USHORT	wDoubleWordIO;
	USHORT	wCapabilities;
	USHORT	wReserved1;
	USHORT	wPIOTiming;
	USHORT	wDMATiming;
	USHORT	wBS;
	USHORT	wNumCurrentCyls;
	USHORT	wNumCurrentHeads;
	USHORT	wNumCurrentSectorsPerTrack;
	ULONG	ulCurrentSectorCapacity;
	USHORT	wMultSectorStuff;
	ULONG	ulTotalAddressableSectors;
	USHORT	wSingleWordDMA;
	USHORT	wMultiWordDMA;
	BYTE	bReserved[128];
} IDSECTOR, *PIDSECTOR;


class CPhysicalMedia : public Provider 
{
private:
	HRESULT Enumerate( MethodContext *pMethodContext );
	HRESULT GetPhysDiskInfoNT ( CInstance *pInstance, LPCWSTR lpwszDiskSpec, BYTE bIndex );
	void ChangeByteOrder(char *szString, USHORT uscStrSize);
	HRESULT GetIdentifyData( HANDLE hDrive, BYTE bDriveNumber, BYTE bDfpDriveMap, BYTE bIDCmd, CHString &a_SerialNumber );
	HRESULT EnableSmart( HANDLE hDrive, BYTE bDriveNum, BYTE & bDfpDriveMap );
	HRESULT GetSmartVersion( HANDLE Handle, BYTE bDriveNumber, 	CHString &a_SerialNumber );
    HRESULT GetSCSIVersion(
        HANDLE h, 
        BYTE bDriveNumber, 	
        CHString &a_SerialNumber);

protected:

        HRESULT EnumerateInstances ( 

			MethodContext *pMethodContext, 
			long lFlags = 0L
		) ;

        HRESULT GetObject (

			CInstance *pInstance, 
			long lFlags,
			CFrameworkQuery &Query
		) ;
public:
        
		CPhysicalMedia (

			LPCWSTR lpwszClassName, 
			LPCWSTR lpwszNameSpace
		) ;

        virtual ~CPhysicalMedia () ;
private:
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include ..\..\..\..\common\makefile.cmn
SOURCES_USED=..\..\..\..\common\makefile.cmn

TARGETNAME=wmipcima

TARGETPATH=obj
TARGETTYPE=DYNLINK

INCLUDES=$(INCLUDES); \
	$(COMMON_NEWTHROW_INC); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
	$(CIMWIN32_LIB_INC); \
	$(WMIIDL_INC); \
	$(CRT_INC_PATH); \
	$(FRAMEDYN_PRIVATE); \
	$(NET_INC_PATH); \
	$(BASE_INC_PATH); \

PRESOURCES=$(PRESOURCES) \
	..\useassoc.cpp \
	..\usebinding.cpp \
	..\JOProcess.cpp \
	..\Ntdomain.cpp \
	..\PhysicalMedia.cpp \
	..\ShutdownEvent.cpp \
	..\UsbHub.cpp	\
	..\VolumeChange.cpp \
	..\Win32_ControllerHasHub.cpp \

NTSOURCES=$(NTSOURCES) \

MISCSOURCES=$(MISCSOURCES) \
	..\cimwin32a.rc \
        ..\maindll.cpp	\

TARGETLIBS= \
	$(COMMON_NEWTHROW_LIB) \
!ifdef USE_FRAMEDYD
	$(SDK_LIB_PATH)\framedyd.lib \
!else
	$(SDK_LIB_PATH)\framedyn.lib \
!endif
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(CIMWIN32_LIB)	\
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\gdi32.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\version.lib \


C_DEFINES=$(C_DEFINES) /D_WINDLL /D_WIN32_DCOM
USER_C_FLAGS=$(USER_C_FLAGS)
USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1
DLLENTRY=_DllMainCRTStartup

DLLDEF=$(O)\cimwin32A.def

!ifdef USE_FRAMEDYD
DEBUG_CRTS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\useassoc.cpp ===
//=================================================================

//

// useassoc.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assoc.h>

CAssociation MyOperatingSystemAutochkSetting(
    L"Win32_OperatingSystemAutochkSetting",
    IDS_CimWin32Namespace,
    L"Win32_OperatingSystem",
    L"Win32_AutoChkSetting",
    IDS_Element,
    IDS_Setting
) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\usebinding.cpp ===
//=================================================================

//

// usebinding.cpp -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <Binding.h>

CBinding UserToDomain(
    L"Win32_UserInDomain",
    IDS_CimWin32Namespace,
    L"Win32_NTDomain",
    L"Win32_UserAccount",
    IDS_GroupComponent,
    IDS_PartComponent,
    L"DomainName",
    IDS_Domain
);

CBinding GroupToDomain(
    L"Win32_GroupInDomain",
    IDS_CimWin32Namespace,
    L"Win32_NTDomain",
    L"Win32_Group",
    IDS_GroupComponent,
    IDS_PartComponent,
    L"DomainName",
    IDS_Domain
);

CBinding JOStats(
    L"Win32_NamedJobObjectStatistics",
    IDS_CimWin32Namespace,
    L"Win32_NamedJobObjectActgInfo",
    L"Win32_NamedJobObject",
    L"Stats",
    L"Collection",
    L"Name",
    L"CollectionID"
);

CBinding JOLimit(
    L"Win32_NamedJobObjectLimit",
    IDS_CimWin32Namespace,
    L"Win32_NamedJobObjectLimitSetting",
    L"Win32_NamedJobObject",
    L"Setting",
    L"Collection",
    L"SettingID",
    L"CollectionID"
);

CBinding JOSecLimit(
    L"Win32_NamedJobObjectSecLimit",
    IDS_CimWin32Namespace,
    L"Win32_NamedJobObjectSecLimitSetting",
    L"Win32_NamedJobObject",
    L"Setting",
    L"Collection",
    L"SettingID",
    L"CollectionID"
);

CBinding Win32_LogonSessionMappedDisk(
    L"Win32_LogonSessionMappedDisk",
    IDS_CimWin32Namespace,
    L"Win32_LogonSession",
    L"Win32_MappedLogicalDisk",
    L"Antecedent",
    L"Dependent",
    L"LogonID",
    L"SessionID"
);

CBinding Win32_DiskDrivePhysicalMedia(
   L"Win32_DiskDrivePhysicalMedia",
   IDS_CimWin32Namespace,
   L"Win32_DiskDrive",
   L"Win32_PhysicalMedia",
   L"Dependent",
   L"Antecedent",
   L"DeviceID",
   L"Tag"
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\volumechange.cpp ===
//=================================================================

//

// VolumeChange.cpp -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <dbt.h>
#include "VolumeChange.h"

//=================================================================
//
// CFactoryRouter
//
// provides for registration and instance creation  
//
//
//=================================================================
// Implements a VolumeChangeProvider
IUnknown * CVolumeChangeFactory::CreateInstance (

REFIID a_riid ,
LPVOID FAR *a_ppvObject
)
{
	return static_cast<IWbemProviderInit *>(new CVolumeChangeEvent) ;
}

//=================================================================
//
// CVolumeChangeEvent
//
// provides for eventing of power management events  
//
//
//=================================================================
//

// CWmiProviderInit needs the class name
BSTR CVolumeChangeEvent::GetClassName()
{
	return SysAllocString(VOLUME_CHANGE_EVENT);
}

// CWmiEventProvider signals us to begin providing for events
void CVolumeChangeEvent::ProvideEvents()
{
	if (!m_bRegistered)
	{
		m_bRegistered = TRUE;
		CWinMsgEvent::RegisterForMessage( WM_DEVICECHANGE ) ;
	}
}


// CWinMsgEvent signals that a message event has arrived
void CVolumeChangeEvent::WinMsgEvent(
			
IN	HWND a_hWnd,
IN	UINT a_message,
IN	WPARAM a_wParam,
IN	LPARAM	a_lParam,
OUT E_ReturnAction &a_eRetAction,
OUT LRESULT &a_lResult
)
{
    DEV_BROADCAST_HDR *pHdr = (DEV_BROADCAST_HDR *)a_lParam;

    if (
          (
           (a_wParam == DBT_DEVICEARRIVAL) ||
           (a_wParam == DBT_DEVICEREMOVECOMPLETE) 
          ) &&

          (pHdr->dbch_devicetype == DBT_DEVTYP_VOLUME) 
       )
    {
	    HandleEvent( a_wParam, (DEV_BROADCAST_VOLUME *) pHdr ) ;
    }
}

void CVolumeChangeEvent::HandleEvent( WPARAM wParam, DEV_BROADCAST_VOLUME *pVol )
{
    HRESULT hr = S_OK;  // Note that this result is NOT sent back from this function
                        // since I don't have any place to send it TO.

    if (pVol->dbcv_flags & DBTF_NET)
    {
	    IWbemObjectSinkPtr t_pHandler(CEventProvider::GetHandler(), false);
	    IWbemClassObjectPtr t_pClass(CEventProvider::GetClass(), false); 

    	if( t_pClass != NULL && t_pHandler != NULL )
	    {
        	IWbemClassObjectPtr t_pInst;

		    if( SUCCEEDED( hr = t_pClass->SpawnInstance( 0L, &t_pInst ) ) )
		    {
                DWORD dwUnitMask = pVol->dbcv_unitmask;

                for (DWORD i = 0; i < 26; ++i)
                {
                    if (dwUnitMask & 0x1)
                    {
                        break;
                    }
                    dwUnitMask = dwUnitMask >> 1;
                }

                WCHAR l[3];
                l[0] = i + L'A';
                l[1] = L':';
                l[2] = L'\0';

                variant_t vValue(l);
                variant_t vEventType;

                switch (wParam)
                {
                    case DBT_DEVICEARRIVAL:
                    {
                        vEventType = (long)2;
                        break;
                    }

                    case DBT_DEVICEREMOVECOMPLETE:
                    {
                        vEventType = (long)3;
                        break;
                    }

                    default:
                    {
                        hr = WBEM_E_FAILED;
                        break;
                    }
                }

                // Only want to report these events for
                // non-mapped (e.g., local) drives (201119).
                if(IsLocalDrive(l))
                {
			        if ( SUCCEEDED(hr) &&
                         SUCCEEDED( hr = t_pInst->Put( L"DriveName", 0, &vValue, 0 ) ) &&
                         SUCCEEDED( hr = t_pInst->Put( L"EventType", 0, &vEventType, 0 ) )
                       )
                    {
                        // We can't use t_pInst here, cuz the operator(cast) for this smartptr
                        // will FREE the pointer before passing it in, under the assumption
                        // that Indicate is going to POPULATE this pointer.
                        IWbemClassObject *p2 = t_pInst;
			            hr = t_pHandler->Indicate ( 1, &p2 ) ;
                    }
                }
		    }
	    }
    }
}


bool CVolumeChangeEvent::IsLocalDrive(const TCHAR* tstrDrive)
{
    DWORD dwDriveType;
    bool bRet = false;

    dwDriveType = ::GetDriveType(tstrDrive);

    if(dwDriveType != DRIVE_REMOTE)
    {
        bRet = true;
    }

    return bRet;
}





//
void CVolumeChangeEvent::OnFinalRelease()
{
    if (m_bRegistered)
	{
		CWinMsgEvent::UnRegisterMessage( WM_DEVICECHANGE ) ;
	}

	delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\usbhub.h ===
//***************************************************************************

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//  USBHub.h
//
//  Purpose: USB Hub property set provider
//
//***************************************************************************

// Property set identification
//============================
#ifndef _USBHUB_H
#define _USBHUB_H

#define USBHUB_ALL_PROPS                    0xFFFFFFFF
#define USBHUB_KEY_ONLY                     0x00000010
#define USBHUB_PROP_ConfigManagerErrorCode  0x00000001
#define USBHUB_PROP_ConfigManagerUserConfig 0x00000002
#define USBHUB_PROP_Status                  0x00000004
#define USBHUB_PROP_PNPDeviceID             0x00000008
#define USBHUB_PROP_DeviceID                0x00000010
#define USBHUB_PROP_SystemCreationClassName 0x00000020
#define USBHUB_PROP_SystemName              0x00000040
#define USBHUB_PROP_Description             0x00000080
#define USBHUB_PROP_Caption                 0x00000100
#define USBHUB_PROP_Name                    0x00000200
#define USBHUB_PROP_CreationClassName       0x00000400

#define	PROPSET_NAME_USBHUB	L"Win32_USBHub"

class CWin32USBHub : virtual public Provider
{
    private:
        CHPtrArray m_ptrProperties;

    protected:

        virtual bool IsOneOfMe
        (
            void *a_pv
        );

        virtual HRESULT LoadPropertyValues
        (
            void *a_pv
        );

        virtual bool ShouldBaseCommit
        (
            void *a_pvData
        );

        HRESULT Enumerate
        (
            MethodContext *a_pMethodContext, 
            long a_lFlags, 
            DWORD a_dwReqProps = USBHUB_ALL_PROPS
        );

    public:

        // Constructor/destructor
        //=======================

        CWin32USBHub
        (
			const CHString &a_strName, 
			LPCWSTR a_pszNamespace
        );

        ~CWin32USBHub();

        // Functions provide properties with current values
        //=================================================
        virtual HRESULT GetObject
        (
            CInstance *a_pInst, 
            long a_lFlags,
            CFrameworkQuery& pQuery
        );

        virtual HRESULT ExecQuery
        (
            MethodContext *a_pMethodContext, 
            CFrameworkQuery &a_pQuery, 
            long a_Flags = 0L 
        );

        virtual HRESULT EnumerateInstances
        (
            MethodContext *a_pMethodContext, 
            long a_lFlags = 0L
        );        
} ;

// This is the base; it should always commit in the base.
inline bool CWin32USBHub::ShouldBaseCommit
(
    void *a_pvData
)
{ 
    return true; 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\volumechange.h ===
//=================================================================

//

// VolumeChange.h -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include "FactoryRouter.h"
#include "EventProvider.h"
#include "WinMsgEvent.h"
#include <dbt.h>


#define VOLUME_CHANGE_EVENT L"Win32_VolumeChangeEvent"

//
class CVolumeChangeFactory :	public CFactoryRouter 
{
	private:
	protected:
	public:

		CVolumeChangeFactory( REFGUID a_rClsId, LPCWSTR a_pClassName )
			: CFactoryRouter( a_rClsId, a_pClassName ) {} ;

		~CVolumeChangeFactory() {};

		// implementation of abstract CProviderClassFactory
		virtual IUnknown * CreateInstance (

			REFIID a_riid ,
			LPVOID FAR *a_ppvObject
			) ;	
};

//
class CVolumeChangeEvent : 
	public CEventProvider, 
	public CWinMsgEvent
{
	private:
        void HandleEvent( WPARAM wParam, DEV_BROADCAST_VOLUME *pVol );
		BOOL m_bRegistered;
        bool IsLocalDrive(const TCHAR* tstrDrive);
	
	protected:
	public:

		CVolumeChangeEvent() : m_bRegistered ( FALSE ) {};
		~CVolumeChangeEvent() {};

		// implementation of abstract CWinMsgEvent
		virtual void WinMsgEvent(
			
			IN	HWND a_hWnd,
			IN	UINT a_message,
			IN	WPARAM a_wParam,
			IN	LPARAM	a_lParam,
			OUT E_ReturnAction &a_eRetAction,
			OUT LRESULT &a_lResult
			) ;

		// implementation of abstract CWmiEventProvider
		virtual void ProvideEvents() ;

		// implementation of class name retrieval for CEventProvider
		virtual void OnFinalRelease() ;

		// implementation of class name retrieval for CWmiProviderInit
		virtual BSTR GetClassName() ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\usbhub.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  USBHub.cpp
//
//  Purpose: USB Hub property set provider
//
//***************************************************************************

#include "precomp.h"
#include "LPVParams.h"
#include <FRQueryEx.h>
#include <ProvExce.h>

#include "USBHub.h"

// Property set declaration
//=========================

CWin32USBHub MyUSBHub( PROPSET_NAME_USBHUB, IDS_CimWin32Namespace );

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USBHub::CWin32USBHub
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : const CHString& strName - Name of the class.
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Registers property set with framework
 *
 *****************************************************************************/

CWin32USBHub::CWin32USBHub
(
	const CHString &a_strName,
	LPCWSTR a_pszNamespace
)
: Provider( a_strName, a_pszNamespace )
{
    m_ptrProperties.SetSize(11);
    m_ptrProperties[0]	= ( (LPVOID) IDS_ConfigManagerErrorCode );
    m_ptrProperties[1]	= ( (LPVOID) IDS_ConfigManagerUserConfig );
    m_ptrProperties[2]	= ( (LPVOID) IDS_Status);
    m_ptrProperties[3]	= ( (LPVOID) IDS_PNPDeviceID);
    m_ptrProperties[4]	= ( (LPVOID) IDS_DeviceID);
    m_ptrProperties[5]	= ( (LPVOID) IDS_SystemCreationClassName);
    m_ptrProperties[6]	= ( (LPVOID) IDS_SystemName);
    m_ptrProperties[7]	= ( (LPVOID) IDS_Description);
    m_ptrProperties[8]	= ( (LPVOID) IDS_Caption);
    m_ptrProperties[9]	= ( (LPVOID) IDS_Name);
    m_ptrProperties[10] = ( (LPVOID) IDS_CreationClassName );
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USBHub::~CWin32USBHub
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Deregisters property set from framework
 *
 ****************************************************************************/

CWin32USBHub::~CWin32USBHub()
{
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USBHub::GetObject
//
//  Inputs:     CInstance		*a_pInst - Instance into which we
//                                          retrieve data.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   The Calling function will Commit the instance.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USBHub::GetObject
(
    CInstance *a_pInst,
    long a_lFlags,
    CFrameworkQuery& pQuery
)
{
    HRESULT t_hResult = WBEM_E_NOT_FOUND ;
    CConfigManager t_cfgmgr ;

	// Let's see if config manager recognizes this device at all
	CHString t_sDeviceID ;
	a_pInst->GetCHString( IDS_DeviceID, t_sDeviceID ) ;

	CConfigMgrDevicePtr t_pDevice;
	if( t_cfgmgr.LocateDevice( t_sDeviceID, &t_pDevice ) )
	{
		// OK, it knows about it.  Is it a USB Hub?
		if( IsOneOfMe(t_pDevice ) )
		{
            CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx*>( &pQuery ) ;
            DWORD t_dwProperties ;

	        t_pQuery2->GetPropertyBitMask( m_ptrProperties, &t_dwProperties ) ;

			t_hResult = LoadPropertyValues( &CLPVParams( a_pInst,
														t_pDevice,
														t_dwProperties ) ) ;
		}
	}

	return t_hResult;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32IDE::ExecQuery
//
//  Inputs:     MethodContext *a_pMethodContext - Context to enum
//                              instance data in.
//              CFrameworkQuery& the query object
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USBHub::ExecQuery
(
    MethodContext *a_pMethodContext,
    CFrameworkQuery &a_pQuery,
    long a_lFlags
)
{
    CFrameworkQueryEx *t_pQuery2 = static_cast <CFrameworkQueryEx*>( &a_pQuery ) ;
    DWORD t_dwProperties ;

	t_pQuery2->GetPropertyBitMask( m_ptrProperties, &t_dwProperties ) ;
    return Enumerate( a_pMethodContext, a_lFlags, t_dwProperties ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USBHub::EnumerateInstances
//
//  Inputs:     MethodContext   *a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USBHub::EnumerateInstances
(
    MethodContext *a_pMethodContext,
    long a_lFlags /*= 0L*/
)
{
    return Enumerate( a_pMethodContext, a_lFlags ) ;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CWin32USBHub::Enumerate
//
//  Inputs:     MethodContext   *a_pMethodContext - Context to enum
//                              instance data in.
//
//  Outputs:    None.
//
//  Returns:    HRESULT         Success/Failure code.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
HRESULT CWin32USBHub::Enumerate
(
    MethodContext *a_pMethodContext,
    long a_lFlags,
    DWORD a_dwReqProps
)
{
    HRESULT				t_hResult = WBEM_E_FAILED ;
    CConfigManager		t_cfgManager ;
    CDeviceCollection	t_deviceList ;
	CInstancePtr		t_pInst;
	CConfigMgrDevicePtr t_pDevice;

	if( t_cfgManager.GetDeviceListFilterByClass( t_deviceList, L"USB" ) )
	{
		REFPTR_POSITION t_pos;
		if( t_deviceList.BeginEnum( t_pos ) )
		{
			t_hResult = WBEM_S_NO_ERROR;

			// Walk the list
            for (t_pDevice.Attach(t_deviceList.GetNext( t_pos ));
                 SUCCEEDED( t_hResult ) && (t_pDevice != NULL);
                 t_pDevice.Attach(t_deviceList.GetNext( t_pos )))
			{
				// Now to find out if this is the usb Hub
				if( IsOneOfMe( t_pDevice ) )
				{
                    t_pInst.Attach(CreateNewInstance( a_pMethodContext ) );
					if( SUCCEEDED( t_hResult = LoadPropertyValues( &CLPVParams(
																		t_pInst,
																		t_pDevice,
																		a_dwReqProps ) ) ) )
					{
						// Derived classes (like CW32USBCntrlDev) may
						// commit as result of call to
						// LoadPropertyValues, so check if we should
						// (only do so if we are of this class's type).
						if( ShouldBaseCommit( NULL ) )
						{
							t_hResult = t_pInst->Commit(  ) ;
						}
					}
				}
			}

			// Always call EndEnum().
			t_deviceList.EndEnum();
		}
	}

	return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USBHub::LoadPropertyValues
 *
 *  DESCRIPTION : Assigns values to properties
 *
 *  INPUTS      : void *a_pv - Instance package to load values into.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

HRESULT CWin32USBHub::LoadPropertyValues
(
    void *a_pv
)
{
    HRESULT		t_hResult = WBEM_S_NO_ERROR;
    CHString	t_chstrDeviceID, t_chstrDesc, t_chstrTemp;

    /*************************************
    * Unpack and confirm our parameters...
    *************************************/
    CLPVParams			*t_pData		= ( CLPVParams * ) a_pv ;
    CInstance			*t_pInst		= ( CInstance * )( t_pData->m_pInstance ) ; // This instance released by caller
    CConfigMgrDevice	*t_pDevice		= ( CConfigMgrDevice * )( t_pData->m_pDevice ) ;
    DWORD				t_dwReqProps	= ( DWORD )( t_pData->m_dwReqProps ) ;

    if( t_pInst == NULL || t_pDevice == NULL )
    {
        return WBEM_E_PROVIDER_FAILURE;
    }


    /***********************
    * Set the key properties
    ***********************/

    t_pDevice->GetDeviceID( t_chstrDeviceID ) ;

    if( t_chstrDeviceID.GetLength() == 0 )
    {
        // We need the device id for the key property of this class.  If we can
        // not obtain it, we can't set the key, which is an unacceptable error.
        return WBEM_E_PROVIDER_FAILURE;
    }
    else
    {
        t_pInst->SetCHString( IDS_DeviceID, t_chstrDeviceID ) ;
    }


    /*********************************
    * Set CIM_LogicalDevice properties
    *********************************/

    if( t_dwReqProps & USBHUB_PROP_PNPDeviceID )
    {
        t_pInst->SetCHString( IDS_PNPDeviceID, t_chstrDeviceID ) ;
    }

	if( t_dwReqProps & USBHUB_PROP_SystemCreationClassName )
    {
        t_pInst->SetCHString( IDS_SystemCreationClassName,
                                  IDS_Win32ComputerSystem ) ;
    }
	if( t_dwReqProps & USBHUB_PROP_CreationClassName )
    {
        SetCreationClassName(t_pInst);
    }
    if( t_dwReqProps & USBHUB_PROP_SystemName )
    {
        t_pInst->SetCHString( IDS_SystemName, GetLocalComputerName() ) ;
    }

    if( t_dwReqProps & (USBHUB_PROP_Description | USBHUB_PROP_Caption | USBHUB_PROP_Name) )
    {
        if( t_pDevice->GetDeviceDesc( t_chstrDesc ) )
        {
            t_pInst->SetCHString( IDS_Description, t_chstrDesc ) ;
        }
    }

    if( t_dwReqProps & USBHUB_PROP_ConfigManagerErrorCode ||
        t_dwReqProps & USBHUB_PROP_Status )
    {
        DWORD t_dwStatus	= 0L;
        DWORD t_dwProblem	= 0L;

		if( t_pDevice->GetStatus( &t_dwStatus, &t_dwProblem ) )
        {
            if( t_dwReqProps & USBHUB_PROP_ConfigManagerErrorCode )
            {
                t_pInst->SetDWORD( IDS_ConfigManagerErrorCode, t_dwProblem ) ;
            }

            if( t_dwReqProps & USBHUB_PROP_Status )
            {
                CHString t_chsTmp;

				ConfigStatusToCimStatus ( t_dwStatus , t_chsTmp ) ;
                t_pInst->SetCHString(IDS_Status, t_chsTmp);
            }
        }
    }

    if( t_dwReqProps & USBHUB_PROP_ConfigManagerUserConfig )
    {
        t_pInst->SetDWORD( IDS_ConfigManagerUserConfig,
                               t_pDevice->IsUsingForcedConfig() ) ;
    }

    // Use the friendly name for caption and name
    if( t_dwReqProps & USBHUB_PROP_Caption || t_dwReqProps & USBHUB_PROP_Name )
    {
        if( t_pDevice->GetFriendlyName( t_chstrTemp ) )
        {
            t_pInst->SetCHString( IDS_Caption, t_chstrTemp ) ;
            t_pInst->SetCHString( IDS_Name, t_chstrTemp ) ;
        }
        else
        {
            // If we can't get the name, settle for the description
            if( t_chstrDesc.GetLength() > 0 )
            {
                t_pInst->SetCHString( IDS_Caption, t_chstrDesc ) ;
                t_pInst->SetCHString( IDS_Name, t_chstrDesc ) ;
            }
        }
    }
    return t_hResult;
}

/*****************************************************************************
 *
 *  FUNCTION    : CWin32USBHub::IsOneOfMe
 *
 *  DESCRIPTION : Checks to make sure pDevice is a hub and not some
 *                other type of USB device.
 *
 *  INPUTS      : void *a_pv - The device to check.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : HRESULT       error/success code.
 *
 *  COMMENTS    :
 *
 *****************************************************************************/
bool CWin32USBHub::IsOneOfMe
(
    void *a_pv
)
{
    bool t_fRet = false;

    if( NULL != a_pv )
    {
        CConfigMgrDevice *t_pDevice = ( CConfigMgrDevice * ) a_pv ;

		// Is it a usb device?
        if( t_pDevice->IsClass( L"USB" ) )
        {
            // Now to find out if this is a usb hub
            CConfigMgrDevicePtr t_pParentDevice;

			if( t_pDevice->GetParent( &t_pParentDevice ) )
            {
                if( t_pParentDevice->IsClass( L"USB" ) )
                {
                    t_fRet = true ;
                }
            }
        }
    }
    return t_fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\win32_controllerhashub.cpp ===
//=================================================================

//

// Win32_ControllerHasHub.cpp -- Controller to usb hub assoc

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <Binding.h>
#include <ConfgMgr.h>
#include "Win32_ControllerHasHub.h"

CContHasHub::CContHasHub(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName,

    LPCWSTR pwszLeftBindingPropertyName,
    LPCWSTR pwszRightBindingPropertyName

) : CBinding (

    pwszClassName,
    pwszNamespaceName,
    pwszLeftClassName,
    pwszRightClassName,
    pwszLeftPropertyName,
    pwszRightPropertyName,
    pwszLeftBindingPropertyName,
    pwszRightBindingPropertyName
)
{
}

CContHasHub UserToDomain(
    L"Win32_ControllerHasHub",
    IDS_CimWin32Namespace,
    L"Win32_USBController",
    L"Win32_USBHub",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_DeviceID,
    IDS_DeviceID
);

bool CContHasHub::AreRelated(

    const CInstance *pLeft, 
    const CInstance *pRight
)
{
    // Ok, at this point, we know pLeft is a usb controller and pRight
    // is a usb hub.  The only question left is whether the usb controller
    // is controlling this specific hub.

    bool bRet = false;
    CHString sHub;

    pRight->GetCHString(IDS_DeviceID, sHub);

    CConfigManager cfgmgr;
    CConfigMgrDevicePtr pDevice, pParentDevice;

    if ( cfgmgr.LocateDevice ( sHub , &pDevice ) )
    {
        CHString sController, sDeviceID;

        pLeft->GetCHString(IDS_DeviceID, sController);

        while (pDevice->GetParent( &pParentDevice ))
        {
            pParentDevice->GetDeviceID(sDeviceID);

            if (sDeviceID.CompareNoCase(sController) == 0)
            {
                bRet = true;
                break;
            }
            else
            {
                pDevice = pParentDevice;
            }
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\cimwin32a\win32_controllerhashub.h ===
//=================================================================

//

// Win32_ControllerHasHub.h -- Controller to usb hub assoc

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include "assoc.h"

#define MAX_ORS 3

class CContHasHub : public CBinding
{
    public:

        CContHasHub(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName,

            LPCWSTR pwszLeftBindingPropertyName,
            LPCWSTR pwszRightBindingPropertyName
        );

        virtual ~CContHasHub() {}

    protected:

        virtual bool AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        );

        // We need to disable this
        virtual void MakeWhere(

            CHStringArray &sRightPaths,
            CHStringArray &sRightWheres
            ) {}

        // We need to disable this
        virtual HRESULT FindWhere(

            TRefPointerCollection<CInstance> &lefts,
            CHStringArray &sLeftWheres
            ) { return WBEM_S_NO_ERROR; }

//-----------

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\accessentry.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntry.h - header file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CACCESSENTRY_H__
#define __CACCESSENTRY_H__

#include "Sid.h"			// CSid class

#define ALL_ACCESS_WITHOUT_GENERIC	0x01FFFFFF	// all possible access rights
												// without generic

// This is an NT 5 flag that we will use to tell us that an ACE although read out, should
// NOT be written back.  It was copied from the NT 5 WINNT.H, since we are not building
// using that file.

#define INHERITED_ACE                     (0x10)

//////////////////////////////////////////////////////////////////
//
//	Class: CAccessEntry
//
//	Class to encapsulate Windows NT ACE information.  It basically
//	acts as a repository for a SID, and access information.
//
//////////////////////////////////////////////////////////////////

class CAccessEntry
{
	// Constructors and destructor
	public:
		CAccessEntry();

		CAccessEntry( PSID pSid,
				BYTE bACEType, BYTE bACEFlags,
                GUID *pguidObjType, GUID *pguidInhObjType,
				DWORD dwAccessMask = ALL_ACCESS_WITHOUT_GENERIC,
				LPCTSTR pszComputerName = NULL );

        CAccessEntry( PSID pSid,
				BYTE bACEType, BYTE bACEFlags,
                GUID *pguidObjType, GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName,
                bool fLookup );

		CAccessEntry( const CSid& sid,
				BYTE bACEType, BYTE bACEFlags,
                GUID *pguidObjType, GUID *pguidInhObjType,
				DWORD dwAccessMask = ALL_ACCESS_WITHOUT_GENERIC,
				LPCTSTR pszComputerName = NULL );

		CAccessEntry( LPCTSTR pszAccountName,
				BYTE bACEType, BYTE bACEFlags,
                GUID *pguidObjType, GUID *pguidInhObjType,
				DWORD dwAccessMask = ALL_ACCESS_WITHOUT_GENERIC,
				LPCTSTR pszComputerName = NULL );

		CAccessEntry( const CAccessEntry &r_AccessEntry );
		~CAccessEntry( void );

		CAccessEntry &	operator= ( const CAccessEntry & );
		bool operator== ( const CAccessEntry & );

		BOOL IsEqualToSID( PSID psid );
		void GetSID( CSid& sid );
		DWORD GetAccessMask( void );
		BYTE GetACEType( void );
		BYTE GetACEFlags( void );
        bool GetObjType(GUID &guidObjType);
        bool GetInhObjType(GUID &guidInhObjType);

		void SetAccessMask( DWORD dwAccessMask );
		void MergeAccessMask( DWORD dwMergeMask );
		void SetACEFlags( BYTE bACEFlags );
		void SetSID( CSid& sid );
		void SetACEType( BYTE aceType );
        void SetObjType(GUID &guidObjType);
        void SetInhObjType(GUID &guidInhObjType);

		BOOL AllocateACE( ACE_HEADER** ppACEHeader );
		void FreeACE( ACE_HEADER* pACEHeader );

		bool IsInherited( void );
        bool IsAllowed();
        bool IsDenied();

        void DumpAccessEntry(LPCWSTR wstrFilename = NULL);

	private:
		CSid		m_Sid;
		DWORD		m_dwAccessMask;
		BYTE		m_bACEType;
		BYTE		m_bACEFlags;
        GUID       *m_pguidObjType;
        GUID       *m_pguidInhObjType;

	

};

inline void CAccessEntry::GetSID( CSid& sid )
{
	sid = m_Sid;
}

inline void CAccessEntry::SetSID( CSid& sid )
{
	m_Sid = sid;
}

inline BOOL CAccessEntry::IsEqualToSID( PSID psid )
{
	return EqualSid( psid, m_Sid.GetPSid() );
}

inline DWORD CAccessEntry::GetAccessMask( void )
{
	return m_dwAccessMask;
}

inline BYTE CAccessEntry::GetACEType( void )
{
	return m_bACEType;
}

inline void CAccessEntry::SetACEType( BYTE aceType )
{
	m_bACEType = aceType;
}

inline BYTE CAccessEntry::GetACEFlags( void )
{
	return m_bACEFlags;
}

inline void CAccessEntry::SetAccessMask( DWORD dwAccessMask )
{
	m_dwAccessMask = dwAccessMask;
}

inline void CAccessEntry::MergeAccessMask( DWORD dwMergeMask )
{
	m_dwAccessMask |= dwMergeMask;
}

inline void CAccessEntry::SetACEFlags( BYTE bACEFlags )
{
	m_bACEFlags = bACEFlags;
}


inline bool CAccessEntry::GetObjType(GUID &guidObjType)
{
    bool fRet = false;
    if(m_pguidObjType != NULL)
    {
        memcpy(&guidObjType, m_pguidObjType, sizeof(GUID));
        fRet = true;
    }
    return fRet;
}

inline void CAccessEntry::SetObjType(GUID &guidObjType)
{
    if(m_pguidObjType == NULL)
    {
        try
        {
            m_pguidObjType = new GUID;   
        }
        catch(...)
        {
            if(m_pguidObjType != NULL)
            {
                delete m_pguidObjType;
                m_pguidObjType = NULL;
            }
            throw;
        }
    }
    if(m_pguidObjType != NULL)
    {
        memcpy(m_pguidObjType, &guidObjType, sizeof(GUID));
    }
}

inline bool CAccessEntry::GetInhObjType(GUID &guidObjType)
{
    bool fRet = false;
    if(m_pguidInhObjType != NULL)
    {
        memcpy(&guidObjType, m_pguidInhObjType, sizeof(GUID));
        fRet = true;
    }
    return fRet;
}

inline void CAccessEntry::SetInhObjType(GUID &guidInhObjType)
{
    if(m_pguidInhObjType == NULL)
    {
        try
        {
            m_pguidInhObjType = new GUID;   
        }
        catch(...)
        {
            if(m_pguidInhObjType != NULL)
            {
                delete m_pguidInhObjType;
                m_pguidInhObjType = NULL;
            }
            throw;
        }
    }
    if(m_pguidInhObjType != NULL)
    {
        memcpy(m_pguidInhObjType, &guidInhObjType, sizeof(GUID));
    }
}

inline void CAccessEntry::FreeACE( ACE_HEADER* pACEHeader )
{
	free( pACEHeader );
}

inline bool CAccessEntry::IsInherited( void )
{
	bool fRet = false;
    if(m_bACEFlags & INHERITED_ACE)
    {
        fRet = true;
    } 
    return fRet;
}

inline bool CAccessEntry::IsAllowed( void )
{
	bool fRet = false;
    if(( m_bACEType == ACCESS_ALLOWED_ACE_TYPE) ||
       ( m_bACEType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE) ||
       ( m_bACEType == ACCESS_ALLOWED_OBJECT_ACE_TYPE))
    {
        fRet = true;
    }
    return fRet;
}

inline bool CAccessEntry::IsDenied( void )
{
	bool fRet = false;
    if(( m_bACEType == ACCESS_DENIED_ACE_TYPE) ||
       ( m_bACEType == ACCESS_DENIED_OBJECT_ACE_TYPE))
    {
        fRet = true;
    }
    return fRet;
}

#endif // __CAccessEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\accessentrylist.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntryList.h - header file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CACCESSENTRYLIST_H__
#define __CACCESSENTRYLIST_H__

#include "AccessEntry.h"
#include "list"


//////////////////////////////////////////////////////////////////
//
//	Class: CAccessEntryList
//
//	Class to encapsulate Windows NT ACL data.  It basically
//	maintains a list of ACEs using an STL Linked List.  It provides
//	a series of public and protected functions to allow manipulation
//	of the list.  By keeping a large group of these functions
//	protected, we goofproof the class by not allowing public
//	users to manipulate our internal data.
//
//////////////////////////////////////////////////////////////////


// Used for front and end indeces

//#define	ACCESSENTRY_LIST_FRONT	(-1)
//#define	ACCESSENTRY_LIST_END	(-2)

// We will hide an ACLIter* as a DWORD
typedef	LPVOID	ACLPOSITION;

typedef std::list<CAccessEntry*>::iterator ACLIter;

// FOR ACE Filtering when Initializing from a PACL.  This value
// means ALL_ACE_TYPES

#define ALL_ACE_TYPES	0xFF

class CAccessEntryList
{
	// Constructors and destructor
	public:
		CAccessEntryList();
		CAccessEntryList( PACL pWin32ACL, bool fLookup = true);
		~CAccessEntryList( void );

		// The only public functions available allow enumeration
		// of entries, and emptying the list.

		bool BeginEnum( ACLPOSITION& pos );
		bool GetNext( ACLPOSITION& pos, CAccessEntry& ACE );
		void EndEnum( ACLPOSITION& pos );
		DWORD NumEntries( void );
		bool IsEmpty( void );
		void Clear( void );
		bool GetAt( DWORD nIndex, CAccessEntry& ace );

		// ACE Location helpers
		virtual bool Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );
		virtual bool Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );

		// Win32 ACL helpers
		BOOL CalculateWin32ACLSize( LPDWORD pdwACLSize );
		DWORD FillWin32ACL( PACL pACL );
		DWORD InitFromWin32ACL( PACL pWin32ACL, BYTE bACEFilter = ALL_ACE_TYPES, bool fLookup = true);

        void DumpAccessEntryList(LPCWSTR wstrFilename = NULL);

//	protected:

		// Only derived classes have access to modify our actual lists.
		void Add( CAccessEntry* pACE );
		void Append( CAccessEntry* pACE );
		ACLIter Find( CAccessEntry* pACE );
		CAccessEntry* Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, bool fLookup = true );
		CAccessEntry* Find( const CAccessEntry& ace );
		void Remove( CAccessEntry* pACE );
		bool SetAt( DWORD dwIndex, const CAccessEntry& ace );
		bool RemoveAt( DWORD dwIndex );

		// These two functions allow us to Add an entry either overwriting or merging
		// the access mask of a preexisting entry.

		bool AddNoDup( PSID psid, 
                       BYTE bACEType, 
                       BYTE bACEFlags, 
                       DWORD dwMask, 
                       GUID *pguidObjGuid, 
                       GUID *pguidInhObjGuid, 
                       bool fMerge = false );

		bool AppendNoDup( PSID psid, 
                          BYTE bACEType, 
                          BYTE bACEFlags, 
                          DWORD dwMask, 
                          GUID *pguidObjGuid, 
                          GUID *pguidInhObjGuid, 
                          bool fMerge = false );


        bool AppendNoDup( PSID psid, 
                          BYTE bACEType, 
                          BYTE bACEFlags, 
                          DWORD dwMask, 
                          GUID *pguidObjGuid, 
                          GUID *pguidInhObjGuid, 
                          bool fMerge,
                          bool fLookup);


		// The copy protection is protected so derived classes can
		// implement a typesafe equals operator
		bool Copy( CAccessEntryList& ACL );
		bool AppendList( CAccessEntryList& ACL );

		// For NT 5, we will need to handle ACEs separately, so use these
		// functions to copy lists inherited/noninherited ACEs into another list.
		bool CopyACEs( CAccessEntryList& ACL, BYTE bACEType );
		bool CopyInheritedACEs( CAccessEntryList& ACL, BYTE bACEType );
        // and use this one to copy lists allowed/denied into another list.
        bool CopyAllowedACEs(CAccessEntryList& ACL);
        bool CopyDeniedACEs(CAccessEntryList& ACL);
        bool CopyByACEType(CAccessEntryList& ACL, BYTE bACEType, bool fInherited);

		// Only let derived classes work with actual pointer values.  This way
		// public users can't 86 our internal memory.
		CAccessEntry* GetNext( ACLPOSITION& pos );


	private:

		std::list<CAccessEntry*>	m_ACL;

};

inline DWORD CAccessEntryList::NumEntries( void )
{
	return m_ACL.size();
}

inline bool CAccessEntryList::IsEmpty( void )
{
	return (m_ACL.empty() ? true : false);
}

#endif // __CAccessEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\accessrights.h ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/







//=================================================================

//

// AccessRights.CPP -- Base class for obtaining effective access

//                      rights.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/99    a-kevhu         Created
//
//=================================================================
#ifndef _CACCESSRIGHTS_H_
#define _CACCESSRIGHTS_H_

#ifdef NTONLY

#define AR_GENERIC_FAILURE  0x00010001
#define AR_BAD_SID          0x00010002
#define AR_ACL_EMPTY        0x00010003
#define AR_BAD_ACL          0x00010004

#define AR_RET_CODE         DWORD
#define USER                void*
#define USER_SPECIFIER      short

#define USER_IS_PSID        0
#define USER_IS_HANDLE      1


class CAccessRights
{
    public:

        // Constructors and destructor...
        CAccessRights(bool fUseCurThrTok = false);
        CAccessRights(const USER user, USER_SPECIFIER usp);
        CAccessRights(const USER psid, const PACL pacl, USER_SPECIFIER usp);
        CAccessRights(const PACL pacl, bool fUseCurThrTok = false);

        //CAccessRights(const CAccessRights &RAccessRights);

        ~CAccessRights();
        
        // Utility functions...
        bool SetUserToThisThread();
        bool SetUser(const USER user, USER_SPECIFIER usp);

        bool SetAcl(const PACL pacl);

        AR_RET_CODE GetEffectiveAccessRights(PACCESS_MASK pAccessMask); 
        
        DWORD GetError() { return m_dwError; }

        bool GetCSid(CSid &csid, bool fResolve = false);


    protected:
        DWORD m_dwError;
        
    private:

        bool InitTrustee(bool fInitFromCurrentThread, const HANDLE hToken = NULL);
        bool InitSidFromToken(const HANDLE hThreadToken);
        AR_RET_CODE FillEmptyPACL(PACL *paclNew);

        TRUSTEE m_trustee;
        CSid m_csid;
        CAccessEntryList m_ael;

};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\accessrights.cpp ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/





//=================================================================

//

// AccessRights.CPP -- Base class for obtaining effective access

//                      rights.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/99    a-kevhu         Created
//
//=================================================================


#include "precomp.h"


#ifdef NTONLY


#include <assertbreak.h>
#include "AdvApi32Api.h"
#include "accctrl.h"
#include "sid.h"
#include "AccessEntryList.h"
#include "AccessRights.h"

//==============================================================================
// CONSTRUCTORS AND DESTRUCTORS
//==============================================================================
// Default initialization...
CAccessRights::CAccessRights(bool fUseCurThrTok /* = false */)
: m_dwError(ERROR_SUCCESS)
{
    if(fUseCurThrTok)
    {
        // Initialize using the current thread token...
        InitTrustee(true);
    }
}

// Initialization specifying user only. Sid domain/account
// not resolved.  ACL uninitialized.
CAccessRights::CAccessRights(const USER user, USER_SPECIFIER usp)
:  m_dwError(ERROR_SUCCESS)
{
    if(usp == USER_IS_PSID)
    {
        m_csid = CSid((PSID)user, NULL, false);
        InitTrustee(false);
    }
    else if(usp == USER_IS_HANDLE)
    {
        ASSERT_BREAK(user != NULL);
        InitTrustee(false, (HANDLE)user);
    }
}

// Initialization of user and acl.  Sid domain/account
// not resolved. ACL initialized.
CAccessRights::CAccessRights(const USER user, const PACL pacl, USER_SPECIFIER usp)
: m_ael(pacl, false),
  m_dwError(ERROR_SUCCESS)
{
    if(usp == USER_IS_PSID)
    {
        m_csid = CSid((PSID)user, NULL, false);
        InitTrustee(false);
    }
    else if(usp == USER_IS_HANDLE)
    {
        ASSERT_BREAK(user != NULL);
        InitTrustee(false, (HANDLE)user);
    }
}


// Initialization of acl only.  ACL Sids not resolved.
CAccessRights::CAccessRights(const PACL pacl, bool fUseCurThrTok /* = false */)
: m_ael(pacl, false),
  m_dwError(ERROR_SUCCESS)
{
    if(fUseCurThrTok)
    {
        // Initialize using the current thread token...
        InitTrustee(true);
    }
}

// Copy constructor
/*  Not complete yet
CAccessRights::CAccessRights(const CAccessRights &RAccessRights)
{
    // Copy members.  We may or may not have either.
    if(RAccessRights.m_csid.IsValid() && RAccessRights.m_csid.IsOK())
    {
        m_csid = RAccessRights.m_csid;
    }
    m_ael.Clear();
    if(!RAccessRights.m_ael.IsEmpty())
    {
        // The best way to do this, to guarentee that the sids are not
        // resolved into domain/name, is to gat a PACL, then reinitialize
        // ourselves from it.
        PACL paclNew = NULL;
        try
        {
            if(RAccessRights.FillEmptyPACL(paclNew))
            {
                if(paclNew != NULL)
                {
                    if(!m_ael.InitFromWin32ACL(paclNew, ALL_ACE_TYPES, false))
                    {
                        // If something went wrong, clean
                        // up after ourselves.
                        m_ael.Clear();
                    }
                    delete paclNew;
                    paclNew = NULL;
                }
            }
        }
        catch(...)
        {
            if(paclNew != NULL)
            {
                delete paclNew;
                paclNew = NULL;
            }
            throw;
        }
    }
}
*/

// Destructor - members destruct themselves.
CAccessRights::~CAccessRights()
{
}


//==============================================================================
// UTILITY FUNCTIONS
//==============================================================================

AR_RET_CODE CAccessRights::GetEffectiveAccessRights(PACCESS_MASK pAccessMask)
{
    DWORD dwRet = AR_GENERIC_FAILURE;
    CAdvApi32Api *pAdvApi32 = NULL;
    PACL pacl = NULL;
    try
    {
        pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
        if(pAdvApi32 != NULL)
        {
            if((dwRet = FillEmptyPACL(&pacl)) == ERROR_SUCCESS)
            {
                ASSERT_BREAK(pacl != NULL);

                if(pacl != NULL)
                {
                    if(m_csid.IsValid() && m_csid.IsOK())
                    {
                        pAdvApi32->GetEffectiveRightsFromAclW(pacl,
                                                              &m_trustee,
                                                              pAccessMask,
                                                              &dwRet);
                    }
                    else
                    {
                        dwRet = AR_BAD_SID;
                    }
                    delete pacl;
                    pacl = NULL;
                }
            }
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
            pAdvApi32 = NULL;
        }
    }
    catch(...)
    {
        if(pacl != NULL)
        {
            delete pacl;
            pacl = NULL;
        }
        if(pAdvApi32 != NULL)
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
            pAdvApi32 = NULL;
        }
        throw;
    }
    return dwRet;
}

bool CAccessRights::InitTrustee(bool fInitFromCurrentThread, const HANDLE hToken)
{
    bool fRet = false;

    // The main thing done here is a sid is obtained and the TRUSTEE struct
    // filled in.

    if(fInitFromCurrentThread)
    {
        // Get the sid of the user/group of the current thread...
        SmartCloseHandle hThreadToken;
        if(::OpenThreadToken(::GetCurrentThread(), TOKEN_READ, FALSE, &hThreadToken))
        {
            InitSidFromToken(hThreadToken);
        }
    }
    else
    {
        // If we were given a hToken, use it instead...
        if(hToken != NULL)
        {
            InitSidFromToken(hToken);
        }
    }

    // We should now have a valid sid in our member CSid (either from the
    // InitSidFromToken calls or from construction).
    // Now we need to initialize the TRUSTEE object.  Check again that our sid
    // is in good standing...
    if(m_csid.IsValid() && m_csid.IsOK())
    {
        m_trustee.pMultipleTrustee = NULL;
        m_trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        m_trustee.TrusteeForm = TRUSTEE_IS_SID;
        m_trustee.TrusteeType = TRUSTEE_IS_UNKNOWN; // we could be operating
                                                    // on behalf of a user,
                                                    // group, well-known-group,
                                                    // who knows.

        m_trustee.ptstrName = (LPWSTR)m_csid.GetPSid();
        fRet = true;
    }
    else
    {
        m_dwError = AR_BAD_SID;
    }
    return fRet;
}


bool CAccessRights::InitSidFromToken(const HANDLE hThreadToken)
{
    bool fRet = false;

    if(hThreadToken != NULL)
    {
        DWORD dwLength = 0L;
        DWORD dwReqLength = 0L;
        PSID psid = NULL;
        LPVOID pBuff = NULL;
        if(!::GetTokenInformation(hThreadToken, TokenUser, NULL, 0, &dwReqLength))
        {
            if(::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // Allocate a buffer to hold the token info...
                try
                {
                    pBuff = new BYTE[dwReqLength];
                    if(pBuff != NULL)
                    {
                        dwLength = dwReqLength;
                        // Now that we have the right size buffer, call again...
                        if(::GetTokenInformation(hThreadToken,
                                                 TokenUser,
                                                 pBuff,
                                                 dwLength,
                                                 &dwReqLength))
                        {
                            if(pBuff != NULL)
                            {
                                TOKEN_USER *pTokUsr = (TOKEN_USER*)pBuff;
                                psid = pTokUsr->User.Sid;

                                ASSERT_BREAK((psid != NULL) && ::IsValidSid(psid));

	                            if((psid != NULL) && ::IsValidSid(psid))
	                            {
                                    m_csid = CSid(psid, NULL, false);
                                    fRet = true;
                                }
                                else
                                {
                                    m_dwError = AR_BAD_SID;
                                }
                            }
                        }
                        delete pBuff;
                        pBuff = NULL;
                    }
                }
                catch(...)
                {
                    if(pBuff != NULL)
                    {
                        delete pBuff;
                        pBuff = NULL;
                    }
                    throw;
                }
            }
        }
    }
    return fRet;
}


// Resets the user to the user to whom the current thread token belongs.
bool CAccessRights::SetUserToThisThread()
{
    return InitTrustee(true, NULL);
}

// Resets the user to the user specified by psid or handle
bool CAccessRights::SetUser(const USER user, USER_SPECIFIER usp)
{
    bool fRet = false;
    if(usp == USER_IS_PSID)
    {
        CSid csidTemp((PSID)user);
        if(csidTemp.IsValid() && csidTemp.IsOK())
        {
            m_csid = csidTemp;
            fRet = true;
        }
    }
    else if(usp == USER_IS_HANDLE)
    {
        fRet = InitSidFromToken((HANDLE)user);
    }
    return fRet;
}


// Resets the acl to the passed in PACL
bool CAccessRights::SetAcl(const PACL pacl)
{
    bool fRet = false;
    if(pacl != NULL)
    {
        m_ael.Clear();
        if(m_ael.InitFromWin32ACL(pacl, ALL_ACE_TYPES, false) == ERROR_SUCCESS)
        {
            fRet = true;
        }
    }
    return fRet;
}

// Gets us a filled out PACL, which must be freed by the caller, using delete.
AR_RET_CODE CAccessRights::FillEmptyPACL(PACL *paclOut)
{
    DWORD dwRet = AR_GENERIC_FAILURE;
    if(paclOut != NULL)
    {
        // The best way to do this, to guarentee that the sids are not
        // resolved into domain/name, is to get a PACL, then reinitialize
        // ourselves from it.
        DWORD dwAclSize = 0L;
        if(m_ael.NumEntries() > 0)
        {
            if(m_ael.CalculateWin32ACLSize(&dwAclSize))
            {
                if(dwAclSize > sizeof(ACL))
                {
                    PACL paclTemp = NULL;
                    try
                    {
                        paclTemp = (PACL) new BYTE[dwAclSize];
                        if(paclTemp != NULL)
                        {
                            ::InitializeAcl(paclTemp, dwAclSize, ACL_REVISION);
                            if((dwRet = m_ael.FillWin32ACL(paclTemp)) == ERROR_SUCCESS)
                            {
                                *paclOut = paclTemp;
                                dwRet = ERROR_SUCCESS;
                            }
                        }
                    }
                    catch(...)
                    {
                        if(paclTemp != NULL)
                        {
                            delete paclTemp;
                            paclTemp = NULL;
                        }
                        throw;
                    }
                }
                else
                {
                    dwRet = AR_ACL_EMPTY;
                }
            }
            else
            {
                dwRet = AR_BAD_ACL;
            }
        }
        else
        {
            dwRet = AR_ACL_EMPTY;
        }
    }
    return dwRet;
}


bool CAccessRights::GetCSid(CSid &csid, bool fResolve)
{
    bool fRet = false;
    if(m_dwError == ERROR_SUCCESS)
    {
        if(m_csid.IsValid() && m_csid.IsOK())
        {
            if(fResolve)
            {
                // Need to create a new one since ours doesn't
                // have account or domain name resolved.
                CSid csidTemp(m_csid.GetPSid());
                if(csidTemp.IsValid() && csidTemp.IsOK())
                {
                    csid = csidTemp;
                    fRet = true;
                }
            }
            else
            {
                csid = m_csid;
                fRet = true;
            }
        }
    }
    return fRet;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\advapi32api.h ===
//=================================================================

//

// AdvApi32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_ADVAPI32API_H_
#define	_ADVAPI32API_H_



#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmerr.h>
#include <ntsecapi.h>
#include <stack>
#include <comdef.h>
#include <dsrole.h> 
#include <dsgetdc.h>
#include <aclapi.h>

#include "DllUtils.h"
/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidAdvApi32Api;
extern const TCHAR g_tstrAdvApi32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_ENUMERATE_TRUSTED_DOMAINS)
(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_QUERY_INFORMATION_POLICY)
(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_NT_STATUS_TO_WIN_ERROR)
(
    IN NTSTATUS Status
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_FREE_MEMORY)
(
    IN PVOID Buffer
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_OPEN_POLICY)
(
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE PolicyHandle
);

typedef NTSTATUS (STDAPICALLTYPE *PFN_LSA_CLOSE)
(
    IN LSA_HANDLE ObjectHandle
);

typedef DWORD (WINAPI *PFN_SET_NAMED_SECURITY_INFO_W)
( 
    IN LPWSTR                pObjectName,
    IN SE_OBJECT_TYPE        ObjectType,
    IN SECURITY_INFORMATION  SecurityInfo,
    IN PSID                  psidOowner,
    IN PSID                  psidGroup,
    IN PACL                  pDacl,
    IN PACL                  pSacl
);

typedef DWORD (WINAPI *PFN_GET_NAMED_SECURITY_INFO_W)
(
	LPWSTR                 pObjectName,
    SE_OBJECT_TYPE         ObjectType,
    SECURITY_INFORMATION   SecurityInfo,
    PSID                  *ppsidOowner,
    PSID                  *ppsidGroup,
    PACL                  *ppDacl,
    PACL                  *ppSacl,
    PSECURITY_DESCRIPTOR  *ppSecurityDescriptor 
);

typedef BOOL (WINAPI *PFN_QUERY_SERVICE_STATUS_EX) 
(
    SC_HANDLE           hService,
    SC_STATUS_TYPE      InfoLevel,
    LPBYTE              lpBuffer,
    DWORD               cbBufSize,
    LPDWORD             pcbBytesNeeded
);

typedef BOOL  (WINAPI *PFN_DUPLICATE_TOKEN_EX ) 
(  
    HANDLE ,					        // handle to token to duplicate
    DWORD ,								// access rights of new token
    LPSECURITY_ATTRIBUTES ,				// security attributes of the new token
    SECURITY_IMPERSONATION_LEVEL ,		// impersonation level of new token
    TOKEN_TYPE ,						// primary or impersonation token
    PHANDLE                             // handle to duplicated token
);

typedef BOOL (WINAPI *PFN_SET_SECURITY_DESCRIPTOR_CONTROL)
(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
);

typedef BOOL (WINAPI *PFN_CONVERT_TO_AUTO_INHERIT_PRIVATE_OBJECT_SECURITY)
(
    IN PSECURITY_DESCRIPTOR ParentDescriptor,
    IN PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    IN GUID *ObjectType,
    IN BOOLEAN IsDirectoryObject,
    IN PGENERIC_MAPPING GenericMapping
);

typedef BOOL (WINAPI *PFN_DESTROY_PRIVATE_OBJECT_SECURITY)
(
    IN OUT PSECURITY_DESCRIPTOR * ObjectDescriptor
);

typedef DWORD (WINAPI *PFN_SET_NAMED_SECURITY_INFO_EX)
(
    IN    LPCTSTR              lpObject,
    IN    SE_OBJECT_TYPE       ObjectType,
    IN    SECURITY_INFORMATION SecurityInfo,
    IN    LPCTSTR              lpProvider,
    IN    PACTRL_ACCESS        pAccessList,
    IN    PACTRL_AUDIT         pAuditList,
    IN    LPTSTR               lpOwner,
    IN    LPTSTR               lpGroup,
    IN    PACTRL_OVERLAPPED    pOverlapped
);

typedef DWORD (WINAPI *PFN_GET_EXPLICIT_ENTRIES_FROM_ACL)
(
    IN  PACL                  pacl,
    OUT PULONG                pcCountOfExplicitEntries,
    OUT PEXPLICIT_ACCESS    * pListOfExplicitEntries
);
						
typedef BOOL (APIENTRY *PFN_CHECK_TOKEN_MEMBERSHIP)
(  
    IN HANDLE					TokenHandle OPTIONAL,
    IN PSID						SidToCheck,
    OUT PBOOL					IsMember
);

typedef BOOL (WINAPI *PFN_ADD_ACCESS_ALLOWED_OBJECT_ACE)
(
    IN OUT PACL pAcl,
    IN DWORD dwAceRevision,
    IN DWORD AceFlags,
    IN DWORD AccessMask,
    IN GUID *ObjectTypeGuid,
    IN GUID *InheritedObjectTypeGuid,
    IN PSID pSid
);

typedef BOOL (WINAPI *PFN_ADD_ACCESS_DENIED_OBJECT_ACE)
(
    IN OUT PACL pAcl,
    IN DWORD dwAceRevision,
    IN DWORD AceFlags,
    IN DWORD AccessMask,
    IN GUID *ObjectTypeGuid,
    IN GUID *InheritedObjectTypeGuid,
    IN PSID pSid
);

typedef BOOL (WINAPI *PFN_ADD_AUDIT_ACCESS_OBJECT_ACE)
(
    IN OUT PACL pAcl,
    IN DWORD dwAceRevision,
    IN DWORD AceFlags,
    IN DWORD AccessMask,
    IN GUID *ObjectTypeGuid,
    IN GUID *InheritedObjectTypeGuid,
    IN PSID pSid,
    IN BOOL bAuditSuccess,
    IN BOOL bAuditFailure
);

typedef DWORD (WINAPI *PFN_GET_EFFECTIVE_RIGHTS_FROM_ACL_W)
(
    IN  PACL          pacl,
    IN  PTRUSTEE_W    pTrustee,
    OUT PACCESS_MASK  pAccessRights
);





/******************************************************************************
 * Wrapper class for AdvApi32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CAdvApi32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    PFN_LSA_ENUMERATE_TRUSTED_DOMAINS   m_pfnLsaEnumerateTrustedDomains;
    PFN_LSA_QUERY_INFORMATION_POLICY    m_pfnLsaQueryInformationPolicy;
    PFN_LSA_NT_STATUS_TO_WIN_ERROR      m_pfnLsaNtStatusToWinError;
    PFN_LSA_FREE_MEMORY                 m_pfnLsaFreeMemory;
    PFN_LSA_OPEN_POLICY                 m_pfnLsaOpenPolicy;
    PFN_LSA_CLOSE                       m_pfnLsaClose;
    PFN_SET_NAMED_SECURITY_INFO_W       m_pfnSetNamedSecurityInfoW;
    PFN_GET_NAMED_SECURITY_INFO_W       m_pfnGetNamedSecurityInfoW;
    PFN_QUERY_SERVICE_STATUS_EX         m_pfnQueryServiceStatusEx;
    PFN_DUPLICATE_TOKEN_EX              m_pfnDuplicateTokenEx;
    PFN_SET_SECURITY_DESCRIPTOR_CONTROL m_pfnSetSecurityDescriptorControl;
    PFN_CONVERT_TO_AUTO_INHERIT_PRIVATE_OBJECT_SECURITY m_pfnConvertToAutoInheritPrivateObjectSecurity;
    PFN_DESTROY_PRIVATE_OBJECT_SECURITY m_pfnDestroyPrivateObjectSecurity;
    PFN_SET_NAMED_SECURITY_INFO_EX      m_pfnSetNamedSecurityInfoEx;
    PFN_GET_EXPLICIT_ENTRIES_FROM_ACL   m_pfnGetExplicitEntriesFromAcl;
	PFN_CHECK_TOKEN_MEMBERSHIP			m_pfnCheckTokenMembership;
    PFN_ADD_ACCESS_ALLOWED_OBJECT_ACE   m_pfnAddAccessAllowedObjectAce;
    PFN_ADD_ACCESS_DENIED_OBJECT_ACE    m_pfnAddAccessDeniedObjectAce;
    PFN_ADD_AUDIT_ACCESS_OBJECT_ACE     m_pfnAddAuditAccessObjectAce;
    PFN_GET_EFFECTIVE_RIGHTS_FROM_ACL_W m_pfnGetEffectiveRightsFromAclW;

public:

    // Constructor and destructor:
    CAdvApi32Api(LPCTSTR a_tstrWrappedDllName);
    ~CAdvApi32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping kernel32 functions.
    // Add new functions here as required:
    NTSTATUS LsaEnumerateTrustedDomains
    (
        LSA_HANDLE a_PolicyHandle,
        PLSA_ENUMERATION_HANDLE a_EnumerationContext,
        PVOID *a_Buffer,
        ULONG a_PreferedMaximumLength,
        PULONG a_CountReturned
    );

    NTSTATUS LsaQueryInformationPolicy
    (
        LSA_HANDLE a_PolicyHandle,
        POLICY_INFORMATION_CLASS a_InformationClass,
        PVOID *a_Buffer
    );

    NTSTATUS LsaNtStatusToWinError
    (
        NTSTATUS a_Status
    );

    NTSTATUS LsaFreeMemory
    (
        PVOID a_Buffer
    );

    NTSTATUS LsaOpenPolicy
    (
        PLSA_UNICODE_STRING a_SystemName,
        PLSA_OBJECT_ATTRIBUTES a_ObjectAttributes,
        ACCESS_MASK a_DesiredAccess,
        PLSA_HANDLE a_PolicyHandle
    );

    NTSTATUS LsaClose
    (
        LSA_HANDLE a_ObjectHandle
    );

    bool SetNamedSecurityInfoW
    ( 
        LPWSTR                a_pObjectName,
        SE_OBJECT_TYPE        a_ObjectType,
        SECURITY_INFORMATION  a_SecurityInfo,
        PSID                  a_psidOowner,
        PSID                  a_psidGroup,
        PACL                  a_pDacl,
        PACL                  a_pSacl,
        DWORD                *a_dwRetval 
    );

    bool GetNamedSecurityInfoW
    (
	    LPWSTR                 a_pObjectName,
        SE_OBJECT_TYPE         a_ObjectType,
        SECURITY_INFORMATION   a_SecurityInfo,
        PSID                  *a_ppsidOowner,
        PSID                  *a_ppsidGroup,
        PACL                  *a_ppDacl,
        PACL                  *a_ppSacl,
        PSECURITY_DESCRIPTOR  *a_ppSecurityDescriptor,
        DWORD                 *a_dwRetval  
    );

    bool QueryServiceStatusEx 
    (
        SC_HANDLE       a_hService,
        SC_STATUS_TYPE  a_InfoLevel,
        LPBYTE          a_lpBuffer,
        DWORD           a_cbBufSize,
        LPDWORD         a_pcbBytesNeeded,
        BOOL           *a_fRetval 
    );

    bool DuplicateTokenEx 
    (  
        HANDLE a_h,					        // handle to token to duplicate
        DWORD a_dw,							// access rights of new token
        LPSECURITY_ATTRIBUTES a_lpsa,		// security attributes of the new token
        SECURITY_IMPERSONATION_LEVEL a_sil,	// impersonation level of new token
        TOKEN_TYPE a_tt,					// primary or impersonation token
        PHANDLE a_ph,                       // handle to duplicated token
        BOOL *a_fRetval                     // encapsulated function return value
    );

    bool SetSecurityDescriptorControl
    (
        PSECURITY_DESCRIPTOR pSecurityDescriptor,
        SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
        SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet,
        BOOL *a_fRetval
    );

    bool ConvertToAutoInheritPrivateObjectSecurity
    (
        PSECURITY_DESCRIPTOR a_ParentDescriptor,
        PSECURITY_DESCRIPTOR a_CurrentSecurityDescriptor,
        PSECURITY_DESCRIPTOR *a_NewSecurityDescriptor,
        GUID *a_ObjectType,
        BOOLEAN a_IsDirectoryObject,
        PGENERIC_MAPPING a_GenericMapping,
        BOOL *a_fRetval
    );

    bool DestroyPrivateObjectSecurity
    (
        PSECURITY_DESCRIPTOR *a_ObjectDescriptor,
        BOOL *a_fRetval
    );

    bool SetNamedSecurityInfoEx
    (
        LPCTSTR              a_lpObject,
        SE_OBJECT_TYPE       a_ObjectType,
        SECURITY_INFORMATION a_SecurityInfo,
        LPCTSTR              a_lpProvider,
        PACTRL_ACCESS        a_pAccessList,
        PACTRL_AUDIT         a_pAuditList,
        LPTSTR               a_lpOwner,
        LPTSTR               a_lpGroup,
        PACTRL_OVERLAPPED    a_pOverlapped,
        DWORD               *a_dwRetval
    );

    bool GetExplicitEntriesFromAcl
    (
        PACL                  a_pacl,
        PULONG                a_pcCountOfExplicitEntries,
        PEXPLICIT_ACCESS     *a_pListOfExplicitEntries,
        DWORD                *a_dwRetval
    );
	
	bool CheckTokenMembership 
	(
		HANDLE a_hTokenHandle OPTIONAL,
		PSID a_pSidToCheck,
		PBOOL a_pfIsMember,
		BOOL *a_fRetval
    );

    bool AddAccessAllowedObjectAce
    (
        PACL  a_pAcl,
        DWORD a_dwAceRevision,
        DWORD a_AceFlags,
        DWORD a_AccessMask,
        GUID  *a_ObjectTypeGuid,
        GUID  *a_InheritedObjectTypeGuid,
        PSID  a_pSid,
        BOOL  *a_fRetval
    );

    bool AddAccessDeniedObjectAce 
    (
        PACL  a_pAcl,
        DWORD a_dwAceRevision,
        DWORD a_AceFlags,
        DWORD a_AccessMask,
        GUID  *a_ObjectTypeGuid,
        GUID  *a_InheritedObjectTypeGuid,
        PSID  a_pSid,
        BOOL  *a_fRetval
    );

    bool AddAuditAccessObjectAce
    (
        PACL  a_pAcl,
        DWORD a_dwAceRevision,
        DWORD a_AceFlags,
        DWORD a_AccessMask,
        GUID  *a_ObjectTypeGuid,
        GUID  *a_InheritedObjectTypeGuid,
        PSID  a_pSid,
        BOOL  a_bAuditSuccess,
        BOOL  a_bAuditFailure,
        BOOL  *a_fRetval
    );

    bool GetEffectiveRightsFromAclW
    (
        PACL          a_pacl,
        PTRUSTEE_W    a_pTrustee,
        PACCESS_MASK  a_pAccessRights,
        DWORD         *a_dwRetval
    );

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\advapi32api.cpp ===
//=================================================================

//

// AdvApi32Api.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "AdvApi32Api.h"
#include "DllWrapperCreatorReg.h"
#include <CreateMutexAsProcess.h>


// {15E4C152-D051-11d2-911F-0060081A46FD}
static const GUID g_guidAdvApi32Api =
{0x15e4c152, 0xd051, 0x11d2, {0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};


static const TCHAR g_tstrAdvApi32[] = _T("ADVAPI32.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CAdvApi32Api, &g_guidAdvApi32Api, g_tstrAdvApi32> MyRegisteredAdvApi32Wrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CAdvApi32Api::CAdvApi32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnLsaEnumerateTrustedDomains(NULL),
   m_pfnLsaQueryInformationPolicy(NULL),
   m_pfnLsaNtStatusToWinError(NULL),
   m_pfnLsaFreeMemory(NULL),
   m_pfnLsaOpenPolicy(NULL),
   m_pfnLsaClose(NULL),
   m_pfnSetNamedSecurityInfoW(NULL),
   m_pfnGetNamedSecurityInfoW(NULL),
   m_pfnQueryServiceStatusEx(NULL),
   m_pfnDuplicateTokenEx(NULL),
   m_pfnSetSecurityDescriptorControl(NULL),
   m_pfnConvertToAutoInheritPrivateObjectSecurity(NULL),
   m_pfnDestroyPrivateObjectSecurity(NULL),
   m_pfnSetNamedSecurityInfoEx(NULL),
   m_pfnGetExplicitEntriesFromAcl(NULL),
   m_pfnCheckTokenMembership(NULL),
   m_pfnAddAccessAllowedObjectAce(NULL),
   m_pfnAddAccessDeniedObjectAce(NULL),
   m_pfnAddAuditAccessObjectAce(NULL),
   m_pfnGetEffectiveRightsFromAclW(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CAdvApi32Api::~CAdvApi32Api()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CAdvApi32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnLsaEnumerateTrustedDomains = (PFN_LSA_ENUMERATE_TRUSTED_DOMAINS)
                                  GetProcAddress("LsaEnumerateTrustedDomains");
        m_pfnLsaQueryInformationPolicy = (PFN_LSA_QUERY_INFORMATION_POLICY)
                                   GetProcAddress("LsaQueryInformationPolicy");
        m_pfnLsaNtStatusToWinError = (PFN_LSA_NT_STATUS_TO_WIN_ERROR)
                                       GetProcAddress("LsaNtStatusToWinError");
        m_pfnLsaFreeMemory = (PFN_LSA_FREE_MEMORY)
                                               GetProcAddress("LsaFreeMemory");
        m_pfnLsaOpenPolicy = (PFN_LSA_OPEN_POLICY)
                                               GetProcAddress("LsaOpenPolicy");
        m_pfnLsaClose = (PFN_LSA_CLOSE) GetProcAddress("LsaClose");

#ifdef NTONLY
        // These functions are only on NT 4 and later
        m_pfnQueryServiceStatusEx = (PFN_QUERY_SERVICE_STATUS_EX)
                                        GetProcAddress("QueryServiceStatusEx");

        m_pfnDuplicateTokenEx = (PFN_DUPLICATE_TOKEN_EX)
                                            GetProcAddress("DuplicateTokenEx");
        // These functions is only on NT 5 or later only
        m_pfnSetSecurityDescriptorControl = (PFN_SET_SECURITY_DESCRIPTOR_CONTROL)
                                GetProcAddress("SetSecurityDescriptorControl");

        m_pfnConvertToAutoInheritPrivateObjectSecurity = (PFN_CONVERT_TO_AUTO_INHERIT_PRIVATE_OBJECT_SECURITY)
                                GetProcAddress("ConvertToAutoInheritPrivateObjectSecurity");

        m_pfnDestroyPrivateObjectSecurity = (PFN_DESTROY_PRIVATE_OBJECT_SECURITY)
                                GetProcAddress("DestroyPrivateObjectSecurity");

		m_pfnCheckTokenMembership = (PFN_CHECK_TOKEN_MEMBERSHIP)
								GetProcAddress("CheckTokenMembership");

        m_pfnAddAccessAllowedObjectAce = (PFN_ADD_ACCESS_ALLOWED_OBJECT_ACE)
                                GetProcAddress("AddAccessAllowedObjectAce");

        m_pfnAddAccessDeniedObjectAce = (PFN_ADD_ACCESS_DENIED_OBJECT_ACE)
                                GetProcAddress("AddAccessDeniedObjectAce");

        m_pfnAddAuditAccessObjectAce = (PFN_ADD_AUDIT_ACCESS_OBJECT_ACE)
                                GetProcAddress("AddAuditAccessObjectAce");

#if ((defined UNICODE) || (defined _UNICODE))
        m_pfnSetNamedSecurityInfoW = (PFN_SET_NAMED_SECURITY_INFO_W)
                                       GetProcAddress("SetNamedSecurityInfoW");

        m_pfnGetNamedSecurityInfoW = (PFN_GET_NAMED_SECURITY_INFO_W)
                                       GetProcAddress("GetNamedSecurityInfoW");

        m_pfnSetNamedSecurityInfoEx = (PFN_SET_NAMED_SECURITY_INFO_EX)
                                GetProcAddress("SetNamedSecurityInfoExW");

        m_pfnGetExplicitEntriesFromAcl = (PFN_GET_EXPLICIT_ENTRIES_FROM_ACL)
                                GetProcAddress("GetExplicitEntriesFromAclW");

        m_pfnGetEffectiveRightsFromAclW = (PFN_GET_EFFECTIVE_RIGHTS_FROM_ACL_W)
                                GetProcAddress("GetEffectiveRightsFromAclW");
#else
        m_pfnSetNamedSecurityInfoEx = (PFN_SET_NAMED_SECURITY_INFO_EX)
                                GetProcAddress("SetNamedSecurityInfoExA");

        m_pfnGetExplicitEntriesFromAcl = (PFN_GET_EXPLICIT_ENTRIES_FROM_ACL)
                                GetProcAddress("GetExplicitEntriesFromAclA");
#endif

#endif


        // These functions are considered essential to all versions of this
        // dll; therefore, if any are not found, return false.
        if(m_pfnLsaEnumerateTrustedDomains == NULL  ||
           m_pfnLsaQueryInformationPolicy == NULL ||
           m_pfnLsaNtStatusToWinError == NULL ||
           m_pfnLsaFreeMemory == NULL ||
           m_pfnLsaOpenPolicy == NULL ||
           m_pfnLsaClose == NULL)
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in AdvApi32Api");
        }
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping AdvApi32 api functions. Add new functions here
 * as required.
 ******************************************************************************/
NTSTATUS CAdvApi32Api::LsaEnumerateTrustedDomains
(
    LSA_HANDLE a_PolicyHandle,
    PLSA_ENUMERATION_HANDLE a_EnumerationContext,
    PVOID *a_Buffer,
    ULONG a_PreferedMaximumLength,
    PULONG a_CountReturned
)
{
    return m_pfnLsaEnumerateTrustedDomains(a_PolicyHandle, a_EnumerationContext,
                                           a_Buffer, a_PreferedMaximumLength,
                                           a_CountReturned);
}

NTSTATUS CAdvApi32Api::LsaQueryInformationPolicy
(
    LSA_HANDLE a_PolicyHandle,
    POLICY_INFORMATION_CLASS a_InformationClass,
    PVOID *a_Buffer
)
{
    return m_pfnLsaQueryInformationPolicy(a_PolicyHandle, a_InformationClass,
                                          a_Buffer);
}

NTSTATUS CAdvApi32Api::LsaNtStatusToWinError
(
    NTSTATUS a_Status
)
{
    return m_pfnLsaNtStatusToWinError(a_Status);
}

NTSTATUS CAdvApi32Api::LsaFreeMemory
(
    PVOID a_Buffer
)
{
    return m_pfnLsaFreeMemory(a_Buffer);
}

NTSTATUS CAdvApi32Api::LsaOpenPolicy
(
    PLSA_UNICODE_STRING a_SystemName,
    PLSA_OBJECT_ATTRIBUTES a_ObjectAttributes,
    ACCESS_MASK a_DesiredAccess,
    PLSA_HANDLE a_PolicyHandle
)
{
    return m_pfnLsaOpenPolicy(a_SystemName, a_ObjectAttributes,
                              a_DesiredAccess, a_PolicyHandle);
}

NTSTATUS CAdvApi32Api::LsaClose
(
    LSA_HANDLE a_ObjectHandle
)
{
    return m_pfnLsaClose(a_ObjectHandle);
}

bool CAdvApi32Api::SetNamedSecurityInfoW
(
    IN LPWSTR                a_pObjectName,
    IN SE_OBJECT_TYPE        a_ObjectType,
    IN SECURITY_INFORMATION  a_SecurityInfo,
    IN PSID                  a_psidOowner,
    IN PSID                  a_psidGroup,
    IN PACL                  a_pDacl,
    IN PACL                  a_pSacl,
    DWORD                   *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnSetNamedSecurityInfoW != NULL)
    {
        DWORD t_dwTemp = m_pfnSetNamedSecurityInfoW(a_pObjectName,
                                     a_ObjectType,
                                     a_SecurityInfo,
                                     a_psidOowner,
                                     a_psidGroup,
                                     a_pDacl,
                                     a_pSacl);

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::GetNamedSecurityInfoW
(
	LPWSTR                 a_pObjectName,
    SE_OBJECT_TYPE         a_ObjectType,
    SECURITY_INFORMATION   a_SecurityInfo,
    PSID                  *a_ppsidOowner,
    PSID                  *a_ppsidGroup,
    PACL                  *a_ppDacl,
    PACL                  *a_ppSacl,
    PSECURITY_DESCRIPTOR  *a_ppSecurityDescriptor,
    DWORD                 *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnGetNamedSecurityInfoW != NULL)
    {
        DWORD t_dwTemp;
        {
#ifdef NTONLY
#if NTONLY < 5
            // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
    		CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
#endif
#endif
            t_dwTemp = m_pfnGetNamedSecurityInfoW(a_pObjectName,
                                                  a_ObjectType,
                                                  a_SecurityInfo,
                                                  a_ppsidOowner,
                                                  a_ppsidGroup,
                                                  a_ppDacl,
                                                  a_ppSacl,
                                                  a_ppSecurityDescriptor);
        }

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}


bool CAdvApi32Api::QueryServiceStatusEx
(
    SC_HANDLE       a_hService,
    SC_STATUS_TYPE  a_InfoLevel,
    LPBYTE          a_lpBuffer,
    DWORD           a_cbBufSize,
    LPDWORD         a_pcbBytesNeeded,
    BOOL           *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnQueryServiceStatusEx != NULL)
    {
        BOOL t_fTemp = m_pfnQueryServiceStatusEx(a_hService,
                                     a_InfoLevel,
                                     a_lpBuffer,
                                     a_cbBufSize,
                                     a_pcbBytesNeeded);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::DuplicateTokenEx
(
    HANDLE a_h,					        // handle to token to duplicate
    DWORD a_dw,							// access rights of new token
    LPSECURITY_ATTRIBUTES a_lpsa,		// security attributes of the new token
    SECURITY_IMPERSONATION_LEVEL a_sil,	// impersonation level of new token
    TOKEN_TYPE a_tt,					// primary or impersonation token
    PHANDLE a_ph,                       // handle to duplicated token
    BOOL *a_fRetval                      // encapsulated function return value
)
{
    bool t_fExists = false;
    if(m_pfnDuplicateTokenEx != NULL)
    {
        BOOL t_fTemp = m_pfnDuplicateTokenEx(a_h, a_dw, a_lpsa,
                                             a_sil, a_tt, a_ph);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}


bool CAdvApi32Api::SetSecurityDescriptorControl
(
    PSECURITY_DESCRIPTOR a_pSecurityDescriptor,
    SECURITY_DESCRIPTOR_CONTROL a_ControlBitsOfInterest,
    SECURITY_DESCRIPTOR_CONTROL a_ControlBitsToSet,
    BOOL *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnSetSecurityDescriptorControl != NULL)
    {
        BOOL t_fTemp = m_pfnSetSecurityDescriptorControl(a_pSecurityDescriptor,
                                                         a_ControlBitsOfInterest,
                                                         a_ControlBitsToSet);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::ConvertToAutoInheritPrivateObjectSecurity
(
    PSECURITY_DESCRIPTOR a_ParentDescriptor,
    PSECURITY_DESCRIPTOR a_CurrentSecurityDescriptor,
    PSECURITY_DESCRIPTOR *a_NewSecurityDescriptor,
    GUID *a_ObjectType,
    BOOLEAN a_IsDirectoryObject,
    PGENERIC_MAPPING a_GenericMapping,
    BOOL *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnConvertToAutoInheritPrivateObjectSecurity != NULL)
    {
        BOOL t_fTemp = m_pfnConvertToAutoInheritPrivateObjectSecurity(a_ParentDescriptor,
                                                         a_CurrentSecurityDescriptor,
                                                         a_NewSecurityDescriptor,
                                                         a_ObjectType,
                                                         a_IsDirectoryObject,
                                                         a_GenericMapping);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::DestroyPrivateObjectSecurity
(
    PSECURITY_DESCRIPTOR *a_ObjectDescriptor,
    BOOL *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnDestroyPrivateObjectSecurity != NULL)
    {
        BOOL t_fTemp = m_pfnDestroyPrivateObjectSecurity(a_ObjectDescriptor);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::SetNamedSecurityInfoEx
(
    LPCTSTR              a_lpObject,
    SE_OBJECT_TYPE       a_ObjectType,
    SECURITY_INFORMATION a_SecurityInfo,
    LPCTSTR              a_lpProvider,
    PACTRL_ACCESS        a_pAccessList,
    PACTRL_AUDIT         a_pAuditList,
    LPTSTR               a_lpOwner,
    LPTSTR               a_lpGroup,
    PACTRL_OVERLAPPED    a_pOverlapped,
    DWORD               *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnSetNamedSecurityInfoEx != NULL)
    {
        DWORD t_dwTemp = m_pfnSetNamedSecurityInfoEx(a_lpObject,a_ObjectType,
                                                     a_SecurityInfo,a_lpProvider,
                                                     a_pAccessList,a_pAuditList,
                                                     a_lpOwner,a_lpGroup,
                                                     a_pOverlapped);

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::GetExplicitEntriesFromAcl
(
    PACL                  a_pacl,
    PULONG                a_pcCountOfExplicitEntries,
    PEXPLICIT_ACCESS     *a_pListOfExplicitEntries,
    DWORD                *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnGetExplicitEntriesFromAcl != NULL)
    {
        DWORD t_dwTemp = m_pfnGetExplicitEntriesFromAcl(a_pacl,
                                                        a_pcCountOfExplicitEntries,
                                                        a_pListOfExplicitEntries);

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::CheckTokenMembership
(
		HANDLE a_hTokenHandle OPTIONAL,
		PSID a_pSidToCheck,
		PBOOL a_pfIsMember,
		BOOL *a_fRetval
)
{
	bool t_fExists = false;
	if(m_pfnCheckTokenMembership)
	{
		t_fExists = true;
		BOOL t_fRet = m_pfnCheckTokenMembership(a_hTokenHandle,
		                                        a_pSidToCheck,
		                                        a_pfIsMember);
		if(a_fRetval)
		{
			*a_fRetval = t_fRet;
		}
	}
	return t_fExists ;
}

bool CAdvApi32Api::AddAccessAllowedObjectAce
(
    PACL  a_pAcl,
    DWORD a_dwAceRevision,
    DWORD a_AceFlags,
    DWORD a_AccessMask,
    GUID  *a_ObjectTypeGuid,
    GUID  *a_InheritedObjectTypeGuid,
    PSID  a_pSid,
    BOOL  *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnAddAccessAllowedObjectAce != NULL)
    {
        BOOL t_fTemp = m_pfnAddAccessAllowedObjectAce(a_pAcl,
                                                      a_dwAceRevision,
                                                      a_AceFlags,
                                                      a_AccessMask,
                                                      a_ObjectTypeGuid,
                                                      a_InheritedObjectTypeGuid,
                                                      a_pSid);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::AddAccessDeniedObjectAce
(
    PACL  a_pAcl,
    DWORD a_dwAceRevision,
    DWORD a_AceFlags,
    DWORD a_AccessMask,
    GUID  *a_ObjectTypeGuid,
    GUID  *a_InheritedObjectTypeGuid,
    PSID  a_pSid,
    BOOL  *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnAddAccessDeniedObjectAce != NULL)
    {
        BOOL t_fTemp = m_pfnAddAccessDeniedObjectAce(a_pAcl,
                                                     a_dwAceRevision,
                                                     a_AceFlags,
                                                     a_AccessMask,
                                                     a_ObjectTypeGuid,
                                                     a_InheritedObjectTypeGuid,
                                                     a_pSid);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::AddAuditAccessObjectAce
(
    PACL  a_pAcl,
    DWORD a_dwAceRevision,
    DWORD a_AceFlags,
    DWORD a_AccessMask,
    GUID  *a_ObjectTypeGuid,
    GUID  *a_InheritedObjectTypeGuid,
    PSID  a_pSid,
    BOOL  a_bAuditSuccess,
    BOOL  a_bAuditFailure,
    BOOL  *a_fRetval
)
{
    bool t_fExists = false;
    if(m_pfnAddAuditAccessObjectAce != NULL)
    {
        BOOL t_fTemp = m_pfnAddAuditAccessObjectAce(a_pAcl,
                                                    a_dwAceRevision,
                                                    a_AceFlags,
                                                    a_AccessMask,
                                                    a_ObjectTypeGuid,
                                                    a_InheritedObjectTypeGuid,
                                                    a_pSid,
                                                    a_bAuditSuccess,
                                                    a_bAuditFailure);

        t_fExists = true;

        if(a_fRetval != NULL)
        {
            *a_fRetval = t_fTemp;
        }
    }
    return t_fExists;
}

bool CAdvApi32Api::GetEffectiveRightsFromAclW
(
    PACL          a_pacl,
    PTRUSTEE_W    a_pTrustee,
    PACCESS_MASK  a_pAccessRights,
    DWORD         *a_dwRetval
)
{
    bool t_fExists = false;
    if(m_pfnGetEffectiveRightsFromAclW != NULL)
    {
        DWORD t_dwTemp;
        {
#ifdef NTONLY
#if NTONLY < 5
            // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
    		CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
#endif
#endif
            t_dwTemp = m_pfnGetEffectiveRightsFromAclW(a_pacl,
                                                       a_pTrustee,
                                                       a_pAccessRights);
        }

        t_fExists = true;

        if(a_dwRetval != NULL)
        {
            *a_dwRetval = t_dwTemp;
        }
    }
    return t_fExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\accessentry.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntry.cpp - implementation file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntry.h"
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( void )
:	m_Sid(),
	m_bACEType( 0 ),
	m_bACEFlags( 0 ),
	m_dwAccessMask( 0 ),
    m_pguidObjType(NULL),
    m_pguidInhObjType(NULL)
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class constructor.
//
//	Inputs:
//				PSID		pSid - Sid to intialize from
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - Flags.
//				DWORD		dwAccessMask - Access Mask
//				char*		pszComputerName - Computer name to
//							init SID from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( PSID pSid,
				BYTE bACEType,
				BYTE bACEFlags,
                GUID *pguidObjType,
                GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName ) : m_Sid( pSid, pszComputerName ),
											m_bACEType( bACEType ),
											m_bACEFlags( bACEFlags ),
                                            m_pguidObjType(NULL),
                                            m_pguidInhObjType(NULL),
											m_dwAccessMask( dwAccessMask )
{
    if(pguidObjType != NULL)
    {
        SetObjType(*pguidObjType);
    }
    if(pguidInhObjType != NULL)
    {
        SetInhObjType(*pguidInhObjType);
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class constructor.
//
//	Inputs:
//				PSID		pSid - Sid to intialize from
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - Flags.
//				DWORD		dwAccessMask - Access Mask
//				char*		pszComputerName - Computer name to
//							init SID from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( PSID pSid,
				BYTE bACEType,
				BYTE bACEFlags,
                GUID *pguidObjType,
                GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName,
                bool fLookup ) : m_Sid( pSid, pszComputerName, fLookup ),
							  	 m_bACEType( bACEType ),
								 m_bACEFlags( bACEFlags ),
                                 m_pguidObjType(NULL),
                                 m_pguidInhObjType(NULL),
								 m_dwAccessMask( dwAccessMask )
{
    if(pguidObjType != NULL)
    {
        SetObjType(*pguidObjType);
    }
    if(pguidInhObjType != NULL)
    {
        SetInhObjType(*pguidInhObjType);
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class constructor.
//
//	Inputs:
//				CSid&		sid - Sid to intialize from
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - Flags.
//				DWORD		dwAccessMask - Access Mask
//				char*		pszComputerName - Computer name to
//							init SID from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( const CSid& sid,
				BYTE bACEType,
				BYTE bACEFlags,
                GUID *pguidObjType,
                GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName ) : m_Sid( sid ),
											m_bACEType( bACEType ),
											m_bACEFlags( bACEFlags ),
                                            m_pguidObjType(NULL),
                                            m_pguidInhObjType(NULL),
											m_dwAccessMask( dwAccessMask )
{
    if(pguidObjType != NULL)
    {
        SetObjType(*pguidObjType);
    }
    if(pguidInhObjType != NULL)
    {
        SetInhObjType(*pguidInhObjType);
    }
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class constructor.
//
//	Inputs:
//				char*		pszAccountName - Account Name
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - Flags.
//				DWORD		dwAccessMask - Access Mask
//				char*		pszComputerName - Computer name to
//							init SID from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( LPCTSTR pszAccountName,
				BYTE bACEType,
				BYTE bACEFlags,
                GUID *pguidObjType,
                GUID *pguidInhObjType,
				DWORD dwAccessMask,
				LPCTSTR pszComputerName ) : m_Sid( pszAccountName, pszComputerName ),
											m_bACEType( bACEType ),
                                            m_pguidObjType(NULL),
                                            m_pguidInhObjType(NULL),
											m_bACEFlags( bACEFlags ),
											m_dwAccessMask( dwAccessMask )
{
    if(pguidObjType != NULL)
    {
        SetObjType(*pguidObjType);
    }
    if(pguidInhObjType != NULL)
    {
        SetInhObjType(*pguidInhObjType);
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Class copy constructor.
//
//	Inputs:
//				const CAccessEntry	r_AccessEntry - object to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::CAccessEntry( const CAccessEntry &r_AccessEntry )
:
    m_Sid(),
	m_bACEType( 0 ),
	m_bACEFlags( 0 ),
	m_dwAccessMask( 0 ),
    m_pguidObjType(NULL),
    m_pguidInhObjType(NULL)
{
	// Copy the values over
	m_Sid = r_AccessEntry.m_Sid;
	m_dwAccessMask = r_AccessEntry.m_dwAccessMask;
	m_bACEType = r_AccessEntry.m_bACEType;
	m_bACEFlags = r_AccessEntry.m_bACEFlags;
    if(r_AccessEntry.m_pguidObjType != NULL)
    {
        SetObjType(*(r_AccessEntry.m_pguidObjType));
    }
    if(r_AccessEntry.m_pguidInhObjType != NULL)
    {
        SetInhObjType(*(r_AccessEntry.m_pguidInhObjType));
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	Assignment operator.
//
//	Inputs:
//				const CAccessEntry	r_AccessEntry - object to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry &	CAccessEntry::operator= ( const CAccessEntry &r_AccessEntry )
{
	// Copy the values over
	m_Sid = r_AccessEntry.m_Sid;
	m_dwAccessMask = r_AccessEntry.m_dwAccessMask;
	m_bACEType = r_AccessEntry.m_bACEType;
	m_bACEFlags = r_AccessEntry.m_bACEFlags;
    if(r_AccessEntry.m_pguidObjType != NULL)
    {
        SetObjType(*(r_AccessEntry.m_pguidObjType));
    }
    if(r_AccessEntry.m_pguidInhObjType != NULL)
    {
        SetInhObjType(*(r_AccessEntry.m_pguidInhObjType));
    }

	return (*this);
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::CAccessEntry
//
//	== Comparison operator.
//
//	Inputs:
//				const CAccessEntry	r_AccessEntry - object to compare.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntry::operator== ( const CAccessEntry &r_AccessEntry )
{
	bool fRet = false;
    if(	    m_Sid			==	r_AccessEntry.m_Sid
		&&	m_dwAccessMask	==	r_AccessEntry.m_dwAccessMask
		&&	m_bACEType		==	r_AccessEntry.m_bACEType
		&&	m_bACEFlags		==	r_AccessEntry.m_bACEFlags)
    {
        if((r_AccessEntry.m_pguidObjType == NULL && m_pguidObjType == NULL) ||
           ((r_AccessEntry.m_pguidObjType != NULL && m_pguidObjType != NULL) &&
            (*(r_AccessEntry.m_pguidObjType) == *m_pguidObjType)))
        {
            if((r_AccessEntry.m_pguidInhObjType == NULL && m_pguidInhObjType == NULL) ||
               ((r_AccessEntry.m_pguidInhObjType != NULL && m_pguidInhObjType != NULL) &&
                (*(r_AccessEntry.m_pguidInhObjType) == *m_pguidInhObjType)))
            {
                fRet = true;
            }
        }
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::~CAccessEntry
//
//	Class Destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry::~CAccessEntry( void )
{
    if(m_pguidObjType != NULL) delete m_pguidObjType;
    if(m_pguidInhObjType != NULL) delete m_pguidInhObjType;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntry::AllocateACE
//
//	Helper function to allocate an appropriate ACE object so outside
//	code can quickly and easily fill out PACLs.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACE_HEADER**	ppACEHeader - Pointer to allocated
//								ACE Header.
//
//	Returns:
//				BOOL			Succes/Failure
//
//	Comments:
//
//	User should use FreeACE to free the allocated object.
//
///////////////////////////////////////////////////////////////////

BOOL CAccessEntry::AllocateACE( ACE_HEADER** ppACEHeader )
{
	// Clear out the structure
	*ppACEHeader = NULL;

	if ( m_Sid.IsValid() )
	{
		ACE_HEADER*	pACEHeader = NULL;
		WORD		wAceSize = 0;
		DWORD		dwSidLength = m_Sid.GetLength();

		switch ( m_bACEType )
		{
			case ACCESS_ALLOWED_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_ALLOWED_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_ALLOWED_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_ALLOWED_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

			case ACCESS_DENIED_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_DENIED_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_DENIED_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_DENIED_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

			case SYSTEM_AUDIT_ACE_TYPE:
			{
				wAceSize = sizeof( SYSTEM_AUDIT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				SYSTEM_AUDIT_ACE* pACE = NULL;
                try
                {
                    pACE = (SYSTEM_AUDIT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_ALLOWED_OBJECT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_ALLOWED_OBJECT_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_ALLOWED_OBJECT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
                        pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        if(m_pguidObjType != NULL)
                        {
                            memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                            pACE->Flags |= ACE_OBJECT_TYPE_PRESENT;
                        }
                        if(m_pguidInhObjType != NULL)
                        {
                            memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
                            pACE->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                        }
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;
/************************* this type has not been implemented yet on W2K *************************************

            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_ALLOWED_COMPOUND_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_ALLOWED_COMPOUND_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_ALLOWED_COMPOUND_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                        memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

*************************************************************************************************************/
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
			{
				wAceSize = sizeof( ACCESS_DENIED_OBJECT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_DENIED_OBJECT_ACE* pACE = NULL;
                try
                {
                    pACE = (ACCESS_DENIED_OBJECT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        if(m_pguidObjType != NULL)
                        {
                            memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                            pACE->Flags |= ACE_OBJECT_TYPE_PRESENT;
                        }
                        if(m_pguidInhObjType != NULL)
                        {
                            memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
                            pACE->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                        }
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
			{
				wAceSize = sizeof( SYSTEM_AUDIT_OBJECT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				SYSTEM_AUDIT_OBJECT_ACE* pACE = NULL;
                try
                {
                    pACE = (SYSTEM_AUDIT_OBJECT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        if(m_pguidObjType != NULL)
                        {
                            memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                            pACE->Flags |= ACE_OBJECT_TYPE_PRESENT;
                        }
                        if(m_pguidInhObjType != NULL)
                        {
                            memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
                            pACE->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                        }
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;

/********************************* type not yet supported under w2k ********************************************
            case SYSTEM_ALARM_ACE_TYPE:
			{
				wAceSize = sizeof( SYSTEM_ALARM_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				SYSTEM_ALARM_ACE* pACE = NULL;
                try
                {
                    pACE = (SYSTEM_ALARM_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;
/********************************* type not yet supported under w2k ********************************************/
/********************************* type not yet supported under w2k ********************************************
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
			{
				wAceSize = sizeof( SYSTEM_ALARM_OBJECT_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				SYSTEM_ALARM_OBJECT_ACE* pACE = NULL;
                try
                {
                    pACE = (SYSTEM_ALARM_OBJECT_ACE*) malloc( wAceSize );

				    if ( NULL != pACE )
				    {
					    pACE->Mask = m_dwAccessMask;
					    CopySid( dwSidLength, (PSID) &pACE->SidStart, m_Sid.GetPSid() );
					    pACEHeader = (ACE_HEADER*) pACE;
                        if(m_pguidObjType != NULL)
                        {
                            memcpy(&(pACE->ObjectType), m_pguidObjType, sizeof(GUID));
                            pACE->Flags |= ACE_OBJECT_TYPE_PRESENT;
                        }
                        if(m_pguidInhObjType != NULL)
                        {
                            memcpy(&(pACE->InheritedObjectType), m_pguidInhObjType, sizeof(GUID));
                            pACE->Flags |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                        }
				    }
                }
                catch(...)
                {
                    if(pACE != NULL)
                    {
                        free(pACE);
                        pACE = NULL;
                    }
                    throw;
                }
			}
			break;
/********************************* type not yet supported under w2k ********************************************/

			default:
			{
				// Something bad just happened
				ASSERT_BREAK(0);
			}

		}	// SWITCH

		// Fill out the common values, then store the value for return.
		if ( NULL != pACEHeader )
		{
			pACEHeader->AceType = m_bACEType;
			pACEHeader->AceFlags = m_bACEFlags;
			pACEHeader->AceSize = wAceSize;

			*ppACEHeader = pACEHeader;
		}

	}

	// Return whether or not a valid ACE is coming out
	return ( NULL != *ppACEHeader );

}

void CAccessEntry::DumpAccessEntry(LPCWSTR wstrFilename)
{
    CHString chstrTemp1;

    Output(L"ACE contents follow...", wstrFilename);

    // Dump the access mask...
    chstrTemp1.Format(L"ACE access mask (hex): %x", m_dwAccessMask);
    Output(chstrTemp1, wstrFilename);

    // Dump the ace type...
    chstrTemp1.Format(L"ACE type (hex): %x", m_bACEType);
    Output(chstrTemp1, wstrFilename);

    // Dump the ace flags...
    chstrTemp1.Format(L"ACE flags (hex): %x", m_bACEFlags);
    Output(chstrTemp1, wstrFilename);

    // Dump the ace sid...
    m_Sid.DumpSid(wstrFilename);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\accessentrylist.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntry.cpp - implementation file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */
#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntryList.h"
#include "DACL.h"
#include "SACL.h"
#include "securitydescriptor.h"
#include "AdvApi32Api.h"
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"
#ifndef MAXDWORD
#define MAXDWORD MAXULONG
#endif

// We're using STL, so this is a requirement
using namespace std;

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CAccessEntryList
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntryList::CAccessEntryList( void )
:	m_ACL()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CAccessEntryList
//
//	Class constructor.
//
//	Inputs:
//				PACL		pWin32ACL - ACL to initialize from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntryList::CAccessEntryList( PACL pWin32ACL, bool fLookup /* = true */ )
:	m_ACL()
{
	InitFromWin32ACL( pWin32ACL, ALL_ACE_TYPES, fLookup );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::~CAccessEntryList
//
//	Class destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntryList::~CAccessEntryList( void )
{
	Clear();
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Add
//
//	Adds a CAccessEntry* pointer to the front of the list.
//
//	Inputs:
//				CAccessEntry*	pACE - ACE to add to the list
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::Add( CAccessEntry* pACE )
{
	// Add to the front of the list
	m_ACL.push_front( pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Append
//
//	Appends a CAccessEntry* pointer to the end of the list.
//
//	Inputs:
//				CAccessEntry*	pACE - ACE to add to the list
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::Append( CAccessEntry* pACE )
{
	// Add to the end of the list
	m_ACL.push_back( pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates a CAccessEntry* pointer in our list
//
//	Inputs:
//				CAccessEntry*	pACE - ACE to find in the list
//
//	Outputs:
//				None.
//
//	Returns:
//				ACLIter		iterator pointing at entry we found
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

ACLIter CAccessEntryList::Find( CAccessEntry* pACE )
{
	for (	ACLIter	acliter	=	m_ACL.begin();
			acliter != m_ACL.end()
		&&	*acliter != pACE;
			acliter++ );

	return acliter;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates a CAccessEntry* pointer in our list whose contents match
//	the supplied ACE.
//
//	Inputs:
//				const CAccessEntry&	ace - ACE to find in the list
//
//	Outputs:
//				None.
//
//	Returns:
//				CAccessEntry*	pointer to matchiong ace.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry* CAccessEntryList::Find( const CAccessEntry& ace )
{
	for (	ACLIter	acliter	=	m_ACL.begin();
			acliter != m_ACL.end()
		&&	!( *(*acliter) == ace );
			acliter++ );

	return ( acliter == m_ACL.end() ? NULL : *acliter );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates a CAccessEntry* pointer in our list based on PSID,
//	bACEType and bACEFlags.
//
//	Inputs:
//				PSID		psid - SID
//				BYTE		bACEType - ACE Type to find.
//				BYTE		bACEFlags - ACE flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				CAccessEntry* Pointer to object we found.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CAccessEntry* CAccessEntryList::Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, bool fLookup /* = true */ )
{

	// Traverse the list until we find an element matching the psid, ACE Type and
	// ACE Flags, or run out of elements.
	for(ACLIter	acliter	= m_ACL.begin(); acliter != m_ACL.end(); acliter++)
    {
		CAccessEntry tempace(psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, NULL, fLookup);
        CAccessEntry *ptempace2 = *acliter;
        if(*ptempace2 == tempace) break;
    }
	return ( acliter == m_ACL.end() ? NULL : *acliter );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::AddNoDup
//
//	Locates a CAccessEntry* pointer in our list based on PSID,
//	bACEType and bACEFlags.  If one is found, we replace the
//	values of that object.  Otherwise, we add the new object to
//	the list.
//
//	Inputs:
//				PSID		psid - SID
//				BYTE		bACEType - ACE Type to find.
//				BYTE		bACEFlags - ACE flags.
//				DWORD		dwMask - Access Mask.
//				BOOL		fMerge - Merge flag.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		success/failure.
//
//	Comments:
//				If fMerge is TRUE, if we find a value, we or the
//				access masks together, otherwise, we replace
//				the mask.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::AddNoDup( PSID psid, BYTE bACEType, BYTE bACEFlags, DWORD dwMask, GUID *pguidObjGuid,
                       GUID *pguidInhObjGuid, bool fMerge /* = false */ )
{
	bool	fReturn = true;

	// Look for a duplicate entry in our linked list.  This means that
	// the sid, the ACEType and the flags are the same.  If this happens,
	// we merge the entries by ORing in the new mask or overwrite (based
	// on the merge mask).  Otherwise, we should add the new entry to the
	// front of the list

	CAccessEntry*	pAccessEntry = Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask );

	if ( NULL == pAccessEntry )
	{
		// NOT found, so we need to add a new entry.
		try
        {
            pAccessEntry = new CAccessEntry(	psid,
											    bACEType,
											    bACEFlags,
                                                pguidObjGuid,
                                                pguidInhObjGuid,
											    dwMask );
		    if ( NULL != pAccessEntry )
		    {
			    Add( pAccessEntry );
		    }
		    else
		    {
			    fReturn = false;
		    }
        }
        catch(...)
        {
            if(pAccessEntry != NULL)
            {
                delete pAccessEntry;
                pAccessEntry = NULL;
            }
            throw;
        }

	}
	else
	{
		if ( fMerge )
		{
			// OR in any new values.
			pAccessEntry->MergeAccessMask( dwMask );
		}
		else
		{
			pAccessEntry->SetAccessMask( dwMask );
		}
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::AppendNoDup
//
//	Locates a CAccessEntry* pointer in our list based on PSID,
//	bACEType and bACEFlags.  If one is found, we replace the
//	values of that object.  Otherwise, we append the new object to
//	the list.
//
//	Inputs:
//				PSID		psid - SID
//				BYTE		bACEType - ACE Type to find.
//				BYTE		bACEFlags - ACE flags.
//				DWORD		dwMask - Access Mask.
//				BOOL		fMerge - Merge flag.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		success/failure.
//
//	Comments:
//				If fMerge is TRUE, if we find a value, we or the
//				access masks together, otherwise, we replace
//				the mask.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::AppendNoDup( PSID psid,
                                    BYTE bACEType,
                                    BYTE bACEFlags,
                                    DWORD dwMask,
                                    GUID *pguidObjGuid,
                                    GUID *pguidInhObjGuid,
                                    bool fMerge /* = false */ )
{
	bool	fReturn = true;

	// Look for a duplicate entry in our linked list.  This means that
	// the sid, the ACEType and the flags are the same.  If this happens,
	// we merge the entries by ORing in the new mask or overwrite (based
	// on the merge mask).  Otherwise, we should add the new entry to the
	// end of the list

	CAccessEntry*	pAccessEntry = Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask );

	if ( NULL == pAccessEntry )
	{
		// NOT found, so we need to append a new entry.
		try
        {
            pAccessEntry = new CAccessEntry(	psid,
											    bACEType,
											    bACEFlags,
                                                pguidObjGuid,
                                                pguidInhObjGuid,
                                                dwMask );
		    if ( NULL != pAccessEntry )
		    {
			    Append( pAccessEntry );
		    }
		    else
		    {
			    fReturn = false;
		    }
        }
        catch(...)
        {
            if(pAccessEntry != NULL)
            {
                delete pAccessEntry;
                pAccessEntry = NULL;
            }
            throw;
        }

	}
	else
	{
		if ( fMerge )
		{
			// OR in any new values.
			pAccessEntry->MergeAccessMask( dwMask );
		}
		else
		{
			pAccessEntry->SetAccessMask( dwMask );
		}
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::AppendNoDup
//
//	Locates a CAccessEntry* pointer in our list based on PSID,
//	bACEType and bACEFlags.  If one is found, we replace the
//	values of that object.  Otherwise, we append the new object to
//	the list.
//
//	Inputs:
//				PSID		psid - SID
//				BYTE		bACEType - ACE Type to find.
//				BYTE		bACEFlags - ACE flags.
//				DWORD		dwMask - Access Mask.
//				BOOL		fMerge - Merge flag.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		success/failure.
//
//	Comments:
//				If fMerge is TRUE, if we find a value, we or the
//				access masks together, otherwise, we replace
//				the mask.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::AppendNoDup( PSID psid,
                                    BYTE bACEType,
                                    BYTE bACEFlags,
                                    DWORD dwMask,
                                    GUID *pguidObjGuid,
                                    GUID *pguidInhObjGuid,
                                    bool fMerge,
                                    bool fLookup )
{
	bool	fReturn = true;

	// Look for a duplicate entry in our linked list.  This means that
	// the sid, the ACEType and the flags are the same.  If this happens,
	// we merge the entries by ORing in the new mask or overwrite (based
	// on the merge mask).  Otherwise, we should add the new entry to the
	// end of the list

	CAccessEntry*	pAccessEntry = Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask, fLookup );

	if ( NULL == pAccessEntry )
	{
		// NOT found, so we need to append a new entry.
		try
        {
            pAccessEntry = new CAccessEntry(	psid,
											    bACEType,
											    bACEFlags,
                                                pguidObjGuid,
                                                pguidInhObjGuid,
                                                dwMask,
                                                NULL,
                                                fLookup );
		    if ( NULL != pAccessEntry )
		    {
			    Append( pAccessEntry );
		    }
		    else
		    {
			    fReturn = false;
		    }
        }
        catch(...)
        {
            if(pAccessEntry != NULL)
            {
                delete pAccessEntry;
                pAccessEntry = NULL;
            }
            throw;
        }

	}
	else
	{
		if ( fMerge )
		{
			// OR in any new values.
			pAccessEntry->MergeAccessMask( dwMask );
		}
		else
		{
			pAccessEntry->SetAccessMask( dwMask );
		}
	}

	return fReturn;

}


///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Remove
//
//	Removes the specified pointer from our list.
//
//	Inputs:
//				CAccessEntry*	pACE - ACE to remove.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	We DO NOT free the pointer.
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::Remove( CAccessEntry* pACE )
{
	ACLIter	acliter = Find( pACE );

	if ( acliter != m_ACL.end() )
	{
		m_ACL.erase( acliter );
	}

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Clear
//
//	Clears and empties out the list.  Frees the pointers as they
//	are located.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::Clear( void )
{

	// Delete all list entries and then clear out the list.

	for (	ACLIter	acliter	=	m_ACL.begin();
			acliter != m_ACL.end();
			acliter++ )
	{
		delete *acliter;
	}

	m_ACL.erase( m_ACL.begin(), m_ACL.end() );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates an ACE in our list matching the specified criteria.
//
//	Inputs:
//				const CSid&	sid - SID
//				BYTE		bACEType - ACE Type
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bACEFlags - ACE Flags
//
//	Outputs:
//				CAccessEntry&	ace
//
//	Returns:
//				BOOL		success/failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::Find( const CSid& sid,
                             BYTE bACEType,
                             BYTE bACEFlags,
                             GUID *pguidObjGuid,
                             GUID *pguidInhObjGuid,
                             DWORD dwAccessMask,
                             CAccessEntry& ace )
{
	CAccessEntry	tempace( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask );

	CAccessEntry* pACE = NULL;
    try
    {
        pACE = Find( tempace );

	    if ( NULL != pACE )
	    {
		    ace = *pACE;
	    }
    }
    catch(...)
    {
        if(pACE != NULL)
        {
            delete pACE;
            pACE = NULL;
        }
        throw;
    }

	return ( NULL != pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Find
//
//	Locates an ACE in our list matching the specified criteria.
//
//	Inputs:
//				PSID		psid - PSID.
//				BYTE		bACEType - ACE Type
//				BYTE		bACEFlags - ACE Flags
//
//	Outputs:
//				CAccessEntry&	ace
//
//	Returns:
//				BOOL		success/failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
	CAccessEntry* pACE = NULL;
    try
    {
        CAccessEntry* pACE = Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask);

	    if ( NULL != pACE )
	    {
		    ace = *pACE;
	    }
    }
    catch(...)
    {
        if(pACE != NULL)
        {
            delete pACE;
            pACE = NULL;
        }
        throw;
    }

	return ( NULL != pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::Copy
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::Copy( CAccessEntryList& ACL )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		CAccessEntry*	pACE = NULL;
        try
        {
            pACE = new CAccessEntry( *(*acliter) );

		    if ( NULL != pACE )
		    {
			    Append( pACE );
		    }
		    else
		    {
			    break;
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyACEs
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies non-Inherited ACEs
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//				BYTE					bACEType - ACE type to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyACEs( CAccessEntryList& ACL, BYTE bACEType )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We don't want inherited ACEs
		if (	(*acliter)->GetACEType() == bACEType
			&&	!(*acliter)->IsInherited() )
		{
			CAccessEntry*	pACE = NULL;
            try
            {
                pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }

            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }

		}
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyInheritedACEs
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies Inherited ACEs
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//				BYTE					bACEType - ACE type to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyInheritedACEs( CAccessEntryList& ACL, BYTE bACEType )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We want inherited ACEs
		if (	(*acliter)->GetACEType() == bACEType
			&&	(*acliter)->IsInherited() )
		{
			CAccessEntry*	pACE = NULL;
            try
            {
                CAccessEntry*	pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }
            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }

		}
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyAllowedACEs
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies Allowed ACEs
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyAllowedACEs( CAccessEntryList& ACL )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We want allowed ACEs
		if ( (*acliter)->IsAllowed() )
		{
			CAccessEntry*	pACE = NULL;
            try
            {
                CAccessEntry*	pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }
            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }

		}
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyDeniedACEs
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies Denied ACEs
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//				BYTE					bACEType - ACE type to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyDeniedACEs( CAccessEntryList& ACL )
{

	// Dump out our existing entries
	Clear();

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We want denied ACEs
		if ( (*acliter)->IsDenied() )
		{
			CAccessEntry*	pACE = NULL;
            try
            {
                CAccessEntry*	pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }
            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }

		}
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::CopyByACEType
//
//	Copies list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.  This
//	function ONLY copies ACEs of the specified type and inheritence.
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to copy.
//				BYTE					bACEType - ACE type to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::CopyByACEType(CAccessEntryList& ACL, BYTE bACEType, bool fInherited)
{
	// Dump out our existing entries
	Clear();
    bool fIsInh;
    fInherited ? fIsInh = true : fIsInh = false;

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		// We want inherited ACEs
		if ( ( (*acliter)->GetACEType() == bACEType ) &&
             ( ((*acliter)->IsInherited() != 0) == fIsInh ) )
        {
			CAccessEntry*	pACE = NULL;
            try
            {
                CAccessEntry*	pACE = new CAccessEntry( *(*acliter) );

			    if ( NULL != pACE )
			    {
				    Append( pACE );
			    }
			    else
			    {
				    break;
			    }
            }
            catch(...)
            {
                if(pACE != NULL)
                {
                    delete pACE;
                    pACE = NULL;
                }
                throw;
            }
        }
	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::AppendList
//
//	Appends list into another one.  Pointers are not copied, as we
//	new more CAccessEntry objects using the Copy Constructor.
//
//	Inputs:
//				const CAccessEntryList&	ACL - ACL to append.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::AppendList( CAccessEntryList& ACL )
{

	// Now iterate our list, duping the ACEs into the ACL
	for (	ACLIter	acliter	=	ACL.m_ACL.begin();
			acliter != ACL.m_ACL.end();
			acliter++ )
	{
		CAccessEntry*	pACE = NULL;
        try
        {
            pACE = new CAccessEntry( *(*acliter) );

		    if ( NULL != pACE )
		    {
			    Append( pACE );
		    }
		    else
		    {
			    break;
		    }
        }

        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }


	}

	// We should be at the end of the source list
	return ( acliter == ACL.m_ACL.end() );

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::BeginEnum
//
//	Call to establish an ACLPOSIION& value for continung enumerations.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACLPOSITION&	pos - Beginning position.
//
//	Returns:
//				BOOL			Success/Failure.
//
//	Comments:
//
//	User MUST call EndEnum() on pos.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::BeginEnum( ACLPOSITION& pos )
{
	// Allocate a new iterator and stick it at the beginning
	ACLIter*	pACLIter = NULL;
    try
    {
        pACLIter = new ACLIter;
    }
    catch(...)
    {
        if(pACLIter != NULL)
        {
            delete pACLIter;
            pACLIter = NULL;
        }
        throw;
    }

	if ( NULL != pACLIter )
	{
		*pACLIter = m_ACL.begin();
	}

	pos = (ACLPOSITION) pACLIter;

	return ( NULL != pACLIter );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::GetNext
//
//	Enumeration call using ACLPOSITION.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACLPOSITION&	pos - Beginning position.
//				CAccessEntry&	ACE - enumed value.
//
//	Returns:
//				BOOL			Success/Failure.
//
//	Comments:
//
//	Because it returns copies, this function is FOR public use.
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::GetNext( ACLPOSITION& pos, CAccessEntry& ACE )
{
	CAccessEntry*	pACE = NULL;
    try
    {
        pACE = GetNext( pos );
    }
    catch(...)
    {
        if(pACE != NULL)
        {
            delete pACE;
            pACE = NULL;
        }
        throw;
    }

	if ( NULL != pACE )
	{
		ACE = *pACE;
	}

	// TRUE/FALSE return based on whether we got back a pointer or not.
	return ( NULL != pACE );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList::GetNext
//
//	Enumeration call using ACLPOSITION.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACLPOSITION&	pos - Beginning position.
//
//	Returns:
//				CAccessEntry*	enumed pointer
//
//	Comments:
//
//	Because it returns actual pointers, DO NOT make this function
//	public.
//
///////////////////////////////////////////////////////////////////

CAccessEntry* CAccessEntryList::GetNext( ACLPOSITION& pos )
{
	CAccessEntry*	pACE		=	NULL;
	ACLIter*		pACLIter	=	(ACLIter*) pos;

	// We'll want to get the current value and increment
	// if we're anywhere but the end.

	if ( *pACLIter != m_ACL.end() )
	{
		// Get the ACE out
		pACE = *(*pACLIter);
		(*pACLIter)++;
	}

	return pACE;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:EndEnum
//
//	Enumeration End call.
//
//	Inputs:
//				None.
//
//	Outputs:
//				ACLPOSITION&	pos - Position to end on.
//
//	Returns:
//				None.
//
//	Comments:
//
//	ACLPOSITION passed in will be invalidated.
//
///////////////////////////////////////////////////////////////////

void CAccessEntryList::EndEnum( ACLPOSITION& pos )
{
	ACLIter*	pACLIter = (ACLIter*) pos;

	delete pACLIter;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:GetAt
//
//	Locates ACE at specified index.
//
//	Inputs:
//				DWORD			dwIndex - Index to find.
//
//	Outputs:
//				CAccessEntry&	ace - ACE located at dwIndex.
//
//	Returns:
//				BOOL			Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::GetAt( DWORD dwIndex, CAccessEntry& ace )
{
	bool	fReturn = false;

	if ( dwIndex < m_ACL.size() )
	{
		ACLIter	acliter	=	m_ACL.begin();

		// Enum the list until we hit the index or run out of values.
		// we should hit the index since we verified that dwIndex is
		// indeed < m_ACL.size().

		for (	DWORD	dwCtr = 0;
				dwCtr < dwIndex
			&&	acliter != m_ACL.end();
				acliter++, dwCtr++ );

		if ( acliter != m_ACL.end() )
		{
			// Copy the ACE
			ace = *(*acliter);
			fReturn = true;
		}

	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:SetAt
//
//	Locates ACE at specified index and overwrites it.
//
//	Inputs:
//				DWORD			dwIndex - Index to find.
//				CAccessEntry&	ace - ACE to set at dwIndex.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::SetAt( DWORD dwIndex, const CAccessEntry& ace )
{
	bool	fReturn = false;

	if ( dwIndex < m_ACL.size() )
	{
		ACLIter	acliter	=	m_ACL.begin();

		// Enum the list until we hit the index, at which point we will
		// replace the existing entry data with the supplied data.

		for (	DWORD	dwCtr = 0;
				dwCtr < dwIndex
			&&	acliter != m_ACL.end();
				acliter++, dwCtr++ );

		if ( acliter != m_ACL.end() )
		{
			// Copy the ACE
			*(*acliter) = ace;
			fReturn = true;
		}

	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:RemoveAt
//
//	Locates ACE at specified index and removes it.
//
//	Inputs:
//				DWORD			dwIndex - Index to find.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CAccessEntryList::RemoveAt( DWORD dwIndex )
{
	bool	fReturn = false;

	if ( dwIndex < m_ACL.size() )
	{
		ACLIter	acliter	=	m_ACL.begin();

		// Enum the list until we hit the index, at which point we will
		// delete the pointer at the entry and erase it from the list.

		for (	DWORD	dwCtr = 0;
				dwCtr < dwIndex
			&&	acliter != m_ACL.end();
				acliter++, dwCtr++ );

		if ( acliter != m_ACL.end() )
		{
			delete *acliter;
			m_ACL.erase( acliter );
			fReturn = true;
		}

	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:CalculateWin32ACLSize
//
//	Traverses our list and calculates the size of a Win32ACL
//	containing corresponding values.
//
//	Inputs:
//				None.
//
//	Outputs:
//				LPDWORD			pdwACLSize - ACL Size.
//
//	Returns:
//				BOOL			Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CAccessEntryList::CalculateWin32ACLSize( LPDWORD pdwACLSize )
{
	BOOL	fReturn = TRUE;

	if ( 0 == *pdwACLSize )
	{
		*pdwACLSize = sizeof(ACL);
	}

	// Objects for internal manipulations and gyrationships
	CAccessEntry*	pAce = NULL;
	CSid			sid;
	ACLPOSITION		pos;

	if ( BeginEnum( pos ) )
	{
        try
        {
		    while (		fReturn
				    &&	( pAce = GetNext( pos ) ) != NULL )
		    {
				// Different structures for different ACEs
				switch ( pAce->GetACEType() )
				{
					case ACCESS_ALLOWED_ACE_TYPE:	            *pdwACLSize += sizeof( ACCESS_ALLOWED_ACE );	                break;
					case ACCESS_DENIED_ACE_TYPE:	            *pdwACLSize += sizeof( ACCESS_DENIED_ACE );		                break;
					case SYSTEM_AUDIT_ACE_TYPE:		            *pdwACLSize += sizeof( SYSTEM_AUDIT_ACE );		                break;
                    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:        *pdwACLSize += sizeof( ACCESS_ALLOWED_OBJECT_ACE );             break;
                    //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:		*pdwACLSize += sizeof( ACCESS_ALLOWED_COMPOUND_ACE );		    break;
                    case ACCESS_DENIED_OBJECT_ACE_TYPE:         *pdwACLSize += sizeof( ACCESS_DENIED_OBJECT_ACE );              break;
                    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:          *pdwACLSize += sizeof( SYSTEM_AUDIT_OBJECT_ACE );               break;
                    //case SYSTEM_ALARM_ACE_TYPE:		            *pdwACLSize += sizeof( SYSTEM_ALARM_ACE_TYPE );		            break;
                    //case SYSTEM_ALARM_OBJECT_ACE_TYPE:          *pdwACLSize += sizeof( SYSTEM_ALARM_OBJECT_ACE );               break;
					default:						            ASSERT_BREAK(0); fReturn = FALSE;			                	break;
				}

				pAce->GetSID( sid );

				// Calculate the storage required for the Sid using the formula
				// from the security reference code samples

				*pdwACLSize += GetLengthSid( sid.GetPSid() ) - sizeof( DWORD );

            }

        }
        catch(...)
        {
            if(pAce != NULL)
            {
                delete pAce;
                pAce = NULL;
            }
            throw;
        }
		EndEnum( pos );
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:FillWin32ACL
//
//	Traverses our list and adds ACE entries to a Win32 ACL.
//
//	Inputs:
//				PACL		pACL - ACL to add ACEs to.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CAccessEntryList::FillWin32ACL( PACL pACL )
{
	DWORD			dwReturn = ERROR_SUCCESS;

    if(pACL == NULL)
    {
        return E_POINTER;
    }

	// Objects for internal manipulations and gyrationships
	CAccessEntry*	pACE = NULL;
	ACLPOSITION		pos;
	ACE_HEADER*		pAceHeader = NULL;

#if NTONLY >= 5
    CAdvApi32Api *t_pAdvApi32 = NULL;
    t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);

#endif

	// Enumerate the List.

	if ( BeginEnum( pos ) )
	{
        try
        {
            while (		ERROR_SUCCESS == dwReturn
				    &&	( pACE = GetNext( pos ) ) != NULL )
		    {
#if NTONLY >= 5
				// If it was an ACCESS_ALLOWED_OBJECT_ACE_TYPE or an ACCESS_DENIED_OBJECT_ACE_TYPE,
                // need to use a different function to add the ACE to the ACL.
                if(pACE->GetACEType() == ACCESS_ALLOWED_OBJECT_ACE_TYPE)
                {
                    if(t_pAdvApi32 != NULL)
                    {
                        // Call the new function AddAccessAllowedObjectAce...
                        CSid sid;
                        pACE->GetSID(sid);
                        BOOL fRetval = FALSE;
                        GUID guidObjType, guidInhObjType;
                        GUID *pguidObjType = NULL;
                        GUID *pguidInhObjType = NULL;

                        if(pACE->GetObjType(guidObjType)) pguidObjType = &guidObjType;
                        if(pACE->GetInhObjType(guidInhObjType)) pguidInhObjType = &guidInhObjType;

                        if(!t_pAdvApi32->AddAccessAllowedObjectAce(pACL,
                                                                   ACL_REVISION_DS,
                                                                   pACE->GetACEFlags(),
                                                                   pACE->GetAccessMask(),
                                                                   pguidObjType,
                                                                   pguidInhObjType,
                                                                   sid.GetPSid(),
                                                                   &fRetval))
                        {
                            dwReturn = ERROR_PROC_NOT_FOUND;
                        }
                        else // fn exists in dll
                        {
                            if(!fRetval)
                            {
                                dwReturn = ::GetLastError();
                            }
                        }
                    }
                    else
                    {
                        dwReturn = E_FAIL;
                    }
                }
                else if(pACE->GetACEType() == ACCESS_DENIED_OBJECT_ACE_TYPE)
                {
                    if(t_pAdvApi32 != NULL)
                    {
                        // Call the new function AddAccessDeniedObjectAce...
                        CSid sid;
                        pACE->GetSID(sid);
                        BOOL fRetval = FALSE;
                        GUID guidObjType, guidInhObjType;
                        GUID *pguidObjType = NULL;
                        GUID *pguidInhObjType = NULL;

                        if(pACE->GetObjType(guidObjType)) pguidObjType = &guidObjType;
                        if(pACE->GetInhObjType(guidInhObjType)) pguidInhObjType = &guidInhObjType;
                        if(!t_pAdvApi32->AddAccessDeniedObjectAce(pACL,
                                                                  ACL_REVISION_DS,
                                                                  pACE->GetACEFlags(),
                                                                  pACE->GetAccessMask(),
                                                                  pguidObjType,
                                                                  pguidInhObjType,
                                                                  sid.GetPSid(),
                                                                  &fRetval))
                        {
                            dwReturn = ERROR_PROC_NOT_FOUND;
                        }
                        else // fn exists in dll
                        {
                            if(!fRetval)
                            {
                                dwReturn = ::GetLastError();
                            }
                        }
                    }
                    else
                    {
                        dwReturn = E_FAIL;
                    }
                }
                else if(pACE->GetACEType() == SYSTEM_AUDIT_OBJECT_ACE_TYPE)
                {
                    if(t_pAdvApi32 != NULL)
                    {
                        // Call the new function AddAccessDeniedObjectAce...
                        CSid sid;
                        pACE->GetSID(sid);
                        BOOL fRetval = FALSE;
                        if(!t_pAdvApi32->AddAuditAccessObjectAce(pACL,
                                                                 ACL_REVISION,
                                                                 pACE->GetACEFlags(),
                                                                 pACE->GetAccessMask(),
                                                                 NULL,
                                                                 NULL,
                                                                 sid.GetPSid(),
                                                                 FALSE,  // we pick this up through the third argument
                                                                 FALSE,  // we pick this up through the third argument
                                                                 &fRetval))
                        {
                            if(!fRetval)
                            {
                                dwReturn = ::GetLastError();
                            }
                            else
                            {
                                dwReturn = ERROR_PROC_NOT_FOUND;
                            }
                        }
                    }
                    else
                    {
                        dwReturn = E_FAIL;
                    }



                }
                else
#endif
                {
                    // For Each ACE we enum, allocate a Win32 ACE, and stick that bad boy at the
				    // end of the Win32 ACL.

                    if ( pACE->AllocateACE( &pAceHeader ) )
				    {
					    if ( !::AddAce( pACL, ACL_REVISION, MAXDWORD, (void*) pAceHeader, pAceHeader->AceSize ) )
					    {
						    dwReturn = ::GetLastError();
					    }

					    // Cleanup the memory block
					    pACE->FreeACE( pAceHeader );
				    }
				    else
				    {
					    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
				    }

                    //////////
                    //CSid sid;
                    //pACE->GetSID(sid);
                    //if(!AddAccessAllowedAce(pACL,ACL_REVISION,pACE->GetAccessMask(),sid.GetPSid()))
                    //{
                    //    dwReturn = ::GetLastError();
                    //}
                    //////////
                }
		    }
        }
        catch(...)
        {
            if(pAceHeader != NULL)
            {
                pACE->FreeACE( pAceHeader );
                pAceHeader = NULL;
            }
            throw;
        }

		EndEnum( pos );

	}

#if NTONLY >= 5
    if(t_pAdvApi32 != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
        t_pAdvApi32 = NULL;
    }
#endif


	return dwReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CAccessEntryList:InitFromWin32ACL
//
//	Traverses a Win32ACL and copies ACEs into our list.
//
//	Inputs:
//				PACL		pACL - ACL to add ACEs to.
//				BYTE		bACEFilter - ACEs to filter on.
//              bool        fLookup - whether the sids should be
//                          resolved to their domain and name values.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	If bACEFilter is not ALL_ACE_TYPES, then we will only copy out
//	ACEs of the specified type.
//
///////////////////////////////////////////////////////////////////

DWORD CAccessEntryList::InitFromWin32ACL( PACL pWin32ACL, BYTE bACEFilter /* = ALL_ACE_TYPES */, bool fLookup /* = true */ )
{
	DWORD		dwError		=	0;
	ACE_HEADER*	pACEHeader	=	NULL;
	DWORD		dwAceIndex	=	0;
	BOOL		fGotACE		=	FALSE;
	DWORD		dwMask		=	0;
	PSID		psid		=	NULL;
    GUID       *pguidObjType = NULL;
    GUID       *pguidInhObjType = NULL;

	// Empty out
	Clear();

	// For each ACE we find, get the values necessary to initialize our
	// CAccessEntries
	do
	{
		fGotACE = ::GetAce( pWin32ACL, dwAceIndex, (LPVOID*) &pACEHeader );

		if ( fGotACE )
		{
			switch ( pACEHeader->AceType )
			{
				case ACCESS_ALLOWED_ACE_TYPE:
				{
					ACCESS_ALLOWED_ACE*	pACE = (ACCESS_ALLOWED_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;

				case ACCESS_DENIED_ACE_TYPE:
				{
					ACCESS_DENIED_ACE*	pACE = (ACCESS_DENIED_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;

				case SYSTEM_AUDIT_ACE_TYPE:
				{
					SYSTEM_AUDIT_ACE*	pACE = (SYSTEM_AUDIT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;

                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
				{
					ACCESS_ALLOWED_OBJECT_ACE*	pACE = (ACCESS_ALLOWED_OBJECT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
                    if(pACE->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidObjType = new GUID;
                            if(pguidObjType != NULL)
                            {
                                memcpy(pguidObjType,&pACE->ObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidObjType != NULL)
                            {
                                delete pguidObjType;
                                pguidObjType = NULL;
                            }
                            throw;
                        }
                    }
                    if(pACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidInhObjType = new GUID;
                            if(pguidInhObjType != NULL)
                            {
                                memcpy(pguidInhObjType,&pACE->InheritedObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidInhObjType != NULL)
                            {
                                delete pguidInhObjType;
                                pguidInhObjType = NULL;
                            }
                            throw;
                        }
                    }
				}
				break;
/********************************* type not yet supported under w2k ********************************************
                case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
				{
					ACCESS_ALLOWED_COMPOUND_ACE_TYPE*	pACE = (ACCESS_ALLOWED_COMPOUND_ACE_TYPE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;
***************************************************************************************************************/
                case ACCESS_DENIED_OBJECT_ACE_TYPE:
				{
					ACCESS_DENIED_OBJECT_ACE*	pACE = (ACCESS_DENIED_OBJECT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
                    if(pACE->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidObjType = new GUID;
                            if(pguidObjType != NULL)
                            {
                                memcpy(pguidObjType,&pACE->ObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidObjType != NULL)
                            {
                                delete pguidObjType;
                                pguidObjType = NULL;
                            }
                            throw;
                        }
                    }
                    if(pACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidInhObjType = new GUID;
                            if(pguidInhObjType != NULL)
                            {
                                memcpy(pguidInhObjType,&pACE->InheritedObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidInhObjType != NULL)
                            {
                                delete pguidInhObjType;
                                pguidInhObjType = NULL;
                            }
                            throw;
                        }
                    }
				}
				break;

                case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
				{
					SYSTEM_AUDIT_OBJECT_ACE*	pACE = (SYSTEM_AUDIT_OBJECT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
                    if(pACE->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidObjType = new GUID;
                            if(pguidObjType != NULL)
                            {
                                memcpy(pguidObjType,&pACE->ObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidObjType != NULL)
                            {
                                delete pguidObjType;
                                pguidObjType = NULL;
                            }
                            throw;
                        }
                    }
                    if(pACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidInhObjType = new GUID;
                            if(pguidInhObjType != NULL)
                            {
                                memcpy(pguidInhObjType,&pACE->InheritedObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidInhObjType != NULL)
                            {
                                delete pguidInhObjType;
                                pguidInhObjType = NULL;
                            }
                            throw;
                        }
                    }
				}
				break;

/********************************* type not yet supported under w2k ********************************************
                case SYSTEM_ALARM_ACE_TYPE:
				{
					SYSTEM_ALARM_ACE*	pACE = (SYSTEM_ALARM_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
				}
				break;
/********************************* type not yet supported under w2k ********************************************/

/********************************* type not yet supported under w2k ********************************************
                case SYSTEM_ALARM_OBJECT_ACE_TYPE:
				{
					SYSTEM_ALARM_OBJECT_ACE*	pACE = (SYSTEM_ALARM_OBJECT_ACE*) pACEHeader;
					psid = (PSID) &pACE->SidStart;
					dwMask = pACE->Mask;
                    if(pACE->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidObjType = new GUID;
                            if(pguidObjType != NULL)
                            {
                                memcpy(pguidObjType,&pACE->ObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidObjType != NULL)
                            {
                                delete pguidObjType;
                                pguidObjType = NULL;
                            }
                            throw;
                        }
                    }
                    if(pACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        try
                        {
                            pguidInhObjType = new GUID;
                            if(pguidInhObjType != NULL)
                            {
                                memcpy(pguidInhObjType,&pACE->InheritedObjectType, sizeof(GUID));
                            }
                            else
                            {
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                        catch(...)
                        {
                            if(pguidInhObjType != NULL)
                            {
                                delete pguidInhObjType;
                                pguidInhObjType = NULL;
                            }
                            throw;
                        }
                    }
				}
				break;
/********************************* type not yet supported under w2k ********************************************/

				default:
				{
					ASSERT_BREAK(0);	// BAD, we don't know what this is!
					dwError = ERROR_INVALID_PARAMETER;
				}
			}

			// We must have no errors, and the filter MUST accept all ACE Types
			// or the ACE Type must match the filter.

			if (	ERROR_SUCCESS == dwError
				&&	(	ALL_ACE_TYPES == bACEFilter
					||	bACEFilter == pACEHeader->AceType ) )
			{

				// We merge duplicate entries during initialization
				if ( !AppendNoDup(	psid,
									pACEHeader->AceType,
									pACEHeader->AceFlags,
									dwMask,
                                    pguidObjType,
                                    pguidInhObjType,
									true,              // Merge flag
                                    fLookup ) )	       // whether to resolve domain and name of sid
				{
					dwError = ERROR_NOT_ENOUGH_MEMORY;
				}

			}


		}	// IF fGot ACE

		// Get the next ACE
		++dwAceIndex;

	}
	while ( fGotACE && ERROR_SUCCESS == dwError );


	return dwError;
}


void CAccessEntryList::DumpAccessEntryList(LPCWSTR wstrFilename)
{
    Output(L"AccessEntryList contents follow...", wstrFilename);

    // Run through the list, outputting each...
    CAccessEntry*	pACE = NULL;
	ACLPOSITION		pos;

    if(BeginEnum(pos))
    {
        while((pACE = GetNext(pos)) != NULL)
        {
            pACE->DumpAccessEntry(wstrFilename);
        }
        EndEnum(pos);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\assoc.h ===
//=================================================================

//

// assoc.h -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#pragma once

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));

class CAssociation : public Provider
{
    public:

        CAssociation(
        LPCWSTR pwszClassName,
        LPCWSTR pwszNamespaceName,

        LPCWSTR pwszLeftClassName,
        LPCWSTR pwszRightClassName,

        LPCWSTR pwszLeftPropertyName,
        LPCWSTR pwszRightPropertyName
        );

        virtual ~CAssociation();

        HRESULT ExecQuery(

            MethodContext* pMethodContext, 
            CFrameworkQuery &pQuery, 
            long lFlags 
        );

        HRESULT GetObject(

            CInstance* pInstance, 
            long lFlags,
            CFrameworkQuery &pQuery
        );

        HRESULT EnumerateInstances(

            MethodContext *pMethodContext,
            long lFlags /*= 0L*/
        );

    protected:
        
        bool IsInstance(const CInstance *pInstance);

        static HRESULT WINAPI StaticEnumerationCallback(

            Provider* pThat,
            CInstance* pInstance,
            MethodContext* pContext,
            void* pUserData
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT EnumerationCallback(

            CInstance *pRight, 
            MethodContext *pMethodContext, 
            void *pUserData
        );

        virtual HRESULT ValidateLeftObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual HRESULT ValidateRightObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual bool AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return IsInstance(pLeft) && IsInstance(pRight);
        }

        virtual void MakeWhere(

            CHStringArray &sRightPaths,
            CHStringArray &sRightWheres
        )
        {
        }

        virtual HRESULT FindWhere(

            TRefPointerCollection<CInstance> &lefts,
            CHStringArray &sLeftWheres
        )
        {
            return WBEM_S_NO_ERROR;
        }

        virtual HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return WBEM_S_NO_ERROR;
        }

        virtual HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts,
            const CHStringArray &sRightValues
        );

        virtual HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts,
            const CHStringArray &sLeftWheres
        );

        bool IsDerivedFrom(
                              
            LPCWSTR pszBaseClassName, 
            LPCWSTR pszDerivedClassName, 
            MethodContext *pMethodContext
        );

        CHString m_sLeftClassName;
        CHString m_sRightClassName;

        CHString m_sLeftPropertyName;
        CHString m_sRightPropertyName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\binding.h ===
//=================================================================

//

// binding.h -- Generic association class

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include "assoc.h"

#define MAX_ORS 3

class CBinding : public CAssociation
{
    public:

        CBinding(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName,

            LPCWSTR pwszLeftBindingPropertyName,
            LPCWSTR pwszRightBindingPropertyName
        );

        virtual ~CBinding();

    protected:

        virtual bool AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        );

        virtual void MakeWhere(

            CHStringArray &sRightPaths,
            CHStringArray &sRightWheres
        );

        virtual HRESULT FindWhere(

            TRefPointerCollection<CInstance> &lefts,
            CHStringArray &sLeftWheres
        );

        virtual HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts,
            const CHStringArray &sRightValues
        );

        virtual HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts,
            const CHStringArray &sLeftWheres
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        bool CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2);

        HRESULT MakeString(VARIANT *pvValue, CHString &sTemp);

        DWORD IsInList(
                                
            const CHStringArray &csaArray, 
            LPCWSTR pwszValue
        );

        void EscapeCharacters(LPCWSTR wszIn,
                          CHString& chstrOut);

//-----------

        CHString m_sLeftBindingPropertyName;
        CHString m_sRightBindingPropertyName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cachedconfigmgrdata.h ===
//=================================================================

//

// CachedConfigMgrData.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

/**********************************************************************************************************
 * #includes to Register this class with the CResourceManager. 
 **********************************************************************************************************/
#include "ResourceManager.h"
#include "TimedDllResource.h"

#include "poormansresource.h"
#include "resourcedesc.h"
#include "configmgrapi.h"
#include "cfgmgrdevice.h"

extern const GUID guidCACHEDCONFIGMGRDATA ;

class CCachedConfigMgrData : public CTimedDllResource
{
public:
	BOOL fReturn ;
	CDeviceCollection deviceList ;

public:
	CCachedConfigMgrData () ;
	~CCachedConfigMgrData () ;
	
protected:
	BOOL GetDeviceList () ;
	BOOL WalkDeviceTree2 ( DEVNODE dn, CConfigMgrAPI* pconfigmgrapi ) ;
	BOOL CheckForLoop ( CConfigMgrDevice* pInDevice ) ;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cautolock.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CAutoLock.cpp -- Automatic locking class for mutexes and critical sections.

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================
#include "precomp.h"
#include "CAutoLock.h"

CAutoLock::CAutoLock(HANDLE hMutexHandle)
:  m_pCritSec(NULL),
   m_pcCritSec(NULL),
   m_pcMutex(NULL),
   m_hMutexHandle(hMutexHandle)
{
    ::WaitForSingleObject(m_hMutexHandle, INFINITE);
}

CAutoLock::CAutoLock(CMutex& rCMutex)
:  m_pCritSec(NULL),
   m_pcCritSec(NULL),
   m_hMutexHandle(NULL),
   m_pcMutex(&rCMutex)
{

    m_pcMutex->Wait(INFINITE);
}

CAutoLock::CAutoLock(CRITICAL_SECTION* pCritSec)
:  m_hMutexHandle(NULL),
   m_pcMutex(NULL),
   m_pcCritSec(NULL),
   m_pCritSec(pCritSec)
{
    ::EnterCriticalSection(m_pCritSec);
}

CAutoLock::CAutoLock(CCriticalSec& rCCritSec)
:  m_hMutexHandle(NULL),
   m_pcMutex(NULL),
   m_pCritSec(NULL),
   m_pcCritSec(&rCCritSec)
{
    m_pcCritSec->Enter();
}

// destructor...
CAutoLock::~CAutoLock()
{
    BOOL bStatus = TRUE;

    if (m_hMutexHandle)
    {
        bStatus = ::ReleaseMutex(m_hMutexHandle);
    }
    else if (m_pcMutex)
    {
        bStatus = m_pcMutex->Release();
    }
    else if (m_pCritSec)
    {
        ::LeaveCriticalSection(m_pCritSec);
    }
    else
    {
        m_pcCritSec->Leave();
    }

    if (!bStatus)
    {
        //CThrowError(::GetLastError());
        LogMessage2(L"CAutoLock Error: %d", ::GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\binding.cpp ===
//=================================================================

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// binding.cpp -- Rule-based association class
//
// This class allows for the creation of a specific type of rule-based associations.  Consider 
// this example:
// 
// CBinding MyPhysicalDiskToLogicalDisk(
//     L"PhysicalDiskToLogicalDisk",
//     L"Root\\default",
//     L"PhysicalFixedDisk",
//     L"LogicalDisk",
//     L"Antecendent",
//     L"Dependent",
//     L"MappedDriveLetter",
//     L"DriveLetter"
// );
// 
// This declaration is saying that there is a class named "PhysicalDiskToLogicalDisk" which 
// resides in the "root\default" namespace.  It is an association between the "PhysicalFixedDisk" 
// class, and the "LogicalDisk" class.  The "PhysicalFixedDisk" value goes into the 
// "Antecendent" property of the "PhysicalDiskToLogicalDisk" class, and the 
// "LogicalDisk" value goes in the "Dependent" property of the "PhysicalDiskToLogicalDisk" class.
// Only return instances where PhysicalFixedDisk.MappedDriveLetter = LogicalDisk.DriveLetter.
// 
// Some notes:
// - When choosing which of the two classes should be the left class, choose the class that is
// likely to have fewer instances.  This will result in less memory being used, and instances
// being sent back to the client sooner.
// 
// - CBinding supports ExecQuery, GetObject, and EnumerateInstances.
// 
// - CBinding is designed to be derived from.  For example, if your association needs to 
// support DeleteInstance, ExecMethod, or PutInstance, create a class that derives from 
// CBinding, and add the appropriate methods.  Also, various methods such as 
// LoadPropertyValues and AreRelated may be useful for further customization.
// 
// - The two endpoint classes can be dynamic, static, or abstract.  CBinding will do a deep 
// enumeration (actually a query, which is always deep) to retrieve the instances.
// 
// - When calling the endpoint classes, CBinding will use per property gets, and queries
// with Select clauses and/or Where statements.  If the endpoint classes support per-property
// gets or queries, this will result in better performance for the associaton class.
// 
// - The association class and both endpoints must all be in the same namespace.
// 
// See also: CAssociation (assoc.cpp) for a different type of rule-based association.
// 
//=================================================================

#include "precomp.h"
#include "Binding.h"

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::CBinding
//
// Constructor.
//
/////////////////////////////////////////////////////////////////////

CBinding::CBinding(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName,

    LPCWSTR pwszLeftBindingPropertyName,
    LPCWSTR pwszRightBindingPropertyName

) : CAssociation (

    pwszClassName,
    pwszNamespaceName,
    pwszLeftClassName,
    pwszRightClassName,
    pwszLeftPropertyName,
    pwszRightPropertyName
)
{
    // Save off the binding property names
    m_sLeftBindingPropertyName = pwszLeftBindingPropertyName;
    m_sRightBindingPropertyName = pwszRightBindingPropertyName;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::~CBinding
//
// Destructor.
//
/////////////////////////////////////////////////////////////////////

CBinding::~CBinding()
{
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::AreRelated
//
// Determine whether the two instances are related.  For
// CBinding, this is done by comparing their BindingProperty values.
//
// Note that NULL properties values are not considered to be related
// to anything, even another NULL.
//
/////////////////////////////////////////////////////////////////////

bool CBinding::AreRelated(

    const CInstance *pLeft,
    const CInstance *pRight
)
{
    bool bRet = false;

    variant_t   LeftBindingPropertyValue,
                RightBindingPropertyValue;

    if (pLeft->GetVariant(m_sLeftBindingPropertyName, LeftBindingPropertyValue) &&
        pRight->GetVariant(m_sRightBindingPropertyName,  RightBindingPropertyValue) )
    {
        bRet = CompareVariantsNoCase(&LeftBindingPropertyValue, &RightBindingPropertyValue);
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::GetRightInstances
//
// Make an async call (well, sort of async) to retrieve all of the
// instances of the righthand class.  If possible use the sLeftWheres
// to create a query to minimize the number of returned instances.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts,
    const CHStringArray &sLeftWheres
)
{
    CHString sQuery;

    // Did we get any where clauses?
    if (sLeftWheres.GetSize() == 0)
    {
        // Nope, retrieve them all.
        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE %s<>NULL", 

                        (LPCWSTR)m_sRightBindingPropertyName, 
                        (LPCWSTR)m_sRightClassName,
                        (LPCWSTR)m_sRightBindingPropertyName);
    }
    else
    {
        // Yup, build a query to only retrieve those instances.
        CHString sQuery2;

        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE (%s<>NULL) AND (%s=%s ", 

            (LPCWSTR)m_sRightBindingPropertyName, 
            (LPCWSTR)m_sRightClassName, 
            (LPCWSTR)m_sRightBindingPropertyName, 
            (LPCWSTR)m_sRightBindingPropertyName, 
            (LPCWSTR)sLeftWheres[0]);

        // Usually, we should only have one (that what ASSOCIATORS and REFERENCES will
        // generate).  However, if we have more than one, tack the rest on.
        for (DWORD x=1; x < sLeftWheres.GetSize(); x++)
        {
            sQuery2.Format(L"OR %s=%s ", (LPCWSTR)m_sRightBindingPropertyName, (LPCWSTR)sLeftWheres[x]);
            sQuery += sQuery2;
        }

        // put the final close parenthesis.
        sQuery.SetAt(sQuery.GetLength() - 1, L')');
    }

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        GetNamespace(),
        pMethodContext,
        lefts);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::GetLeftInstances
//
// Retrieve the lefthand instances, storing them in lefts
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts,
    const CHStringArray &sRightWheres
)
{
    CHString sQuery;

    // Did we get any where clauses?
    if (sRightWheres.GetSize() == 0)
    {
        // Nope, retrieve them all.
        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE %s <> NULL", 
                            (LPCWSTR)m_sLeftBindingPropertyName, 
                            (LPCWSTR)m_sLeftClassName,
                            (LPCWSTR)m_sLeftBindingPropertyName
                            );
    }
    else
    {
        // Yup, build a query to only retrieve those instances.
        CHString sQuery2;

        sQuery.Format(L"SELECT __RELPATH, %s FROM %s WHERE (%s<>NULL) AND (%s=%s ", 
            (LPCWSTR)m_sLeftBindingPropertyName, 
            (LPCWSTR)m_sLeftClassName, 
            (LPCWSTR)m_sLeftBindingPropertyName, 
            (LPCWSTR)m_sLeftBindingPropertyName, 
            (LPCWSTR)sRightWheres[0]);

        // Usually, we should only have one (that what ASSOCIATORS and REFERENCES will
        // generate).  However, if we have more than one, tack the rest on.
        for (DWORD x=1; x < sRightWheres.GetSize(); x++)
        {
            sQuery2.Format(L"OR %s=%s ", (LPCWSTR)m_sLeftBindingPropertyName, (LPCWSTR)sRightWheres[x]);
            sQuery += sQuery2;
        }

        // put the final close parenthesis.
        sQuery.SetAt(sQuery.GetLength() - 1, L')');
    }

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext, GetNamespace());
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::RetrieveLeftInstance
//
// Retrieve a specific lefthand instance.  Use per-property gets
// to only request the required properties for best performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__Relpath");
    csaProperties.Add(m_sLeftBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::RetrieveRightInstance
//
// Retrieve a specific lefthand instance.  Use per-property gets
// to only request the required properties for best performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__Relpath");
    csaProperties.Add(m_sRightBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::MakeWhere
//
// If the key property of the righthand class also happens to be
// the binding property AND if we have a path for specific righthand
// instances we need to return, then we can use the path for the 
// righthand instances to build a where clause for the lefthand 
// instances.
//
// Note that if we find invalid paths in sRightPaths, we remove
// them from sRightPaths.
//
/////////////////////////////////////////////////////////////////////

void CBinding::MakeWhere(

    CHStringArray &sRightPaths,
    CHStringArray &sRightWheres
)
{
    // See if we have any righthand instances
    if (sRightPaths.GetSize() > 0)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;
        CHString sTemp;

        for (DWORD x=0; x < sRightPaths.GetSize();) // Note that x++ is done inside the loop
        {
            // Parse the instance
            int nStatus = objpathParser.Parse( sRightPaths[x],  &pParsedPath );

            if ( 0 == nStatus )
            {
                try
                {
                    // See if the property name in the key is the property name we are binding on
                    if ( (pParsedPath->m_dwNumKeys == 1) && (pParsedPath->m_paKeys[0]->m_pName != NULL) )
                    {
                        if (_wcsicmp(pParsedPath->m_paKeys[0]->m_pName, m_sRightBindingPropertyName) == 0)
                        {
                            // Yes, it is.  Make a where clause statement.
                            HRESULT hr = MakeString(&pParsedPath->m_paKeys[0]->m_vValue, sTemp);

                            // See if we already have that where clause
                            if ( SUCCEEDED(hr) && IsInList(sRightWheres, sTemp) == -1)
                            {
                                // A query with 1000 where clauses isn't going
                                // to be very efficient either.  Pick a reasonable limit
                                if (sRightWheres.GetSize() < MAX_ORS)
                                {
                                    sRightWheres.Add(sTemp);
                                }
                                else
                                {
                                    // Too many.  Fall back on a complete enum
                                    sRightWheres.RemoveAll();
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // Fall back on a complete enum
                            sRightWheres.RemoveAll();
                            break;
                        }
                    }
                    else
                    {
                        // Fall back on a complete enum
                        sRightWheres.RemoveAll();
                        break;
                    }

                    // This was a valid path
                    x++;
                }
                catch ( ... )
                {
                    objpathParser.Free( pParsedPath );
                    throw;
                }

                objpathParser.Free( pParsedPath );
            }
            else
            {
                // This was an invalid path.  Remove it
                sRightPaths.RemoveAt(x);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::FindWhere
//
// At this point, we have loaded all the lefthand instances.  We
// can use the binding property from these instances to build
// a where clause to be used when retrieve the righthand instances.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::FindWhere(

    TRefPointerCollection<CInstance> &lefts,
    CHStringArray &sLeftWheres
)
{
    REFPTRCOLLECTION_POSITION posLeft;
    CInstancePtr pLeft;
    HRESULT hr = WBEM_S_NO_ERROR;

    if (lefts.BeginEnum(posLeft))
    {
        variant_t   vLeftBindingPropertyValue;
        CHString sTemp;

        // Walk the left instances
        for (pLeft.Attach(lefts.GetNext(posLeft)) ;
            (pLeft != NULL) ;
            pLeft.Attach(lefts.GetNext(posLeft)) )
        {
            // Get the binding property from the left
            if (pLeft->GetVariant(m_sLeftBindingPropertyName, vLeftBindingPropertyValue))
            {
                // Turn it into a where clause
                hr = MakeString(&vLeftBindingPropertyValue, sTemp);

                // See if we alread have this where clause
                if (SUCCEEDED(hr) && IsInList(sLeftWheres, sTemp) == -1)
                {
                    // A query with 1000 where clauses isn't going
                    // to be very efficient either.  Pick a reasonable limit
                    if (sLeftWheres.GetSize() < MAX_ORS)
                    {
                        sLeftWheres.Add(sTemp);
                    }
                    else
                    {
                        // Too many.  Fall back to enum
                        sLeftWheres.RemoveAll();
                        break;
                    }
                }

                vLeftBindingPropertyValue.Clear();
            }
            else
            {
                hr = WBEM_E_FAILED;
                break;
            }
        }

        lefts.EndEnum();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::MakeString
//
// Turn the bindingproperty value into a string suitable for using
// in a wql where clause.
//
/////////////////////////////////////////////////////////////////////

HRESULT CBinding::MakeString(VARIANT *pvValue, CHString &sTemp)
{
    bool bIsString = V_VT(pvValue) == VT_BSTR;
    HRESULT hr = VariantChangeType(
        
            pvValue, 
            pvValue, 
            VARIANT_NOVALUEPROP, 
            VT_BSTR
    );

    if (SUCCEEDED(hr))
    {
        // If the original type was string, we need to escape quotes
        // and backslashes, and put double quotes around it.
        if (bIsString)
        {
            CHString sTemp2;
            EscapeCharacters(V_BSTR(pvValue), sTemp2);

            sTemp.Format(L"\"%s\"", (LPCWSTR)sTemp2);
        }
        else
        {
            sTemp = V_BSTR(pvValue);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::IsInList
//
// See whether a given string already exists in a chstring array.
//
/////////////////////////////////////////////////////////////////////

DWORD CBinding::IsInList(
                                
    const CHStringArray &csaArray, 
    LPCWSTR pwszValue
)
{
    DWORD dwSize = csaArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        // Note this is a CASE INSENSITIVE compare
        if (_wcsicmp(csaArray[x], pwszValue) == 0)
        {
            return x;
        }
    }

    return -1;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::CompareVariantsNoCase
//
// Compare two variants to see if they are the same.
//
/////////////////////////////////////////////////////////////////////

bool CBinding::CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2)
{
   if (v1->vt == v2->vt)
   {
      switch (v1->vt)
      {
          case VT_NULL: return false;
          case VT_BOOL: return (v1->boolVal == v2->boolVal);
          case VT_UI1:  return (v1->bVal == v2->bVal);
          case VT_I2:   return (v1->iVal == v2->iVal);
          case VT_I4:   return (v1->lVal == v2->lVal);
          case VT_R4:   return (v1->fltVal == v2->fltVal);
          case VT_R8:   return (v1->dblVal == v2->dblVal);
          case VT_BSTR:
          {
              if ( (v1->bstrVal == v2->bstrVal) || // deal with both being NULL
                   (0 == _wcsicmp(v1->bstrVal, v2->bstrVal)) )
              {                   
                  return true;
              }
              else
              {
                  return false;
              }
          }
          default:
          {
              // Should never get here
          }
      }
   }

   return false;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CBinding::EscapeBackslashes
//
// Prefix " and \ characters with an additional \
//
/////////////////////////////////////////////////////////////////////

VOID CBinding::EscapeCharacters(LPCWSTR wszIn,
                     CHString& chstrOut)
{
    CHString chstrCpyNormPathname(wszIn);
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next character to escape
    while( (lNext = chstrCpyNormPathname.FindOneOf(L"\"\\") ) != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrOut += _T('\\');
        // Hack off from the input string the portion we just copied
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
    }

    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\assoc.cpp ===
//=================================================================================================

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// assoc.cpp -- Rule-based association class
//
// This class allows for the creation of a specific type of rule-based associations.  Consider 
// this example:
// 
//     CAssociation MyThisComputerPhysicalFixedDisk(
//         L"ThisComputerPhysicalFixedDisk",
//         L"Root\\default",
//         L"ThisComputer",
//         L"PhysicalFixedDisk",
//         L"GroupComponent",
//         L"PartComponent"
//     ) ;
// 
// This declaration is saying that there is a class named "ThisComputerPhysicalFixedDisk" which 
// resides in the "root\default" namespace.  It is an association between the "ThisComputer" 
// class, and the "PhysicalFixedDisk" class.  The "ThisComputer" value goes into the 
// "GroupComponent" property of the "ThisComputerPhysicalFixedDisk" class, and the 
// "PhysicalFixedDisk" value goes in the "PartComponent" property of the 
// "ThisComputerPhysicalFixedDisk" class.
// 
// Some notes:
// - This class will take all the instances of the left class ("ThisComputer" in the example
// above) and relate them to ALL instances of the right class ("PhysicalFixedDisk" in the example
// above).  So, if there are 3 instances of the left class, and 4 instances of the right class,
// this association class will return 12 instances.
// 
// - When choosing which of the two classes should be the left class, choose the class that is
// likely to have fewer instances.  This will result in less memory being used, and instances
// being sent back to the client sooner.
// 
// - CAssociation supports ExecQuery, GetObject, and EnumerateInstances.
// 
// - CAssociation is designed to be derived from.  For example, if your association needs to 
// support DeleteInstance, ExecMethod, or PutInstance, create a class that derives from 
// CAssociation, and add the appropriate methods.  Also, various methods such as 
// LoadPropertyValues and AreRelated may be useful for further customization.
// 
// - The two endpoint classes can be dynamic, static, or abstract.  CAssociation will do a deep 
// enumeration (actually a query, which is always deep) to retrieve the instances.
//
// - When calling the endpoint classes, CAssociation will use per property gets, and queries
// with Select clauses and/or Where statements.  If the endpoint classes support per-property
// gets or queries, this will result in better performance for the associaton class.
//
// - The association class and both endpoints must all be in the same namespace.
// 
// See also: CBinding (binding.cpp) for a different type of rule-based association.
//
//=================================================================================================

#include "precomp.h"
#include "Assoc.h"

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::CAssociation
//
// Constructor.
//
/////////////////////////////////////////////////////////////////////

CAssociation::CAssociation(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName

) : Provider(pwszClassName, pwszNamespaceName)
{
    // Save off the class and property names
    m_sLeftClassName = pwszLeftClassName;
    m_sRightClassName = pwszRightClassName;

    m_sLeftPropertyName = pwszLeftPropertyName;
    m_sRightPropertyName = pwszRightPropertyName;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::~CAssociation
//
// Destructor
//
/////////////////////////////////////////////////////////////////////

CAssociation::~CAssociation()
{
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::ExecQuery
//
// This routine will optimize on queries of the form:
// WHERE prop1 = value1 [ or prop1 = value2 ...]
// 
// This type of query is commonly seen when doing an ASSOCIATORS or 
// REFERENCES query against one of the endpoint classes.
// 
// This routine will also optimize on queries of the form:
// WHERE prop1 = value1 [ or prop1 = value2 ...] AND 
//       prop2 = value3 [ or prop2 = value4 ...]
// 
// It will NOT optmize on queries of the form:
// WHERE prop1 <> value1
// WHERE prop1 > value1
// WHERE prop1 = value1 OR prop2 = value2
// 
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::ExecQuery(

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> lefts;

    CHStringArray sLeftPaths, sRightPaths;

    // Look for WHERE m_sLeftPropertyName=value1
    pQuery.GetValuesForProp ( m_sLeftPropertyName, sLeftPaths ) ;

    // Look for WHERE m_sRightPropertyName=value1
    pQuery.GetValuesForProp ( m_sRightPropertyName, sRightPaths ) ;

    if (sLeftPaths.GetSize() == 0)
    {
        // They didn't ask for a specific set of left instances.  However,
        // it may be that we can figure out what left instances we need
        // by looking at what right instances they requested.  CAssociation 
        // doesn't do this, but CBinding does.
        CHStringArray sRightWheres;
        bool bHadRights = sRightPaths.GetSize() > 0;

        MakeWhere(sRightPaths, sRightWheres);

        // If we used to have a list of RightWheres, and MakeWhere discarded
        // them all as unusable, then there aren't going to be any
        // instances that match the query.
        if (!bHadRights || sRightPaths.GetSize() > 0)
        {
            // GetLeftInstances populates lefts using a sRightWheres
            // to construct a query.
            hr = GetLeftInstances(pMethodContext, lefts, sRightWheres);
        }
    }
    else
    {
        // For each sLeftPaths that is valid, create an entry in lefts by
        // doing a GetObject on the sLeftPaths entry.
        hr = ValidateLeftObjectPaths(pMethodContext, sLeftPaths, lefts);
    }

    // If we failed, or if there are no instances on the left, there's
    // no point in continuing.
    if (SUCCEEDED(hr) && lefts.GetSize() > 0)
    {
        // If the where clause didn't specify any value for the right property
        if (sRightPaths.GetSize() == 0)
        {
            // We may be able to use the information from the already retrieved 
            // left instances to limit which instances we retrieve from the right.
            // CAssociation doesn't do this, but CBinding does.
            CHStringArray sLeftWheres;
            hr = FindWhere(lefts, sLeftWheres);

            if (SUCCEEDED(hr))
            {
                // GetRightInstances takes the 'lefts' and rubs all the
                // rights against them creating instances where appropriate
                hr = GetRightInstances(pMethodContext, &lefts, sLeftWheres);
            }
        }
        else
        {
            // They gave us a list of object paths for the righthand property
            TRefPointerCollection<CInstance> rights;

            // For each sRightPaths that is valid, create an instance
            hr = ValidateRightObjectPaths(pMethodContext, sRightPaths, lefts);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::GetObject
//
// Verify the exist of the specified association class instance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::GetObject(

    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString sLeftPath, sRightPath;

    // Get the two endpoints to verify
    if (pInstance->GetCHString(m_sLeftPropertyName, sLeftPath ) &&
        pInstance->GetCHString(m_sRightPropertyName, sRightPath ) )
    {
        CInstancePtr pLeft, pRight;

        // Try to get the objects
        if (
                SUCCEEDED(hr = RetrieveLeftInstance(

                                    sLeftPath, 
                                    &pLeft, 
                                    pInstance->GetMethodContext())
                       ) &&
                SUCCEEDED(hr = RetrieveRightInstance(

                                    sRightPath, 
                                    &pRight, 
                                    pInstance->GetMethodContext())
                         ) 
           )
        {

            hr = WBEM_E_NOT_FOUND;

            // So, the end points exist.  Are they derived from or equal 
            // to the classes we are working with?
            CHString sLeftClass, sRightClass;

            pLeft->GetCHString(L"__Class", sLeftClass);
            pRight->GetCHString(L"__Class", sRightClass);

            bool bDerived = IsDerivedFrom(

                                m_sLeftClassName, 
                                sLeftClass, 
                                pInstance->GetMethodContext()
                            );

            if (bDerived)
            {
                bDerived = IsDerivedFrom(

                                m_sRightClassName, 
                                sRightClass, 
                                pInstance->GetMethodContext()
                            );
            }

            if (bDerived)
            {
                // Just because two instances are valid and derive from the right class, 
                // doesn't mean they are related.  Do any other checks.
                if (AreRelated(pLeft, pRight))
                {
                    // CBinding and CAssoc don't populate any additional properties, but
                    // an overload of one of these classes might.
                    hr = LoadPropertyValues(pInstance, pLeft, pRight);
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::EnumerateInstances
//
// Return all instances of the association class
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::EnumerateInstances(

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRefPointerCollection<CInstance> lefts;
    CHStringArray sWheres;

    // GetLeftInstances populates lefts
    if (SUCCEEDED(hr = GetLeftInstances(pMethodContext, lefts, sWheres)))
    {
        // We may be able to use the information from the already retrieved 
        // left instances to limit which instances we retrieve from the right.
        // CAssociation doesn't do this, but CBinding does.
        FindWhere(lefts, sWheres);

        // GetRightInstances takes the 'lefts' and rubs all the
        // rights against them
        hr = GetRightInstances(pMethodContext, &lefts, sWheres);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::GetRightInstances
//
// For each instance of the righthand class retrieved, call
// CAssociation::StaticEnumerationCallback.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts,
    const CHStringArray &sLeftWheres
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_sRightClassName);

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        GetNamespace(),
        pMethodContext,
        lefts);

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::StaticEnumerationCallback
//
// Put the 'this' pointer back, and call CAssociation::EnumerationCallback
//
/////////////////////////////////////////////////////////////////////

HRESULT WINAPI CAssociation::StaticEnumerationCallback(

    Provider* pThat,
    CInstance* pInstance,
    MethodContext* pContext,
    void* pUserData
)
{
    HRESULT hr;

    CAssociation *pThis = (CAssociation *) pThat;

    if (pThis)
    {
        hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
    }
    else
    {
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::EnumerationCallback
//
// Take the righthand instance that was passed in and pair it
// with each of the left hand instances.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::EnumerationCallback(

    CInstance *pRight,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    HRESULT hr = WBEM_E_FAILED;

    CInstancePtr pLeft;
    REFPTRCOLLECTION_POSITION posLeft;
    CHString sLeftPath, sRightPath;

    // Cast for userdata back to what it is
    TRefPointerCollection<CInstance> *pLefts = (TRefPointerCollection<CInstance> *)pUserData;

    if (pLefts->BeginEnum(posLeft))
    {
        hr = WBEM_S_NO_ERROR;

        // Walk all the pLefts
        for (pLeft.Attach(pLefts->GetNext(posLeft)) ;
            (SUCCEEDED(hr)) && (pLeft != NULL) ;
            pLeft.Attach(pLefts->GetNext(posLeft)) )
        {
            // Compare it to the current pRight
            if(AreRelated(pLeft, pRight))
            {
                // We have a winner.  Populate the properties and send it back.
                if (GetLocalInstancePath(pLeft,  sLeftPath) &&
                    GetLocalInstancePath(pRight, sRightPath))
                {
                    CInstancePtr pNewAssoc(CreateNewInstance(pMethodContext), false);

                    if (pNewAssoc->SetCHString(m_sLeftPropertyName, sLeftPath) &&
                        pNewAssoc->SetCHString(m_sRightPropertyName, sRightPath) )
                    {
                        if (SUCCEEDED(hr = LoadPropertyValues(pNewAssoc, pLeft, pRight)))
                        {
                            hr = pNewAssoc->Commit();
                        }
                    }
                }
            }
        }

        pLefts->EndEnum();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::ValidateLeftObjectPaths
//
// Populate the lefts array by doing GetObjects on the object paths
// passed in sPaths.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::ValidateLeftObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    CInstancePtr pInstance;

    // Walk the object paths
    for (DWORD x=0; x < sPaths.GetSize(); x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;
        CHString sPath(sPaths[x]);

        // Parse the object path
        int nStatus = objpathParser.Parse( sPath,  &pParsedPath );

        if ( 0 == nStatus )
        {
            // Is this class derived from or equal to the lefthand class?
            bool bDerived = false;

            try
            {
                bDerived = IsDerivedFrom(

                                m_sLeftClassName, 
                                pParsedPath->m_pClass, 
                                pMethodContext
                            );

                // Make sure this is an absolute path
                if (pParsedPath->m_dwNumNamespaces == 0)
                {
                    sPath = L"\\\\.\\" + GetNamespace() + L':' + sPath;
                }

            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );

            if (bDerived)
            {
                // See if it is valid.  Note that we DON'T send back an error just because
                // we can't find one of the object paths.
                if (SUCCEEDED(RetrieveLeftInstance(sPath, &pInstance, pMethodContext)))
                {
                    // Yup, add it to the list
                    lefts.Add(pInstance);
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::ValidateRightObjectPaths
//
// Retrieve the righthand instances by doing GetObjects on the object 
// paths passed in sPaths.  Pass them to EnumerationCallback.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::ValidateRightObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    HRESULT hr = WBEM_S_NO_ERROR;;
    CInstancePtr pInstance;
    
    // Walk the object paths
    for (DWORD x=0;
    (x < sPaths.GetSize()) && SUCCEEDED(hr);
    x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;
        CHString sPath(sPaths[x]);
        
        int nStatus = objpathParser.Parse( sPath,  &pParsedPath );
        
        if ( 0 == nStatus )
        {
            bool bDerived = false;
            try
            {
                // Make sure this object path is at least related to us
                bDerived = IsDerivedFrom(
                    
                    m_sRightClassName, 
                    pParsedPath->m_pClass, 
                    pMethodContext
                    );
                
                // Make sure this is an absolute path
                if (pParsedPath->m_dwNumNamespaces == 0)
                {
                    sPath = L"\\\\.\\" + GetNamespace() + L':' + sPath;
                }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }
            
            objpathParser.Free( pParsedPath );
            
            if (bDerived)
            {
                // See if it is valid.  Note that we DON'T send back an error just because
                // we can't find one of the object paths.
                if (SUCCEEDED(RetrieveRightInstance(sPath, &pInstance, pMethodContext)))
                {
                    hr = EnumerationCallback(pInstance, pMethodContext, &lefts);
                }
            }
        }
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::GetLeftInstances
//
// Retrieve all the lefthand instances and store them in lefts
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts,
    const CHStringArray &sRightWheres
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_sLeftClassName);

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext, GetNamespace());
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::RetrieveLeftInstance
//
// Retrieve a specific lefthand instance.  Use per-property gets
// to only request the keys for maximum performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::RetrieveRightInstance
//
// Retrieve a specific righthand instance.  Use per-property gets
// to only request the keys for maximum performance.
//
/////////////////////////////////////////////////////////////////////

HRESULT CAssociation::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::IsInstance
//
// See whether the specified CInstance is an Instance object, or a
// Class object.
//
/////////////////////////////////////////////////////////////////////

bool CAssociation::IsInstance(const CInstance *pInstance)
{
    DWORD dwGenus = 0;

    pInstance->GetDWORD(L"__Genus", dwGenus);

    return dwGenus == WBEM_GENUS_INSTANCE;
}

/////////////////////////////////////////////////////////////////////
//
// Function:   CAssociation::IsDerivedFrom
//
// See whether the specified class is derived from or equal 
// to the class we are working with.  Specifically, does 
// pszDerivedClassName derive from pszBaseClassName?
//
/////////////////////////////////////////////////////////////////////

bool CAssociation::IsDerivedFrom(
                              
    LPCWSTR pszBaseClassName, 
    LPCWSTR pszDerivedClassName, 
    MethodContext *pMethodContext
)
{
    // First let's see if they are equal.  CWbemProviderGlue::IsDerivedFrom 
    // doesn't check for this case
    bool bDerived = _wcsicmp(pszBaseClassName, pszDerivedClassName) == 0;
    if (!bDerived)
    {
        bDerived = CWbemProviderGlue::IsDerivedFrom(
            
                                            pszBaseClassName, 
                                            pszDerivedClassName, 
                                            pMethodContext,
                                            GetNamespace()
                                        );
    }

    return bDerived;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cachedconfigmgrdata.cpp ===
//=================================================================

//

// CachedConfigMgrData.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include "CachedConfigMgrData.h"

#define CFGMGR_WORRY_SIZE 250  //from confgmgr.h

/**********************************************************************************************************
 * Register this class with the CResourceManager.
 **********************************************************************************************************/

// {7EF4F49D-C836-11d2-B353-00105A1F8569}
static const GUID guidCACHEDCONFIGMGRDATA =
{ 0x7ef4f49d, 0xc836, 0x11d2, { 0xb3, 0x53, 0x0, 0x10, 0x5a, 0x1f, 0x85, 0x69 } };


class CCachedConfigMgrDataCreatorRegistration
{
public:
	CCachedConfigMgrDataCreatorRegistration ()
	{
		CResourceManager::sm_TheResourceManager.AddInstanceCreator ( guidCACHEDCONFIGMGRDATA, CCachedConfigMgrDataCreator ) ;
	}
	~CCachedConfigMgrDataCreatorRegistration	()
	{}

	static CResource * CCachedConfigMgrDataCreator ( PVOID pData )
	{
		return new CCachedConfigMgrData ;
	}

};

CCachedConfigMgrDataCreatorRegistration MyCCachedConfigMgrDataCreatorRegistration ;

/**************************************************************************************************************/


CCachedConfigMgrData :: CCachedConfigMgrData ()
{
	fReturn = GetDeviceList () ;
}

CCachedConfigMgrData :: ~CCachedConfigMgrData ()
{
}

BOOL CCachedConfigMgrData :: GetDeviceList ()
{
	CONFIGRET		cr;
	CConfigMgrAPI*	pconfigmgrapi = ( CConfigMgrAPI* ) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;

	DEVNODE dnRoot;
	if ( CR_SUCCESS == ( cr = pconfigmgrapi->CM_Locate_DevNode( &dnRoot, NULL, 0 ) ) )
	{
		DEVNODE dnFirst;
		if ( CR_SUCCESS == ( cr = pconfigmgrapi->CM_Get_Child( &dnFirst, dnRoot, 0 ) ) )
		{
			// This should only fail in case we are unable to allocate a device
			if ( !WalkDeviceTree2( dnFirst, pconfigmgrapi ) )
			{
				cr = CR_OUT_OF_MEMORY;
			}
		}
	}
	CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgrapi ) ;
	return ( CR_SUCCESS == cr );
}


BOOL CCachedConfigMgrData :: WalkDeviceTree2( DEVNODE dn, CConfigMgrAPI*	pconfigmgrapi )
{
	BOOL				fReturn = TRUE;	// Assume TRUE, the only failure is where we
										// beef allocating a device.
    BOOL                fIsLoop = FALSE; // Config manager has a bug that causes a loop in device lists<sigh>
    CConfigMgrDevicePtr pDevice(NULL);
//	CHString			strFilterValue;
    DEVNODE				dnSibling,
						dnChild;

	// We're walking the list for siblings and children.  Waliing for siblings
	// is done in the context of the following loop, since siblings are at
	// the same level in the tree.  Walking for children is, of course, recursive.

    do
    {
		// Store siblings, since we will proceed from it to the next
		// sibling.

		if ( CR_SUCCESS != pconfigmgrapi->CM_Get_Sibling( &dnSibling, dn, 0 ) )
		{
			dnSibling = NULL;
		}

		// Allocate a new device, and if it passes through our filter, or if
		// there is no filter, go ahead and store the device in the device collection.

		pDevice.Attach(new CConfigMgrDevice( dn, ResType_All )) ;

		if	( NULL != pDevice )
		{

            if (deviceList.GetSize() > CFGMGR_WORRY_SIZE)
            {
                fIsLoop = CheckForLoop ( pDevice ) ;
            }

            if (!fIsLoop)
            {
                // While it would make more sense to check the filter in WalkDeviceTree2,
                // we can't.  Config manager sometimes has a loop in its nodes.  As a result,
                // we need to be checking the entire list for a loop, so we need to apply
                // the filter here.

				fReturn = deviceList.Add( pDevice );
            }

		}	// IF NULL != pszDevice
		else
		{
			// We just beefed on memory, so bail out while the gettin's good
			fReturn = FALSE;
		}

		// If we have a child, we must walk recursively.
		// Note that fReturn of FALSE supercedes all of this.

		if ( fReturn &&	!fIsLoop && CR_SUCCESS == pconfigmgrapi->CM_Get_Child( &dnChild, dn, 0 ) )
		{
			fReturn = WalkDeviceTree2( dnChild, pconfigmgrapi );
		}

		// The new active node will be our sibling.
		dn = dnSibling;

    } while ( fReturn && NULL != dn && !fIsLoop );

    return fReturn;
}

BOOL CCachedConfigMgrData :: CheckForLoop ( CConfigMgrDevice* pInDevice )
{
    DWORD dwSize, x, y;
    BOOL bIsLoop = FALSE;
    CConfigMgrDevicePtr pDevice1(NULL);
    CConfigMgrDevicePtr pDevice2(NULL);

    // Get the list size
    dwSize = deviceList.GetSize()-1;

    // If it is in here, it is probably close to the end, let's walk backward
    for (x = dwSize; ((x > 0) && (!bIsLoop)); x--)
    {
        pDevice1.Attach(deviceList.GetAt(x));

        // This compares the device nodes (see CConfigMgrDevice)
        if (*pDevice1 == *pInDevice)
        {
            // Yup, there's a loop
            bIsLoop = TRUE;
        }
    }

    // If there is a loop, let's drop off the duplicated elements
    if (bIsLoop)
    {
        // Remember, x get decremented one more time from the last loop
        y = dwSize;
        do {
            pDevice1.Attach(deviceList.GetAt(x--));
            pDevice2.Attach(deviceList.GetAt(y--));
        } while ((*pDevice1 == *pDevice2) && (x > 0));

        // Delete all the duplicate elements
        y++;
        for (x = dwSize; x > y; x--)
        {
            deviceList.Remove(x);
        }
    }

    return bIsLoop;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cautolock.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CAutoLock.h -- Automatic locking class for mutexes and critical sections.

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#ifndef __CAUTOLOCK_H__
#define __CAUTOLOCK_H__

#include "CGlobal.h"
#include "CMutex.h"
#include "CCriticalSec.h"

class CAutoLock 
{
private:
    HANDLE m_hMutexHandle;
    CRITICAL_SECTION* m_pCritSec;
    CMutex* m_pcMutex;
    CCriticalSec* m_pcCritSec;

public:
    // Constructors
    CAutoLock( HANDLE hMutexHandle);    
    CAutoLock( CMutex& rCMutex);
    CAutoLock( CRITICAL_SECTION* pCritSec);
    CAutoLock( CCriticalSec& rCCriticalSec);

    // Destructor
    ~CAutoLock();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ccriticalsec.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CCriticalSec.h -- Critical Section Wrapper

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#ifndef __CCriticalSec_H__
#define __CCriticalSec_H__

#include <windows.h>
#include <process.h>

class CCriticalSec 
{
private:
    CRITICAL_SECTION m_cs;

public:
    CCriticalSec();
    virtual ~CCriticalSec();

    // Enter the critical section:
    void Enter();

    // Leave the critical section:
    void Leave();

    // return a pointer to the internal
    // critical section...
    CRITICAL_SECTION* GetCritSec();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ccriticalsec.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CCriticalSec.cpp -- Critical Section Wrapper

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#include "precomp.h"
#include "CCriticalSec.h"

CCriticalSec::CCriticalSec()
{
    ::InitializeCriticalSection(&m_cs);
}

CCriticalSec::~CCriticalSec()
{
    ::DeleteCriticalSection(&m_cs);
}

void CCriticalSec::Enter()
{
    ::EnterCriticalSection(&m_cs);
}

void CCriticalSec::Leave()
{
    ::LeaveCriticalSection(&m_cs);
}

CRITICAL_SECTION *CCriticalSec::GetCritSec()
{
    return &m_cs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cevent.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CThreadPool.cpp -- Thread pool class

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//============================================================================
#ifndef __CEVENT_H__
#define __CEVENT_H__

#include "CGlobal.h"
#include "CKernel.h"

class CEvent : public CKernel 
{
public:
    // constructor creates an event object...
    CEvent( BOOL bManualReset = FALSE, 
            BOOL bInitialState = FALSE, 
            LPCTSTR lpName = NULL, 
            LPSECURITY_ATTRIBUTES lpEventAttributes = NULL);
    
    // constructor opens an existing named event,
    // you must check the status after using this constructor,
    // it will NOT throw an error exception if the object cannot be opened...
    CEvent( LPCTSTR lpName, 
            BOOL bInheritHandle = FALSE, 
            DWORD dwDesiredAccess = EVENT_ALL_ACCESS);

    // operations on event object...
    BOOL Set(void);
    BOOL Reset(void);
    BOOL Pulse(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cevent.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CThreadPool.cpp -- Thread pool class

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//============================================================================
#include "precomp.h"
#include "CEvent.h"

// constructor creates an event object...
CEvent::CEvent( BOOL bManualReset,
                BOOL bInitialState,
                LPCTSTR lpName,
                LPSECURITY_ATTRIBUTES lpEventAttributes)
{
    m_hHandle = ::CreateEvent( lpEventAttributes, bManualReset, bInitialState, lpName);
    if (CIsValidHandle(m_hHandle))
    {
        if (lpName)
        {
            m_dwStatus = GetLastError();
        }
        else
        {
            m_dwStatus = NO_ERROR;
        }
    }
    else
    {
        m_dwStatus = GetLastError();
        ThrowError(m_dwStatus);
    }
}

// constructor opens an existing named event...
CEvent::CEvent( LPCTSTR lpName, BOOL bInheritHandle, DWORD dwDesiredAccess)
{
    m_hHandle = ::OpenEvent( dwDesiredAccess, bInheritHandle, lpName);
    if (CIsValidHandle(m_hHandle))
    {
        m_dwStatus = NO_ERROR;
    }
    else
    {
        m_dwStatus = GetLastError();
    }
}

// operations on event object...
BOOL CEvent::Set(void)
{
    return ::SetEvent(m_hHandle);
}

BOOL CEvent::Reset(void)
{
    return ::ResetEvent(m_hHandle);
}

BOOL CEvent::Pulse(void)
{
    return ::PulseEvent(m_hHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cglobal.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CGlobal.cpp -- Global functions

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================
#include "precomp.h"
#include "CGlobal.h"
/*
void CInternalThrowError(DWORD dwStatus, LPCWSTR lpFilename, int line)
{
#ifdef _DEBUG
    // print the error for debug builds...
    WCHAR string[2*MAX_PATH];
    wsprintf( string, "C Library Win32 Error 0x%08x(%d) at %s line %d\n",
                dwStatus, dwStatus, lpFilename, line);
    OutputDebugString(string);
#endif

#if __C_THROW_EXCEPTIONS__
    // throw exception for fatal errors...
    throw dwStatus;
#endif
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cfgmgrdevice.cpp ===
/////////////////////////////////////////////////////////////////////////

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//  History:    10/15/97        Sanj        Created by Sanj
//              10/17/97        jennymc     Moved things a tiny bit
//
/////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>
#include "poormansresource.h"
#include "resourcedesc.h"
#include "irqdesc.h"

#include <regstr.h>
#include "refptr.h"

#include "cfgmgrdevice.h"
#include "irqdesc.h"
#include "iodesc.h"        // don't need this yet
#include "devdesc.h"       // don't need this yet
#include "dmadesc.h"
#include <cregcls.h>
#include "nt4svctoresmap.h"
#include "chwres.h"
#include "configmgrapi.h"
#include <map>
// The Map we will use below is an STL Template, so make sure we have the std namespace
// available to us.

using namespace std;

typedef ULONG (WINAPI  *CIM16GetConfigManagerStatus)(LPSTR HardwareKey);

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::CConfigMgrDevice
//
//	Class Constructor.
//
//	Inputs:		LPCTSTR		pszConfigMgrName - Name of device in config
//							manager (HKEY_DYN_DATA\Config Manager\Enum
//							subkey).
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CConfigMgrDevice::CConfigMgrDevice( LPCWSTR pszConfigMgrName,DWORD dwTypeToGet )
:					CRefPtrLite(),
                	m_strConfigMgrName( pszConfigMgrName ),
	                m_strHardwareKey(),
	                m_strDeviceDesc(),
	                m_pbAllocationData( NULL ),
	                m_dwSizeAllocationData( 0 )
{
    m_dwTypeToGet = dwTypeToGet;
	GetConfigMgrInfo();
	GetDeviceInfo();
}
////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::CConfigMgrDevice
//
//	Class Constructor.
//
//	Inputs:		LPCTSTR		pszConfigMgrName - Name of device in config
//							manager (HKEY_DYN_DATA\Config Manager\Enum
//							subkey).
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////
/*CConfigMgrDevice::CConfigMgrDevice( LPCWSTR pszConfigMgrName )
:					CRefPtrLite(),
                	m_strConfigMgrName( pszConfigMgrName ),
	                m_strHardwareKey(),
	                m_strDeviceDesc(),
	                m_pbAllocationData( NULL ),
	                m_dwSizeAllocationData( 0 )
{
    m_dwTypeToGet = 0;
	//=========================================================
	//  If this is a key, then we need to find the device name
	//=========================================================
	if( -1 != m_strConfigMgrName.Find(L"\\") ){
		if( !MapKeyToConfigMgrDeviceName()){
			m_strConfigMgrName.Empty();
		}
	}
	if( !m_strConfigMgrName.IsEmpty()){
		GetConfigMgrInfo();
		GetDeviceInfo();
	}
}
*/
////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::CConfigMgrDevice
//
//	Class Constructor.
//
//	Inputs:		DEVNODE		m_dn - Device Node  from tree
//				DWORD		dwResType - Resource Types to Enum
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////
CConfigMgrDevice::CConfigMgrDevice( DEVNODE dn, DWORD dwResType /*=ResType_All*/ )
:					CRefPtrLite(),
                	m_strConfigMgrName(),
	                m_strHardwareKey(),
	                m_strDeviceDesc(),
	                m_pbAllocationData( NULL ),
	                m_dwSizeAllocationData( 0 ),
					m_dn( dn ),
					m_dwTypeToGet( dwResType )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::~CConfigMgrDevice
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CConfigMgrDevice::~CConfigMgrDevice( void )
{
	if ( NULL != m_pbAllocationData ){
		delete [] m_pbAllocationData;
		m_pbAllocationData = NULL;
	}
}
////////////////////////////////////////////////////////////////////////
//
//  This function searches for the configuration manager device name
//  based on the
//
////////////////////////////////////////////////////////////////////////
BOOL CConfigMgrDevice::MapKeyToConfigMgrDeviceName()
{
	BOOL fRc = FALSE;
    CRegistrySearch Search;
    CHPtrArray chsaList;
	CHString  *pPtr;

	Search.SearchAndBuildList( _T("Config Manager\\Enum"), chsaList,
							   m_strConfigMgrName,
							   _T("HardWareKey"),
							   VALUE_SEARCH,HKEY_DYN_DATA );
    if( chsaList.GetSize() > 0 ){

        pPtr = ( CHString *) chsaList.GetAt(0);
		WCHAR szTmp[50];
      szTmp[0] = _T('\0');
		swscanf(*pPtr, L"Config Manager\\Enum\\%s", szTmp);
      m_strConfigMgrName = CHString(szTmp);
		fRc = TRUE;
    }
    Search.FreeSearchList( CSTRING_PTR, chsaList );

	return fRc;

}

////////////////////////////////////////////////////////////////////////
#ifdef WIN9XONLY
DWORD CConfigMgrDevice::GetStatusFromConfigManagerDirectly(void)
{
    DWORD dwStatus = 0L;
        // thunk down to 16-bit to get it
    CCim32NetApi *t_pCim32Api = HoldSingleCim32NetPtr::GetCim32NetApiPtr();
    if( t_pCim32Api)
    {
        dwStatus = (t_pCim32Api->GetWin9XConfigManagerStatus)((char*)(const char*)_bstr_t(m_strHardwareKey));
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Api);
        t_pCim32Api = NULL;
	}
    return dwStatus;
}
#endif

////////////////////////////////////////////////////////////////////////
//
//  This function translates the binary status code from the registry
//  into the following values:
//     OK, ERROR, DEGRADED, UNKNOWN
//
////////////////////////////////////////////////////////////////////////
BOOL CConfigMgrDevice::GetStatus(CHString & chsStatus)
{
	DWORD dwStatus = 0L;
	BOOL fRc = FALSE;
	CRegistry Reg;
	CHString chsKey = CONFIGMGR_ENUM_KEY+m_strConfigMgrName;

    chsStatus = IDS_STATUS_Unknown;

	// Do this the old tried and true LEGACY way.  Lose this code ASAP!
	if ( NULL == m_dn )
	{
#ifdef WIN9XONLY
		{
			if( !m_strHardwareKey.IsEmpty() )
			{
				dwStatus = GetStatusFromConfigManagerDirectly();
			}
		}
#endif
#ifdef NTONLY
		if( !m_strConfigMgrName.IsEmpty())
#endif
		{
			//===================================================
			//  Initialize
			//===================================================
			if( Reg.Open(HKEY_DYN_DATA, chsKey, KEY_READ) == ERROR_SUCCESS )
			{
                DWORD dwSize = 4;
				Reg.GetCurrentBinaryKeyValue(CONFIGMGR_DEVICE_STATUS_VALUE, (BYTE *)&dwStatus, &dwSize);
			}
		}
	}
	else
	{
		// Use the config manager to get the data for us
		GetStatus( &dwStatus, NULL );
	}

    if( dwStatus != 0L )
	{
		fRc = TRUE;
		//==============================================
		//  OK, these are wild guesses at translation,
		//  we may need to fiddle with these
		//==============================================
		if( dwStatus & DN_ROOT_ENUMERATED  ||
			dwStatus & DN_DRIVER_LOADED ||
			dwStatus & DN_ENUM_LOADED ||
			dwStatus & DN_STARTED ){
			chsStatus = IDS_STATUS_OK;
		}
		// we don't care about these:
		// DN_MANUAL,DN_NOT_FIRST_TIME,DN_HARDWARE_ENUM,DN_FILTERED
		// DN_DISABLEABLE, DN_REMOVABLE,DN_MF_PARENT,DN_MF_CHILD
	    // DN_NEED_TO_ENUM, DN_LIAR,DN_HAS_MARK
		if( dwStatus & DN_MOVED ||
			dwStatus & DN_WILL_BE_REMOVED){
			chsStatus = IDS_STATUS_Degraded;
		}

		if( dwStatus & DN_HAS_PROBLEM ||
			dwStatus & DN_PRIVATE_PROBLEM){
			chsStatus = IDS_STATUS_Error;
		}
	}
	return fRc;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetConfigMgrInfo
//
//	Opens the appropriate Config Manager SubKey and loads values from
//	there.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we open the subkey and get the values
//								we wanted.
//
//	Comments:	Needs to be able to get read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetConfigMgrInfo( void )
{
	BOOL	fReturn = FALSE;

	// For this to function correctly, we MUST have a value in
	// m_strConfigMgrName.


	if ( !m_strConfigMgrName.IsEmpty() ){
		HKEY	hConfigMgrKey = NULL;

		CHString	strKeyName( CONFIGMGR_ENUM_KEY );

		// Open the config manager key

		strKeyName += m_strConfigMgrName;	// Don't forget to concat name Sanj, you big dummy

		if ( ERROR_SUCCESS == RegOpenKeyEx(	HKEY_DYN_DATA,
											TOBSTRT(strKeyName),
											0,
											KEY_READ,
											&hConfigMgrKey ) )
		{
			// Get our hardware key, status and our resource allocation
			if ( GetHardwareKey( hConfigMgrKey ) )
			{
				// Status is device status information from the registry.
				if ( GetStatusInfo( hConfigMgrKey ) )
				{
					fReturn = GetResourceAllocation( hConfigMgrKey );
				}
			}

            RegCloseKey(hConfigMgrKey);
		}

	}

	return FALSE;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetHardwareKey
//
//	Gets the Config Manager HardwareKey value.
//
//	Inputs:		HKEY		Key - Config Manager SubKey to open.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the value.
//
//	Comments:	Needs to be able to get read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetHardwareKey( HKEY hKey )
{
	BOOL	fReturn					=	FALSE;
	DWORD	dwSizeHardwareKeyName	=	0;


	// First, get the Hardware key name buffer size.

	if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
											CONFIGMGR_DEVICE_HARDWAREKEY_VALUE,
											0,
											NULL,
											NULL,
											&dwSizeHardwareKeyName ) )
	{
		m_strHardwareKey = L"";

        // We do it this way since CHString no longer changes types with TCHAR
//		LPTSTR	pszBuffer = m_strHardwareKey.GetBuffer( dwSizeHardwareKeyName );
        LPTSTR  pszBuffer = new TCHAR[dwSizeHardwareKeyName]; //(LPTSTR) malloc(dwSizeHardwareKeyName * sizeof(TCHAR));

		if ( NULL != pszBuffer )
		{

            try
            {
			    // Now get the real buffer
			    if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
													    CONFIGMGR_DEVICE_HARDWAREKEY_VALUE,
													    0,
													    NULL,
													    (LPBYTE) pszBuffer,
													    &dwSizeHardwareKeyName ) )
			    {
				    fReturn = TRUE;
                    m_strHardwareKey = pszBuffer;
			    }
            }
            catch ( ... )
            {
    			delete [] pszBuffer;
                throw ;
            }

			delete [] pszBuffer;
		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }


	}	// IF RegQueryValue Ex

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetResourceAllocation
//
//	Gets the Config Manager Device Resource Allocation and fills
//	out the resource list as appropriate.
//
//	Inputs:		HKEY		Key - Config Manager SubKey to open.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the value.
//
//	Comments:	Must have read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetResourceAllocation( HKEY hKey )
{
	BOOL	fReturn					=	FALSE;
	DWORD	dwSizeAllocation		=	0;


	// First, get the buffer size.

	if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
											CONFIGMGR_DEVICE_ALLOCATION_VALUE,
											0,
											NULL,
											NULL,
											&dwSizeAllocation ) )
	{
		// Initialize pbData, using a stack buffer if we can (most of the time
		// this will probably suffice).
		LPBYTE	pbData	=	new BYTE[dwSizeAllocation];
		// Just be safe here.
		if ( NULL != pbData )
        {
			// Now get the real buffer

			if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
													CONFIGMGR_DEVICE_ALLOCATION_VALUE,
													0,
													NULL,
													pbData,
													&dwSizeAllocation ) )
			{
				m_pbAllocationData = pbData;
				m_dwSizeAllocationData = dwSizeAllocation;
				fReturn = TRUE;
			}

			// DON'T delete the data buffer.  The object destructor does it.
//				delete [] pbData;
		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }


	}	// IF RegQueryValue Ex

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetStatusInfo
//
//	Gets the Config Manager Device Status and Problem fields.
//
//	Inputs:		HKEY		Key - Config Manager SubKey to open.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the values.
//
//	Comments:	Must have read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetStatusInfo( HKEY hKey )
{
	BOOL	fReturn					=	FALSE;
	DWORD	dwBuffSize				=	sizeof(DWORD);


	// First, get the status value, then get the problem value.

	if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
											CONFIGMGR_DEVICE_STATUS_VALUET,
											0,
											NULL,
											(LPBYTE) &m_dwStatus,
											&dwBuffSize ) )
	{

		// Now get the problem

		dwBuffSize = sizeof(DWORD);

		if ( ERROR_SUCCESS == RegQueryValueEx(	hKey,
												CONFIGMGR_DEVICE_PROBLEM_VALUE,
												0,
												NULL,
												(LPBYTE) &m_dwProblem,
												&dwBuffSize ) )	{
			fReturn = TRUE;
		}

	}	// IF RegQueryValue Ex

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetDeviceInfo
//
//	Uses the HardwareKey value to get further device information.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the value(s).
//
//	Comments:	Needs to be able to get read access to the registry.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetDeviceInfo( void )
{
	BOOL	fReturn = FALSE;

	// For this to function correctly, we MUST have a value in
	// m_strHardwareKey


	if ( !m_strHardwareKey.IsEmpty() )
	{
		HKEY	hDeviceKey = NULL;

		CHString	strKeyName( LOCALMACHINE_ENUM_KEY );

		// Open the config manager key

		strKeyName += m_strHardwareKey;	// Don't forget to concat name Sanj, you big dummy

		if ( ERROR_SUCCESS == RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
											TOBSTRT(strKeyName),
											0,
											KEY_READ,
											&hDeviceKey ) )
		{
			fReturn = GetDeviceDesc( hDeviceKey );
            RegCloseKey(hDeviceKey);
		}

	}

	return FALSE;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetDeviceDesc
//
//	Gets the Device Description from the supplied subkey.
//
//	Inputs:		HKEY		Key - Device SubKey to get info from.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE	-	Did we get the value.
//
//	Comments:	If the value doesn't exist, this is not an error.  We'll
//				just clear the value.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetDeviceDesc( HKEY hKey )
{
	BOOL	fReturn				=	FALSE;
	DWORD	dwSizeDeviceName	=	0;
	LONG	lReturn				=	0L;


	// First, get the DeviceDesc buffer size.

	if ( ( lReturn = RegQueryValueEx(	hKey,
										CONFIGMGR_DEVICEDESC_VALUE,
										0,
										NULL,
										NULL,
										&dwSizeDeviceName ) )
					== ERROR_SUCCESS )
	{
		//LPTSTR	pszBuffer = m_strDeviceDesc.GetBuffer( dwSizeDeviceName );
        LPTSTR pszBuffer = new TCHAR[dwSizeDeviceName]; //(LPTSTR) malloc(dwSizeDeviceName * sizeof(TCHAR));

		m_strDeviceDesc = L"";
        // Just be safe here.

		if ( NULL != pszBuffer )
		{
            try
            {
			    // Now get the real buffer

			    if ( ( lReturn = RegQueryValueEx(	hKey,
												    CONFIGMGR_DEVICEDESC_VALUE,
												    0,
												    NULL,
												    (LPBYTE) pszBuffer,
												    &dwSizeDeviceName ) )
							    == ERROR_SUCCESS )
			    {
				    fReturn = TRUE;
                    m_strDeviceDesc = pszBuffer;
			    }
			    else
			    {
				    fReturn = ( ERROR_FILE_NOT_FOUND == lReturn );
			    }
            }
            catch ( ... )
            {
                delete [] pszBuffer;
                throw ;
            }

			//m_strDeviceDesc.ReleaseBuffer();	// Resets to string size
            delete [] pszBuffer;
		}
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }


	}	// IF RegQueryValue Ex
	else
	{
		fReturn = ( ERROR_FILE_NOT_FOUND == lReturn );
	}

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetIRQResources
//
//	Walks the device's allocated resource configuration and fills out
//	an IRQ collection with IRQ Resources for this device.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CIRQCollection&	irqList - List to populate
//
//	Return:		TRUE/FALSE				Error occured or not (empty list
//										is NOT an error).
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetIRQResources( CIRQCollection& irqList, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL				fReturn = TRUE;
	CResourceCollection	resourceList;

	// Clear the irq list first

	irqList.Empty();

	// Populate the resource list first, specifying only IRQ resources, then we will
	// need to Dup the data into the irq list.  If we go to an AddRef/Release model, we
	// will be able to copy pointers directly, saving time by not forcing us to
	// alloc and realloc data.

	if ( WalkAllocatedResources( resourceList, pResourceMap, ResType_IRQ ) )
	{
		REFPTR_POSITION	pos;

		if ( resourceList.BeginEnum( pos ) )
		{

			CResourceDescriptorPtr	pResource;

			// Check each resource, validating it is an IRQ before we cast.  Because
			// the call to Walk should have filtered for us, these should be the
			// only resources returned.

			for ( pResource.Attach(resourceList.GetNext( pos )) ;
                  pResource != NULL && fReturn ;
				  pResource.Attach(resourceList.GetNext( pos )) )
			{
				ASSERT_BREAK( pResource->GetResourceType() == ResType_IRQ );

				if ( pResource->GetResourceType() == ResType_IRQ )
				{

					// Cast the resource (we know the type) and add it to the
					// supplied list and we're done. (Ain't AddRef/Release easy?).

					CIRQDescriptor*	pIRQ = (CIRQDescriptor*) pResource.GetInterfacePtr();
					irqList.Add( pIRQ );

				}	// IF an IRQ Resource

			}	// WHILE retrieving descriptors

			resourceList.EndEnum();

		}	// BeginEnum

	}	// IF walked list

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetIOResources
//
//	Walks the device's allocated resource configuration and fills out
//	an IO collection with IO Resources for this device.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CIOCollection&	IOList - List to populate
//
//	Return:		TRUE/FALSE				Error occured or not (empty list
//										is NOT an error).
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetIOResources( CIOCollection& IOList, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL				fReturn = TRUE;
	CResourceCollection	resourceList;

	// Clear the IO list first

	IOList.Empty();

	// Populate the resource list first, specifying only IO resources, then we will
	// need to Dup the data into the IO list.  If we go to an AddRef/Release model, we
	// will be able to copy pointers directly, saving time by not forcing us to
	// alloc and realloc data.

	if ( WalkAllocatedResources( resourceList, pResourceMap, ResType_IO ) )
	{
		REFPTR_POSITION	pos;

		if ( resourceList.BeginEnum( pos ) )
		{

			CResourceDescriptorPtr pResource;

			// Check each resource, validating it is an IO before we cast.  Because
			// the call to Walk should have filtered for us, these should be the
			// only resources returned.

			for ( pResource.Attach(resourceList.GetNext( pos )) ;
                  pResource != NULL && fReturn ;
				  pResource.Attach(resourceList.GetNext( pos )) )
			{
				ASSERT_BREAK( pResource->GetResourceType() == ResType_IO );

				if ( pResource->GetResourceType() == ResType_IO )
				{
					// Cast the resource (we know the type) and add it to the
					// supplied list and we're done. (Ain't AddRef/Release easy?).

					CIODescriptor*	pIO = (CIODescriptor*) pResource.GetInterfacePtr();
					IOList.Add( pIO );

				}	// IF an IO Resource

			}	// WHILE retrieving descriptors

			resourceList.EndEnum();

		}	// BeginEnum()

	}	// IF walked list

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetDMAResources
//
//	Walks the device's allocated resource configuration and fills out
//	an DMA collection with DMA Resources for this device.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CDMACollection&	DMAList - List to populate
//
//	Return:		TRUE/FALSE				Error occured or not (empty list
//										is NOT an error).
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetDMAResources( CDMACollection& DMAList, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL				fReturn = TRUE;
	CResourceCollection	resourceList;

	// Clear the DMA list first

	DMAList.Empty();

	// Populate the resource list first, specifying only DMA resources, then we will
	// need to Dup the data into the DMA list.  If we go to an AddRef/Release model, we
	// will be able to copy pointers directly, saving time by not forcing us to
	// alloc and realloc data.

	if ( WalkAllocatedResources( resourceList, pResourceMap, ResType_DMA ) )
	{
		REFPTR_POSITION	pos;

		if ( resourceList.BeginEnum( pos ) )
		{

			CResourceDescriptorPtr pResource;

			// Check each resource, validating it is an DMA before we cast.  Because
			// the call to Walk should have filtered for us, these should be the
			// only resources returned.

			for ( pResource.Attach(resourceList.GetNext( pos )) ;
                  pResource != NULL && fReturn ;
				  pResource.Attach(resourceList.GetNext( pos )) )
			{
				ASSERT_BREAK( pResource->GetResourceType() == ResType_DMA );

				if ( pResource->GetResourceType() == ResType_DMA )
				{

					// Cast the resource (we know the type) and add it to the
					// supplied list and we're done. (Ain't AddRef/Release easy?).

					CDMADescriptor*	pDMA = (CDMADescriptor*) pResource.GetInterfacePtr();
					DMAList.Add( pDMA );

				}	// IF an DMA Resource

			}	// WHILE retrieving descriptors

			resourceList.EndEnum();

		}	// BeginEnum

	}	// IF walked list

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetDeviceMemoryResources
//
//	Walks the device's allocated resource configuration and fills out
//	an DeviceMemory collection with DeviceMemory Resources for this device.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CDeviceMemoryCollection&	DeviceMemoryList - List to populate
//
//	Return:		TRUE/FALSE				Error occured or not (empty list
//										is NOT an error).
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetDeviceMemoryResources( CDeviceMemoryCollection& DeviceMemoryList, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL				fReturn = TRUE;
	CResourceCollection	resourceList;

	// Clear the DeviceMemory list first

	DeviceMemoryList.Empty();

	// Populate the resource list first, specifying only DeviceMemory resources, then we will
	// need to Dup the data into the DeviceMemory list.  If we go to an AddRef/Release model, we
	// will be able to copy pointers directly, saving time by not forcing us to
	// alloc and realloc data.

	if ( WalkAllocatedResources( resourceList, pResourceMap, ResType_Mem ) )
	{
		REFPTR_POSITION	pos;

		if ( resourceList.BeginEnum( pos ) )
		{

			CResourceDescriptorPtr	pResource;

			// Check each resource, validating it is an DeviceMemory before we cast.  Because
			// the call to Walk should have filtered for us, these should be the
			// only resources returned.

			for ( pResource.Attach(resourceList.GetNext( pos )) ;
                  pResource != NULL && fReturn ;
				  pResource.Attach(resourceList.GetNext( pos )) )
			{
				ASSERT_BREAK( pResource->GetResourceType() == ResType_Mem );

				if ( pResource->GetResourceType() == ResType_Mem )
				{
					// Cast the resource (we know the type) and add it to the
					// supplied list and we're done. (Ain't AddRef/Release easy?).

					CDeviceMemoryDescriptor*	pDeviceMemory = (CDeviceMemoryDescriptor*) pResource.GetInterfacePtr();;
					DeviceMemoryList.Add( pDeviceMemory );

				}	// IF an DeviceMemory Resource

			}	// WHILE retrieving descriptors

			resourceList.EndEnum();

		}	// BeginEnum

	}	// IF walked list

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::WalkAllocatedResources
//
//	Walks the device's allocated resource configuration and fills out
//	a resource collection with the appropriate data.
//
//	Inputs:		RESOURCEID					resType - Types of resources
//											to return.
//				CNT4ServiceToResourceMap*	pResourceMap - For NT 4.
//
//	Outputs:	CResourceCollection&	resourceList - List to populate
//
//	Return:		TRUE/FALSE				List found or not.
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::WalkAllocatedResources( CResourceCollection& resourceList, CNT4ServiceToResourceMap *pResourceMap, RESOURCEID resType  )
{
    LOG_CONF LogConfig;
    RES_DES ResDes;
    CONFIGRET cr;
	BOOL	fReturn = FALSE ;

	// Dump the resource list first
	resourceList.Empty();

	// If we're on NT 4, we gotta march to the beat of a different
	// drummer.

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		// Convert Resource Type from RESOURCEID to CM_RESOURCE_TYPE

		fReturn = WalkAllocatedResourcesNT4( resourceList, pResourceMap, RESOURCEIDToCM_RESOURCE_TYPE( resType ) );
	}
	else
#endif
	{
		CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
		if ( pconfigmgr )
		{
			if ( pconfigmgr->IsValid () )
			{
#ifdef NTONLY
		BOOL			fIsNT5 = IsWinNT5();
#endif

				// Get the allocated Logical Configuration.  From there, we can iterate resource descriptors
				// until we find an IRQ Descriptor.

				cr = CR_NO_MORE_LOG_CONF ;

				if ( (

					pconfigmgr->CM_Get_First_Log_Conf( &LogConfig, m_dn, ALLOC_LOG_CONF ) == CR_SUCCESS ||
					pconfigmgr->CM_Get_First_Log_Conf( &LogConfig, m_dn, BOOT_LOG_CONF ) == CR_SUCCESS
				) )
				{
					cr = CR_SUCCESS ;

					RESOURCEID	resID;

					// To get the first Resource Descriptor, we pass in the logical configuration.
					// The config manager knows how to handle this (or at least that's what the
					// ahem-"documentation" sez.

					RES_DES	LastResDes = LogConfig;

					do
					{

						// Get only resources of the type we were made to retrieve
						cr = pconfigmgr->CM_Get_Next_Res_Des( &ResDes, LastResDes, resType, &resID, 0 );

						// Clean up the prior resource descriptor handle
						if ( LastResDes != LogConfig )
						{
							pconfigmgr->CM_Free_Res_Des_Handle( LastResDes );
						}

						if ( CR_SUCCESS == cr )
						{

							// CAUTION!	On NT5, if we are doing a resource Type that is NOT ResType_All,
							// the OS does not appear to fill out ResID.  I guess the assumption being
							// that we already know the resource type we are trying to get.  HOWEVER,
							// if any bits like ResType_Ignored are set, NT 5 appears to be smartly
							// dropping those resources, so we'll just set resID here as if the
							// call on NT 5 had done anything.

#ifdef NTONLY
							if	(	ResType_All	!=	resType
								&&	fIsNT5 )
							{
								resID = resType;
							}
#endif

							ULONG	ulDataSize = 0;

							if ( CR_SUCCESS == ( cr = pconfigmgr->CM_Get_Res_Des_Data_Size( &ulDataSize, ResDes, 0 ) ) )
							{
								ulDataSize += 10;	// Pad for 10 bytes of safety

								BYTE*	pbData = new BYTE[ulDataSize];

								if ( NULL != pbData )
								{
                                    try
                                    {
									    cr = pconfigmgr->CM_Get_Res_Des_Data( ResDes, pbData, ulDataSize, 0 );

									    if ( CR_SUCCESS == cr )
									    {
										    if ( !AddResourceToList( resID, pbData, ulDataSize, resourceList ) )
										    {
											    cr = CR_OUT_OF_MEMORY;
										    }
									    }
                                    }
                                    catch ( ... )
                                    {
                                        delete [] pbData;
                                        throw ;
                                    }

									// We're done with the data
									delete [] pbData;

								}	// IF NULL != pbData
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }

							}	// IF Get Data Size

							// Store the last descriptor, so we can go on to the next one.
							LastResDes = ResDes;

						}	// If we got a descriptor

					}	while ( CR_SUCCESS == cr );

					// If we blew out on this, we're okay, since the error means we ran out of
					// resource descriptors.

					if ( CR_NO_MORE_RES_DES == cr )
					{
						cr = CR_SUCCESS;
					}

					// Clean up the logical configuration handle
					pconfigmgr->CM_Free_Log_Conf_Handle( LogConfig );
				}	// IF got alloc logconf
				fReturn = ( CR_SUCCESS == cr );
			}
			CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
		}
	}	// else !NT 4
	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::AddResourceToList
//
//	Copies resource data as necessary, coercing from 16 to 32 bit as
//	necessary, then adds the resource to the supplied list.
//
//	Inputs:		RESOURCEID				resourceID - What resource is this?
//				LPVOID					pResource - The resource
//				DWORD					dwResourceLength - How long is it?
//
//	Outputs:	CResourceCollection&	resourceList - List to populate
//
//	Return:		TRUE/FALSE				Add succeeded or failed.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::AddResourceToList( RESOURCEID resourceID, LPVOID pResource, DWORD dwResourceLength, CResourceCollection& resourceList )
{
	IRQ_DES		irqDes;
	IOWBEM_DES	ioDes;
	DMA_DES		dmaDes;
	MEM_DES		memDes;

	// Don't know if Config Manager will return a resource ignored value,
	// so what we'll do here is check if the ignored bit is set, and for
	// now, ASSERT

	//ASSERT_BREAK( !(resourceID & ResType_Ignored_Bit) );

	// Filter out extraneous bits
	RESOURCEID	resType = ( resourceID & RESOURCE_TYPE_MASK );

	// Hey, I'm an optimist
	BOOL		fReturn = TRUE;

	// Different structures for 32/16 bit CFGMGR, so if
	// we ain't on WINNT, we need to coerce the data into
	// a proper structure.

#ifdef WIN9XONLY
	{
		// We have to cheat here and coerce the data from a 16-bit
		// structure into a matching 32-bit structure.

		switch ( resType )
		{
			case ResType_IRQ:
			{
				IRQDes16To32( (PIRQ_DES16) pResource, &irqDes );
			}
			break;

			case ResType_IO:
			{
				IODes16To32( (PIO_DES16) pResource, &ioDes );
			}
			break;

			case ResType_DMA:
			{
				DMADes16To32( (PDMA_DES16) pResource, &dmaDes );
			}
			break;

			case ResType_Mem:
			{
				MEMDes16To32( (PMEM_DES16) pResource, &memDes );
			}
			break;

		}	// switch ResourceID

	}	// IF !IsWinNT
#endif
#ifdef NTONLY
	{
		// Just copy the resource data into the appropriate descriptor

		switch ( resType )
		{
			case ResType_IRQ:
			{
				CopyMemory( &irqDes, pResource, sizeof(IRQ_DES) );
			}
			break;

			case ResType_IO:
			{
				// Because 16-bit has values 32-bit does not, we cheated and came up with our
				// own structure.  32-bit values are at the top, so zero out the struct and
				// trhe other values will just be ignored...yeah, that's the ticket.

				ZeroMemory( &ioDes, sizeof(ioDes) );
				CopyMemory( &ioDes, pResource, sizeof(IO_DES) );
			}
			break;

			case ResType_DMA:
			{
				CopyMemory( &dmaDes, pResource, sizeof(DMA_DES) );
			}
			break;

			case ResType_Mem:
			{
				CopyMemory( &memDes, pResource, sizeof(MEM_DES) );
			}
			break;

		}	// SWITCH ResourceId

	}	// else IsWinNT
#endif

	CResourceDescriptorPtr	pResourceDescriptor;

	// Just copy the resource data into the appropriate descriptor

    bool bAdd = true;

	switch ( resType )
	{
		case ResType_IRQ:
		{
			pResourceDescriptor.Attach( (CResourceDescriptor*) new CIRQDescriptor( resourceID, irqDes, this ) );
		}
		break;

		case ResType_IO:
		{
            bAdd = (ioDes).IOD_Alloc_End >= (ioDes).IOD_Alloc_Base;
			pResourceDescriptor.Attach ( (CResourceDescriptor*) new CIODescriptor( resourceID, ioDes, this ) );
		}
		break;

		case ResType_DMA:
		{
			pResourceDescriptor.Attach ( (CResourceDescriptor*) new CDMADescriptor( resourceID, dmaDes, this ) );
		}
		break;

		case ResType_Mem:
		{
			pResourceDescriptor.Attach ( (CResourceDescriptor*) new CDeviceMemoryDescriptor( resourceID, memDes, this ) );
		}
		break;

		default:
		{
			// We don't know what it is, but make a raw one anyway
			pResourceDescriptor.Attach ( new CResourceDescriptor( resourceID, pResource, dwResourceLength, this ) );
		}
		break;

	}	// SWITCH ResourceId

    if (bAdd)
    {
	    if ( NULL != pResourceDescriptor )
	    {
    	    fReturn = resourceList.Add( pResourceDescriptor );
	    }
	    else
	    {
		    fReturn = FALSE;
	    }
    }
    else
    {
        fReturn = TRUE;
    }

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::WalkAllocatedResourcesNT4
//
//	Because none of the logical configuration stuff in NT4 seems to
//	work worth a darn, we're gonna manhandle our own data from the
//	registry data under HKLM\HARDWARE\RESOURCEMAP.
//
//	Inputs:		CNT4ServiceToResourceMap*	pResourceMap - Resource map
//											to use for the walk.  We create
//											one if this is NULL.
//				CM_RESOURCE_TYPE			resType - Resource Types to return.
//
//	Outputs:	CResourceCollection&	resourceList - List to populate
//
//	Return:		TRUE/FALSE				List found or not.
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CConfigMgrDevice::WalkAllocatedResourcesNT4(
    CResourceCollection& resourceList,
    CNT4ServiceToResourceMap *pResourceMap,
    CM_RESOURCE_TYPE resType )
{
	BOOL						fReturn = FALSE;
	CHString					strServiceName;

	// Allocate a map if we need one.  Otherwise use the one passed in that somebody
	// theoretically has cached off somewhere.

	CNT4ServiceToResourceMap*	pLocalMap = pResourceMap;

	if ( NULL == pLocalMap )
	{
		pLocalMap = new CNT4ServiceToResourceMap;
	}

	if ( NULL != pLocalMap )
	{

        try
        {
		    // Get our service name.  If this succeeds, pull our resources from the reource map
		    if ( GetService( strServiceName ) )
		    {
			    fReturn = GetServiceResourcesNT4( strServiceName, *pLocalMap, resourceList, resType );
		    }
        }
        catch ( ... )
        {
		    if ( pLocalMap != pResourceMap )
		    {
			    delete pLocalMap;
		    }
            throw ;
        }

		// Clean up the local map if we allocated one
		if ( pLocalMap != pResourceMap )
		{
			delete pLocalMap;
		}
	}
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }


	return fReturn;
}
#endif

#ifdef NTONLY
BOOL CConfigMgrDevice::GetServiceResourcesNT4( LPCTSTR pszServiceName, CNT4ServiceToResourceMap& resourceMap, CResourceCollection& resourceList, CM_RESOURCE_TYPE cmrtFilter/*=CmResourceTypeNull*/ )
{
	BOOL						fReturn = TRUE;
	LPRESOURCE_DESCRIPTOR		pResourceDescriptor;

	// Iterate the resources, looking for matches against values we may be filtering
	// for.

	DWORD	dwNumResources = resourceMap.NumServiceResources( pszServiceName );

	for	(	DWORD	dwCtr	=	0;
					dwCtr	<	dwNumResources
			&&		fReturn;
					dwCtr++ )
	{
		pResourceDescriptor = resourceMap.GetServiceResource( pszServiceName, dwCtr );

		// Grab the resource if it's our filter, or our filter is NULL, meaning grab everything
		if	(	NULL	!=	pResourceDescriptor
			&&	(	CmResourceTypeNull	==	cmrtFilter
				||	cmrtFilter			==	pResourceDescriptor->CmResourceDescriptor.Type
				)
			)
		{
			CResourceDescriptorPtr pResource;

			// Perform appropriate type coercsions, and hook the resource into the resource
			/// list.
			switch ( pResourceDescriptor->CmResourceDescriptor.Type )
			{
				case CmResourceTypeInterrupt:
				{
					IRQ_DES		irqDes;
					NT4IRQToIRQ_DES( pResourceDescriptor, &irqDes );
					pResource.Attach(new CIRQDescriptor( ResType_IRQ, irqDes, this ) );
				}
				break;

				case CmResourceTypePort:
				{
					IOWBEM_DES		ioDes;
					NT4IOToIOWBEM_DES( pResourceDescriptor, &ioDes );
					pResource.Attach(new CIODescriptor( ResType_IO, ioDes, this ) );
				}
				break;

				case CmResourceTypeMemory:
				{
					MEM_DES		memDes;
					NT4MEMToMEM_DES( pResourceDescriptor, &memDes );
					pResource.Attach(new CDeviceMemoryDescriptor( ResType_Mem, memDes, this ));
				}
				break;

				case CmResourceTypeDma:
				{
					DMA_DES		dmaDes;
					NT4DMAToDMA_DES( pResourceDescriptor, &dmaDes );
					pResource.Attach(new CDMADescriptor( ResType_DMA, dmaDes, this ));
				}
				break;

				// If it ain't one of these four, there ain't a whole heck of a
				// lot we're gonna do here
			}


			if ( NULL != pResource )
			{
    			fReturn = resourceList.Add( pResource );
			}
			else
			{
				// We beefed on a simple memory allocation.  Get out of here.
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
			}

		}	// IF resource was one we wanted to handle

	}	// FOR enum resources

	return fReturn;
}
#endif

#ifdef NTONLY
CM_RESOURCE_TYPE CConfigMgrDevice::RESOURCEIDToCM_RESOURCE_TYPE( RESOURCEID resType )
{
	CM_RESOURCE_TYPE	cmResType = CmResourceTypeNull;
	switch ( resType )
	{
		case ResType_All:		cmResType	=	CmResourceTypeNull;			break;
		case ResType_IO:		cmResType	=	CmResourceTypePort;			break;
		case ResType_IRQ:		cmResType	=	CmResourceTypeInterrupt;	break;
		case ResType_DMA:		cmResType	=	CmResourceTypeDma;			break;
		case ResType_Mem:		cmResType	=	CmResourceTypeMemory;		break;
		default:				cmResType	=	CmResourceTypeNull;			break;
	}

	return cmResType;
}
#endif

#ifdef NTONLY
void CConfigMgrDevice::NT4IRQToIRQ_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PIRQ_DES pirqDes32 )
{
	ZeroMemory( pirqDes32, sizeof(IRQ_DES) );

	// 32-bit structure
	//typedef struct IRQ_Des_s {
	//   DWORD IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
	//   DWORD IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
	//   DWORD IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
	//   ULONG IRQD_Alloc_Num;   // specifies the IRQ that was allocated
	//   ULONG IRQD_Affinity;
	//} IRQ_DES, *PIRQ_DES;

	pirqDes32->IRQD_Alloc_Num = pResourceDescriptor->CmResourceDescriptor.u.Interrupt.Level;
	pirqDes32->IRQD_Affinity = pResourceDescriptor->CmResourceDescriptor.u.Interrupt.Affinity;

	// We'll do our best on the flags conversion.

	if ( CmResourceShareShared == pResourceDescriptor->CmResourceDescriptor.ShareDisposition )
	{
		pirqDes32->IRQD_Flags |= fIRQD_Share;
	}

	// Latched -> Edge?  Have no idea, the other value in either case was Level,
	// so here's a leap of faith.

	if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_INTERRUPT_LATCHED )
	{
		pirqDes32->IRQD_Flags |= fIRQD_Edge;
	}

}
#endif

#ifdef NTONLY
void CConfigMgrDevice::NT4IOToIOWBEM_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PIOWBEM_DES pioDes32 )
{
	ZeroMemory( pioDes32, sizeof(IOWBEM_DES) );

	// 32-bit structure
	//typedef struct _IOWBEM_DES{
	//	DWORD		IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
	//	DWORD		IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
	//	DWORDLONG	IOD_Alloc_Base;     // base of allocated port range
	//	DWORDLONG	IOD_Alloc_End;      // end of allocated port range
	//	DWORD		IOD_DesFlags;       // flags relating to allocated port range
	//	BYTE		IOD_Alloc_Alias;	// From 16-bit-land
	//	BYTE		IOD_Alloc_Decode;	// From 16-bit-land
	//} IOWBEM_DES;

    LARGE_INTEGER liTemp;  // Used to avoid 64bit alignment problems

    liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.HighPart;
    liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Port.Start.LowPart;

	pioDes32->IOD_Alloc_Base = liTemp.QuadPart;
	pioDes32->IOD_Alloc_End = pioDes32->IOD_Alloc_Base + ( pResourceDescriptor->CmResourceDescriptor.u.Port.Length - 1);

	// Don't know what to do with Share disposition here, since CFGMGR32 doesn't seem to
	// do it for IO Ports.
	//if ( CmResourceShareShared == pResourceDescriptor->CmResourceDescriptor.ShareDisposition )
	//{
	//	pioDes32->IOD_Flags |= fIRQD_Share;
	//}

	//
	// Port Type flags convert straight across
	//

	//#define fIOD_PortType   (0x1) // Bitmask,whether port is IO or memory
	//#define fIOD_Memory     (0x0) // Port resource really uses memory
	//#define fIOD_IO         (0x1) // Port resource uses IO ports

	//#define CM_RESOURCE_PORT_MEMORY 0
	//#define CM_RESOURCE_PORT_IO 1

	pioDes32->IOD_DesFlags = pResourceDescriptor->CmResourceDescriptor.Flags;

}
#endif

#ifdef NTONLY
void CConfigMgrDevice::NT4MEMToMEM_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PMEM_DES pmemDes32 )
{
	ZeroMemory( pmemDes32, sizeof(MEM_DES) );

	// 32-bit structure
	//typedef struct Mem_Des_s {
	//   DWORD     MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
	//   DWORD     MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
	//   DWORDLONG MD_Alloc_Base;   // base memory address of range allocated
	//   DWORDLONG MD_Alloc_End;    // end of allocated range
	//   DWORD     MD_Flags;        // flags describing allocated range (fMD flags)
	//   DWORD     MD_Reserved;
	//} MEM_DES, *PMEM_DES;

    LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

    liTemp.HighPart = pResourceDescriptor->CmResourceDescriptor.u.Memory.Start.HighPart;
    liTemp.LowPart = pResourceDescriptor->CmResourceDescriptor.u.Memory.Start.LowPart;

	pmemDes32->MD_Alloc_Base = liTemp.QuadPart;
	pmemDes32->MD_Alloc_End = pmemDes32->MD_Alloc_Base + ( pResourceDescriptor->CmResourceDescriptor.u.Memory.Length - 1);

	// Don't know what to do with Share disposition here, since CFGMGR32 doesn't seem to
	// do it for IO Ports.
	//if ( CmResourceShareShared == pResourceDescriptor->CmResourceDescriptor.ShareDisposition )
	//{
	//	pioDes32->MD_Flags |= fIRQD_Share;
	//}

	// Flag conversions I can do
	if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_MEMORY_READ_WRITE )
	{
		pmemDes32->MD_Flags |= fMD_RAM;
		pmemDes32->MD_Flags |= fMD_ReadAllowed;
	}
	else if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_MEMORY_READ_ONLY )
	{
		pmemDes32->MD_Flags |= fMD_ROM;
		pmemDes32->MD_Flags |= fMD_ReadAllowed;
	}
	else if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_MEMORY_WRITE_ONLY )
	{
		pmemDes32->MD_Flags |= fMD_RAM;
		pmemDes32->MD_Flags |= fMD_ReadDisallowed;
	}

	if ( pResourceDescriptor->CmResourceDescriptor.Flags & CM_RESOURCE_MEMORY_PREFETCHABLE )
	{
		pmemDes32->MD_Flags |= fMD_PrefetchAllowed;
	}

	// Don't know what to do with these flags:

	//#define mMD_32_24                   (0x2) // Bitmask, memory is 24 or 32-bit
	//#define fMD_32_24                   mMD_32_24 // compatibility
	//#define fMD_24                      (0x0) // Memory range is 24-bit
	//#define fMD_32                      (0x2) // Memory range is 32-bit

	//#define mMD_CombinedWrite           (0x10) // Bitmask,supports write-behind
	//#define fMD_CombinedWrite           mMD_CombinedWrite // compatibility
	//#define fMD_CombinedWriteDisallowed (0x0)  // no combined-write caching
	//#define fMD_CombinedWriteAllowed    (0x10) // supports combined-write caching

	//#define mMD_Cacheable               (0x20) // Bitmask,whether memory is cacheable
	//#define fMD_NonCacheable            (0x0)  // Memory range is non-cacheable
	//#define fMD_Cacheable               (0x20) // Memory range is cacheable

}
#endif

#ifdef NTONLY
void CConfigMgrDevice::NT4DMAToDMA_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PDMA_DES pdmaDes32 )
{
	ZeroMemory( pdmaDes32, sizeof(DMA_DES) );

	// 32-bit structure
	//typedef struct DMA_Des_s {
	//   DWORD  DD_Count;       // number of DMA_RANGE structs in DMA_RESOURCE
	//   DWORD  DD_Type;        // size (in bytes) of DMA_RANGE struct (DType_Range)
	//   DWORD  DD_Flags;       // Flags describing DMA channel (fDD flags)
	//   ULONG  DD_Alloc_Chan;  // Specifies the DMA channel that was allocated
	//} DMA_DES, *PDMA_DES;

	pdmaDes32->DD_Alloc_Chan = pResourceDescriptor->CmResourceDescriptor.u.Dma.Channel;

	// Don't know what to do with Share disposition here, since CFGMGR32 doesn't seem to
	// do it for IO Ports.
	//if ( CmResourceShareShared == pResourceDescriptor->CmResourceDescriptor.ShareDisposition )
	//{
	//	pioDes32->MD_Flags |= fIRQD_Share;
	//}

	// These are possible flags for DMA, but I don't see any values from the
	// CHWRES.H file which make a sensible conversion to these values.

	//
	// Define the attribute flags for a DMA resource range.  Each bit flag is
	// identified with a constant bitmask.  Following the bitmask definition
	// are the possible values.
	//
	//#define mDD_Width         (0x3)    // Bitmask, width of the DMA channel:
	//#define fDD_BYTE          (0x0)    //   8-bit DMA channel
	//#define fDD_WORD          (0x1)    //   16-bit DMA channel
	//#define fDD_DWORD         (0x2)    //   32-bit DMA channel
	//#define fDD_BYTE_AND_WORD (0x3)    //   8-bit and 16-bit DMA channel

	//#define mDD_BusMaster     (0x4)    // Bitmask, whether bus mastering is supported
	//#define fDD_NoBusMaster   (0x0)    //   no bus mastering
	//#define fDD_BusMaster     (0x4)    //   bus mastering

	//#define mDD_Type         (0x18)    // Bitmask, specifies type of DMA
	//#define fDD_TypeStandard (0x00)    //   standard DMA
	//#define fDD_TypeA        (0x08)    //   Type-A DMA
	//#define fDD_TypeB        (0x10)    //   Type-B DMA
	//#define fDD_TypeF        (0x18)    //   Type-F DMA

}
#endif

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::IRQDes16To32
//
//	Coerces data from a 16-bit structure into a 32-bit structure.
//
//	Inputs:		PIRQ_DES16				pirqDes16 - 16-bit structure
//
//	Outputs:	PIRQ_DES				pirqDes32 - 32-bit structure
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::IRQDes16To32( PIRQ_DES16 pirqDes16, PIRQ_DES pirqDes32 )
{
	ZeroMemory( pirqDes32, sizeof(IRQ_DES) );

	// 16-bit Structure
	//struct	IRQ_Des_s {
	//	WORD			IRQD_Flags;
	//	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	//	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	//	WORD			IRQD_Reserved;
	//};

	// 32-bit structure
	//typedef struct IRQ_Des_s {
	//   DWORD IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
	//   DWORD IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
	//   DWORD IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
	//   ULONG IRQD_Alloc_Num;   // specifies the IRQ that was allocated
	//   ULONG IRQD_Affinity;
	//} IRQ_DES, *PIRQ_DES;

	pirqDes32->IRQD_Alloc_Num	=	pirqDes16->IRQD_Alloc_Num;
	pirqDes32->IRQD_Flags		=	pirqDes16->IRQD_Flags;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::IODes16To32
//
//	Coerces data from a 16-bit structure into a 32-bit structure.
//
//	Inputs:		PIO_DES16				pioDes16 - 16-bit structure
//
//	Outputs:	PIOWBEM_DES				pioDes32 - 32-bit structure
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::IODes16To32( PIO_DES16 pioDes16, PIOWBEM_DES pioDes32 )
{
	ZeroMemory( pioDes32, sizeof(IOWBEM_DES) );

	// 16-bit structure
	//struct	IO_Des_s {
	//	WORD			IOD_Count;
	//	WORD			IOD_Type;
	//	WORD			IOD_Alloc_Base;
	//	WORD			IOD_Alloc_End;
	//	WORD			IOD_DesFlags;
	//	BYTE			IOD_Alloc_Alias;
	//	BYTE			IOD_Alloc_Decode;
	//};

	// 32-bit Structure
	//typedef struct _IOWBEM_DES{
	//	DWORD		IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
	//	DWORD		IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
	//	DWORDLONG	IOD_Alloc_Base;     // base of allocated port range
	//	DWORDLONG	IOD_Alloc_End;      // end of allocated port range
	//	DWORD		IOD_DesFlags;       // flags relating to allocated port range
	//	BYTE		IOD_Alloc_Alias;	// From 16-bit-land
	//	BYTE		IOD_Alloc_Decode;	// From 16-bit-land
	//} IOWBEM_DES;

	pioDes32->IOD_Count			=	pioDes16->IOD_Count;
	pioDes32->IOD_Type			=	pioDes16->IOD_Type;
	pioDes32->IOD_Alloc_Base	=	pioDes16->IOD_Alloc_Base;
	pioDes32->IOD_Alloc_End		=	pioDes16->IOD_Alloc_End;
	pioDes32->IOD_DesFlags		=	pioDes16->IOD_DesFlags;
	pioDes32->IOD_Alloc_Alias	=	pioDes16->IOD_Alloc_Alias;
	pioDes32->IOD_Alloc_Decode	=	pioDes16->IOD_Alloc_Decode;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::DMADes16To32
//
//	Coerces data from a 16-bit structure into a 32-bit structure.
//
//	Inputs:		PDMA_DES16				pdmaDes16 - 16-bit structure
//
//	Outputs:	PDMA_DES				pdmaDes32 - 32-bit structure
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::DMADes16To32( PDMA_DES16 pdmaDes16, PDMA_DES pdmaDes32 )
{
	ZeroMemory( pdmaDes32, sizeof(DMA_DES) );

	// 16-bit structure
	//struct	DMA_Des_s {
	//	BYTE			DD_Flags;
	//	BYTE			DD_Alloc_Chan;	// Channel number allocated
	//	BYTE			DD_Req_Mask;	// Mask of possible channels
	//	BYTE			DD_Reserved;
	//};

	// 32-bit structure
	//typedef struct DMA_Des_s {
	//   DWORD  DD_Count;       // number of DMA_RANGE structs in DMA_RESOURCE
	//   DWORD  DD_Type;        // size (in bytes) of DMA_RANGE struct (DType_Range)
	//   DWORD  DD_Flags;       // Flags describing DMA channel (fDD flags)
	//   ULONG  DD_Alloc_Chan;  // Specifies the DMA channel that was allocated
	//} DMA_DES, *PDMA_DES;

	pdmaDes32->DD_Flags			=	pdmaDes16->DD_Flags;
	pdmaDes32->DD_Alloc_Chan	=	pdmaDes16->DD_Alloc_Chan;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::MEMDes16To32
//
//	Coerces data from a 16-bit structure into a 32-bit structure.
//
//	Inputs:		PMEM_DES16				pmemDes16 - 16-bit structure
//
//	Outputs:	PMEM_DES				pmemDes32 - 32-bit structure
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::MEMDes16To32( PMEM_DES16 pmemDes16, PMEM_DES pmemDes32 )
{
	ZeroMemory( pmemDes32, sizeof(MEM_DES) );

	// 16-bit Structure
	//struct	Mem_Des_s {
	//	WORD			MD_Count;
	//	WORD			MD_Type;
	//	ULONG			MD_Alloc_Base;
	//	ULONG			MD_Alloc_End;
	//	WORD			MD_Flags;
	//	WORD			MD_Reserved;
	//};

	// 32-bit Structure
	//typedef struct Mem_Des_s {
	//   DWORD     MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
	//   DWORD     MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
	//   DWORDLONG MD_Alloc_Base;   // base memory address of range allocated
	//   DWORDLONG MD_Alloc_End;    // end of allocated range
	//   DWORD     MD_Flags;        // flags describing allocated range (fMD flags)
	//   DWORD     MD_Reserved;
	//} MEM_DES, *PMEM_DES;

	pmemDes32->MD_Count			=	pmemDes16->MD_Count;
	pmemDes32->MD_Type			=	pmemDes16->MD_Type;
	pmemDes32->MD_Alloc_Base	=	pmemDes16->MD_Alloc_Base;
	pmemDes32->MD_Alloc_End		=	pmemDes16->MD_Alloc_End;
	pmemDes32->MD_Flags			=	pmemDes16->MD_Flags;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::TraverseAllocationData
//
//	Traverses a block of data in order to determine
//	resource allocations for a particular device.
//
//	Inputs:		None.
//
//	Outputs:	CResourceCollection&	resourceList - List to populate
//
//	Return:		None.
//
//	Comments:	Requires READ Access to the data.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::TraverseAllocationData( CResourceCollection& resourceList )
{
	const BYTE *	pbTraverseData		=	m_pbAllocationData;
	DWORD			dwSizeRemainingData =	m_dwSizeAllocationData,
					dwResourceType		=	ResType_None,
					dwResourceSize		=	0;

	// Clear the resource list first
	resourceList.Empty();

	// OWCH!  The first hack.  Near as I can tell, we need to jump eight bytes in to get
	// to the first resource descriptor header (if there is one).

	TraverseData( pbTraverseData, dwSizeRemainingData, FIRST_RESOURCE_OFFSET );

	// From here on, we only want to deal with known resource information.  Use the
	// clever GetNextResource function to do all of our dirty work for us.  If it
	// returns TRUE, then it's located a resource.  Allocate the proper type of
	// descriptor based on type, place it in the list and go on to the next resource.

	while ( GetNextResource( pbTraverseData, dwSizeRemainingData, dwResourceType, dwResourceSize ) )
	{
        if( dwResourceType == m_dwTypeToGet ){

		    PPOORMAN_RESDESC_HDR	pResDescHdr	=	(PPOORMAN_RESDESC_HDR) pbTraverseData;
		    CResourceDescriptorPtr pResDesc;

		    // We have a valid type, however the actual resource descriptor will
		    // lie SIZEOF_RESDESC_HDR bytes past where we're at now (pointing at
		    // a resource header).

		    switch ( dwResourceType ){
			    case ResType_Mem:
			    {
				    CDeviceMemoryDescriptor*	pMemDesc = new CDeviceMemoryDescriptor( pResDescHdr, this );
				    pResDesc.Attach(pMemDesc);
				    break;
			    }

			    case ResType_IO:
			    {
				    CIODescriptor*	pIODesc = new CIODescriptor( pResDescHdr, this );
				    pResDesc.Attach(pIODesc);
				    break;
			    }

			    case ResType_DMA:
			    {
				    CDMADescriptor*	pDMADesc = new CDMADescriptor( pResDescHdr, this );
				    pResDesc.Attach(pDMADesc);
				    break;
			    }

			    case ResType_IRQ:
			    {
				    CIRQDescriptor*	pIRQDesc = new CIRQDescriptor( pResDescHdr, this );
				    pResDesc.Attach(pIRQDesc);
				    break;
			    }

			    default:
			    {
				    pResDesc.Attach (new CResourceDescriptor( pResDescHdr, this ));
			    }

    		}	// SWITCH

    		// Give up if we have any failures, since they are most likely memory
		    // related, and something really bad has happened.

		    if ( NULL != pResDesc )
            {
                if ( !resourceList.Add( pResDesc ) )
                {
				    break;
			    }
		    }
		    else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		    }
        }
		// Move the pointer to the next resource descriptor header.
		TraverseData( pbTraverseData, dwSizeRemainingData, dwResourceSize );

	}	// WHILE finding new resources

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::FindNextResource
//
//	Iterates through a block of data, hunting for byte patterns that
//	identify a resource type.  In this case, as long as there are
//	SIZEOF_RESDESC_HDR bytes let to work with, we extract the resource
//	type and size and return those values for interpretation.
//
//	Inputs:		const BYTE*		pbTraverseData	- Data we are traversing.  The
//								value will change as we progress through the
//								data.
//				DWORD			dwSizeRemainingData - How much data remains to
//								be traversed.
//
//	Outputs:	DWORD&			dwResourceType - What type of resource have we
//								found.
//				DWORD&			dwResourceSize - How big the block of data
//								describing the resource is.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CConfigMgrDevice::GetNextResource( const BYTE  *pbTraverseData, DWORD dwSizeRemainingData, DWORD& dwResourceType, DWORD& dwResourceSize )
{
	BOOL	fReturn = FALSE;

	// If we have less than SIZEOF_RESDESC_HDR bytes to work with,
	// give up, we ain't goin' nowhere.

	if ( dwSizeRemainingData > SIZEOF_RESDESC_HDR )
	{
		PPOORMAN_RESDESC_HDR	pResDescHdr = (PPOORMAN_RESDESC_HDR) pbTraverseData;
		DWORD					dwResourceId = 0;

		dwResourceSize = pResDescHdr->dwResourceSize;

		// If we run into a zero byte header, the only value will be length, which
		// makes no sense, so we should probably just give up.

		if ( 0 != dwResourceSize )
		{
			// See if it's one of the four standard types.  If so, be aware that this code
			// ain't checking to see if it's ignored, and that an OEM can create a replacement
			// for one of these standard types, in which case strange and wondrous things
			// may happen.

			// Strip out any unwanted data, the first 5 bits are reserved for resource type
			// identification, so mask out everything else

			dwResourceType = pResDescHdr->dwResourceId;
			dwResourceType &= RESOURCE_TYPE_MASK;

			// We got a live one!
			fReturn = TRUE;

		}
	}

	// Return whether or not we found a resource

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::GetStatus
//
//	Returns the status of the device as a string.  If OK, it is "OK", if
//	we have a problem, it is "Error".
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - String to place status in.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::GetProblem( CHString& str )
{
	// Save the string
	str = ( 0 == m_dwProblem ? IDS_CfgMgrDeviceStatus_OK : IDS_CfgMgrDeviceStatus_ERR );
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	CConfigMgrDevice::TraverseData
//
//	Helper function to safely bounce a pointer around our data.  It will
//	jump the pointer by the specified amount, or the amount remaining,
//	whichever is smaller.
//
//	Inputs:		DWORD			dwSizeTraverse - Size of upcoming jump.
//
//	Outputs:	const BYTE*&	pbTraverseData	- Data we are traversing.  The
//								value will change as we progress through the
//								data.
//				DWORD&			dwSizeRemainingData - How much data remains to
//								be traversed.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

void CConfigMgrDevice::TraverseData( const BYTE *& pbTraverseData, DWORD& dwSizeRemainingData, DWORD dwSizeTraverse )
{
	// Increment the pointer and reduce the size of remaining data, do this safely, not
	// traversing beyond the end of the remaining data, if that is all that is left.

	pbTraverseData += min( dwSizeRemainingData, dwSizeTraverse );
	dwSizeRemainingData -= min( dwSizeRemainingData, dwSizeTraverse );
}

// New functions that converse directly with the Config Manager APIs

BOOL CConfigMgrDevice::GetDeviceID( CHString& strID )
{
	BOOL bRet = FALSE ;
	CONFIGRET	cr = CR_SUCCESS;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{
			char		szDeviceId[MAX_DEVICE_ID_LEN+1];

			ULONG		ulBuffSize = 0;

			cr = pconfigmgr->CM_Get_Device_IDA( m_dn, szDeviceId, sizeof(szDeviceId), 0  );

			if ( CR_SUCCESS == cr )
			{
				strID = szDeviceId;
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetStatus( LPDWORD pdwStatus, LPDWORD pdwProblem )
{
	BOOL bRet = FALSE ;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			DWORD		dwStatus,
						dwProblem;

			CONFIGRET	cr = pconfigmgr->CM_Get_DevNode_Status( &dwStatus, &dwProblem, m_dn, 0 );

			// Perform pointer testing here.  Ignore the man behind the curtain...
			if ( CR_SUCCESS == cr )
			{
				if ( NULL != pdwStatus )
				{
					*pdwStatus = dwStatus;
				}

				if ( NULL != pdwProblem )
				{
					*pdwProblem = dwProblem;
				}
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::IsUsingForcedConfig()
{
	BOOL bRet = FALSE ;
	LOG_CONF			conf;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			bRet = (pconfigmgr->CM_Get_First_Log_Conf(&conf, m_dn, FORCED_LOG_CONF) ==
					CR_SUCCESS);
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetParent( CConfigMgrDevice **ppParentDevice )
{
	BOOL bRet = FALSE ;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	DEVNODE			dn;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			CONFIGRET	cr = pconfigmgr->CM_Get_Parent( &dn, m_dn, 0 );

			if ( CR_SUCCESS == cr )
			{
				CConfigMgrDevice*	pDevice	=	new CConfigMgrDevice( dn );

				if ( NULL != pDevice )
				{
					*ppParentDevice = pDevice;
				}
				else
				{
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetChild( CConfigMgrDevice **ppChildDevice )
{
	BOOL bRet = FALSE ;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	DEVNODE			dn;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			CONFIGRET	cr = pconfigmgr->CM_Get_Child( &dn, m_dn, 0 );

			if ( CR_SUCCESS == cr )
			{
				CConfigMgrDevice*	pDevice	=	new CConfigMgrDevice( dn );

				if ( NULL != pDevice )
				{
					*ppChildDevice = pDevice;
				}
				else
				{
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetSibling( CConfigMgrDevice **ppSiblingDevice )
{
	BOOL bRet = FALSE ;
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	DEVNODE			dn;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			CONFIGRET	cr = pconfigmgr->CM_Get_Sibling( &dn, m_dn, 0 );

			if ( CR_SUCCESS == cr )
			{
				CConfigMgrDevice*	pDevice	=	new CConfigMgrDevice( dn );

				if ( NULL != pDevice )
				{
					*ppSiblingDevice = pDevice;
				}
				else
				{
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetStringProperty( ULONG ulProperty, CHString& strValue )
{
    TCHAR Buffer[REGSTR_VAL_MAX_HCID_LEN+1];
    ULONG Type;
    ULONG Size = sizeof(Buffer);
	BOOL bRet = FALSE ;
	CONFIGRET	cr = CR_SUCCESS;

	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{

			if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																						ulProperty,
																						&Type,
																						Buffer,
																						&Size,
																						0 ) ) )
			{
				if ( REG_SZ == Type )
				{
					strValue = Buffer;
				}
				else
				{
					cr = CR_WRONG_TYPE;
				}
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetDWORDProperty( ULONG ulProperty, DWORD *pdwVal )
{
	DWORD	dwVal = 0;
    ULONG Type;
    ULONG Size = sizeof(DWORD);
	BOOL bRet = FALSE ;
	CONFIGRET	cr = CR_SUCCESS;

	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{
			if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																						ulProperty,
																						&Type,
																						&dwVal,
																						&Size,
																						0 ) ) )
			{
#ifdef NTONLY
				{
					if ( REG_DWORD == Type )
					{
						*pdwVal = dwVal;
					}
					else
					{
						cr = CR_WRONG_TYPE;
					}

				}
#endif
#ifdef WIN9XONLY
				{
					if ( REG_BINARY == Type )	// Apparently Win16 doesn't do REG_DWORD
					{
						*pdwVal = dwVal;
					}
					else
					{
						cr = CR_WRONG_TYPE;
					}
				}
#endif
			}
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
	return bRet ;
}

BOOL CConfigMgrDevice::GetMULTISZProperty( ULONG ulProperty, CHStringArray& strArray )
{
	CONFIGRET	cr = CR_SUCCESS;
	BOOL bRet = FALSE ;
// No one is currently using this, so I'm not going to fix it now
#ifdef DOESNT_WORK_FOR_UNICODE
	LPSTR	pszStrings = NULL;
    ULONG	Type;
    ULONG	Size = 0;


	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{
			if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																						ulProperty,
																						&Type,
																						pszStrings,
																						&Size,
																						0 ) )
				||	CR_BUFFER_SMALL	==	cr )

			{
				// SZ or MULTI_SZ is Okay (32-bit has MULTI_SZ values that are SZ in 16-bit)
				if ( REG_SZ == Type || REG_MULTI_SZ == Type )
				{
					// Pad the string, but be aware that on NT4 I have seen situations in which
					// it reports less data than it actually returns (scary)

					Size += 32;
					pszStrings = new char[Size];

					if ( NULL != pszStrings )
					{
                        try
                        {
					        // Clear out the memory to be especially safe.
					        ZeroMemory( pszStrings, Size );

						    if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																									    ulProperty,
																									    &Type,
																									    pszStrings,
																									    &Size,
																									    0 ) ) )
						    {
							    // For REG_SZ, add a single entry to the array
							    if ( REG_SZ == Type )
							    {
								    strArray.Add( pszStrings );
							    }
							    else if ( REG_MULTI_SZ == Type )
							    {
								    // Add strings to the array, watching out for the double NULL
								    // terminator for the array

								    LPSTR	pszTemp = pszStrings;

								    do
								    {
									    strArray.Add( pszTemp );
									    pszTemp += ( lstrlen( pszTemp ) + 1 );
								    } while ( NULL != *pszTemp );
							    }
							    else
							    {
								    cr = CR_WRONG_TYPE;
							    }

						    }	// If Got value
                        }
                        catch ( ... )
                        {
                            delete [] pszStrings;
                            throw ;
                        }

						delete [] pszStrings;

					}	// IF alloc pszStrings
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
				}	// IF REG_SZ or REG_MULTI_SZ
				else
				{
					cr = CR_WRONG_TYPE;
				}

			}	// IF got size of entry
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}
#endif

	return bRet ;
}

BOOL CConfigMgrDevice::GetBusInfo( INTERFACE_TYPE *pitBusType, LPDWORD pdwBusNumber, CNT4ServiceToResourceMap *pResourceMap/*=NULL*/  )
{
	CMBUSTYPE		busType = 0;
	ULONG			ulSizeOfInfo = 0;
	PBYTE			pbData = NULL;
	BOOL			fReturn = FALSE;

	// Farm out to the appropriate handler
#if NTONLY > 4
	fReturn = GetBusInfoNT5( pitBusType, pdwBusNumber );
#endif
#if NTONLY == 4
	fReturn = GetBusInfoNT4( pitBusType, pdwBusNumber, pResourceMap );
#endif
#ifdef WIN9XONLY
	{
		// Buffer for data.  Should be big enough for any of the values we come across.
		BYTE		abData[255];

		ulSizeOfInfo = sizeof(abData);

		// Get the type and number.  If the type is PCI, then get the PCI info, and this
		// will return a Bus Number value.  If it returns a type other than PCI, then
		// we will assume a bus number of 0.
		CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
		if ( pconfigmgr )
		{
			if ( pconfigmgr->IsValid () )
			{
				CONFIGRET	cr = pconfigmgr->CM_Get_Bus_Info( m_dn, &busType, &ulSizeOfInfo, abData, 0 );

				if ( CR_SUCCESS == cr )
				{
					// Make sure we can convert from a 16-bit type to a known 32-bit type.
					// BusType_None will usually fail this, in which case we can call it
					// quits.

					if ( BusType16ToInterfaceType( busType, pitBusType ) )
					{

						if ( BusType_PCI == busType )
						{
							sPCIAccess *pPCIInfo = (sPCIAccess*) abData;
							*pdwBusNumber = pPCIInfo->bBusNumber;
						}
						else
						{
							*pdwBusNumber = 0;
						}

					}	// IF 16-32bit conversion
					else
					{
						cr = CR_FAILURE;
					}

				}	// CR_SUCCESS == cr

				fReturn = ( CR_SUCCESS == cr );
			}
			CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
		}
	}	// else !IsWinNT
#endif
	return fReturn;
}

#if NTONLY > 4
// This is to hack around W2K problem where Cfg Mgr devices report they're
// using Isa on boxes that have Eisa and not Isa.
BOOL CConfigMgrDevice::IsIsaReallyEisa()
{
    static bRet = -1;

    if (bRet == -1)
    {
        // FYI: This code based on code from motherboard.cpp.

        CRegistry   regAdapters;
	    CHString    strPrimarySubKey;
	    HRESULT     hRc = WBEM_E_FAILED;
	    DWORD       dwPrimaryRc;

        // If anything below fails, we'll just assume Isa really is Isa.
        bRet = FALSE;

        //****************************************
        //  Open the registry
        //****************************************
        if (regAdapters.OpenAndEnumerateSubKeys(
            HKEY_LOCAL_MACHINE,
            L"HARDWARE\\Description\\System",
            KEY_READ) == ERROR_SUCCESS)
        {
    	    BOOL    bDone = FALSE,
                    bIsaFound = FALSE,
                    bEisaFound = FALSE;

            // Our goal is to find any subkey that has the string "Adapter" in
            // it and then read the "Identifier" value.
            for ( ;
                (!bIsaFound || !bEisaFound) &&
                ((dwPrimaryRc = regAdapters.GetCurrentSubKeyName(strPrimarySubKey))
                    == ERROR_SUCCESS);
                regAdapters.NextSubKey())
            {
                strPrimarySubKey.MakeUpper();

                // If this is one of the keys we want since it has "Adapter" in
                // it then get the "Identifier" value.
		        if (wcsstr(strPrimarySubKey, L"ADAPTER"))
                {
                    WCHAR		szKey[_MAX_PATH];
			        CRegistry	reg;

                    swprintf(
				        szKey,
				        L"%s\\%s",
                        L"HARDWARE\\Description\\System",
				        (LPCWSTR) strPrimarySubKey);

                    if (reg.OpenAndEnumerateSubKeys(
                        HKEY_LOCAL_MACHINE,
                        szKey,
                        KEY_READ) == ERROR_SUCCESS)
                    {
				        CHString strSubKey;

        	            // Enumerate the  system components (like 0,1,...).
                        for ( ;
                            reg.GetCurrentSubKeyName(strSubKey) == ERROR_SUCCESS;
                            reg.NextSubKey())
                        {
                            CHString strBus;

                            if (reg.GetCurrentSubKeyValue(L"Identifier",
                                strBus) == ERROR_SUCCESS)
                            {
				                if (strBus == L"ISA")
                                    bIsaFound = TRUE;
                                else if (strBus == L"EISA")
                                    bEisaFound = TRUE;
                            }
                        }
                    }
                }
            }

            // If we found Eisa but not Isa, assume Cfg Mgr devices that report they're
            // using Isa are actually using Eisa.
            if (!bIsaFound && bEisaFound)
                bRet = TRUE;
	    }
    }

    return bRet;
}
#endif

#if NTONLY > 4
INTERFACE_TYPE CConfigMgrDevice::ConvertBadIsaBusType(INTERFACE_TYPE type)
{
    if (type == Isa && IsIsaReallyEisa())
        type = Eisa;

    return type;
}
#endif

#if NTONLY > 4
BOOL CConfigMgrDevice::GetBusInfoNT5( INTERFACE_TYPE *pitBusType, LPDWORD pdwBusNumber )
{
	ULONG			ulSizeOfInfo = 0;
	CONFIGRET		cr;

	// Bus Number and Type are retrieved via the Registry function.  This will only
	// work on NT 5.
	BOOL bRet = FALSE ;
	DWORD			dwType = 0;
	DWORD			dwBusNumber;
	INTERFACE_TYPE	BusType;

	ulSizeOfInfo = sizeof(DWORD);
	CConfigMgrAPI*	pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	if ( pconfigmgr )
	{
		if ( pconfigmgr->IsValid () )
		{
			if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																						CM_DRP_BUSNUMBER,
																						&dwType,
																						&dwBusNumber,
																						&ulSizeOfInfo,
																						0 ) ) )
			{
				*pdwBusNumber = dwBusNumber;

				ulSizeOfInfo = sizeof(BusType);

				if (	CR_SUCCESS == ( cr = pconfigmgr->CM_Get_DevNode_Registry_PropertyA(	m_dn,
																							CM_DRP_LEGACYBUSTYPE,
																							&dwType,
																							&BusType,
																							&ulSizeOfInfo,
																							0 ) ) )
				{
					*pitBusType = ConvertBadIsaBusType(BusType);
				}	// IF GetBusType

			}	// IF GetBusNumber
			bRet = ( CR_SUCCESS == cr );
		}
		CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, pconfigmgr ) ;
	}

	return bRet ;
}
#endif

#if NTONLY == 4
BOOL CConfigMgrDevice::GetBusInfoNT4( INTERFACE_TYPE *pitBusType, LPDWORD pdwBusNumber, CNT4ServiceToResourceMap *pResourceMap )
{
	BOOL			fReturn = FALSE;
	CHString		strService;

	if ( GetService( strService ) )
	{
		CNT4ServiceToResourceMap*	pLocalMap = pResourceMap;

		// Instantiate a resource map if we need one.  Then look for
		// resources for this service

		if ( NULL == pLocalMap )
		{
			pLocalMap = new CNT4ServiceToResourceMap;
		}

		if ( NULL != pLocalMap )
		{
            try
            {
			    if ( 0 != pLocalMap->NumServiceResources( strService ) )
			    {
				    LPRESOURCE_DESCRIPTOR	pResource = pLocalMap->GetServiceResource( strService, 0 );

				    // If we got a resource, then use its BUS information directly to populate
				    // our values.

				    if ( NULL != pResource )
				    {
					    fReturn = TRUE;
					    *pitBusType = pResource->InterfaceType;
					    *pdwBusNumber = pResource->Bus;
				    }

			    }	// If there are resources for this service
            }
            catch ( ... )
            {
			    if ( pLocalMap != pResourceMap )
			    {
				    delete pLocalMap;
			    }
                throw ;
            }

			// Delete the local map if we allocated one.
			if ( pLocalMap != pResourceMap )
			{
				delete pLocalMap;
			}

		}	// if pLocalMap
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }


	}	// If got service name

	return fReturn;
}
#endif

BOOL CConfigMgrDevice::BusType16ToInterfaceType( CMBUSTYPE cmBusType16, INTERFACE_TYPE *pinterfaceType )
{

	BOOL	fReturn = TRUE;

//	These are the enums defined for NT, so we'll standardize on these
//
//	typedef enum Interface_Type {
//		Internal,
//		Isa,
//		Eisa,
//		MicroChannel,
//		TurboChannel,
//		PCIBus,
//		VMEBus,
//		NuBus,
//		PCMCIABus,
//		CBus,
//		MPIBus,
//		MPSABus,
//		MaximumInterfaceType
//	}INTERFACE_TYPE;
//

	switch ( cmBusType16 )
	{
		case BusType_ISA:
		{
			*pinterfaceType = Isa;
		}
		break;

		case BusType_EISA:
		{
			*pinterfaceType = Eisa;
		}
		break;

		case BusType_PCI:
		{
			*pinterfaceType = PCIBus;
		}
		break;

		case BusType_PCMCIA:
		{
			*pinterfaceType = PCMCIABus;
		}
		break;

		case BusType_ISAPNP:
		{
			// Closest match I could find
			*pinterfaceType = Isa;
		}
		break;

		case BusType_MCA:
		{
			*pinterfaceType = MicroChannel;
		}
		break;

		case BusType_BIOS:
		{
			*pinterfaceType = Internal;
		}
		break;

		default:
		{
			// Couldn't make the conversion (e.g. BusType_None)
			fReturn = FALSE;
		}
	}

	return fReturn;
}

// Registry Access functions.  Sometimes we want to access the registry directly because
// the device in question places private values in there that our regular functions cannot
// access.
BOOL CConfigMgrDevice::GetRegistryKeyName( CHString &strName)
{
	CHString	strDeviceID;
    BOOL bRet = TRUE;

    if ( GetDeviceID(strDeviceID) )
	{

		// Build the correct key
#ifdef NTONLY
			strName = _T("SYSTEM\\CurrentControlSet\\Enum\\");
#endif
#ifdef WIN9XONLY
			strName = _T("Enum\\");
#endif

		strName += strDeviceID;
    }
    else
    {
        bRet = false;
    }

    return bRet;
}

//
//	Constructor and Destructor for the Device Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceCollection::CDeviceCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceCollection::CDeviceCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceCollection::~CDeviceCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceCollection::~CDeviceCollection( void )
{
}

BOOL CDeviceCollection::GetResourceList( CResourceCollection& resourceList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CResourceCollection	deviceresourceList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

#ifdef NTONLY
	CNT4ServiceToResourceMap*	pResourceMap = NULL;

	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}

    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the Resource List first

	resourceList.Empty();

	if ( BeginEnum( pos ) )
	{

		// Get the resource list from the device, then append it
		// to the list passed in to us.

		for ( pDevice.Attach(GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach(GetNext( pos ) ) )
		{
#ifdef NTONLY
			pDevice->GetResourceList( deviceresourceList, pResourceMap );
#endif
#ifdef WIN9XONLY
			pDevice->GetResourceList( deviceresourceList, NULL );
#endif
			resourceList.Append( deviceresourceList );

		}	// WHILE enuming devices

		EndEnum();

	}
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

BOOL CDeviceCollection::GetIRQResources( CIRQCollection& IRQList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CIRQCollection		deviceIRQList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

	CNT4ServiceToResourceMap*	pResourceMap = NULL;

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}
    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the IRQ List first

	IRQList.Empty();

	if ( BeginEnum( pos ) )
	{

		// For each device, get the IRQs and append them to the
		// supplied IRQ list

		for ( pDevice.Attach( GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach( GetNext( pos ) ))
		{
			pDevice->GetIRQResources( deviceIRQList, pResourceMap );
			IRQList.Append( deviceIRQList );

		}	// for all devices

		EndEnum();

	}	// Begin Enum
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

BOOL CDeviceCollection::GetIOResources( CIOCollection& IOList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CIOCollection		deviceIOList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

	CNT4ServiceToResourceMap*	pResourceMap = NULL;

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}
    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the IO List first

	IOList.Empty();

	if ( BeginEnum( pos ) )
	{

		// For each device, get the IO Port List and append
		// it to the supplied list of IO Ports.

		for ( pDevice.Attach( GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach( GetNext( pos ) ))
		{
			pDevice->GetIOResources( deviceIOList, pResourceMap );
			IOList.Append( deviceIOList );

		}	// for all devices

		EndEnum();

	}	// BeginEnum
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

BOOL CDeviceCollection::GetDMAResources( CDMACollection& DMAList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CDMACollection		deviceDMAList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

	CNT4ServiceToResourceMap*	pResourceMap = NULL;

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}
    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the DMA List first

	DMAList.Empty();

	if ( BeginEnum( pos ) )
	{

		// For each device, get the DMA resources and append them
		// to the supplied list of DMA resources

		for ( pDevice.Attach( GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach( GetNext( pos ) ))
		{
			pDevice->GetDMAResources( deviceDMAList, pResourceMap );
			DMAList.Append( deviceDMAList );

		}	// for all devices

	}	// BeginEnum
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

BOOL CDeviceCollection::GetDeviceMemoryResources( CDeviceMemoryCollection& DeviceMemoryList )
{
	REFPTR_POSITION		pos = NULL;
	CConfigMgrDevicePtr	pDevice;
	CDeviceMemoryCollection	memoryList;
	BOOL				fReturn = TRUE;

	// Snapshot the resources on an NT 4 box.  This only needs to happen once
	// and then we can pass this to devices to hook themselves up to the
	// appropriate resources.  This keeps us from having to build this data
	// for each and every device.

	CNT4ServiceToResourceMap*	pResourceMap = NULL;

#ifdef NTONLY
	if ( IsWinNT4() )
	{
		pResourceMap = new CNT4ServiceToResourceMap;
	}
    if (pResourceMap == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
#endif

	// Empty out the DeviceMemory List first

	DeviceMemoryList.Empty();

	if ( BeginEnum( pos ) )
	{

		// For each device get the list of Memory Resources and
		// append it to the list of supplied Memory Resources.

		for ( pDevice.Attach( GetNext( pos ) );
              pDevice != NULL;
              pDevice.Attach( GetNext( pos ) ))
		{
			pDevice->GetDeviceMemoryResources( memoryList, pResourceMap );
			DeviceMemoryList.Append( memoryList );

		}	// for all devices

		EndEnum();

	}	// BeginEnum()
	else
	{
		fReturn = FALSE;
	}

#ifdef NTONLY
    }
    catch ( ... )
    {
	    if ( NULL != pResourceMap )
	    {
		    delete pResourceMap;
	    }
        throw ;
    }

	// Clean up the resource map if we allocated one.
	if ( NULL != pResourceMap )
	{
		delete pResourceMap;
	}
#endif

	return fReturn;

}

#define MAX_DOS_DEVICES 8192
#define MAX_SYMBOLIC_DEVICES 8192

/*****************************************************************************
 *
 *  FUNCTION    : QueryDosDeviceNames
 *
 *  DESCRIPTION : Queries for all Dos Device symbolic links
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : nichts
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL WINAPI QueryDosDeviceNames ( TCHAR *&a_DosDeviceNameList )
{
	BOOL t_Status = FALSE ;

	CSmartBuffer pQueryBuffer ((MAX_DOS_DEVICES * sizeof (TCHAR)));

	DWORD t_QueryStatus = QueryDosDevice ( NULL , (LPTSTR)((LPBYTE)pQueryBuffer) , MAX_DOS_DEVICES ) ;
	if ( t_QueryStatus )
	{
		a_DosDeviceNameList = new TCHAR [ t_QueryStatus ] ;
        if (a_DosDeviceNameList == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

		memcpy ( a_DosDeviceNameList , (void*)((LPBYTE)pQueryBuffer) , t_QueryStatus * sizeof ( TCHAR ) ) ;

		t_Status = TRUE;
	}

	return t_Status ;
}

/*****************************************************************************
 *
 *  FUNCTION    : FindDosDeviceName
 *
 *  DESCRIPTION : Finds the dos device symbolic link given an NT device name
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : nichts
 *
 *  RETURNS     : nada
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#define MAX_MAPPED_DEVICES 26
#define MAX_DEVICENAME_LENGTH 256

BOOL WINAPI FindDosDeviceName ( const TCHAR *a_DosDeviceNameList , const CHString a_SymbolicName , CHString &a_DosDevice , BOOL a_MappedDevice )
{
	BOOL t_Status = FALSE ;

	CSmartBuffer t_MappedDevices ;

	if ( a_MappedDevice )
	{
		DWORD t_Length = GetLogicalDriveStrings ( 0 , NULL ) ;

        if (t_Length)
        {
            LPBYTE t_buff = new BYTE[(t_Length + 1)  * sizeof(TCHAR)];

            if (t_buff == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            t_MappedDevices = t_buff;

            if (!GetLogicalDriveStrings ( t_Length , (LPTSTR)((LPBYTE)t_MappedDevices) ) )
            {
                DWORD t_Error = GetLastError () ;
                return FALSE;
            }
        }
        else
        {
            DWORD t_Error = GetLastError () ;
            return FALSE;
        }
	}

	const TCHAR *t_Device = a_DosDeviceNameList ;
	while ( *t_Device != NULL )
	{
		CSmartBuffer pQueryBuffer ((MAX_DOS_DEVICES * sizeof (TCHAR)));

		DWORD t_QueryStatus = QueryDosDevice ( t_Device , (LPTSTR)((LPBYTE)pQueryBuffer) , MAX_DOS_DEVICES ) ;
		if ( t_QueryStatus )
		{
			TCHAR *t_Symbolic = (LPTSTR)((LPBYTE)pQueryBuffer) ;

			while ( *t_Symbolic != NULL )
			{
				if ( _wcsicmp ( a_SymbolicName , TOBSTRT(t_Symbolic) ) == 0 )
				{
/*
 *	Atleast get a match even if there is no mapped drive
 */
					t_Status = TRUE ;
					a_DosDevice = t_Device ;

					if ( a_MappedDevice )
					{
						const TCHAR *t_CurrentDevice = (const LPTSTR)((LPBYTE)t_MappedDevices) ;
						while ( *t_CurrentDevice != NULL )
						{
							if ( _tcsnicmp ( t_Device, t_CurrentDevice , 2 ) == 0 )
							{
								t_Status = TRUE ;
								a_DosDevice = t_Device ;
								return TRUE ;
							}

							t_CurrentDevice = t_CurrentDevice + _tcslen ( t_CurrentDevice ) + 1 ;
						}
					}
					else
					{
						return TRUE ;
					}
				}

				t_Symbolic = t_Symbolic + _tcslen ( t_Symbolic ) + 1 ;
			}
		}
		else
		{
			DWORD t_Error = GetLastError () ;
		}

		t_Device = t_Device + _tcslen ( t_Device ) + 1 ;
	}

	return t_Status ;
}

BOOL CConfigMgrDevice::IsClass(LPCWSTR pwszClassName)
{
    BOOL bRet = FALSE;
    CHString sTemp;

    if (GetClass(sTemp))
    {
        if (sTemp.CompareNoCase(pwszClassName) == 0)
        {
            bRet = TRUE;
        }
        else
        {
            bRet = FALSE;
        }
    }
    else
    {
        CHString sClass(pwszClassName);
        sClass.MakeUpper();

        WCHAR cGuid[128];
        GUID gFoo = CConfigManager::s_ClassMap[sClass];
        StringFromGUID2(gFoo, cGuid, sizeof(cGuid)/sizeof(WCHAR));
        if (GetClassGUID(sTemp) && (sTemp.CompareNoCase(cGuid) == 0))
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL CConfigMgrDevice::GetRegStringProperty(
    LPCWSTR szProperty,
    CHString &strValue)
{
    CHString    strKeyName;
    DWORD       dwRet;
    CRegistry   reg;

    if (GetRegistryKeyName(strKeyName) &&
        (dwRet = reg.Open(HKEY_LOCAL_MACHINE, strKeyName,
        KEY_QUERY_VALUE) == ERROR_SUCCESS))
    {
        dwRet = reg.GetCurrentKeyValue(szProperty, strValue);
    }

    return dwRet == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cfgmgrdevice.h ===
/////////////////////////////////////////////////////////////////////////

//

//  cfgmgrdevice.h    

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//  
/////////////////////////////////////////////////////////////////////////

#ifndef __CFGMGRDEVICE_H__
#define __CFGMGRDEVICE_H__

/////////////////////////////////////////////////////////////////////////
//  registry keys
/////////////////////////////////////////////////////////////////////////
#define	CONFIGMGR_ENUM_KEY					L"Config Manager\\Enum\\"
#define	LOCALMACHINE_ENUM_KEY				L"Enum\\"

#define	CONFIGMGR_DEVICE_HARDWAREKEY_VALUE	_T("HardwareKey")
#define	CONFIGMGR_DEVICE_ALLOCATION_VALUE	_T("Allocation")
#define	CONFIGMGR_DEVICEDESC_VALUE			_T("DeviceDesc")
#define	CONFIGMGR_DEVICE_PROBLEM_VALUE		_T("Problem")
#define	CONFIGMGR_DEVICE_STATUS_VALUE		L"Status"
#define	CONFIGMGR_DEVICE_STATUS_VALUET		_T("Status")

#include "iodesc.h"
#include "chwres.h"
#include "sms95lanexp.h"
#include "refptrlite.h"

class CIRQCollection;
class CDMACollection;
class CDeviceMemoryCollection;
class CNT4ServiceToResourceMap;

BOOL WINAPI FindDosDeviceName ( const TCHAR *a_DosDeviceNameList , const CHString a_SymbolicName , CHString &a_DosDevice , BOOL a_MappedDevice = FALSE ) ;
BOOL WINAPI QueryDosDeviceNames ( TCHAR *&a_DosDeviceNameList ) ;


/////////////////////////////////////////////////////////////////////////
class 
__declspec(uuid("CB0E0536-D375-11d2-B35E-00104BC97924"))
CConfigMgrDevice : public CRefPtrLite
{
	
    public:

	    // Construction/Destruction
	    CConfigMgrDevice( LPCWSTR pszConfigMgrName,DWORD dwTypeToGet );
	    //CConfigMgrDevice( LPCWSTR pszDevice );
		CConfigMgrDevice( DEVNODE dn = NULL, DWORD dwResType = ResType_All );
	    ~CConfigMgrDevice();

		//////////////////////////////////////////////////
		//	AVOID THESE FUNCTIONS, THESE ARE LEGACY		//
		//////////////////////////////////////////////////

	    LPCWSTR	GetName( void );
	    LPCWSTR	GetHardwareKey( void );
	    LPCWSTR	GetDeviceDesc( void );

		// Status and problem functions
		DWORD	GetStatus( void );
		BOOL	GetStatus( CHString& str );
		void	GetProblem( CHString& str );

		DWORD	GetProblem( void );
		BOOL	IsOK( void );
		BOOL	MapKeyToConfigMgrDeviceName();

		//////////////////////////////////
		//	END LEGACY FUNCTIONS		//
		//////////////////////////////////

		//////////////////////////////////////////////////////
		//	USE THESE FUNCTIONS, THESE ARE THE REAL THING!	//
		//////////////////////////////////////////////////////

		// New functions that use config manager APIs directly

		// Resource retrieval
	    void GetResourceList( CResourceCollection& resourceList, CNT4ServiceToResourceMap* pResourceMap = NULL  );
	    BOOL GetIRQResources( CIRQCollection& irqList, CNT4ServiceToResourceMap* pResourceMap = NULL  );
	    BOOL GetIOResources( CIOCollection& ioList, CNT4ServiceToResourceMap* pResourceMap = NULL  );
	    BOOL GetDMAResources( CDMACollection& dmaList, CNT4ServiceToResourceMap* pResourceMap = NULL  );
	    BOOL GetDeviceMemoryResources( CDeviceMemoryCollection& DeviceMemoryList, CNT4ServiceToResourceMap* pResourceMap = NULL  );

		// String Values
		BOOL GetDeviceDesc( CHString& strVal );
		BOOL GetService( CHString& strVal );
		BOOL GetClass( CHString& strVal );
		BOOL GetClassGUID( CHString& strVal );
		BOOL GetDriver( CHString& strVal );
		BOOL GetMfg( CHString& strVal );
		BOOL GetFriendlyName( CHString& strVal );
		BOOL GetLocationInformation( CHString& strVal );
		BOOL GetPhysicalDeviceObjectName( CHString& strVal );
		BOOL GetEnumeratorName( CHString& strVal );

		// DWORD Values
		BOOL GetConfigFlags( DWORD& dwVal );
		BOOL GetCapabilities( DWORD& dwVal );
		BOOL GetUINumber( DWORD& dwVal );

		// MULTI_SZ Values
		BOOL GetHardwareID( CHStringArray& strArray );
		BOOL GetCompatibleIDS( CHStringArray& strArray );
		BOOL GetUpperFilters( CHStringArray& strArray );
		BOOL GetLowerFilters( CHStringArray& strArray );

		// Use Config Manager APIs directly
		BOOL GetStringProperty( ULONG ulProperty, CHString& strValue );
		BOOL GetDWORDProperty( ULONG ulProperty, DWORD* pdwVal );
		BOOL GetMULTISZProperty( ULONG ulProperty, CHStringArray& strArray );

		// Device Relationship functions
		BOOL GetParent( CConfigMgrDevice** pParentDevice );
		BOOL GetChild( CConfigMgrDevice** pChildDevice );
		BOOL GetSibling( CConfigMgrDevice** pSiblingDevice );

		// Miscelaneous Device functions
		BOOL GetBusInfo( INTERFACE_TYPE* pitBusType, LPDWORD pdwBusNumber, CNT4ServiceToResourceMap* pResourceMap = NULL );
		BOOL GetDeviceID( CHString& strID );
		BOOL GetStatus( LPDWORD pdwStatus, LPDWORD pdwProblem );
		BOOL IsUsingForcedConfig();
        BOOL IsClass(LPCWSTR pwszClassName);

		// Direct registry access helpers
        BOOL GetRegistryKeyName( CHString &strName);
        BOOL GetRegStringProperty(LPCWSTR szProperty, CHString &strValue);

		BOOL operator == ( const CConfigMgrDevice& device );

    private:

	    // Registry traversal helpers

		// LEGACY FUNCTIONS BEGIN		
	    BOOL GetConfigMgrInfo( void );
	    BOOL GetDeviceInfo( void );

	    BOOL GetHardwareKey( HKEY hKey );
	    BOOL GetResourceAllocation( HKEY hKey );
		BOOL GetStatusInfo( HKEY hKey );
	    BOOL GetDeviceDesc( HKEY hKey );
		// LEGACY FUNCTIONS END

#if NTONLY > 4
		// NT 5 Helpers
		BOOL GetBusInfoNT5( INTERFACE_TYPE* pitBusType, LPDWORD pdwBusNumber );
        static BOOL WINAPI IsIsaReallyEisa();
        static INTERFACE_TYPE WINAPI ConvertBadIsaBusType(INTERFACE_TYPE type);
#endif

	    // Resource Allocation Data Helpers

	    // Resource allocation registry walkthroughs
	    void TraverseAllocationData( CResourceCollection& resourceList );
	    void TraverseData( const BYTE *& pbTraverseData, DWORD& dwSizeRemainingData, DWORD dwSizeTraverse );
	    BOOL GetNextResource( const BYTE * pbTraverseData, DWORD dwSizeRemainingData, DWORD& dwResourceType, DWORD& dwResourceSize );

		// Resource functions
		BOOL WalkAllocatedResources( CResourceCollection& resourceList, CNT4ServiceToResourceMap* pResourceMap, RESOURCEID resType );
		BOOL AddResourceToList( RESOURCEID resourceID, LPVOID pResource, DWORD dwResourceLength, CResourceCollection& resourceList );

#ifdef NTONLY
		// NT4 Resource functions
		BOOL WalkAllocatedResourcesNT4( CResourceCollection& resourceList, CNT4ServiceToResourceMap* pResourceMap, CM_RESOURCE_TYPE resType );
		BOOL GetServiceResourcesNT4( LPCWSTR pszServiceName, CNT4ServiceToResourceMap& resourceMap, CResourceCollection& resourceList, CM_RESOURCE_TYPE cmrtFilter = CmResourceTypeNull );
#if NTONLY == 4
		BOOL GetBusInfoNT4( INTERFACE_TYPE* pitBusType, LPDWORD pdwBusNumber, CNT4ServiceToResourceMap* pResourceMap );
#endif

		// NT 4 resource datatype coercsion functions
		CM_RESOURCE_TYPE RESOURCEIDToCM_RESOURCE_TYPE( RESOURCEID resType );
		void NT4IRQToIRQ_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PIRQ_DES pirqDes32 );
		void NT4IOToIOWBEM_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PIOWBEM_DES pioDes32 );
		void NT4MEMToMEM_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PMEM_DES pmemDes32 );
		void NT4DMAToDMA_DES( LPRESOURCE_DESCRIPTOR pResourceDescriptor, PDMA_DES pdmaDes32 );
#endif

		// 16 to 32-bit coercsion functions
		void IRQDes16To32( PIRQ_DES16 pirqDes16, PIRQ_DES pirqDes32 );
		void IODes16To32( PIO_DES16 pioDes16, PIOWBEM_DES pioDes32 );
		void DMADes16To32( PDMA_DES16 pdmaDes16, PDMA_DES pdmaDes32 );
		void MEMDes16To32( PMEM_DES16 pmemDes16, PMEM_DES pmemDes32 );
		BOOL BusType16ToInterfaceType( CMBUSTYPE cmBusType16, INTERFACE_TYPE* pinterfaceType );

		// LEGACY VARIABLES BEGIN		

	    CHString	m_strConfigMgrName;
	    CHString	m_strHardwareKey;
	    CHString	m_strDeviceDesc;
        DWORD       m_dwTypeToGet;

	    // If we get allocation information, we store it in here.
	    BYTE*	m_pbAllocationData;
	    DWORD	m_dwSizeAllocationData;

		// Device status info
		DWORD	m_dwStatus;
		DWORD	m_dwProblem;

#ifdef WIN9XONLY
        DWORD   GetStatusFromConfigManagerDirectly(void);
#endif

		// LEGACY VARIABLES END

		// Use the devnode to query values directly from config manager
		DEVNODE	m_dn;

};

_COM_SMARTPTR_TYPEDEF(CConfigMgrDevice, __uuidof(CConfigMgrDevice));

inline LPCWSTR CConfigMgrDevice::GetName( void )
{
	return m_strConfigMgrName;
}


inline LPCWSTR CConfigMgrDevice::GetHardwareKey( void )
{
	return m_strHardwareKey;
}

inline LPCWSTR CConfigMgrDevice::GetDeviceDesc( void )
{
	return m_strDeviceDesc;
}

inline void CConfigMgrDevice::GetResourceList( CResourceCollection& resourceList, CNT4ServiceToResourceMap* pResourceMap/*=NULL*/ )
{
	WalkAllocatedResources( resourceList, pResourceMap, m_dwTypeToGet );
}

inline DWORD CConfigMgrDevice::GetStatus( void )
{
	return m_dwStatus;
}

inline DWORD CConfigMgrDevice::GetProblem( void )
{
	return m_dwProblem;
}

inline BOOL CConfigMgrDevice::IsOK( void )
{
	return ( 0 == m_dwProblem );
}

// New Config manager functions that query Config Manager (16 & 32 bit)
// directly for info.

// REG_SZ Properties
inline BOOL CConfigMgrDevice::GetDeviceDesc( CHString& strVal )
{
	return GetStringProperty( CM_DRP_DEVICEDESC, strVal );
}

inline BOOL CConfigMgrDevice::GetService( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_SERVICE, strVal );
}

inline BOOL CConfigMgrDevice::GetClass( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_CLASS, strVal );
}

inline BOOL CConfigMgrDevice::GetClassGUID( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_CLASSGUID, strVal );
}

inline BOOL CConfigMgrDevice::GetDriver( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_DRIVER, strVal );
}

inline BOOL CConfigMgrDevice::GetMfg( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_MFG, strVal );
}

inline BOOL CConfigMgrDevice::GetFriendlyName( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_FRIENDLYNAME, strVal );
}

inline BOOL CConfigMgrDevice::GetLocationInformation( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_LOCATION_INFORMATION, strVal );
}

inline BOOL CConfigMgrDevice::GetPhysicalDeviceObjectName( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME, strVal );
}

inline BOOL CConfigMgrDevice::GetEnumeratorName( CHString& strVal )
{
	return 	GetStringProperty( CM_DRP_ENUMERATOR_NAME, strVal );
}

// DWORD functions
inline BOOL CConfigMgrDevice::GetConfigFlags( DWORD& dwVal )
{
	return 	GetDWORDProperty( CM_DRP_CONFIGFLAGS, &dwVal );
}

inline BOOL CConfigMgrDevice::GetCapabilities( DWORD& dwVal )
{
	return 	GetDWORDProperty( CM_DRP_CAPABILITIES, &dwVal );
}

inline BOOL CConfigMgrDevice::GetUINumber( DWORD& dwVal )
{
	return 	GetDWORDProperty( CM_DRP_UI_NUMBER, &dwVal );
}

// MULTI_SZ properties
inline BOOL CConfigMgrDevice::GetHardwareID( CHStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_HARDWAREID, strArray );
}

inline BOOL CConfigMgrDevice::GetCompatibleIDS( CHStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_COMPATIBLEIDS, strArray );
}

inline BOOL CConfigMgrDevice::GetUpperFilters( CHStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_UPPERFILTERS, strArray );
}

inline BOOL CConfigMgrDevice::GetLowerFilters( CHStringArray& strArray )
{
	return 	GetMULTISZProperty( CM_DRP_LOWERFILTERS, strArray );
}

// Overloaded == operator.  Checks if DEVNODEs are the same.
inline BOOL CConfigMgrDevice::operator == ( const CConfigMgrDevice& device )
{
	return ( m_dn == device.m_dn );
}

// A collection of Devices
class CDeviceCollection : public TRefPtr<CConfigMgrDevice>
{
public:

	// Construction/Destruction
	CDeviceCollection();
	~CDeviceCollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CDeviceCollection& operator = ( const CDeviceCollection& srcCollection );

	// Get the resources for this list of devices.

	BOOL GetResourceList( CResourceCollection& resourceList );
	BOOL GetIRQResources( CIRQCollection& IRQList );
	BOOL GetDMAResources( CDMACollection& DMAList );
	BOOL GetIOResources( CIOCollection& IOList );
	BOOL GetDeviceMemoryResources( CDeviceMemoryCollection& DeviceMemoryList );

};

inline const CDeviceCollection& CDeviceCollection::operator = ( const CDeviceCollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\chwres.cpp ===
//====================================================================

//

// chwres.cpp -- Hardware resource access wrapper class implementation

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    02/25/97    a-jmoon    Adapted from original horrible
//                                      code -- only comments remain.
//
//====================================================================
#include "precomp.h"
#include <cregcls.h>
#include "chwres.h"

/*****************************************************************************
 *
 *  FUNCTION    : CHWResource::CHWResource
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Initialization
 *
 *****************************************************************************/

#ifdef NTONLY
CHWResource::CHWResource()
{
    // Zero out public structure
    //==========================

    memset(&_SystemResourceList, 0, sizeof(_SystemResourceList)) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CHWResource::~CHWResource
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Cleanup
 *
 *****************************************************************************/

CHWResource::~CHWResource()
{
    // Make sure we've destroyed everything
    //=====================================

    DestroySystemResourceLists() ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CHWResource::DestroySystemResourceLists
 *
 *  DESCRIPTION : Walks list of devices & frees associated resource records
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

void CHWResource::DestroySystemResourceLists()
{
    LPDEVICE pDevice ;
    LPRESOURCE_DESCRIPTOR pResource ;

    while(_SystemResourceList.DeviceHead != NULL)
    {
        pDevice = _SystemResourceList.DeviceHead ;
        _SystemResourceList.DeviceHead = pDevice->Next ;

        delete pDevice->Name ;
        delete pDevice->KeyName ;

        while(pDevice->ResourceDescriptorHead != NULL)
        {
            pResource = pDevice->ResourceDescriptorHead ;
            pDevice->ResourceDescriptorHead = pResource->NextDiff ;

            delete pResource ;
        }

        delete pDevice ;
    }

    memset(&_SystemResourceList, 0, sizeof(_SystemResourceList)) ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CHWResource::CreateSystemResourceLists
 *                CHWResource::EnumerateResources
 *                CHWResource::CreateResourceList
 *                CHWResource::CreateResourceRecord
 *
 *  DESCRIPTION : These four routines recursively enumerate device records
 *                under HKEY_LOCAL_MACHINE\Hardware\ResourceMap and its
 *                subkeys, creating a linked list of discovered devices.
 *                Under each device, a linked list of resources owned by
 *                the device is also created.  Resource records are also
 *                linked into chains specific to the type of resource.
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Initialization
 *
 *****************************************************************************/

void CHWResource::CreateSystemResourceLists()
{
    // Start w/clean slate
    //====================

    DestroySystemResourceLists() ;

    // Begin device enumeration at HKLM\Hardware\ResourceMap
    //======================================================

    EnumerateResources(_T("Hardware\\ResourceMap")) ;
}

void CHWResource::EnumerateResources(CHString sKeyName)
{
    CRegistry Reg ;
    CHString sSubKeyName, sDeviceName ;
    int iFirst ;
    DWORD i, dwCount, dwValueType, dwValueNameSize, dwValueDataSize ;
    TCHAR *pValueName ;
    unsigned char *pValueData ;
    PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor ;

    // Open target key
    //================

    if(Reg.Open(HKEY_LOCAL_MACHINE, (LPCTSTR) sKeyName, KEY_READ) != ERROR_SUCCESS)
    {
        return ;
    }

    // First, enumerate subkeys
    //=========================

    for( ; ; )
    {
        if(Reg.GetCurrentSubKeyName(sSubKeyName) == ERROR_SUCCESS)
        {
            EnumerateResources(sKeyName + "\\" + sSubKeyName) ;
        }

        if(Reg.NextSubKey() != ERROR_SUCCESS)
        {
            break ;
        }
    }

    // Extract this subkey's name
    //===========================

    iFirst = sKeyName.ReverseFind('\\') ;
    sSubKeyName = sKeyName.Mid(iFirst + 1, sKeyName.GetLength() - iFirst) ;

    // Create name & data buffers
    //===========================

    pValueName = new TCHAR[Reg.GetLongestValueName() + 2] ;
    pValueData = new unsigned char[Reg.GetLongestValueData() + 2] ;

    if(pValueName == NULL || pValueData == NULL)
    {

        delete [] pValueName ;
        delete [] pValueData ;

        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    // Enumerate subkeys
	//==================

    try
    {
        for(i = 0 ; i < Reg.GetValueCount() ; i++)
        {

            // We need type data, so can't use the CRegistry wrapper
            //======================================================

            dwValueNameSize = Reg.GetLongestValueName() + 2 ;
            dwValueDataSize = Reg.GetLongestValueData() + 2 ;

            if(RegEnumValue(Reg.GethKey(), i, pValueName, &dwValueNameSize,
                            NULL, &dwValueType, pValueData, &dwValueDataSize) != ERROR_SUCCESS)
            {
                continue ;
            }

            // Only deal w/'Raw' data
            //=======================

            sDeviceName = pValueName ;
            if(sDeviceName.Right(4) != _T(".Raw")) {

                continue ;
            }

            // We've found some resource records -- extract device name
            //=========================================================

            iFirst = sDeviceName.ReverseFind('\\') ;
            if(iFirst == -1)
            {
                // No device in value name -- device is subkey
                //============================================

                sDeviceName = sSubKeyName ;
            }
            else
            {
                sDeviceName = sDeviceName.Mid(iFirst + 1, sDeviceName.GetLength() - 5 - iFirst) ;
            }

            if(sDeviceName.IsEmpty())
            {
                continue ;
            }

            // Based on returned type, set up for resource enumeration
            //========================================================

            if(dwValueType == REG_FULL_RESOURCE_DESCRIPTOR)
            {
                dwCount         = 1 ;
                pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) pValueData ;
            }
            else if(dwValueType == REG_RESOURCE_LIST)
            {
                dwCount         = ((PCM_RESOURCE_LIST) pValueData)->Count ;
                pFullDescriptor = ((PCM_RESOURCE_LIST) pValueData)->List ;
            }
            else
            {
                continue ;
            }

            // Add the device & resources to system lists
            //===========================================

            CreateResourceList(sDeviceName, dwCount, pFullDescriptor, sKeyName) ;
        }
    }
    catch ( ... )
    {
        delete [] pValueName ;
        delete [] pValueData ;

        throw;
    }

    delete [] pValueName ;
    delete [] pValueData ;

    Reg.Close() ;
}

void CHWResource::CreateResourceList(CHString sDeviceName, DWORD dwFullResourceCount,
                                     PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, CHString sKeyName)
{
    LPDEVICE pDevice ;
    DWORD i, j ;
    PCM_PARTIAL_RESOURCE_LIST pPartialList ;

    // Locate/create record for device
    //================================

    pDevice = _SystemResourceList.DeviceHead ;
    while(pDevice != NULL)
    {

        if(sDeviceName == pDevice->Name)
        {

            break ;
        }

        pDevice = pDevice->Next ;
    }

    if(pDevice == NULL)
    {

        // Device not found -- create new device record
        //=============================================

        pDevice = new DEVICE ;
        if(pDevice == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

        memset(pDevice, 0, sizeof(DEVICE)) ;

        pDevice->Name = new TCHAR[sDeviceName.GetLength() + 2] ;
        if(pDevice->Name == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

        try
        {
            _tcscpy(pDevice->Name, LPCTSTR(sDeviceName)) ;

            pDevice->KeyName = new TCHAR [sKeyName.GetLength() + 2] ;
            if(pDevice->KeyName == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            _tcscpy(pDevice->KeyName, LPCTSTR(sKeyName)) ;

            if(_SystemResourceList.DeviceHead == NULL)
            {
                _SystemResourceList.DeviceHead = pDevice ;
            }
            else
            {
                _SystemResourceList.DeviceTail->Next = pDevice ;
            }

            _SystemResourceList.DeviceTail = pDevice ;
        }
        catch ( ... )
        {
            delete pDevice;
            throw ;
        }
    }

    // Create record for each owned resource
    //======================================

    for(i = 0 ; i < dwFullResourceCount ; i++)
    {
        pPartialList = &pFullDescriptor->PartialResourceList ;

        for(j = 0 ; j < pPartialList->Count; j++)
        {
            CreateResourceRecord(pDevice, pFullDescriptor->InterfaceType, pFullDescriptor->BusNumber, &pPartialList->PartialDescriptors[j]) ;
        }

        // Point to next full descriptor
        //==============================

        pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) &pPartialList->PartialDescriptors[pPartialList->Count] ;
    }
}

void CHWResource::CreateResourceRecord(LPDEVICE pDevice, INTERFACE_TYPE InterfaceType, ULONG Bus, PCM_PARTIAL_RESOURCE_DESCRIPTOR pResource)
{
    LPRESOURCE_DESCRIPTOR pNewResource, *pHead, *pTail, pCurrent, pLast ;

    // Only deal w/'known' resource types
    //===================================

    if(pResource->Type != CmResourceTypePort        &&
       pResource->Type != CmResourceTypeInterrupt   &&
       pResource->Type != CmResourceTypeMemory      &&
       pResource->Type != CmResourceTypeDma         )
    {
        return ;
    }

    // Create new record for resource & add to device's list
    //======================================================

    pNewResource = new RESOURCE_DESCRIPTOR ;
    if(pNewResource == NULL)
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
        memset(pNewResource, 0, sizeof(RESOURCE_DESCRIPTOR)) ;

        memcpy(&pNewResource->CmResourceDescriptor, pResource, sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)) ;

        pNewResource->Owner = pDevice ;
        pNewResource->Bus = Bus;
        pNewResource->InterfaceType = InterfaceType;

        if(pDevice->ResourceDescriptorHead == NULL)
        {

            pDevice->ResourceDescriptorHead = pNewResource ;
        }
        else
        {

            pDevice->ResourceDescriptorTail->NextDiff = pNewResource ;
        }

        pDevice->ResourceDescriptorTail = pNewResource ;
    }
    catch ( ... )
    {
        delete pNewResource;
        throw ;
    }

    // Locate insertion point into sorted type-specific list
    //======================================================

    switch(pResource->Type)
    {
        case CmResourceTypePort :

            pHead = &_SystemResourceList.PortHead ;
            pTail = &_SystemResourceList.PortTail ;

            pCurrent = *pHead ;
            pLast    = NULL ;

            LARGE_INTEGER liTemp;  // Used to avoid 64bit alignment problems

            liTemp.HighPart = pResource->u.Port.Start.HighPart;
            liTemp.LowPart = pResource->u.Port.Start.LowPart;

            while(pCurrent != NULL)
            {
                LARGE_INTEGER liTemp2;  // Used to avoid 64bit alignment problems

                liTemp2.HighPart = pCurrent->CmResourceDescriptor.u.Port.Start.HighPart;
                liTemp2.LowPart = pCurrent->CmResourceDescriptor.u.Port.Start.LowPart;

                if (liTemp2.QuadPart < liTemp.QuadPart)
                {
                    pLast    = pCurrent ;
                    pCurrent = pCurrent->NextSame ;
                }
                else
                {
                    break;
                }
            }

            break;

        case CmResourceTypeInterrupt :
        {
            pHead = &_SystemResourceList.InterruptHead ;
            pTail = &_SystemResourceList.InterruptTail ;

            pCurrent = *pHead ;
            pLast    = NULL ;

            ULONGLONG iIRQ = pResource->u.Interrupt.Level;

            // If the IRQ to add is less than the current IRQ, OR
            // if the IRQ to add is the same as the current IRQ and the current
            // IRQ is not an internal one, put it after the current one.  This
            // will make sure that internal IRQs are listed last in the list.
            while (pCurrent != NULL &&
                   ( (pCurrent->CmResourceDescriptor.u.Interrupt.Level < iIRQ) ||
                     ((pCurrent->CmResourceDescriptor.u.Interrupt.Level == iIRQ) &&
                      (pCurrent->InterfaceType != Internal))
                  ))
            {
                pLast    = pCurrent ;
                pCurrent = pCurrent->NextSame ;
            }

            break;
        }

        case CmResourceTypeMemory :
        {

            pHead = &_SystemResourceList.MemoryHead ;
            pTail = &_SystemResourceList.MemoryTail ;

            pCurrent = *pHead ;
            pLast    = NULL ;

            LARGE_INTEGER liTemp;  // Used to avoid 64bit alignment problems

            liTemp.HighPart = pResource->u.Memory.Start.HighPart;
            liTemp.LowPart = pResource->u.Memory.Start.LowPart;

            while(pCurrent != NULL)
            {
                LARGE_INTEGER liTemp2;  // Used to avoid 64bit alignment problems

                liTemp2.HighPart = pCurrent->CmResourceDescriptor.u.Memory.Start.HighPart;
                liTemp2.LowPart = pCurrent->CmResourceDescriptor.u.Memory.Start.LowPart;

                if (liTemp2.QuadPart < liTemp.QuadPart)
                {
                    pLast    = pCurrent ;
                    pCurrent = pCurrent->NextSame ;
                }
                else
                {
                    break;
                }
            }

            break;
        }

        case CmResourceTypeDma :

            pHead = &_SystemResourceList.DmaHead ;
            pTail = &_SystemResourceList.DmaTail ;

            pCurrent = *pHead ;
            pLast    = NULL ;

            while(pCurrent != NULL &&
                  pCurrent->CmResourceDescriptor.u.Dma.Channel < pResource->u.Dma.Channel)
            {
                pLast    = pCurrent ;
                pCurrent = pCurrent->NextSame ;
            }

            break;

    }

    // Insert into...
    //===============

    if(*pHead == NULL)
    {

        // ...empty list
        //==========================

        (*pHead) = pNewResource ;
        (*pTail) = pNewResource ;
    }
    else if(pLast == NULL)
    {

        // ...beginning of list
        //=================================

        pNewResource->NextSame = pCurrent ;
        (*pHead)               = pNewResource ;
    }
    else if(pCurrent == NULL)
    {
        // ...end of list
        //=========================

        pLast->NextSame = pNewResource ;
        (*pTail)        = pNewResource ;
    }
    else
    {
        // ...middle of list
        //==============================

        pLast->NextSame        = pNewResource ;
        pNewResource->NextSame = pCurrent ;
    }
}
#endif

// Helper function for converting strings to resource types
BOOL WINAPI StringFromInterfaceType( INTERFACE_TYPE it, CHString& strVal )
{
	//BOOL	fReturn = TRUE;

	//switch ( it )
	//{
	//	case	Internal:			strVal = "INTERNAL";			break;
	//	case	Isa:				strVal = "ISA";					break;
	//	case	Eisa:				strVal = "EISA";				break;
	//	case	MicroChannel:		strVal = "MICROCHANNEL";		break;
	//	case	TurboChannel:		strVal = "TURBOCHANNEL";		break;
	//	case	PCIBus:				strVal = "PCI";					break;
	//	case	VMEBus:				strVal = "VME";					break;
	//	case	NuBus:				strVal = "NU";					break;
	//	case	PCMCIABus:			strVal = "PCMCIA";				break;
	//	case	CBus:				strVal = "INTERNAL";			break;
	//	case	MPIBus:				strVal = "INTERNAL";			break;
	//	case	MPSABus:			strVal = "MPSA";				break;
	//	case	ProcessorInternal:	strVal = "PROCESSORINTERNAL";	break;
	//	case	InternalPowerBus:	strVal = "INTERNALPOWER";		break;
	//	case	PNPISABus:			strVal = "PNPISA";				break;
	//	case	PNPBus:				strVal = "PNP";					break;
	//	default:					fReturn = FALSE;
	//}

    if(it > InterfaceTypeUndefined && it < MaximumInterfaceType)
    {
        strVal = szBusType[it];
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cim32netapi.h ===
//=================================================================

//

// Cim32NetApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_CIM32NETAPI_H_
#define	_CIM32NETAPI_H_

#ifdef WIN9XONLY
#include "win32thk.h"
#include "DllWrapperBase.h"

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidCim32NetApi;
extern const TCHAR g_tstrCim32Net[];


typedef ULONG *LPULONG;     
typedef DWORD CMBUSTYPE;
typedef CMBUSTYPE *PCMBUSTYPE;
typedef unsigned short *LPUSHORT;

// Config Manager definitions
typedef	DWORD LOG_CONF;	// Logical configuration.
typedef	DWORD RES_DES;	// Resource descriptor.
typedef	LOG_CONF* PLOG_CONF;	// Pointer to logical configuration.
typedef	RES_DES* PRES_DES;	// Pointer to resource descriptor.
typedef DWORD RANGE_LIST;
typedef DWORD RANGE_ELEMENT;
typedef RANGE_ELEMENT* PRANGE_ELEMENT;

typedef DWORD DEVNODE;
typedef DEVNODE* PDEVNODE;
typedef	DWORD CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE *PCMBUSTYPE;	// Pointer to a bus type.
typedef	ULONG RESOURCEID;	// Resource type ID.
typedef	RESOURCEID* PRESOURCEID;	// Pointer to resource type ID.

/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef WORD (WINAPI *PFN_CIM32NET_GET_WIN_9_X_BIOS_UNIT) 
(
    LPSTR lpDeviceID
);

typedef BYTE (WINAPI *PFN_CIM32NET_GET_WIN_9_X_PARTITION_TABLE) 
(
    BYTE cDrive, 
    pMasterBootSector pMBR
);

typedef BYTE (WINAPI *PFN_CIM32NET_WIN_9_X_DRIVE_PARAMS) 
(
    BYTE cDrive, 
    pInt13DriveParams pParams
);


typedef ULONG (WINAPI *PFN_CIM32NET_GET_WIN_9_X_USE_INFO_1)
(
    LPSTR Name, 
    LPSTR Local, 
    LPSTR Remote, 
    LPSTR Password, 
    LPULONG pdwStatus,
    LPULONG pdwType,
    LPULONG pdwRefCount,
    LPULONG pdwUseCount
);

typedef ULONG (WINAPI *PFN_CIM32NET_GET_WIN_9_X_NET_USE_ENUM)
(
    LPCSTR pszServer,
    short sLevel,
    LPSTR pbBuffer,
    use_info_1Out *pBuffer2,
    unsigned short cbBuffer,
    unsigned short far *pcEntriesRead,
    unsigned short far *pcTotalAvail
);

typedef ULONG (WINAPI *PFN_CIM32NET_GET_WIN_9_X_USER_INFO_1)
(
    LPSTR Name,	
    LPSTR HomeDirectory, 
    LPSTR Comment, 
    LPSTR ScriptPath, 
    LPULONG PasswordAge, 
    LPUSHORT Privileges, 
    LPUSHORT Flags 
);

typedef ULONG (WINAPI *PFN_CIM32NET_GET_WIN_9_X_USER_INFO_2)
(
    LPSTR Name, 
    LPSTR FullName,
    LPSTR UserComment, 
    LPSTR Parameters, 
    LPSTR Workstations, 
    LPSTR LogonServer, 
    LPLOGONDETAILS LogonDetails 
);

typedef ULONG (WINAPI *PFN_CIM32NET_GET_WIN_9_X_USER_INFO_1_EX)
(
    LPSTR DomainName,
    LPSTR Name,
    DWORD fGetDC,	
    LPSTR HomeDirectory, 
    LPSTR Comment, 
    LPSTR ScriptPath, 
    LPULONG PasswordAge, 
    LPUSHORT Privileges, 
    LPUSHORT Flags 
);

typedef ULONG (WINAPI *PFN_CIM32NET_GET_WIN_9_X_USER_INFO_2_EX)
(
    LPSTR DomainName,
    LPSTR Name,
    DWORD fGetDC, 
    LPSTR FullName,
    LPSTR UserComment, 
    LPSTR Parameters, 
    LPSTR Workstations, 
    LPSTR LogonServer, 
    LPLOGONDETAILS LogonDetails 
);


typedef ULONG (WINAPI *PFN_CIM32NET_GET_WIN_9_X_CONFIG_MANAGER_STATUS)
(
    LPSTR HardwareKey
);

typedef DWORD (WINAPI *PFN_CIM32NET_GET_WIN_9_X_FREE_SPACE)
(
    DWORD dwOption
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_LOCATE_DEVNODE) 
( 
    PDEVNODE pdn, 
    LPSTR HardwareKey, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_CHILD) 
(
    PDEVNODE pdn, 
    DEVNODE dnParent, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_SIBLING) 
( 
    PDEVNODE pdn, 
    DEVNODE dnParent, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_READ_REGISTRY_VALUE) 
( 
    DEVNODE dnDevNode, 
    LPSTR pszSubKey, LPCSTR pszValueName, 
    ULONG ulExpectedType, 
    LPVOID Buffer, 
    LPULONG pulLength, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_DEVNODE_STATUS) 
( 
    LPULONG pulStatus, 
    LPULONG pulProblemNumber, 
    DEVNODE dnDevNode, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_DEVICE_ID) 
( 
    DEVNODE dnDevNode, 
    LPVOID Buffer, 
    ULONG BufferLen, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_DEVICE_ID_SIZE) 
( 
    LPULONG pulLen, 
    DEVNODE dnDevNode, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_FIRST_LOG_CONF) 
( 
    PLOG_CONF plcLogConf, 
    DEVNODE dnDevNode, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_NEXT_RES_DES) 
( 
    PRES_DES prdResDes, 
    RES_DES rdResDes, 
    RESOURCEID ForResource, 
    PRESOURCEID pResourceID, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_RES_DES_DATA_SIZE) 
( 
    LPULONG pulSize, 
    RES_DES rdResDes, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_RES_DES_DATA) 
( 
    RES_DES rdResDes, 
    LPVOID Buffer, 
    ULONG BufferLen, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_BUS_INFO) 
(
    DEVNODE dnDevNode, 
    PCMBUSTYPE pbtBusType, 
    LPULONG pulSizeOfInfo, 
    LPVOID pInfo, 
    ULONG ulFlags
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_GET_PARENT) 
( 
    PDEVNODE pdn, 
    DEVNODE dnChild, 
    ULONG ulFlags 
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_QUERY_ARBITRATOR_FREE_DATA)
(
    PVOID pData, 
    ULONG DataLen, 
    DEVNODE dnDevInst, 
    RESOURCEID ResourceID, 
    ULONG ulFlags
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_DELETE_RANGE)
(
    ULONG ulStartValue, 
    ULONG ulEndValue, 
    RANGE_LIST rlh, 
    ULONG ulFlags
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_FIRST_RANGE)
(
    RANGE_LIST rlh, 
    LPULONG pulStart, 
    LPULONG pulEnd, 
    PRANGE_ELEMENT preElement, 
    ULONG ulFlags
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_NEXT_RANGE)
(
    PRANGE_ELEMENT preElement, 
    LPULONG pulStart, 
    LPULONG pullEnd, 
    ULONG ulFlags
);

typedef DWORD (WINAPI* PFN_CIM32NET_CM_FREE_RANGE_LIST)
(
    RANGE_LIST rlh, 
    ULONG ulFlags
);

/******************************************************************************
 * Wrapper class for Cim32Net load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CCim32NetApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Cim32Net functions.
    // Add new functions here as required.
    PFN_CIM32NET_GET_WIN_9_X_BIOS_UNIT                   m_pfnGetWin9XBiosUnit;
    PFN_CIM32NET_GET_WIN_9_X_PARTITION_TABLE       m_pfnGetWin9XPartitionTable;
    PFN_CIM32NET_WIN_9_X_DRIVE_PARAMS                 m_pfnGetWin9XDriveParams;
    PFN_CIM32NET_GET_WIN_9_X_USE_INFO_1                  m_pfnGetWin9XUseInfo1;
    PFN_CIM32NET_GET_WIN_9_X_NET_USE_ENUM              m_pfnGetWin9XNetUseEnum;
    PFN_CIM32NET_GET_WIN_9_X_USER_INFO_1                m_pfnGetWin9XUserInfo1;
    PFN_CIM32NET_GET_WIN_9_X_USER_INFO_2                m_pfnGetWin9XUserInfo2;
    PFN_CIM32NET_GET_WIN_9_X_USER_INFO_1_EX           m_pfnGetWin9XUserInfo1Ex;
    PFN_CIM32NET_GET_WIN_9_X_USER_INFO_2_EX           m_pfnGetWin9XUserInfo2Ex;
    PFN_CIM32NET_GET_WIN_9_X_CONFIG_MANAGER_STATUS m_pfnGetWin9XConfigManagerStatus;
	PFN_CIM32NET_GET_WIN_9_X_FREE_SPACE				m_pfnGetWin9XFreeSpace ;
    PFN_CIM32NET_CM_LOCATE_DEVNODE             m_pfnCIM32THK_CM_Locate_DevNode;
    PFN_CIM32NET_CM_GET_CHILD                       m_pfnCIM32THK_CM_Get_Child;
    PFN_CIM32NET_CM_GET_SIBLING                   m_pfnCIM32THK_CM_Get_Sibling;
    PFN_CIM32NET_CM_READ_REGISTRY_VALUE   m_pfnCIM32THK_CM_Read_Registry_Value;
    PFN_CIM32NET_CM_GET_DEVNODE_STATUS     m_pfnCIM32THK_CM_Get_DevNode_Status;
    PFN_CIM32NET_CM_GET_DEVICE_ID               m_pfnCIM32THK_CM_Get_Device_ID;
    PFN_CIM32NET_CM_GET_DEVICE_ID_SIZE     m_pfnCIM32THK_CM_Get_Device_ID_Size;
    PFN_CIM32NET_CM_GET_FIRST_LOG_CONF     m_pfnCIM32THK_CM_Get_First_Log_Conf;
    PFN_CIM32NET_CM_GET_NEXT_RES_DES         m_pfnCIM32THK_CM_Get_Next_Res_Des;
    PFN_CIM32NET_CM_GET_RES_DES_DATA_SIZE m_pfnCIM32THK_CM_Get_Res_Des_Data_Size;
    PFN_CIM32NET_CM_GET_RES_DES_DATA         m_pfnCIM32THK_CM_Get_Res_Des_Data;
    PFN_CIM32NET_CM_GET_BUS_INFO                 m_pfnCIM32THK_CM_Get_Bus_Info;
    PFN_CIM32NET_CM_GET_PARENT                     m_pfnCIM32THK_CM_Get_Parent;
    PFN_CIM32NET_CM_QUERY_ARBITRATOR_FREE_DATA   m_pfnCIM32THK_CM_Query_Arbitrator_Free_Data;
    PFN_CIM32NET_CM_DELETE_RANGE                 m_pfnCIM32THK_CM_Delete_Range;
    PFN_CIM32NET_CM_FIRST_RANGE                   m_pfnCIM32THK_CM_First_Range;
    PFN_CIM32NET_CM_NEXT_RANGE                     m_pfnCIM32THK_CM_Next_Range;
    PFN_CIM32NET_CM_FREE_RANGE_LIST           m_pfnCIM32THK_CM_Free_Range_List;


    


public:

    // Constructor and destructor:
    CCim32NetApi(LPCTSTR a_tstrWrappedDllName);
    ~CCim32NetApi();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping Cim32Net functions.
    // Add new functions here as required:
    WORD GetWin9XBiosUnit
    (
        LPSTR a_lpDeviceID
    );

    BYTE GetWin9XPartitionTable 
    (
        BYTE a_cDrive, 
        pMasterBootSector a_pMBR
    );

    BYTE GetWin9XDriveParams 
    (
        BYTE a_cDrive, 
        pInt13DriveParams a_pParams
    );

    ULONG GetWin9XUseInfo1
    (
        LPSTR Name, 
        LPSTR Local, 
        LPSTR Remote, 
        LPSTR Password, 
        LPULONG pdwStatus,
        LPULONG pdwType,
        LPULONG pdwRefCount,
        LPULONG pdwUseCount
    );

    ULONG GetWin9XNetUseEnum(
        LPCSTR pszServer,
        short sLevel,
        LPSTR pbBuffer,
        use_info_1Out *pBuffer2,
        unsigned short cbBuffer,
        unsigned short far *pcEntriesRead,
        unsigned short far *pcTotalAvail
    );

    ULONG GetWin9XUserInfo1
    (
        LPSTR Name,	
        LPSTR HomeDirectory, 
        LPSTR Comment, 
        LPSTR ScriptPath, 
        LPULONG PasswordAge, 
        LPUSHORT Privileges, 
        LPUSHORT Flags 
    );

    ULONG GetWin9XUserInfo2
    (
        LPSTR Name, 
        LPSTR FullName,
        LPSTR UserComment, 
        LPSTR Parameters, 
        LPSTR Workstations, 
        LPSTR LogonServer, 
        LPLOGONDETAILS LogonDetails 
    );

    ULONG GetWin9XUserInfo1Ex
    (
        LPSTR DomainName,
        LPSTR Name,
        DWORD fGetDC,	
        LPSTR HomeDirectory, 
        LPSTR Comment, 
        LPSTR ScriptPath, 
        LPULONG PasswordAge, 
        LPUSHORT Privileges, 
        LPUSHORT Flags 
    );

    ULONG GetWin9XUserInfo2Ex
    (
        LPSTR DomainName,
        LPSTR Name, 
        DWORD fGetDC,
        LPSTR FullName,
        LPSTR UserComment, 
        LPSTR Parameters, 
        LPSTR Workstations, 
        LPSTR LogonServer, 
        LPLOGONDETAILS LogonDetails 
    );

    ULONG GetWin9XConfigManagerStatus
    (
        LPSTR a_HardwareKey
    );

    DWORD CCim32NetApi::GetWin9XGetFreeSpace
	(
		DWORD dwOption
	);

    DWORD CIM32THK_CM_Locate_DevNode 
    ( 
        PDEVNODE pdn, 
        LPSTR HardwareKey, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_Child 
    (
        PDEVNODE pdn, 
        DEVNODE dnParent, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_Sibling 
    ( 
        PDEVNODE pdn, 
        DEVNODE dnParent, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Read_Registry_Value 
    ( 
        DEVNODE dnDevNode, 
        LPSTR pszSubKey, LPCSTR pszValueName, 
        ULONG ulExpectedType, 
        LPVOID Buffer, 
        LPULONG pulLength, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_DevNode_Status 
    ( 
        LPULONG pulStatus, 
        LPULONG pulProblemNumber, 
        DEVNODE dnDevNode, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_Device_ID 
    ( 
        DEVNODE dnDevNode, 
        LPVOID Buffer, 
        ULONG BufferLen, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_Device_ID_Size 
    ( 
        LPULONG pulLen, 
        DEVNODE dnDevNode, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_First_Log_Conf 
    ( 
        PLOG_CONF plcLogConf, 
        DEVNODE dnDevNode, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_Next_Res_Des 
    ( 
        PRES_DES prdResDes, 
        RES_DES rdResDes, 
        RESOURCEID ForResource, 
        PRESOURCEID pResourceID, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_Res_Des_Data_Size 
    ( 
        LPULONG pulSize, 
        RES_DES rdResDes, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_Res_Des_Data 
    ( 
        RES_DES rdResDes, 
        LPVOID Buffer, 
        ULONG BufferLen, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Get_Bus_Info 
    (
        DEVNODE dnDevNode, 
        PCMBUSTYPE pbtBusType, 
        LPULONG pulSizeOfInfo, 
        LPVOID pInfo, 
        ULONG ulFlags
    );

    DWORD CIM32THK_CM_Get_Parent 
    ( 
        PDEVNODE pdn, 
        DEVNODE dnChild, 
        ULONG ulFlags 
    );

    DWORD CIM32THK_CM_Query_Arbitrator_Free_Data
    (
        PVOID pData, 
        ULONG DataLen, 
        DEVNODE dnDevInst, 
        RESOURCEID ResourceID, 
        ULONG ulFlags
    );
    
    DWORD CIM32THK_CM_Delete_Range
    (
        ULONG ulStartValue, 
        ULONG ulEndValue, 
        RANGE_LIST rlh, 
        ULONG ulFlags
    );
    
    DWORD CIM32THK_CM_First_Range
    (
        RANGE_LIST rlh, 
        LPULONG pulStart, 
        LPULONG pulEnd, 
        PRANGE_ELEMENT preElement, 
        ULONG ulFlags
    );
    
    DWORD CIM32THK_CM_Next_Range
    (
        PRANGE_ELEMENT preElement, 
        LPULONG pulStart, 
        LPULONG pullEnd, 
        ULONG ulFlags
    );
    
    DWORD CIM32THK_CM_Free_Range_List
    (
        RANGE_LIST rlh, 
        ULONG ulFlags
    );



};

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cim32netapi.cpp ===
//=================================================================

//

// Cim32NetAPI.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#include "precomp.h"
#ifdef WIN9XONLY
#include <assertbreak.h>
#include "refptr.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "cfgmgrdevice.h"
#include "irqdesc.h"
#include <cominit.h>
#include "DllWrapperCreatorReg.h"



// {318C0D32-D27D-11d2-9120-0060081A46FD}
static const GUID g_guidCim32NetApi =
{0x318c0d32, 0xd27d, 0x11d2, {0x91, 0x20, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};


static const TCHAR g_tstrCim32Net[] = _T("CIM32NET.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CCim32NetApi, &g_guidCim32NetApi, g_tstrCim32Net> MyRegisteredCim32NetWrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CCim32NetApi::CCim32NetApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnGetWin9XBiosUnit(NULL),
   m_pfnGetWin9XPartitionTable(NULL),
   m_pfnGetWin9XDriveParams(NULL),
   m_pfnGetWin9XUseInfo1(NULL),
   m_pfnGetWin9XNetUseEnum(NULL),
   m_pfnGetWin9XUserInfo1(NULL),
   m_pfnGetWin9XUserInfo2(NULL),
   m_pfnGetWin9XUserInfo1Ex(NULL),
   m_pfnGetWin9XUserInfo2Ex(NULL),
   m_pfnGetWin9XConfigManagerStatus(NULL),
   m_pfnGetWin9XFreeSpace(NULL),
   m_pfnCIM32THK_CM_Locate_DevNode(NULL),
   m_pfnCIM32THK_CM_Get_Child(NULL),
   m_pfnCIM32THK_CM_Get_Sibling(NULL),
   m_pfnCIM32THK_CM_Read_Registry_Value(NULL),
   m_pfnCIM32THK_CM_Get_DevNode_Status(NULL),
   m_pfnCIM32THK_CM_Get_Device_ID(NULL),
   m_pfnCIM32THK_CM_Get_Device_ID_Size(NULL),
   m_pfnCIM32THK_CM_Get_First_Log_Conf(NULL),
   m_pfnCIM32THK_CM_Get_Next_Res_Des(NULL),
   m_pfnCIM32THK_CM_Get_Res_Des_Data_Size(NULL),
   m_pfnCIM32THK_CM_Get_Res_Des_Data(NULL),
   m_pfnCIM32THK_CM_Get_Bus_Info(NULL),
   m_pfnCIM32THK_CM_Get_Parent(NULL),
   m_pfnCIM32THK_CM_Query_Arbitrator_Free_Data(NULL),
   m_pfnCIM32THK_CM_Delete_Range(NULL),
   m_pfnCIM32THK_CM_First_Range(NULL),
   m_pfnCIM32THK_CM_Next_Range(NULL),
   m_pfnCIM32THK_CM_Free_Range_List(NULL)
{
}


/******************************************************************************
 * Destructor
 *****************************************************************************/
CCim32NetApi::~CCim32NetApi()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 *****************************************************************************/
bool CCim32NetApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnGetWin9XBiosUnit = (PFN_CIM32NET_GET_WIN_9_X_BIOS_UNIT)
                                            GetProcAddress("GetWin9XBiosUnit");

        m_pfnGetWin9XPartitionTable = (PFN_CIM32NET_GET_WIN_9_X_PARTITION_TABLE)
                                            GetProcAddress("GetWin9XPartitionTable");

        m_pfnGetWin9XDriveParams = (PFN_CIM32NET_WIN_9_X_DRIVE_PARAMS)
                                            GetProcAddress("GetWin9XDriveParams");

        m_pfnGetWin9XUseInfo1 = (PFN_CIM32NET_GET_WIN_9_X_USE_INFO_1)
                                            GetProcAddress("GetWin9XUseInfo1");

        m_pfnGetWin9XNetUseEnum = (PFN_CIM32NET_GET_WIN_9_X_NET_USE_ENUM)
                                            GetProcAddress("GetWin9XNetUseEnum");

        m_pfnGetWin9XUserInfo1 = (PFN_CIM32NET_GET_WIN_9_X_USER_INFO_1)
                                            GetProcAddress("GetWin9XUserInfo1");

        m_pfnGetWin9XUserInfo2 = (PFN_CIM32NET_GET_WIN_9_X_USER_INFO_2)
                                            GetProcAddress("GetWin9XUserInfo2");

        m_pfnGetWin9XUserInfo1Ex = (PFN_CIM32NET_GET_WIN_9_X_USER_INFO_1_EX)
                                            GetProcAddress("GetWin9XUserInfo1Ex");

        m_pfnGetWin9XUserInfo2Ex = (PFN_CIM32NET_GET_WIN_9_X_USER_INFO_2_EX)
                                            GetProcAddress("GetWin9XUserInfo2Ex");

        m_pfnGetWin9XConfigManagerStatus = (PFN_CIM32NET_GET_WIN_9_X_CONFIG_MANAGER_STATUS)
                                            GetProcAddress("GetWin9XConfigManagerStatus");

		m_pfnGetWin9XFreeSpace	= (PFN_CIM32NET_GET_WIN_9_X_FREE_SPACE)
											GetProcAddress("GetWin9XFreeSpace");

        m_pfnCIM32THK_CM_Locate_DevNode = (PFN_CIM32NET_CM_LOCATE_DEVNODE)
                                            GetProcAddress( "CIM32THK_CM_Locate_DevNode" );

        m_pfnCIM32THK_CM_Get_Child = (PFN_CIM32NET_CM_GET_CHILD)
                            				GetProcAddress("CIM32THK_CM_Get_Child" );

        m_pfnCIM32THK_CM_Get_Sibling = (PFN_CIM32NET_CM_GET_SIBLING)
                                            GetProcAddress("CIM32THK_CM_Get_Sibling" );

        m_pfnCIM32THK_CM_Read_Registry_Value = (PFN_CIM32NET_CM_READ_REGISTRY_VALUE)
                                            GetProcAddress("CIM32THK_CM_Read_Registry_Value" );

        m_pfnCIM32THK_CM_Get_DevNode_Status	= (PFN_CIM32NET_CM_GET_DEVNODE_STATUS)
                                            GetProcAddress("CIM32THK_CM_Get_DevNode_Status" );

        m_pfnCIM32THK_CM_Get_Device_ID = (PFN_CIM32NET_CM_GET_DEVICE_ID)
                                            GetProcAddress("CIM32THK_CM_Get_Device_ID" );

        m_pfnCIM32THK_CM_Get_Device_ID_Size	= (PFN_CIM32NET_CM_GET_DEVICE_ID_SIZE)
                                            GetProcAddress("CIM32THK_CM_Get_Device_ID_Size" );

        m_pfnCIM32THK_CM_Get_First_Log_Conf	= (PFN_CIM32NET_CM_GET_FIRST_LOG_CONF)
                                            GetProcAddress("CIM32THK_CM_Get_First_Log_Conf" );

        m_pfnCIM32THK_CM_Get_Next_Res_Des =	(PFN_CIM32NET_CM_GET_NEXT_RES_DES)
                                            GetProcAddress("CIM32THK_CM_Get_Next_Res_Des" );

        m_pfnCIM32THK_CM_Get_Res_Des_Data_Size = (PFN_CIM32NET_CM_GET_RES_DES_DATA_SIZE)
                                            GetProcAddress("CIM32THK_CM_Get_Res_Des_Data_Size" );

        m_pfnCIM32THK_CM_Get_Res_Des_Data = (PFN_CIM32NET_CM_GET_RES_DES_DATA)
                                            GetProcAddress("CIM32THK_CM_Get_Res_Des_Data" );

        m_pfnCIM32THK_CM_Get_Bus_Info = (PFN_CIM32NET_CM_GET_BUS_INFO)
                                            GetProcAddress("CIM32THK_CM_Get_Bus_Info" );

        m_pfnCIM32THK_CM_Get_Parent = (PFN_CIM32NET_CM_GET_PARENT)
                                            GetProcAddress("CIM32THK_CM_Get_Parent" );

        m_pfnCIM32THK_CM_Query_Arbitrator_Free_Data = (PFN_CIM32NET_CM_QUERY_ARBITRATOR_FREE_DATA)
                                            GetProcAddress("CIM32THK_CM_Query_Arbitrator_Free_Data" );

        m_pfnCIM32THK_CM_Delete_Range = (PFN_CIM32NET_CM_DELETE_RANGE)
                                            GetProcAddress("CIM32THK_CM_Delete_Range" );

        m_pfnCIM32THK_CM_First_Range = (PFN_CIM32NET_CM_FIRST_RANGE)
                                            GetProcAddress("CIM32THK_CM_First_Range" );

        m_pfnCIM32THK_CM_Next_Range = (PFN_CIM32NET_CM_NEXT_RANGE)
                                            GetProcAddress("CIM32THK_CM_Next_Range" );

        m_pfnCIM32THK_CM_Free_Range_List = (PFN_CIM32NET_CM_FREE_RANGE_LIST)
                                            GetProcAddress("CIM32THK_CM_Free_Range_List" );


        // Check that we have function pointers to functions that should be
        // present in all versions of this dll...
        if(m_pfnGetWin9XBiosUnit == NULL ||
           m_pfnGetWin9XPartitionTable == NULL ||
           m_pfnGetWin9XDriveParams == NULL ||
           m_pfnGetWin9XUseInfo1 == NULL ||
           m_pfnGetWin9XNetUseEnum == NULL ||
           m_pfnGetWin9XUserInfo1 == NULL ||
           m_pfnGetWin9XUserInfo2 == NULL ||
           m_pfnGetWin9XUserInfo1Ex == NULL ||
           m_pfnGetWin9XUserInfo2Ex == NULL ||
           m_pfnGetWin9XConfigManagerStatus == NULL ||
		   m_pfnGetWin9XFreeSpace == NULL ||
           m_pfnCIM32THK_CM_Locate_DevNode == NULL ||
           m_pfnCIM32THK_CM_Get_Child == NULL ||
           m_pfnCIM32THK_CM_Get_Sibling == NULL ||
           m_pfnCIM32THK_CM_Read_Registry_Value == NULL ||
           m_pfnCIM32THK_CM_Get_DevNode_Status == NULL ||
           m_pfnCIM32THK_CM_Get_Device_ID == NULL ||
           m_pfnCIM32THK_CM_Get_Device_ID_Size == NULL ||
           m_pfnCIM32THK_CM_Get_First_Log_Conf == NULL ||
           m_pfnCIM32THK_CM_Get_Next_Res_Des == NULL ||
           m_pfnCIM32THK_CM_Get_Res_Des_Data_Size == NULL ||
           m_pfnCIM32THK_CM_Get_Res_Des_Data == NULL ||
           m_pfnCIM32THK_CM_Get_Bus_Info == NULL ||
           m_pfnCIM32THK_CM_Get_Parent == NULL)
        {
            fRet = false;
        }
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping Cim32Net api functions. Add new functions here
 * as required.
 *****************************************************************************/
WORD CCim32NetApi::GetWin9XBiosUnit
(
    LPSTR a_lpDeviceID
)
{
    return m_pfnGetWin9XBiosUnit(a_lpDeviceID);
}

BYTE CCim32NetApi::GetWin9XPartitionTable
(
    BYTE a_cDrive,
    pMasterBootSector a_pMBR
)
{
    return m_pfnGetWin9XPartitionTable(a_cDrive, a_pMBR);
}

BYTE CCim32NetApi::GetWin9XDriveParams
(
    BYTE a_cDrive,
    pInt13DriveParams a_pParams
)
{
    return m_pfnGetWin9XDriveParams(a_cDrive, a_pParams);
}

ULONG CCim32NetApi::GetWin9XUseInfo1
(
    LPSTR Name,
    LPSTR Local,
    LPSTR Remote,
    LPSTR Password,
    LPULONG pdwStatus,
    LPULONG pdwType,
    LPULONG pdwRefCount,
    LPULONG pdwUseCount
)
{
    return m_pfnGetWin9XUseInfo1(Name,
                                 Local,
                                 Remote,
                                 Password,
                                 pdwStatus,
                                 pdwType,
                                 pdwRefCount,
                                 pdwUseCount
                                 );
}


// pbBuffer is used internally as a work buffer.  It should be allocated and
// freed by the caller, and should be the same length as pBuffer2, which
// is a pointer to an array of use_info_1Out structures.
ULONG CCim32NetApi::GetWin9XNetUseEnum(
    LPCSTR pszServer,
    short sLevel,
    LPSTR pbBuffer,
    use_info_1Out *pBuffer2,
    unsigned short cbBuffer,
    unsigned short far *pcEntriesRead,
    unsigned short far *pcTotalAvail
)
{
    return m_pfnGetWin9XNetUseEnum(
        pszServer,
        sLevel,
        pbBuffer,
        pBuffer2,
        cbBuffer,
        pcEntriesRead,
        pcTotalAvail);
}

ULONG CCim32NetApi::GetWin9XUserInfo1
(
    LPSTR Name,
    LPSTR HomeDirectory,
    LPSTR Comment,
    LPSTR ScriptPath,
    LPULONG PasswordAge,
    LPUSHORT Privileges,
    LPUSHORT Flags
)
{
    return m_pfnGetWin9XUserInfo1(Name,
                                  HomeDirectory,
                                  Comment,
                                  ScriptPath,
                                  PasswordAge,
                                  Privileges,
                                  Flags);
}

ULONG CCim32NetApi::GetWin9XUserInfo2
(
    LPSTR Name,
    LPSTR FullName,
    LPSTR UserComment,
    LPSTR Parameters,
    LPSTR Workstations,
    LPSTR LogonServer,
    LPLOGONDETAILS LogonDetails
)
{
    return m_pfnGetWin9XUserInfo2(Name,
                                  FullName,
                                  UserComment,
                                  Parameters,
                                  Workstations,
                                  LogonServer,
                                  LogonDetails);
}

ULONG CCim32NetApi::GetWin9XUserInfo1Ex
(
    LPSTR DomainName,
    LPSTR Name,
    DWORD fGetDC,
    LPSTR HomeDirectory,
    LPSTR Comment,
    LPSTR ScriptPath,
    LPULONG PasswordAge,
    LPUSHORT Privileges,
    LPUSHORT Flags
)
{
    return m_pfnGetWin9XUserInfo1Ex(DomainName,
                                  Name,
                                  fGetDC,
                                  HomeDirectory,
                                  Comment,
                                  ScriptPath,
                                  PasswordAge,
                                  Privileges,
                                  Flags);
}

ULONG CCim32NetApi::GetWin9XUserInfo2Ex
(
    LPSTR DomainName,
    LPSTR Name,
    DWORD fGetDC,
    LPSTR FullName,
    LPSTR UserComment,
    LPSTR Parameters,
    LPSTR Workstations,
    LPSTR LogonServer,
    LPLOGONDETAILS LogonDetails
)
{
    return m_pfnGetWin9XUserInfo2Ex(DomainName,
                                  Name,
                                  fGetDC,
                                  FullName,
                                  UserComment,
                                  Parameters,
                                  Workstations,
                                  LogonServer,
                                  LogonDetails);
}


ULONG CCim32NetApi::GetWin9XConfigManagerStatus
(
    LPSTR a_HardwareKey
)
{
    return m_pfnGetWin9XConfigManagerStatus(a_HardwareKey);
}

DWORD CCim32NetApi::GetWin9XGetFreeSpace
(
	DWORD dwOption
)
{
	return m_pfnGetWin9XFreeSpace ( dwOption ) ;
}

DWORD CCim32NetApi::CIM32THK_CM_Locate_DevNode
(
    PDEVNODE pdn,
    LPSTR HardwareKey,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Locate_DevNode(pdn,
                                           HardwareKey,
                                           ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Get_Child
(
    PDEVNODE pdn,
    DEVNODE dnParent,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_Child(pdn,
                                      dnParent,
                                      ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Get_Sibling
(
    PDEVNODE pdn,
    DEVNODE dnParent,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_Sibling(pdn,
                                        dnParent,
                                        ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Read_Registry_Value
(
    DEVNODE dnDevNode,
    LPSTR pszSubKey,
    LPCSTR pszValueName,
    ULONG ulExpectedType,
    LPVOID Buffer,
    LPULONG pulLength,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Read_Registry_Value(dnDevNode,
                                                pszSubKey,
                                                pszValueName,
                                                ulExpectedType,
                                                Buffer,
                                                pulLength,
                                                ulFlags );
}

DWORD CCim32NetApi::CIM32THK_CM_Get_DevNode_Status
(
    LPULONG pulStatus,
    LPULONG pulProblemNumber,
    DEVNODE dnDevNode,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_DevNode_Status(pulStatus,
                                               pulProblemNumber,
                                               dnDevNode,
                                               ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Get_Device_ID
(
    DEVNODE dnDevNode,
    LPVOID Buffer,
    ULONG BufferLen,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_Device_ID(dnDevNode,
                                          Buffer,
                                          BufferLen,
                                          ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Get_Device_ID_Size
(
    LPULONG pulLen,
    DEVNODE dnDevNode,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_Device_ID_Size(pulLen,
                                               dnDevNode,
                                               ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Get_First_Log_Conf
(
    PLOG_CONF plcLogConf,
    DEVNODE dnDevNode,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_First_Log_Conf(plcLogConf,
                                               dnDevNode,
                                               ulFlags );
}

DWORD CCim32NetApi::CIM32THK_CM_Get_Next_Res_Des
(
    PRES_DES prdResDes,
    RES_DES rdResDes,
    RESOURCEID ForResource,
    PRESOURCEID pResourceID,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_Next_Res_Des(prdResDes,
                                             rdResDes,
                                             ForResource,
                                             pResourceID,
                                             ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Get_Res_Des_Data_Size
(
    LPULONG pulSize,
    RES_DES rdResDes,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_Res_Des_Data_Size(pulSize,
                                                  rdResDes,
                                                  ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Get_Res_Des_Data
(
    RES_DES rdResDes,
    LPVOID Buffer,
    ULONG BufferLen,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_Res_Des_Data(rdResDes,
                                             Buffer,
                                             BufferLen,
                                             ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Get_Bus_Info
(
    DEVNODE dnDevNode,
    PCMBUSTYPE pbtBusType,
    LPULONG pulSizeOfInfo,
    LPVOID pInfo,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_Bus_Info(dnDevNode,
                                         pbtBusType,
                                         pulSizeOfInfo,
                                         pInfo,
                                         ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Get_Parent
(
    PDEVNODE pdn,
    DEVNODE dnChild,
    ULONG ulFlags
)
{
    return m_pfnCIM32THK_CM_Get_Parent(pdn, dnChild, ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Query_Arbitrator_Free_Data
(
    PVOID pData,
    ULONG DataLen,
    DEVNODE dnDevInst,
    RESOURCEID ResourceID,
    ULONG ulFlags
)
{
    return
        m_pfnCIM32THK_CM_Query_Arbitrator_Free_Data(
            pData,
            DataLen,
            dnDevInst,
            ResourceID,
            ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Delete_Range
(
    ULONG ulStartValue,
    ULONG ulEndValue,
    RANGE_LIST rlh,
    ULONG ulFlags
)
{
    return
        m_pfnCIM32THK_CM_Delete_Range(
            ulStartValue,
            ulEndValue,
            rlh,
            ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_First_Range
(
    RANGE_LIST rlh,
    LPULONG pulStart,
    LPULONG pulEnd,
    PRANGE_ELEMENT preElement,
    ULONG ulFlags
)
{
    return
        m_pfnCIM32THK_CM_First_Range(
            rlh,
            pulStart,
            pulEnd,
            preElement,
            ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Next_Range
(
    PRANGE_ELEMENT preElement,
    LPULONG pulStart,
    LPULONG pullEnd,
    ULONG ulFlags
)
{
    return
        m_pfnCIM32THK_CM_Next_Range(
            preElement,
            pulStart,
            pullEnd,
            ulFlags);
}

DWORD CCim32NetApi::CIM32THK_CM_Free_Range_List
(
    RANGE_LIST rlh,
    ULONG ulFlags
)
{
    return
        m_pfnCIM32THK_CM_Free_Range_List(
            rlh,
            ulFlags);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\chwres.h ===
//=================================================================

//

// chwres.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================


#ifndef _RESOURCE_H_
#define _RESOURCE_H_

// Pseudo handle type definition.
#define HREGKEY     LPKEY

// Single value description within a key.
typedef struct _VALUE
{
   LPTSTR  Name;
   DWORD   Type;
}  VALUE, *LPVALUE;

// Macro to initialize a value description table entry.
//
//  v   - value name
//  t   - value type

#define MakeValue( v, t )                                              \
{                                                                      \
   #v,                                                                 \
   REG_##t                                                             \
}


// Single key description. Points to a table of value descriptions.
typedef struct _KEY
{
    HKEY    ParentHandle;
    LPTSTR  Name;
    DWORD   CountOfValues;
    LPVALUE Values;
    HKEY    hKey;
    LPBYTE  Data;
    DWORD   Size;
    LPTSTR  ValueName;
    DWORD   ValueNameLength;
    LPTSTR  Subkey;
    DWORD   SubkeyLength;
    DWORD   Subkeys;
    DWORD   Type;
    DWORD   CurrentSize;
    DWORD   CurrentValueNameLength;
    DWORD   CurrentValue;
    DWORD   CurrentSubkeyLength;
    DWORD   CurrentSubkey;
}   KEY, *LPKEY;

// Macro to initialize a subkey description.
//
//  k   - key variable name
//  h   - parent handle (HREGKEY)
//  n   - key name (path)

#define InitializeKey( k, h, n )                                            \
    {                                                                       \
        ( k )->ParentHandle             = h->hRegKey;                       \
        ( k )->Name                     = n;                                \
        ( k )->CountOfValues            = 0;                                \
        ( k )->Values                   = NULL;                             \
        ( k )->hKey                     = NULL;                             \
        ( k )->Data                     = NULL;                             \
        ( k )->Size                     = 0;                                \
        ( k )->ValueName                = NULL;                             \
        ( k )->ValueNameLength          = 0;                                \
        ( k )->Subkey                   = NULL;                             \
        ( k )->SubkeyLength             = 0;                                \
        ( k )->Subkeys                  = 0;                                \
        ( k )->Type                     = REG_NONE;                         \
        ( k )->CurrentSize              = 0;                                \
        ( k )->CurrentValueNameLength   = 0;                                \
        ( k )->CurrentValue             = 0;                                \
        ( k )->CurrentSubkeyLength      = 0;                                \
        ( k )->CurrentSubkey            = 0;                                \
    }

// Macro to statically initialize a key description.
//
//  k   - key variable name
//  h   - parent handle
//  n   - key name (path)
//  v   - count of values in table
//  t   - pointer to values table
//

#define MakeKey( k, h, n, v, t )                                            \
    KEY                                                                     \
    k = {                                                                 \
          h,                                                                  \
          n,                                                                  \
          v,                                                                  \
          t,                                                                  \
          NULL,                                                               \
          NULL,                                                               \
          0,                                                                  \
          NULL,                                                               \
          0,                                                                  \
          NULL,                                                               \
          0,                                                                  \
          0,                                                                  \
          REG_NONE,                                                           \
          0,                                                                  \
          0,                                                                  \
          0,                                                                  \
          0,                                                                  \
          0                                                                   \
        }


class ClRegistry {
public:
   BOOL CloseRegistryKey(HREGKEY Handle);
   BOOL QueryNextValue(HREGKEY Handle);
   HREGKEY OpenRegistryKey(LPKEY Key);
   HREGKEY QueryNextSubkey(HREGKEY Handle);
};

typedef LARGE_INTEGER PHYSICAL_ADDRESS;

// ntconfig.h defines this as an int
#ifndef _NTCONFIG_
typedef enum _CM_RESOURCE_TYPE {
    CmResourceTypeNull = 0,    // Reserved
    CmResourceTypePort,
    CmResourceTypeInterrupt,
    CmResourceTypeMemory,
    CmResourceTypeDma,
    CmResourceTypeDeviceSpecific
} CM_RESOURCE_TYPE;

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

#endif
//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY 0x0000
#define CM_RESOURCE_PORT_IO 0x0001

#ifndef _NTCONFIG_
typedef enum Interface_Type {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE;
#endif


#define REG_RESOURCE_LIST            ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description


// ntconfig.h defines this
#ifndef _NTCONFIG_
#pragma pack(4)
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        //

        struct {
            ULONG Level;
            ULONG Vector;
            ULONG Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;


#pragma pack()
#endif

//
// The device data record for the Keyboard peripheral.
// The KeyboardFlags is defined (by x86 BIOS INT 16h, function 02) as:
//      bit 7 : Insert on
//      bit 6 : Caps Lock on
//      bit 5 : Num Lock on
//      bit 4 : Scroll Lock on
//      bit 3 : Alt Key is down
//      bit 2 : Ctrl Key is down
//      bit 1 : Left shift key is down
//      bit 0 : Right shift key is down
//

// ntconfig.h defines this
#ifndef _NTCONFIG_
typedef struct _CM_KEYBOARD_DEVICE_DATA {
    USHORT Version;
    USHORT Revision;
    UCHAR Type;
    UCHAR Subtype;
    USHORT KeyboardFlags;
} CM_KEYBOARD_DEVICE_DATA, *PCM_KEYBOARD_DEVICE_DATA;
#endif

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

// ntconfig.h defines this
#ifndef _NTCONFIG_
typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;
#endif

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// Note2: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

// ntconfig.h defines this
#ifndef _NTCONFIG_
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;
#endif

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

// ntconfig.h defines this as an int
#ifndef _NTCONFIG_
typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;
#endif

typedef struct _RESOURCE_DESCRIPTOR *LPRESOURCE_DESCRIPTOR;
typedef struct _DEVICE              *LPDEVICE;


typedef struct _RESOURCE_DESCRIPTOR 
{
  CM_PARTIAL_RESOURCE_DESCRIPTOR  CmResourceDescriptor;
  LPRESOURCE_DESCRIPTOR           NextSame;
  LPRESOURCE_DESCRIPTOR           NextDiff;
  LPDEVICE                        Owner;
  ULONG                           Bus;
  INTERFACE_TYPE                  InterfaceType;
} RESOURCE_DESCRIPTOR;

typedef struct _DEVICE 
{
   LPTSTR                          Name;
   LPRESOURCE_DESCRIPTOR           ResourceDescriptorHead;
   LPRESOURCE_DESCRIPTOR           ResourceDescriptorTail;
   LPDEVICE                        Next;
   LPTSTR                          KeyName;
} DEVICE;
                                    
typedef struct _SYSTEM_RESOURCES 
{                 
    LPDEVICE                        DeviceHead;
    LPDEVICE                        DeviceTail;
    LPRESOURCE_DESCRIPTOR           DmaHead;
    LPRESOURCE_DESCRIPTOR           DmaTail;
    LPRESOURCE_DESCRIPTOR           InterruptHead;
    LPRESOURCE_DESCRIPTOR           InterruptTail;
    LPRESOURCE_DESCRIPTOR           MemoryHead;
    LPRESOURCE_DESCRIPTOR           MemoryTail;
    LPRESOURCE_DESCRIPTOR           PortHead;
    LPRESOURCE_DESCRIPTOR           PortTail;
}   SYSTEM_RESOURCES, *LPSYSTEM_RESOURCES;

// Helper function for converting interface_type values to strings
BOOL WINAPI StringFromInterfaceType( INTERFACE_TYPE it, CHString& strVal );

#ifdef NTONLY
class CHWResource {

    public :

        CHWResource() ;
       ~CHWResource() ;

        void CreateSystemResourceLists(void);
        void DestroySystemResourceLists();

        SYSTEM_RESOURCES _SystemResourceList ;

    private :

        void EnumerateResources(CHString sKeyName);
        void CreateResourceList(CHString sDeviceName,
                                DWORD dwResourceCount,
                                PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, CHString sKeyName);
        void CreateResourceRecord(LPDEVICE pDevice, INTERFACE_TYPE Interface, ULONG Bus,
                                  PCM_PARTIAL_RESOURCE_DESCRIPTOR pResource);


} ;

#endif

#endif // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ckernel.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CKernal.h -- Wraper for Kernal functions

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================



#ifndef __CKERNEL_H__
#define __CKERNEL_H__

#include "CGlobal.h"
#include "CWaitableObject.h"

class CKernel : public CWaitableObject 
{
protected:
    HANDLE m_hHandle;
    DWORD m_dwStatus;

protected:
    // constructor...
    CKernel();

    // error handling...
    void ThrowError(DWORD dwStatus);

public:
    // destructor is virtual to make CKernel an abstract base class...
    virtual ~CKernel() = 0;

    // read the creation status of the internal kernel object...
    DWORD Status() const;

    // wait on the current kernel object...
    DWORD Wait(DWORD dwMilliseconds);

    // wait on the current object and one other...
    DWORD WaitForTwo(CWaitableObject &rCWaitableObject, 
                     BOOL bWaitAll, 
                     DWORD dwMilliseconds);

    // get the internal handle...
    HANDLE GetHandle() const;

    // another way to get the internal handle...
    operator HANDLE() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cglobal.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CGlobal.h -- Global declarations

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================


#ifndef __CGLOBAL_H__
#define __CGLOBAL_H__


#include <windows.h>
#include <process.h>
#include <winerror.h>
#include <stdio.h>
#include <brodcast.h>
#include <dllutils.h>

#define ERR_LOG_FILE _T("c:\\temp\\test.txt")

// forward class declarations to make the compiler happy...
class CWaitableObject;
class CWaitableCollection;
class CKernel;
class CMutex;
class CSemaphore;
class CEvent;
class CThread;
class CCriticalSec;
class CAutoLock;
class CMonitor;
class CSharedMemory;
class CMailbox;

// defined symbol determines if CThrowError throws exceptions
// or just prints debug error messages...
#ifndef __C_THROW_EXCEPTIONS__
#define __C_THROW_EXCEPTIONS__   TRUE
#endif

// for higher level objects which might have to check internal
// object status when exceptions are disabled, these macros can be useful...

// PTR is the smart pointer to check for NULL, 
// STATUS is the variable in which to store an error code if an error is detected...
#if __C_THROW_EXCEPTIONS__
#define C_CHECK_AUTOPTR_OBJECT(PTR,STATUS) if ((PTR).IsNull()) { /*CThrowError(ERROR_OUTOFMEMORY);*/ LogMessage2(L"CAutoLock Error: %d", ERROR_OUTOFMEMORY); }
#else
#define C_CHECK_AUTOPTR_OBJECT(PTR,STATUS) if ((PTR).IsNull()) { (STATUS) = ERROR_OUTOFMEMORY; return; }
#endif

// SCODE is the return value to check,
// STATUS is the variable in which to store an error code if an error is detected...
#if __C_THROW_EXCEPTIONS__
#define C_CHECK_CREATION_STATUS(SCODE,STATUS) {}
#else
#define C_CHECK_CREATION_STATUS(SCODE,STATUS) if (((SCODE)!=NO_ERROR)&&((SCODE)!=ERROR_ALREADY_EXISTS)) { STATUS = (SCODE); return; }
#endif

//// error handling macro and function...
//#define CThrowError(dwStatus) CInternalThrowError((dwStatus), __FILE__, __LINE__)
//extern void CInternalThrowError( DWORD dwStatus, LPCWSTR lpFilename, int line);

// check handle for NULL and INVALID_HANDLE
inline BOOL CIsValidHandle( HANDLE hHandle) {
    return ((hHandle != NULL) && (hHandle != INVALID_HANDLE_VALUE));
}

// validate wait return codes...
inline BOOL CWaitSucceeded( DWORD dwWaitResult, DWORD dwHandleCount) {
    return (dwWaitResult < WAIT_OBJECT_0 + dwHandleCount);
}

inline BOOL CWaitAbandoned( DWORD dwWaitResult, DWORD dwHandleCount) {
    return ((dwWaitResult >= WAIT_ABANDONED_0) &&
            (dwWaitResult < WAIT_ABANDONED_0 + dwHandleCount));
}

inline BOOL CWaitTimeout( DWORD dwWaitResult) {
    return (dwWaitResult == WAIT_TIMEOUT);
}
    
inline BOOL CWaitFailed( DWORD dwWaitResult) {
    return (dwWaitResult == WAIT_FAILED);
}

// compute object indices for waits...
inline DWORD CWaitSucceededIndex( DWORD dwWaitResult) {
    return (dwWaitResult - WAIT_OBJECT_0);
}

inline DWORD CWaitAbandonedIndex( DWORD dwWaitResult) {
    return (dwWaitResult - WAIT_ABANDONED_0);
}

// Log messages
inline DWORD LogMsg(LPCTSTR szMsg, LPCTSTR szFileName = ERR_LOG_FILE)
{
    //HANDLE hFile = NULL;
    //DWORD dwBytesWritten = 0L;                   
    //DWORD dwTotBytesWritten = 0L;
    //hFile = CreateFile(szFileName, 
    //                   GENERIC_WRITE, 
    //                   FILE_SHARE_WRITE, 
    //                   NULL, 
    //                   OPEN_ALWAYS, 
    //                   FILE_ATTRIBUTE_NORMAL, 
    //                   NULL);
    //
    //WriteFile(hFile, szMsg, strlen(szMsg), &dwBytesWritten, NULL);
    //const char* szEndLine = "\r\n";
    //dwTotBytesWritten += dwBytesWritten;
    //WriteFile(hFile, szEndLine, strlen(szEndLine), &dwBytesWritten, NULL); 
    //dwTotBytesWritten += dwBytesWritten;
    //CloseHandle(hFile);
    //return dwTotBytesWritten;
    
    // Flavor 2
    SYSTEMTIME systime;
    GetSystemTime(&systime);
    //FILE* fp = NULL;
    //if((fp = _tfopen(szFileName,_T("a+"))) != NULL)
    {
        TCHAR szTime[64];
        ZeroMemory(szTime,sizeof(szTime));
        wsprintf(szTime,_T("(%02d:%02d:%02d.%04d) "),systime.wHour,systime.wMinute,systime.wSecond,systime.wMilliseconds);
        //fputws(szTime,fp);
        //fputws(szMsg,fp);
        //fputws(_T("\r\n"),fp);
        LogMessage3((LPCWSTR)TOBSTRT("%s%s"), TOBSTRT(szTime), TOBSTRT(szMsg));
    }
    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ckernel.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CKernal.cpp -- Wraper for Kernal functions

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================
#include "precomp.h"
#include "CKernel.h"

CKernel::CKernel()
{
    m_hHandle = NULL;
    m_dwStatus = ERROR_INVALID_HANDLE;
}

CKernel::~CKernel()
{
    if (CIsValidHandle(m_hHandle))
    {
        ::CloseHandle(m_hHandle);
        m_hHandle = NULL;
    }
}

void CKernel::ThrowError(DWORD dwStatus)
{
    //CThrowError(dwStatus);
    LogMessage2(L"CKernel Error: %d", dwStatus);
}

DWORD CKernel::Status() const
{
    return m_dwStatus;
}

DWORD CKernel::Wait(DWORD dwMilliseconds)
{
    return ::WaitForSingleObject(m_hHandle, dwMilliseconds);
}

// wait on the current object and one other...
DWORD CKernel::WaitForTwo(CWaitableObject &rCWaitableObject,
                          BOOL bWaitAll,
                          DWORD dwMilliseconds)
{
    HANDLE handles[2];

    // the current object...
    handles[0] = m_hHandle;

    // the parameter object...
    handles[1] = rCWaitableObject.GetHandle();

    // wait for the objects...
    return ::WaitForMultipleObjects(2, handles, bWaitAll, dwMilliseconds);
}

HANDLE CKernel::GetHandle() const
{
    if (this != NULL)
    {
        return m_hHandle;
    }
    else
    {
        return NULL;
    }
}

CKernel::operator HANDLE() const
{
    return GetHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cmdh.cpp ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// CMDH.cpp - Helper class for working with
//            logical disks mapped by logon
//            session.
// 
// Created: 4/23/2000   Kevin Hughes (khughes)
//

// USEAGE NOTE: This class presents a view of
// information pertaining to mapped drives in
// the context of the process id specified in
// the class constructor.


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above


#pragma warning (disable: 4786)
#pragma warning (disable: 4284)

#include <precomp.h>
#include <objbase.h>
#include <comdef.h>
#include <stdio.h>    //sprintf
#include <stdlib.h>
#include <assert.h>
#include <strstrea.h>
#include <vector>
#include <DskQuota.h>
#include <smartptr.h>

#include "DllWrapperBase.h"
#include "AdvApi32Api.h"
#include "NtDllApi.h"
#include "Kernel32Api.h"


#include <ntioapi.h>
#include "cmdh.h"

#include <session.h>
#include <dllutils.h>
#include <..\..\framework\provexpt\include\provexpt.h>




///////////////////////////////////////////////////////////////////////////////
//  CMDH Public interface functions
///////////////////////////////////////////////////////////////////////////////


HRESULT CMDH::GetMDData(
    DWORD dwReqProps,
    VARIANT* pvarData)
{
    HRESULT hr = S_OK;
    
    if(!pvarData) return E_POINTER;
    
    if(SUCCEEDED(hr))
    {
        hr = GetMappedDisksAndData(
            dwReqProps,
            pvarData);
    }

    return hr;
}

HRESULT CMDH::GetOneMDData(
	BSTR bstrDrive,
	DWORD dwReqProps, 
	VARIANT* pvarData)
{
    HRESULT hr = S_OK;

    if(!pvarData) return E_POINTER;

    if(SUCCEEDED(hr))
    {
        hr = GetSingleMappedDiskAndData(
            bstrDrive,
            dwReqProps,
            pvarData);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  CMDH Private internal functions
///////////////////////////////////////////////////////////////////////////////

// This function does pretty much all of the
// work this object was constructed to do -
// it obtains, for the process space that this
// server is running in, the set of mapped
// drives, and for each of these, the following
// information as well:
// 
HRESULT CMDH::GetMappedDisksAndData(
    DWORD dwReqProps,
    VARIANT* pvarData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ::VariantInit(pvarData);
	V_VT(pvarData) = VT_EMPTY;

    // Get the mapped drives into a vector...
    std::vector<_bstr_t> vecMappedDrives;
    {
        // Impersonate member process...
        SmartRevertTokenHANDLE hCurImpTok;
        
        hCurImpTok = Impersonate();

        if(hCurImpTok != INVALID_HANDLE_VALUE)
        {
            GetMappedDriveList(
                vecMappedDrives);
        }
    }

    // Now allocate the two dimensional
    // safearray that will hold the properties
    // for each mapped drive...
    SAFEARRAY* saDriveProps = NULL;
    SAFEARRAYBOUND rgsabound[2];
    
    rgsabound[0].cElements = PROP_COUNT;
	rgsabound[0].lLbound = 0; 

    rgsabound[1].cElements = vecMappedDrives.size();
	rgsabound[1].lLbound = 0;

    saDriveProps = ::SafeArrayCreate(
        VT_BSTR, 
        2, 
        rgsabound);

    if(saDriveProps)
    {
        // For each mapped drive, obtain its
        // properties and store in the safearray...
        for(long m = 0;
            m < vecMappedDrives.size() && SUCCEEDED(hr);
            m++)
        {
            hr = GetMappedDriveInfo(
                vecMappedDrives[m],
                m,
                saDriveProps,
                dwReqProps);
        }

        // And finally package the safearray
        // into the outgoing variant.
        if(SUCCEEDED(hr))
        {
            ::VariantInit(pvarData);
	        V_VT(pvarData) = VT_BSTR | VT_ARRAY; 
            V_ARRAY(pvarData) = saDriveProps;
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}


// Similar to GetMappedDisksAndData, but only
// retrieves info for a single disk.
//
HRESULT CMDH::GetSingleMappedDiskAndData(
    BSTR bstrDrive,
    DWORD dwReqProps,
    VARIANT* pvarData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ::VariantInit(pvarData);
	V_VT(pvarData) = VT_EMPTY;

    // Impersonate member process...
    SmartRevertTokenHANDLE hCurImpTok;
    
    hCurImpTok = Impersonate();

    if(hCurImpTok != INVALID_HANDLE_VALUE)
    {
        // Get the mapped drives into a vector...
        std::vector<_bstr_t> vecMappedDrives;
        GetMappedDriveList(
            vecMappedDrives);

        // Now allocate the two dimensional
        // safearray that will hold the properties
        // for each mapped drive...
        // Note: in this routine, it is really
        // only a one dimensional array, but,
        // for code reuse, we'll treat it as a
        // two dimensional array with only one
        // element in one of the dimensions.
        SAFEARRAY* saDriveProps = NULL;
        SAFEARRAYBOUND rgsabound[2];
    
        rgsabound[0].cElements = PROP_COUNT; 
	    rgsabound[0].lLbound = 0; 

        rgsabound[1].cElements = 1; // for code reuse
	    rgsabound[1].lLbound = 0;

        saDriveProps = ::SafeArrayCreate(
            VT_BSTR, 
            2, 
            rgsabound);

        if(saDriveProps)
        {
            // See if the drive specified is a member
            // of the vector.
            _bstr_t bstrtTmp = bstrDrive;
            bstrtTmp += L"\\";
            bool fFoundIt = false;

            for(long n = 0;
                n < vecMappedDrives.size() && !fFoundIt;
                n++)
            {
                if(_wcsicmp(bstrtTmp, vecMappedDrives[n]) == 0)
                {
                    fFoundIt = true;
                    n--;
                }
            }
            // For the mapped drive, obtain its
            // properties and store in the safearray...
            if(fFoundIt)
            {
                hr = GetMappedDriveInfo(
                    vecMappedDrives[n],
                    0,   // for code reuse
                    saDriveProps,
                    dwReqProps);

                // And finally package the safearray
                // into the outgoing variant.
                ::VariantInit(pvarData);
	            V_VT(pvarData) = VT_BSTR | VT_ARRAY; 
                V_ARRAY(pvarData) = saDriveProps;
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}


// Builds a list of mapped drives as
// seen with respect to the process
// identified by m_dwImpPID.  Hence, this
// routine will return a valid picture
// of the drives seen by m_dwImpPID, regardless
// of our current thread impersonation.
//
#ifdef NTONLY  // uses ntdll.dll functions
void CMDH::GetMappedDriveList(
    std::vector<_bstr_t>& vecMappedDrives)
{
    // Need to call NtQueryInformationProcess,
    // asking for ProcessDeviceMap info, specifying
    // a handle to the process identified by
    // m_dwImpPID.

    // Need to get a process handle to the 
    // process specified by PID.
    NTSTATUS Status;

    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;

	Status = ::NtQueryInformationProcess(
        ::GetCurrentProcess() /*hProcess*/,
        ProcessDeviceMap,
        &ProcessDeviceMapInfo.Query,
        sizeof(ProcessDeviceMapInfo.Query),

        NULL);

    if(NT_SUCCESS(Status))
    {
        WCHAR wstrDrive[4];
        for(short s = 0; 
            s < 32; 
            s++) 
        {
            if(ProcessDeviceMapInfo.Query.DriveMap & (1<<s))
            {
                wstrDrive[0] = s + L'A';
                wstrDrive[1] = L':';
                wstrDrive[2] = L'\\';
                wstrDrive[3] = L'\0';
        
                if(ProcessDeviceMapInfo.Query.DriveType[s] == 
                      DOSDEVICE_DRIVE_REMOTE)
                {
                    vecMappedDrives.push_back(wstrDrive);
                }
                else if(ProcessDeviceMapInfo.Query.DriveType[s] == 
                      DOSDEVICE_DRIVE_CALCULATE)
                {
                    // We have more work to do.
                    // Create an nt file path...
                    WCHAR NtDrivePath[_MAX_PATH] = { '\0' };
                    wcscpy(NtDrivePath, L"\\??\\");
                    wcscat(NtDrivePath, wstrDrive);

                    // Create the unicode string...
                    UNICODE_STRING ustrNtFileName;

                    ::RtlInitUnicodeString(
                        &ustrNtFileName, 
                        NtDrivePath);

                    // Get the object attributes...
                    OBJECT_ATTRIBUTES oaAttributes;

                    InitializeObjectAttributes(&oaAttributes,
					   &ustrNtFileName,
					   OBJ_CASE_INSENSITIVE,
					   NULL,
					   NULL);

                    // Open the file
                    DWORD dwStatus = ERROR_SUCCESS;
                    IO_STATUS_BLOCK IoStatusBlock;
                    HANDLE hFile = NULL;

                    dwStatus = ::NtOpenFile( 
                        &hFile,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &oaAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0);

                    FILE_FS_DEVICE_INFORMATION DeviceInfo;

                    if(NT_SUCCESS(dwStatus))
                    {
						try
						{
							// Get information on the file...
							dwStatus = ::NtQueryVolumeInformationFile( 
								hFile,
								&IoStatusBlock,
								&DeviceInfo,
								sizeof(DeviceInfo),
								FileFsDeviceInformation);

							::NtClose(hFile);
							hFile = NULL;
						}
						catch(...)
						{
							::NtClose(hFile);
							hFile = NULL;
							throw;
						}
                    }

                    if(NT_SUCCESS(dwStatus))
                    {
                        if((DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) ||
                            (DeviceInfo.DeviceType == FILE_DEVICE_NETWORK ||
                            DeviceInfo.DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM))
                        {
                            // it is a remote drive...
                            vecMappedDrives.push_back(wstrDrive);                                    
                        }
                    }
                }
            }
        }
    }
}
#endif

// All of the routines used in this function -
// GetProviderName, GetVolumeInformation,
// and GetDriveFreeSpace, return information
// for the drive who's mapping string appears
// in wstrDriveName with respect to that
// mapping string's meaning in the context of
// the current thread's impersonation. Hence
// we impersonate before calling them.
//
HRESULT CMDH::GetMappedDriveInfo(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps,
    DWORD dwReqProps)
{
    HRESULT hr = S_OK;

    // Right away we can set the device id prop...
    hr = SetProperty(
        lDrivePropArrayDriveIndex,
        PROP_DEVICEID,
        wstrDriveName,
        saDriveProps);

    // If we couldn't even set the device id, it is
    // a problem.  Otherwise, continue.
    if(SUCCEEDED(hr))
    {
        // Set the other properties if they
        // were requested...
        // Get Expensive properties now if appropriate.
	    if(dwReqProps &
            (SPIN_DISK |
            GET_PROVIDER_NAME))
        {
			
            // Impersonate member process...
            SmartRevertTokenHANDLE hCurImpTok;
            hCurImpTok = Impersonate(); 

            if(dwReqProps & GET_PROVIDER_NAME)
			{   
                GetProviderName(
                    wstrDriveName,
                    lDrivePropArrayDriveIndex,
                    saDriveProps);
            }

            if(dwReqProps & GET_VOL_INFO)
			{
				// Obtain volume information
				GetDriveVolumeInformation(
                    wstrDriveName,
                    lDrivePropArrayDriveIndex,
                    saDriveProps);
			}

			
			if ( dwReqProps &
				(PROP_SIZE |
				 PROP_FREE_SPACE) )
			{
				GetDriveFreeSpace(
                    wstrDriveName,
                    lDrivePropArrayDriveIndex,
                    saDriveProps);
			}
        }
    }

    return hr;
}


// Presents a view based on the current 
// impersonation of the current thread.
//
HRESULT CMDH::GetProviderName(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps)
{
    HRESULT hr = S_OK;

    WCHAR wstrTempDrive[_MAX_PATH] ;
	wsprintf(
        wstrTempDrive, 
        L"%c%c", 
        wstrDriveName[0], 
        wstrDriveName[1]);

	WCHAR wstrProvName[_MAX_PATH];
	DWORD dwProvName = sizeof(wstrProvName ) ;
    WCHAR* wstrNewProvName = NULL;

    // Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;
	try  
    {
	    DWORD dwRetCode = ::WNetGetConnection(
            wstrTempDrive, 
            wstrProvName, 
            &dwProvName);

	    if(dwRetCode == NO_ERROR ||
            dwRetCode == ERROR_CONNECTION_UNAVAIL)
	    {
		    hr = SetProperty(
                lDrivePropArrayDriveIndex,
                PROP_PROVIDER_NAME,
                wstrProvName,
                saDriveProps);
	    }
	    else
	    {
		    dwRetCode = GetLastError();

		    if((dwRetCode == ERROR_MORE_DATA) && 
                (dwProvName > _MAX_PATH))
		    {
                wstrNewProvName = new WCHAR[dwProvName];
			    if(wstrNewProvName != NULL)
			    {
					dwRetCode = ::WNetGetConnection(
                        wstrTempDrive, 
                        wstrNewProvName, 
                        &dwProvName);

					if(dwRetCode == NO_ERROR ||
                        dwRetCode == ERROR_CONNECTION_UNAVAIL)
					{
						hr = SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_PROVIDER_NAME,
                            wstrNewProvName,
                            saDriveProps);
					}
                    else
                    {
                        hr = HRESULT_FROM_WIN32(dwRetCode);
                    }

				    delete wstrNewProvName;
                }
                else
			    {
				    hr = E_OUTOFMEMORY;
			    }
		    }
            else
            {
                hr = HRESULT_FROM_WIN32(dwRetCode);
            }
	    }
    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo());    
        if(wstrNewProvName)
        {
            delete wstrNewProvName;
            wstrNewProvName = NULL;
        }
        hr = WBEM_E_FAILED;
    }  
    catch(...)
    {
        if(wstrNewProvName)
        {
            delete wstrNewProvName;
            wstrNewProvName = NULL;
        }
        // The filter will do the work.  Just re-throw here.
        throw;
    }    
  

    return hr;
}



// Presents a view based on the current 
// impersonation of the current thread.
//
HRESULT CMDH::GetDriveVolumeInformation(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps)
{
    HRESULT hr = S_OK;
    DWORD dwResult = ERROR_SUCCESS;

	WCHAR wstrVolumeName[_MAX_PATH];
	WCHAR wstrFileSystem[_MAX_PATH];
    WCHAR wstrTmp[_MAX_PATH];
    DWORD dwSerialNumber;
	DWORD dwMaxComponentLength;
	DWORD dwFSFlags;

	BOOL fReturn = ::GetVolumeInformation(
		wstrDriveName,
		wstrVolumeName,
		sizeof(wstrVolumeName)/sizeof(WCHAR),
		&dwSerialNumber,
		&dwMaxComponentLength,
		&dwFSFlags,
		wstrFileSystem,
		sizeof(wstrFileSystem)/sizeof(WCHAR)
	);

    if(fReturn)
	{
	    // Win32 API will return volume information for all drive types.
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_VOLUME_NAME,
            wstrVolumeName,
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_FILE_SYSTEM,
            wstrFileSystem,
            saDriveProps);

        if (dwSerialNumber != 0)
        {
	        WCHAR wstrSerialNumber[_MAX_PATH];
            wsprintf(wstrSerialNumber, 
                L"%.8X", 
                dwSerialNumber);

            SetProperty(
                lDrivePropArrayDriveIndex,
                PROP_VOLUME_SERIAL_NUMBER,
                wstrSerialNumber,
                saDriveProps);
        }

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_COMPRESSED,
            STR_FROM_bool(dwFSFlags & FS_VOL_IS_COMPRESSED),
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_SUPPORTS_FILE_BASED_COMPRESSION,
            STR_FROM_bool(dwFSFlags & FS_FILE_COMPRESSION),
            saDriveProps);

        _ultow(dwMaxComponentLength,
            wstrTmp,
            10);
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_MAXIMUM_COMPONENT_LENGTH,
            wstrTmp,
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_SUPPORTS_DISK_QUOTAS,
            STR_FROM_bool(dwFSFlags & FILE_VOLUME_QUOTAS),
            saDriveProps);

		

		// To get the state of the volume, 
        // we need to get the Interface pointer...
        IDiskQuotaControlPtr pIQuotaControl;
        ::SetLastError(ERROR_SUCCESS);

		if(SUCCEEDED(CoCreateInstance(
		    CLSID_DiskQuotaControl,
		    NULL,
		    CLSCTX_INPROC_SERVER,
		    IID_IDiskQuotaControl,
		    (void **)&pIQuotaControl)))
		{
			WCHAR wstrVolumePathName[MAX_PATH + 1];
            ::SetLastError(ERROR_SUCCESS);

			BOOL fRetVal = FALSE;
            
            CKernel32Api* pKernel32 = NULL;
            pKernel32 = (CKernel32Api*)CResourceManager::sm_TheResourceManager.GetResource(
                    g_guidKernel32Api, NULL);
    
            try
            {
                if(pKernel32)
                {
                    pKernel32->GetVolumePathName(
			            wstrDriveName,    
			            wstrVolumePathName, 
			            MAX_PATH,
                        &fRetVal);

                    CResourceManager::sm_TheResourceManager.ReleaseResource(
                        g_guidKernel32Api, pKernel32);

                    pKernel32 = NULL;
                }
            }
            catch(...)
            {
                if(pKernel32)
                {
                    CResourceManager::sm_TheResourceManager.ReleaseResource(
                        g_guidKernel32Api, pKernel32);
                }
                throw;            
            }

			if(fRetVal)
			{
				::SetLastError(ERROR_SUCCESS);
                if(SUCCEEDED(pIQuotaControl->Initialize(
                    wstrVolumePathName, 
                    TRUE)))
				{
					DWORD dwQuotaState;
                    ::SetLastError(ERROR_SUCCESS);

					hr = pIQuotaControl->GetQuotaState(&dwQuotaState);
					if(SUCCEEDED(hr))
					{
                        SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_QUOTAS_INCOMPLETE,
                            STR_FROM_bool(DISKQUOTA_FILE_INCOMPLETE(dwQuotaState)),
                            saDriveProps);
					
                        SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_QUOTAS_REBUILDING,
                            STR_FROM_bool(DISKQUOTA_FILE_REBUILDING(dwQuotaState)),
                            saDriveProps);
				
                        SetProperty(
                            lDrivePropArrayDriveIndex,
                            PROP_QUOTAS_DISABLED,
                            STR_FROM_bool(DISKQUOTA_STATE_DISABLED & dwQuotaState),
                            saDriveProps);
					}
					else
					{
						dwResult = GetLastError();
					}
				}
				else
				{
					dwResult = GetLastError();
				}
			}
		}
		else
		{
			dwResult = GetLastError();
		}
    }
    else
    {
        dwResult = GetLastError();
    }

    // for chkdsk VolumeDirty Property
	BOOLEAN fVolumeDirty = FALSE;
	BOOL fSuccess = FALSE;

	_bstr_t bstrtDosDrive(wstrDriveName);
	UNICODE_STRING string = { 0 };
    _bstr_t nt_drive_name;

    try
    {
	    RtlDosPathNameToNtPathName_U(
            (LPCWSTR)bstrtDosDrive, 
            &string, 
            NULL, 
            NULL);

	    string.Buffer[string.Length/sizeof(WCHAR) - 1] = 0;
	    nt_drive_name = string.Buffer;

        if(string.Buffer)
        {
            RtlFreeUnicodeString(&string);
            string.Buffer = NULL;
        }
    }
    catch(...)
    {
        if(string.Buffer)
        {
            RtlFreeUnicodeString(&string);
            string.Buffer = NULL;
        }
        throw;
    }

    ::SetLastError(ERROR_SUCCESS);
	fSuccess = IsVolumeDirty(
        nt_drive_name, 
        &fVolumeDirty );

	if(fSuccess)
	{
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_PERFORM_AUTOCHECK,
            STR_FROM_bool(!fVolumeDirty),
            saDriveProps);
	}

    if(dwResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }

    return hr;
}



// Presents a view based on the current 
// impersonation of the current thread.
//
BOOLEAN CMDH::IsVolumeDirty(
    _bstr_t &bstrtNtDriveName,
    BOOLEAN *Result)
{
    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   obj;
    NTSTATUS            status = 0;
    IO_STATUS_BLOCK     iosb;
    HANDLE              h = 0;
    ULONG               r = 0;
	BOOLEAN				bRetVal = FALSE;
    WCHAR               wstrNtDriveName[_MAX_PATH];

    wcscpy(wstrNtDriveName, bstrtNtDriveName);
    u.Length = (USHORT) wcslen(wstrNtDriveName) * sizeof(WCHAR);
    u.MaximumLength = u.Length;
    u.Buffer = wstrNtDriveName;

    InitializeObjectAttributes(&obj, &u, OBJ_CASE_INSENSITIVE, 0, 0);

    status = NtOpenFile(
        &h,
        SYNCHRONIZE | FILE_READ_DATA,
        &obj,
        &iosb,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        FILE_SYNCHRONOUS_IO_ALERT);

    if(NT_SUCCESS(status)) 
	{
		try
		{
			status = NtFsControlFile(
				h, NULL, NULL, NULL,
				&iosb,
				FSCTL_IS_VOLUME_DIRTY,
				NULL, 0,
				&r, sizeof(r));

			if(NT_SUCCESS(status)) 
			{

#if(_WIN32_WINNT >= 0x0500)
				*Result = (BOOLEAN)(r & VOLUME_IS_DIRTY);
#else
				*Result = (BOOLEAN)r;
#endif
				bRetVal = TRUE;
			}
		}
		catch(...)
		{
			NtClose(h);
			h = 0;
			throw;
		}

		NtClose(h);
		h = 0;
	}

	return bRetVal;
}



// Presents a view based on the current 
// impersonation of the current thread.
//
HRESULT CMDH::GetDriveFreeSpace(
    LPCWSTR wstrDriveName,
    long lDrivePropArrayDriveIndex,
    SAFEARRAY* saDriveProps)
{
	HRESULT hr = S_OK;

	ULARGE_INTEGER uliTotalBytes;
	ULARGE_INTEGER uliUserFreeBytes;
	ULARGE_INTEGER uliTotalFreeBytes;

    ::SetLastError(ERROR_SUCCESS);
	if(::GetDiskFreeSpaceEx(
        wstrDriveName, 
        &uliUserFreeBytes, 
        &uliTotalBytes, 
        &uliTotalFreeBytes))
	{
		WCHAR wstrTmp[128] = { L'\0' };
        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_SIZE,
            _ui64tow(
                uliTotalBytes.QuadPart,
                wstrTmp,
                10),
            saDriveProps);

        SetProperty(
            lDrivePropArrayDriveIndex,
            PROP_FREE_SPACE,
            _ui64tow(
                uliTotalFreeBytes.QuadPart,
                wstrTmp,
                10),
            saDriveProps);

	}
    else
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());    
    }

    return hr;
}



// Sets a property for a given drive
// in the drive safearray.
//
HRESULT CMDH::SetProperty(
    long lDrivePropArrayDriveIndex,
    long lDrivePropArrayPropIndex,
    LPCWSTR wstrPropValue,
    SAFEARRAY* saDriveProps)
{
    HRESULT hr = S_OK;

    BSTR bstrTmp = NULL;
    try
    {
        bstrTmp = ::SysAllocString(wstrPropValue);
        long ix[2];
        ix[0] = lDrivePropArrayPropIndex;
        ix[1] = lDrivePropArrayDriveIndex;

        hr = ::SafeArrayPutElement(
            saDriveProps, 
            ix, 
            bstrTmp);
    }
    catch(...)
    {
        if(bstrTmp != NULL)
        {
            ::SysFreeString(bstrTmp);
            bstrTmp = NULL;
        }
        throw;
    }

    return hr;
}



// Sets our current thread's impersonation
// to the token belonging to the process
// identified by our member, m_dwImpPID.
//
HANDLE CMDH::Impersonate()
{
    HANDLE hCurToken = INVALID_HANDLE_VALUE;
    HANDLE hCurThread = INVALID_HANDLE_VALUE;

    // Find the explorer process...
    if(m_dwImpPID != -1L)
    {
        try  // Make sure we don't leave current thread token open
        {    // unless all went well.
            bool fOK = false;

            hCurThread = ::GetCurrentThread();

            if(hCurThread != INVALID_HANDLE_VALUE)
            {
                if(::OpenThreadToken(
                    hCurThread, 
                    TOKEN_IMPERSONATE, 
                    TRUE, 
                    &hCurToken))
                {
                    SmartCloseHANDLE hProcess;
                    hProcess = ::OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        m_dwImpPID);

                    if(hProcess != INVALID_HANDLE_VALUE)
                    {
                        // now open its token...
                        SmartCloseHANDLE hProcToken;
                        if(::OpenProcessToken(
                                hProcess,
                                TOKEN_DUPLICATE,
                                &hProcToken))
                        {
                            // Duplicate the token...
                            SmartCloseHANDLE hDupProcToken; 
                            if(::DuplicateTokenEx(
                                hProcToken,
                                MAXIMUM_ALLOWED,
                                NULL,  
                                SecurityImpersonation,
                                TokenImpersonation,
                                &hDupProcToken))
                            {
                                // Set the thread token...
                                if(::SetThreadToken(
                                    &hCurThread,
                                    hDupProcToken))
                                {
                                    fOK = true;                        
                                }
                            }
                        }
                    }
                }
                CloseHandle(hCurThread); hCurThread = INVALID_HANDLE_VALUE;
            }

            if(!fOK)
            {
                if(hCurToken != INVALID_HANDLE_VALUE)
                {
                    ::CloseHandle(hCurToken);
                    hCurToken = INVALID_HANDLE_VALUE;
                }    
            }
        }
        catch(...)
        {
            if(hCurToken != INVALID_HANDLE_VALUE)
            {
                ::CloseHandle(hCurToken);
                hCurToken = INVALID_HANDLE_VALUE;
            }
            if(hCurThread != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hCurThread); hCurThread = INVALID_HANDLE_VALUE;
            }
            throw;
        }
    }

    return hCurToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cmdh.h ===
//  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// CMDH.cpp - Helper class for working with
//            logical disks mapped by logon
//            session.
// 
// Created: 4/23/2000   Kevin Hughes (khughes)
//


#pragma once



#define STR_FROM_bool(x) ( x ? L"TRUE" : L"FALSE" )



_COM_SMARTPTR_TYPEDEF(IDiskQuotaControl, IID_IDiskQuotaControl);


#define GET_NOTHING                             0x00000000
#define GET_ALL_PROPERTIES                      0xFFFFFFFF
#define GET_DEVICEID                            0x00000001
#define GET_PROVIDER_NAME                       0x00000002
#define GET_VOLUME_NAME                         0x00000004
#define GET_FILE_SYSTEM                         0x00000008
#define GET_VOLUME_SERIAL_NUMBER                0x00000010
#define GET_COMPRESSED                          0x00000020
#define GET_SUPPORTS_FILE_BASED_COMPRESSION     0x00000040
#define GET_MAXIMUM_COMPONENT_LENGTH            0x00000080
#define GET_SUPPORTS_DISK_QUOTAS                0x00000100
#define GET_QUOTAS_INCOMPLETE                   0x00000200
#define GET_QUOTAS_REBUILDING                   0x00000400
#define GET_QUOTAS_DISABLED                     0x00000800
#define GET_PERFORM_AUTOCHECK                   0x00001000
#define GET_FREE_SPACE                          0x00002000
#define GET_SIZE                                0x00004000

#define GET_VOL_INFO        (GET_VOLUME_NAME | \
                             GET_FILE_SYSTEM | \
                             GET_VOLUME_SERIAL_NUMBER | \
                             GET_COMPRESSED | \
                             GET_SUPPORTS_FILE_BASED_COMPRESSION | \
                             GET_MAXIMUM_COMPONENT_LENGTH | \
                             GET_SUPPORTS_DISK_QUOTAS | \
                             GET_QUOTAS_INCOMPLETE | \
                             GET_QUOTAS_REBUILDING | \
                             GET_QUOTAS_DISABLED | \
                             GET_PERFORM_AUTOCHECK)

#define SPIN_DISK           (GET_VOL_INFO | \
                             GET_FREE_SPACE | \
                             GET_SIZE)


enum 
{
    PROP_DEVICEID                          = 0,
    PROP_PROVIDER_NAME                     = 1,                   	
    PROP_VOLUME_NAME                       = 2,
    PROP_FILE_SYSTEM                       = 3,
    PROP_VOLUME_SERIAL_NUMBER              = 4,
    PROP_COMPRESSED                        = 5,
    PROP_SUPPORTS_FILE_BASED_COMPRESSION   = 6,
    PROP_MAXIMUM_COMPONENT_LENGTH          = 7,
    PROP_SUPPORTS_DISK_QUOTAS              = 8,
    PROP_QUOTAS_INCOMPLETE                 = 9,
    PROP_QUOTAS_REBUILDING                 = 10,
    PROP_QUOTAS_DISABLED                   = 11,
    PROP_PERFORM_AUTOCHECK                 = 12,
    PROP_FREE_SPACE                        = 13,
    PROP_SIZE                              = 14,

    PROP_COUNT                             = 15

};








class CMDH
{
public:

    CMDH() : m_dwImpPID(-1L) {}
    CMDH(
        DWORD dwPID)
      : m_dwImpPID(dwPID)
    {}

    virtual ~CMDH() {}

    HRESULT GetMDData(
        DWORD dwReqProps,
        VARIANT* pvarData);

    HRESULT GetOneMDData(
	    BSTR bstrDrive,
	    DWORD dwReqProps, 
	    VARIANT* pvarData);

    DWORD GetImpPID()
    {
        return m_dwImpPID;
    }

    void SetImpPID(
        DWORD dwPID)
    {
        m_dwImpPID = dwPID;
    }

private:

    HRESULT GetMappedDisksAndData(
        DWORD dwReqProps,
        VARIANT* pvarData);

    HRESULT GetSingleMappedDiskAndData(
        BSTR bstrDrive,
        DWORD dwReqProps,
        VARIANT* pvarData);

#ifdef NTONLY
    void GetMappedDriveList(
        std::vector<_bstr_t>& vecMappedDrives);
#endif

    HRESULT GetMappedDriveInfo(
        LPCWSTR wstrDriveName,
        long lDrivePropArrayDriveIndex,
        SAFEARRAY* saDriveProps,
        DWORD dwReqProps);

    HRESULT GetProviderName(
        LPCWSTR wstrDriveName,
        long lDrivePropArrayDriveIndex,
        SAFEARRAY* saDriveProps);

    HRESULT GetDriveVolumeInformation(
        LPCWSTR wstrDriveName,
        long lDrivePropArrayDriveIndex,
        SAFEARRAY* saDriveProps);

    BOOLEAN IsVolumeDirty(
        _bstr_t &bstrtNtDriveName,
        BOOLEAN *Result);

    HRESULT GetDriveFreeSpace(
        LPCWSTR wstrDriveName,
        long lDrivePropArrayDriveIndex,
        SAFEARRAY* saDriveProps);

    HRESULT SetProperty(
        long lDrivePropArrayDriveIndex,
        long lDrivePropArrayPropIndex,
        LPCWSTR wstrPropValue,
        SAFEARRAY* saDriveProps);

    HANDLE Impersonate();


    DWORD m_dwImpPID;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cmutex.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CMutex.cpp -- Mutex Wrapper

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#include "precomp.h"
#include "CMutex.h"

// constructor creates a mutex allowing creation parameters to be specified...
CMutex::CMutex(BOOL bInitialOwner, LPCTSTR lpName, LPSECURITY_ATTRIBUTES lpMutexAttributes)
{
    m_hHandle = ::CreateMutex(lpMutexAttributes, bInitialOwner, lpName);
    if (CIsValidHandle(m_hHandle))
    {
        if (lpName)
        {
            m_dwStatus = GetLastError();
        }
        else
        {
            m_dwStatus = NO_ERROR;
        }
    }
    else
    {
        m_dwStatus = GetLastError();
        ThrowError(m_dwStatus);
    }
}

// constructor opens an existing named mutex...
CMutex::CMutex(LPCTSTR lpName, BOOL bInheritHandle, DWORD dwDesiredAccess)
{
    m_hHandle = ::OpenMutex(dwDesiredAccess, bInheritHandle, lpName);
    if (CIsValidHandle(m_hHandle))
    {
        m_dwStatus = NO_ERROR;
    }
    else
    {
        m_dwStatus = GetLastError();
    }
}

// release a lock on a mutex...
BOOL CMutex::Release(void)
{
    return ::ReleaseMutex(m_hHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cmutex.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CMutex.h -- Mutex Wrapper

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================


#ifndef __CMUTEX_H__
#define __CMUTEX_H__

#include "CKernel.h"

class CMutex : public CKernel {
public:
    CMutex(BOOL bInitialOwner = FALSE, 
           LPCTSTR lpName = NULL, 
           LPSECURITY_ATTRIBUTES lpMutexAttributes = NULL);
    
    // Constructor opens an existing named mutex.
    // Check the status after using this constructor, as it will
    // NOT throw an error exception if the object cannot be opened.
    CMutex(LPCTSTR lpName, 
           BOOL bInheritHandle = FALSE, 
           DWORD dwDesiredAccess = MUTEX_ALL_ACCESS);

    // release a lock on a mutex...
    BOOL Release(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cndisapi.h ===
//=================================================================

//

// NTDriverIO.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/07/99	a-peterc        Created
//
//=================================================================
#ifndef _CNDISAPI_H_
#define _CNDISAPI_H_

class CNdisApi
{
	private:
  	
	protected:
	public:
	        
        //=================================================
        // Constructor/destructor
        //=================================================
  		CNdisApi();
       ~CNdisApi();

    	UINT PnpUpdateGateway(	PCWSTR a_pAdapter ) ; 
		
		UINT PnpUpdateNbtAdapter( PCWSTR a_pAdapter ) ; 

		UINT PnpUpdateNbtGlobal( 

								BOOL a_fLmhostsFileSet,
								BOOL a_fEnableLmHosts
								) ; 
		
		UINT PnpUpdateIpxGlobal() ;
		UINT PnpUpdateIpxAdapter( PCWSTR a_pAdapter, BOOL a_fAuto ) ; 
};

#endif _CNDISAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cndisapi.cpp ===
//=================================================================

//

// NTDriverIO.cpp --

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    07/07/99	a-peterc        Created
//
//=================================================================













#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"

#include "CNdisApi.h"
#include "ndismisc.h"




/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  CNdisApi::CNdisApi()

 Description: encapsulates the functionallity of NdisHandlePnPEvent()

 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  15-Nov-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

CNdisApi::CNdisApi()
{
}

//
CNdisApi::~CNdisApi()
{
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateGateway(

PCWSTR a_pAdapter,
BOOL a_fRouterDiscovery,
BOOL a_fIPEnableRouter
)

 Description:	PNP notification of gateway changes

 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateGateway(

PCWSTR a_pAdapter
)
{
	IP_PNP_RECONFIG_REQUEST IpReconfigRequest;

	memset( &IpReconfigRequest, NULL, sizeof( IP_PNP_RECONFIG_REQUEST ) ) ;

	// DWORD version
    IpReconfigRequest.version = IP_PNP_RECONFIG_VERSION;
	IpReconfigRequest.gatewayListUpdate = TRUE ;
	IpReconfigRequest.InterfaceMetricUpdate = TRUE ;

	IpReconfigRequest.Flags = IP_PNP_FLAG_GATEWAY_LIST_UPDATE |
                              IP_PNP_FLAG_INTERFACE_METRIC_UPDATE ;

	IpReconfigRequest.gatewayListUpdate  = TRUE ;
	IpReconfigRequest.InterfaceMetricUpdate = TRUE ;

	CHString t_chsAdapterDevice(L"\\Device\\") ;
			 t_chsAdapterDevice += a_pAdapter ;

	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, t_chsAdapterDevice ) ;

	UNICODE_STRING	t_strTcpIp ;
	RtlInitUnicodeString( &t_strTcpIp, L"Tcpip" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	UINT t_iRet = NdisHandlePnPEvent(
									NDIS,
									RECONFIGURE,
									&t_strAdapter,
									&t_strTcpIp,
									&t_strBinding,
									&IpReconfigRequest,
									sizeof( IP_PNP_RECONFIG_REQUEST )
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}
	return t_iRet;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateNbtAdapter( PCWSTR a_pAdapter )

 Description:	PNP notification of NetBios adapter level changes
 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateNbtAdapter( PCWSTR a_pAdapter )
{
	CHString t_chsAdapterDevice(L"\\Device\\") ;
			 t_chsAdapterDevice += a_pAdapter ;

	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, t_chsAdapterDevice ) ;

	UNICODE_STRING	t_strNetBT ;
	RtlInitUnicodeString( &t_strNetBT, L"NetBT" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	// per adapter notification
	UINT t_iRet = NdisHandlePnPEvent(
									TDI,
									RECONFIGURE,
									&t_strAdapter,
									&t_strNetBT,
									&t_strBinding,
									NULL,
									0
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}

	return t_iRet;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateNbtGlobal(

BOOL a_fLmhostsFileSet,
BOOL a_fEnableLmHosts
)

 Description:	PNP notification of NetBios global level changes

 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateNbtGlobal(

BOOL a_fLmhostsFileSet,
BOOL a_fEnableLmHosts
)
{
	NETBT_PNP_RECONFIG_REQUEST t_NetbtReconfigRequest;

	memset( &t_NetbtReconfigRequest, NULL, sizeof( NETBT_PNP_RECONFIG_REQUEST ) ) ;

	// DWORD version
    t_NetbtReconfigRequest.version = 1;

	t_NetbtReconfigRequest.enumDnsOption = WinsThenDns;
	t_NetbtReconfigRequest.fScopeIdUpdated = FALSE;
	t_NetbtReconfigRequest.fLmhostsEnabled = a_fEnableLmHosts == 0 ? 0 : 1;
	t_NetbtReconfigRequest.fLmhostsFileSet = a_fLmhostsFileSet == 0 ? 0 : 1;


	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, L""  ) ;

	UNICODE_STRING	t_strNetBT ;
	RtlInitUnicodeString( &t_strNetBT, L"NetBT" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	// global notification
	UINT t_iRet = NdisHandlePnPEvent(
									TDI,
									RECONFIGURE,
									&t_strAdapter,
									&t_strNetBT,
									&t_strBinding,
									&t_NetbtReconfigRequest,
									sizeof( NETBT_PNP_RECONFIG_REQUEST )
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}

	return t_iRet;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateIpxGlobal()

 Description:	PNP notification of IPX global level changes

 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateIpxGlobal()
{
	RECONFIG t_IpxConfig ;

	memset( &t_IpxConfig, NULL, sizeof( RECONFIG ) ) ;

	// DWORD version
    t_IpxConfig.ulVersion = IPX_RECONFIG_VERSION;
	t_IpxConfig.InternalNetworkNumber = TRUE;

	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, L""  ) ;

	UNICODE_STRING	t_strIPX ;
	RtlInitUnicodeString( &t_strIPX, L"NwlnkIpx" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	// global notification
	UINT t_iRet = NdisHandlePnPEvent(
									NDIS,
									RECONFIGURE,
									&t_strAdapter,
									&t_strIPX,
									&t_strBinding,
									&t_IpxConfig,
									sizeof( RECONFIG )
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}

	return t_iRet;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  UINT CNdisApi::PnpUpdateIpxAdapter( PCWSTR a_pAdapter, BOOL a_fAuto )

 Description:	PNP notification of IPX adapter level changes

 Arguments:
 Returns:		win32 error code
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:	a-peterc  07-July-1999     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

UINT CNdisApi::PnpUpdateIpxAdapter( PCWSTR a_pAdapter, BOOL a_fAuto )
{
	RECONFIG t_IpxConfig ;

	memset( &t_IpxConfig, NULL, sizeof( RECONFIG ) ) ;

	// DWORD version
    t_IpxConfig.ulVersion = IPX_RECONFIG_VERSION;
	t_IpxConfig.InternalNetworkNumber = FALSE ;

	t_IpxConfig.AdapterParameters[ a_fAuto ? RECONFIG_AUTO_DETECT : RECONFIG_MANUAL ] = TRUE;

	// set all frame types
	memset( &t_IpxConfig.AdapterParameters[ RECONFIG_PREFERENCE_1 ],
			TRUE,
			sizeof(BOOLEAN) * 8) ;

	CHString t_chsAdapterDevice(L"\\Device\\") ;
			 t_chsAdapterDevice += a_pAdapter ;

	UNICODE_STRING	t_strAdapter ;
	RtlInitUnicodeString( &t_strAdapter, t_chsAdapterDevice ) ;

	UNICODE_STRING	t_strIPX ;
	RtlInitUnicodeString( &t_strIPX, L"NwlnkIpx" ) ;

	UNICODE_STRING	t_strBinding ;
	RtlInitUnicodeString( &t_strBinding, L"" ) ;
	t_strBinding.MaximumLength = 0;

	// global notification
	UINT t_iRet = NdisHandlePnPEvent(
									NDIS,
									RECONFIGURE,
									&t_strAdapter,
									&t_strIPX,
									&t_strBinding,
									&t_IpxConfig,
									sizeof( RECONFIG )
									) ;

	if( !t_iRet )
	{
		t_iRet = GetLastError();
	}

	return t_iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\confgmgr.cpp ===
//=================================================================

//

// Confgmgr.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//              10/17/97        jennymc     Created
//
/////////////////////////////////////////////////////////////////////////
#define INITGUID
#include "precomp.h"
#include <cregcls.h>
#include <assertbreak.h>
#include "refptr.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "cfgmgrdevice.h"
#include "irqdesc.h"
#include "DllUtils.h"
#include "dmadesc.h"
#include <brodcast.h>
#include <lockwrap.h>
#include "strings.h"
#include <smartptr.h>

#include <devguid.h>

static CCritSec map;
STRING2GUID	CConfigManager::s_ClassMap;
BOOL CConfigManager::s_ClassIsValid = FALSE;


CConfigManager::CConfigManager( DWORD dwTypeToGet )
{
    m_dwTypeToGet = dwTypeToGet;

    if (!s_ClassIsValid)
    {
        CLockWrapper t_lockMap( map ) ;

        // Check again now that we have the lock
        if (!s_ClassIsValid)
        {
            s_ClassMap[_T("1394")] = GUID_DEVCLASS_1394;
            s_ClassMap[_T("ADAPTER")] = GUID_DEVCLASS_ADAPTER;
            s_ClassMap[_T("APMSUPPORT")] = GUID_DEVCLASS_APMSUPPORT;
            s_ClassMap[_T("BATTERY")] = GUID_DEVCLASS_BATTERY;
            s_ClassMap[_T("CDROM")] = GUID_DEVCLASS_CDROM;
            s_ClassMap[_T("COMPUTER")] = GUID_DEVCLASS_COMPUTER;
            s_ClassMap[_T("DECODER")] = GUID_DEVCLASS_DECODER;
            s_ClassMap[_T("DISKDRIVE")] = GUID_DEVCLASS_DISKDRIVE;
            s_ClassMap[_T("DISPLAY")] = GUID_DEVCLASS_DISPLAY;
            s_ClassMap[_T("FDC")] = GUID_DEVCLASS_FDC;
            s_ClassMap[_T("FLOPPYDISK")] = GUID_DEVCLASS_FLOPPYDISK;
            s_ClassMap[_T("GPS")] = GUID_DEVCLASS_GPS;
            s_ClassMap[_T("HDC")] = GUID_DEVCLASS_HDC;
            s_ClassMap[_T("HIDCLASS")] = GUID_DEVCLASS_HIDCLASS;
            s_ClassMap[_T("IMAGE")] = GUID_DEVCLASS_IMAGE;
            s_ClassMap[_T("INFRARED")] = GUID_DEVCLASS_INFRARED;
            s_ClassMap[_T("KEYBOARD")] = GUID_DEVCLASS_KEYBOARD;
            s_ClassMap[_T("LEGACYDRIVER")] = GUID_DEVCLASS_LEGACYDRIVER;
            s_ClassMap[_T("MEDIA")] = GUID_DEVCLASS_MEDIA;
            s_ClassMap[_T("MODEM")] = GUID_DEVCLASS_MODEM;
            s_ClassMap[_T("MONITOR")] = GUID_DEVCLASS_MONITOR;
            s_ClassMap[_T("MOUSE")] = GUID_DEVCLASS_MOUSE;
            s_ClassMap[_T("MTD")] = GUID_DEVCLASS_MTD;
            s_ClassMap[_T("MULTIFUNCTION")] = GUID_DEVCLASS_MULTIFUNCTION;
            s_ClassMap[_T("MULTIPORTSERIAL")] = GUID_DEVCLASS_MULTIPORTSERIAL;
            s_ClassMap[_T("NET")] = GUID_DEVCLASS_NET;
            s_ClassMap[_T("NETCLIENT")] = GUID_DEVCLASS_NETCLIENT;
            s_ClassMap[_T("NETSERVICE")] = GUID_DEVCLASS_NETSERVICE;
            s_ClassMap[_T("NETTRANS")] = GUID_DEVCLASS_NETTRANS;
            s_ClassMap[_T("NODRIVER")] = GUID_DEVCLASS_NODRIVER;
            s_ClassMap[_T("PCMCIA")] = GUID_DEVCLASS_PCMCIA;
            s_ClassMap[_T("PORTS")] = GUID_DEVCLASS_PORTS;
            s_ClassMap[_T("PRINTER")] = GUID_DEVCLASS_PRINTER;
            s_ClassMap[_T("PRINTERUPGRADE")] = GUID_DEVCLASS_PRINTERUPGRADE;
            s_ClassMap[_T("SCSIADAPTER")] = GUID_DEVCLASS_SCSIADAPTER;
            s_ClassMap[_T("SMARTCARDREADER")] = GUID_DEVCLASS_SMARTCARDREADER;
            s_ClassMap[_T("SOUND")] = GUID_DEVCLASS_SOUND;
            s_ClassMap[_T("SYSTEM")] = GUID_DEVCLASS_SYSTEM;
            s_ClassMap[_T("TAPEDRIVE")] = GUID_DEVCLASS_TAPEDRIVE;
            s_ClassMap[_T("UNKNOWN")] = GUID_DEVCLASS_UNKNOWN;
            s_ClassMap[_T("USB")] = GUID_DEVCLASS_USB;
            s_ClassMap[_T("VOLUME")] = GUID_DEVCLASS_VOLUME;

            s_ClassIsValid = TRUE;
        }

    }

}
////////////////////////////////////////////////////////////////////////
//
//  Reads the config manager registry keys for win98 and win95
//
////////////////////////////////////////////////////////////////////////
BOOL CConfigManager::BuildListsForThisDevice(CConfigMgrDevice *pDevice)
{
    CResourceCollection	resourceList;
    CHString sDeviceName, sClass, sKey(_T("Enum\\"));
    BOOL fRc = FALSE;
    CRegistry RegInfo;

	// Extract the device name
	sDeviceName = pDevice->GetDeviceDesc();
	// Pull the resource list out and enumerate it.
	pDevice->GetResourceList( resourceList );

   sKey += pDevice->GetHardwareKey();
   if (RegInfo.Open(HKEY_LOCAL_MACHINE, sKey, KEY_READ) == ERROR_SUCCESS) {
      RegInfo.GetCurrentKeyValue(L"Class", sClass);
   }

	REFPTR_POSITION	pos;

	if ( resourceList.BeginEnum( pos ) ){
        PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor = NULL;// Watch the scoping on this guy!
        DWORD dwCount = 0;

#if NTONLY >= 5
        // Go find the resource descriptor for this device
        CHString sRegKeyName;
        CRegistry Reg;
        CSmartBuffer Buffer;  // Watch the scoping on this guy!

        if ( (Reg.Open(HKEY_LOCAL_MACHINE, L"hardware\\resourcemap\\PnP Manager\\PNPManager", KEY_QUERY_VALUE) == ERROR_SUCCESS) &&
            pDevice->GetPhysicalDeviceObjectName(sRegKeyName) )
        {
            sRegKeyName += L".raw";

            DWORD dwValueType;
            DWORD dwValueDataSize = Reg.GetLongestValueData() + 2 ;

            Buffer = new BYTE[dwValueDataSize];

            if ((LPBYTE)Buffer == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            if(RegQueryValueEx(Reg.GethKey(), sRegKeyName, NULL,
                            &dwValueType, (LPBYTE)Buffer, &dwValueDataSize) == ERROR_SUCCESS)
            {
                if(dwValueType == REG_FULL_RESOURCE_DESCRIPTOR)
                {
                    dwCount         = 1 ;
                    pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) (LPBYTE)Buffer ;// Watch the scoping on this guy!
                }
                else if(dwValueType == REG_RESOURCE_LIST)
                {
                    dwCount         = ((PCM_RESOURCE_LIST) (LPBYTE)Buffer)->Count ;
                    pFullDescriptor = ((PCM_RESOURCE_LIST) (LPBYTE)Buffer)->List ;// Watch the scoping on this guy!
                }
            }
        }
#endif

        CHString sResource;
        //=========================================================
		// For each descriptor we find, if it's not ignored,
        // we should get the string data, and place it in the
        // appropriate list based on Type.
        //=========================================================
        CResourceDescriptorPtr pResDesc;
		for( pResDesc.Attach(resourceList.GetNext( pos ));
			 NULL != pResDesc;
             pResDesc.Attach(resourceList.GetNext( pos )) )

	    {
		    DWORD t_dwResType = pResDesc->GetResourceType();

	    	if ( (!pResDesc->IsIgnored()) &&
                ((m_dwTypeToGet == ResType_All) || (m_dwTypeToGet == t_dwResType) ) )
            {

			    switch ( t_dwResType )
                {

		    		case ResType_DMA:

                        DMA_INFO  *pDMA_Info;
                        DMA_DES  *pTmp;
                        pDMA_Info = new DMA_INFO;
                        if (pDMA_Info != NULL)
                        {

                            try
                            {
                                DWORD dwChannelWidth;

                                pTmp = (DMA_DES*) pResDesc->GetResource();
                                dwChannelWidth = (pTmp->DD_Flags) & 0x0003;

                                pDMA_Info->ChannelWidth = 0;
                                if( dwChannelWidth == 0 )
                                {
                                    pDMA_Info->ChannelWidth = 8;
                                }
                                else if( dwChannelWidth == 1 )
                                {
                                    pDMA_Info->ChannelWidth = 16;
                                }
                                else if( dwChannelWidth == 2 )
                                {
                                    pDMA_Info->ChannelWidth = 32;
                                }

						        pDMA_Info->DeviceType = sClass;
                                pDMA_Info->Channel      = pTmp->DD_Alloc_Chan;
                                pResDesc->GetOwnerDeviceID(pDMA_Info->OwnerDeviceId);
                                pResDesc->GetOwnerName(pDMA_Info->OwnerName);
                                pDMA_Info->OEMNumber = pResDesc->GetOEMNumber();
                                pDMA_Info->Port = GetDMAPort(pFullDescriptor, dwCount, pTmp->DD_Alloc_Chan);
                            }
                            catch ( ... )
                            {
                                delete pDMA_Info;
                                throw ;
                            }

						    // real DMA channels are in the range 0-7
						    // sometimes the confug mugger reports channels
						    // with great big numbers - we don't care
						    if (pDMA_Info->Channel < 8)
                            {
                                try
                                {
			    			        m_List.Add(pDMA_Info);
                                }
                                catch ( ... )
                                {
                                    delete pDMA_Info;
                                    throw ;
                                }
                            }
						    else
                            {
							    delete pDMA_Info;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

	    				break;

			    	case ResType_IRQ:
                        IRQ_INFO  *pIRQ_Info;
                        IRQ_DES  *pTmpIrq;
                        pIRQ_Info = new IRQ_INFO;

                        if (pIRQ_Info != NULL)
                        {
                            try
                            {
                                pTmpIrq = (IRQ_DES*) pResDesc->GetResource();

                                pIRQ_Info->Shareable = pTmpIrq->IRQD_Flags;
	                            pIRQ_Info->IRQNumber = pTmpIrq->IRQD_Alloc_Num;		// Allocated IRQ number

						        pIRQ_Info->DeviceType = sClass;
                                pResDesc->GetOwnerDeviceID(pIRQ_Info->OwnerDeviceId);
                                pResDesc->GetOwnerName(pIRQ_Info->OwnerName);
                                pIRQ_Info->OEMNumber = pResDesc->GetOEMNumber();
                                pIRQ_Info->Vector = GetIRQVector(pFullDescriptor, dwCount, pTmpIrq->IRQD_Alloc_Num);

			    		        m_List.Add(pIRQ_Info);
                            }
                            catch ( ... )
                            {
                                delete pIRQ_Info;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

				    	break;

			    	case ResType_IO:
                        IO_INFO  *pIO_Info;
                        IOWBEM_DES  *pTmpIO;
                        pIO_Info = new IO_INFO;

                        if (pIO_Info != NULL)
                        {
                            try
                            {

                                pTmpIO = (IOWBEM_DES*) pResDesc->GetResource();

                                pIO_Info->DeviceType = sClass;
                                pIO_Info->StartingAddress = pTmpIO->IOD_Alloc_Base;
                                pIO_Info->EndingAddress = pTmpIO->IOD_Alloc_End;
                                pIO_Info->Alias = pTmpIO->IOD_Alloc_Alias;
                                pIO_Info->Decode = pTmpIO->IOD_Alloc_Decode;
                                pResDesc->GetOwnerName(pIO_Info->OwnerName);
                                m_List.Add(pIO_Info);
                            }
                            catch ( ... )
                            {
                                delete pIO_Info;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

                        break;

			    	case ResType_Mem:
                        MEM_INFO  *pMem_Info;
                        MEM_DES  *pTmpMem;
                        pMem_Info = new MEM_INFO;

                        if (pMem_Info != NULL)
                        {
                            try
                            {
                                pTmpMem = (MEM_DES*) pResDesc->GetResource();

						        pMem_Info->DeviceType = sClass;
                 		        pMem_Info->StartingAddress = pTmpMem->MD_Alloc_Base;
                 		        pMem_Info->EndingAddress = pTmpMem->MD_Alloc_End;
                                pResDesc->GetOwnerName(pMem_Info->OwnerName);
                                pMem_Info->MemoryType = GetMemoryType(pFullDescriptor, dwCount, pTmpMem->MD_Alloc_Base);

			    		        m_List.Add(pMem_Info);
                            }
                            catch ( ... )
                            {
                                delete pMem_Info;
                                throw ;
                            }
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

				    	break;


				}	// SWITCH
			}	// IF !IsIgnored

		}	// For EnumResources

		resourceList.EndEnum();

	}	// IF BeginEnum()

    return fRc;
}
////////////////////////////////////////////////////////////////////////
void CConfigManager::ResetList()
{
   IO_INFO  *pIOInfo;
   IRQ_INFO  *pIRQInfo;
   DMA_INFO  *pDMAInfo;
   MEM_INFO  *pMemInfo;

   int nNum =  m_List.GetSize();

   for( int i=0; i < nNum; i++ ){
      switch (m_dwTypeToGet) {

         case ResType_DMA:
            pDMAInfo = ( DMA_INFO *) m_List.GetAt(i);
            delete pDMAInfo;
            break;

         case ResType_IRQ:
            pIRQInfo = ( IRQ_INFO *) m_List.GetAt(i);
            delete pIRQInfo;
            break;

         case ResType_IO:
            pIOInfo = ( IO_INFO *) m_List.GetAt(i);
            delete pIOInfo;
            break;

         case ResType_Mem:
            pMemInfo = ( MEM_INFO *) m_List.GetAt(i);
            delete pMemInfo;
            break;

         default:
            ASSERT_BREAK(0);
            break;
      }
   }
   m_List.RemoveAll();
}
////////////////////////////////////////////////////////////////////////
BOOL CConfigManager::RefreshList()
{
    BOOL bRc = FALSE;
    //===========================================================
    //  Reset lists
    //===========================================================
    ResetList();

	// Get all the available devices and check each of them for resources used
	CDeviceCollection	deviceList;

	if ( GetDeviceList( deviceList ) )
	{
		REFPTR_POSITION	pos;

		if ( deviceList.BeginEnum( pos ) )
		{

			CConfigMgrDevicePtr	pDevice;

			for ( pDevice.Attach(deviceList.GetNext( pos )) ;
                  pDevice != NULL;
                  pDevice.Attach(deviceList.GetNext( pos )))
			{
				BuildListsForThisDevice(pDevice);
			}

			// For every begin, there is an End
			deviceList.EndEnum();

		}	// BeginEnum

		bRc = TRUE;
	}

	return bRc;

/*
    //===========================================================
    //  Enumerate all
    //===========================================================
    CRegistry Reg;
    CHString sDevice;

    if( ERROR_SUCCESS == Reg.OpenAndEnumerateSubKeys(HKEY_DYN_DATA, "Config Manager\\Enum", KEY_READ )){

        while( ERROR_SUCCESS == Reg.GetCurrentSubKeyName(sDevice) ){

            //===========================================================
	        // Since we're keeping back pointers to the Device Object,
	        // new him, rather than keeping him on the stack so we're
	        // not dependent on the order of destruction as to how
	        // safe we are.
            //===========================================================
	        CConfigMgrDevice *pDevice = new CConfigMgrDevice(sDevice,m_dwTypeToGet);
            if ( NULL != pDevice ){
                if( !BuildListsForThisDevice(pDevice) ){
		        // We're done with this pointer
                   delete pDevice;
                }
                // otherwise ptr is deleted after device is added to list
	        }	// IF NULL != pDevice
            bRc = TRUE;
			if( Reg.NextSubKey() != ERROR_SUCCESS ){
				break;
			}

        }
    }
    return bRc;
*/
}

// valid properties for filtering
//#define CM_DRP_DEVICEDESC                  (0x00000001) // DeviceDesc REG_SZ property (RW)
//#define CM_DRP_SERVICE                     (0x00000005) // Service REG_SZ property (RW)
//#define CM_DRP_CLASS                       (0x00000008) // Class REG_SZ property (RW)
//#define CM_DRP_CLASSGUID                   (0x00000009) // ClassGUID REG_SZ property (RW)
//#define CM_DRP_DRIVER                      (0x0000000A) // Driver REG_SZ property (RW)
//#define CM_DRP_MFG                         (0x0000000C) // Mfg REG_SZ property (RW)
//#define CM_DRP_FRIENDLYNAME                (0x0000000D) // FriendlyName REG_SZ property (RW)
//#define CM_DRP_LOCATION_INFORMATION        (0x0000000E) // LocationInformation REG_SZ property (RW)
//#define CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME (0x0000000F) // PhysicalDeviceObjectName REG_SZ property (R)
//#define CM_DRP_MIN                         (0x00000001)
//#define CM_DRP_MAX                         (0x00000017)

BOOL CConfigManager::GetDeviceList( CDeviceCollection& deviceList, LPCWSTR pszFilter/*=NULL*/, ULONG ulProperty/*=CM_DRP_MAX*/ )
{
	CONFIGRET		cr = CR_INVALID_POINTER;

	// Dump the list first
	deviceList.Empty();

	DEVNODE dnRoot;
	CConfigMgrAPI*	t_pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	try
	{
		if ( t_pconfigmgr )
		{
			if ( CR_SUCCESS == ( cr = t_pconfigmgr->CM_Locate_DevNode( &dnRoot, NULL, 0 ) ) )
			{
				DEVNODE dnFirst;
				if ( CR_SUCCESS == ( cr = t_pconfigmgr->CM_Get_Child( &dnFirst, dnRoot, 0 ) ) )
				{
					// This should only fail in case we are unable to allocate a device
					if ( !WalkDeviceTree( dnFirst, deviceList, pszFilter, ulProperty, t_pconfigmgr ) )
					{
						cr = CR_OUT_OF_MEMORY;
					}
				}
			}

			CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, t_pconfigmgr ) ;
			t_pconfigmgr = NULL ;
		}
	}
	catch ( ... )
	{
		if ( t_pconfigmgr )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, t_pconfigmgr ) ;
			t_pconfigmgr = NULL ;
		}
		throw ;
	}

	return ( CR_SUCCESS == cr );
}

// This device MUST be Released!
BOOL CConfigManager::LocateDevice( LPCWSTR pszDeviceID, CConfigMgrDevice **ppCfgMgrDevice )
{
	CONFIGRET		cr = CR_INVALID_POINTER;

    if ( (pszDeviceID != NULL) && (pszDeviceID[0] != L'\0') )
    {
	    CConfigMgrAPI*	t_pconfigmgr = ( CConfigMgrAPI *) CResourceManager::sm_TheResourceManager.GetResource ( guidCFGMGRAPI, NULL ) ;
	    try
	    {
		    if ( t_pconfigmgr )
		    {
			    if ( NULL != ppCfgMgrDevice )
			    {

				    DEVNODE dnRoot;

				    if ( CR_SUCCESS == ( cr = t_pconfigmgr->CM_Locate_DevNode( &dnRoot, bstr_t(pszDeviceID), 0 ) ) )
				    {
					    *ppCfgMgrDevice = new CConfigMgrDevice( dnRoot, m_dwTypeToGet );

					    if ( NULL == *ppCfgMgrDevice )
					    {
						    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
					    }
				    }

			    }	// IF NULL != ppCfgMgrDevice

			    CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, t_pconfigmgr ) ;
			    t_pconfigmgr = NULL ;
		    }
	    }
	    catch ( ... )
	    {
		    if ( t_pconfigmgr )
		    {
			    CResourceManager::sm_TheResourceManager.ReleaseResource ( guidCFGMGRAPI, t_pconfigmgr ) ;
			    t_pconfigmgr = NULL ;
		    }
		    throw ;
	    }
    }

	return ( CR_SUCCESS == cr );
}

BOOL CConfigManager::WalkDeviceTree( DEVNODE dn, CDeviceCollection& deviceList, LPCWSTR pszFilter, ULONG ulFilterProperty, CConfigMgrAPI *a_pconfigmgr )
{
    BOOL fReturn = TRUE;

    // While it would make more sense to check the filter in WalkDeviceTree2,
    // we can't.  Config manager sometimes has a loop in its nodes.  As a result,
    // we need to be checking the entire list for a loop, so we need to apply
    // the filter here.

    if ( NULL == pszFilter)
    {
        // Load ALL the nodes
        fReturn = WalkDeviceTree2(dn, deviceList, a_pconfigmgr );
    }
    else
    {
        CDeviceCollection deviceList2;
        CConfigMgrDevicePtr	pDevice;
        fReturn = WalkDeviceTree2(dn, deviceList2, a_pconfigmgr );

        if (fReturn)
        {
            // Walk all the nodes looking for ones that match the filter.  Copy the matches
            // to the passed in array.

            CHString strFilterValue;
            DWORD dwSize = deviceList2.GetSize();
            for (int x=0; x < dwSize; x++)
            {
                pDevice.Attach(deviceList2.GetAt(x));
                // Apply our filter, and save the device pointer to the list only
                // if the device property value is the same as the filter.

                if ( pDevice->GetStringProperty( ulFilterProperty, strFilterValue ) )
                {
                    if ( strFilterValue.CompareNoCase( pszFilter ) == 0 )
                    {
                        fReturn = deviceList.Add( pDevice );
                    }
                }
            }
        }
    }

    return fReturn;
}

BOOL CConfigManager::WalkDeviceTree2( DEVNODE dn, CDeviceCollection& deviceList, CConfigMgrAPI *a_pconfigmgr )

{
	BOOL				fReturn = TRUE;	// Assume TRUE, the only failure is where we
										// beef allocating a device.
    BOOL                fIsLoop = FALSE; // Config manager has a bug that causes a loop in device lists<sigh>
    CConfigMgrDevicePtr	pDevice;
//	CHString			strFilterValue;
    DEVNODE				dnSibling,
						dnChild;

	// We're walking the list for siblings and children.  Waliing for siblings
	// is done in the context of the following loop, since siblings are at
	// the same level in the tree.  Walking for children is, of course, recursive.

    do
    {
		// Store siblings, since we will proceed from it to the next
		// sibling.

		if ( CR_SUCCESS != a_pconfigmgr->CM_Get_Sibling( &dnSibling, dn, 0 ) )
		{
			dnSibling = NULL;
		}

		// Allocate a new device, and if it passes through our filter, or if
		// there is no filter, go ahead and store the device in the device collection.

		pDevice.Attach(new CConfigMgrDevice( dn, m_dwTypeToGet ));

		if	( NULL != pDevice )
		{

            if (deviceList.GetSize() > CFGMGR_WORRY_SIZE)
            {
                fIsLoop = CheckForLoop(deviceList, pDevice);
            }

            if (!fIsLoop)
            {
                // While it would make more sense to check the filter in WalkDeviceTree2,
                // we can't.  Config manager sometimes has a loop in its nodes.  As a result,
                // we need to be checking the entire list for a loop, so we need to apply
                // the filter here.

				fReturn = deviceList.Add( pDevice );
            }

		}	// IF NULL != pszDevice
		else
		{
			// We just beefed on memory, so bail out while the gettin's good
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

		// If we have a child, we must walk recursively.
		// Note that fReturn of FALSE supercedes all of this.

		if ( fReturn &&	!fIsLoop && CR_SUCCESS == a_pconfigmgr->CM_Get_Child( &dnChild, dn, 0 ) )
		{
			fReturn = WalkDeviceTree2( dnChild, deviceList, a_pconfigmgr );
		}

		// The new active node will be our sibling.
		dn = dnSibling;

    } while ( fReturn && NULL != dn && !fIsLoop );

    return fReturn;
}

// Check to see if pInDevice already exists in deviceList
BOOL CConfigManager::CheckForLoop(CDeviceCollection& deviceList, CConfigMgrDevice *pInDevice)
{
    DWORD dwSize, x, y;
    BOOL bIsLoop = FALSE;
    CConfigMgrDevicePtr pDevice1;
    CConfigMgrDevicePtr pDevice2;

    // Get the list size
    dwSize = deviceList.GetSize()-1;

    // If it is in here, it is probably close to the end, let's walk backward
    for (x = dwSize; ((x > 0) && (!bIsLoop)); x--)
    {
        pDevice1.Attach(deviceList.GetAt(x));

        // This compares the device nodes (see CConfigMgrDevice)
        if (*pDevice1 == *pInDevice)
        {
            // Yup, there's a loop
            bIsLoop = TRUE;
        }
    }

    // If there is a loop, let's drop off the duplicated elements
    if (bIsLoop)
    {
        // Remember, x get decremented one more time from the last loop
        y = dwSize;
        do {
            pDevice1.Attach(deviceList.GetAt(x--));
            pDevice2.Attach(deviceList.GetAt(y--));
        } while ((*pDevice1 == *pDevice2) && (x > 0));

        // Delete all the duplicate elements
        y++;
        for (x = dwSize; x > y; x--)
        {
            deviceList.Remove(x);
        }
    }

    return bIsLoop;
}

BOOL CConfigManager::GetDeviceListFilterByClass( CDeviceCollection& deviceList, LPCWSTR pszFilter )
{
#ifdef NTONLY
    if (IsWinNT5())
    {
        CHString sClassName(pszFilter);
        sClassName.MakeUpper();
        WCHAR cGuid[128];

        StringFromGUID2(s_ClassMap[sClassName], cGuid, sizeof(cGuid));

	    return GetDeviceList( deviceList, cGuid, CM_DRP_CLASSGUID );
    }
    else
    {
    	return GetDeviceList( deviceList, pszFilter, CM_DRP_CLASS );
    }

#else
	return GetDeviceList( deviceList, pszFilter, CM_DRP_CLASS );
#endif
}

// Given a FULL_RESOURCE_DESCRIPTOR, find the specified IRQ number, and return its vector
DWORD CConfigManager::GetIRQVector(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwFullCount, DWORD dwIRQNum)
{
    if	(NULL != pFullDescriptor)
    {
        PCM_PARTIAL_RESOURCE_LIST pPartialList ;

        for (DWORD x=0; x < dwFullCount; x++)
        {
            pPartialList = &pFullDescriptor->PartialResourceList ;

            for (DWORD y = 0; y < pPartialList->Count; y++)
            {
                PCM_PARTIAL_RESOURCE_DESCRIPTOR pDescriptor = &pPartialList->PartialDescriptors[y];

                if ( (CmResourceTypeInterrupt == pDescriptor->Type) &&
                     ( pDescriptor->u.Interrupt.Level == dwIRQNum)
                   )
                {
                    return pDescriptor->u.Interrupt.Vector;
                }
            }

            pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) &pPartialList->PartialDescriptors[pPartialList->Count] ;

        }

        ASSERT_BREAK(0);

    }

    return 0xffffffff;
}

// Given a FULL_RESOURCE_DESCRIPTOR, find the specified DMA channel, and return its port
DWORD CConfigManager::GetDMAPort(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwFullCount, DWORD dwChannel)
{
	if	(NULL != pFullDescriptor)
    {
        PCM_PARTIAL_RESOURCE_LIST pPartialList ;

        for (DWORD x=0; x < dwFullCount; x++)
        {
            pPartialList = &pFullDescriptor->PartialResourceList ;

            for (DWORD y = 0; y < pPartialList->Count; y++)
            {
                PCM_PARTIAL_RESOURCE_DESCRIPTOR pDescriptor = &pPartialList->PartialDescriptors[y];

                if ( (CmResourceTypeDma == pDescriptor->Type) &&
                     ( pDescriptor->u.Dma.Channel == dwChannel)
                   )
                {
                    return pDescriptor->u.Dma.Port;
                }
            }

            pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) &pPartialList->PartialDescriptors[pPartialList->Count] ;
        }

        ASSERT_BREAK(0);

    }

    return 0xffffffff;
}

// Given a FULL_RESOURCE_DESCRIPTOR, find the specified startingaddress, and return its MemoryType
LPCWSTR CConfigManager::GetMemoryType(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwCount, ULONGLONG ulStartAddress)
{
	if	(NULL != pFullDescriptor)
    {
        PCM_PARTIAL_RESOURCE_LIST pPartialList ;

        for (DWORD x=0; x < dwCount; x++)
        {
            pPartialList = &pFullDescriptor->PartialResourceList ;

            for (DWORD y = 0; y < pPartialList->Count; y++)
            {
                PCM_PARTIAL_RESOURCE_DESCRIPTOR pDescriptor = &pPartialList->PartialDescriptors[y];

                LARGE_INTEGER liTemp;   // Used to avoid 64bit alignment problems

                liTemp.HighPart = pDescriptor->u.Memory.Start.HighPart;
                liTemp.LowPart = pDescriptor->u.Memory.Start.LowPart;

                if ( (CmResourceTypeMemory == pDescriptor->Type) &&
                     ( liTemp.QuadPart == ulStartAddress)
                   )
                {
                    switch(pDescriptor->Flags)
	                {
                        case CM_RESOURCE_MEMORY_READ_WRITE :
		                {
			                return IDS_MTReadWrite;
		                }

                        case CM_RESOURCE_MEMORY_READ_ONLY:
		                {
			                return IDS_MTReadOnly;
		                }

                        case CM_RESOURCE_MEMORY_WRITE_ONLY:
		                {
			                return IDS_MTWriteOnly;
		                }

                        case CM_RESOURCE_MEMORY_PREFETCHABLE:
		                {
			                return IDS_MTPrefetchable;
		                }
                    }

                    return L"";
                }
            }

            pFullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) &pPartialList->PartialDescriptors[pPartialList->Count] ;
        }

        ASSERT_BREAK(0);

    }

    return L"";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\confgmgr.h ===
//=================================================================

//

// ConfgMgr.h

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

#include <chstring.h>
#include <chptrarr.h>
#include "refptr.h"
#include "poormansresource.h"
//#include <cfgmgrdevice.h>
#include "resourcedesc.h"
#include "cfgmgrdevice.h"
#include "irqdesc.h"
#include "dmadesc.h"
#include "devdesc.h"
#include "configmgrapi.h"

#define CFGMGR_WORRY_SIZE 250
typedef std::map<CHString, _GUID> STRING2GUID;

typedef struct _IO_INFO{
    DWORD StartingAddress;
    DWORD EndingAddress;
    DWORD Alias;
    DWORD Decode;
    CHString OwnerName;
    CHString DeviceType;
} IO_INFO;


typedef struct _DMA_INFO{
    DWORD Channel;
    DWORD ChannelWidth;
    CHString OwnerDeviceId;
    CHString OwnerName;
    DWORD OEMNumber;
    CHString DeviceType;
    DWORD Port;
} DMA_INFO;

typedef struct _IRQ_INFO{
    BOOL Shareable;
    DWORD IRQNumber;
    CHString OwnerDeviceId;
    CHString OwnerName;
    DWORD OEMNumber;
    CHString DeviceType;
    DWORD Vector;
} IRQ_INFO;

typedef struct _MEM_INFO{
    DWORD StartingAddress;
    DWORD EndingAddress;
    CHString OwnerName;
    CHString DeviceType;
    CHString MemoryType;
} MEM_INFO;

class CConfigManager
{
    public:

		// The Type to get parameter should be discarded whenever we get a chance.
        CConfigManager( DWORD dwTypeToGet = ResType_All );
        ~CConfigManager()                   { ResetList();}

		//////////////////////////////////////////////////////////////////
		//	The following functions are LEGACY!  Phase these out ASAP!	//
		//	DO NOT USE!													//
		//////////////////////////////////////////////////////////////////

        BOOL BuildListsForThisDevice(CConfigMgrDevice *pDevice);
        BOOL RefreshList();

        inline IRQ_INFO * GetIRQ(int i)    {  return(( IRQ_INFO * ) m_List.GetAt(i));}
        inline DMA_INFO * GetDMA(int i)    {  return(( DMA_INFO * ) m_List.GetAt(i));}
        inline IO_INFO  * GetIO(int i)     {  return(( IO_INFO * )  m_List.GetAt(i));}
        inline MEM_INFO * GetMem(int i)    {  return(( MEM_INFO * ) m_List.GetAt(i));}

        inline int GetTotal()   { return m_List.GetSize(); }

		//////////////////////////////
		//	End Legacy functions	//
		//////////////////////////////

		BOOL GetDeviceList( CDeviceCollection& deviceList, LPCWSTR pszFilter = NULL, ULONG ulProperty = CM_DRP_MAX );
		BOOL LocateDevice( LPCWSTR pszDeviceID, CConfigMgrDevice** ppCfgMgrDevice );

		// Device List Helper functions
		BOOL GetDeviceListFilterByClass( CDeviceCollection& deviceList, LPCWSTR pszFilter );
		BOOL GetDeviceListFilterByService( CDeviceCollection& deviceList, LPCWSTR pszFilter );
		BOOL GetDeviceListFilterByDriver( CDeviceCollection& deviceList, LPCWSTR pszFilter );
		BOOL GetDeviceListFilterByClassGUID( CDeviceCollection& deviceList, LPCWSTR pszFilter );

        static STRING2GUID	s_ClassMap;

    private:

		// Legacy function
        void ResetList();

        static BOOL s_ClassIsValid;

        DWORD GetIRQVector(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwCount, DWORD dwIRQNum);
        LPCWSTR GetMemoryType(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwCount, ULONGLONG ulStartAddress);
        DWORD GetDMAPort(PCM_FULL_RESOURCE_DESCRIPTOR pFullDescriptor, DWORD dwCount, DWORD dwChannel);

		BOOL WalkDeviceTree( DEVNODE dn, CDeviceCollection& deviceList, LPCWSTR pszFilter, ULONG ulFilterProperty, CConfigMgrAPI *a_pconfigmgr );
		BOOL WalkDeviceTree2( DEVNODE dn, CDeviceCollection& deviceList,  CConfigMgrAPI *a_pconfigmgr ) ;

		// Legacy variables
        CHPtrArray m_List;
        DWORD m_dwTypeToGet;
        BOOL CheckForLoop(CDeviceCollection& deviceList, CConfigMgrDevice* pDevice);
};

// Device List Helper functions
inline BOOL CConfigManager::GetDeviceListFilterByService( CDeviceCollection& deviceList, LPCWSTR pszFilter )
{
	return GetDeviceList( deviceList, pszFilter, CM_DRP_SERVICE );
}

inline BOOL CConfigManager::GetDeviceListFilterByDriver( CDeviceCollection& deviceList, LPCWSTR pszFilter )
{
	return GetDeviceList( deviceList, pszFilter, CM_DRP_DRIVER );
}

inline BOOL CConfigManager::GetDeviceListFilterByClassGUID( CDeviceCollection& deviceList, LPCWSTR pszFilter )
{
	return GetDeviceList( deviceList, pszFilter, CM_DRP_CLASSGUID );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\configmgrapi.h ===
//=================================================================

//

// CfgMgr32.h

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	__CFGMGR32_H__
#define	__CFGMGR32_H__

extern "C"
{
#include <cfgmgr32.h>
}

#ifdef WIN9XONLY
#include "Cim32NetApi.h"
#endif

#include "sms95lanexp.h"

/**********************************************************************************************************
 * #includes to Register this class with the CResourceManager. 
 **********************************************************************************************************/
#include "ResourceManager.h"
#include "TimedDllResource.h"
extern const GUID guidCFGMGRAPI ;


typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_CONNECT_MACHINEA)	(	PCSTR		UNCServerName,
																	PHMACHINE	phMachine
																);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_DISCONNECT_MACHINE)	(	HMACHINE	hMachine
																	);
typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_LOCATE_DEVNODE)	(	PDEVINST	pdnDevInst,
																	TCHAR       *pDeviceID,
																	ULONG		ulFlags
																	);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_PARENT)		(	PDEVINST	pdnDevInst,
																	DEVINST		dnDevInst,
																	ULONG		ulFlags
																);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_CHILD)			(	PDEVINST	pdnDevInst,
																	DEVINST		dnDevInst,
																	ULONG		ulFlags
																);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_SIBLING)		(	PDEVINST	pdnDevInst,
																	DEVINST		dnDevInst,
																	ULONG		ulFlags
																);


typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTY)		(	DEVINST	dnDevInst,
																						ULONG	ulProperty,
																						PULONG	pulRegDataType,
																						PVOID	Buffer,
																						PULONG	pulLength,
																						ULONG	ulFlags
																					);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVNODE_STATUS)					(	PULONG	pulStatus,
																						PULONG	pulProblemNumber,
																						DEVINST	dnDevInst,
																						ULONG	ulFlags
																					);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_FIRST_LOG_CONF)					(	PLOG_CONF plcLogConf,
																						DEVINST   dnDevInst,
																						ULONG     ulFlags
																					);

typedef	CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_NEXT_RES_DES)						(	PRES_DES    prdResDes,
																						RES_DES     rdResDes,
																						RESOURCEID  ForResource,
																						PRESOURCEID pResourceID,
																						ULONG       ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_RES_DES_DATA)						(	RES_DES  rdResDes,
																						PVOID    Buffer,
																						ULONG    BufferLen,
																						ULONG    ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_RES_DES_DATA_SIZE)					(	PULONG   pulSize,
																						RES_DES  rdResDes,
																						ULONG    ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_FREE_LOG_CONF_HANDLE)					(	LOG_CONF  lcLogConf
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_FREE_RES_DES_HANDLE)					(	RES_DES    rdResDes
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVICE_IDA)						(	DEVNODE		dnDevNode,
																						PCHAR		Buffer,
																						ULONG		BufferLen,
																						ULONG		ulFlags
																					);

typedef CONFIGRET	(WINAPI*	PCFGMGR32_CM_GET_DEVICE_ID_SIZE)					(	PULONG		pulLen,
																						DEVNODE		dnDevNode,
																						ULONG		ulFlags
																					);

class CConfigMgrAPI : public CTimedDllResource
{
public:

	CConfigMgrAPI();
	~CConfigMgrAPI();

	BOOL IsValid () ;

	CONFIGRET	CM_Connect_MachineA( PCSTR UNCServerName, PHMACHINE phMachine );
	CONFIGRET	CM_Disconnect_Machine( HMACHINE hMachine );
	CONFIGRET	CM_Get_Parent( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_Child( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_Sibling( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags );
	CONFIGRET	CM_Locate_DevNode( PDEVINST pdnDevInst, TCHAR *pDeviceID, ULONG ulFlags );
	CONFIGRET	CM_Get_DevNode_Registry_PropertyA( DEVINST dnDevInst, ULONG ulProperty, PULONG pulRegDataType,
													PVOID Buffer, PULONG pulLength, ULONG ulFlags );
	CONFIGRET	CM_Get_DevNode_Status( PULONG pulStatus, PULONG pulProblemNumber, DEVINST dnDevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_First_Log_Conf( PLOG_CONF plcLogConf, DEVINST dnDevInst, ULONG ulFlags );
	CONFIGRET	CM_Get_Next_Res_Des( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags );
	CONFIGRET	CM_Get_Res_Des_Data( RES_DES rdResDes, PVOID Buffer, ULONG BufferLen, ULONG ulFlags );
	CONFIGRET	CM_Get_Res_Des_Data_Size( PULONG pulSize, RES_DES rdResDes, ULONG ulFlags );
	CONFIGRET	CM_Free_Log_Conf_Handle( LOG_CONF lcLogConf );
	CONFIGRET	CM_Free_Res_Des_Handle( RES_DES rdResDes );
	CONFIGRET	CM_Get_Device_IDA(	DEVNODE dnDevNode, PCHAR Buffer, ULONG BufferLen, ULONG ulFlags );
	CONFIGRET	CM_Get_Device_ID_Size( PULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags );

	// Win 95/98 only
#ifdef WIN9XONLY
	CONFIGRET	CM_Get_Bus_Info( DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags );

    // So far these are only needed on 9x.
    CONFIGRET   CM_Query_Arbitrator_Free_Data(PVOID pData, ULONG DataLen, DEVINST dnDevInst, RESOURCEID ResourceID, ULONG ulFlags);
    CONFIGRET   CM_Delete_Range(ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags);
    CONFIGRET   CM_First_Range(RANGE_LIST rlh, LPULONG pulStart, LPULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags);
    CONFIGRET   CM_Next_Range(PRANGE_ELEMENT preElement, LPULONG pulStart, LPULONG pullEnd, ULONG ulFlags);
    CONFIGRET   CM_Free_Range_List(RANGE_LIST rlh, ULONG ulFlags);
#endif

private:

#ifdef NTONLY
	HINSTANCE	m_hConfigMgrDll;
#endif
#ifdef WIN9XONLY
    CCim32NetApi* m_pCim32NetApi;
#endif

#ifdef NTONLY
	// 32-bit Config Manager pointers
	PCFGMGR32_CM_CONNECT_MACHINEA		m_pCM_Connect_MachineA;
	PCFGMGR32_CM_DISCONNECT_MACHINE		m_pCM_Disconnect_Machine;
	PCFGMGR32_CM_LOCATE_DEVNODE 		m_pCM_Locate_DevNode;
	PCFGMGR32_CM_GET_CHILD				m_pCM_Get_Child;
	PCFGMGR32_CM_GET_SIBLING			m_pCM_Get_Sibling;
	PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTY		m_pCM_Get_DevNode_Registry_Property;
	PCFGMGR32_CM_GET_DEVNODE_STATUS		m_pCM_Get_DevNode_Status;
	PCFGMGR32_CM_GET_FIRST_LOG_CONF		m_pCM_Get_First_Log_Config;
	PCFGMGR32_CM_GET_NEXT_RES_DES		m_pCM_Get_Next_Res_Des;
	PCFGMGR32_CM_GET_RES_DES_DATA		m_pCM_Get_Res_Des_Data;
	PCFGMGR32_CM_GET_RES_DES_DATA_SIZE	m_pCM_Get_Res_Des_Data_Size;
	PCFGMGR32_CM_FREE_LOG_CONF_HANDLE	m_pCM_Free_Log_Conf_Handle;
	PCFGMGR32_CM_FREE_RES_DES_HANDLE	m_pCM_Free_Res_Des_Handle;
	PCFGMGR32_CM_GET_DEVICE_IDA			m_pCM_Get_Device_IDA;
	PCFGMGR32_CM_GET_DEVICE_ID_SIZE		m_pCM_Get_Device_ID_Size;
	PCFGMGR32_CM_GET_PARENT				m_pCM_Get_Parent;
#endif

#ifdef WIN9XONLY
	// 16-bit Config Manager Thunking Pass-Thrus
/*
	PCIM32THK_CM_LOCATE_DEVNODE			m_pCM16_Locate_DevNode;
	PCIM32THK_CM_GET_CHILD				m_pCM16_Get_Child;
	PCIM32THK_CM_GET_SIBLING			m_pCM16_Get_Sibling;
	PCIM32THK_CM_READ_REGISTRY_VALUE	m_pCM16_Read_Registry_Value;
	PCIM32THK_CM_GET_DEVNODE_STATUS		m_pCM16_Get_DevNode_Status;
	PCIM32THK_CM_GET_DEVICE_ID			m_pCM16_Get_Device_ID;
	PCIM32THK_CM_GET_DEVICE_ID_SIZE		m_pCM16_Get_Device_ID_Size;
	PCIM32THK_CM_GET_FIRST_LOG_CONF		m_pCM16_Get_First_Log_Conf;
	PCIM32THK_CM_GET_NEXT_RES_DES		m_pCM16_Get_Next_Res_Des;
	PCIM32THK_CM_GET_RES_DES_DATA_SIZE	m_pCM16_Get_Res_Des_Data_Size;
	PCIM32THK_CM_GET_RES_DES_DATA		m_pCM16_Get_Res_Des_Data;
	PCIM32THK_CM_GET_BUS_INFO			m_pCM16_Get_Bus_Info;
	PCIM32THK_CM_GET_PARENT				m_pCM16_Get_Parent;
*/
#endif

	const static char*					s_pszRegistryStrings[];
	static ULONG						s_pszRegistryValueTypes[];
};

// CIM16 registry ULONG to Str conversions
#define CM_DRP_DEVICEDESC_S						"DeviceDesc" // DeviceDesc REG_SZ property (RW)
#define CM_DRP_HARDWAREID_S						"HardwareID" // HardwareID REG_MULTI_SZ property (RW)
#define CM_DRP_COMPATIBLEIDS_S					"CompatibleIDs" // CompatibleIDs REG_MULTI_SZ property (RW)
#define CM_DRP_NTDEVICEPATHS_S					"NtDevicePaths" // NTDevicePaths (NT4)
#define CM_DRP_SERVICE_S 						"Service" // Service REG_SZ property (RW)
#define CM_DRP_CONFIGURATION_S					"Configuration" // Configuration (NT4)
#define CM_DRP_CONFIGURATIONVECTOR_S			"ConfigurationVector" // ConfigurationVector(NT4)
#define CM_DRP_CLASS_S							"Class" // Class REG_SZ property (RW)
#define CM_DRP_CLASSGUID_S						"ClassGUID" // ClassGUID REG_SZ property (RW)
#define CM_DRP_DRIVER_S							"Driver" // Driver REG_SZ property (RW)
#define CM_DRP_CONFIGFLAGS_S					"ConfigFlags" // ConfigFlags REG_DWORD property (RW)
#define CM_DRP_MFG_S							"Mfg" // Mfg REG_SZ property (RW)
#define CM_DRP_FRIENDLYNAME_S					"FriendlyName" // FriendlyName REG_SZ property (RW)
#define CM_DRP_LOCATION_INFORMATION_S			"LocationInformation" // LocationInformation REG_SZ property (RW)
#define CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME_S	"PhysicalDeviceObjectName" // PhysicalDeviceObjectName REG_SZ property (R)
#define CM_DRP_CAPABILITIES_S					"Capabilities" // Capabilities REG_DWORD property (R)
#define CM_DRP_UI_NUMBER_S						"UiNumber" // UiNumber REG_DWORD property (R)
#define CM_DRP_UPPERFILTERS_S					"UpperFilters" // UpperFilters REG_MULTI_SZ property (RW)
#define CM_DRP_LOWERFILTERS_S					"LowerFilters" // LowerFilters REG_MULTI_SZ property (RW)
#define CM_DRP_BUSTYPEGUID_S					"BusTypeGuid" // Bus Type Guid, GUID, (R)
#define CM_DRP_LEGACYBUSTYPE_S					"LegacyBusType" // Legacy bus type, INTERFACE_TYPE, (R)
#define CM_DRP_BUSNUMBER_S						"BusNumber" // Bus Number, DWORD, (R)
#define CM_DRP_ENUMERATOR_NAME_S				"Enumerator" // Enumerator Name REG_SZ property (R)
#define CM_DRP_MIN_S							""			// Min
#define CM_DRP_MAX_S							""			// Max

#endif //__CFGMGRCOMPUTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cthread.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CThreadPool.cpp -- Thread pool class

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//============================================================================

#ifndef __CTHREAD_H__
#define __CTHREAD_H__

#include "CGlobal.h"
#include "CKernel.h"
#include "CEvent.h"
#include <tchar.h>

#define THREADPROC_MAX_ALIVE_WAIT    1000   // milliseconds (only 1 s since we don't want to wait very long if we have signaled that we should stop

typedef unsigned (__stdcall *BTEX_START_ROUTINE)(LPVOID lpThreadParameter);
typedef BTEX_START_ROUTINE LPBTEX_START_ROUTINE;


// this is a function used to kick-start the thread...
unsigned __stdcall ThreadProcWrapper(LPVOID lParam);



class CThread : public CKernel 
{
public:
    // only the thread handler reference needs to 
    // be supplied since the other arguments have default values...
    CThread(LPCTSTR tstrThreadName = _T("NO_NAME"),
            LPBTEX_START_ROUTINE pfn = NULL,
            LPVOID pdata = NULL,
            DWORD dwCreationFlags = 0, 
            LPSECURITY_ATTRIBUTES lpSecurity = NULL,
            unsigned uStackSize = 0); 

    ~CThread();

    // Declare friends and family
    friend unsigned __stdcall ThreadProcWrapper(LPVOID lParam);
    
    // suspend the thread...
    DWORD Suspend(void);

    // resume the thread...
    DWORD Resume(void);

    // terminate the thread...
    BOOL Terminate( DWORD dwExitCode);

    // read a thread's exit code...
    BOOL GetExitCode( DWORD *pdwExitCode);

    // set a thread's priority...
    BOOL SetPriority( int nPriority);

    // read a thread's priority...
    int GetPriority(void);

    // get the internal thread id...
    DWORD GetThreadId(void);

    // get the thread's text name...
    LPCTSTR GetThreadName(void);

    // set the thread proceedure
    VOID SetThreadProc(unsigned (__stdcall *lpfn)(void*));

    // set the thread proceedure data
    VOID SetThreadProcData(LPVOID lpvdata);

    // reset the m_ceAlive event:
    VOID SignalToStop();

    // signals the thread proc wrapper to run the currently set proceedure
    VOID RunThreadProc();

    // helper use to wait until the thread's proc is complete
    DWORD WaitTillThreadProcComplete(DWORD dwTimeout = INFINITE);

    // may want to have external acces to the ThreadDie event for event coordination:
    HANDLE GetThreadDieEventHandle();

    // similarly, may want to have external acces to the ThreadProcDone event for event coordination:
    HANDLE GetThreadProcDoneEventHandle();

protected:
    unsigned int m_uiThreadID;
    LPBTEX_START_ROUTINE m_lpfnThreadRoutine;
    LPVOID m_lpvThreadData;

private:
    CEvent m_ceThreadRun;
    CEvent m_ceThreadDie;
    CEvent m_ceThreadProcDone;
    TCHAR* m_tstrThreadName;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cthread.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CThreadPool.cpp -- Thread pool class

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//============================================================================
#include "precomp.h"
#include "CThread.h"

// Constructor creates a thread C++ object and
// creates the kernel thread object which begins executing
// at the pfn ...
CThread::CThread(LPCTSTR tstrThreadName,
                 LPBTEX_START_ROUTINE pfn,
                 LPVOID pdata,
                 DWORD dwCreationFlags,
                 LPSECURITY_ATTRIBUTES lpSecurity,
                 unsigned uStackSize)
        : m_lpfnThreadRoutine(pfn),
          m_lpvThreadData(pdata),
          m_ceThreadDie(TRUE,FALSE),      // manual reset (must be so for CThreadPool to function properly)
          m_ceThreadRun(FALSE,FALSE),
          m_ceThreadProcDone(TRUE,FALSE)  // manual reset (must be so for CThreadPool to function properly)
{
    // Store the thread name, if there is one...
    m_tstrThreadName = (TCHAR*) new TCHAR[(_tcslen(tstrThreadName)+1) * sizeof(TCHAR)];
    _tcscpy(m_tstrThreadName,tstrThreadName);

    // Create the thread, saving the thread HANDLE, identifier, and
    // setting the status...
    m_hHandle = (HANDLE) _beginthreadex(lpSecurity,
                                        uStackSize,
                                        ThreadProcWrapper,
                                        this,
                                        dwCreationFlags,
                                        &m_uiThreadID);

    if (CIsValidHandle(m_hHandle))
    {
        m_dwStatus = NO_ERROR;
    }
    else
    {
        // throw thread creation error...
        m_dwStatus = errno;
        ThrowError(m_dwStatus);
    }
    Sleep(0);  //allow thread to initialize
}

CThread::~CThread()
{
    delete m_tstrThreadName;
}

unsigned __stdcall ThreadProcWrapper(LPVOID lParam)
{
    DWORD dw = 4;
    DWORD dwWaitVal = -1;
    CThread* pct = (CThread*) lParam;
    if(pct == NULL)
    {
        return -4;
    }
    // Make an array of event handles for the WaitForMultipleObjects:
    HANDLE hEvents[2] = {pct->m_ceThreadRun, pct->m_ceThreadDie};


#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("Thread %s:    In ThreadProcWrapper()"), pct->m_tstrThreadName);
    LogMsg(szMsg);
}
#endif
    // Stay in this wrapper proceedure as long as not signaled to die.
    // If signaled to die, the return value will be WAIT_OBJECT_0, as
    // long as that signal occurs at the same time as or before the
    // thread is signaled to run.  If it is signaled to run first, it
    // will do so.  Since the threadrun event is an autoreset, the
    // following wait resets it, causing the function to only be called
    // once until and unless someone else sets that event.
    while((dwWaitVal = WaitForMultipleObjects(2,hEvents,FALSE,INFINITE)) == WAIT_OBJECT_0)
    {
        if(pct->m_lpfnThreadRoutine != NULL)
        {
            // We have a routine to run, so run it...
            (*(pct->m_lpfnThreadRoutine))(pct->m_lpvThreadData);

            // Signal that the thread proc has completed
            pct->m_ceThreadProcDone.Set();
            Sleep(0);
        }
    }
#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("Thread %s:    Exiting ThreadProcWrapper(), wait code was %d"), pct->m_tstrThreadName, dwWaitVal);
    LogMsg(szMsg);
}
#endif

    return dw;
}

VOID CThread::RunThreadProc()
{
    m_ceThreadRun.Set();
    Sleep(0);
}

DWORD CThread::WaitTillThreadProcComplete(DWORD dwTimeout)
{
    return WaitForSingleObject(m_ceThreadProcDone, dwTimeout);
}

// Signal to stop the thread...
VOID CThread::SignalToStop()
{
    // Signal (set) the 'die' event
    m_ceThreadDie.Set();
    Sleep(0);
}

// Obtains the thread's Die event handle.  This is useful in situations where, as in the
// case of CThreadPool's Attendent thread, the thread wrapper is waiting on that function
// to execute, but that function is waiting on something else.  We want that other function
// to be able to wait, at the same time, on a Die event.  Otherwise the wrapper, even though
// signaled to die, will wait for a potentially long time if its wrapped function is waiting
// on some other event and can't see the Die event.  Don't want to use named event since
// we could potentially have lots of threads created with this class, and how would we identify
// that we had the right thread's event?
HANDLE CThread::GetThreadDieEventHandle()
{
    return m_ceThreadDie.GetHandle();
}

// ibid.
HANDLE CThread::GetThreadProcDoneEventHandle()
{
    return m_ceThreadProcDone.GetHandle();
}

VOID CThread::SetThreadProc(unsigned (__stdcall *lpfn)(void*))
{
#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("Thread %s:    In SetThreadProc()"), m_tstrThreadName);
    LogMsg(szMsg);
}
#endif

    m_lpfnThreadRoutine = lpfn;
}

VOID CThread::SetThreadProcData(LPVOID lpvdata)
{
#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("Thread %s:    In SetThreadProcData()"), m_tstrThreadName);
    LogMsg(szMsg);
}
#endif

    m_lpvThreadData = lpvdata;
}

// Suspend the thread...
DWORD CThread::Suspend(void)
{
#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("Thread %s:    In Suspend()"), m_tstrThreadName);
    LogMsg(szMsg);
}
#endif

    return ::SuspendThread( m_hHandle);
}

// Resume the thread...
DWORD CThread::Resume(void)
{
#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("Thread %s:    In Resume()"), m_tstrThreadName);
    LogMsg(szMsg);
}
#endif

    return ::ResumeThread( m_hHandle);
}

// Terminate the thread...
BOOL CThread::Terminate( DWORD dwExitCode)
{
#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("Thread %s:    In Terminate()"), m_tstrThreadName);
    LogMsg(szMsg);
}
#endif

    return ::TerminateThread( m_hHandle, dwExitCode);
}

// Read a thread's exit code...
BOOL CThread::GetExitCode( DWORD *pdwExitCode)
{
    return ::GetExitCodeThread( m_hHandle, pdwExitCode);
}

// Set a thread's priority...
BOOL CThread::SetPriority( int nPriority)
{
    return ::SetThreadPriority( m_hHandle, nPriority);
}

// Read a thread's priority...
int CThread::GetPriority( void)
{
    return ::GetThreadPriority( m_hHandle);
}

// Return the thread's identifier...
DWORD CThread::GetThreadId(void)
{
    return static_cast<DWORD>(m_uiThreadID);
}

// Return the thread's text id...
LPCTSTR CThread::GetThreadName(void)
{
    return m_tstrThreadName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cthreadpool.h ===
//=================================================================

//

// ThreadPool.h -- thread pool class header

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//=================================================================

#ifndef __THREADPOOL_H__
#define __THREADPOOL_H__


#include "CCriticalSec.h"
#include "CThread.h"
#include <deque>
#include <tchar.h>



#define IDS_POOL_SEM_NAME       _T("PoolSemaphore")
#define POOL_DEFAULT_SIZE       5
#define POOL_TIMEOUT            INFINITE   // in milliseconds (wait time for getting a place in the pool)
#define DESTROY_POOL_MAX_WAIT   5000      // in milliseconds (wait time for destroying the pool) 


class CJob;

typedef std::deque<CJob*> CJOB_PTR_DEQUE;
typedef std::deque<CJob> CJOB_DEQUE;

unsigned _stdcall PoolAttendant(LPVOID lParam);
unsigned _stdcall PoolCleaner(LPVOID lParam);


class CThreadPool
{
    public:
        CThreadPool(LONG lPoolSize = POOL_DEFAULT_SIZE);
        ~CThreadPool();
        
        VOID DispatchQueue(LPBTEX_START_ROUTINE pfn,
                           LPVOID pdata,
                           bool fSetJobPending = TRUE);
        
        DWORD WaitTillAllJobsDone(DWORD dwTimeout = INFINITE);

        VOID SetJobsPendingEvent();

    private:
        // The Attendant is this class's best friend, and needs access to its private parts...
        friend unsigned _stdcall PoolAttendant(LPVOID lParam);
        friend unsigned _stdcall PoolCleaner(LPVOID lParam);

        CJob* GetJob();
        VOID RemoveJob();
        VOID RemoveJobsFromDeque();
        HRESULT WaitTillSwimmersDone(DWORD dwTimeout = INFINITE);
        VOID KillPool();

        HANDLE          m_hSemPool;
        LONG            m_lPoolSize;
        BOOL**          m_ppfThreadAvailIndex;
        CThread**       m_ppctPool;
        HANDLE*         m_phThreadHandleArray;
        CCriticalSec    m_csPool;
        CJOB_PTR_DEQUE  m_Jobs;
        LONG            m_lJobsPendingCount;
        CEvent          m_ceJobsPending;
        CEvent          m_ceOutOfJobs;
        CThread*        m_pctPoolAttendant;
        CThread*        m_pctPoolCleaner;
        CCriticalSec    m_csJobs;
};

class CJob
{
public:

    CJob(LPBTEX_START_ROUTINE pfn,
         LPVOID pdata)
          :  m_pfn(pfn),m_pdata(pdata)
    {
    }
    ~CJob() {}
    

    LPBTEX_START_ROUTINE m_pfn;
    LPVOID m_pdata;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cthreadpool.cpp ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CThreadPool.cpp -- Thread pool class

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    7/14/98    a-kevhu         Created
//
//============================================================================

#include "precomp.h"
#include "CThreadPool.h"
#include "CAutoLock.h"
//#include <fstream.h>

CThreadPool::CThreadPool(LONG lPoolSize)
    : m_hSemPool(NULL),
      m_lPoolSize(lPoolSize),
      m_ppfThreadAvailIndex(NULL),
      m_ppctPool(NULL),
      m_ceJobsPending(FALSE,FALSE),
      m_ceOutOfJobs(TRUE,TRUE),     // manually reset by PoolAttendant
      m_lJobsPendingCount(0L),
      m_pctPoolAttendant(NULL),
      m_pctPoolCleaner(NULL)
{
    // Allocate array used to indicate thread availability:
    m_ppfThreadAvailIndex = (BOOL**) new BOOL*[m_lPoolSize];

    // Create the pool of threads:
    m_ppctPool = (CThread**) new CThread*[m_lPoolSize];

    // Create array of thread handles:
    m_phThreadHandleArray = (HANDLE*) new HANDLE[m_lPoolSize];

    // Initialize the pool threads and threadavail and handle arrays
    for(LONG m = 0L; m < m_lPoolSize; m++)
    {
        TCHAR tstrTmp[32];
        wsprintf(tstrTmp,_T("POOL_%d"),m);
        m_ppctPool[m] = (CThread*) new CThread(tstrTmp);
        m_ppfThreadAvailIndex[m] = (BOOL*) new BOOL;
        *m_ppfThreadAvailIndex[m] = TRUE;        // Initially all threads are available
        m_phThreadHandleArray[m] = m_ppctPool[m]->GetHandle();
        Sleep(0);  // allow thread to initialize
    }

    // Create the semaphore that will control access to the pool
    m_hSemPool = CreateSemaphore(NULL,m_lPoolSize,m_lPoolSize,IDS_POOL_SEM_NAME);

    // Create Attendant and cleaner threads
    m_pctPoolAttendant = (CThread*) new CThread(_T("Attendant"),PoolAttendant,this);
    m_pctPoolCleaner = (CThread*) new CThread(_T("Cleaner"),PoolCleaner,this);

    // Now that everything is set up, run the thread that manages the pool:
    m_pctPoolAttendant->RunThreadProc();

    // and run the thread that cleans the pool:
    m_pctPoolCleaner->RunThreadProc();
    Sleep(50);  // allow all threads to reach quiescent state
}

CThreadPool::~CThreadPool()
{
#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("~CThreadPool() -> BEGINNING OF THE END..."));
    LogMsg(szMsg);
}
#endif



    // Signal the threadprocwrapper threads to stop once the proc they are
    // currently running finishes...
    for(LONG p = 0L; p < m_lPoolSize; p++)
    {
        m_ppctPool[p]->SignalToStop();
    }

    // Wait for the pool threads (threadprocwrapper functions) to finish...
    DWORD dwWait = WaitTillSwimmersDone(DESTROY_POOL_MAX_WAIT);

    // Kill the poolAttendant thread:
    m_pctPoolAttendant->SignalToStop();
    Sleep(0);

    // Kill the pool cleaner thread:
    m_pctPoolCleaner->SignalToStop();
    Sleep(0);

    // Wait for those two threads to terminate...
    HANDLE hHandles[2];
    hHandles[0] = m_pctPoolAttendant->GetThreadDieEventHandle();
    hHandles[1] = m_pctPoolCleaner->GetThreadDieEventHandle();
    if(WaitForMultipleObjects(2,hHandles, TRUE, DESTROY_POOL_MAX_WAIT) != WAIT_OBJECT_0)
    {
        // get serious... they aren't dying fast enough...
        DWORD dwExitCode = 666;
        m_pctPoolAttendant->Terminate(dwExitCode);
        m_pctPoolCleaner->Terminate(dwExitCode);
    }

    // In the meantime, back at the ranch, we may have timed out waiting
    // for the pool threads to finish, so need to force them to stop now...
    if(dwWait == WAIT_TIMEOUT)
    {
        KillPool();
    }

    // Delete all waiting jobs:
    RemoveJobsFromDeque();

    // Now we should be able to deallocate everything with impunity...
    for(LONG m = 0L; m < m_lPoolSize; m++)
    {
        delete m_ppfThreadAvailIndex[m];
        delete m_ppctPool[m];
    }
    delete [] m_ppfThreadAvailIndex;
    delete [] m_ppctPool;
    delete m_phThreadHandleArray;
    delete m_pctPoolAttendant;
    delete m_pctPoolCleaner;
    CloseHandle(m_hSemPool);
}



// DispatchQueue adds a job to the stack of jobs performed by the PoolAttendant...
VOID CThreadPool::DispatchQueue(LPBTEX_START_ROUTINE pfn,
                                 LPVOID lpvData,
                                 bool fSetJobPending)
{
    CJob* pcjob = (CJob*) new CJob(pfn,lpvData);
    CAutoLock cal(m_csJobs);
    m_Jobs.push_back(pcjob);
    if(fSetJobPending)
    {
        SetJobsPendingEvent();
    }
}

// Gives external access to the jobspending event
VOID CThreadPool::SetJobsPendingEvent()
{
    m_ceJobsPending.Set();
    Sleep(0);
}

CJob* CThreadPool::GetJob()
{
    CJob* pcj = NULL;
    CAutoLock cal(m_csJobs);
    if(!m_Jobs.empty())
    {
        pcj = m_Jobs.front();
    }
    return pcj;
}

VOID CThreadPool::RemoveJob()
{
    CAutoLock cal(m_csJobs);
    if(!m_Jobs.empty())
    {
        delete m_Jobs.front();
        m_Jobs.pop_front();
    }
}

VOID CThreadPool::RemoveJobsFromDeque()
{
    LONG lJobsRemaining = 0L;
    CAutoLock cal(m_csJobs);
    for(LONG p = 0L; p < lJobsRemaining; p++)
    {
        delete m_Jobs.front();
        m_Jobs.pop_front();
    }
}


HRESULT CThreadPool::WaitTillSwimmersDone(DWORD dwTimeout)
{
    return ::WaitForMultipleObjects(m_lPoolSize, m_phThreadHandleArray, TRUE, dwTimeout);
}

// The client ap, which presumably knows when it is done adding jobs
// to the queue, can use this function to wait until all jobs are done...
DWORD CThreadPool::WaitTillAllJobsDone(DWORD dwTimeout)
{
    DWORD dwRet = ::WaitForSingleObject(m_ceOutOfJobs,dwTimeout);
    if(dwRet == WAIT_FAILED)
    {
        dwRet = ::GetLastError();
    }
    return dwRet;
}

// Forceably kills threads from the pool
VOID CThreadPool::KillPool()
{
    DWORD dwExitCode = 666;
    // no more Mr. Nice Guy...
    for(LONG p = 0L; p < m_lPoolSize; p++)
    {
        m_ppctPool[p]->Terminate(dwExitCode);
    }
}


// This function oversees the pools activities by assigning jobs out of the
// stack of jobs into threads.  It goes dormant if there are no jobs pending.
unsigned _stdcall PoolAttendant(LPVOID lParam)
{
    CThreadPool* pctp = (CThreadPool*) lParam;
    DWORD dwRetVal = 6;
    if(pctp == NULL)
    {
        return -6;
    }
    HANDLE hEvents[2] = { pctp->m_ceJobsPending, pctp->m_pctPoolAttendant->GetThreadDieEventHandle() };
    CJob* pcjob = NULL;

#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("Starting PoolAttendant() (thread %s)"), pctp->m_pctPoolAttendant->GetThreadName());
    LogMsg(szMsg);
}
#endif

    LONG m = 0L;


    // Wait while there are jobs pending and we are not signaled to close the pool:
    while(WaitForMultipleObjects(2,hEvents,FALSE,INFINITE) == WAIT_OBJECT_0)
    {
        // The wait ended because I had a job.
        // Process jobs as long as there are jobs queued up...

#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("PoolAttendant():  I've been signaled that there are jobs..."));
    LogMsg(szMsg);
}
#endif

        while((pcjob = pctp->GetJob()) != NULL)
        {
            // Indicate that we are NOT out of work (we have a job):
            pctp->m_ceOutOfJobs.Reset();

            // Wait for the semaphore
            if(WaitForSingleObject(pctp->m_hSemPool, INFINITE) == WAIT_OBJECT_0)
            {
                pctp->m_csPool.Enter();
                {
                    // Increment index to indicate the first available thread:
                    for(m = 0L; m < pctp->m_lPoolSize && *(pctp->m_ppfThreadAvailIndex[m]) == FALSE; m++);
                    *(pctp->m_ppfThreadAvailIndex[m]) = FALSE;

#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("PoolAttendant():  assigned a job to pool slot %d"), m);
    LogMsg(szMsg);
}
#endif

                }
                pctp->m_csPool.Leave();

                // Now we have our reserved seat in the pool, so get ready to start swimming:
                pctp->m_ppctPool[m]->SetThreadProc(pcjob->m_pfn);
                pctp->m_ppctPool[m]->SetThreadProcData(pcjob->m_pdata);
                pctp->m_ppctPool[m]->RunThreadProc();
                // The Attendant doesn't need to wait for the job to finish.  He just looks for another job,
                // and then waits for space in the pool.  The PoolCleaner keeps track of when jobs are finished
                // and frees up space in the pool when they are.
            }
            // remove the job from the stack of jobs:
            pctp->RemoveJob();
        } // while there were jobs
        // For those who care, signal that we are (at least temporarily) out of work:
        pctp->m_ceOutOfJobs.Set();
        Sleep(0);  // allow that event to percolate

#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("PoolAttendant():  I just announced that I am out of jobs..."));
    LogMsg(szMsg);
}
#endif


    } // while not signaled to terminate

#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("PoolAttendant(): Exiting"));
    LogMsg(szMsg);
}
#endif

    return dwRetVal;
}


// This function cleans the pool if any pool thread's ThreadProcDone event is set.
// Since more than one could have been set at exactly the same time, this function
// checks each.
// It goes dormant if no thread's ThreadProcDone events are set and it isn't signaled
// to die.
unsigned _stdcall PoolCleaner(LPVOID lParam)
{
    CThreadPool* pctp = (CThreadPool*) lParam;
    if(pctp == NULL)
    {
        return -7;
    }
    HANDLE* phSomeoneIsDoneOrImDead = NULL;
    DWORD dwRetval = 7;
    DWORD dwDoneOrDeadVal = -1;
    bool fKeepGoing = true;

#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("Starting PoolCleaner() (thread %s)"), pctp->m_pctPoolCleaner->GetThreadName());
    LogMsg(szMsg);
}
#endif


    phSomeoneIsDoneOrImDead = (HANDLE*) new HANDLE[pctp->m_lPoolSize + 1];
    if(phSomeoneIsDoneOrImDead != NULL)
    {
        // The first p handles relate to the pool's threads
        for(LONG p = 0; p < pctp->m_lPoolSize; p++)
        {
            phSomeoneIsDoneOrImDead[p] = pctp->m_ppctPool[p]->GetThreadProcDoneEventHandle();
        }
        // The last handle is the ThreadDie event for the thread running this function (PoolCleaner)
        phSomeoneIsDoneOrImDead[p] = pctp->m_pctPoolCleaner->GetThreadDieEventHandle();

        while(fKeepGoing)
        {
            // Enter into an efficient wait state (till either signaled to die or some thread finished its work)...
            dwDoneOrDeadVal = WaitForMultipleObjects(pctp->m_lPoolSize + 1, phSomeoneIsDoneOrImDead, FALSE, INFINITE);
            // If the last handle was one of the ones set, this PoolCleaner routine should end.
            // If not, then we are good to continue.  Use wfso to check:

#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("PoolCleaner():  Indicated that someone is done or I'm dead - wait value was %d"), dwDoneOrDeadVal);
    LogMsg(szMsg);
}
#endif

            if(WaitForSingleObject(phSomeoneIsDoneOrImDead[p],0) != WAIT_OBJECT_0) // WAIT_OBJECT_0 would be set now if we had been signaled to die...
            {
                // One or more threads are done, so go through each and indicate as free those that are done
                for(LONG s = 0; s < pctp->m_lPoolSize; s++)
                {
                    // Use wfso to check the status of the event handle to find out which thread finished its work:
                    if(WaitForSingleObject(phSomeoneIsDoneOrImDead[s],0) == WAIT_OBJECT_0) // the event was signaled
                    {
                        // The status of the thread in the pool corresponding to that event can be
                        // switched to indicate it is available:
                        pctp->m_csPool.Enter();
                        {
                            *(pctp->m_ppfThreadAvailIndex[s]) = TRUE;
                            // Reset that thread's ThreadProcDone event:
                            ResetEvent(phSomeoneIsDoneOrImDead[s]);
                            Sleep(0);  // allow that event to percolate
                        }
                        pctp->m_csPool.Leave();
                        ReleaseSemaphore(pctp->m_hSemPool, 1, NULL);

#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("PoolCleaner():  released pool slot %d"), s);
    LogMsg(szMsg);
}
#endif

                    }
                }
            }  // if not signaled to die
            else //we were signaled to die
            {
                fKeepGoing = false;
            }
        } // while we should KeepGoing
        delete [] phSomeoneIsDoneOrImDead;
    }  // phSomeoneIsDoneOrImDead allocation successful


#ifdef TEST
{
    TCHAR szMsg[256];
    wsprintf(szMsg,_T("PoolCleaner():  Exiting"));
    LogMsg(szMsg);
}
#endif


    return dwRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ctoken.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved 
//
//	Created:	4/21/2000, Kevin Hughes

#include "precomp.h"
#include <vector>
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
//#include "SecUtils.h"

#include "CToken.h"



///////////////////////////////////////////////////////////////////////////////
//  CToken base class
///////////////////////////////////////////////////////////////////////////////
CToken::CToken()
  :  m_hToken(NULL),
     m_fIsValid(false),
     m_dwLastError(ERROR_SUCCESS),
     m_psdDefault(NULL)
{
    ::SetLastError(ERROR_SUCCESS);
}


// Copy constructor
CToken::CToken(
    const CToken &rTok)
{
	rTok.Duplicate(*this);
}


CToken::~CToken(void)
{
	// Close token handle
	::CloseHandle( m_hToken );
    
    if(m_psdDefault)
    {
        delete m_psdDefault;
        m_psdDefault = NULL;
    }
}



// Duplicate CToken
void CToken::Duplicate(
    CToken &tokDup) const
{
	// Initialize data 
	tokDup.m_hToken = NULL;
	tokDup.m_fIsValid = false;
	tokDup.m_dwLastError = ERROR_SUCCESS;
	
	// Duplicate token handle
    HANDLE hTmp = NULL;
	BOOL fResult = ::DuplicateToken( 
        GetTokenHandle(),
		SecurityImpersonation,
		&hTmp);

	if(!fResult) 
    {
		tokDup.m_dwLastError = ::GetLastError();
	}
    else
    {
	    tokDup.m_hToken = hTmp;
        tokDup.m_dwLastError = tokDup.ReinitializeAll();
	    if(tokDup.m_dwLastError == ERROR_SUCCESS )
		{
            tokDup.m_fIsValid = true;
        }
    }
}


CToken& CToken::operator=(
    const CToken& rTok)
{
    // Initialize data 
	m_fIsValid = false;
    m_hToken = rTok.m_hToken;
	m_fIsValid = rTok.m_fIsValid;
	m_dwLastError = rTok.m_dwLastError;
	
	// Duplicate token handle
    HANDLE hTmp;
	BOOL fResult = ::DuplicateToken( 
        GetTokenHandle(),
		SecurityImpersonation,
		&hTmp);

	if(!fResult) 
    {
		m_dwLastError = ::GetLastError();
	}
    else
    {
	    m_hToken = hTmp;
        m_dwLastError = ReinitializeAll();
	    if(m_dwLastError == ERROR_SUCCESS )
		{
            m_fIsValid = true;
        }
    }
    return *this;
}


DWORD CToken::ReinitializeAll()
{
	DWORD dwRet = ERROR_SUCCESS;
    
    dwRet = ReinitializeOwnerSid();
	if(dwRet == ERROR_SUCCESS )
	{
        dwRet = ReinitializeDefaultSD();
    }

	if(dwRet == ERROR_SUCCESS )
	{
	    dwRet = RebuildGroupList();
    }

    if(dwRet == ERROR_SUCCESS )
	{
        dwRet = RebuildPrivilegeList();
    }

	return dwRet;
}


DWORD CToken::ReinitializeOwnerSid()
{
	m_dwLastError = ERROR_SUCCESS;
    
    PTOKEN_USER ptokusr = NULL;

    try
    {
        GTI(TokenUser, (void**)&ptokusr);

        if(ptokusr)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {
                m_sidTokenOwner = CSid(ptokusr->User.Sid);
            }

            delete ptokusr; ptokusr = NULL;
        }
    }
    catch(...)
    {
        if(ptokusr)
        {
            delete ptokusr; ptokusr = NULL;
        }
        throw;
    } 

    return m_dwLastError;
}


DWORD CToken::ReinitializeDefaultSD()
{
	m_dwLastError = ERROR_SUCCESS;
    
    // Clean up default SD
	if(m_psdDefault)
    {
        delete m_psdDefault;
        m_psdDefault = NULL;
    }

    CSid* psidDefOwner = NULL;
    CDACL* pdaclDefault = NULL;
    PTOKEN_OWNER ptokowner = NULL;
    PTOKEN_DEFAULT_DACL pdefdacl = NULL;

	// Get default owner
    try
    {
        GTI(TokenOwner, (void**)&ptokowner);
        if(ptokowner)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {   
                psidDefOwner = new CSid(ptokowner->Owner);
            }
        }
    
        GTI(TokenDefaultDacl, (void**)&pdefdacl);
        if(pdefdacl)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {
                pdaclDefault = new CDACL;
                m_dwLastError = pdaclDefault->Init(
                    pdefdacl->DefaultDacl);
            }
        }

        if(m_dwLastError == ERROR_SUCCESS)
        {
            m_psdDefault = new CSecurityDescriptor(
                psidDefOwner,
                false,
                NULL,
                false,
                pdaclDefault,
                false,
                false,
                NULL,
                false,
                false);
        }
	
        if(psidDefOwner)
        {
            delete psidDefOwner; psidDefOwner = NULL;
        }
        if(pdaclDefault)
        {
            delete pdaclDefault; pdaclDefault = NULL;
        }
        if(ptokowner)
        {
            delete ptokowner; ptokowner = NULL;
        }
        if(pdefdacl)
        {
            delete pdefdacl; pdefdacl = NULL;
        }
	}
    catch(...)
    {
        if(psidDefOwner)
        {
            delete psidDefOwner; psidDefOwner = NULL;
        }
        if(pdaclDefault)
        {
            delete pdaclDefault; pdaclDefault = NULL;
        }
        if(ptokowner)
        {
            delete ptokowner; ptokowner = NULL;
        }
        if(pdefdacl)
        {
            delete pdefdacl; pdefdacl = NULL;
        }
        throw;
    }
	
	return m_dwLastError;
}



DWORD CToken::RebuildGroupList( void )
{
	m_dwLastError = ERROR_SUCCESS;
    // Release the old list
	m_vecGroupsAndAttributes.clear();

	// Obtain and initialize groups from token
	PTOKEN_GROUPS ptg = NULL;

    try
    {
        GTI(TokenGroups, (void**)&ptg);

        if(ptg)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {
                for(long m = 0;
                    m < ptg->GroupCount;
                    m++)
                {
                    m_vecGroupsAndAttributes.push_back(
                        CSidAndAttribute(
                            CSid(ptg->Groups[m].Sid),
                            ptg->Groups[m].Attributes));
                }
            }
            delete ptg; ptg = NULL;
        }
    }
    catch(...)
    {
        if(ptg)
        {
            delete ptg; ptg = NULL;
        }
    }

	
	// If we are here, then groups are initialized	
	return m_dwLastError;
}


DWORD CToken::RebuildPrivilegeList()
{
	// Release the old list
	m_vecPrivileges.clear();

	// Obtain and initialize groups from token
	PTOKEN_PRIVILEGES ptp = NULL;
    const int NAME_SIZE = 128;
    BYTE bytePrivilegeName[NAME_SIZE];
    DWORD dwNameSize;

    try
    {
        GTI(TokenPrivileges, (void**)&ptp);

        if(ptp)
        {
            if(m_dwLastError == ERROR_SUCCESS)
            {
                for(long m = 0;
                    m < ptp->PrivilegeCount &&
                        m_dwLastError == ERROR_SUCCESS;
                    m++)
                {
                    dwNameSize = NAME_SIZE;
		            if(::LookupPrivilegeName( 
                        NULL,
						&(ptp->Privileges[m].Luid),
						(WCHAR*) bytePrivilegeName,
						&dwNameSize))
                    {
		                m_vecPrivileges.push_back(Privilege(
                             CHString((LPWSTR) bytePrivilegeName),
                             ptp->Privileges[m].Attributes));
                    }
                    else
                    {
                        m_dwLastError = ::GetLastError();
                    }
                }
            }
            delete ptp; ptp = NULL;
        }
    }
    catch(...)
    {
        if(ptp)
        {
            delete ptp; ptp = NULL;
        }
    }

	// If we are here, then privileges are initialized
	return m_dwLastError;
}


DWORD CToken::GTI(
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID* ppvBuff)
{
	::SetLastError(ERROR_SUCCESS);
    m_dwLastError = ERROR_SUCCESS;
    DWORD dwRetSize = 0;

    if(!::GetTokenInformation(
        m_hToken,
        TokenInformationClass,
        NULL,
        0L,
        &dwRetSize))
    {
        m_dwLastError = ::GetLastError();
    }

    if(m_dwLastError == ERROR_INSUFFICIENT_BUFFER)
    {
        // now get it for real...
        ::SetLastError(ERROR_SUCCESS);
        m_dwLastError = ERROR_SUCCESS;
        *ppvBuff = (PVOID) new BYTE[dwRetSize];
        DWORD dwTmp = dwRetSize;
        if(*ppvBuff)
        {
            if(!::GetTokenInformation(
                m_hToken,
                TokenInformationClass,
                *ppvBuff,
                dwTmp,
                &dwRetSize))
            {
                m_dwLastError = ::GetLastError();
            }
        }
        else
        {
            m_dwLastError = ::GetLastError();  
        }
    }

    return m_dwLastError;
}



bool CToken::GetPrivilege(
    Privilege* privOut,
    long lPos) const
{
    bool fRet = false;
    if(privOut)
    {
        if(lPos >= 0 &&
           lPos < m_vecPrivileges.size())
        {
            *privOut = m_vecPrivileges[lPos];
            fRet = true;
        }
    }
    return fRet;
}


bool CToken::GetGroup(
    CSid* sidOut,
    long lPos) const
{
    bool fRet = false;
    if(sidOut)
    {
        if(lPos >= 0 &&
           lPos < m_vecGroupsAndAttributes.size())
        {
            *sidOut = m_vecGroupsAndAttributes[lPos].m_sid;
            fRet = true;
        }
    }
    return fRet;
}


long CToken::GetPrivCount() const
{
     return m_vecPrivileges.size();
}


long CToken::GetGroupCount() const
{
    
    return m_vecGroupsAndAttributes.size();
}



HANDLE CToken::GetTokenHandle() const
{
	return m_hToken;
}


bool CToken::GetTokenOwner(
    CSid* sidOwner) const
{	
	bool fRet = false;
    if(sidOwner)
    {
        sidOwner = new CSid(m_sidTokenOwner);
        fRet = true;
    }
    return fRet;
}


// NOTE: hands back internal descriptor.
bool CToken::GetDefaultSD(
    CSecurityDescriptor** ppsdDefault)
{
	bool fRet = false;
    
    if(ppsdDefault)
    {
        if(m_psdDefault)
        {
            *ppsdDefault = m_psdDefault;
            fRet = true;
        }
    }
    return fRet;
}


DWORD CToken::SetDefaultSD(
    CSecurityDescriptor& SourceSD)
{
    ::SetLastError(ERROR_SUCCESS);

    // Inject new default info into token
		
	// Set new default owner
	CSid SidOwner;
    CDACL cd;
    SourceSD.GetOwner(SidOwner);

	TOKEN_OWNER to;
	to.Owner = SidOwner.GetPSid();
	BOOL fResult = ::SetTokenInformation( 
        m_hToken,
		TokenOwner,
		&to,
		sizeof(TOKEN_OWNER));

	if(!fResult) 
    {
		m_dwLastError = ::GetLastError();
	}
	
    if(m_dwLastError == ERROR_SUCCESS)
    {
	    // Set new default DACL
	    TOKEN_DEFAULT_DACL tdd;
        
        if(SourceSD.GetDACL(cd))
        {
	        CAccessEntryList cael;
            if(cd.GetMergedACL(cael))
            {
                PACL paclOut = NULL;
                if((m_dwLastError = 
                    cael.FillWin32ACL(paclOut)) == 
                        ERROR_SUCCESS)
                {
                    tdd.DefaultDacl = paclOut;
	                fResult = ::SetTokenInformation( 
                        m_hToken,
			            TokenDefaultDacl,
			            &tdd,
			            sizeof(TOKEN_DEFAULT_DACL));

                    if(fResult)
                    {
                        // Reference new CSD in  member variable
	                    if(m_psdDefault)
                        {
                            delete m_psdDefault; m_psdDefault = NULL;
                        }

                        m_psdDefault = new CSecurityDescriptor(
                            &SidOwner,
                            false,
                            NULL,
                            false,
                            &cd,
                            false,
                            false,
                            NULL,
                            false,
                            false);
                    }
                    else
                    {
                        m_dwLastError = ERROR_SUCCESS;   
                    }
	            }
            }
            else
            {
                m_dwLastError = ERROR_SUCCESS;
            }
        }
        else
        {
            m_dwLastError = ERROR_SUCCESS;
        }
    }
	
	return m_dwLastError;
}


DWORD CToken::EnablePrivilege(
    CHString& strPrivilegeName )
{
	// Check whether privilege exists
	bool fPrivilegeListed = false;
	
    for(long m = 0;
        m < m_vecPrivileges.size();
        m++)
    {
		if(m_vecPrivileges[m].chstrName.CompareNoCase(strPrivilegeName) == 0) 
        {
			fPrivilegeListed = true;
			break;
		}
	}

	if(!fPrivilegeListed ) 
    {
		m_dwLastError = ERROR_INVALID_PARAMETER;
	}
	else
    {
	    LUID luid;
	    BOOL fResult = ::LookupPrivilegeValue( 
            NULL,	// use local computer
			strPrivilegeName,
			&luid);

	    if(!fResult) 
        {
		    m_dwLastError = ::GetLastError();
	    }
		else
        {    
	        TOKEN_PRIVILEGES tpNewState;
	        tpNewState.PrivilegeCount = 1;
	        tpNewState.Privileges[0].Luid = luid;
	        tpNewState.Privileges[0].Attributes = 
                SE_PRIVILEGE_ENABLED;

	        TOKEN_PRIVILEGES tpPreviousState;
	        DWORD dwSizePreviousState = 
                sizeof(TOKEN_PRIVILEGES);

	        fResult = ::AdjustTokenPrivileges(
                m_hToken,
				FALSE,
				&tpNewState,
				sizeof(TOKEN_PRIVILEGES),
				&tpPreviousState,
				&dwSizePreviousState);

	        if(!fResult) 
            {
		        m_dwLastError = ::GetLastError();
	        }
	        else
            {
	            m_dwLastError = RebuildPrivilegeList();
            }
        }
    }

	return m_dwLastError;
}


DWORD CToken::DisablePrivilege(
    CHString& chstrPrivilegeName)
{
	// Check whether privilege exists
	bool fPrivilegeListed = false;
	
    for(long m = 0;
        m < m_vecPrivileges.size();
        m++)
    {
		if(m_vecPrivileges[m].chstrName.CompareNoCase(chstrPrivilegeName) == 0) 
        {
			fPrivilegeListed = true;
			break;
		}
	}

	if(!fPrivilegeListed ) 
    {
		m_dwLastError = ERROR_INVALID_PARAMETER;
	}
	else
    {
	    LUID luid;
	    BOOL fResult = ::LookupPrivilegeValue( 
            NULL,	// use local computer
			chstrPrivilegeName,
			&luid);

	    if(!fResult) 
        {
		    m_dwLastError = ::GetLastError();
	    }
		else
        {    
	        TOKEN_PRIVILEGES tpNewState;
	        tpNewState.PrivilegeCount = 1;
	        tpNewState.Privileges[0].Luid = luid;
	        tpNewState.Privileges[0].Attributes = 
                0;

	        TOKEN_PRIVILEGES tpPreviousState;
	        DWORD dwSizePreviousState = 
                sizeof(TOKEN_PRIVILEGES);

	        fResult = ::AdjustTokenPrivileges(
                m_hToken,
				FALSE,
				&tpNewState,
				sizeof(TOKEN_PRIVILEGES),
				&tpPreviousState,
				&dwSizePreviousState);

	        if(!fResult) 
            {
		        m_dwLastError = ::GetLastError();
	        }
	        else
            {
	            m_dwLastError = RebuildPrivilegeList();
            }
        }
    }

	return m_dwLastError;
}


void CToken::Dump(WCHAR* pszFileName)
{
	/*
	 *	Algorithm:
	 *		1. Dump token owner SID, name, and domain.
	 *		2. Dump all group SIDs with names and domains.
	 *		3. Dump list of privileges with attributes.
	 *		4. Dump default owner.
	 *		5. Dump default DACL.
	 */

	CHString strFileName = pszFileName;

	// If file name is not empty - create the file
	FILE* fp = NULL;
	if(!strFileName.IsEmpty()) 
    {
		fp = _wfopen((LPCWSTR)strFileName, L"a");
	}
    else
    {
        return;
    }

    if(!fp) return;


	// Write to the file
	DWORD dwBytesWritten = 0;
	CHString strCRLF = L"\r\n";
	CHString strDump;

	{
		strDump = L"Token owner: " + m_sidTokenOwner.GetAccountName() + strCRLF;
		fputws(strDump, fp);

		strDump = L"Domain: " + m_sidTokenOwner.GetDomainName() + strCRLF;
		fputws(strDump, fp);

		strDump = L"SID: " + m_sidTokenOwner.GetSidString() + strCRLF + strCRLF;
		fputws(strDump, fp);
	}

	// Dump all groups
    fputws(strCRLF, fp);
    fputws(strCRLF, fp);

	for(long m = 0;
        m < m_vecGroupsAndAttributes.size();
        m++)
    {		
		// Write to the file as well
		{
			strDump = L"Member of this group: " + m_vecGroupsAndAttributes[m].m_sid.GetSidString() + strCRLF;
			fputws(strDump, fp);
			
            strDump = L"\t(" + m_vecGroupsAndAttributes[m].m_sid.GetAccountName() + L" in " + 
							m_vecGroupsAndAttributes[m].m_sid.GetDomainName() + L" domain)" + strCRLF;
			fputws(strDump, fp);
		}	
    }

	// Dump all privileges
    fputws(strCRLF, fp);
    fputws(strCRLF, fp);

	for(m = 0;
        m < m_vecPrivileges.size();
        m++)
    {
		// Write to the file as well
		{
				
			strDump.Format( L"%d", m_vecPrivileges[m].dwAttributes );
			strDump = L"Holds a " + m_vecPrivileges[m].chstrName + L" with attributes: " + strDump + strCRLF;
			fputws(strDump, fp);
		}
	}

	// Dump default information
    fputws(strCRLF, fp);
    fputws(strCRLF, fp);
	{
		strDump = strCRLF + L"Default information:" + strCRLF;
		fputws(strDump, fp);

	}
    fputws(strCRLF, fp);
    fputws(strCRLF, fp);

	fclose(fp);

    if(m_psdDefault)
    {
	    m_psdDefault->DumpDescriptor(pszFileName);
    }
}


// Deletes a member from the access token's
// member list, and applies the change.  
bool CToken::DeleteGroup(
    CSid& sidToDelete)
{
    bool fRet = false;

    // See if the group is in the membership
    // vector...
    bool fFoundIt = false;

    SANDATTRIBUTE_VECTOR::iterator iter;
    for(iter = m_vecGroupsAndAttributes.begin();
        iter != m_vecGroupsAndAttributes.end();
        iter++)
    {
        if(iter->m_sid.GetSidString().CompareNoCase( 
            sidToDelete.GetSidString()) == 0)
        {
            fFoundIt = true;
            break;
        }
    }
    
    if(fFoundIt)
    {
        m_vecGroupsAndAttributes.erase(iter);
        
        // Now need to apply the changes.  To do
        // so, we need to construct a TOKEN_GROUPS
        // structure...
        fRet = ApplyTokenGroups();
    }   

    return fRet;
}

// Adds a member to the specified group to
// the list of token groups.
bool CToken::AddGroup(
    CSid& sidToAdd, 
    DWORD dwAttributes)
{
    bool fRet = false;

    // See if the group is in the membership
    // vector...
    bool fFoundIt = false;

    SANDATTRIBUTE_VECTOR::iterator iter;
    for(iter = m_vecGroupsAndAttributes.begin();
        iter != m_vecGroupsAndAttributes.end();
        iter++)
    {
        if(iter->m_sid.GetSidString().CompareNoCase( 
            sidToAdd.GetSidString()) == 0)
        {
            fFoundIt = true;
            break;
        }
    }
    
    if(!fFoundIt)
    {
        m_vecGroupsAndAttributes.push_back(
            CSidAndAttribute(
                sidToAdd,
                dwAttributes));
        
        // Now need to apply the changes.  To do
        // so, we need to construct a TOKEN_GROUPS
        // structure...
        fRet = ApplyTokenGroups();
    }   

    return fRet;
}


bool CToken::ApplyTokenGroups()
{
    bool fRet = false;
    PTOKEN_GROUPS ptg = NULL;
    try
    {
        ptg = (PTOKEN_GROUPS) new BYTE[sizeof(DWORD) + 
            m_vecGroupsAndAttributes.size() * sizeof(SID_AND_ATTRIBUTES)];
        
        if(ptg)
        {
            ptg->GroupCount = m_vecGroupsAndAttributes.size();
            
            for(long m = 0;
                m < m_vecGroupsAndAttributes.size();
                m++)
            {
                ptg->Groups[m].Sid = 
                    m_vecGroupsAndAttributes[m].m_sid.GetPSid();
                ptg->Groups[m].Attributes = 
                    m_vecGroupsAndAttributes[m].m_dwAttributes;
            }                                                    

            // Now we can alter the groups...
            fRet = ::AdjustTokenGroups(
                m_hToken,
                FALSE,
                ptg,
                0,
                NULL,
                NULL);

            delete ((PBYTE) ptg);
            ptg = NULL;
        }
    }
    catch(...)
    {
        if(ptg)
        {
            delete ((PBYTE) ptg);
            ptg = NULL;
        }
        throw;
    }
    
    return fRet;
}


///////////////////////////////////////////////////////////////////////////////
//  CProcessToken class
///////////////////////////////////////////////////////////////////////////////

CProcessToken::CProcessToken(
    DWORD dwDesiredAccess,
    bool fGetHandleOnly,
    HANDLE hProcess)
{
    // Open handle to process access token
    m_dwLastError = ERROR_SUCCESS;
    
    // If they didn't give us a process handle,
    // use the current process.
    if(hProcess == INVALID_HANDLE_VALUE)
    {
        if(!::OpenProcessToken( 
            GetCurrentProcess(),
		    dwDesiredAccess,
		    &m_hToken ))
        {
            m_dwLastError = ::GetLastError();
        }
    }
    else
    {
        m_hToken = hProcess;
    }

    if(!fGetHandleOnly)
    {
	    m_dwLastError = ReinitializeAll();
	}
        
    if(m_dwLastError == ERROR_SUCCESS )
	{
        m_fIsValid = true;
    }
}




///////////////////////////////////////////////////////////////////////////////
//  CThreadToken class
///////////////////////////////////////////////////////////////////////////////

CThreadToken::CThreadToken(
    bool fAccessCheckProcess, 
    bool fPrimary,
    bool fGetHandleOnly)
{
	// Open thread access token
	HANDLE hToken = NULL;
    m_dwLastError = ERROR_SUCCESS;

	if(!::OpenThreadToken(
        GetCurrentThread(),
		MAXIMUM_ALLOWED,
		fAccessCheckProcess,
		&hToken))
    {
		m_dwLastError = ::GetLastError();
	}
    else
    {
	    // Create primary token if requested
	    if(fPrimary) 
        {
		    // Duplicate into another primary
		    if(!::DuplicateTokenEx( 
                    hToken,
				    MAXIMUM_ALLOWED,
				    NULL,
				    SecurityImpersonation,
				    TokenPrimary,
				    &m_hToken))
            {
			    m_dwLastError = ::GetLastError();
		    }

            ::CloseHandle(hToken);
        }
	    else
        { 
		    m_hToken = hToken;
        }

        if((m_dwLastError == ERROR_SUCCESS) && 
            !fGetHandleOnly)
        {
            m_dwLastError = ReinitializeAll();
        }
    }
            
    if(m_dwLastError == ERROR_SUCCESS)
    {
        // If we are here, everything is initialized
	    m_fIsValid = TRUE;
    }
}

CThreadToken::CThreadToken(HANDLE hToken)
{
    m_hToken = hToken;
    m_dwLastError = ReinitializeAll();
    if(m_dwLastError == ERROR_SUCCESS)
    {
        // If we are here, everything is initialized
	    m_fIsValid = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\configmgrapi.cpp ===
//=================================================================

//

// Configmgrapi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>

#include "DllWrapperBase.h"
#include "Cim32NetApi.h"

#include "configmgrapi.h"
#include <createmutexasprocess.h>

/**********************************************************************************************************
 * Register this class with the CResourceManager.
 **********************************************************************************************************/
// {4D060F17-C791-11d2-B353-00105A1F8569}
static const GUID guidCFGMGRAPI =
{ 0x4d060f17, 0xc791, 0x11d2, { 0xb3, 0x53, 0x0, 0x10, 0x5a, 0x1f, 0x85, 0x69 } };


class CConfigMgrApiCreatorRegistration
{
public:
	CConfigMgrApiCreatorRegistration ()
	{
		CResourceManager::sm_TheResourceManager.AddInstanceCreator ( guidCFGMGRAPI, CConfigMgrApiCreator ) ;
	}
	~CConfigMgrApiCreatorRegistration ()
	{}

	static CResource * CConfigMgrApiCreator ( PVOID pData )
	{
		CConfigMgrAPI *t_pConfigmgrapi = new CConfigMgrAPI ;
		if ( !t_pConfigmgrapi )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
		return t_pConfigmgrapi ;
	}
};

CConfigMgrApiCreatorRegistration MyCConfigMgrApiCreatorRegistration ;

/**********************************************************************************************************/


// String array for converting between 32-bit ULONG Constants and
// corresponding registry strings in 16-bit land

const char*	CConfigMgrAPI::s_pszRegistryStrings[]	=	{
													CM_DRP_DEVICEDESC_S,
													CM_DRP_HARDWAREID_S,
													CM_DRP_COMPATIBLEIDS_S,
													CM_DRP_NTDEVICEPATHS_S,
													CM_DRP_SERVICE_S,
													CM_DRP_CONFIGURATION_S,
													CM_DRP_CONFIGURATIONVECTOR_S,
													CM_DRP_CLASS_S,
													CM_DRP_CLASSGUID_S,
													CM_DRP_DRIVER_S,
													CM_DRP_CONFIGFLAGS_S,
													CM_DRP_MFG_S,
													CM_DRP_FRIENDLYNAME_S,
													CM_DRP_LOCATION_INFORMATION_S,
													CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME_S,
													CM_DRP_CAPABILITIES_S,
													CM_DRP_UI_NUMBER_S,
													CM_DRP_UPPERFILTERS_S,
													CM_DRP_LOWERFILTERS_S,
													CM_DRP_BUSTYPEGUID_S,
													CM_DRP_LEGACYBUSTYPE_S,
													CM_DRP_BUSNUMBER_S,
													CM_DRP_ENUMERATOR_NAME_S,
													CM_DRP_MAX_S
												};

ULONG	CConfigMgrAPI::s_pszRegistryValueTypes[]	=	{
														REG_SZ,	// CM_DRP_DEVICEDESC_S
														REG_SZ,	// CM_DRP_HARDWAREID_S
														REG_SZ,	// CM_DRP_COMPATIBLEIDS_S
														REG_SZ,	// CM_DRP_NTDEVICEPATHS_S
														REG_SZ,	// CM_DRP_SERVICE_S
														REG_SZ,	// CM_DRP_CONFIGURATION_S
														REG_SZ,	// CM_DRP_CONFIGURATIONVECTOR_S
														REG_SZ,	// CM_DRP_CLASS_S
														REG_SZ,	// CM_DRP_CLASSGUID_S
														REG_SZ,	// CM_DRP_DRIVER_S
														REG_BINARY,	// CM_DRP_CONFIGFLAGS_S
														REG_SZ,	// CM_DRP_MFG_S
														REG_SZ,	// CM_DRP_FRIENDLYNAME_S
														REG_SZ,	// CM_DRP_LOCATION_INFORMATION_S
														REG_BINARY,	// CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME_S
														REG_BINARY,	// CM_DRP_CAPABILITIES_S
														REG_SZ,	// CM_DRP_UI_NUMBER_S
														REG_SZ,	// CM_DRP_UPPERFILTERS_S
														REG_SZ,	// CM_DRP_LOWERFILTERS_S
														REG_SZ,	// CM_DRP_BUSTYPEGUID_S
														REG_BINARY,	// CM_DRP_LEGACYBUSTYPE_S
														REG_BINARY,	// CM_DRP_BUSNUMBER_S
														REG_SZ,	// CM_DRP_ENUMERATOR_NAME_S
														REG_SZ	// CM_DRP_MAX_S
													};

CConfigMgrAPI::CConfigMgrAPI( void )
:
#ifdef NTONLY
    m_hConfigMgrDll( NULL ),
	m_pCM_Connect_MachineA( NULL ),
	m_pCM_Disconnect_Machine( NULL ),
	m_pCM_Locate_DevNode( NULL ),
	m_pCM_Get_Child( NULL ),
	m_pCM_Get_Sibling( NULL ),
	m_pCM_Get_DevNode_Registry_Property( NULL ),
	m_pCM_Get_DevNode_Status( NULL ),
	m_pCM_Get_First_Log_Config( NULL ),
	m_pCM_Get_Next_Res_Des( NULL ),
	m_pCM_Get_Res_Des_Data( NULL ),
	m_pCM_Get_Res_Des_Data_Size( NULL ),
	m_pCM_Free_Log_Conf_Handle( NULL ),
	m_pCM_Free_Res_Des_Handle( NULL ),
	m_pCM_Get_Device_IDA( NULL ),
	m_pCM_Get_Device_ID_Size( NULL ),
	m_pCM_Get_Parent( NULL )
#endif
#ifdef WIN9XONLY
    m_pCim32NetApi(NULL)
/*
	m_pCM16_Locate_DevNode( NULL ),
	m_pCM16_Get_Child( NULL ),
	m_pCM16_Get_Sibling( NULL ),
	m_pCM16_Read_Registry_Value( NULL ),
	m_pCM16_Get_DevNode_Status( NULL ),
	m_pCM16_Get_Device_ID( NULL ),
	m_pCM16_Get_Device_ID_Size( NULL ),
	m_pCM16_Get_First_Log_Conf( NULL ),
	m_pCM16_Get_Next_Res_Des( NULL ),
	m_pCM16_Get_Res_Des_Data_Size( NULL ),
	m_pCM16_Get_Res_Des_Data( NULL ),
	m_pCM16_Get_Bus_Info( NULL ),
	m_pCM16_Get_Parent( NULL ),
*/
#endif

{
#ifdef NTONLY
	{

       	m_hConfigMgrDll = LoadLibrary(_T("CFGMGR32.DLL"));

        if ( NULL != m_hConfigMgrDll )
		{
			m_pCM_Connect_MachineA		=	(PCFGMGR32_CM_CONNECT_MACHINEA)		GetProcAddress( m_hConfigMgrDll, "CM_Connect_MachineA" );
			m_pCM_Disconnect_Machine	=	(PCFGMGR32_CM_DISCONNECT_MACHINE)	GetProcAddress( m_hConfigMgrDll, "CM_Disconnect_Machine" );
#ifdef UNICODE
			m_pCM_Locate_DevNode		=	(PCFGMGR32_CM_LOCATE_DEVNODE)	GetProcAddress( m_hConfigMgrDll, "CM_Locate_DevNodeW" );
			m_pCM_Get_DevNode_Registry_Property	=	(PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTY)	GetProcAddress( m_hConfigMgrDll, "CM_Get_DevNode_Registry_PropertyW" );
#else
			m_pCM_Get_DevNode_Registry_Property	=	(PCFGMGR32_CM_GET_DEVNODE_REGISTRY_PROPERTY)	GetProcAddress( m_hConfigMgrDll, "CM_Get_DevNode_Registry_PropertyA" );
			m_pCM_Locate_DevNode		=	(PCFGMGR32_CM_LOCATE_DEVNODE)	GetProcAddress( m_hConfigMgrDll, "CM_Locate_DevNodeA" );
#endif
			m_pCM_Get_Child				=	(PCFGMGR32_CM_GET_CHILD)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Child" );
			m_pCM_Get_Sibling			=	(PCFGMGR32_CM_GET_SIBLING)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Sibling" );
			m_pCM_Get_DevNode_Status	=	(PCFGMGR32_CM_GET_DEVNODE_STATUS)	GetProcAddress( m_hConfigMgrDll, "CM_Get_DevNode_Status" );
			m_pCM_Get_First_Log_Config	=	(PCFGMGR32_CM_GET_FIRST_LOG_CONF)	GetProcAddress( m_hConfigMgrDll, "CM_Get_First_Log_Conf" );
			m_pCM_Get_Next_Res_Des		=	(PCFGMGR32_CM_GET_NEXT_RES_DES)		GetProcAddress( m_hConfigMgrDll, "CM_Get_Next_Res_Des" );
			m_pCM_Get_Res_Des_Data		=	(PCFGMGR32_CM_GET_RES_DES_DATA)		GetProcAddress( m_hConfigMgrDll, "CM_Get_Res_Des_Data" );
			m_pCM_Get_Res_Des_Data_Size	=	(PCFGMGR32_CM_GET_RES_DES_DATA_SIZE)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Res_Des_Data_Size" );
			m_pCM_Free_Log_Conf_Handle	=	(PCFGMGR32_CM_FREE_LOG_CONF_HANDLE)	GetProcAddress( m_hConfigMgrDll, "CM_Free_Log_Conf_Handle" );
			m_pCM_Free_Res_Des_Handle	=	(PCFGMGR32_CM_FREE_RES_DES_HANDLE)	GetProcAddress( m_hConfigMgrDll, "CM_Free_Res_Des_Handle" );
			m_pCM_Get_Device_IDA		=	(PCFGMGR32_CM_GET_DEVICE_IDA)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Device_IDA" );
			m_pCM_Get_Device_ID_Size	=	(PCFGMGR32_CM_GET_DEVICE_ID_SIZE)	GetProcAddress( m_hConfigMgrDll, "CM_Get_Device_ID_Size" );
			m_pCM_Get_Parent			=	(PCFGMGR32_CM_GET_PARENT)			GetProcAddress( m_hConfigMgrDll, "CM_Get_Parent" );
		}
        else
        {
            LogErrorMessage(L"Failed to load library cfgmgr32.dll");
        }

	}
#endif
#ifdef WIN9XONLY
	{
		m_pCim32NetApi = HoldSingleCim32NetPtr::GetCim32NetApiPtr();
/*
		if ( NULL != m_hConfigMgrDll )
		{
			m_pCM16_Locate_DevNode			=	(PCIM32THK_CM_LOCATE_DEVNODE)			GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Locate_DevNode" );
			m_pCM16_Get_Child				=	(PCIM32THK_CM_GET_CHILD)				GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Child" );
			m_pCM16_Get_Sibling				=	(PCIM32THK_CM_GET_SIBLING)				GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Sibling" );
			m_pCM16_Read_Registry_Value		=	(PCIM32THK_CM_READ_REGISTRY_VALUE)		GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Read_Registry_Value" );
			m_pCM16_Get_DevNode_Status		=	(PCIM32THK_CM_GET_DEVNODE_STATUS)		GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_DevNode_Status" );
			m_pCM16_Get_Device_ID			=	(PCIM32THK_CM_GET_DEVICE_ID)			GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Device_ID" );
			m_pCM16_Get_Device_ID_Size		=	(PCIM32THK_CM_GET_DEVICE_ID_SIZE)		GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Device_ID_Size" );
			m_pCM16_Get_First_Log_Conf		=	(PCIM32THK_CM_GET_FIRST_LOG_CONF)		GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_First_Log_Conf" );
			m_pCM16_Get_Next_Res_Des		=	(PCIM32THK_CM_GET_NEXT_RES_DES)			GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Next_Res_Des" );
			m_pCM16_Get_Res_Des_Data_Size	=	(PCIM32THK_CM_GET_RES_DES_DATA_SIZE)	GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Res_Des_Data_Size" );
			m_pCM16_Get_Res_Des_Data		=	(PCIM32THK_CM_GET_RES_DES_DATA)			GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Res_Des_Data" );
			m_pCM16_Get_Bus_Info			=	(PCIM32THK_CM_GET_BUS_INFO)				GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Bus_Info" );
			m_pCM16_Get_Parent				=	(PCIM32THK_CM_GET_PARENT)				GetProcAddress( m_hConfigMgrDll, "CIM32THK_CM_Get_Parent" );
		}
*/
	}
#endif
}

CConfigMgrAPI::~CConfigMgrAPI( void )
{
#ifdef NTONLY
	if ( NULL != m_hConfigMgrDll )
	{
		FreeLibrary( m_hConfigMgrDll );
	}
#endif
#ifdef WIN9XONLY
    if(m_pCim32NetApi != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, m_pCim32NetApi);
        m_pCim32NetApi = NULL;
    }
#endif
}

CONFIGRET CConfigMgrAPI::CM_Connect_MachineA( PCSTR UNCServerName, PHMACHINE phMachine )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	if ( NULL != m_pCM_Connect_MachineA )
	{
		cr = m_pCM_Connect_MachineA( UNCServerName, phMachine );
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Disconnect_Machine( HMACHINE hMachine )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	if ( NULL != m_pCM_Connect_MachineA )
	{
		cr = m_pCM_Disconnect_Machine( hMachine );
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Parent( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_Parent )
		{
			cr = m_pCM_Get_Parent( pdnDevInst, DevInst, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_Parent( pdnDevInst, DevInst, ulFlags );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Child( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_Child )
		{
			cr = m_pCM_Get_Child( pdnDevInst, DevInst, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_Child( pdnDevInst, DevInst, ulFlags );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Sibling( PDEVINST pdnDevInst, DEVINST DevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_Sibling )
		{
			cr = m_pCM_Get_Sibling( pdnDevInst, DevInst, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_Sibling( pdnDevInst, DevInst, ulFlags );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Locate_DevNode( PDEVINST pdnDevInst, TCHAR *pDeviceID, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Locate_DevNode )
		{
			cr = m_pCM_Locate_DevNode( pdnDevInst, pDeviceID, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
#ifndef UNICODE
            cr = m_pCim32NetApi->CIM32THK_CM_Locate_DevNode( pdnDevInst, pDeviceID, ulFlags );
#endif
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_DevNode_Registry_PropertyA( DEVINST dnDevInst, ULONG ulProperty, PULONG pulRegDataType,
													PVOID Buffer, PULONG pulLength, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_DevNode_Registry_Property )
		{
			cr = m_pCM_Get_DevNode_Registry_Property( dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if	(	NULL		!=	m_pCim32NetApi
			&&	CM_DRP_MIN	<=	ulProperty
			&&	CM_DRP_MAX	>	ulProperty )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Read_Registry_Value( dnDevInst, NULL, s_pszRegistryStrings[ulProperty-1], s_pszRegistryValueTypes[ulProperty-1], Buffer, pulLength, 0 );

			// Fake the returned type since we at least had a match
			*pulRegDataType = s_pszRegistryValueTypes[ulProperty-1];
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_DevNode_Status( PULONG pulStatus, PULONG pulProblemNumber, DEVINST dnDevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{

		if ( NULL != m_pCM_Get_DevNode_Status )
		{
			cr = m_pCM_Get_DevNode_Status( pulStatus, pulProblemNumber, dnDevInst, ulFlags );
		}

	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_DevNode_Status( pulStatus, pulProblemNumber, dnDevInst, ulFlags );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_First_Log_Conf( PLOG_CONF plcLogConf, DEVINST dnDevInst, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_First_Log_Config )
		{
			cr = m_pCM_Get_First_Log_Config( plcLogConf, dnDevInst, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_First_Log_Conf( plcLogConf, dnDevInst, ulFlags );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Next_Res_Des( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_Next_Res_Des )
		{
			cr = m_pCM_Get_Next_Res_Des( prdResDes, rdResDes, ForResource, pResourceID, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_Next_Res_Des( prdResDes, rdResDes, ForResource, pResourceID, ulFlags );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Res_Des_Data( RES_DES rdResDes, PVOID Buffer, ULONG BufferLen, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_Res_Des_Data )
		{
			cr = m_pCM_Get_Res_Des_Data( rdResDes, Buffer, BufferLen, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr =m_pCim32NetApi-> CIM32THK_CM_Get_Res_Des_Data( rdResDes, Buffer, BufferLen, ulFlags );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Res_Des_Data_Size( PULONG pulSize, RES_DES rdResDes, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_Res_Des_Data_Size )
		{
			cr = m_pCM_Get_Res_Des_Data_Size( pulSize, rdResDes, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_Res_Des_Data_Size( pulSize, rdResDes, ulFlags );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Free_Log_Conf_Handle( LOG_CONF lcLogConf )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	// This function does NOT appear to have a 16-bit implementation or an
	// equivalent thereof.
#ifdef NTONLY
	{
		if ( NULL != m_pCM_Free_Log_Conf_Handle )
		{
			cr = m_pCM_Free_Log_Conf_Handle( lcLogConf );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Free_Res_Des_Handle( RES_DES rdResDes )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	// This function does NOT appear to have a 16-bit implementation or an
	// equivalent thereof.
#ifdef NTONLY
	{
		if ( NULL != m_pCM_Free_Res_Des_Handle )
		{
			cr = m_pCM_Free_Res_Des_Handle( rdResDes );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Device_IDA( DEVNODE dnDevNode, PCHAR Buffer, ULONG BufferLen, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_Device_IDA )
		{
			cr = m_pCM_Get_Device_IDA( dnDevNode, Buffer, BufferLen, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_Device_ID( dnDevNode, Buffer, BufferLen, ulFlags );
		}
	}
#endif

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Get_Device_ID_Size( PULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

#ifdef NTONLY
	{
		if ( NULL != m_pCM_Get_Device_ID_Size )
		{
			cr = m_pCM_Get_Device_ID_Size( pulLen, dnDevNode, ulFlags );
		}
	}
#endif
#ifdef WIN9XONLY
	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_Device_ID_Size( pulLen, dnDevNode, ulFlags );
		}
	}
#endif

	return cr;
}

#ifdef WIN9XONLY
// This is a 16-bit only function
CONFIGRET CConfigMgrAPI::CM_Get_Bus_Info( DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags )
{
	CONFIGRET	cr = CR_INVALID_POINTER;

	{
		if ( NULL != m_pCim32NetApi )
		{
			cr = m_pCim32NetApi->CIM32THK_CM_Get_Bus_Info( dnDevNode, pbtBusType, pulSizeOfInfo, pInfo, ulFlags );
		}
	}

	return cr;
}

CONFIGRET CConfigMgrAPI::CM_Query_Arbitrator_Free_Data(PVOID pData, ULONG DataLen, DEVINST dnDevInst, RESOURCEID ResourceID, ULONG ulFlags)
{
	if (m_pCim32NetApi)
	{
		return m_pCim32NetApi->CIM32THK_CM_Query_Arbitrator_Free_Data(pData, DataLen, dnDevInst, ResourceID, ulFlags);
	}
    else
    {
        return CR_INVALID_POINTER;
    }
}

CONFIGRET CConfigMgrAPI::CM_Delete_Range(ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags)
{
	if (m_pCim32NetApi)
	{
		return m_pCim32NetApi->CIM32THK_CM_Delete_Range(ulStartValue, ulEndValue, rlh, ulFlags);
	}
    else
    {
        return CR_INVALID_POINTER;
    }
}

CONFIGRET CConfigMgrAPI::CM_First_Range(RANGE_LIST rlh, LPULONG pulStart, LPULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags)
{
	if (m_pCim32NetApi)
	{
		return m_pCim32NetApi->CIM32THK_CM_First_Range(rlh, pulStart, pulEnd, preElement, ulFlags);
	}
    else
    {
        return CR_INVALID_POINTER;
    }
}

CONFIGRET CConfigMgrAPI::CM_Next_Range(PRANGE_ELEMENT preElement, LPULONG pulStart, LPULONG pullEnd, ULONG ulFlags)
{
	if (m_pCim32NetApi)
	{
		return m_pCim32NetApi->CIM32THK_CM_Next_Range(preElement, pulStart, pullEnd, ulFlags);
	}
    else
    {
        return CR_INVALID_POINTER;
    }
}

CONFIGRET CConfigMgrAPI::CM_Free_Range_List(RANGE_LIST rlh, ULONG ulFlags)
{
	if (m_pCim32NetApi)
	{
		return m_pCim32NetApi->CIM32THK_CM_Free_Range_List(rlh, ulFlags);
	}
    else
    {
        return CR_INVALID_POINTER;
    }
}

#endif

BOOL CConfigMgrAPI :: IsValid ()
{
#ifdef WIN9XONLY
    return m_pCim32NetApi != NULL;
#endif
#ifdef NTONLY
    return m_hConfigMgrDll != NULL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ctoken.h ===
/*

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
 *
 *	Created:	4/21/2000, Kevin Hughes
 */


#pragma once


class CSidAndAttribute
{
public:
    CSidAndAttribute() {}
    CSidAndAttribute(
        CSid& csidIn,
        DWORD dwAttribIn)
    {
        m_sid = csidIn;
        m_dwAttributes = dwAttribIn;
    }

    virtual ~CSidAndAttribute() {}
    CSid m_sid;
    DWORD m_dwAttributes; 
};


class Privilege
{
public:

    Privilege() : dwAttributes(0) {}
    virtual ~Privilege() {}
    Privilege(
        CHString& strIn,
        DWORD attribsIn)
      : dwAttributes(attribsIn)
    {
        chstrName = strIn;
    }

    CHString chstrName;
	DWORD dwAttributes;
};


typedef std::vector<CSidAndAttribute> SANDATTRIBUTE_VECTOR;
typedef std::vector<Privilege> PRIVILEGE_VECTOR;



class CToken
{
public:
    CToken();
    CToken(
        const CToken& rTok);
    virtual ~CToken();

    void Duplicate(CToken& tokDup) const;

    long GetPrivCount() const;
    long GetGroupCount() const;

    bool GetPrivilege(
        Privilege* privOut,
        long lPos) const;

    bool GetGroup(
        CSid* sidOut,
        long lPos) const;

    // Deletes a member from the access token's
    // member list, and applies the change.  
    bool DeleteGroup(
        CSid& sidToDelete);

    // Adds a member to the specified group to
    // the list of token groups.
    bool AddGroup(
        CSid& sidToAdd, 
        DWORD dwAttributes);

    CToken& operator=(
        const CToken& rv);

    HANDLE GetTokenHandle() const;

    bool GetTokenOwner(
        CSid* sidOwner) const;

    // NOTE: hands back internal descriptor.
    bool GetDefaultSD(
        CSecurityDescriptor** ppsdDefault);

    DWORD SetDefaultSD(
        CSecurityDescriptor& SourceSD);

    DWORD EnablePrivilege(
        CHString& strPrivilegeName);

    DWORD DisablePrivilege(
        CHString& chstrPrivilegeName);

    void Dump(WCHAR* pszFileName);


protected:
    
    DWORD ReinitializeAll();    
    HANDLE m_hToken;
    DWORD m_dwLastError;
    bool m_fIsValid;

private:

    
	DWORD ReinitializeOwnerSid();
	DWORD ReinitializeDefaultSD();
	DWORD RebuildGroupList();
	DWORD RebuildPrivilegeList();
    DWORD GTI(
        TOKEN_INFORMATION_CLASS TokenInformationClass,
        PVOID* ppvBuff);
    bool ApplyTokenGroups();

   
    CSid m_sidTokenOwner;					
	CSecurityDescriptor* m_psdDefault;    // Default security info
	SANDATTRIBUTE_VECTOR m_vecGroupsAndAttributes;  // List of groups and their attributes
	PRIVILEGE_VECTOR m_vecPrivileges;	  // List of privileges

};



class CProcessToken : public CToken
{
public:
    CProcessToken(
        DWORD dwDesiredAccess = TOKEN_ALL_ACCESS,
        bool fGetHandleOnly = false,
        HANDLE hProcess = INVALID_HANDLE_VALUE);
    
    //CProcessToken(
    //    const CProcessToken& rTok);
    
    virtual ~CProcessToken() {}


private:


};


class CThreadToken : public CToken
{
public:
    //CThreadToken();

    CThreadToken(
        bool fAccessCheckProcess, 
        bool fPrimary,
        bool fGetHandleOnly = false);

    CThreadToken(HANDLE h);

    //CThreadToken(
    //    const CThreadToken& rTok);

    virtual ~CThreadToken() {}

private:


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dacl.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CDACL.h - header file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CDACL_H__
#define __CDACL_H__





enum DACL_Types
{
    ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE = 0,
    ENUM_ACCESS_DENIED_ACE_TYPE,
    ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE,
    ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE,
    ENUM_ACCESS_ALLOWED_ACE_TYPE,

    ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE,
    ENUM_INH_ACCESS_DENIED_ACE_TYPE,
    ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE,
    ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE,
    ENUM_INH_ACCESS_ALLOWED_ACE_TYPE,
    
    // Keep this the last entry
    NUM_DACL_TYPES
};

#define DACLTYPE short

#define STATUS_EMPTY_DACL 0x10000000
#define STATUS_NULL_DACL  0x20000000



//////////////////////////////////////////////////////////////////
//
//	Class: CDACL
//
//	Class encapsulates a Win32 DACL, by providing public methods
//	for manipulating Access Allowed/Denied entries only.
//
//////////////////////////////////////////////////////////////////

class CDACL
{
	// Constructors and destructor
	public:
		CDACL();
		~CDACL( void );
        
        DWORD Init(PACL	pDACL);

        bool AddDACLEntry( PSID psid, 
                           DACLTYPE DaclType, 
                           DWORD dwAccessMask, 
                           BYTE bAceFlags, 
                           GUID *pguidObjGuid, 
                           GUID *pguidInhObjGuid );

        bool RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, DWORD dwIndex = 0  );
		bool RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid ); 
		
		bool CopyDACL ( CDACL & dacl );
		bool AppendDACL ( CDACL & dacl );

        void Clear();
        bool CreateNullDACL();

        // Override of functions of same name from CAccessEntry
        virtual bool Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );
		virtual bool Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );

        DWORD ConfigureDACL( PACL& pDacl );
        BOOL CalculateDACLSize( LPDWORD pdwDaclLength );
        DWORD FillDACL( PACL pDacl );

        bool IsNULLDACL();
        bool IsEmpty();

        // Virtual function for returning all access value (default is GENERIC_ALL)
        virtual DWORD AllAccessMask();

        bool GetMergedACL(CAccessEntryList& a_aclIn);

        void DumpDACL(LPCWSTR wstrFilename = NULL);


    private:

        CAccessEntryList* m_rgDACLSections[NUM_DACL_TYPES];

         // Helper function for splitting aces by their cononical types
        bool SplitIntoCanonicalSections(CAccessEntryList& a_aclIn);

        // Helper to undo the damage done from the previous function!
        bool ReassembleFromCanonicalSections(CAccessEntryList& a_aclIn);

        // And for a real helper, here is one that takes a dacl that
        // might be in any fubar order and creates it afresh!
        bool PutInNT5CanonicalOrder();



        
};












#endif // __CAccessEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllcommon.cpp ===
//=================================================================

//

// DllCommon.cpp

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#include "precomp.h"
#include "DllCommon.h"

extern HMODULE ghModule ;

//***************************************************************************
//
//  CommonGetClassObject
//
//  Given an IID, PPVOID, Provider name, and a long ref, perform
//  the common tasks for a framework prover to get a class object
//
//***************************************************************************

STDAPI CommonGetClassObject (

    REFIID riid,
    PPVOID ppv,
    LPCWSTR wszProviderName,
    LONG &lCount
)
{
    HRESULT hr = S_OK;
    CWbemGlueFactory *pObj = NULL;

    try
    {
        LogMessage2( L"%s -> DllGetClassObject", wszProviderName );

        pObj = new CWbemGlueFactory (&lCount) ;

        if (NULL != pObj)
        {
            hr = pObj->QueryInterface(riid, ppv);

            if (FAILED(hr))
            {
                delete pObj;
                pObj = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    catch ( ... )
    {
        hr = E_OUTOFMEMORY;
        if ( pObj != NULL )
        {
            delete pObj;
        }
    }

    return hr;
}

//***************************************************************************
//
//  CommonGetClassObject
//
//  Given a Provider name, and a long ref, perform
//  the common tasks for a framework prover to determine whether it is ready
//  to unload
//
//***************************************************************************

STDAPI CommonCanUnloadNow (LPCWSTR wszProviderName, LONG &lCount)
{
    SCODE sc = S_FALSE;

    try
    {
        if (CWbemProviderGlue :: FrameworkLogoffDLL ( wszProviderName, &lCount ))
        {
            sc = S_OK;
            LogMessage2( L"%s  -> Dll CAN Unload",  wszProviderName);
        }
        else
        {
            LogMessage2( L"%s  -> Dll can NOT Unload", wszProviderName );
        }
    }
    catch ( ... )
    {
        // sc should already be set correctly
    }

    return sc;
}

//***************************************************************************
//
//  CommonCommonProcessAttach
//
//  Given a Provider name, a long ref, and the HINSTANCE passed to DLLMAIN, 
//  perform the common tasks loading a provider.
//
//  Note that this routine uses the extern ghModule assumed to be defined
//  by the caller.
//
//***************************************************************************

BOOL STDAPICALLTYPE CommonProcessAttach(LPCWSTR wszProviderName, LONG &lCount, HINSTANCE hInstDLL)
{
    BOOL bRet = TRUE;
    try
    {
        LogMessage( L"DLL_PROCESS_ATTACH" );
        ghModule = hInstDLL ;

        // Initialize once for each new process.
        // Return FALSE to fail DLL load.

        bRet = CWbemProviderGlue::FrameworkLoginDLL ( wszProviderName, &lCount ) ;
        if (!DisableThreadLibraryCalls(hInstDLL))
        {
            LogErrorMessage( L"DisableThreadLibraryCalls failed" );
        }
    }
    catch ( ... )
    {
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\devdesc.cpp ===
/////////////////////////////////////////////////////////////////////////

//

//  devdesc.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    1/20/98		davwoh		Created
//
/////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <assertbreak.h>
#include "poormansresource.h"
#include "resourcedesc.h"
#include "devdesc.h"
////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryDescriptor::CDeviceMemoryDescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryDescriptor::CDeviceMemoryDescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( pResDescHdr, pOwnerDevice )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryDescriptor::CDeviceMemoryDescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Resource Id with flags
//				MEM_DES					memDes - Device Memory Descriptor.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryDescriptor::CDeviceMemoryDescriptor(	DWORD				dwResourceId,
													MEM_DES&			memDes,
													CConfigMgrDevice*	pOwnerDevice )
:	CResourceDescriptor( dwResourceId, &memDes, sizeof(MEM_DES), pOwnerDevice )
{
	ASSERT_BREAK( ResType_Mem == GetResourceType() );
}

// Copy Constructor
CDeviceMemoryDescriptor::CDeviceMemoryDescriptor( const CDeviceMemoryDescriptor& mem )
: CResourceDescriptor( mem )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryDescriptor::~CDeviceMemoryDescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryDescriptor::~CDeviceMemoryDescriptor( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryDescriptor::GetString
//
//	Returns a string representation of the associated IO Port Address.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		TRUE/FALSE		Function successful or not.
//
//	Comments:	Do NOT call down to the base class.
//
////////////////////////////////////////////////////////////////////////
void *CDeviceMemoryDescriptor::GetResource()
{

	if ( NULL != m_pbResourceDescriptor ){
		// Cast to an IO Resource Descriptor, and place it's IO address values
		// in the string.
		PMEM_DES	pMEM = (PMEM_DES) m_pbResourceDescriptor;
        return pMEM;
	}

	return NULL;
}

//
//	Constructor and Destructor for the IO Port Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryCollection::CDeviceMemoryCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryCollection::CDeviceMemoryCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDeviceMemoryCollection::~CDeviceMemoryCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDeviceMemoryCollection::~CDeviceMemoryCollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllcommon.h ===
//=================================================================

//

// DllCommon.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

STDAPI CommonGetClassObject (

    REFIID riid,
    PPVOID ppv,
    LPCWSTR wszProviderName,
    LONG &lCount
);

STDAPI CommonCanUnloadNow (LPCWSTR wszProviderName, LONG &lCount);
BOOL STDAPICALLTYPE CommonProcessAttach(LPCWSTR wszProviderName, LONG &lCount, HINSTANCE hInstDLL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\cwaitableobject.h ===
/*****************************************************************************



*  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

 *                            

 *                         All Rights Reserved

 *

 * This software is furnished under a license and may be used and copied

 * only in accordance with the terms of such license and with the inclusion

 * of the above copyright notice.  This software or any other copies thereof

 * may not be provided or otherwise  made available to any other person.  No

 * title to and ownership of the software is hereby transferred.

 *****************************************************************************/



//============================================================================

//

// CWaitableObject.h -- Pure virtual base class for waitable objects

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/26/98    a-kevhu         Created
//
//============================================================================

#ifndef __CWAITABLEOBJECT_H__
#define __CWAITABLEOBJECT_H__

#include "CGlobal.h"

class CWaitableObject {
    // class has no member data, it's only purpose is to provide
    // a base class for waitable objects which have internal HANDLES
    // and Status...

    // class needs no construtor, since it has no members...

public:
    // get the internal handle...
    // this member function is virtual to assure
    // this function appears in all derived classes
    // and pure (= 0) so that this class cannot be instantiated...
    virtual HANDLE GetHandle(void) const = 0;

    // get the internal object status...
    // this member function is virtual to assure
    // this function appears in all derived classes
    // and pure (= 0) so that this class cannot be instantiated...
    virtual DWORD Status(void) const = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\devdesc.h ===
/////////////////////////////////////////////////////////////////////////

//

//  cfgmgrdevice.h    

//  

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    1/20/98		davwoh		Created
//  
/////////////////////////////////////////////////////////////////////////

#ifndef __DEVICEDESC_H__
#define __DEVICEDESC_H__


class 
__declspec(uuid("571D3188-D45D-11d2-B35E-00104BC97924"))
CDeviceMemoryDescriptor: public CResourceDescriptor
{
	
public:

	// Construction/Destruction
	CDeviceMemoryDescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CDeviceMemoryDescriptor( DWORD dwResourceId, MEM_DES& memDes, CConfigMgrDevice* pOwnerDevice );
	CDeviceMemoryDescriptor( const CDeviceMemoryDescriptor& mem );
	~CDeviceMemoryDescriptor();

	DWORDLONG GetBaseAddress( void );
	DWORDLONG GetEndAddress( void );
	DWORD GetFlags( void );

	// Override of base class functionality
	virtual void * GetResource();
	
};

_COM_SMARTPTR_TYPEDEF(CDeviceMemoryDescriptor, __uuidof(CDeviceMemoryDescriptor));

inline DWORDLONG CDeviceMemoryDescriptor::GetBaseAddress( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PMEM_DES) m_pbResourceDescriptor)->MD_Alloc_Base : 0 );
}

inline DWORDLONG CDeviceMemoryDescriptor::GetEndAddress( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PMEM_DES) m_pbResourceDescriptor)->MD_Alloc_End : 0 );
}

inline DWORD CDeviceMemoryDescriptor::GetFlags( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PMEM_DES) m_pbResourceDescriptor)->MD_Flags : 0 );
}

// A collection of DeviceMemory Port Descriptors
class CDeviceMemoryCollection : public TRefPtr<CDeviceMemoryDescriptor>
{
public:

	// Construction/Destruction
	CDeviceMemoryCollection();
	~CDeviceMemoryCollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CDeviceMemoryCollection& operator = ( const CDeviceMemoryCollection& srcCollection );

};

inline const CDeviceMemoryCollection& CDeviceMemoryCollection::operator = ( const CDeviceMemoryCollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllmain.h ===
//***************************************************************************

//

//  MAINDLL.H

// 

//  Module: WBEM Framework Instance provider 

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

HRESULT RegisterServer(TCHAR *a_pName, REFGUID a_rguid ) ;
HRESULT UnregisterServer( REFGUID a_rguid ) ;

extern HMODULE ghModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dacl.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CAccessEntry.cpp - implementation file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::CDACL
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CDACL::CDACL( void )
{
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        m_rgDACLSections[s] = NULL;
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::~CDACL
//
//	Class destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CDACL::~CDACL( void )
{
    Clear();
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::Init
//
//	Initializes the DACL member lists.
//
//	Inputs:
//
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD CDACL::Init(PACL a_pDACL)
{
    DWORD t_dwRes = E_FAIL;
    if(a_pDACL == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    CAccessEntryList t_aclTemp;
    t_dwRes = t_aclTemp.InitFromWin32ACL(a_pDACL);

    if(t_dwRes == ERROR_SUCCESS)
    {
        if(!SplitIntoCanonicalSections(t_aclTemp))
        {
            for(short s = 0; s < NUM_DACL_TYPES; s++)
            {
                delete m_rgDACLSections[s];
                m_rgDACLSections[s] = NULL;
            }
            t_dwRes = ERROR_SUCCESS;
        }
    }
    return t_dwRes;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::AddDACLEntry
//
//	Adds an access allowed entry to the ACL.  By default, these go
//	to the end of the list.
//
//	Inputs:
//				PSID		psid - PSID
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CDACL::AddDACLEntry( PSID psid, DACLTYPE DaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool fReturn = true;
    BYTE bACEType;

    // Sid must be valid
	if ( (psid != NULL) && IsValidSid( psid ) )
	{
        switch(DaclType)
        {
            case ENUM_ACCESS_DENIED_ACE_TYPE:
                bACEType = ACCESS_DENIED_ACE_TYPE;
                break;
            case ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE:
                bACEType = ACCESS_DENIED_OBJECT_ACE_TYPE;
                break;
            case ENUM_ACCESS_ALLOWED_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_ACE_TYPE;
                break;
            case ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
                break;
            case ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_DENIED_ACE_TYPE:
                bACEType = ACCESS_DENIED_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE:
                bACEType = ACCESS_DENIED_OBJECT_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_ALLOWED_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
                break;
            case ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                bACEType = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
                break;
            default:
                fReturn = false;
                break;
        }

        if(fReturn)
        {
            if(m_rgDACLSections[DaclType] == NULL)
            {
                try
                {
                    m_rgDACLSections[DaclType] = new CAccessEntryList;
                }
                catch(...)
                {
                    if(m_rgDACLSections[DaclType] != NULL)
                    {
                        delete m_rgDACLSections[DaclType];
                        m_rgDACLSections[DaclType] = NULL;
                    }
                    throw;
                }
                if(m_rgDACLSections[DaclType] != NULL)
                {
                    fReturn = m_rgDACLSections[DaclType]->AppendNoDup( psid, bACEType, bAceFlags, dwAccessMask, pguidObjGuid, pguidInhObjGuid );
                }
            }
            else
            {
                fReturn = m_rgDACLSections[DaclType]->AppendNoDup( psid, bACEType, bAceFlags, dwAccessMask, pguidObjGuid, pguidInhObjGuid );
            }
        }
	}
    else
    {
        fReturn = false;
    }

	return fReturn;
}




///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::RemoveDACLEntry
//
//	Removes an access allowed entry from the ACL.
//
//	Inputs:
//				CSID&		sid - PSID
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST match the supplied parameters.
//
///////////////////////////////////////////////////////////////////

bool CDACL::RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool	fReturn = false;

	// We need an ACE to compare
	CAccessEntry	ACE( &sid, DaclType, bAceFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask);
	ACLPOSITION		pos;

	if ( m_rgDACLSections[DaclType]->BeginEnum( pos ) )
	{
		// For loop will try to find a matching ACE in the list
	    CAccessEntry*	pACE = NULL;
        try
        {
    	    for (	pACE = m_rgDACLSections[DaclType]->GetNext( pos );
				    NULL != pACE
			    &&	!(ACE == *pACE);
				    pACE = m_rgDACLSections[DaclType]->GetNext( pos ) );

		    // If we got a match, delete the ACE.
		    if ( NULL != pACE )
		    {
			    m_rgDACLSections[DaclType]->Remove( pACE );
			    delete pACE;
			    fReturn = true;
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }

		m_rgDACLSections[DaclType]->EndEnum( pos );

	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::RemoveDACLEntry
//
//	Removes an access allowed entry from the ACL.
//
//	Inputs:
//				CSID&		sid - PSID
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST match the supplied parameters.
//
///////////////////////////////////////////////////////////////////

bool CDACL::RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool	fReturn = false;

	// We need an ACE to compare
	ACLPOSITION		pos;

	if ( m_rgDACLSections[DaclType]->BeginEnum( pos ) )
	{
		// For loop will try to find a matching ACE in the list
		CAccessEntry*	pACE = NULL;
        try
        {
            for (	CAccessEntry*	pACE = m_rgDACLSections[DaclType]->GetNext( pos );
				    NULL != pACE;
				    pACE = m_rgDACLSections[DaclType]->GetNext( pos ) )
		    {

			    CAccessEntry caeTemp(sid, DaclType, bAceFlags, pguidObjGuid, pguidInhObjGuid, pACE->GetAccessMask());
                // If we got a match, delete the ACE.
			    if (*pACE == caeTemp)
			    {
				    m_rgDACLSections[DaclType]->Remove( pACE );
				    fReturn = true;
				    break;
			    }
                delete pACE;
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
		m_rgDACLSections[DaclType]->EndEnum( pos );
	}
	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::RemoveDACLEntry
//
//	Removes an access allowed entry from the ACL.
//
//	Inputs:
//				CSID&		sid - PSID
//				DWORD		dwIndex - Index to remove.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST be dwIndex entry matching CSid.
//
///////////////////////////////////////////////////////////////////

bool CDACL::RemoveDACLEntry( CSid& sid, DACLTYPE DaclType, DWORD dwIndex /*= 0*/ )
{
	bool	fReturn = false;

	// We need an ACE to compare
	CSid			tempsid;
	ACLPOSITION		pos;
	DWORD			dwCtr = 0;

	if ( m_rgDACLSections[DaclType]->BeginEnum( pos ) )
	{

		// For each ACE we find, see if it is an ACCESS_ALLOWED_ACE_TYPE,
		// and if the Sid matches the one passed in.  If it does, increment
		// the counter, then if we're on the right index remove the ACE,
		// delete it and quit.
		CAccessEntry*	pACE = NULL;
        try
        {
            for (	pACE = m_rgDACLSections[DaclType]->GetNext( pos );
				    NULL != pACE;
				    pACE = m_rgDACLSections[DaclType]->GetNext( pos ) )
		    {
			    if ( DaclType == pACE->GetACEType() )
			    {
				    pACE->GetSID( tempsid );

				    if ( sid == tempsid )
				    {
					    if ( dwCtr == dwIndex )
					    {
						    m_rgDACLSections[DaclType]->Remove( pACE );
						    fReturn = true;
						    break;
					    }
					    else
					    {
						    ++dwCtr;
					    }
				    }
                    delete pACE;
			    }
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
		m_rgDACLSections[DaclType]->EndEnum( pos );
	}
	return fReturn;
}




///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::Find
//
//	Finds the specified ace in the dacl
//
//
//	Returns:
//				true if found it.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////
bool CDACL::Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
    bool fReturn = false;

    switch(bACEType)
    {
        case ACCESS_DENIED_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        default:
        {
            fReturn = false;
        }
    }
    return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::Find
//
//	Finds the specified ace in the dacl
//
//
//	Returns:
//				true if found it.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////
bool CDACL::Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
    bool fReturn = false;

    switch(bACEType)
    {
        case ACCESS_DENIED_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        {
            if(bACEFlags & INHERITED_ACE)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            else
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
                }
            }
            break;
        }
        default:
        {
            fReturn = false;
        }
    }

    return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::ConfigureDACL
//
//	Configures a Win32 PACL with DACL information, maintaining
//	proper canonical order.
//
//	Inputs:
//				None.
//
//	Outputs:
//				PACL&			pDacl - Pointer to a DACL.
//
//	Returns:
//				DWORD			ERROR_SUCCESS if successful.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CDACL::ConfigureDACL( PACL& pDacl )
{
	DWORD		dwReturn		=	ERROR_SUCCESS,
				dwDaclLength	=	0;

	// Since we actually fake a NULL DACL with full control access for everyone.
	// If that's what we have, then we have what we call a NULL DACL, so we
	// shouldn't allocate a PACL.

	if ( !IsNULLDACL() )
	{
		if ( CalculateDACLSize( &dwDaclLength ) )
		{
			if ( 0 != dwDaclLength )
			{
                pDacl = NULL;
                try
                {
				    pDacl = (PACL) malloc( dwDaclLength );

				    if ( NULL != pDacl )
				    {
					    if ( !InitializeAcl( (PACL) pDacl, dwDaclLength, ACL_REVISION ) )
					    {
						    dwReturn = ::GetLastError();
					    }

				    }	// If NULL != pDacl
                }
                catch(...)
                {
                    if(pDacl != NULL)
                    {
                        free(pDacl);
                        pDacl = NULL;
                    }
                    throw;
                }

			}	// If 0 != dwDaclLength
            else // we have an empty dacl
            {
                pDacl = NULL;
                try
                {
                    pDacl = (PACL) malloc( sizeof(ACL) );
                    if ( NULL != pDacl )
				    {
					    if ( !InitializeAcl( (PACL) pDacl, sizeof(ACL), ACL_REVISION ) )
					    {
						    dwReturn = ::GetLastError();
					    }

				    }	// If NULL != pDacl
                }
                catch(...)
                {
                    if(pDacl != NULL)
                    {
                        free(pDacl);
                        pDacl = NULL;
                    }
                    throw;
                }
            }

		}	// If Calcaulate DACL Size
		else
		{
			dwReturn = ERROR_INVALID_PARAMETER;	// One or more of the DACLs is bad
		}

		if ( ERROR_SUCCESS == dwReturn )
		{
			dwReturn = FillDACL( pDacl );
		}

		if ( ERROR_SUCCESS != dwReturn )
		{
			free( pDacl );
			pDacl = NULL;
		}

	}	// IF !IsNULLDACL

	return dwReturn;

}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::CalculateDACLSize
//
//	Obtains the size necessary to populate a DACL.
//
//	Inputs:
//				None.
//
//	Outputs:
//				LPDWORD			pdwDaclLength - Calculated Length.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CDACL::CalculateDACLSize( LPDWORD pdwDaclLength )
{
	BOOL			fReturn			=	TRUE;

	*pdwDaclLength = 0;


    for(short s = 0; s < NUM_DACL_TYPES && fReturn; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            fReturn = m_rgDACLSections[s]->CalculateWin32ACLSize( pdwDaclLength );
        }
    }
	return fReturn;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::FillDACL
//
//	Fills out a DACL, maintaining proper canonical order.
//
//	Inputs:
//				PACL			pDacl - Dacl to fill out.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CDACL::FillDACL( PACL pDacl )
{
	DWORD	dwReturn = E_FAIL;

	// For NT 5, we need to split out Inherited ACEs and add those in after the
	// current ones (which override).  The real trick here, is that the canonical
	// order of Access Denied, Access Denied Object, Access Allowed, Access Allowed Compound, Access Allowed Object,
    // Inherited Access Denied, Inherrited Access Denied Object, Inherited Access Allowed, Inherrited Access Allowed Compound,
    // and Inherrited Access Allowed Object must be maintained.

	// For prior versions, the only canonical order is Access Denied followed
	// by Access Allowed.

    // Create a working dacl
    CAccessEntryList t_daclCombined;

    ReassembleFromCanonicalSections(t_daclCombined);
    dwReturn = t_daclCombined.FillWin32ACL(pDacl);

	return dwReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::SplitIntoCanonicalSections
//
//	Splits a DACL by into its canonical parts.
//
//	Inputs:     accessentrylist to split up.  Results stored with
//              this CDACL.
//
//
//	Returns:
//				None.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////

bool CDACL::SplitIntoCanonicalSections
(
    CAccessEntryList& a_aclIn
)
{
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            delete m_rgDACLSections[s];
            m_rgDACLSections[s] = NULL;
        }
    }


    CAccessEntryList t_aclTemp;
    bool fRet = false;

    fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_DENIED_ACE_TYPE, false);
    if(!t_aclTemp.IsEmpty())
    {
        try
        {
            m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] = new CAccessEntryList;
        }
        catch(...)
        {
            if(m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] != NULL)
            {
                delete m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE];
                m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] = NULL;
            }
            throw;
        }

        m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE]->Copy(t_aclTemp);
        t_aclTemp.Clear();
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_DENIED_OBJECT_ACE_TYPE, false);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE];
                    m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_ACE_TYPE, false);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]!= NULL)
                {
                    delete m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE];
                    m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_COMPOUND_ACE_TYPE, false);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE];
                    m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_OBJECT_ACE_TYPE, false);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE];
                    m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_DENIED_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_DENIED_OBJECT_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_COMPOUND_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    if(fRet)
    {
        fRet = t_aclTemp.CopyByACEType(a_aclIn, ACCESS_ALLOWED_OBJECT_ACE_TYPE, true);
        if(!t_aclTemp.IsEmpty())
        {
            try
            {
                m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] != NULL)
                {
                    delete m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE];
                    m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] = NULL;
                }
                throw;
            }

            m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE]->Copy(t_aclTemp);
            t_aclTemp.Clear();
        }
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::ReassembleFromCanonicalSections
//
//	Reassembles a DACL by from its canonical parts.
//
//  Inputs: reference to accessentrylist that gets built up.

//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////

bool CDACL::ReassembleFromCanonicalSections
(
    CAccessEntryList& a_aclIn
)
{
    bool fRet = true;

    // and reassemble a new one (we rely on the fact that the enumeration
    // was layed out in the proper order) ...
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            fRet = a_aclIn.AppendList(*m_rgDACLSections[s]);
        }
    }

    return fRet;
}


bool CDACL::PutInNT5CanonicalOrder()
{
    bool t_fRet = false;
    CAccessEntryList t_ael;

    if(SplitIntoCanonicalSections(t_ael))
    {
        t_fRet = ReassembleFromCanonicalSections(t_ael);
    }
    return t_fRet;
}

bool CDACL::GetMergedACL
(
    CAccessEntryList& a_aclIn
)
{
    return ReassembleFromCanonicalSections(a_aclIn);
}


void CDACL::Clear()
{
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            delete m_rgDACLSections[s];
            m_rgDACLSections[s] = NULL;
        }
    }
}

bool CDACL::CopyDACL ( CDACL& dacl )
{
	bool fRet = true;

    Clear();

    for(short s = 0; s < NUM_DACL_TYPES && fRet; s++)
    {
        if(dacl.m_rgDACLSections[s] != NULL)
        {
            try
            {
                m_rgDACLSections[s] = new CAccessEntryList;
            }
            catch(...)
            {
                if(m_rgDACLSections[s] != NULL)
                {
                    delete m_rgDACLSections[s];
                    m_rgDACLSections[s] = NULL;
                }
                throw;
            }
            if(m_rgDACLSections[s] != NULL)
            {
                fRet = m_rgDACLSections[s]->Copy(*(dacl.m_rgDACLSections[s]));

            }
            else
            {
                fRet = false;
            }
        }
    }
    return fRet;
}

bool CDACL::AppendDACL ( CDACL& dacl )
{
	bool fRet = true;

    for(short s = 0; s < NUM_DACL_TYPES && fRet; s++)
    {
        if(dacl.m_rgDACLSections[s] != NULL)
        {
            if(m_rgDACLSections[s] == NULL)
            {
                try
                {
                    m_rgDACLSections[s] = new CAccessEntryList;
                }
                catch(...)
                {
                    if(m_rgDACLSections[s] != NULL)
                    {
                        delete m_rgDACLSections[s];
                        m_rgDACLSections[s] = NULL;
                    }
                    throw;
                }
            }

            if(m_rgDACLSections[s] != NULL)
            {
                fRet = m_rgDACLSections[s]->AppendList(*(dacl.m_rgDACLSections[s]));

            }
            else
            {
                fRet = false;
            }
        }
    }
    return fRet;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::IsNULLDACL
//
//	Checks our DACL Lists to see if we have a NULL DACL.  Which
//  means that all our lists are NULL, except for the
//  ACCESS_ALLOWED_ACE_TYPE list, which will have exactly one entry
//  in it - namely, an ACE for Everyone.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, a NULL DACL is the same as "Everyone" has Full Control,
//	so if a single Access Allowed entry exists that meets these
//	criteria, we consider ourselves to be NULL.
//
///////////////////////////////////////////////////////////////////

bool CDACL::IsNULLDACL()
{
	bool fReturn = false;

    // We have a NULL DACL if all the elements of our DACL array
    // are NULL
	if (m_rgDACLSections[ENUM_ACCESS_DENIED_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_INH_ACCESS_DENIED_ACE_TYPE] == NULL &&
		m_rgDACLSections[ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE] == NULL  &&
        m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_ACE_TYPE] == NULL &&
		m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE] == NULL &&
        m_rgDACLSections[ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE] == NULL)
	{
		if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
		{
			// There can be only one.
			if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->NumEntries() == 1)
			{
				CSid			sid(_T("Everyone"));
				CAccessEntry	ace;

				// Get the entry and check that it is "Everyone" with
				// Full Control and no flags
				if (m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->GetAt( 0, ace ) )
				{
					CSid	aceSID;

					ace.GetSID( aceSID );
					fReturn = (		sid == aceSID
								&&	ace.GetAccessMask() == AllAccessMask()
								&&	ace.GetACEFlags() == 0 );
				}
			}	// IF only one entry
		}
	}	// If we had entries in other lists, no go.

	return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::IsEmpty
//
//	Checks if our various lists are empty.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				bool   true if we have at least one entry in at
//                     least one of our lists.
//
//	Comments:
//
//
///////////////////////////////////////////////////////////////////

bool CDACL::IsEmpty()
{
    bool fIsEmpty = true;
    for(short s = 0; s < NUM_DACL_TYPES && fIsEmpty; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            fIsEmpty = m_rgDACLSections[s]->IsEmpty();
        }
    }
    return fIsEmpty;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CDACL::CreateNullDacl
//
//	NULLs out our DACL Lists except for the ACCESS_ALLOWED_ACE_TYPE
//  list, which it clears, then enters an Everybody ace into.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, an empty DACL is different from a NULL DACL, in that
//	empty means nobody has access and NULL means everyone has
//	full control.
//
///////////////////////////////////////////////////////////////////

bool CDACL::CreateNullDACL()
{
	bool fReturn = false;

	// Clear out our DACLs first...
    for(short s = 0; s < NUM_DACL_TYPES; s++)
    {
        if(m_rgDACLSections[s] != NULL)
        {
            delete m_rgDACLSections[s];
            m_rgDACLSections[s] = NULL;
        }
    }

    // then allocate an ACCESS_ALLOWED_ACE_TYPE dacl...
    try
    {
        m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] = new CAccessEntryList;
    }
    catch(...)
    {
        if(m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
        {
            delete m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE];
            m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] = NULL;
        }
        throw;
    }

    // then fake a null dacl by adding an Everyone entry...
	if (m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE] != NULL)
	{
		CSid	sid( _T("Everyone") );
        if(sid.IsOK() && sid.IsValid())
        {
		    fReturn = m_rgDACLSections[ENUM_ACCESS_ALLOWED_ACE_TYPE]->AppendNoDup(sid.GetPSid(),
                                                                                  ACCESS_ALLOWED_ACE_TYPE,
                                                                                  CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                                                                                  AllAccessMask(),
                                                                                  NULL,
                                                                                  NULL,
                                                                                  false,
                                                                                  false);
        }
	}

	return fReturn;

}


DWORD CDACL::AllAccessMask()
{
	return GENERIC_ALL;
    //return 0x01FFFFFF;
}


void CDACL::DumpDACL(LPCWSTR wstrFilename)
{
    CAccessEntryList aelCombo;

    Output(L"DACL contents follow...", wstrFilename);
    if(ReassembleFromCanonicalSections(aelCombo))
    {
        aelCombo.DumpAccessEntryList(wstrFilename);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllunreg.h ===
//=================================================================

//

// DllUnreg.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#pragma once

HRESULT UnregisterServer( REFGUID a_rguid );
HRESULT RegisterServer (

    TCHAR *a_pName,
    REFGUID a_rguid
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllunreg.cpp ===
//=================================================================

//

// DllUnreg.cpp

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#include "precomp.h"
extern HMODULE ghModule ;

//***************************************************************************
//
//  UnregisterServer
//
//  Given a clsid, remove the com registration
//
//***************************************************************************

HRESULT UnregisterServer( REFGUID a_rguid )
{
    WCHAR wcID[128];
    TCHAR szCLSID[128];
    TCHAR szProviderCLSIDAppID[128];
    HKEY  hKey;

    // Create the path using the CLSID

    StringFromGUID2( a_rguid, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    _tcscpy(szProviderCLSIDAppID, TEXT("SOFTWARE\\CLASSES\\APPID\\"));

#ifndef _UNICODE

    char szID[128];
    wcstombs(szID, wcID, 128);
    lstrcat(szCLSID, szID);
    _tcscat(szProviderCLSIDAppID, szID);

#else

    lstrcat(szCLSID, wcID);
    _tcscat(szProviderCLSIDAppID, wcID);

#endif

    DWORD dwRet ;

    //Delete entries under APPID

    dwRet = RegDeleteKey(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID);

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        dwRet = RegDeleteKey(hKey, _T("InProcServer32") );
        dwRet = RegDeleteKey(hKey, _T("LocalServer32"));
        CloseHandle(hKey);
    }

    dwRet = RegDeleteKeyW(HKEY_LOCAL_MACHINE, szCLSID);

    return NOERROR;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore ()
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( ! GetVersionEx ( & os ) )
    {
        return FALSE;           // should never happen
    }

    return os.dwMajorVersion >= 4;
}

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue (

    wchar_t *pszKey,
    wchar_t *pszSubkey,
    wchar_t *pszValueName,
    wchar_t *pszValue
)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
        _tcscat(szKey, _T("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, (LPCTSTR)pszValueName, 0, REG_SZ, (BYTE *)(LPCTSTR)pszValue
            , (_tcslen(pszValue)+1)*sizeof(TCHAR)))
            return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;
}

//***************************************************************************
//
//  RegisterServer
//
//  Given a clsid and a description, perform the com registration
//
//***************************************************************************

HRESULT RegisterServer (

    TCHAR *a_pName,
    REFGUID a_rguid
)
{
    WCHAR      wcID[128];
    TCHAR      szCLSID[128];
    TCHAR      szModule[MAX_PATH];
    TCHAR * pName = _T("WBEM Framework Instance Provider");
    TCHAR * pModel;
    HKEY hKey1;

    GetModuleFileName(ghModule, szModule,  MAX_PATH);

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = _T("Both") ;
    else
        pModel = _T("Apartment") ;

    // Create the path.

    StringFromGUID2(a_rguid, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));

#ifndef _UNICODE

    TCHAR      szID[128];
    wcstombs(szID, wcID, 128);
    lstrcat(szCLSID, szID);

#else

    lstrcat(szCLSID, wcID);

#endif

#ifdef LOCALSERVER

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID,TEXT("SOFTWARE\\CLASSES\\APPID\\"));

#ifndef _UNICODE

    TCHAR      szAPPID[128];
    wcstombs(szProviderCLSIDAppID, wcID, 128);
    lstrcat(szProviderCLSIDAppID, szID);

#else

    lstrcat(szProviderCLSIDAppID, wcID);

#endif

    if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_pName ))
        return SELFREG_E_CLASS;
#endif

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)a_pName, (lstrlen(a_pName)+1) *
        sizeof(TCHAR));


#ifdef LOCALSERVER

    if (FALSE ==SetKeyAndValue(szCLSID, _T("LocalServer32"), NULL,szModule))
        return SELFREG_E_CLASS;

    if (FALSE ==SetKeyAndValue(szCLSID, _T("LocalServer32"),_T("ThreadingModel"), pModel))
        return SELFREG_E_CLASS;
#else

    HKEY hKey2 ;
    RegCreateKey(hKey1, _T("InprocServer32"), &hKey2);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule,
        (lstrlen(szModule)+1) * sizeof(TCHAR));
    RegSetValueEx(hKey2, _T("ThreadingModel"), 0, REG_SZ,
        (BYTE *)pModel, (lstrlen(pModel)+1) * sizeof(TCHAR));

    CloseHandle(hKey2);

#endif

    CloseHandle(hKey1);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllutils.h ===
//=================================================================

//

// DllUtils.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _DLL_UTILS_H_
#define _DLL_UTILS_H_

#define UNRECOGNIZED_VARIANT_TYPE FALSE

#include "DllWrapperBase.h"
#include "Cim32NetApi.h"
#include "sid.h"
#include <list>

#ifdef UNICODE
#define W2A(w, a, cb)     lstrcpy (a, w)
#define A2W(a, w, cb)     lstrcpy (w, a)
#define TOBSTRT(x)        x
#else
#define W2A(w, a, cb)     WideCharToMultiByte(                              \
                                               CP_ACP,                      \
                                               0,                           \
                                               w,                           \
                                               -1,                          \
                                               a,                           \
                                               cb,                          \
                                               NULL,                        \
                                               NULL)

#define A2W(a, w, cb)     MultiByteToWideChar(                              \
                                               CP_ACP,                      \
                                               0,                           \
                                               a,                           \
                                               -1,                          \
                                               w,                           \
                                               cb)
#define TOBSTRT(x)        _bstr_t(x)
#endif

#define VWIN32_DIOC_DOS_IOCTL 1
#define VWIN32_DIOC_DOS_INT13 4
#define VWIN32_DIOC_DOS_DRIVEINFO 6

#define CARRY_FLAG  0x1

#define MAXITOA 18
#define MAXI64TOA 33

// In theory, this is defined in winnt.h, but not in our current one
#ifndef FILE_ATTRIBUTE_ENCRYPTED
#define FILE_ATTRIBUTE_ENCRYPTED        0x00000040 
#endif

typedef std::list<CHString> CHStringList;
typedef std::list<CHString>::iterator CHStringList_Iterator;

// To Get Cim32NetApi

#ifdef WIN9XONLY
CCim32NetApi* WINAPI GetCim32NetApiPtr();
void WINAPI FreeCim32NetApiPtr();
#endif

// platform identification
DWORD WINAPI GetPlatformMajorVersion(void);
DWORD WINAPI GetPlatformMinorVersion(void);
DWORD WINAPI GetPlatformBuildNumber(void);
#ifdef WIN9XONLY
bool WINAPI IsWin95(void);
bool WINAPI IsWin98(void);
bool WINAPI IsMillennium(void);
#endif
#ifdef NTONLY
bool WINAPI IsWinNT51(void);
bool WINAPI IsWinNT5(void);
bool WINAPI IsWinNT351(void);  
bool WINAPI IsWinNT4(void);    
#endif

// error logging
void WINAPI LogEnumValueError( LPCWSTR szFile, DWORD dwLine, LPCWSTR szKey, LPCWSTR szId );
void WINAPI LogOpenRegistryError( LPCWSTR szFile, DWORD dwLine, LPCWSTR szKey );
void WINAPI LogError( LPCTSTR szFile, DWORD dwLine, LPCTSTR szKey );
void WINAPI LogLastError( LPCTSTR szFile, DWORD dwLine );

class CConfigMgrDevice;
class CInstance;

void WINAPI SetConfigMgrProperties(CConfigMgrDevice *pDevice, CInstance *pInstance);

// map standard API return values (defined WinError.h)
// to WBEMish hresults (defined in WbemCli.h)
HRESULT WINAPI WinErrorToWBEMhResult(LONG error);

#pragma pack(1)
typedef struct _DEVIOCTL_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DEVIOCTL_REGISTERS, *PDEVIOCTL_REGISTERS;

typedef struct  BPB { /* */
   WORD wBytesPerSector;      // Bytes per sector
   BYTE btSectorsPerCluster;  // Sectors per cluster
   WORD wReservedSectors;     // Number of reserved sectors
   BYTE btNumFats;            // Number of FATs
   WORD wEntriesInRoot;       // Number of root-directory entries
   WORD wTotalSectors;        // Total number of sectors
   BYTE btMediaIdByte;        // Media descriptor
   WORD wSectorsPerFat;       // Number of sectors per FAT
   WORD wSectorsPerTrack;     // Number of sectors per track
   WORD wHeads;               // Number of heads
   DWORD dwHiddenSecs;        // Number of hidden sectors
   DWORD dwSectorsPerTrack;   // Number of sectors if wTotalSectors == 0
} BPB, *PBPB;

typedef struct _DEVICEPARMS {
   BYTE btSpecialFunctions;   // Special functions
   BYTE btDeviceType;         // Device type
   WORD wDeviceAttribs;       // Device attributes
   WORD wCylinders;           // Number of cylinders
   BYTE btMediaType;          // Media type
                        // Beginning of BIOS parameter block (BPB)
   BPB stBPB;
   BYTE  reserved[6];       //
} DEVICEPARMS, *PDEVICEPARMS;

typedef struct _A_BF_BPB {
    BPB stBPB;

    USHORT A_BF_BPB_BigSectorsPerFat;   /* BigFAT Fat sectors        */
    USHORT A_BF_BPB_BigSectorsPerFatHi; /* High word of BigFAT Fat sectrs  */
    USHORT A_BF_BPB_ExtFlags;           /* Other flags           */
    USHORT A_BF_BPB_FS_Version;         /* File system version       */
    USHORT A_BF_BPB_RootDirStrtClus;    /* Starting cluster of root directory */
    USHORT A_BF_BPB_RootDirStrtClusHi;  
    USHORT A_BF_BPB_FSInfoSec;          /* Sector number in the reserved   */
                                        /* area where the BIGFATBOOTFSINFO */
                                        /* structure is. If this is >=     */
                                        /* oldBPB.BPB_ReservedSectors or   */
                                        /* == 0 there is no FSInfoSec      */
    USHORT A_BF_BPB_BkUpBootSec;        /* Sector number in the reserved   */
                                        /* area where there is a backup    */
                                        /* copy of all of the boot sectors */
                                        /* If this is >=           */
                                        /* oldBPB.BPB_ReservedSectors or   */
                                        /* == 0 there is no backup copy.   */
    USHORT A_BF_BPB_Reserved[6];        /* Reserved for future expansion   */
} A_BF_BPB, *PA_BF_BPB;

#define MAX_SECTORS_IN_TRACK        128 // MAXIMUM SECTORS ON A DISK.

typedef struct A_SECTORTABLE  {
    WORD ST_SECTORNUMBER;
    WORD ST_SECTORSIZE;
} A_SECTORTABLE;

typedef struct _EA_DEVICEPARAMETERS {
    BYTE btSpecialFunctions;   // Special functions
    BYTE btDeviceType;         // Device type
    WORD wDeviceAttribs;       // Device attributes
    WORD dwCylinders;         // Number of cylinders
    BYTE btMediaType;          // Media type
    A_BF_BPB stBPB32;           // Fat32 Bios parameter block
    BYTE RESERVED1[32];
    WORD EDP_TRACKTABLEENTRIES;
    A_SECTORTABLE stSectorTable[MAX_SECTORS_IN_TRACK];
} EA_DEVICEPARAMETERS, *PEA_DEVICEPARAMETERS;

typedef struct _DRIVE_MAP_INFO {
   BYTE btAllocationLength;
   BYTE btInfoLength;
   BYTE btFlags;
   BYTE btInt13Unit;
   DWORD dwAssociatedDriveMap;
   __int64 i64PartitionStartRBA;
} DRIVE_MAP_INFO, *PDRIVE_MAP_INFO;

typedef struct _ExtGetDskFreSpcStruc {
    WORD Size;                      // Size of structure (out)
    WORD Level;                     // Level (must be zero)
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD AvailableClusters;
    DWORD TotalClusters;
    DWORD AvailablePhysSectors;
    DWORD TotalPhysSectors;
    DWORD AvailableAllocationUnits;
    DWORD TotalAllocationUnits;
    DWORD Rsvd1;
    DWORD Rsvd2;
} ExtGetDskFreSpcStruc, *pExtGetDskFreSpcStruc;

#pragma pack()


BOOL LoadStringW(CHString &sString, UINT nID);
void Format(CHString &sString, UINT nFormatID, ...);
void FormatMessageW(CHString &sString, UINT nFormatID, ...);
int LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf);


#ifdef WIN9XONLY
BOOL WINAPI GetDeviceParms(PDEVICEPARMS pstDeviceParms, UINT nDrive);
BOOL WINAPI GetDeviceParmsFat32(PEA_DEVICEPARAMETERS  pstDeviceParms, UINT nDrive);
BOOL WINAPI GetDriveMapInfo(PDRIVE_MAP_INFO pDriveMapInfo, UINT nDrive);
BOOL WINAPI VWIN32IOCTL(PDEVIOCTL_REGISTERS preg, DWORD dwCall);
BYTE WINAPI GetBiosUnitNumberFromPNPID(CHString strDeviceID);
#endif

#ifdef NTONLY
void WINAPI TranslateNTStatus( DWORD dwStatus, CHString & chsValue);
BOOL WINAPI GetServiceFileName(LPCTSTR szService, CHString &strFileName);
bool WINAPI GetServiceStatus( CHString a_chsService,  CHString &a_chsStatus ) ;
#endif

void WINAPI ConfigStatusToCimStatus ( DWORD a_Status , CHString &a_StringStatus ) ;

CHString WINAPI GetFileTypeDescription(LPCTSTR szExtension);
bool WINAPI CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2);

bool WINAPI GetManufacturerFromFileName(LPCTSTR szFile, CHString &strMfg);
bool WINAPI GetVersionFromFileName(LPCTSTR szFile, CHString &strVersion);

BOOL WINAPI EnablePrivilegeOnCurrentThread(LPCTSTR szPriv);

bool WINAPI GetFileInfoBlock(LPCTSTR szFile, LPVOID *pInfo);
bool WINAPI GetVarFromInfoBlock(LPVOID pInfo, LPCTSTR szVar, CHString &strValue);
BOOL WINAPI GetVersionLanguage(void *vpInfo, WORD *wpLang, WORD *wpCodePage);

BOOL WINAPI Get_ExtFreeSpace(BYTE btDriveName, ExtGetDskFreSpcStruc *pstExtGetDskFreSpcStruc);

HRESULT WINAPI GetHKUserNames(CHStringList &list);  

VOID WINAPI EscapeBackslashes(CHString& chstrIn, CHString& chstrOut);
VOID WINAPI EscapeQuotes(CHString& chstrIn, CHString& chstrOut);
VOID WINAPI RemoveDoubleBackslashes(const CHString& chstrIn, CHString& chstrOut);
CHString WINAPI RemoveDoubleBackslashes(const CHString& chstrIn);

void WINAPI SetSinglePrivilegeStatusObject(MethodContext* pContext, const WCHAR* pPrivilege);

bool WINAPI StrToIdentifierAuthority(const CHString& str, SID_IDENTIFIER_AUTHORITY& identifierAuthority);
bool WINAPI WhackToken(CHString& str, CHString& token);
PSID WINAPI StrToSID(const CHString& str);

#ifdef WIN9XONLY
class HoldSingleCim32NetPtr
{
public:
    HoldSingleCim32NetPtr();
    ~HoldSingleCim32NetPtr();
    static void WINAPI FreeCim32NetApiPtr();
    static CCim32NetApi* WINAPI GetCim32NetApiPtr();
private:
    static CCritSec m_csCim32Net;
    static HINSTANCE m_spCim32NetApiHandle ; 
};
#endif



// Used to get WBEM time from a filename.  We need this because FAT and NTFS 
// work differently.
enum FT_ENUM
{
    FT_CREATION_DATE,
    FT_MODIFIED_DATE,
    FT_ACCESSED_DATE
};

CHString WINAPI GetDateTimeViaFilenameFiletime(LPCTSTR szFilename, FILETIME *pFileTime);
CHString WINAPI GetDateTimeViaFilenameFiletime(LPCTSTR szFilename, FT_ENUM ftWhich);
CHString WINAPI GetDateTimeViaFilenameFiletime(BOOL bNTFS, FILETIME *pFileTime);


// Used to validate a numbered device ID is OK.
// Example: ValidateNumberedDeviceID("VideoController7", "VideoController", pdwWhich)
//          returns TRUE, pdwWhich = 7.
// Example: ValidateNumberedDeviceID("BadDeviceID", "VideoController", pdwWhich)
//          returns FALSE, pdwWhich unchanged
BOOL WINAPI ValidateNumberedDeviceID(LPCWSTR szDeviceID, LPCWSTR szTag, DWORD *pdwWhich);


// Critical sections used by various classes.
extern CCritSec g_csPrinter;
extern CCritSec g_csSystemName;
#ifdef WIN9XONLY
extern CCritSec g_csVXD;
#endif

bool WINAPI DelayLoadDllExceptionFilter(PEXCEPTION_POINTERS pep); 


#ifdef NTONLY
HRESULT CreatePageFile(
    LPCWSTR wstrPageFileName,
    const LARGE_INTEGER liInitial,
    const LARGE_INTEGER liMaximum,
    const CInstance& Instance);
#endif



#if NTONLY >= 5
bool GetAllUsersName(CHString& chstrAllUsersName);
bool GetDefaultUsersName(CHString& chstrDefaultUsersName);
bool GetCommonStartup(CHString& chstrCommonStartup);
#endif

BOOL GetLocalizedNTAuthorityString(
    CHString& chstrNT_AUTHORITY);

BOOL GetLocalizedBuiltInString(
    CHString& chstrBuiltIn);

BOOL GetSysAccountNameAndDomain(
    PSID_IDENTIFIER_AUTHORITY a_pAuthority,
    CSid& a_accountsid,
    BYTE  a_saCount = 0,
    DWORD a_dwSubAuthority1 = 0,
    DWORD a_dwSubAuthority2 = 0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllwrappercreatorreg.h ===
//=================================================================

//

// DllWrapperCreatorReg.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "ResourceManager.h"
#include <ProvExce.h>



/******************************************************************************
 * Register this class with the CResourceManager. 
 *****************************************************************************/
 
template<class a_T, const GUID* a_pguidT, const TCHAR* a_ptstrDllName>
class CDllApiWraprCreatrReg 
{
public:
	CDllApiWraprCreatrReg()
    {
        CResourceManager::sm_TheResourceManager.AddInstanceCreator(*a_pguidT, ApiWraprCreatrFn);
    }

	~CDllApiWraprCreatrReg(){}

	static CResource* ApiWraprCreatrFn
    (
        PVOID pData
    )
    {
        a_T* t_pT = NULL ;
		
		if( !(t_pT = (a_T*) new a_T(a_ptstrDllName) ) )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

        try
		{
			if( t_pT->Init() )
            {
                return t_pT ;
            }
            else
            {
				delete t_pT ;
                return NULL ;
            }
        }
        catch( ... )
	    {
       		delete t_pT ;
			throw ; 
	    }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllwrapperbase.cpp ===
//=================================================================

//

// DllWrapperBase.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "DllWrapperBase.h"
#include <..\..\framework\provexpt\include\provexpt.h>






/******************************************************************************
 * Constructor
 ******************************************************************************/
CDllWrapperBase::CDllWrapperBase(LPCTSTR a_tstrWrappedDllName)
 : m_tstrWrappedDllName(a_tstrWrappedDllName),
   m_hDll(NULL)
{

}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CDllWrapperBase::~CDllWrapperBase()
{
    if(m_hDll != NULL)
	{
	    FreeLibrary(m_hDll);
	}
}


/******************************************************************************
 * Initialization function to load the dll, obtain function addresses, and
 * check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 ******************************************************************************/
// bool CDllWrapperBase::Init()
// << PURE VIRTUAL FUNCTION -> DERIVED CLASSES MUST OVERLOAD.



/******************************************************************************
 * Helper for loading the dll that hides the implementation.  Returns true
 * if we succeeded in obtaining a handle to the dll.
 ******************************************************************************/
bool CDllWrapperBase::LoadLibrary()
{
    bool t_fRet = false;
    if(m_hDll != NULL)
    {
        FreeLibrary(m_hDll);
    }
    if((m_hDll = ::LoadLibrary(m_tstrWrappedDllName)) != NULL)
    {
        t_fRet = true;
    }
    else
    {
        LogErrorMessage2(L"Failed to load library: %s", m_tstrWrappedDllName);
    }

    return t_fRet;
}


/******************************************************************************
 * Helper for getting proc addresses that hides the implementation.
 ******************************************************************************/
FARPROC CDllWrapperBase::GetProcAddress(LPCSTR a_strProcName)
{
    FARPROC t_fpProc = NULL;
    if(m_hDll != NULL)
    {
        t_fpProc = ::GetProcAddress(m_hDll, a_strProcName);
    }
    return t_fpProc;
}

/******************************************************************************
 * Helper for retrieving the version of the dll wrapped by this class.
 ******************************************************************************/
BOOL CDllWrapperBase::GetDllVersion(CHString& a_chstrVersion)
{
    return (GetVarFromVersionInfo(
             m_tstrWrappedDllName,   // Name of file to get ver info about
             _T("ProductVersion"),   // String identifying resource of interest
             a_chstrVersion));       // Buffer to hold version string
}


/******************************************************************************
 * Member functions wrapping Kernel32 api functions. Add new functions here
 * as required.
 ******************************************************************************/

// << Section empty in base class only. >>


/******************************************************************************
 * Private parts.
 ******************************************************************************/
BOOL CDllWrapperBase::GetVarFromVersionInfo
(
    LPCTSTR a_szFile,
    LPCTSTR a_szVar,
    CHString &a_strValue
)
{
	BOOL    t_fRc = FALSE;
	DWORD   t_dwTemp;
    DWORD   t_dwBlockSize = 0L;
	LPVOID  t_pInfo = NULL;

	// Use of delay loaded function requires exception handler.
    SetStructuredExceptionHandler seh;

    try
    {
        t_dwBlockSize = ::GetFileVersionInfoSize((LPTSTR) a_szFile, &t_dwTemp);

	    if (t_dwBlockSize)
        {
		    t_pInfo = (LPVOID) new BYTE[t_dwBlockSize + 4];

			if ( !t_pInfo )
           	{
				throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
			}

			UINT t_len;

			memset( t_pInfo, NULL, t_dwBlockSize + 4);

			if (::GetFileVersionInfo((LPTSTR) a_szFile, 0, t_dwBlockSize, t_pInfo))
            {
				WORD wLang = 0;
				WORD wCodePage = 0;
				if(!GetVersionLanguage(t_pInfo, &wLang, &wCodePage) )
				{
					// on failure: default to English

					// this returns a pointer to an array of WORDs
					WORD *pArray;
                    bool fGotTranslation = false;

					fGotTranslation = ::VerQueryValue(
                        t_pInfo, _T("\\VarFileInfo\\Translation"),
                        (void **)(&pArray), 
                        &t_len);
                    
                    if(fGotTranslation)
					{
						t_len = t_len / sizeof(WORD);

						// find the english one...
						for (int i = 0; i < t_len; i += 2)
						{
							if( pArray[i] == 0x0409 )	{
								wLang	  = pArray[i];
								wCodePage = pArray[i + 1];
								break;
							}
						}
					}
				}

				TCHAR   *pMfg, szTemp[256];
				wsprintf(szTemp, _T("\\StringFileInfo\\%04X%04X\\%s"), wLang, wCodePage, a_szVar);
                bool fGotCodePageInfo = false;

                fGotCodePageInfo = ::VerQueryValue(
                    t_pInfo, 
                    szTemp, (void **)
                    (&pMfg), 
                    &t_len);

                if(fGotCodePageInfo)
                {
                    a_strValue = pMfg;
					t_fRc = TRUE;
				}
			}

			delete t_pInfo;
			t_pInfo = NULL ;
	    }

    }
    catch(Structured_Exception se)
    {
        DelayLoadDllExceptionFilter(se.GetExtendedInfo()); 
        if (t_pInfo)
		{
			delete t_pInfo ;
		}
        t_fRc = FALSE;   
    }
    catch(...)
    {
        if (t_pInfo)
		{
			delete t_pInfo ;
		}
		throw ;
    }

    return t_fRc;
}


BOOL CDllWrapperBase::GetVersionLanguage
(
    void *a_vpInfo,
    WORD *a_wpLang,
    WORD *a_wpCodePage
)
{
    WORD *t_wpTemp;
    WORD t_wLength;
    WCHAR *t_wcpTemp;
    char *t_cpTemp;
    BOOL t_bRet = FALSE;

    t_wpTemp = (WORD *) a_vpInfo;
    t_cpTemp = (char *) a_vpInfo;

    t_wpTemp++; // jump past buffer length.
    t_wLength = *t_wpTemp;  // capture value length.
    t_wpTemp++; // skip past value length to what should be type code in new format
    if (*t_wpTemp == 0 || *t_wpTemp == 1) // new format expect unicode strings.
    {
		t_cpTemp = t_cpTemp + 38 + t_wLength + 8;
		t_wcpTemp = (WCHAR *) t_cpTemp;
        if (wcscmp(L"StringFileInfo", t_wcpTemp) == 0) // OK! were aligned properly.
        {
			t_bRet = TRUE;

			t_cpTemp += 30; // skip over "StringFileInfo"
			while ((DWORD_PTR) t_cpTemp % 4 > 0) // 32 bit align
				t_cpTemp++;

			t_cpTemp += 6; // skip over length and type fields.

			t_wcpTemp = (WCHAR *) t_cpTemp;
			swscanf(t_wcpTemp, L"%4x%4x", a_wpLang, a_wpCodePage);
        }
    }
    else  // old format, expect single byte character strings.
    {
        t_cpTemp += 20 + t_wLength + 4;
        if (strcmp("StringFileInfo", t_cpTemp) == 0) // OK! were aligned properly.
        {
			t_bRet = TRUE;

			t_cpTemp += 20; // skip over length fields.
			sscanf(t_cpTemp, "%4x%4x", a_wpLang, a_wpCodePage);
        }
    }
	return (t_bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllutils.cpp ===
//=================================================================

//

// DllUtils.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================
#include "precomp.h"
#include <cregcls.h>
#include <assertbreak.h>
#include <lockwrap.h>
#include <lmerr.h>
#include <createmutexasprocess.h>
#include <CCriticalSec.h>
#include <CAutoLock.h>
#include "dllmain.h"

#ifdef WIN9XONLY
#include <win32thk.h>
#endif

#include <CRegCls.h>
#include <delayimp.h>

#define UNRECOGNIZED_VARIANT_TYPE FALSE

DWORD   g_dwMajorVersion,
        g_dwMinorVersion,
        g_dwBuildNumber;

CCriticalSec g_CSFlakyFileVersionAPI;

// There is a problem with loading Cim32Net.dll over and over, so this code
// makes sure we only load it once, then unloads it at exit.
// these are used with GetCim32NetHandle

#ifdef WIN9XONLY
HoldSingleCim32NetPtr::HoldSingleCim32NetPtr()
{
}

// Initialize the static members
HINSTANCE HoldSingleCim32NetPtr::m_spCim32NetApiHandle = NULL;
CCritSec HoldSingleCim32NetPtr::m_csCim32Net;

HoldSingleCim32NetPtr::~HoldSingleCim32NetPtr()
{
//    FreeCim32NetApiPtr();
}

void HoldSingleCim32NetPtr::FreeCim32NetApiPtr()
{
    CLockWrapper Cim32NetLock( m_csCim32Net ) ;
	if (m_spCim32NetApiHandle)
    {
        FreeLibrary ( m_spCim32NetApiHandle );
        m_spCim32NetApiHandle = NULL;
    }
}

CCim32NetApi* HoldSingleCim32NetPtr::GetCim32NetApiPtr()
{
    CCim32NetApi* pNewCim32NetApi = NULL ;
	{
        // Avoid contention on static
        CLockWrapper Cim32NetLock( m_csCim32Net ) ;

        // Check for race condition
        if (m_spCim32NetApiHandle == NULL)
        {
            m_spCim32NetApiHandle = LoadLibrary ( "Cim32Net.dll" ) ;
        }

        if (m_spCim32NetApiHandle != NULL)
        {
		    pNewCim32NetApi = (CCim32NetApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidCim32NetApi, NULL);
        }
        else
        {
            LogErrorMessage2(L"Failed to loadlibrary Cim32Net.dll (0x%x)", GetLastError());
        }
	}

    return pNewCim32NetApi;
}

HoldSingleCim32NetPtr g_GlobalInstOfHoldSingleCim32NetPtr;


#endif




class CInitDllUtilsData
{
public:
    CInitDllUtilsData();
};

CInitDllUtilsData::CInitDllUtilsData()
{
	OSVERSIONINFO version = { sizeof(version) };

	GetVersionEx((LPOSVERSIONINFO) &version);

    g_dwMajorVersion = version.dwMajorVersion;
    g_dwMinorVersion = version.dwMinorVersion;
    g_dwBuildNumber = version.dwBuildNumber;
}

// So we can cache OS info automatically.
static CInitDllUtilsData dllUtilsData;

#ifdef NTONLY
// sets a status object with one single missing privilege
void WINAPI SetSinglePrivilegeStatusObject(MethodContext* pContext, const WCHAR* pPrivilege)
{
	SAFEARRAY *psaPrivilegesReqd, *psaPrivilegesNotHeld;
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].cElements = 1;
	rgsabound[0].lLbound = 0;
	psaPrivilegesReqd = SafeArrayCreate(VT_BSTR, 1, rgsabound);
	psaPrivilegesNotHeld = SafeArrayCreate(VT_BSTR, 1, rgsabound);

    if (psaPrivilegesReqd && psaPrivilegesNotHeld)
    {
        try
        {
            long index = 0;
            bstr_t privilege(pPrivilege);
            SafeArrayPutElement(psaPrivilegesReqd, &index, (void*)(BSTR)privilege);
            SafeArrayPutElement(psaPrivilegesNotHeld, &index, (void*)(BSTR)privilege);
            CWbemProviderGlue::SetStatusObject(pContext, IDS_CimWin32Namespace,
                L"Required privilege not enabled", WBEM_E_FAILED, psaPrivilegesNotHeld, psaPrivilegesReqd);
        }
        catch ( ... )
        {
            SafeArrayDestroy(psaPrivilegesNotHeld);
            SafeArrayDestroy(psaPrivilegesReqd);
            throw ;
        }

        SafeArrayDestroy(psaPrivilegesNotHeld);
        SafeArrayDestroy(psaPrivilegesReqd);
    }
    else
    {
        if (psaPrivilegesNotHeld)
            SafeArrayDestroy(psaPrivilegesNotHeld);
        if (psaPrivilegesReqd)
            SafeArrayDestroy(psaPrivilegesReqd);

        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

}
#endif

DWORD WINAPI GetPlatformBuildNumber(void)
{
	return g_dwBuildNumber;
}

// 3 for NT 3.51
// 4 for NT 4.0, W95 & W98
DWORD WINAPI GetPlatformMajorVersion(void)
{
	return g_dwMajorVersion;
}

// 0 for W95, 10 for 98
DWORD WINAPI GetPlatformMinorVersion(void)
{
	return g_dwMajorVersion;
}

#ifdef WIN9XONLY
// returns TRUE iff the current OS is Win 98+
// false for NT or Win 95
bool WINAPI IsWin95(void)
{
	return g_dwMinorVersion == 0;
}

bool WINAPI IsWin98(void)
{
	return g_dwMinorVersion >= 10;
}

bool WINAPI IsMillennium(void)
{
	return g_dwMinorVersion >= 90;
}
#endif

#ifdef NTONLY
bool WINAPI IsWinNT51(void)
{
	return (g_dwMajorVersion >= 5 && g_dwMinorVersion == 1);
}

bool WINAPI IsWinNT5(void)
{
	return g_dwMajorVersion >= 5;
}

bool WINAPI IsWinNT4(void)
{
	return g_dwMajorVersion == 4;
}

bool WINAPI IsWinNT351(void)
{
	return g_dwMajorVersion	== 3 && g_dwMinorVersion	== 51;
}
#endif

/////////////////////////////////////////////////////////////////////
void WINAPI LogEnumValueError( LPCWSTR szFile, DWORD dwLine, LPCWSTR szKey, LPCWSTR szId )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_REGISTRY_ENUM_VALUE_FOR_KEY, szId, szKey);
		LogErrorMessageEx(gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
void WINAPI LogOpenRegistryError( LPCWSTR szFile, DWORD dwLine, LPCWSTR szKey )
{
	if (IsErrorLoggingEnabled())
	{
		CHString gazotta;
		gazotta.Format(ERR_OPEN_REGISTRY, szKey);

		LogErrorMessageEx(gazotta, szFile, dwLine);
	}
}
/////////////////////////////////////////////////////////////////////
// left in for hysterical purposes
// prefer to use LogMessage macro in BrodCast.h
//void LogError( char * szFile, DWORD dwLine, char * szKey )
//{
//	LogErrorMessageEx(szKey, szFile, dwLine);
//}
/////////////////////////////////////////////////////////////////////
void WINAPI LogLastError( LPCTSTR szFile, DWORD dwLine )
{
	if (IsErrorLoggingEnabled())
	{
		DWORD duhWord = GetLastError();
		CHString gazotta;
		gazotta.Format(IDS_GETLASTERROR, duhWord, duhWord);

		LogErrorMessageEx(gazotta, TOBSTRT(szFile), dwLine);
    }
}

///////////////////////////////////////////////////////////////////////
BOOL WINAPI GetValue( CRegistry & Reg,
               LPCWSTR szKey,
               LPCWSTR ValueName,
               CHString * pchsValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);

	if( !bRet )
        LogEnumValueError(_T2(__FILE__), __LINE__, szKey, ValueName);

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL WINAPI GetValue( CRegistry & Reg,
               LPCWSTR szKey,
               LPCWSTR ValueName,
               DWORD * dwValueBuffer )
{
    BOOL bRet = (Reg.GetCurrentKeyValue( ValueName, *dwValueBuffer) == ERROR_SUCCESS);

	if( !bRet )
        LogEnumValueError(_T2(__FILE__),__LINE__, TOBSTRT(szKey), TOBSTRT(ValueName));

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL WINAPI OpenAndGetValue( CRegistry & Reg,
                      LPCWSTR szKey,
                      LPCWSTR ValueName,
                      CHString * pchsValueBuffer )
{
	BOOL bRet = ( Reg.OpenLocalMachineKeyAndReadValue( szKey, ValueName, *pchsValueBuffer )== ERROR_SUCCESS);

	if( !bRet )
        LogEnumValueError(_T2(__FILE__),__LINE__, szKey, ValueName);

    return bRet;
}
///////////////////////////////////////////////////////////////////////
BOOL WINAPI GetBinaryValue( CRegistry & Reg, LPCWSTR szKey,
                     LPCWSTR ValueName, CHString * pchsValueBuffer )
{
    BOOL bRet = ( Reg.GetCurrentBinaryKeyValue( ValueName, *pchsValueBuffer) == ERROR_SUCCESS);

    if( !bRet )
        (LogEnumValueError(_T2(__FILE__),__LINE__, szKey, ValueName));

    return bRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetDeviceParms
 *
 *  DESCRIPTION : Gets drive characteristics (heads, tracks, cylinders, etc)
 *
 *  INPUTS      : Pointer to a DEVICEPARMS struct to receive the data
 *                Drive number of the drive to query (0 = default drive,
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI GetDeviceParms(PDEVICEPARMS pstDeviceParms, UINT nDrive)
{
    DEVIOCTL_REGISTERS reg;
    memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

    reg.reg_EAX = 0x440D;       /* IOCTL for block devices */
    reg.reg_EBX = nDrive;       /* zero-based drive ID     */
    reg.reg_ECX = 0x0860;       /* Get Media ID command    */
    reg.reg_EDX = (DWORD) pstDeviceParms;

    memset(pstDeviceParms, 0, sizeof(DEVICEPARMS));

    if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
        return FALSE;

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */
        return FALSE;

    // While the docs say failure will set carry, experience shows
    // this isn't true.  So, if carry is clear, and ax is zero, we'll
    // assume that things are ok.
    if (reg.reg_EAX == 0)
        return TRUE;

    // If they didn't change the value, we'll assume that they followed
    // the spec and are correctly setting carry.
    if (reg.reg_EAX == 0x440d)
        return TRUE;

    // Otherwise, assume they are incorrectly setting carry, and have returned
    // a failure code.
    return FALSE;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : GetDeviceParmsFat32
 *
 *  DESCRIPTION : Gets drive characteristics (heads, tracks, cylinders, etc)
 *                for Fat32 drives.
 *
 *  INPUTS      : Pointer to a EA_DEVICEPARMS struct to receive the data
 *                Drive number of the drive to query (0 = default drive,
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI GetDeviceParmsFat32(PEA_DEVICEPARAMETERS  pstDeviceParms, UINT nDrive)
{
    DEVIOCTL_REGISTERS reg;
    memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

    reg.reg_EAX = 0x440D;       /* IOCTL for block devices */
    reg.reg_EBX = nDrive;       /* zero-based drive ID     */
    reg.reg_ECX = 0x4860;       /* Get Media ID command    */
    reg.reg_EDX = (DWORD) pstDeviceParms;

    memset(pstDeviceParms, 0, sizeof(EA_DEVICEPARAMETERS));

    if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
        return FALSE;

    if (reg.reg_Flags & 0x8000) /* error if carry flag set */
        return FALSE;

    return TRUE;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : GetDriveMapInfo
 *
 *  DESCRIPTION : Gets logical to physical mapping info
 *
 *  INPUTS      : Pointer to a DRIVE_MAP_INFO struct to receive the data
 *                Drive number of the drive to query (0 = default drive,
 *                   1 = A, 2 = B, and so on)
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI GetDriveMapInfo(PDRIVE_MAP_INFO pDriveMapInfo, UINT nDrive)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));

   reg.reg_EAX = 0x440d;      /* IOCTL for block devices */
   reg.reg_EBX = nDrive;      /* zero-based drive ID     */
   reg.reg_ECX = 0x086f;      /* Get Drive Map Info */
   reg.reg_EDX = (DWORD) pDriveMapInfo;

   // zero the struct
   memset(pDriveMapInfo, 0, sizeof(DRIVE_MAP_INFO));

   // Set the length byte
   pDriveMapInfo->btAllocationLength = sizeof(DRIVE_MAP_INFO);

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_IOCTL))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : Get_ExtFreeSpace
 *
 *  DESCRIPTION : Gets detailed info about a partition
 *
 *  INPUTS      : Drive number of the drive to query (0 = default drive,
 *                   1 = A, 2 = B, and so on)
 *                Pointer to ExtGetDskFreSpcStruct
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI Get_ExtFreeSpace(BYTE btDriveName, ExtGetDskFreSpcStruc *pstExtGetDskFreSpcStruc)
{
   DEVIOCTL_REGISTERS reg;
   memset(&reg, '\0', sizeof(DEVIOCTL_REGISTERS));
   char szDrive[4];

   szDrive[0] = btDriveName;
   szDrive[1] = ':';
   szDrive[2] = '\\';
   szDrive[3] = '\0';

   reg.reg_EAX = 0x7303;							// Get_ExtFreeSpace
   reg.reg_ECX = sizeof(ExtGetDskFreSpcStruc);		// Size of the structure sent in
   reg.reg_EDI = (DWORD)pstExtGetDskFreSpcStruc;	// Structure
   reg.reg_EDX = (DWORD)szDrive;					// Drive to get info for

   // zero the struct
   memset(pstExtGetDskFreSpcStruc, 0, sizeof(ExtGetDskFreSpcStruc));

   // Doit
   if (!VWIN32IOCTL(&reg, VWIN32_DIOC_DOS_DRIVEINFO))
      return FALSE;

   if (reg.reg_Flags & 0x8000) {/* error if carry flag set */
      return FALSE;
   }

   return TRUE;

}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : VWIN32IOCTL
 *
 *  DESCRIPTION : Calls IOControl against the vwin32 vxd
 *
 *  INPUTS      : Pointer to DEVIOCTL_REGISTERS structure
 *                IOControl call number.
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : TRUE if successful, FALSE otherwise
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef WIN9XONLY
BOOL WINAPI VWIN32IOCTL(PDEVIOCTL_REGISTERS preg, DWORD dwCall)
{

    BOOL fResult;
    DWORD cb;

    preg->reg_Flags = 0x8000; /* assume error (carry flag set) */

    SmartCloseHandle hDevice = CreateFile(_T("\\\\.\\VWIN32"), 0, 0, 0, OPEN_EXISTING,
        FILE_FLAG_DELETE_ON_CLOSE, 0);

    if (hDevice == (HANDLE) INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    else
    {
        fResult = DeviceIoControl(hDevice, dwCall, preg, sizeof(*preg), preg, sizeof(*preg), &cb, 0);
    }

    if (!fResult)
    {
        return FALSE;
    }

    return TRUE;
}
#endif

CHString WINAPI GetFileTypeDescription(LPCTSTR szExtension)
{
   CRegistry RegInfo;
   CHString sTemp, sType(szExtension);

   if (RegInfo.Open(HKEY_CLASSES_ROOT, TOBSTRT(szExtension), KEY_READ) == ERROR_SUCCESS) {
      RegInfo.GetCurrentKeyValue(L"", sTemp);

      if (RegInfo.Open(HKEY_CLASSES_ROOT, sTemp, KEY_READ) == ERROR_SUCCESS) {
         RegInfo.GetCurrentKeyValue(L"", sType);
      }
   }

   return sType;
}

void WINAPI ConfigStatusToCimStatus ( DWORD a_Status , CHString &a_StringStatus )
{
	if( a_Status & DN_ROOT_ENUMERATED  ||
		a_Status & DN_DRIVER_LOADED ||
		a_Status & DN_ENUM_LOADED ||
		a_Status & DN_STARTED )
	{
		a_StringStatus = IDS_STATUS_OK;
	}

		// we don't care about these:
		// DN_MANUAL,DN_NOT_FIRST_TIME,DN_HARDWARE_ENUM,DN_FILTERED
		// DN_DISABLEABLE, DN_REMOVABLE,DN_MF_PARENT,DN_MF_CHILD
	    // DN_NEED_TO_ENUM, DN_LIAR,DN_HAS_MARK

	if( a_Status & DN_MOVED ||
		a_Status & DN_WILL_BE_REMOVED)
	{
		a_StringStatus = IDS_STATUS_Degraded;
	}

	if( a_Status & DN_HAS_PROBLEM ||
		a_Status & DN_PRIVATE_PROBLEM)
	{
		a_StringStatus = IDS_STATUS_Error;
	}
}

#ifdef NTONLY
///////////////////////////////////////////////////////////////////
//
// Define the severity codes
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error

//
// Define the severity codes
//
//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#define SEV_MASK 0xC0000000
void WINAPI TranslateNTStatus( DWORD dwStatus, CHString & chsValue)
{

	switch((dwStatus & SEV_MASK) >> 30){

		case STATUS_SEVERITY_WARNING:
			chsValue = IDS_STATUS_Degraded;
			break;

		case STATUS_SEVERITY_SUCCESS:
			chsValue = IDS_STATUS_OK;
			break;

		case STATUS_SEVERITY_ERROR:
			chsValue = IDS_STATUS_Error;
			break;

		case STATUS_SEVERITY_INFORMATIONAL:
			chsValue = IDS_STATUS_OK;
			break;

		default:
			chsValue = IDS_STATUS_Unknown;
	}
}
#endif

//
#ifdef NTONLY
bool WINAPI GetServiceStatus( CHString a_chsService,  CHString &a_chsStatus )
{
	bool		t_bRet = false ;
	SC_HANDLE	t_hDBHandle	= NULL ;
	SC_HANDLE	t_hSvcHandle	= NULL ;

	try
	{
		if( t_hDBHandle = OpenSCManager( NULL, NULL, GENERIC_READ ) )
		{
			t_bRet = true ;

			if( t_hSvcHandle = OpenService (
				t_hDBHandle,
				a_chsService,
				SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_INTERROGATE ) )
			{
				SERVICE_STATUS t_StatusInfo ;
				if ( ControlService( t_hSvcHandle, SERVICE_CONTROL_INTERROGATE, &t_StatusInfo ) )
				{
					switch( t_StatusInfo.dwCurrentState )
					{
						case SERVICE_STOPPED:
						{
							a_chsStatus = L"Degraded" ;
						}
						break ;

						case SERVICE_START_PENDING:
						{
							a_chsStatus = L"Starting" ;
						}
						break ;

						case SERVICE_STOP_PENDING:
						{
							a_chsStatus = L"Stopping" ;
						}
						break ;

						case SERVICE_RUNNING:
						case SERVICE_PAUSE_PENDING:
						{
							a_chsStatus = L"OK" ;
						}
						break ;

						case SERVICE_PAUSED:
						case SERVICE_CONTINUE_PENDING:
						{
							a_chsStatus = L"Degraded" ;
						}
						break ;
					}
				}
				else
				{
					a_chsStatus = L"Unknown" ;
				}

				CloseServiceHandle( t_hSvcHandle ) ;
				t_hSvcHandle = NULL ;
			}
			else
			{
				a_chsStatus = L"Unknown" ;
			}

			CloseServiceHandle( t_hDBHandle ) ;
			t_hDBHandle = NULL ;
		}
	}
	catch( ... )
	{
		if( t_hSvcHandle )
		{
			CloseServiceHandle( t_hSvcHandle ) ;
		}

		if( t_hDBHandle )
		{
			CloseServiceHandle( t_hDBHandle ) ;
		}

		throw ;
	}
	return t_bRet ;
}
#endif

//
bool WINAPI GetFileInfoBlock(LPCTSTR szFile, LPVOID *pInfo)
{
	BOOL    fRet = false;
	DWORD   dwTemp,
	        dwBlockSize;
    LPVOID pInfoTemp = NULL;

    if(pInfo != NULL)
    {
        try
        {
			CAutoLock cs(g_CSFlakyFileVersionAPI);
            dwBlockSize = GetFileVersionInfoSize((LPTSTR) szFile, &dwTemp);
	        if(dwBlockSize)
            {
		        pInfoTemp = (LPVOID) new BYTE[dwBlockSize + 4];
		        if(pInfoTemp != NULL)
                {
    			    memset( pInfoTemp, NULL, dwBlockSize + 4);
			        if (GetFileVersionInfo((LPTSTR) szFile, 0, dwBlockSize, pInfoTemp))
                    {
				        *pInfo = pInfoTemp;
                        fRet = true;
			        }
		        }
                else
                {
                    throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                }
	        }
        }
        catch(...)
        {
            // We don't need to do anything else, just need to protect ourselves
            // from the flaky version.dll calls.
        }
    }
	return fRet;
}


bool WINAPI GetVarFromInfoBlock(LPVOID pInfo, LPCTSTR szVar, CHString &strValue)
{
	bool    fRet = false;

	try
    {
		if(pInfo != NULL)
        {
			WORD wLang = 0;
            WORD wCodePage = 0;
            UINT len;
            if(!GetVersionLanguage(pInfo, &wLang, &wCodePage) )
			{
				// on failure: default to English
				// this returns a pointer to an array of WORDs
				WORD *pArray;
				if (VerQueryValue(pInfo, _T("\\VarFileInfo\\Translation"), (void **)(&pArray), &len))
				{
					len = len / sizeof(WORD);

					// find the english one...
					for (int i = 0; i < len; i += 2)
					{
						if( pArray[i] == 0x0409 )
                        {
							wLang	  = pArray[i];
							wCodePage = pArray[i + 1];
							break;
						}
					}
				}
			}

			TCHAR *pMfg;
            TCHAR szTemp[256];
			wsprintf(szTemp, _T("\\StringFileInfo\\%04X%04X\\%s"), wLang, wCodePage, szVar);

			if( VerQueryValue(pInfo, szTemp, (void **)(&pMfg), &len))
            {
                strValue = pMfg;
				fRet = true;
			}
	    }
    }
    catch(...)
    {
        // We don't need to do anything else, just need to protect ourselves
        // from the flaky version.dll calls.
    }

	return fRet;
}



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:		BOOL GetVersionLanguage(void *vpInfo,
									WORD *wpLang,
									WORD *wpCodePage);
 Description:	This function extracts the language and codepage out of a passed GetFileVersionInfo()
				result. Consideration is given to variation in the layout.
 Arguments:		vpInfo, wpLang, wpCodePage
 Returns:		Boolean
 Inputs:
 Outputs:
 Caveats:
 Courtesy of:	SMS, Nick Dyer
 Raid:
 History:		a-peterc  30-Oct-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
BOOL WINAPI GetVersionLanguage(void *vpInfo, WORD *wpLang, WORD *wpCodePage)
{
  WORD *wpTemp;
  WORD wLength;
  WCHAR *wcpTemp;
  char *cpTemp;
  BOOL bRet = FALSE;

  wpTemp = (WORD *) vpInfo;
  cpTemp = (char *) vpInfo;

  wpTemp++; // jump past buffer length.
  wLength = *wpTemp;  // capture value length.
  wpTemp++; // skip past value length to what should be type code in new format
  if (*wpTemp == 0 || *wpTemp == 1) // new format expect unicode strings.
  {
		cpTemp = cpTemp + 38 + wLength + 8;
		wcpTemp = (WCHAR *) cpTemp;
    if (wcscmp(L"StringFileInfo", wcpTemp) == 0) // OK! were aligned properly.
    {
			bRet = TRUE;

			cpTemp += 30; // skip over "StringFileInfo"
			while ((DWORD_PTR) cpTemp % 4 > 0) // 32 bit align
				cpTemp++;

			cpTemp += 6; // skip over length and type fields.

			wcpTemp = (WCHAR *) cpTemp;
			swscanf(wcpTemp, L"%4x%4x", wpLang, wpCodePage);
    }
  }
  else  // old format, expect single byte character strings.
  {
    cpTemp += 20 + wLength + 4;
    if (strcmp("StringFileInfo", cpTemp) == 0) // OK! were aligned properly.
    {
			bRet = TRUE;

			cpTemp += 20; // skip over length fields.
			sscanf(cpTemp, "%4x%4x", wpLang, wpCodePage);
    }
  }

	return (bRet);
}

///////////////////////////////////////////////////////////////////

bool WINAPI GetManufacturerFromFileName(LPCTSTR szFile, CHString &strMfg)
{
    LPVOID lpv = NULL;
    bool fRet = false;
    try
    {
        if(GetFileInfoBlock(szFile, &lpv) && (lpv != NULL))
        {
            fRet = GetVarFromInfoBlock(lpv, _T("CompanyName"), strMfg);
            delete lpv;
            lpv = NULL;
        }
    }
    catch(...)
    {
        if(lpv != NULL)
        {
            delete lpv;
            lpv = NULL;
        }
        throw;
    }
    return fRet;
}

bool WINAPI GetVersionFromFileName(LPCTSTR szFile, CHString &strVersion)
{
    LPVOID lpv = NULL;
    bool fRet = false;
    try
    {
        if(GetFileInfoBlock(szFile, &lpv) && (lpv != NULL))
        {
            fRet = GetVarFromInfoBlock(lpv, _T("ProductVersion"), strVersion);
            delete lpv;
            lpv = NULL;
        }
    }
    catch(...)
    {
        if(lpv != NULL)
        {
            delete lpv;
            lpv = NULL;
        }
        throw;
    }
    return fRet;
}


void WINAPI ReplaceString(CHString &str, LPCWSTR szFind, LPCWSTR szReplace)
{
    int iWhere,
        nLen = lstrlenW(szFind);

    while ((iWhere = str.Find(szFind)) != -1)
    {
        str.Format(
            L"%s%s%s",
            (LPCWSTR) str.Left(iWhere),
            szReplace,
            (LPCWSTR) str.Mid(iWhere + nLen));
    }
}

#ifdef NTONLY
BOOL WINAPI GetServiceFileName(LPCTSTR szService, CHString &strFileName)
{
    SmartCloseServiceHandle   hSCManager,
                hService;
    TCHAR       szBuffer[2048];
    QUERY_SERVICE_CONFIG
                *pConfig = (QUERY_SERVICE_CONFIG *) szBuffer;
    DWORD       dwNeeded;
    BOOL        bRet = FALSE;

    hSCManager =
        OpenSCManager(
            NULL,
            NULL,
            STANDARD_RIGHTS_REQUIRED);

    if (!hSCManager)
        return FALSE;

    hService =
        OpenService(
        hSCManager,
        szService,
        SERVICE_QUERY_CONFIG);

    if (hService)
    {
        if (QueryServiceConfig(
            hService,
            pConfig,
            sizeof(szBuffer),
            &dwNeeded))
        {
            strFileName = pConfig->lpBinaryPathName;

            // Now fix up the path so that it has a drive letter.

            strFileName.MakeUpper();

            // If the filename is using \SYSTEMROOT\, replace it with %SystemRoot%.
            if (strFileName.Find(_T("\\SYSTEMROOT\\")) == 0)
                ReplaceString(strFileName, _T("\\SYSTEMROOT\\"), _T("%SystemRoot%\\"));
            // If the filename doesn't start with a replacement string, and if it
            // doesn't have a drive letter, assume it should start with
            // %SystemRoot%.
            else if (strFileName.GetLength() >= 2 &&
                strFileName[0] != '%' && strFileName[1] != ':')
            {
                CHString strTemp;

                strTemp.Format(_T("%%SystemRoot%%\\%s"), (LPCTSTR) strFileName);
                strFileName = strTemp;
            }

            TCHAR szOut[MAX_PATH * 2];

            ExpandEnvironmentStrings(strFileName, szOut, sizeof(szOut) / sizeof(TCHAR));
            strFileName = szOut;

            bRet = TRUE;
        }
    }

    return bRet;
}
#endif

///////////////////////////////////////////////////////////////////
// Performs a case insensitive compare (such as is required for keys)
// on two variants and returns true if they are the same type and
// the same value, else false.  Note that arrays, VT_NULL, and
// embedded objects will assert, and return false.
///////////////////////////////////////////////////////////////////
bool WINAPI CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2)
{

   if (v1->vt == v2->vt)
   {
      switch (v1->vt)
      {
          case VT_BOOL: return (v1->boolVal == v2->boolVal);
          case VT_UI1:  return (v1->bVal == v2->bVal);
          case VT_I2:   return (v1->iVal == v2->iVal);
          case VT_I4:   return (v1->lVal == v2->lVal);
          case VT_R4:   return (v1->fltVal == v2->fltVal);
          case VT_R8:   return (v1->dblVal == v2->dblVal);
          case VT_BSTR: return (0 == _wcsicmp(v1->bstrVal, v2->bstrVal));
          default:
             ASSERT_BREAK(UNRECOGNIZED_VARIANT_TYPE);
      }
   }

   return false;
}

// map standard API return values (defined WinError.h)
// to WBEMish hresults (defined in WbemCli.h)
HRESULT WINAPI WinErrorToWBEMhResult(LONG error)
{
	HRESULT hr = WBEM_E_FAILED;

	switch (error)
	{
		case ERROR_SUCCESS:
			hr = WBEM_S_NO_ERROR;
			break;
		case ERROR_ACCESS_DENIED:
			hr = WBEM_E_ACCESS_DENIED;
			break;
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_OUTOFMEMORY:
			hr = WBEM_E_OUT_OF_MEMORY;
			break;
		case ERROR_ALREADY_EXISTS:
			hr = WBEM_E_ALREADY_EXISTS;
			break;
		case ERROR_BAD_NETPATH:
        case ERROR_INVALID_DATA:
        case ERROR_BAD_PATHNAME:
        case REGDB_E_INVALIDVALUE:
		case ERROR_PATH_NOT_FOUND:
		case ERROR_FILE_NOT_FOUND:
                case ERROR_INVALID_PRINTER_NAME:
		case ERROR_BAD_USERNAME:
		case NERR_NetNameNotFound:
        case ERROR_NOT_READY:
        case ERROR_INVALID_NAME:
			hr = WBEM_E_NOT_FOUND;
			break;
		default:
			hr = WBEM_E_FAILED;
	}

	return hr;
}

void WINAPI SetConfigMgrProperties(CConfigMgrDevice *pDevice, CInstance *pInstance)
{
    CHString	strDeviceID;
    DWORD		dwStatus,
        dwProblem;

    if (pDevice->GetDeviceID(strDeviceID))
        pInstance->SetCHString(IDS_PNPDeviceID, strDeviceID);

    if (pDevice->GetStatus(&dwStatus, &dwProblem))
        pInstance->SetDWORD(IDS_ConfigManagerErrorCode, dwProblem);

    pInstance->SetDWORD(IDS_ConfigManagerUserConfig,
        pDevice->IsUsingForcedConfig());
}

#ifdef NTONLY
BOOL WINAPI EnablePrivilegeOnCurrentThread(LPCTSTR szPriv)
{
    BOOL                bRet = FALSE;
    HANDLE              hToken = NULL;
    TOKEN_PRIVILEGES    tkp;
    BOOL                bLookup = FALSE;
    DWORD               dwLastError = ERROR_SUCCESS;

    // Try to open the thread token. 
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES |
        TOKEN_QUERY, FALSE, &hToken))
    {

        {
            CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
            bLookup = LookupPrivilegeValue(NULL, szPriv, &tkp.Privileges[0].Luid);
        }
        if (bLookup)
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Clear the last error.
            SetLastError(0);

            // Turn it on
            bRet = AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
                        (PTOKEN_PRIVILEGES) NULL, 0);
            dwLastError = GetLastError();
        }

        CloseHandle(hToken);
    }
	else
	{
		dwLastError = ::GetLastError();
	}

    // We have to check GetLastError() because AdjustTokenPrivileges lies about
    // its success but GetLastError() doesn't.
    return bRet && dwLastError == ERROR_SUCCESS;
}
#endif

// Takes a pnp id and returns a bios unit number
// To avoid frequent load/unload of a library, the pGetWin9XBiosUnit parameter comes from:
//                     HINSTANCE hInst =  LoadLibrary("cim32net.dll");
//                     pGetWin9XBiosUnit = (fnGetWin9XBiosUnit)GetProcAddress(hInst, "GetWin9XBiosUnit");
#ifdef WIN9XONLY
BYTE WINAPI GetBiosUnitNumberFromPNPID(CHString strDeviceID)
{
    CHString sTemp;
    DRIVE_MAP_INFO stDMI;
    CRegistry Reg1;

    BYTE btBiosUnit = -1;

    // Open the associated registry key
    if (Reg1.Open(HKEY_LOCAL_MACHINE, _T("enum\\") + strDeviceID, KEY_QUERY_VALUE) == ERROR_SUCCESS)
    {

        // Get a drive letter for this pnp id
        if ((Reg1.GetCurrentKeyValue(L"CurrentDriveLetterAssignment", sTemp) != ERROR_SUCCESS) ||
            (sTemp.GetLength() == 0)) {
            // No drive letters, let's try one more thing.  On memphis sp1, this call will also
            // get us a unit number.
            CCim32NetApi* t_pCim32Net = HoldSingleCim32NetPtr::GetCim32NetApiPtr();
            if (t_pCim32Net != NULL)
            {
#ifndef UNICODE // This function only takes a LPSTR, and only works on 9x anyway.
                btBiosUnit = t_pCim32Net->GetWin9XBiosUnit(TOBSTRT(strDeviceID));
                CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidCim32NetApi, t_pCim32Net);
                t_pCim32Net = NULL;
#endif
            }
        }
        else
        {
            if (GetDriveMapInfo(&stDMI, toupper(sTemp[0]) - 'A' + 1))
            {
                btBiosUnit = stDMI.btInt13Unit;
            }
        }
    }

    return btBiosUnit;
}
#endif

HRESULT WINAPI GetHKUserNames(CHStringList &list)
{
	HRESULT hres;

	// Empty the list.
	list.clear();

#ifdef NTONLY
	{
		// Enum the profiles from the registry.
		CRegistry	regProfileList;
		CHString	strProfile;
		DWORD		dwErr;

		// Open the ProfileList key so we know which profiles to load up.
		if ((dwErr = regProfileList.OpenAndEnumerateSubKeys(
			HKEY_LOCAL_MACHINE,
			IDS_RegNTProfileList,
			KEY_READ)) == ERROR_SUCCESS)
		{
			for (int i = 0; regProfileList.GetCurrentSubKeyName(strProfile) ==
				ERROR_SUCCESS; i++)
			{
				list.push_back(strProfile);
				regProfileList.NextSubKey();
			}
		}

		// Add the .DEFAULT name.
		list.push_back(_T(".DEFAULT"));

		hres = WinErrorToWBEMhResult(dwErr);
	}
#endif
#ifdef WIN9XONLY
	{
		DWORD	dwErr = ERROR_SUCCESS;
#ifdef _DEBUG
		DWORD	dwSize = 10,
#else
		DWORD	dwSize = 1024,
#endif
				dwBytesRead;
		TCHAR	*szBuff = NULL;

		// Keep looping until we read the entire section.
		// You know your buffer wasn't big enough if the returned number
		// of bytes == (size passed in - 2).
		do
		{
			if (szBuff)
			{
				delete [] szBuff;

				dwSize *= 2;
			}

			szBuff = new TCHAR [dwSize];

			// Out of memory.  Get out of loop.
			if (!szBuff)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            try
            {
			    dwBytesRead =
				    GetPrivateProfileString(
					    _T("Password Lists"),
					    NULL,
					    _T(""),
					    szBuff,
					    dwSize / sizeof(TCHAR),
					    _T("system.ini"));
            }
            catch ( ... )
            {
                delete [] szBuff;
                throw;
            }

		} while (dwBytesRead >= dwSize - 2);

		if (szBuff)
		{
            try
            {
			    // Loop through the list of names.  Each is null-terminated, and the
			    // list is terminated with a double null.
			    TCHAR *pszCurrent = szBuff;

			    while (*pszCurrent)
			    {
				    list.push_back(pszCurrent);

				    pszCurrent += lstrlen(pszCurrent) + 1;
			    }

			    hres = WBEM_S_NO_ERROR;
            }
            catch ( ... )
            {
                delete [] szBuff;
                throw;
            }

			// Free the buffer.
			delete [] szBuff;

			// Add the .DEFAULT name.
			list.push_back(_T(".DEFAULT"));
		}
		else
			// Failed to malloc, so set error code.
			hres = WBEM_E_OUT_OF_MEMORY;
	}
#endif

	return hres;
}


VOID WINAPI EscapeBackslashes(CHString& chstrIn,
                     CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\\'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext + 1);
        // Add on the second backslash:
        chstrOut += _T('\\');
        // Hack off from the input string the portion we just copied
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\\'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}

VOID WINAPI EscapeQuotes(CHString& chstrIn,
                  CHString& chstrOut)
{
    CHString chstrCpyNormPathname = chstrIn;
    LONG lNext = -1L;
    chstrOut.Empty();

    // Find the next '\'
    lNext = chstrCpyNormPathname.Find(_T('\"'));
    while(lNext != -1)
    {
        // Add on to the new string we are building:
        chstrOut += chstrCpyNormPathname.Left(lNext);
        // Escape the quote:
        chstrOut += _T("\\\"");
        // Hack off from the input string the portion we just copied
        chstrCpyNormPathname = chstrCpyNormPathname.Right(chstrCpyNormPathname.GetLength() - lNext - 1);
        lNext = chstrCpyNormPathname.Find(_T('\"'));
    }
    // If the last character wasn't a '\', there may still be leftovers, so
    // copy them here.
    if(chstrCpyNormPathname.GetLength() != 0)
    {
        chstrOut += chstrCpyNormPathname;
    }
}

VOID WINAPI RemoveDoubleBackslashes(const CHString& chstrIn, CHString& chstrOut)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(L"\\\\");
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    chstrOut = chstrBuildString;
}

CHString WINAPI RemoveDoubleBackslashes(const CHString& chstrIn)
{
    CHString chstrBuildString;
    CHString chstrInCopy = chstrIn;
    BOOL fDone = FALSE;
    LONG lPos = -1;
    while(!fDone)
    {
        lPos = chstrInCopy.Find(L"\\\\");
        if(lPos != -1)
        {
            chstrBuildString += chstrInCopy.Left(lPos);
            chstrBuildString += _T("\\");
            chstrInCopy = chstrInCopy.Mid(lPos+2);
        }
        else
        {
            chstrBuildString += chstrInCopy;
            fDone = TRUE;
        }
    }
    return chstrBuildString;
}

#ifdef NTONLY
// helper for StrToSID
// takes a string, converts to a SID_IDENTIFIER_AUTHORITY
// returns false if not a valid SID_IDENTIFIER_AUTHORITY
// contents of identifierAuthority are unrelieable on failure
bool WINAPI StrToIdentifierAuthority(const CHString& str, SID_IDENTIFIER_AUTHORITY& identifierAuthority)
{
    bool bRet = false;
    memset(&identifierAuthority, '\0', sizeof(SID_IDENTIFIER_AUTHORITY));

    DWORD duhWord;
    WCHAR* p = NULL;
    CHString localStr(str);

    // per KB article Q13132, if identifier authority is greater than 2**32, it's in hex
    if ((localStr[0] == '0') && ((localStr[1] == 'x') || (localStr[1] == 'X')))
    // if it looks hexidecimalish...
    {
        // going to parse this out backwards, chpping two chars off the end at a time
        // first, whack off the 0x
        localStr = localStr.Mid(2);

        CHString token;
        int nValue =5;

        bRet = true;
        while (bRet && localStr.GetLength() && (nValue > 0))
        {
            token = localStr.Right(2);
            localStr = localStr.Left(localStr.GetLength() -2);
            duhWord = wcstoul(token, &p, 16);

            // if strtoul succeeds, the pointer is moved
            if (p != (LPCTSTR)token)
                identifierAuthority.Value[nValue--] = (BYTE)duhWord;
            else
                bRet = false;
        }
    }
    else
    // it looks decimalish
    {
        duhWord = wcstoul(localStr, &p, 10);

        if (p != (LPCTSTR)localStr)
        // conversion succeeded
        {
            bRet = true;
            identifierAuthority.Value[5] = LOBYTE(LOWORD(duhWord));
            identifierAuthority.Value[4] = HIBYTE(LOWORD(duhWord));
            identifierAuthority.Value[3] = LOBYTE(HIWORD(duhWord));
            identifierAuthority.Value[2] = HIBYTE(HIWORD(duhWord));
        }
    }

    return bRet;
}

// for input of the form AAA-BBB-CCC
// will return AAA in token
// and BBB-CCC in str
bool WINAPI WhackToken(CHString& str, CHString& token)
{
	bool bRet = false;
	if (bRet = !str.IsEmpty())
	{
		int index;
		index = str.Find('-');

		if (index == -1)
		{
			// all that's left is the token, we're done
			token = str;
			str.Empty();
		}
		else
		{
			token = str.Left(index);
			str = str.Mid(index+1);
		}
	}
	return bRet;
}

// a string representation of a SID is assumed to be:
// S-#-####-####-####-####-####-####
// we will enforce only the S ourselves,
// The version is not checked
// everything else will be handed off to the OS
// caller must free the SID returned
PSID WINAPI StrToSID(const CHString& sid)
{
	PSID pSid = NULL;
	if (!sid.IsEmpty() && ((sid[0] == 'S')||(sid[0] == 's')) && (sid[1] == '-'))
	{
		// get a local copy we can play with
		// we'll parse this puppy the easy way
		// by slicing off each token as we find it
		// slow but sure
		// start by slicing off the "S-"
		CHString str(sid.Mid(2));
		CHString token;

		SID_IDENTIFIER_AUTHORITY identifierAuthority = {0,0,0,0,0,0};
		BYTE nSubAuthorityCount =0;  // count of subauthorities
		DWORD dwSubAuthority[8]   = {0,0,0,0,0,0,0,0};    // subauthorities

		// skip version
		WhackToken(str, token);
		// Grab Authority
		if (WhackToken(str, token))
		{
            DWORD duhWord;
			WCHAR* p = NULL;
			bool bDoIt = false;

			if (StrToIdentifierAuthority(token, identifierAuthority))
			// conversion succeeded
			{
				bDoIt = true;

				// now fill up the subauthorities
				while (bDoIt && WhackToken(str, token))
				{
					p = NULL;
					duhWord = wcstoul(token, &p, 10);

					if (p != (LPCTSTR)token)
					{
						dwSubAuthority[nSubAuthorityCount] = duhWord;
						bDoIt = (++nSubAuthorityCount <= 8);
					}
					else
						bDoIt = false;
				} // end while WhackToken

				if(bDoIt)
                {
					AllocateAndInitializeSid(&identifierAuthority,
					   						  nSubAuthorityCount,
											  dwSubAuthority[0],
											  dwSubAuthority[1],
											  dwSubAuthority[2],
											  dwSubAuthority[3],
											  dwSubAuthority[4],
											  dwSubAuthority[5],
											  dwSubAuthority[6],
											  dwSubAuthority[7],
											  &pSid);
                }
			}
		}
	}
	return pSid;
}
#endif // NTONLY defined


CHString WINAPI GetDateTimeViaFilenameFiletime(LPCTSTR szFilename, FILETIME *pFileTime)
{
    CHString strDate,
             strRootPath;

    // UNC path?
    if (szFilename[0] == '\\' && szFilename[1] == '\\')
    {
        LPTSTR szSlash = _tcschr(&szFilename[2], '\\');

        // If szSlash, we're sitting on 3rd slash of \\server\share\myfile
        if (szSlash)
        {
            szSlash = _tcschr(szSlash + 1, '\\');

            // If no 4th slash, there's no filename.
            if (szSlash)
            {
                strRootPath = szFilename;
                strRootPath =
                    strRootPath.Left(szSlash - szFilename + 1);
            }
        }
    }
    // Drive path?
    else if (szFilename[1] == ':')
    {
        strRootPath = szFilename;
        strRootPath = strRootPath.Left(3);
    }

    if (!strRootPath.IsEmpty())
    {
        TCHAR szBuffer[MAX_PATH];
        BOOL  bNTFS = FALSE;

        if (GetVolumeInformation(
                TOBSTRT(strRootPath),
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                szBuffer,
                sizeof(szBuffer) / sizeof(TCHAR)) &&
            !lstrcmpi(szBuffer, _T("NTFS")))
        {
            bNTFS = TRUE;
        }

        strDate = GetDateTimeViaFilenameFiletime(bNTFS, pFileTime);
    }

    return strDate;
}

CHString WINAPI GetDateTimeViaFilenameFiletime(LPCTSTR szFilename, FT_ENUM ftWhich)
{
    WIN32_FIND_DATA finddata;
    SmartFindClose  hFind = FindFirstFile(szFilename, &finddata);
    CHString        strDate;

    if (hFind != INVALID_HANDLE_VALUE)
    {
        FILETIME *pFileTime = NULL;

        switch(ftWhich)
        {
            case FT_CREATION_DATE:
                pFileTime = &finddata.ftCreationTime;
                break;

            case FT_ACCESSED_DATE:
                pFileTime = &finddata.ftLastAccessTime;
                break;

            case FT_MODIFIED_DATE:
                pFileTime = &finddata.ftLastWriteTime;
                break;

            default:
                // Caller must send in a proper enum value.
                ASSERT_BREAK(FALSE);
                break;
        }

        if (pFileTime)
            strDate = GetDateTimeViaFilenameFiletime(szFilename, pFileTime);
    }

    return strDate;
}

CHString WINAPI GetDateTimeViaFilenameFiletime(BOOL bNTFS, FILETIME *pFileTime)
{
    WBEMTime wbemTime(*pFileTime);
             // This is just used as a wrapper.  It avoids a try/catch block.
    bstr_t   bstrDate(bNTFS ? wbemTime.GetDMTF() : wbemTime.GetDMTFNonNtfs(), false);
    CHString strRet = (LPWSTR) bstrDate;

    return strRet;
}

// Used to validate a numbered device ID is OK.
// Example: ValidateNumberedDeviceID("VideoController7", "VideoController", pdwWhich)
//          returns TRUE, pdwWhich = 7.
// Example: ValidateNumberedDeviceID("BadDeviceID", "VideoController", pdwWhich)
//          returns FALSE, pdwWhich unchanged
BOOL WINAPI ValidateNumberedDeviceID(LPCWSTR szDeviceID, LPCWSTR szTag, DWORD *pdwWhich)
{
    BOOL bRet = FALSE;
    int  nTagLen = wcslen(szTag);

    if (wcslen(szDeviceID) > nTagLen)
    {
        CHString strDeviceID;
        DWORD    dwWhich = _wtoi(&szDeviceID[nTagLen]);

        strDeviceID.Format(L"%s%d", szTag, dwWhich);

        if (!_wcsicmp(szDeviceID, strDeviceID))
        {
            bRet = TRUE;
            *pdwWhich = dwWhich;
        }
    }

    return bRet;
}

// Critical sections used by various
CCritSec g_csPrinter;
CCritSec g_csSystemName;
#ifdef WIN9XONLY
CCritSec g_csVXD;
#endif

#define STR_BLK_SIZE 256
#define CHAR_FUDGE 1    // one WCHAR unused is good enough
BOOL LoadStringW(CHString &sString, UINT nID)
{
    // try fixed buffer first (to avoid wasting space in the heap)
    WCHAR szTemp[ STR_BLK_SIZE ];

    int nLen = LoadStringW(nID, szTemp, STR_BLK_SIZE);
    
    if (STR_BLK_SIZE - nLen > CHAR_FUDGE)
    {
        sString = szTemp;
    }
    else
    {
        // try buffer size of 512, then larger size until entire string is retrieved
        int nSize = STR_BLK_SIZE;

        do
        {
            nSize += STR_BLK_SIZE;
            nLen = LoadStringW(nID, sString.GetBuffer(nSize-1), nSize);

        } 
        while (nSize - nLen <= CHAR_FUDGE);

        sString.ReleaseBuffer();
    }

    return nLen > 0;
}

void Format(CHString &sString, UINT nFormatID, ...)
{
    va_list argList;
    va_start(argList, nFormatID);

    CHString strFormat;
    
    LoadStringW(strFormat, nFormatID);

    sString.FormatV(strFormat, argList);
    va_end(argList);
}

void FormatMessageW(CHString &sString, UINT nFormatID, ...)
{
    // get format string from string table
    CHString strFormat;
    
    LoadStringW(strFormat, nFormatID);

    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, nFormatID);

#ifdef NTONLY
    LPWSTR lpszTemp;

    if (::FormatMessageW(
        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        (LPCWSTR) strFormat, 
        0, 
        0, 
        (LPWSTR) &lpszTemp, 
        0, 
        &argList) == 0 || lpszTemp == NULL)
    {
        // Should throw memory exception here.  Now we do.
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
    else
    {
        // assign lpszTemp into the resulting string and free lpszTemp
        sString = lpszTemp;
        LocalFree(lpszTemp);
        va_end(argList);
    }
#else
    #error Not written for win9x
#endif
}

int LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf)
{
    int nLen = 0;

#ifdef NTONLY
    nLen = ::LoadStringW(ghModule, nID, lpszBuf, nMaxBuf);
    if (nLen == 0)
    {
        lpszBuf[0] = '\0';
    }
#else
    #error Not written for win9x
#endif

    return nLen; // excluding terminator
}

bool WINAPI DelayLoadDllExceptionFilter(PEXCEPTION_POINTERS pep) 
{
    // We might have thrown as a result of the
    // delay load library mechanism.  There are
    // two types of such exceptions - those
    // generated because the dll could not be
    // loaded, and thos generated because the
    // proc address of the function referred to
    // could not be found.  We want to log an
    // error message in either case.
    bool fRet = false;
    if(pep &&
        pep->ExceptionRecord)
    {
        // If this is a Delay-load problem, ExceptionInformation[0] points 
        // to a DelayLoadInfo structure that has detailed error info
        PDelayLoadInfo pdli = PDelayLoadInfo(
            pep->ExceptionRecord->ExceptionInformation[0]);
        
        if(pdli)
        {
            switch(pep->ExceptionRecord->ExceptionCode) 
            {
                case VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND):
                {
                    // The DLL module was not found at runtime
                    LogErrorMessage2(L"Dll not found: %s", pdli->szDll);
                    fRet = true; 
                    break;
                }
                case VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND):
                {
                    // The DLL module was found but it doesn't contain the function
                    if(pdli->dlp.fImportByName) 
                    {
                        LogErrorMessage3(
                            L"Function %s was not found in %s",
                            pdli->dlp.szProcName, 
                            pdli->szDll);
                    } 
                    else 
                    {
                        LogErrorMessage3(
                            L"Function ordinal %d was not found in %s",
                            pdli->dlp.dwOrdinal, 
                            pdli->szDll);
                    }
                    fRet = true;
                    break; 
                }
            }
        }
    }
    return fRet;
}


// This is here in common because
// at least the classes Pagefile and
// PageFileSetting use it, perhaps
// more in the future.
#ifdef NTONLY
HRESULT CreatePageFile(
    LPCWSTR wstrPageFileName,
    const LARGE_INTEGER liInitial,
    const LARGE_INTEGER liMaximum,
    const CInstance& Instance)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    UNICODE_STRING ustrFileName = { 0 };
    NTSTATUS status = STATUS_SUCCESS;
    
    if(!EnablePrivilegeOnCurrentThread(SE_CREATE_PAGEFILE_NAME))
    {
        SetSinglePrivilegeStatusObject(
            Instance.GetMethodContext(), 
            SE_CREATE_PAGEFILE_NAME);
        hr = WBEM_E_ACCESS_DENIED;
    }

    
    if(SUCCEEDED(hr))
    {
        if(!::RtlDosPathNameToNtPathName_U(
            wstrPageFileName, 
            &ustrFileName, 
            NULL, 
            NULL) && ustrFileName.Buffer) 
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    
    try
    {
        if(SUCCEEDED(hr))
        {
            LARGE_INTEGER liInit;
            LARGE_INTEGER liMax;
        
            liInit.QuadPart = liInitial.QuadPart * 1024 * 1024;
            liMax.QuadPart = liMaximum.QuadPart * 1024 * 1024;

            if(!NT_SUCCESS(
                status = ::NtCreatePagingFile(
                    &ustrFileName,
                    &liInit,
                    &liMax,
                    0)))
            {
                hr = WinErrorToWBEMhResult(status);
            }
        }

    
        RtlFreeUnicodeString(&ustrFileName);
        ustrFileName.Buffer = NULL;
     
    }
    catch(...)
    {
        RtlFreeUnicodeString(&ustrFileName);
        ustrFileName.Buffer = NULL;
        throw;
    }

    return hr;
}
#endif


// Useful for obtaining the localized versions
// of "All Users" and "Default User".
#if NTONLY >= 5
bool GetAllUsersName(CHString& chstrAllUsersName)
{
    bool fRet = false;
    CRegistry reg;
    CHString chstrTemp;

    DWORD dwRet = reg.Open(
		HKEY_LOCAL_MACHINE,
		L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
		KEY_READ);

    if(dwRet == ERROR_SUCCESS)
    {
        if(reg.GetCurrentKeyValue(
            L"AllUsersProfile", 
            chstrTemp) == ERROR_SUCCESS)
        {
            chstrAllUsersName = chstrTemp.SpanExcluding(L".");
            fRet = true;
        }
    }
    if(!fRet)
    {
        chstrAllUsersName = L"";
    }

    return fRet;
}
#endif

#if NTONLY >= 5
bool GetDefaultUsersName(CHString& chstrDefaultUsersName)
{
    bool fRet = false;
    CRegistry reg;
    CHString chstrTemp;

    DWORD dwRet = reg.Open(
		HKEY_LOCAL_MACHINE,
		L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
		KEY_READ);

    if(dwRet == ERROR_SUCCESS)
    {
        if(reg.GetCurrentKeyValue(
            L"DefaultUserProfile", 
            chstrTemp) == ERROR_SUCCESS)
        {
            chstrDefaultUsersName = chstrTemp.SpanExcluding(L".");
            fRet = true;
        }
    }
    if(!fRet)
    {
        chstrDefaultUsersName = L"";
    }

    return fRet;
}
#endif


#if NTONLY >= 5
bool GetCommonStartup(CHString& chstrCommonStartup)
{
    bool fRet = false;
    CRegistry reg;
    CHString chstrTemp;

    DWORD dwRet = reg.Open(
		HKEY_LOCAL_MACHINE,
		L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
		KEY_READ);

    if(dwRet == ERROR_SUCCESS)
    {
        if(reg.GetCurrentKeyValue(
            L"Common Startup", 
            chstrTemp) == ERROR_SUCCESS)
        {
            int iPos = chstrTemp.ReverseFind(L'\\');
            if(iPos != -1)
            {
                chstrCommonStartup = chstrTemp.Mid(iPos+1);
                fRet = true;
            }
        }
    }
    if(!fRet)
    {
        chstrCommonStartup = L"";
    }

    return fRet;
}
#endif

BOOL GetLocalizedNTAuthorityString(
    CHString& chstrNT_AUTHORITY)
{
    BOOL fRet = false;
    SID_IDENTIFIER_AUTHORITY siaNTSidAuthority = SECURITY_NT_AUTHORITY;
    CSid csidAccountSid;
    
    if(GetSysAccountNameAndDomain(
        &siaNTSidAuthority, 
        csidAccountSid, 
        1, 
        SECURITY_NETWORK_SERVICE_RID))
    {
        chstrNT_AUTHORITY = csidAccountSid.GetDomainName();
        fRet = TRUE;
    }

    return fRet;
}

BOOL GetLocalizedBuiltInString(
    CHString& chstrBuiltIn)
{
    BOOL fRet = false;
    SID_IDENTIFIER_AUTHORITY siaNTSidAuthority = SECURITY_NT_AUTHORITY;
    CSid csidAccountSid;
    
    if(GetSysAccountNameAndDomain(
        &siaNTSidAuthority, 
        csidAccountSid, 
        1, 
        SECURITY_BUILTIN_DOMAIN_RID))
    {
        chstrBuiltIn = csidAccountSid.GetDomainName();
        fRet = TRUE;
    }

    return fRet;
}

BOOL GetSysAccountNameAndDomain(
    PSID_IDENTIFIER_AUTHORITY a_pAuthority,
    CSid& a_accountsid,
    BYTE  a_saCount /*=0*/,
    DWORD a_dwSubAuthority1 /*=0*/,
    DWORD a_dwSubAuthority2 /*=0*/  )
{
	BOOL t_fReturn = FALSE;
	PSID t_psid = NULL;

	if ( AllocateAndInitializeSid(	a_pAuthority,
									a_saCount,
									a_dwSubAuthority1,
									a_dwSubAuthority2,
									0,
									0,
									0,
									0,
									0,
									0,
									&t_psid ) )
	{
	    try
	    {
			CSid t_sid( t_psid ) ;

			// The SID may be valid in this case, however the Lookup may have failed
			if ( t_sid.IsValid() && t_sid.IsOK() )
			{
				a_accountsid = t_sid;
				t_fReturn = TRUE;
			}

	    }
	    catch( ... )
	    {
		    if( t_psid )
		    {
			    FreeSid( t_psid ) ;
		    }
		    throw ;
	    }

		// Cleanup the sid
		FreeSid( t_psid ) ;
	}

	return t_fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dllwrapperbase.h ===
//=================================================================

//

// DllWrapperBase.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_DLLWRAPPERBASE_H_
#define	_DLLWRAPPERBASE_H_


#include "ResourceManager.h"
#include "TimedDllResource.h"



/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

 // << section empty in base class only>>


/******************************************************************************
 * Wrapper class to load/unload, for registration with ResourceManager. 
 ******************************************************************************/
class CDllWrapperBase : public CTimedDllResource
{
private:
    // Member variables (function pointers) pointing to dll procs.
    // Add new functions here as required.
    
    BOOL GetVarFromVersionInfo(LPCTSTR a_szFile, 
                               LPCTSTR a_szVar, 
                               CHString &a_strValue);

    BOOL GetVersionLanguage(void *a_vpInfo, WORD *a_wpLang, WORD *a_wpCodePage);

    HINSTANCE m_hDll;                // handle to the dll this class wraps
    LPCTSTR m_tstrWrappedDllName;    // name of dll this class wraps

protected:
    
    // Handy wrapers to simplify calls and hide m_hDll...
    bool LoadLibrary();
    FARPROC GetProcAddress(LPCSTR a_strProcName);

public:

    // Constructor and destructor:
    CDllWrapperBase(LPCTSTR a_chstrWrappedDllName);
    ~CDllWrapperBase();

    // Initialization function to check function pointers. Requires derived
    // class implementation.
    virtual bool Init() = 0;

    // Helper for retrieving the version.
    BOOL GetDllVersion(CHString& a_chstrVersion);

        
      
    
    // Member functions wrapping dll procs.
    // Add new functions here as required:
    
    // << section empty in base class only >>
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dmadesc.cpp ===
//=================================================================

//

// DmaDesc.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "refptr.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "dmadesc.h"

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMADescriptor::CDMADescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMADescriptor::CDMADescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( pResDescHdr, pOwnerDevice )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMADescriptor::CDMADescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Resource Id with flags
//				DMA_DES					dmaDes - DMA Descriptor.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMADescriptor::CDMADescriptor(	DWORD				dwResourceId,
							    DMA_DES&				dmaDes,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( dwResourceId, &dmaDes, sizeof(DMA_DES), pOwnerDevice )
{
	ASSERT_BREAK( ResType_DMA == GetResourceType() );
}

// Copy Constructor
CDMADescriptor::CDMADescriptor( const CDMADescriptor& dma )
: CResourceDescriptor( dma )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMADescriptor::~CDMADescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMADescriptor::~CDMADescriptor( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMADescriptor::GetResource
//
//	Returns a string representation of the associated Device Memory
//	Address.
//
//	Inputs:		None.
//
//	Outputs:	CString&		str - Storage for string.
//
//	Return:		TRUE/FALSE		Function successful or not.
//
//	Comments:	Do NOT call down to the base class.
//
////////////////////////////////////////////////////////////////////////

void *CDMADescriptor::GetResource()
{

	if ( NULL != m_pbResourceDescriptor ){
		// Cast to a DMA Descriptor, and place it's channel value in the
		// string

		PDMA_DES	pDMA = (PDMA_DES) m_pbResourceDescriptor;
        return pDMA;
	}

	return NULL;
}

//
//	Constructor and Destructor for the DMA Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMACollection::CDMACollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMACollection::CDMACollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CDMACollection::~CDMACollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CDMACollection::~CDMACollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\dmadesc.h ===
//=================================================================

//

// dmadesc.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __DMADESC_H__
#define __DMADESC_H__

class 
__declspec(uuid("571D3186-D45D-11d2-B35E-00104BC97924"))
CDMADescriptor : public CResourceDescriptor
{
	
public:

	// Construction/Destruction
	CDMADescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CDMADescriptor(	DWORD dwResourceId, DMA_DES& dmaDes, CConfigMgrDevice* pOwnerDevice );
	CDMADescriptor(	const CDMADescriptor& dma );
	~CDMADescriptor();

	DWORD GetFlags( void );
	ULONG GetChannel( void );

	// Override of base class functionality
	virtual void * GetResource();
	
};

_COM_SMARTPTR_TYPEDEF(CDMADescriptor, __uuidof(CDMADescriptor));

inline DWORD CDMADescriptor::GetFlags( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PDMA_DES) m_pbResourceDescriptor)->DD_Flags : 0 );
}

inline DWORD CDMADescriptor::GetChannel( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PDMA_DES) m_pbResourceDescriptor)->DD_Alloc_Chan : 0 );
}

// A collection of DMA Descriptors
class CDMACollection : public TRefPtr<CDMADescriptor>
{
public:

	// Construction/Destruction
	CDMACollection();
	~CDMACollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CDMACollection& operator = ( const CDMACollection& srcCollection );

};

inline const CDMACollection& CDMACollection::operator = ( const CDMACollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\factoryrouter.h ===
//=================================================================

//

// FactoryRouter.h -- 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _WMI_FACTORY_ROUTER_H
#define _WMI_FACTORY_ROUTER_H

#include <cautolock.h>
//=================================================================================
//  This is the router factory
//=================================================================================
class CFactoryRouter :	public IClassFactory
{
	private:
		DWORD		m_Register;
		GUID		m_ClsId; 
		CHString	m_sDescription;

	public:

		CFactoryRouter ( REFGUID a_rClsId, LPCWSTR a_pClassName ) ;
		~CFactoryRouter () ;

		//IUnknown members
		STDMETHODIMP QueryInterface( REFIID , LPVOID FAR * ) ;
		STDMETHODIMP_( ULONG ) AddRef() ;
		STDMETHODIMP_( ULONG ) Release() ;
		
		//IClassFactory members
		STDMETHODIMP CreateInstance( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
		STDMETHODIMP LockServer( BOOL ) ;
	
		static void ClsToString( CHString &a_chsClsId, REFGUID a_rClsId ) ;

		REFGUID GetClsId();
		LPCWSTR GetClassDescription();
		DWORD	GetRegister();
		void	SetRegister( DWORD a_dwRegister );

		// pure virtuals
		virtual IUnknown * CreateInstance (	REFIID a_riid ,	LPVOID FAR *a_ppvObject	) = 0 ;
};
//=================================================================================
//  There is only one global instance of this class to manage all of the data
//  from the CFactoryRouter guys
//=================================================================================
class CFactoryRouterData
{
	private:
		typedef std::map<CHString, CFactoryRouter*> Factory_Map ;
		Factory_Map	mg_oFactoryMap ;
		CCriticalSec m_cs;
		LONG s_LocksInProgress ;
		LONG s_ObjectsInProgress ;
		long m_ReferenceCount ;

	public:
		CFactoryRouterData();
		~CFactoryRouterData();

		void AddToMap( REFGUID a_rClsId, CFactoryRouter * pFactory ) ;  
		void AddLock();
		void ReleaseLock();
		STDMETHODIMP_( ULONG ) AddRef() ;
		STDMETHODIMP_( ULONG ) Release() ;


		// dll level interfaces
		BOOL DllCanUnloadNow() ;
		HRESULT DllGetClassObject( REFCLSID rclsid, REFIID riid, PPVOID ppv ) ;
		HRESULT DllRegisterServer() ;
		HRESULT DllUnregisterServer() ;
		HRESULT InitComServer() ;
		HRESULT UninitComServer() ;
};



#endif // _WMI_FACTORY_ROUTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\fileattributes.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
// File attributes helper class.




#include <precomp.h>
#include <assertbreak.h>

class CFileAttributes
{
    public:

        CFileAttributes(
            LPCWSTR wstrFileName,
            bool fAutoRevert = true)
          :
          m_fAutoRevert(fAutoRevert),
          m_dwOldFileAttributes(static_cast<DWORD>(-1L))
        {
            m_chstrFileName = wstrFileName;
            if(m_fAutoRevert)
            {
                m_dwOldFileAttributes = ::GetFileAttributes(m_chstrFileName);
            }
        }

        CFileAttributes(const CFileAttributes& cfa)
        {
            m_chstrFileName = cfa.m_chstrFileName;
            m_fAutoRevert = cfa.m_fAutoRevert;
            m_dwOldFileAttributes = cfa.m_dwOldFileAttributes;   
        }

        virtual ~CFileAttributes() 
        {
            if(m_fAutoRevert)
            {
                if(!ResetAttributes())
                {
                    ASSERT_BREAK(0);
                    LogErrorMessage2(
                        L"Could not reset file attributes on file %s",
                        m_chstrFileName);
                }
            }
        }

        DWORD GetAttributes(DWORD* pdw)
        {
            DWORD dwRet = ERROR_SUCCESS;
            DWORD dwTemp = ::GetFileAttributes(m_chstrFileName);
            
            if(pdw)
            {
                *pdw = 0L;
                if(dwTemp != -1L)
                {
                    *pdw = dwTemp;
                }
                else
                {
                    dwRet = ::GetLastError();
                }
            }
            else
            {
                dwRet = ERROR_INVALID_PARAMETER;
            }
                   
            return dwRet;
        }

        DWORD SetAttributes(DWORD dwAttributes)
        {
            DWORD dwRet = E_FAIL;
            DWORD dwTemp = ::GetFileAttributes(m_chstrFileName);

            if(dwTemp != -1L)
            {
                m_dwOldFileAttributes = dwTemp;
                if(::SetFileAttributes(
                    m_chstrFileName,
                    dwAttributes))
                {
                    dwRet = ERROR_SUCCESS;
                }
                else
                {
                    dwRet = ::GetLastError();
                }
            }
            else
            {
                dwRet = ::GetLastError();
            }
                   
            return dwRet;
        }

        BOOL ResetAttributes()
        {
            BOOL fResult = FALSE;
            if(m_dwOldFileAttributes != static_cast<DWORD>(-1L))
            {
                fResult = ::SetFileAttributes(
                m_chstrFileName,
                m_dwOldFileAttributes);
            }
            return fResult;
        }


    private:

        CHString m_chstrFileName;
        bool m_fAutoRevert;
        DWORD m_dwOldFileAttributes;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\factoryrouter.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// FactoryRouter.cpp -- Generic Com Class factory class
//
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "dllmain.h"
#include "cautolock.h"

using namespace std;
#include "FactoryRouter.h"
#define DUPLICATE_RELEASE FALSE

extern CFactoryRouterData g_FactoryRouterData;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************************
// Utility functions
//*************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ClsToString( CHString &a_chsClsId, REFGUID a_rClsId ) 
{
	WCHAR wcID[128] ;
	StringFromGUID2( a_rClsId, wcID, 128 ) ;

	a_chsClsId = wcID ;

	a_chsClsId.MakeUpper() ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************************
//  The CFactoryRouter Class
//*************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFactoryRouter::CFactoryRouter(REFGUID	a_rClsId, LPCWSTR a_pClassName):m_Register( 0 )
{
	m_ClsId = a_rClsId ; 
	m_sDescription = a_pClassName ;
	g_FactoryRouterData.AddToMap( a_rClsId,this ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFactoryRouter::~CFactoryRouter()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CFactoryRouter::AddRef()
{	
	return g_FactoryRouterData.AddRef();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CFactoryRouter::Release()
{
	ULONG nRet = g_FactoryRouterData.Release();
	if ( nRet == 0 )
	{
		try
		{
			LogMessage(L"CFactoryRouter Ref Count = 0");
		}
		catch ( ... )
		{
		}
//	    delete this;  Can't delete this, because these hang around the whole time the dll is loaded
//      the ptr to this factory is deleted upon dll being detached		
	}
	else if (nRet > 0x80000000)
    {
        ASSERT_BREAK(DUPLICATE_RELEASE);
		LogErrorMessage(L"Duplicate CFactoryRouter Release()");
    }
	return nRet;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CFactoryRouter::QueryInterface( REFIID a_riid, PPVOID a_ppv )
{
    *a_ppv = NULL ;

    if ( IID_IUnknown == a_riid || IID_IClassFactory == a_riid )
	{
        *a_ppv = this ;
    }
    
    if ( NULL != *a_ppv )    
    {
        AddRef() ;
        return NOERROR ;
    }
    return ResultFromScode( E_NOINTERFACE ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CFactoryRouter::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CFactoryRouter::LockServer( BOOL a_fLock )
{
	if ( a_fLock )
	{
		g_FactoryRouterData.AddLock();
	}
	else
	{
		g_FactoryRouterData.ReleaseLock();
	}
	return S_OK	;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CFactoryRouter::CreateInstance
//
// Purpose: Instantiates a Event Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CFactoryRouter::CreateInstance (LPUNKNOWN a_pUnkOuter ,REFIID a_riid ,LPVOID FAR *a_ppvObject)
{
	HRESULT t_status = S_OK ;
	if ( a_pUnkOuter )
	{
		t_status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		// resolve request to whomever derived from us
		IUnknown *t_lpunk = (IUnknown *) CreateInstance( a_riid, a_ppvObject ) ; 
	
		if ( t_lpunk == NULL )
		{
			t_status = E_OUTOFMEMORY ;
		}
		else
		{
			// declare interface support
			t_status = t_lpunk->QueryInterface ( a_riid , a_ppvObject ) ;
			if ( FAILED ( t_status ) )
			{
				delete t_lpunk ;
			}
		}			
	}
	return t_status ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
REFGUID CFactoryRouter::GetClsId()
{
    return m_ClsId;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
LPCWSTR CFactoryRouter::GetClassDescription() 
{ 
    return (LPCWSTR)m_sDescription; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD CFactoryRouter::GetRegister() 
{ 
    return m_Register; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFactoryRouter::SetRegister( DWORD a_dwRegister )  
{ 
    m_Register = a_dwRegister; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************************
//
//*************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFactoryRouterData::CFactoryRouterData()
{
	s_LocksInProgress = s_ObjectsInProgress = m_ReferenceCount = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFactoryRouterData::~CFactoryRouterData()
{
	CAutoLock cal( m_cs);
LogMessage(L"************ Clearing the FactoryRouterMap");

		mg_oFactoryMap.clear() ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFactoryRouterData::AddToMap( REFGUID a_rClsId, CFactoryRouter * pFactory ) 
{
	CHString t_chsClsId ;
	ClsToString( t_chsClsId, a_rClsId ) ;
	CAutoLock cal( m_cs);

LogMessage2(L"************ Adding to map %s", (WCHAR*)(const WCHAR*) t_chsClsId);
		// map class and instance 
		mg_oFactoryMap[ t_chsClsId ] = pFactory ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*void CFactoryRouterData::RemoveFromMap( REFGUID a_rClsId ) 
{
	CHString t_chsClsId ;
	ClsToString( t_chsClsId, a_rClsId ) ;
	CAutoLock cal( m_cs);
		mg_oFactoryMap.erase( t_chsClsId ) ;
}*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CFactoryRouterData::DllCanUnloadNow()
{
	return !(s_ObjectsInProgress || s_LocksInProgress) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFactoryRouterData::AddLock()
{
	InterlockedIncrement ( &s_LocksInProgress ) ;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFactoryRouterData::ReleaseLock()
{
	InterlockedDecrement ( &s_LocksInProgress ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CFactoryRouterData::AddRef()
{	
	InterlockedIncrement ( &s_ObjectsInProgress ) ;
	return InterlockedIncrement ( &m_ReferenceCount ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CFactoryRouterData::Release()
{
	InterlockedDecrement ( &s_ObjectsInProgress ) ;
	return InterlockedDecrement( &m_ReferenceCount ) ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::DllGetClassObject( REFCLSID a_rclsid, REFIID a_riid, PPVOID a_ppv )
{	
	HRESULT t_hResult = E_FAIL ;
	CHString t_chsClsId ;
    Factory_Map::iterator	t_FactoryIter;
	
	ClsToString( t_chsClsId, a_rclsid ) ;
	CAutoLock cal(m_cs);

LogMessage2(L"************ Looking for %s in DllGetClassObject", (WCHAR*)(const WCHAR*) t_chsClsId);

		t_FactoryIter = mg_oFactoryMap.find( t_chsClsId ) ;
		if( t_FactoryIter != mg_oFactoryMap.end() )
		{
			t_hResult = t_FactoryIter->second->QueryInterface( a_riid, a_ppv ) ;
		}
LogMessage2(L"************ DllGetClassObject QueryInterface returned %x",t_hResult);

	return t_hResult ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::DllRegisterServer() 
{
	HRESULT t_hResult = NOERROR;
	CAutoLock cal(m_cs);

		Factory_Map::iterator	t_FactoryIter ;
		t_FactoryIter = mg_oFactoryMap.begin() ;

		while( t_FactoryIter != mg_oFactoryMap.end() )
		{
			bstr_t t_bstrPreface( "WMI instrumentation: " ) ;
			bstr_t t_bstrClassDescription( t_FactoryIter->second->GetClassDescription() ) ;

			t_bstrPreface += t_bstrClassDescription ; 
			t_hResult = ::RegisterServer( t_bstrPreface, t_FactoryIter->second->GetClsId() ) ;
			
			if( NOERROR != t_hResult )
			{
				break ;
			}

			++t_FactoryIter ;
		}
	return t_hResult ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::DllUnregisterServer() 
{
	HRESULT t_hResult = NOERROR ;
	CAutoLock cal(m_cs);

		Factory_Map::iterator	t_FactoryIter ;

		t_FactoryIter = mg_oFactoryMap.begin() ;

		while( t_FactoryIter != mg_oFactoryMap.end() )
		{
			t_hResult = ::UnregisterServer( t_FactoryIter->second->GetClsId() ) ;
			
			if( NOERROR != t_hResult )
			{
				break ;
			}

			++t_FactoryIter ;
		}
	return t_hResult ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::InitComServer()
{
	HRESULT t_hResult = S_OK ;
	CAutoLock cal(m_cs);

		Factory_Map::iterator	t_FactoryIter ;

		t_FactoryIter = mg_oFactoryMap.begin() ;

		while( t_FactoryIter != mg_oFactoryMap.end() )
		{
			DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
			DWORD t_Flags = REGCLS_MULTIPLEUSE ;
			DWORD t_dwRegister = 0 ;

			t_hResult = CoRegisterClassObject(t_FactoryIter->second->GetClsId(),t_FactoryIter->second,t_ClassContext,t_Flags,&t_dwRegister);
			if( NOERROR != t_hResult )
			{
				break ;
			}
			
			t_FactoryIter->second->SetRegister( t_dwRegister ) ;
			++t_FactoryIter ;
		}
	return t_hResult ;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFactoryRouterData::UninitComServer()
{
	HRESULT t_hResult = S_OK ;
	CAutoLock cal( m_cs);

		Factory_Map::iterator	t_FactoryIter ;
		t_FactoryIter = mg_oFactoryMap.begin() ;

		while( t_FactoryIter != mg_oFactoryMap.end() )
		{
			DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
			DWORD t_Flags = REGCLS_MULTIPLEUSE ;
			DWORD t_dwRegister = t_FactoryIter->second->GetRegister() ;
			
			if( t_dwRegister )
			{ 
				t_hResult = CoRevokeClassObject ( t_dwRegister ) ;
				t_FactoryIter->second->SetRegister( 0 ) ;
			}
		
			if( NOERROR != t_hResult )
			{
				break ;
			}

			++t_FactoryIter ;
		}

	return t_hResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\impersonateconnecteduser.h ===
//=================================================================

//

// ImpersonateConnectedUser.h -- Class to perform impersonation of 

//								 a connected user.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    05/21/99    a-peterc        Created
//
//=================================================================

#ifndef __IMPCONNECTEDUSER_H__
#define __IMPCONNECTEDUSER_H__

#ifdef NTONLY
#include "wbempsapi.h"
using namespace std;

// Memory allocation definitions
#define	PROCESSID_ARRAY_BLOCKSIZE	1024

class CProcessID
{
public:
	
	DWORD	dwProcessId ;
	__int64	luid ; 
};

class CImpersonateConnectedUser
{

private:

	BOOL			m_fImpersonatingUser ;
	BOOL			m_fRecacheHive;
	HANDLE			m_hThreadToken ,
					m_hProcessToken ;
	
	typedef std::multimap<__int64, DWORD> Process_Map ;
	Process_Map				m_oProcessMap ;
	Process_Map::iterator	m_ProcessIter ;	


	void	ResetImpersonation() ;
	void	RecacheHive() ;
	void	FlushCachedHive() ;
	__int64	GetLogonID( HANDLE a_hToken ) ;
	HANDLE	GetProcessToken( DWORD a_dwProcessID ) ;

	// Memory Allocation Helpers
	BOOL	ReallocProcessIdArray( PDWORD &a_pdwProcessIds, DWORD &a_dwArraySize ) ;

protected:

public:

	CImpersonateConnectedUser(  BOOL t_fRecacheHive = TRUE ) ;
	~CImpersonateConnectedUser() ;

	// User Interface
	BOOL	Begin() ;
	BOOL	End() ;
	
	// custom impersonation routines
	BOOL	FindProcessesBy( __int64 a_luid ) ;
	void	BeginProcessEnum() ;
	BOOL	GetNextProcess( CProcessID &a_oProcess ) ;
	BOOL	ImpersonateLogonOfProcess( DWORD &a_dwProcessID ) ;
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\eventprovider.cpp ===
//=================================================================

//

// EventProvider.cpp -- Generic class for eventing

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "FactoryRouter.h"
#include "EventProvider.h"
extern CFactoryRouterData g_FactoryRouterData;
//=================================================================
//
// CEventProvider
//
// abstract base for providing eventing services 
//
//
//=================================================================
//
CEventProvider::CEventProvider() :

m_ReferenceCount( 0 )
{
	InitializeCriticalSection( &m_cs ) ;
	g_FactoryRouterData.AddLock();
}

//
CEventProvider::~CEventProvider()
{
	DeleteCriticalSection( &m_cs ) ;

    // m_pHandler is a smartptr and will self destruct
    // m_pClass is a smartptr and will self destruct
	g_FactoryRouterData.ReleaseLock();
}

//
STDMETHODIMP_( ULONG ) CEventProvider::AddRef()
{
LogMessage2(L"*************CEventProvider AddRef: %ld",m_ReferenceCount+1 );
	return InterlockedIncrement( &m_ReferenceCount ) ;
}

//
STDMETHODIMP_(ULONG) CEventProvider::Release()
{
LogMessage2(L"*************CEventProvider AddRef: %ld",m_ReferenceCount-1 );
	LONG t_ref = InterlockedDecrement( &m_ReferenceCount );

	try
    {
        if (IsVerboseLoggingEnabled())
        {
            LogMessage2(L"CEventProvider::Release, count is (approx) %d", m_ReferenceCount);
        }
    }
    catch ( ... )
    {
    }

	if ( t_ref == 0 )
	{

	   try
       {
			LogMessage(L"CFactoryRouter Ref Count = 0");
       }
       catch ( ... )
       {
	   }
       OnFinalRelease();
	}
	else if (t_ref > 0x80000000)
    {
        ASSERT_BREAK(DUPLICATE_RELEASE);
		LogErrorMessage(L"Duplicate CFactoryRouter Release()");
    }

	return t_ref ;
}

//
STDMETHODIMP CEventProvider::QueryInterface( 
											 
REFIID a_riid,
LPVOID FAR *a_ppvObj
)
{
    if( IsEqualIID( a_riid, IID_IUnknown ) )
    {
        *a_ppvObj = static_cast<IWbemProviderInit *>(this) ;
    }
	else if( IsEqualIID( a_riid, IID_IWbemProviderInit ) )
    {
        *a_ppvObj = static_cast<IWbemProviderInit *>(this) ;
    }
	else if( IsEqualIID( a_riid, IID_IWbemEventProvider ) )
    {
        *a_ppvObj = static_cast<IWbemEventProvider *>(this) ;
    }	
    else
    {
		*a_ppvObj = NULL ;        

        return E_NOINTERFACE ;
    }

	AddRef() ;
	return NOERROR ;
}

//
STDMETHODIMP CEventProvider::Initialize(

LPWSTR					a_wszUser,
long					a_lFlags, 
LPWSTR					a_wszNamespace,
LPWSTR					a_wszLocale, 
IWbemServices			*a_pNamespace, 
IWbemContext			*a_pCtx,
IWbemProviderInitSink	*a_pSink 
)
{
	
    IWbemClassObjectPtr t_pClass ;

    bstr_t bstrClassName(GetClassName(), false);

    HRESULT t_hRes = a_pNamespace->GetObject(	bstrClassName,
												0,
												a_pCtx, 
												&t_pClass,
												NULL ) ;
	
	// ptr initialization routines
	SetClass( t_pClass ) ;

	return a_pSink->SetStatus( t_hRes, 0 ) ;
    
}

//
STDMETHODIMP CEventProvider::ProvideEvents(

IWbemObjectSink __RPC_FAR *a_pSink,
long a_lFlags 
)
{
  	SetHandler( a_pSink ) ;

	// notify instance
	ProvideEvents() ;

	return S_OK ;
}

//
void CEventProvider::SetClass(

IWbemClassObject __RPC_FAR *a_pClass
) 
{ 
    EnterCriticalSection( &m_cs ) ;

    try
	{
		m_pClass = a_pClass ; 
	}
	catch( ... )
	{
		LeaveCriticalSection( &m_cs ) ;
		throw ;
	}

    LeaveCriticalSection( &m_cs ) ;
}

//
IWbemClassObject __RPC_FAR * CEventProvider::GetClass()
{
	IWbemClassObject __RPC_FAR *t_pClass ;

	EnterCriticalSection( &m_cs ) ;

    m_pClass->AddRef() ;

	t_pClass = m_pClass ;

	LeaveCriticalSection( &m_cs ) ;

	return t_pClass ;
}

//
void CEventProvider::SetHandler(

IWbemObjectSink __RPC_FAR *a_pHandler 
) 
{ 
    EnterCriticalSection( &m_cs ) ;

    try
	{
		m_pHandler = a_pHandler ; 
	}
	catch( ... )
	{
		LeaveCriticalSection( &m_cs ) ;
		throw ;
	}

    LeaveCriticalSection( &m_cs ) ;
}

//
IWbemObjectSink __RPC_FAR * CEventProvider::GetHandler()
{
	IWbemObjectSink __RPC_FAR *t_pHandler ;

	EnterCriticalSection( &m_cs ) ;

    m_pHandler->AddRef() ;

	t_pHandler = m_pHandler ;

	LeaveCriticalSection( &m_cs ) ;

	return t_pHandler ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\eventprovider.h ===
//=================================================================

//

// EventProvider.h -- Generic class for eventing

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef _EVENT_PROVIDER_H
#define _EVENT_PROVIDER_H

//
class CEventProvider : 
	public IWbemProviderInit,
	public IWbemEventProvider 
{
	private:

		long m_ReferenceCount ;	

		IWbemObjectSinkPtr			m_pHandler ;
		IWbemClassObjectPtr			m_pClass ;
		CRITICAL_SECTION			m_cs ;		

		// sink management
		void SetHandler( IWbemObjectSink __RPC_FAR *a_pHandler ) ;
		
		// class management
		void SetClass( IWbemClassObject __RPC_FAR *a_pClass ) ;

	protected:
	public:

		CEventProvider() ;
		~CEventProvider() ;

		STDMETHOD(QueryInterface)( REFIID a_riid, void **a_ppv ) ;
		STDMETHODIMP_( ULONG ) AddRef() ;
		STDMETHODIMP_( ULONG ) Release() ;
      
        STDMETHOD(ProvideEvents)(	IWbemObjectSink __RPC_FAR *a_pSink,
									long a_lFlags ) ;

		STDMETHOD (Initialize)(	LPWSTR					a_wszUser, 
								long					a_lFlags, 
								LPWSTR					a_wszNamespace,
								LPWSTR					a_wszLocale,
								IWbemServices			*a_pNamespace, 
								IWbemContext			*a_pCtx,
								IWbemProviderInitSink	*a_pSink ) ;
		
		
		// sink retrieval
		IWbemObjectSink __RPC_FAR * GetHandler() ;

		// class retrieval
		IWbemClassObject __RPC_FAR * GetClass() ;
		IWbemClassObject __RPC_FAR * GetInstance() ;

		// implementor must supply the class name
		virtual BSTR GetClassName() = 0 ;

        // implementor must supply this function.  Normally, it will be
        // one line: delete this;
        virtual void OnFinalRelease() = 0;

		// notification to begin eventing 
		virtual void ProvideEvents() = 0 ;
};

#endif // _EVENT_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\implogonuser.cpp ===
//=================================================================

//

// ImpLogonUser.CPP -- Class to perform impersonation of logged on user.

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    09/09/97    a-sanjes        Created
//
//=================================================================
//#define _WIN32_DCOM // For CoImpersonateUser and CoRevertToSelf
//#include <objbase.h>

#include "precomp.h"

#ifdef NTONLY
#include <tchar.h>
#include <winerror.h>


#include <cominit.h>
#include <lockwrap.h>
#include "Sid.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "CToken.h"
#include "SecureKernelObj.h"
#include "implogonuser.h"




static DWORD s_dwProcessID = 0;
static CCritSec g_csImpersonate;

//////////////////////////////////////////////////////////////////////////////
//
//	implogonuser.cpp - Class implementation of CImpersonateLoggedOnUser.
//
//	This class is intended to provide a way for a process to identify the shell
//	process on a Windows NT system, and using the access token of that process
//	to attempt to impersonate the user logged onto the Interactive Desktop of
//	a workstation.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CImpersonateLoggedOnUser::CImpersonateLoggedOnUser
//
//	DESCRIPTION :	Constructor
//
//	INPUTS      :	NONE		
//
//	OUTPUTS     :	none
//
//	RETURNS     :	nothing
//
//	COMMENTS    :	Constructs empty instance to prepare for impersonation of user.
//
//////////////////////////////////////////////////////////////////////////////

CImpersonateLoggedOnUser::CImpersonateLoggedOnUser() :
	m_hShellProcess(NULL),
	m_hUserToken(NULL),
	m_fImpersonatingUser(FALSE) ,
	m_hThreadToken ( INVALID_HANDLE_VALUE )
{
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CImpersonateLoggedOnUser::~CImpersonateLoggedOnUser
//
//	DESCRIPTION :	Destructor
//
//	INPUTS      :	none
//
//	OUTPUTS     :	none
//
//	RETURNS     :	nothing
//
//	COMMENTS    :	Class destructor
//
//////////////////////////////////////////////////////////////////////////////

CImpersonateLoggedOnUser::~CImpersonateLoggedOnUser( void )
{
	// Stop any current impersonation
	End();
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CImpersonateLoggedOnUser::Begin
//
//	DESCRIPTION :	Attempts to begin impersonation of user.
//
//	INPUTS      :	none
//
//	OUTPUTS     :	none
//
//	RETURNS     :	BOOL		TRUE/FALSE - Success/Failure
//
//	COMMENTS    :	Uses helper functions to try to impersonate the
//						currently logged on user.  The process must have
//						the proper level of access to perform the operation.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::Begin( void )
{
	BOOL	fReturn = FALSE;
	TCHAR	szShellProcessName[256];
	LogMessage(_T("CImpersonateLoggedOnUser::Begin"));
	
	// Only continue if we are not already impersonating a user
	if (!m_fImpersonatingUser )
	{
		//Store the current thread token, assuming that the thread is impersonating somebody (DCOM client)
        if ( !OpenThreadToken ( GetCurrentThread(), TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, TRUE, &m_hThreadToken ) )
		{
			m_hThreadToken = INVALID_HANDLE_VALUE;
		}

		// We will need a copy of PSAPI.DLL and a bunch of entry point
		// addresses before we can continue, so let our base class take
		// care of this.
	
		// We need a handle for the Shell Process in order to
		// successfully impersonate the user.
		if ( NULL == m_hShellProcess )
		{
			if ( LoadShellName( szShellProcessName, sizeof(szShellProcessName) ) )
				FindShellProcess( szShellProcessName);
			else
				LogErrorMessage(_T("LoadShellName failed"));
		}

		if ( NULL != m_hShellProcess )
		{
			fReturn = ImpersonateUser();
		}
		else
		{
			// We didn't find the Shell Process Name that we extracted from the
			// registry.  We saw this happening on Alphas that seem to get "fx32strt.exe"
			// dumped in the shell.  In these cases, it seems to cause explorer to run.
			// So with that in mind, if we drop down in this branch of code, we're going
			// to retry the locate shell process operation using Explorer.Exe and if that
			// fails, Progman.Exe.

			if ( IsErrorLoggingEnabled() )
			{
				CHString sTemp;
				sTemp.Format(_T("Shell Name %s in Registry not found in process list."), szShellProcessName);
				LogErrorMessage(sTemp);
			}

			// First try Explorer, then Progman
			if ( !FindShellProcess( IDS_WINNT_SHELLNAME_EXPLORER ) )
			{
				FindShellProcess( IDS_WINNT_SHELLNAME_PROGMAN );
			}

			// m_hShellProcess will be non-NULL if and only if we got one.
			if ( NULL != m_hShellProcess )
			{
				fReturn = ImpersonateUser();
			}
			else
			{
				LogErrorMessage(_T("Unable to locate Shell Process, Impersonation failed."));
				SetLastError(0);
			}
		}
	}
	else
	{
		LogMessage(_T("CImpersonateLoggedOnUser::Begin - Already impersonated"));
		fReturn = TRUE;	// Already initialized
	}

	// We don't yet have a way to know whether explorer is really alive
	// because we're impersonating someone and I can't find a way to
	// revert back to LocalSystem.  So, for now just set it to 0.
	SetLastError(0);

	return fReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CImpersonateLoggedOnUser::End
//
//	DESCRIPTION :	Ends impersonation of logged on user
//
//	INPUTS      :	none
//
//	OUTPUTS     :	none
//
//	RETURNS     :	BOOL		TRUE/FALSE - Success/Failure
//
//	COMMENTS    :	Ends impersonation of logged on user.  Clears all elements
//						of class as a byproduct.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::End( void )
{
	BOOL	fReturn = FALSE;

	// Only initiate a Revert if we are impersonating the user.

	if ( m_fImpersonatingUser )
	{
		LogMessage(_T("CImpersonateLoggedOnUser::End"));
		fReturn = Revert();
	}
	else
	{
		fReturn = TRUE;
	}

	// Clear the handles out
	if ( NULL != m_hUserToken )
	{
		CloseHandle( m_hUserToken );
		m_hUserToken = NULL;
	}

	if ( NULL != m_hShellProcess )
	{
		CloseHandle( m_hShellProcess );
		m_hShellProcess = NULL;
	}
	if ( m_hThreadToken != INVALID_HANDLE_VALUE )
	{
		CloseHandle( m_hThreadToken );
		m_hThreadToken = INVALID_HANDLE_VALUE ;
	}
	return fReturn;

}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::LoadShellName
//
//  DESCRIPTION : Loads Windows NT Shell name from registry
//
//  INPUTS      :	DWORD		cbShellNameBuffer - Shell Name Buffer Size (in bytes)
//
//  OUTPUTS     : LPTSTR	pszShellName - Buffer to contain shell name.
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Jumps into Windows Registry and attempts to determine the
//						NT Shell Name.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::LoadShellName( LPTSTR pszShellName, DWORD cbShellNameBuffer )
{
	BOOL	fReturn = FALSE;
	LONG	lErrReturn = ERROR_SUCCESS;

	// Only continue if we have a buffer to work with first

	if ( NULL != pszShellName )
	{
		HKEY	hReg = NULL;

		// Open the key in HKEY_LOCAL_MACHINE, if that succeeds, get the
		// value associated with "Shell".
		if ( ( lErrReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
												  WINNT_WINLOGON_KEY,
												  0,
												  KEY_READ,
												  &hReg ) ) == ERROR_SUCCESS )
		{
            try
            {

			    DWORD		dwType = REG_SZ;

			    if ( ( lErrReturn = RegQueryValueEx( hReg,
															    WINNT_SHELL_VALUE,
															    0,
															    &dwType,
															    (LPBYTE) pszShellName,
															    &cbShellNameBuffer ) ) == ERROR_SUCCESS )
			    {
				    fReturn = TRUE;
			    }
			    else
                {
				    LogErrorMessage(_T("RegQueryValueEx FAILED"));
                }
            }
            catch ( ... )
            {
    			RegCloseKey( hReg );
                throw ;
            }

			RegCloseKey( hReg );

		}	// RegOpenKeyEx
		else
        {
			LogErrorMessage(_T("RegOpenKeyEx FAILED"));
        }

	}	// NULL != pszShellName

	return fReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::FindShellProcess
//
//  DESCRIPTION : Enumerates the processes to locate the Shell Process.
//
//  INPUTS      :	LPCTSTR	pszShellName - Name of the process to locate.
//
//  OUTPUTS     : None.
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Enumerates the processes on the local system using PSAPI.DLL
//						functions, attempting to locate the one that corresponds to
//						the WINNT Shell passed into this function.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::FindShellProcess( LPCTSTR pszShellName )
{
	BOOL fReturn = FALSE;
	HANDLE	hProcess = NULL;
	HMODULE *phModules = NULL;
    DWORD dwModuleArraySize = 0;
	DWORD*	pdwProcessIds = NULL;

	if ( NULL != pszShellName )
	{
	    CPSAPI *t_psapi = (CPSAPI*) CResourceManager::sm_TheResourceManager.GetResource ( guidPSAPI, NULL ) ;

	    try
	    {
            // This locks access to the s_dwProcessID value.  WATCH THE SCOPING HERE!
            CLockWrapper t_lockImp(g_csImpersonate);

            // First check to see if we have a cached value.  If so, check to see if it's still valid.
            if (s_dwProcessID != 0)
            {
		        if ( ( hProcess = OpenProcess(	PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
													        FALSE,
													        s_dwProcessID ) )
							        != NULL )
		        {
			        try
			        {
				        // Now search the process modules for a match to the supplied
				        // shell name.

				        fReturn = FindShellModuleInProcess( pszShellName, hProcess, phModules, dwModuleArraySize, t_psapi );
			        }
			        catch ( ... )
			        {
				        CloseHandle (hProcess);
				        throw ;
			        }

			        // Close the process handle if it's not the shell (in which
			        // case we'll save the value and close it as part of the
			        // Clear() function.

			        if ( !fReturn )
			        {
				        CloseHandle( hProcess );
				        hProcess = NULL;

                        // Not valid anymore
                        s_dwProcessID = 0;
			        }
			        else
			        {
				        m_hShellProcess = hProcess;
                    	LogMessage(L"Using cached handle for impersonation");

				        hProcess = NULL;
			        }

		        }	// if OpenProcess
                else
                {
                    // We didn't open the process, so we need to set the value to zero so that
                    // we will look for a new process below.
                    s_dwProcessID = 0;
                }
            }

            // Did we find a cached value?
            if (s_dwProcessID == 0)
            {
                // Nope.  Scan all processes to see if we can find the explorer

			    DWORD		dwProcessIdArraySize	=	0,
						    dwNumProcesses			=	0,
						    cbDataReturned			=	0;
			    BOOL		fEnumSucceeded	=	FALSE;

			    // Perform initial allocations of our arrays.  Since
			    // pointers and values are 0, this will just fill out
			    // said values.

				do
				{
                    ReallocProcessIdArray( pdwProcessIds, dwProcessIdArraySize );

                    fEnumSucceeded = t_psapi->EnumProcesses( pdwProcessIds, dwProcessIdArraySize, &cbDataReturned );

                } while ( (dwProcessIdArraySize == cbDataReturned) && fEnumSucceeded);

				// Only walk the array if we sucessfully populated it
				if ( fEnumSucceeded )
				{
					// Count of Bytes returned / sizeof(DWORD) tells us how many
					// processes are out in the world.

					dwNumProcesses = cbDataReturned / sizeof(DWORD);

					DWORD	dwId = 0;

					// Enum processes until we obtain a shell process or run out
					// of processes to query.

					while (		dwId		<		dwNumProcesses
								&&	!fReturn								)
					{
						if ( ( hProcess = OpenProcess(	PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
																	FALSE,
																	pdwProcessIds[dwId] ) )
											!= NULL )
						{
							try
							{
								// Now search the process modules for a match to the supplied
								// shell name.

								fReturn = FindShellModuleInProcess( pszShellName, hProcess, phModules, dwModuleArraySize, t_psapi );
							}
							catch ( ... )
							{
								CloseHandle (hProcess);
								throw ;
							}

							// Close the process handle if it's not the shell (in which
							// case we'll save the value and close it as part of the
							// Clear() function.

							if ( !fReturn )
							{
								CloseHandle( hProcess );
								hProcess = NULL;
							}
							else
							{
								m_hShellProcess = hProcess;
                                s_dwProcessID = pdwProcessIds[dwId];
								hProcess = NULL;
							}

						}	// if OpenProcess

						// Increment the Id counter

						++dwId;

					}	// While OpenProcesses

				}	// If !fRetryEnumProcesses
            }
	    }
	    catch ( ... )
	    {
            if (phModules)
            {
			    delete [] phModules;
            }

            if (pdwProcessIds)
            {
			    delete [] pdwProcessIds;
            }

            if ( t_psapi )
		    {
			    CResourceManager::sm_TheResourceManager.ReleaseResource ( guidPSAPI, t_psapi ) ;
			    t_psapi = NULL ;
		    }
		    throw ;
	    }

        if (pdwProcessIds)
        {
			delete [] pdwProcessIds;
        }

        if (phModules)
        {
            delete [] phModules;
        }

	    if ( t_psapi )
	    {
		    CResourceManager::sm_TheResourceManager.ReleaseResource ( guidPSAPI, t_psapi ) ;
//		    t_psapi = NULL ;
	    }
    }

	return fReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::FindShellModuleInProcess
//
//  DESCRIPTION : Enumerates the modules in a process to find our
//						shell.
//
//  INPUTS      :	LPCTSTR		pszShellName - Name of the process to locate.
//						HANDLE		hProcess - Process we are enumerating modules in.
//
//  OUTPUTS     : HMODULE*&	phModules - Array of module handle pointers.
//						DWORD&		dwModuleArraySize - Size of Module Array (in bytes)
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Enumerates the modules specified by a process identifier and
//						attemptsto locate the one that corresponds to the WINNT Shell
//						passed into this function.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::FindShellModuleInProcess( LPCTSTR pszShellName, HANDLE hProcess, HMODULE*& phModules, DWORD& dwModuleArraySize, CPSAPI *a_psapi )
{
	BOOL	fReturn				=	FALSE,
			fRetryEnumModules	=	FALSE;
	DWORD	dwNumModules		=	0,
			cbDataReturned		=	0;

	TCHAR	szModuleName[MAX_PATH];

    if (dwModuleArraySize == 0)
    {
	    ReallocModuleHandleArray( phModules, dwModuleArraySize );
    }

	do
	{
		// Get a list of the process HMODULEs and for each HMODULE, get
		// the base file name.

		if ( a_psapi->EnumProcessModules( hProcess, phModules, dwModuleArraySize, &cbDataReturned ) )
		{

			// Because m_pfnEnumProcessModules will NOT fail if there are more process
			// modules than bytes available in the array, if the amount returned is
			// the same size as the array, realloc the array and retry the Enum.

			if ( dwModuleArraySize == cbDataReturned )
			{
				fRetryEnumModules = ReallocModuleHandleArray( phModules, dwModuleArraySize );
			}
			else
			{
				fRetryEnumModules = FALSE;
			}

			// Only walk the array if we don't need to retry the enum
			if ( !fRetryEnumModules )
			{

				dwNumModules = cbDataReturned / sizeof(DWORD);

                DWORD dwModuleCtr = 0;

                // Executable name always returned in entry 0
//				for ( DWORD dwModuleCtr = 0;
//
//						!fReturn &&
//						dwModuleCtr < dwNumModules;
//
//						dwModuleCtr++ )
				{

					if ( a_psapi->GetModuleBaseName( hProcess, phModules[dwModuleCtr], szModuleName, sizeof(szModuleName) ) )
					{
						fReturn = ( lstrcmpi( pszShellName, szModuleName ) == 0 );
					}

				}	// for dwModuleCtr

			}	// If !fRetryEnumModules

		}	// if EnumProcessModules

	}
	while ( fRetryEnumModules );

	return fReturn;
}

DWORD CImpersonateLoggedOnUser::AdjustSecurityDescriptorOfImpersonatedToken(
    CSid& csidSidOfCurrentProcess )
{
	DWORD dwRet = E_FAIL;
    
    // Get the thread token...
    CThreadToken ctt(false, false, true);
    // Obtain access to its security descriptor...
    CSecureKernelObj sko(ctt.GetTokenHandle(), FALSE);
    // Modify the security descriptor...
    if(sko.AddDACLEntry(
        csidSidOfCurrentProcess,
        ENUM_ACCESS_ALLOWED_ACE_TYPE,
        TOKEN_ALL_ACCESS,
        0,
        NULL,
        NULL))
    {
        dwRet = sko.ApplySecurity(
			DACL_SECURITY_INFORMATION);
    }

    return dwRet ;
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::ImpersonateUser
//
//  DESCRIPTION : Attempts to impersonate the user.
//
//  INPUTS      :	None.
//
//  OUTPUTS     : None.
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Opens the security token of the Shell Process and
//						uses it to try to impersonate the user.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::ImpersonateUser( void )
{
	BOOL fRet = FALSE;
    // Make sure we have a shell process
	if (m_hShellProcess)
    {
        CSid csidCurrentProcess;
        if(GetCurrentProcessSid(csidCurrentProcess))
        {
            // Get the Process User token if we don't have one (token of the explorer process).
	        //Removed the TOKEN_ALL_ACCESS desired access mask to this call as Winmgmt(Local system) can't open the token of the
	        //shell process (with all access rights)if the logged-in user is an Admin. So open the token with 'desired access' sufficient
	        //enough to use it for impersonation only.
	        if (m_hUserToken ||
		        OpenProcessToken(m_hShellProcess, TOKEN_QUERY | TOKEN_DUPLICATE , &m_hUserToken))
		    {
	            // Now we should have what we need.  Impersonate the user.

                if(::ImpersonateLoggedOnUser( m_hUserToken ))
                {
                   if(AdjustSecurityDescriptorOfImpersonatedToken ( csidCurrentProcess ) == ERROR_SUCCESS)
                   {
                        fRet = TRUE;
                   }
                }
            }
        }
    }
	return (m_fImpersonatingUser = fRet);
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::Revert
//
//  DESCRIPTION : Attempts to revert to self.
//
//  INPUTS      :	None.
//
//  OUTPUTS     : None.
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : If we're impersonating a user, we now revert to
//						ourselves.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::Revert( void )
{
	HRESULT hRes = WBEM_E_FAILED ;
	BOOL bRet = FALSE ;
	// See if we're currently impersonating prior to reverting.
	if (m_fImpersonatingUser)
	{
		// Now get back to to the previous impersonation or impersonate the DCOM client.
		if ( m_hThreadToken != INVALID_HANDLE_VALUE )
		{
			bRet = ImpersonateLoggedOnUser ( m_hThreadToken ) ;

			if (!bRet)
			{
				throw CFramework_Exception(L"ImpersonateLoggedOnUser failed", GetLastError());
			}
		}
		else
		{
			hRes = WbemCoImpersonateClient();

			if (FAILED(hRes))
			{
				throw CFramework_Exception(L"WbemCoImpersonateClient failed", hRes);
			}
		}

		if (SUCCEEDED(hRes) || hRes == E_NOTIMPL || bRet )
		{
			m_fImpersonatingUser = FALSE;
		}
	}
	return ( !m_fImpersonatingUser );
}



//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::ReallocProcessIdArray
//
//  DESCRIPTION : Helper function to alloc a process id array.
//
//  INPUTS      :	None.
//
//  OUTPUTS     : PDWORD&	pdwProcessIds - Process Id Array pointer
//						DWORD&	dwArraySize - Size of array in bytes
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Call when we need to realloc our process id array.
//						This will grow the array by a fixed size, but not
//						preserve values.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::ReallocProcessIdArray( PDWORD& pdwProcessIds, DWORD& dwArraySize )
{
	DWORD		dwNewArraySize	=	dwArraySize + ( PROCESSID_ARRAY_BLOCKSIZE * sizeof(DWORD) );
	PDWORD	pdwNewArray		=	new DWORD[dwNewArraySize];

	// Make sure the allocation succeeded before overwriting any existing values.
	if ( NULL != pdwNewArray )
	{
		if ( NULL != pdwProcessIds )
		{
			delete [] pdwProcessIds;
		}

		pdwProcessIds = pdwNewArray;
		dwArraySize = dwNewArraySize;
	}
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

	return ( NULL != pdwNewArray );
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    : CImpersonateLoggedOnUser::ReallocModuleHandleArray
//
//  DESCRIPTION : Helper function to alloc a module handle array.
//
//  INPUTS      :	None.
//
//  OUTPUTS     : HMODULE*&	phModules - Module Handle Array pointer
//						DWORD&		dwArraySize - size of array in bytes
//
//  RETURNS     : BOOL		TRUE/FALSE - Success/Failure
//
//  COMMENTS    : Call when we need to realloc our module handle array.
//						This will grow the array by a fixed size, but not
//						preserve values.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CImpersonateLoggedOnUser::ReallocModuleHandleArray( HMODULE*& phModules, DWORD& dwArraySize )
{
	DWORD		dwNewArraySize	=	dwArraySize + ( HMODULE_ARRAY_BLOCKSIZE * sizeof(HMODULE) );
	HMODULE*	phNewArray		=	new HMODULE[dwNewArraySize];

	// Make sure the allocation succeeded before overwriting any existing values.

	if ( NULL != phNewArray )
	{
		if ( NULL != phModules )
		{
			delete [] phModules;
		}

		phModules = phNewArray;
		dwArraySize = dwNewArraySize;
	}
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }


	return ( NULL != phNewArray );
}

bool CImpersonateLoggedOnUser::GetCurrentProcessSid(CSid& sidCurrentProcess)
{
    bool fRet = false;

    PBYTE pbuff = NULL;

    // I am going to revert here in order to access the process's
    // sid.  This is not privileged information, so this doesn't
    // present a security breach.

    WbemCoRevertToSelf();

    try
    {
        CProcessToken cpt(TOKEN_QUERY, true);

        DWORD dwLen = 0;
        if(!::GetTokenInformation(
            cpt.GetTokenHandle(),    // the PR0CESS token
            TokenUser,
            NULL,
            0L,
            &dwLen) && (::GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            pbuff = new BYTE[dwLen];
            if(pbuff)
            {
                if(::GetTokenInformation(
                    cpt.GetTokenHandle(),
                    TokenUser,
                    pbuff,
                    dwLen,
                    &dwLen))
                {
                    PTOKEN_USER ptu = (PTOKEN_USER)pbuff;
                    CSid sidTemp(ptu->User.Sid);
                    if(sidTemp.IsOK() &&
                        sidTemp.IsValid())
                    {
                        sidCurrentProcess = sidTemp;
                        fRet = true;
                    }
                }
                delete pbuff;
                pbuff = NULL;
            }
        }
    }
    catch(...)
    {
		//on our way out not returning anything to user except failure
		//can't do anything on this impersonation failure...
        WbemCoImpersonateClient();
        delete pbuff;
        pbuff = NULL;
        throw;
    }

	HRESULT hr = WbemCoImpersonateClient() ;

	if (FAILED(hr))
	{
		throw CFramework_Exception(L"WbemCoImpersonateClient failed", hr);
	}

    return fRet;     
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\implogonuser.h ===
//=================================================================

//

// ImpLogonUser.H -- Class to perform impersonation of logged on user.

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    09/09/97    a-sanjes        Created
//
//=================================================================

#ifndef __IMPLOGONUSER_H__
#define __IMPLOGONUSER_H__

//////////////////////////////////////////////////////////////////////////////
//
//	ImpLogonUser.H - Class definition of CImpersonateLoggedOnUser.
//	
//	This class is intended to provide a way for a process to identify the shell
//	process on a Windows NT system, and using the access token of that process
//	to attempt to impersonate the user logged onto the Interactive Desktop of
//	a workstation.
//	
//	To use this class, simply construct it, and call the Begin() function.  If
//	it succeeds, you may then access information that would otherwise not be
//	available to your process (such as network connection info).  When you are
//	finished, call End() to clear out the class.  
//
//	Caveats:
//	1>	This class is NOT thread safe, so don't share it across multiple
//		threads!  Besides, ImpersonateLoggedOnUser() is only good for the thread
//		it was called on.
//	2>	If multiple instances of the Shell process are running, this method
//		may or may not be accurate.  It will probably work in a large percentage
//		of cases however.
//	3>	Multiple logged on users will cause problems for this code (see #2).
//	4>	This class may need to be optimized for speed, as it currently makes no
//		use of caches and "redicovers" the shell process each time an instance
//		is implemented.
//	5>	PSAPI.DLL must be available.
//
//////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
#include "wbempsapi.h"

// String Constants

// Resides under HKEY_LOCAL_MACHINE
#define	WINNT_WINLOGON_KEY	_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon")
#define	WINNT_SHELL_VALUE		_T("Shell")

// Memory allocation definitions
#define	PROCESSID_ARRAY_BLOCKSIZE	1024
#define	HMODULE_ARRAY_BLOCKSIZE		1024

class CImpersonateLoggedOnUser
{
public:

	CImpersonateLoggedOnUser();
	~CImpersonateLoggedOnUser();

	// User Interface
	BOOL Begin( void );
	BOOL End( void );

	// inlines

	BOOL IsImpersonatingUser( void );

protected:

private:

	// Helpers for identifying the shell process and locating it
	BOOL LoadShellName( LPTSTR pszShellName, DWORD cbShellNameBuffer );
	BOOL FindShellProcess( LPCTSTR pszShellProcessName );
	BOOL FindShellModuleInProcess( LPCTSTR pszShellName, HANDLE hProcess, HMODULE*& phModules, DWORD& dwModuleArraySize, CPSAPI *a_psapi );
    bool GetCurrentProcessSid(CSid& csidCurrentProcess);
    DWORD AdjustSecurityDescriptorOfImpersonatedToken(CSid& csidSidOfCurrentProcess);


	// Perform actual impersonation and revert
	BOOL ImpersonateUser( void );
	BOOL Revert( void );

	// Memory Allocation Helpers

	BOOL ReallocProcessIdArray( PDWORD& pdwProcessIds, DWORD& dwArraySize );
	BOOL ReallocModuleHandleArray( HMODULE*& phModules, DWORD& dwArraySize );

	// Data for impersonating data
	BOOL		m_fImpersonatingUser;
	HANDLE	m_hShellProcess, m_hThreadToken ,
				m_hUserToken;
};

inline BOOL CImpersonateLoggedOnUser::IsImpersonatingUser( void )
{
	return m_fImpersonatingUser;
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\iodesc.cpp ===
//=================================================================

//

//  IODesc.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj
//              10/17/97        jennymc     Moved things a tiny bit
//
/////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <assertbreak.h>
#include "poormansresource.h"
#include "resourcedesc.h"
#include "iodesc.h"
////////////////////////////////////////////////////////////////////////
//
//	Function:	CIODescriptor::CIODescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIODescriptor::CIODescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( pResDescHdr, pOwnerDevice )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIODescriptor::CIODescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Resource Id with flags
//				IOWBEM_DES				ioDes - IO Descriptor.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIODescriptor::CIODescriptor(	DWORD				dwResourceId,
								IOWBEM_DES&				ioDes,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( dwResourceId, &ioDes, sizeof(IOWBEM_DES), pOwnerDevice )
{
	ASSERT_BREAK( ResType_IO == GetResourceType() );
}

// Copy Constructor
CIODescriptor::CIODescriptor( const CIODescriptor& io )
: CResourceDescriptor( io )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIODescriptor::~CIODescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIODescriptor::~CIODescriptor( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIODescriptor::GetString
//
//	Returns a string representation of the associated IO Port Address.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		TRUE/FALSE		Function successful or not.
//
//	Comments:	Do NOT call down to the base class.
//
////////////////////////////////////////////////////////////////////////
void *CIODescriptor::GetResource()
{

	if ( NULL != m_pbResourceDescriptor ){
		// Cast to an IO Resource Descriptor, and place it's IO address values
		// in the string.
		PIO_DES	pIO = (PIO_DES) m_pbResourceDescriptor;
        return pIO;
	}

	return NULL;
}

//
//	Constructor and Destructor for the IO Port Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIOCollection::CIOCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIOCollection::CIOCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIOCollection::~CIOCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIOCollection::~CIOCollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\irqdesc.h ===
#ifndef __IRQDESC_H__

#define __IRQDESC_H__

/////////////////////////////////////////////////////////////////////////

//

//  cfgmgrdevice.h    

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//  
/////////////////////////////////////////////////////////////////////////


class 
__declspec(uuid("CB0E0537-D375-11d2-B35E-00104BC97924"))
CIRQDescriptor : public CResourceDescriptor
{
	
public:

	// Construction/Destruction
	CIRQDescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CIRQDescriptor(	DWORD dwResourceId, IRQ_DES& irqDes, CConfigMgrDevice* pOwnerDevice );
	CIRQDescriptor( const CIRQDescriptor& irq );
	~CIRQDescriptor();

	// Accessors
	DWORD	GetFlags( void );
	BOOL	IsShareable( void );
	ULONG	GetInterrupt( void );
	ULONG	GetAffinity( void );

	// Override of base class functionality
	virtual void * GetResource();
	
};

_COM_SMARTPTR_TYPEDEF(CIRQDescriptor, __uuidof(CIRQDescriptor));

inline DWORD CIRQDescriptor::GetFlags( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIRQ_DES) m_pbResourceDescriptor)->IRQD_Flags : 0 );
}

inline BOOL CIRQDescriptor::IsShareable( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIRQ_DES) m_pbResourceDescriptor)->IRQD_Flags & fIRQD_Share : FALSE );
}

inline DWORD CIRQDescriptor::GetInterrupt( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIRQ_DES) m_pbResourceDescriptor)->IRQD_Alloc_Num : 0 );
}

inline DWORD CIRQDescriptor::GetAffinity( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIRQ_DES) m_pbResourceDescriptor)->IRQD_Affinity : 0 );
}

// A collection of IRQ Descriptors
class CIRQCollection : public TRefPtr<CIRQDescriptor>
{
public:

	// Construction/Destruction
	CIRQCollection();
	~CIRQCollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CIRQCollection& operator = ( const CIRQCollection& srcCollection );

};

inline const CIRQCollection& CIRQCollection::operator = ( const CIRQCollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\irqdesc.cpp ===
//=================================================================

//

//  IRQDesc.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//
//  History:    10/15/97        Sanj        Created by Sanj
//              10/17/97        jennymc     Moved things a tiny bit
//
/////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>
#include "refptr.h"
#include "poormansresource.h"
#include "resourcedesc.h"
#include "irqdesc.h"
////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQDescriptor::CIRQDescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQDescriptor::CIRQDescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( pResDescHdr, pOwnerDevice )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQDescriptor::CIRQDescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Resource Id with flags
//				IRQ_DES					irqDes - IRQ Descriptor.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQDescriptor::CIRQDescriptor(	DWORD				dwResourceId,
							    IRQ_DES&				irqDes,
								CConfigMgrDevice*		pOwnerDevice )
:	CResourceDescriptor( dwResourceId, &irqDes, sizeof(IRQ_DES), pOwnerDevice )
{
	ASSERT_BREAK( ResType_IRQ == GetResourceType() );
}

// Copy Constructor
CIRQDescriptor::CIRQDescriptor( const CIRQDescriptor& irq )
: CResourceDescriptor( irq )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQDescriptor::~CIRQDescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQDescriptor::~CIRQDescriptor( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQDescriptor::GetResource()
//
//	Returns a string representation of the associated IRQ Number.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		TRUE/FALSE		Function successful or not.
//
//	Comments:	Do NOT call down to the base class.
//
////////////////////////////////////////////////////////////////////////

void *CIRQDescriptor::GetResource()
{
	if ( NULL != m_pbResourceDescriptor )
	{
		// Traverse an IRQ Resource Descriptor and place it's IRQ valuestring

		PIRQ_DES	pIRQ = (PIRQ_DES) m_pbResourceDescriptor;
        return pIRQ;

	}
	return NULL;
}

//
//	Constructor and Destructor for the IRQ Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQCollection::CIRQCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQCollection::CIRQCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CIRQCollection::~CIRQCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CIRQCollection::~CIRQCollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\impersonateconnecteduser.cpp ===
//=================================================================

//

// ImpersonateConnectedUser.cpp -- Class to perform impersonation of

//								   a connected user.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    05/21/99    a-peterc        Created
//
// Notes:	This class maps the logon luid ( AuthenticationId )
//			of the running thread to a process that also has the same
//			AuthenticationId. The class then impersonates the process
//			on the running thread.
//
//			Additional routines are available to allow custom
//			looping across all AuthenticationIds. This is useful when
//			targeting for example a Terminal Server in which information
//			across all AuthenticationIds may be required.
//
//=================================================================
#include "precomp.h"
#include <tchar.h>
#include <winerror.h>

#include "ImpersonateConnectedUser.h"
#include <cominit.h>

#ifdef NTONLY

/*=================================================================
 Function:  CImpersonateConnectedUser(),~CImpersonateConnectedUser()

 Description: contructor and destructor

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
CImpersonateConnectedUser::CImpersonateConnectedUser( BOOL t_fRecacheHive /*=TRUE*/ ) :

m_fImpersonatingUser( FALSE ),
m_hProcessToken( NULL ),
m_fRecacheHive( t_fRecacheHive )
{
	// Cache the current thread token
	if ( !OpenThreadToken ( GetCurrentThread(),
							TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, TRUE,
							&m_hThreadToken ) )
	{
		m_hThreadToken = NULL ;
	}

	// validate multimap process iterator
	m_ProcessIter = m_oProcessMap.end() ;
}

//
CImpersonateConnectedUser::~CImpersonateConnectedUser()
{
	FlushCachedHive() ;

	End() ;

	if( m_hThreadToken )
	{
		CloseHandle ( m_hThreadToken ) ;
	}

	// Clear the luid / process map
	m_oProcessMap.clear();
}

/*=================================================================
 Functions:  Begin(), End()

 Description: Provides for impersonation against the running thread.

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
BOOL CImpersonateConnectedUser::Begin()
{
	CProcessID t_Process ;

	__int64 t_ThreadLogonID = GetLogonID( m_hThreadToken ) ;

	if( t_ThreadLogonID )
	{
		if( FindProcessesBy( t_ThreadLogonID ) )
		{
			// For each process associated with this logon ID
			// attempt to impersonate the process onto the thread.

			BeginProcessEnum() ;

			while( GetNextProcess( t_Process ) )
			{
				if( ImpersonateLogonOfProcess( t_Process.dwProcessId ) )
				{
					return TRUE ;
				}
			}
		}
	}
	return FALSE ;
}

//
BOOL CImpersonateConnectedUser::End()
{
	// reverts to whomever this thread was
	// impersonating, i.e. DCOM client or someone else ...
	if( m_hProcessToken )
	{
		CloseHandle( m_hProcessToken ) ;
		m_hProcessToken = NULL ;
	}

	if( m_fImpersonatingUser )
	{
		ResetImpersonation() ;

		m_fImpersonatingUser = FALSE ;
	}
	return TRUE ;
}

/*=================================================================
 Functions:  BeginProcessEnum(), GetNextProcess( CProcessID &a_oProcess )

 Description: Provides for custom impersonation across multiple logons.

 Arguments:

 Notes:		used with FindProcessesBy() and ImpersonateLogonOfProcess()
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
void CImpersonateConnectedUser::BeginProcessEnum()
{
	m_ProcessIter = m_oProcessMap.begin() ;
}

//
BOOL CImpersonateConnectedUser::GetNextProcess( CProcessID &a_oProcess )
{
	if ( m_ProcessIter == m_oProcessMap.end() )
	{
		return FALSE ;
	}
	else
	{
		a_oProcess.luid			= m_ProcessIter->first ;
		a_oProcess.dwProcessId	= m_ProcessIter->second ;
		++m_ProcessIter ;
		return TRUE ;
	}
}

/*=================================================================
 Functions:  ImpersonateLogonOfProcess

 Description: Provides for impersonation against a targeted process.

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
BOOL CImpersonateConnectedUser::ImpersonateLogonOfProcess( DWORD &a_dwProcessID )
{
	HANDLE	t_hProcess = NULL ;

	try
	{
		if( m_hProcessToken = GetProcessToken( a_dwProcessID ) )
		{
			if( !ImpersonateLoggedOnUser ( m_hProcessToken ) )
			{
				CloseHandle( m_hProcessToken ) ;
				m_hProcessToken = NULL ;

				// reset to baseline context
				ResetImpersonation() ;
			}
			else
			{
				m_fImpersonatingUser = TRUE ;

				RecacheHive() ;
			}
		}
	}
	catch( ... )
	{
		End() ;

		if( t_hProcess )
		{
			CloseHandle( t_hProcess ) ;
		}
		throw ;
	}

	return m_hProcessToken ? TRUE : FALSE ;
}

/*=================================================================
 Functions:  ResetImpersonation

 Description: Restores the impersonation on the thread to the original state .

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
void CImpersonateConnectedUser::ResetImpersonation()
{
	// reset the original impersonation token
	if ( m_hThreadToken )
	{
		if (!ImpersonateLoggedOnUser ( m_hThreadToken ))
		{
			throw CFramework_Exception(L"ImpersonateLoggedOnUser failed", GetLastError());
		}
	}
	else
	{
		HRESULT hr = WbemCoImpersonateClient() ;

		if (FAILED(hr))
		{
			throw CFramework_Exception(L"WbemCoImpersonateClient failed", hr);
		}
	}

	RecacheHive() ;
}

/*=================================================================
 Functions:  GetLogonID

 Description: Retrieves a logon luid for a process ot thread token.

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
__int64 CImpersonateConnectedUser::GetLogonID( HANDLE a_hToken )
{
	// get the session logon ID
	TOKEN_STATISTICS	t_oTokenStats ;
	DWORD				t_dwReturnLength ;

	if( GetTokenInformation(
							a_hToken,				// handle of access token
							TokenStatistics,		// type of information to retrieve
							&t_oTokenStats,			// address of retrieved information
							sizeof( t_oTokenStats ),// size of information buffer
							&t_dwReturnLength ) )	// address of required buffer size
	{
		return *(__int64*)(&t_oTokenStats.AuthenticationId) ;
	}

	return NULL ;
}

/*=================================================================
 Functions:  GetProcessToken

 Description: Retrieves a process token for a specific process.

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
HANDLE CImpersonateConnectedUser::GetProcessToken( DWORD a_dwProcessID )
{
	HANDLE	t_hProcess		= NULL ;
	HANDLE	t_hProcessToken = NULL ;

	try
	{
		// Handle for this process
		if ( ( t_hProcess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, a_dwProcessID ) ) != NULL )
		{
			// Token for this process. TOKEN_QUERY | TOKEN_DUPLICATE only as
			// as Winmgmt(Local system) can't open the token of the
			// shell process (with all access rights) if the logged-in user is an Admin.

			if ( !OpenProcessToken( t_hProcess, TOKEN_QUERY | TOKEN_DUPLICATE , &t_hProcessToken ) )
			{
				t_hProcessToken = NULL ;
			}

			CloseHandle ( t_hProcess ) ;
			t_hProcess = NULL ;
		}
	}
	catch( ... )
	{
		if( t_hProcess )
		{
			CloseHandle ( t_hProcess ) ;
		}
		throw ;
	}

	return t_hProcessToken ;
}

/*=================================================================
 Functions:  FindProcessesBy

 Description: Locates and builds a process map either by luid or if
			  the argument is NULL builds a process map for all processes.

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
BOOL CImpersonateConnectedUser::FindProcessesBy( __int64 a_luid )
{
	BOOL t_fReturn = FALSE;

	CPSAPI	*t_psapi = (CPSAPI*) CResourceManager::sm_TheResourceManager.GetResource ( guidPSAPI, NULL ) ;

	if( !t_psapi )
	{
		return FALSE ;
	}

	DWORD	*t_pdwProcessIds	=	NULL;
	HANDLE	t_hThreadToken		=	NULL;
	HANDLE	t_hProcessToken		=	NULL ;
	try
	{
		DWORD	t_dwProcessIdArraySize	=	0,
				t_dwNumProcesses		=	0,
				t_cbDataReturned		=	0;
		BOOL	t_fValidProcessArray	=	FALSE;

		// Clear the luid / process map
		m_oProcessMap.clear();

		// make up to 3 passes to get at the process list
		for( int i = 0; i < 3; i++ )
		{
			ReallocProcessIdArray( t_pdwProcessIds, t_dwProcessIdArraySize ) ;

			if ( t_psapi->EnumProcesses( t_pdwProcessIds, t_dwProcessIdArraySize, &t_cbDataReturned ) )
			{
				// Because EnumProcesses will NOT fail if there are more processes than
				// bytes available in the array, if the amount returned is the same size
				// as the array, realloc the array and retry the Enum.

				if ( t_dwProcessIdArraySize == t_cbDataReturned )
				{
					ReallocProcessIdArray( t_pdwProcessIds, t_dwProcessIdArraySize );
				}
				else
				{
					t_fValidProcessArray = TRUE ;
					break ;
				}
			}
		}

		// Identify and stow any processes matching the requested logonID
		if( t_fValidProcessArray )
		{
			// # of processes
			t_dwNumProcesses = t_cbDataReturned / sizeof( DWORD ) ;

			// ID the processes by logon ID
			for( DWORD t_dwId = 0; t_dwId < t_dwNumProcesses; t_dwId++ )
			{
				// process token
				if( t_hProcessToken = GetProcessToken( t_pdwProcessIds[ t_dwId ] ) )
				{
					// and Logon ID
					__int64 t_ProcessLogonID = GetLogonID( t_hProcessToken ) ;

					// add to the process list
					if( NULL == a_luid || t_ProcessLogonID == a_luid )
					{
						// map this process
						m_oProcessMap.insert(
										pair<__int64 const, DWORD>(
										t_ProcessLogonID,
										t_pdwProcessIds[ t_dwId ] ) ) ;

						t_fReturn = TRUE ;
					}

					CloseHandle( t_hProcessToken ) ;
					t_hProcessToken = NULL ;
				}
			}
		}

		if( t_pdwProcessIds )
		{
			delete [] t_pdwProcessIds;
			t_pdwProcessIds = NULL ;
		}

		if ( t_psapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( guidPSAPI, t_psapi ) ;
			t_psapi = NULL ;
		}
	}
	catch ( ... )
	{
		if( t_hProcessToken )
		{
      		CloseHandle( t_hProcessToken ) ;
			t_hProcessToken = NULL ;
		}

		if( t_pdwProcessIds )
		{
			delete [] t_pdwProcessIds;
		}

		if ( t_psapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource ( guidPSAPI, t_psapi ) ;
		}
		throw ;
	}

	return t_fReturn ;
}

/*=================================================================
 Functions:  ReallocProcessIdArray

 Description: Memory allocation routine for EnumProcess

 Arguments:

 Notes:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:					a-peterc  21-May-1999     Created
=================================================================*/
BOOL CImpersonateConnectedUser::ReallocProcessIdArray( PDWORD& pdwProcessIds, DWORD& dwArraySize )
{
	DWORD		dwNewArraySize	=	dwArraySize + ( PROCESSID_ARRAY_BLOCKSIZE * sizeof(DWORD) );
	PDWORD	pdwNewArray		=	new DWORD[dwNewArraySize];

	// Make sure the allocation succeeded before overwriting any existing values.
	if ( NULL != pdwNewArray )
	{
		if ( NULL != pdwProcessIds )
		{
			delete [] pdwProcessIds;
		}

		pdwProcessIds = pdwNewArray;
		dwArraySize = dwNewArraySize;
	}
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

	return ( NULL != pdwNewArray );
}

//
void CImpersonateConnectedUser::RecacheHive()
{
	// load the users hive
	if( m_fRecacheHive )
	{
		RegCloseKey( HKEY_CURRENT_USER ) ;
		RegEnumKey( HKEY_CURRENT_USER, 0, NULL, 0 ) ;
	}
}

void CImpersonateConnectedUser::FlushCachedHive()
{
	// load the users hive
	if( m_fRecacheHive )
	{
		RegCloseKey( HKEY_CURRENT_USER ) ;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\kernel32api.cpp ===
//=================================================================

//

// Kernel32API.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "Kernel32Api.h"
#include "DllWrapperCreatorReg.h"



// {DDEA7E32-CCE8-11d2-911E-0060081A46FD}
static const GUID g_guidKernel32Api =
{0xddea7e32, 0xcce8, 0x11d2, {0x91, 0x1e, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};

static const TCHAR g_tstrKernel32[] = _T("KERNEL32.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CKernel32Api, &g_guidKernel32Api, g_tstrKernel32> MyRegisteredKernel32Wrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CKernel32Api::CKernel32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnGetDiskFreeSpaceEx(NULL),
   m_pfnCreateToolhelp32Snapshot(NULL),
   m_pfnThread32First(NULL),
   m_pfnThread32Next(NULL),
   m_pfnProcess32First(NULL),
   m_pfnProcess32Next(NULL),
   m_pfnModule32First(NULL),
   m_pfnModule32Next(NULL),
   m_pfnHeap32ListFirst(NULL),
   m_pfnGlobalMemoryStatusEx(NULL),
   m_pfnGetSystemDefaultUILanguage(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CKernel32Api::~CKernel32Api()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CKernel32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {

#ifdef NTONLY

        m_pfnGetDiskFreeSpaceEx = (PFN_KERNEL32_GET_DISK_FREE_SPACE_EX)
                                    GetProcAddress("GetDiskFreeSpaceExW");

        m_pfnGetVolumePathName = (PFN_KERNEL32_GET_VOLUME_PATH_NAME)
                                    GetProcAddress("GetVolumePathNameW");
#endif

#ifdef WIN9XONLY

        m_pfnGetDiskFreeSpaceEx = (PFN_KERNEL32_GET_DISK_FREE_SPACE_EX)
                                    GetProcAddress("GetDiskFreeSpaceExA");

        m_pfnGetVolumePathName = (PFN_KERNEL32_GET_VOLUME_PATH_NAME)
                                    GetProcAddress("GetVolumePathNameA");

#endif
        // NT5 ONLY FUNCTIONS
        m_pfnCreateToolhelp32Snapshot = (PFN_KERNEL32_CREATE_TOOLHELP32_SNAPSHOT)
                                    GetProcAddress("CreateToolhelp32Snapshot");

        m_pfnThread32First = (PFN_KERNEL32_THREAD32_FIRST)
                                    GetProcAddress("Thread32First");

        m_pfnThread32Next = (PFN_KERNEL32_THREAD32_NEXT)
                                    GetProcAddress("Thread32Next");

        m_pfnProcess32First = (PFN_KERNEL32_PROCESS32_FIRST)
                                    GetProcAddress("Process32First");

        m_pfnProcess32Next = (PFN_KERNEL32_PROCESS32_NEXT)
                                    GetProcAddress("Process32Next");

        m_pfnModule32First = (PFN_KERNEL32_MODULE32_FIRST)
                                    GetProcAddress("Module32First");

        m_pfnModule32Next = (PFN_KERNEL32_MODULE32_NEXT)
                                    GetProcAddress("Module32Next");

        m_pfnHeap32ListFirst = (PFN_KERNEL32_HEAP32_LIST_FIRST)
                                    GetProcAddress("Heap32ListFirst");

        m_pfnGlobalMemoryStatusEx = (PFN_KERNEL32_GLOBAL_MEMORY_STATUS_EX)
                                    GetProcAddress("GlobalMemoryStatusEx");

        m_pfnGetSystemDefaultUILanguage = (PFN_KERNEL32_GET_SYSTEM_DEFAULT_U_I_LANGUAGE)
                                    GetProcAddress("GetSystemDefaultUILanguage");

        // Check that we have function pointers to functions that should be
        // present in all versions of this dll...
        // ( in this case, ALL these are functions that may or may not be
        //   present, so don't bother)
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping Kernel32 api functions. Add new functions here
 * as required.
 ******************************************************************************/

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::GetDiskFreeSpaceEx
(
    LPCTSTR a_lpDirectoryName,
    PULARGE_INTEGER a_lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER a_lpTotalNumberOfBytes,
    PULARGE_INTEGER a_lpTotalNumberOfFreeBytes,
    BOOL *a_pfRetval
)
{
    BOOL t_fExists = FALSE;
    BOOL t_fTemp = FALSE;
    if(m_pfnGetDiskFreeSpaceEx != NULL)
    {
        t_fTemp = m_pfnGetDiskFreeSpaceEx(a_lpDirectoryName,
                                       a_lpFreeBytesAvailableToCaller,
                                       a_lpTotalNumberOfBytes,
                                       a_lpTotalNumberOfFreeBytes);
        t_fExists = TRUE;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::CreateToolhelp32Snapshot
(
    DWORD a_dwFlags,
    DWORD a_th32ProcessID,
    HANDLE *a_phRetval
)
{
    bool t_fExists = false;
    HANDLE t_hTemp;
    if(m_pfnCreateToolhelp32Snapshot != NULL)
    {
        t_hTemp = m_pfnCreateToolhelp32Snapshot(a_dwFlags, a_th32ProcessID);

        t_fExists = true;

        if(a_phRetval != NULL)
        {
            *a_phRetval = t_hTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Thread32First
(
    HANDLE a_hSnapshot,
    LPTHREADENTRY32 a_lpte,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnThread32First != NULL)
    {
        t_fTemp = m_pfnThread32First(a_hSnapshot, a_lpte);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Thread32Next
(
    HANDLE a_hSnapshot,
    LPTHREADENTRY32 a_lpte,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnThread32Next != NULL)
    {
        t_fTemp = m_pfnThread32Next(a_hSnapshot, a_lpte);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Process32First
(
    HANDLE a_hSnapshot,
    LPPROCESSENTRY32 a_lppe,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnProcess32First != NULL)
    {
        t_fTemp = m_pfnProcess32First(a_hSnapshot, a_lppe);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Process32Next
(
    HANDLE a_hSnapshot,
    LPPROCESSENTRY32 a_lppe,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnProcess32Next != NULL)
    {
        t_fTemp = m_pfnProcess32Next(a_hSnapshot, a_lppe);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Module32First
(
    HANDLE a_hSnapshot,
    LPMODULEENTRY32 a_lpme,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnModule32First != NULL)
    {
        t_fTemp = m_pfnModule32First(a_hSnapshot, a_lpme);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Module32Next
(
    HANDLE a_hSnapshot,
    LPMODULEENTRY32 a_lpme,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnModule32Next != NULL)
    {
        t_fTemp = m_pfnModule32Next(a_hSnapshot, a_lpme);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::Heap32ListFirst
(
    HANDLE a_hSnapshot,
    LPHEAPLIST32 a_lphl,
    BOOL *a_pfRetval
)
{
    bool t_fExists = false;
    BOOL t_fTemp = FALSE;
    if(m_pfnHeap32ListFirst != NULL)
    {
        t_fTemp = m_pfnHeap32ListFirst(a_hSnapshot, a_lphl);

        t_fExists = true;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::GlobalMemoryStatusEx
(
    IN OUT LPMEMORYSTATUSEX a_lpBuffer,
    BOOL *a_pfRetval
)
{
    BOOL t_fExists = FALSE;
    BOOL t_fTemp = FALSE;
    if(m_pfnGlobalMemoryStatusEx != NULL && a_pfRetval != NULL)
    {
        t_fTemp = m_pfnGlobalMemoryStatusEx(a_lpBuffer);

        t_fExists = TRUE;

        if(a_pfRetval != NULL)
        {
            *a_pfRetval = t_fTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::GetSystemDefaultUILanguage
(
    LANGID *a_plidRetval
)
{
    BOOL t_fExists = FALSE;
    LANGID t_lidTemp;
    if(m_pfnGetSystemDefaultUILanguage != NULL && a_plidRetval != NULL)
    {
        t_lidTemp = m_pfnGetSystemDefaultUILanguage();

        t_fExists = TRUE;

        if(a_plidRetval != NULL)
        {
            *a_plidRetval = t_lidTemp;
        }
    }
    return t_fExists;
}


// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool CKernel32Api::GetVolumePathName(
        LPCTSTR lpszFileName,
        LPTSTR lpszVolumePathName,
        DWORD dwBufferLength,
        BOOL *pfRetval)
{
    bool fExists = false;
    BOOL fTemp = FALSE;
    if(m_pfnGetVolumePathName != NULL && 
        pfRetval != NULL)
    {
        fTemp = m_pfnGetVolumePathName(
            lpszFileName,
            lpszVolumePathName,
            dwBufferLength);

        fExists = true;

        if(pfRetval != NULL)
        {
            *pfRetval = fTemp;
        }
    }
    return fExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\iodesc.h ===
/////////////////////////////////////////////////////////////////////////

//

//  iodesc.h    

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//  
/////////////////////////////////////////////////////////////////////////

#ifndef __IODESC_H__
#define __IODESC_H__

// This structure is a munge of 16-bit and 32-bit values that basically combine both
// structures into one with common information (sigh...)

typedef struct _IOWBEM_DES{
	DWORD		IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
	DWORD		IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
	DWORDLONG	IOD_Alloc_Base;     // base of allocated port range
	DWORDLONG	IOD_Alloc_End;      // end of allocated port range
	DWORD		IOD_DesFlags;       // flags relating to allocated port range
	BYTE		IOD_Alloc_Alias;	// From 16-bit-land
	BYTE		IOD_Alloc_Decode;	// From 16-bit-land
} IOWBEM_DES;

typedef IOWBEM_DES*	PIOWBEM_DES;

class 
__declspec(uuid("571D3187-D45D-11d2-B35E-00104BC97924"))
CIODescriptor : public CResourceDescriptor
{
	
public:

	// Construction/Destruction
	CIODescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CIODescriptor( DWORD dwResourceId, IOWBEM_DES& ioDes, CConfigMgrDevice* pOwnerDevice );
	CIODescriptor( const CIODescriptor& io );
	~CIODescriptor();

	DWORDLONG GetBaseAddress( void );
	DWORDLONG GetEndAddress( void );
	DWORD GetFlags( void );
	BYTE GetAlias( void );
	BYTE GetDecode( void );

	// Override of base class functionality
	virtual void * GetResource();
	
};

_COM_SMARTPTR_TYPEDEF(CIODescriptor, __uuidof(CIODescriptor));

inline DWORDLONG CIODescriptor::GetBaseAddress( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_Alloc_Base : 0 );
}

inline DWORDLONG CIODescriptor::GetEndAddress( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_Alloc_End : 0 );
}

inline DWORD CIODescriptor::GetFlags( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_DesFlags : 0 );
}

inline BYTE CIODescriptor::GetAlias( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_Alloc_Alias : 0 );
}

inline BYTE CIODescriptor::GetDecode( void )
{
	return ( NULL != m_pbResourceDescriptor ? ((PIOWBEM_DES) m_pbResourceDescriptor)->IOD_Alloc_Decode : 0 );
}

// A collection of IO Port Descriptors
class CIOCollection : public TRefPtr<CIODescriptor>
{
public:

	// Construction/Destruction
	CIOCollection();
	~CIOCollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CIOCollection& operator = ( const CIOCollection& srcCollection );

};

inline const CIOCollection& CIOCollection::operator = ( const CIOCollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\kernel32api.h ===
//=================================================================

//

// Kernel32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_KERNEL32API_H_
#define	_KERNEL32API_H_


#include <tlhelp32.h>
//#include <resource.h>

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidKernel32Api;
extern const TCHAR g_tstrKernel32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef BOOL (WINAPI *PFN_KERNEL32_GET_DISK_FREE_SPACE_EX)
(
	LPCTSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
);

typedef HANDLE (WINAPI *PFN_KERNEL32_CREATE_TOOLHELP32_SNAPSHOT) 
(
    DWORD, 
    DWORD
);

typedef BOOL (WINAPI *PFN_KERNEL32_THREAD32_FIRST)  
(
    HANDLE, 
    LPTHREADENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_THREAD32_NEXT)  
(
    HANDLE, 
    LPTHREADENTRY32
);


typedef BOOL (WINAPI *PFN_KERNEL32_PROCESS32_FIRST)
(
    HANDLE, 
    LPPROCESSENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_PROCESS32_NEXT)
(
    HANDLE, 
    LPPROCESSENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_MODULE32_FIRST)  
(
    HANDLE, 
    LPMODULEENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_MODULE32_NEXT)  
(
    HANDLE, 
    LPMODULEENTRY32
);

typedef BOOL (WINAPI *PFN_KERNEL32_HEAP32_LIST_FIRST)    
(
    HANDLE, 
    LPHEAPLIST32
);

typedef BOOL (WINAPI *PFN_KERNEL32_GLOBAL_MEMORY_STATUS_EX) 
(
    IN OUT LPMEMORYSTATUSEX lpBuffer
);

typedef LANGID (WINAPI *PFN_KERNEL32_GET_SYSTEM_DEFAULT_U_I_LANGUAGE)
(
);

typedef BOOL (WINAPI *PFN_KERNEL32_GET_VOLUME_PATH_NAME)
(
    LPCTSTR lpszFileName,
    LPTSTR lpszVolumePathName,
    DWORD cchBufferLength
);



/******************************************************************************
 * Wrapper class for Kernel32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class 
__declspec(uuid("3CA401C6-D477-11d2-B35E-00104BC97924"))
CKernel32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    PFN_KERNEL32_GET_DISK_FREE_SPACE_EX m_pfnGetDiskFreeSpaceEx;
    PFN_KERNEL32_CREATE_TOOLHELP32_SNAPSHOT m_pfnCreateToolhelp32Snapshot;
	PFN_KERNEL32_THREAD32_FIRST  m_pfnThread32First;
    PFN_KERNEL32_THREAD32_NEXT  m_pfnThread32Next;
    PFN_KERNEL32_PROCESS32_FIRST m_pfnProcess32First;
    PFN_KERNEL32_PROCESS32_NEXT m_pfnProcess32Next;
    PFN_KERNEL32_MODULE32_FIRST  m_pfnModule32First;
    PFN_KERNEL32_MODULE32_NEXT  m_pfnModule32Next;
    PFN_KERNEL32_HEAP32_LIST_FIRST m_pfnHeap32ListFirst;
    PFN_KERNEL32_GLOBAL_MEMORY_STATUS_EX m_pfnGlobalMemoryStatusEx;
    PFN_KERNEL32_GET_SYSTEM_DEFAULT_U_I_LANGUAGE m_pfnGetSystemDefaultUILanguage;
    PFN_KERNEL32_GET_VOLUME_PATH_NAME m_pfnGetVolumePathName;

public:

    // Constructor and destructor:
    CKernel32Api(LPCTSTR a_tstrWrappedDllName);
    ~CKernel32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping kernel32 functions.
    // Add new functions here as required:
    bool GetDiskFreeSpaceEx
    (
        LPCTSTR lpDirectoryName,
        PULARGE_INTEGER a_lpFreeBytesAvailableToCaller,
        PULARGE_INTEGER a_lpTotalNumberOfBytes,
        PULARGE_INTEGER a_lpTotalNumberOfFreeBytes,
        BOOL *a_pfRetval 
    );

    bool CreateToolhelp32Snapshot
    (
        DWORD a_dwFlags, 
        DWORD a_th32ProcessID,
        HANDLE *a_hRetval 
    );

	bool Thread32First
    (
        HANDLE a_hSnapshot, 
        LPTHREADENTRY32 a_lpte,
        BOOL *a_pfRetval 
    );

    bool Thread32Next
    (
        HANDLE a_hSnapshot,  
        LPTHREADENTRY32 a_lpte,
        BOOL *a_pfRetval 
    );

    bool Process32First
    (
        HANDLE a_hSnapshot, 
        LPPROCESSENTRY32 a_lppe,
        BOOL *a_pfRetval 
    );

    bool Process32Next
    (
        HANDLE a_hSnapshot, 
        LPPROCESSENTRY32 a_lppe,
        BOOL *a_pfRetval 
    );

    bool Module32First
    (
        HANDLE a_hSnapshot, 
        LPMODULEENTRY32 a_lpme,
        BOOL *a_pfRetval 
    );

    bool Module32Next
    (
        HANDLE a_hSnapshot, 
        LPMODULEENTRY32 a_lpme,
        BOOL *a_pfRetval 
    );

    bool Heap32ListFirst
    (
        HANDLE a_hSnapshot, 
        LPHEAPLIST32 a_lphl,
        BOOL *a_pfRetval 
    );

    bool GlobalMemoryStatusEx 
    (
        IN OUT LPMEMORYSTATUSEX a_lpBuffer,
        BOOL *a_pfRetval 
    );

    bool GetSystemDefaultUILanguage
    (
        LANGID *a_plidRetval 
    );

    bool GetVolumePathName
    (
        LPCTSTR lpszFileName,
        LPTSTR lpszVolumePathName,
        DWORD cchBufferLength,
        BOOL *pfRetval 
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\lpvparams.h ===
//=================================================================

//

// LPVParams.h 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    2/18/99    a-kevhu        Created
//
//=================================================================

#ifndef _LPVPARAMS_H
#define _LPVPARAMS_H
// Parameter class for LoadPropertyValues
//=======================================
class CLPVParams
{
    public:
        CLPVParams() {}

        CLPVParams(CInstance* pInstance, CConfigMgrDevice* pDevice, DWORD dwReqProps);
        ~CLPVParams() {}

        CInstance* m_pInstance;
        CConfigMgrDevice* m_pDevice;
        DWORD m_dwReqProps;
};

inline CLPVParams::CLPVParams(CInstance* pInstance, CConfigMgrDevice* pDevice, DWORD dwReqProps)
:m_pInstance(pInstance), m_pDevice(pDevice), m_dwReqProps(dwReqProps)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\mprapi.h ===
//=================================================================

//

// MprApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_MprApi_H_
#define	_MprApi_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidMprApi;
extern const TCHAR g_tstrMpr[];

/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

#ifdef UNICODE
typedef DWORD (APIENTRY *PFN_Mpr_WNetEnumResource )
(
     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
);
#else
typedef DWORD (APIENTRY *PFN_Mpr_WNetEnumResource )
(
     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
);
#endif

#ifdef UNICODE
typedef DWORD (APIENTRY *PFN_Mpr_WNetOpenEnum )
(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEW lpNetResource,
     OUT LPHANDLE       lphEnum
);
#else
typedef DWORD (APIENTRY *PFN_Mpr_WNetOpenEnum )
(
     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEA lpNetResource,
     OUT LPHANDLE       lphEnum
);
#endif

typedef DWORD (APIENTRY *PFN_Mpr_WNetCloseEnum )
(
    IN HANDLE   hEnum
);

#ifdef UNICODE
typedef DWORD (APIENTRY *PFN_Mpr_WNetGetUser )
(
     IN LPCWSTR  lpName,
     OUT LPWSTR   lpUserName,
     IN OUT LPDWORD   lpnLength
    );
#else
typedef DWORD (APIENTRY *PFN_Mpr_WNetGetUser )
(
     IN LPCSTR  lpName,
     OUT LPSTR   lpUserName,
     IN OUT LPDWORD   lpnLength
);
#endif

#ifdef UNICODE
typedef DWORD (APIENTRY *PFN_Mpr_WNetGetConnection )
(
     IN LPCWSTR lpLocalName,
     OUT LPWSTR  lpRemoteName,
     IN OUT LPDWORD  lpnLength
    );
#else
typedef DWORD (APIENTRY *PFN_Mpr_WNetGetConnection )
(
     IN LPCSTR lpLocalName,
     OUT LPSTR  lpRemoteName,
     IN OUT LPDWORD  lpnLength
 );
#endif

/******************************************************************************
 * Wrapper class for Tapi load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CMprApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Tapi functions.
    // Add new functions here as required.

	PFN_Mpr_WNetEnumResource m_pfnWNetEnumResource ;
	PFN_Mpr_WNetOpenEnum m_pfnWNetOpenEnum ;
	PFN_Mpr_WNetCloseEnum m_pfnWNetCloseEnum ;
	PFN_Mpr_WNetGetUser m_pfnWNetGetUser ;
	PFN_Mpr_WNetGetConnection m_pfnWNetGetConnection ;

public:

    // Constructor and destructor:
    CMprApi(LPCTSTR a_tstrWrappedDllName);
    ~CMprApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Tapi functions.
    // Add new functions here as required:

#ifdef UNICODE
	DWORD WNetEnumResource (

		 IN HANDLE  hEnum,
		 IN OUT LPDWORD lpcCount,
		 OUT LPVOID  lpBuffer,
		 IN OUT LPDWORD lpBufferSize
	) ;
#else
	DWORD WNetEnumResource (

		 IN HANDLE  hEnum,
		 IN OUT LPDWORD lpcCount,
		 OUT LPVOID  lpBuffer,
		 IN OUT LPDWORD lpBufferSize
	) ;
#endif

#ifdef UNICODE
	DWORD WNetOpenEnum (

		 IN DWORD          dwScope,
		 IN DWORD          dwType,
		 IN DWORD          dwUsage,
		 IN LPNETRESOURCEW lpNetResource,
		 OUT LPHANDLE       lphEnum
	) ;
#else
	DWORD WNetOpenEnum (

		 IN DWORD          dwScope,
		 IN DWORD          dwType,
		 IN DWORD          dwUsage,
		 IN LPNETRESOURCEA lpNetResource,
		 OUT LPHANDLE       lphEnum
	) ;
#endif

#ifdef UNICODE
	DWORD WNetGetUser (

		 IN LPCWSTR  lpName,
		 OUT LPWSTR   lpUserName,
		 IN OUT LPDWORD   lpnLength
	) ;
#else
	DWORD WNetGetUser (

		 IN LPCSTR  lpName,
		 OUT LPSTR   lpUserName,
		 IN OUT LPDWORD   lpnLength
	) ;
#endif

#ifdef UNICODE
	DWORD WNetGetConnection (

		 IN LPCWSTR lpLocalName,
		 OUT LPWSTR  lpRemoteName,
		 IN OUT LPDWORD  lpnLength
	) ;
#else
	DWORD WNetGetConnection (

		 IN LPCSTR lpLocalName,
		 OUT LPSTR  lpRemoteName,
		 IN OUT LPDWORD  lpnLength
	) ;
#endif

	DWORD WNetCloseEnum (

		IN HANDLE   hEnum
	) ;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\msacm32api.h ===
//=================================================================

//

// MsAcm32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_MsAcm32Api_H_
#define	_MsAcm32Api_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidMsAcm32Api;
extern const TCHAR g_tstrMsAcm32[];

/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

#ifdef UNICODE
typedef MMRESULT  (ACMAPI *PFN_MsAcm32_acmDriverDetails )
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSW     padd,
    DWORD                   fdwDetails
);
#else
typedef MMRESULT  (ACMAPI *PFN_MsAcm32_acmDriverDetails )
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSA     padd,
    DWORD                   fdwDetails
);
#endif

typedef MMRESULT  (ACMAPI *PFN_MsAcm32_acmDriverEnum )
(
    ACMDRIVERENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
);

/******************************************************************************
 * Wrapper class for Tapi load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CMsAcm32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to Tapi functions.
    // Add new functions here as required.

	PFN_MsAcm32_acmDriverDetails m_pfnacmDriverDetails ;
	PFN_MsAcm32_acmDriverEnum m_pfnacmDriverEnum ;

public:

    // Constructor and destructor:
    CMsAcm32Api(LPCTSTR a_tstrWrappedDllName);
    ~CMsAcm32Api();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping Tapi functions.
    // Add new functions here as required:

#ifdef UNICODE
	MMRESULT MsAcm32acmDriverDetails 
	(
		HACMDRIVERID            hadid,
		LPACMDRIVERDETAILSW     padd,
		DWORD                   fdwDetails
	);
#else
	MMRESULT MsAcm32acmDriverDetails
	(
		HACMDRIVERID            hadid,
		LPACMDRIVERDETAILSA     padd,
		DWORD                   fdwDetails
	);
#endif

	MMRESULT  MsAcm32acmDriverEnum (

		ACMDRIVERENUMCB         fnCallback,
		DWORD_PTR               dwInstance,
		DWORD                   fdwEnum
	);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ndismisc.h ===
//=================================================================

//

// ndismisc.h -- 

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// 
//=================================================================

#ifndef _NDISMISC_
#define _NDISMISC_

#define _PNP_POWER_
#include <ntddip.h> 

// Taken from Ndisapi.h the __stdcall is required here
//
// Definitions for Layer
//
#define NDIS            0x01
#define TDI             0x02

//
// Definitions for Operation
//
#define BIND            0x01
#define UNBIND          0x02
#define RECONFIGURE     0x03
#define UNBIND_FORCE    0x04
#define UNLOAD          0x05
#define REMOVE_DEVICE   0x06    // This is a notification that a device is about to be removed.
//
// Return code from this api is to be treated as a BOOL. Link with ndispnp.lib for this.
//
#ifdef __cplusplus
extern "C" {
#endif

extern
UINT __stdcall
NdisHandlePnPEvent(
    IN  UINT            Layer,
    IN  UINT            Operation,
    IN  PUNICODE_STRING LowerComponent,
    IN  PUNICODE_STRING UpperComponent,
    IN  PUNICODE_STRING BindList,
    IN  PVOID           ReConfigBuffer      OPTIONAL,
    IN  UINT            ReConfigBufferSize  OPTIONAL
    );

#ifdef __cplusplus
}       // extern "C"
#endif


// the following is found in /nt/private/net/config/netcfg/nwlnkcfg/nwlnkipx.cpp and 
//							 /nt/private/net/routing/ipx/autonet/netnum.cpp
#define IPX_RECONFIG_VERSION        0x1

#define RECONFIG_AUTO_DETECT        1
#define RECONFIG_MANUAL             2
#define RECONFIG_PREFERENCE_1       3
#define RECONFIG_NETWORK_NUMBER_1   4
#define RECONFIG_PREFERENCE_2       5
#define RECONFIG_NETWORK_NUMBER_2   6
#define RECONFIG_PREFERENCE_3       7
#define RECONFIG_NETWORK_NUMBER_3   8
#define RECONFIG_PREFERENCE_4       9
#define RECONFIG_NETWORK_NUMBER_4   10

#define RECONFIG_PARAMETERS         10

//
// Main configuration structure.
//

typedef struct _RECONFIG {
   unsigned long  ulVersion;
   BOOLEAN        InternalNetworkNumber;
   BOOLEAN        AdapterParameters[RECONFIG_PARAMETERS];
} RECONFIG, *PRECONFIG;


#endif // _NDISMISC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\netapi32api.cpp ===
//=================================================================

//

// NetApi32API.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include <winerror.h>
#include "NetApi32Api.h"
#include "DllWrapperCreatorReg.h"
#include <CreateMutexAsProcess.h>



// {EDC5C632-D027-11d2-911F-0060081A46FD}
static const GUID g_guidNetApi32Api =
{0xedc5c632, 0xd027, 0x11d2, { 0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};


static const TCHAR g_tstrNetApi32[] = _T("NETAPI32.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CNetApi32Api, &g_guidNetApi32Api, g_tstrNetApi32> MyRegisteredNetApi32Wrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CNetApi32Api::CNetApi32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
   m_pfnNetGroupEnum(NULL),
   m_pfnNetGroupGetInfo(NULL),
   m_pfnNetGroupSetInfo(NULL),
   m_pfnNetLocalGroupGetInfo(NULL),
   m_pfnNetLocalGroupSetInfo(NULL),
   m_pfnNetGroupGetUsers(NULL),
   m_pfnNetLocalGroupGetMembers(NULL),
   m_pfnNetLocalGroupEnum(NULL),
   m_pfnNetShareEnum(NULL),
   m_pfnNetShareGetInfo(NULL),
   m_pfnNetShareAdd(NULL),
   m_pfnNetShareEnumSticky(NULL),
   m_pfnNetShareSetInfo(NULL),
   m_pfnNetShareDel(NULL),
   m_pfnNetShareDelSticky(NULL),
   m_pfnNetShareCheck(NULL),
   m_pfnNetUserEnum(NULL),
   m_pfnNetUserGetInfo(NULL),
   m_pfnNetUserSetInfo(NULL),
   m_pfnNetApiBufferFree(NULL),
   m_pfnNetQueryDisplayInformation(NULL),
   m_pfnNetServerSetInfo(NULL),
   m_pfnNetServerGetInfo(NULL),
   m_pfnNetGetDCName(NULL),
   m_pfnNetWkstaGetInfo(NULL),
   m_pfnNetGetAnyDCName(NULL),
   m_pfnNetServerEnum(NULL),
   m_pfnNetUserModalsGet(NULL),
   m_pfnNetScheduleJobAdd(NULL),
   m_pfnNetScheduleJobDel(NULL),
   m_pfnNetScheduleJobEnum(NULL),
   m_pfnNetScheduleJobGetInfo(NULL),
   m_pfnNetUseGetInfo(NULL),
// ******* BEGIN:  NT 4 and over only *******
   m_pfnNetEnumerateTrustedDomains(NULL),

#ifdef NTONLY
   m_pfnDsGetDcNameW(NULL),
#else
   m_pfnDsGetDcNameA(NULL),
#endif

// ******* END: NT4 and over only ***********
// ******* BEGIN:  NT 5 and over only *******
   m_pfnDsRoleGetPrimaryDomainInformation(NULL),
   m_pfnDsRoleFreeMemory(NULL),
   m_pfnNetRenameMachineInDomain(NULL),
   m_pfnNetJoinDomain(NULL),
   m_pfnNetUnjoinDomain(NULL)

// ******* END: NT5 and over only ***********
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CNetApi32Api::~CNetApi32Api()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CNetApi32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnNetGroupEnum = (PFN_NETAPI32_NET_GROUP_ENUM)
                                    GetProcAddress("NetGroupEnum");
        m_pfnNetGroupGetInfo = (PFN_NETAPI32_NET_GROUP_GET_INFO)
                                    GetProcAddress("NetGroupGetInfo");
		m_pfnNetGroupSetInfo = (PFN_NETAPI32_NET_GROUP_SET_INFO)
                                    GetProcAddress("NetGroupSetInfo");
        m_pfnNetLocalGroupGetInfo = (PFN_NETAPI32_NET_LOCAL_GROUP_GET_INFO)
                                    GetProcAddress("NetLocalGroupGetInfo");
		m_pfnNetLocalGroupSetInfo = (PFN_NETAPI32_NET_LOCAL_GROUP_SET_INFO)
                                    GetProcAddress("NetLocalGroupSetInfo");
        m_pfnNetGroupGetUsers = (PFN_NETAPI32_NET_GROUP_GET_USERS)
                                    GetProcAddress("NetGroupGetUsers");
        m_pfnNetLocalGroupGetMembers = (PFN_NETAPI32_NET_LOCAL_GROUP_GET_MEMBERS)
                                    GetProcAddress("NetLocalGroupGetMembers");
        m_pfnNetLocalGroupEnum = (PFN_NETAPI32_NET_LOCAL_GROUP_ENUM)
                                    GetProcAddress("NetLocalGroupEnum");
        m_pfnNetShareEnum = (PFN_NETAPI32_NET_SHARE_ENUM)
                                    GetProcAddress("NetShareEnum");
        m_pfnNetShareGetInfo = (PFN_NETAPI32_NET_SHARE_GET_INFO)
                                    GetProcAddress("NetShareGetInfo");
        m_pfnNetShareAdd = (PFN_NETAPI32_NET_SHARE_ADD)
                                    GetProcAddress("NetShareAdd");
        m_pfnNetShareEnumSticky = (PFN_NETAPI32_NET_SHARE_ENUM_STICKY)
                                    GetProcAddress("NetShareEnumSticky");
        m_pfnNetShareSetInfo = (PFN_NETAPI32_NET_SHARE_SET_INFO)
                                    GetProcAddress("NetShareSetInfo");
        m_pfnNetShareDel = (PFN_NETAPI32_NET_SHARE_DEL)
                                    GetProcAddress("NetShareDel");
        m_pfnNetShareDelSticky = (PFN_NETAPI32_NET_SHARE_DEL_STICKY)
                                    GetProcAddress("NetShareDelSticky");
        m_pfnNetShareCheck = (PFN_NETAPI32_NET_SHARE_CHECK)
                                    GetProcAddress("NetShareCheck");
        m_pfnNetUserEnum = (PFN_NETAPI32_NET_USER_ENUM)
                                    GetProcAddress("NetUserEnum");
        m_pfnNetUserGetInfo = (PFN_NETAPI32_NET_USER_GET_INFO)
                                    GetProcAddress("NetUserGetInfo");
		m_pfnNetUserSetInfo = (PFN_NETAPI32_NET_USER_SET_INFO)
                                    GetProcAddress("NetUserSetInfo");
        m_pfnNetGroupEnum = (PFN_NETAPI32_NET_GROUP_ENUM)
                                    GetProcAddress("NetGroupEnum");
        m_pfnNetApiBufferFree = (PFN_NETAPI32_NET_API_BUFFER_FREE)
                                    GetProcAddress("NetApiBufferFree");
        m_pfnNetQueryDisplayInformation = (PFN_NETAPI32_NET_QUERY_DISPLAY_INFORMATION)
                                    GetProcAddress("NetQueryDisplayInformation");
        m_pfnNetServerSetInfo = (PFN_NETAPI32_NET_SERVER_SET_INFO)
                                    GetProcAddress("NetServerSetInfo");
        m_pfnNetServerGetInfo = (PFN_NETAPI32_NET_SERVER_GET_INFO)
                                    GetProcAddress("NetServerGetInfo");
        m_pfnNetGetDCName = (PFN_NETAPI32_NET_GET_DC_NAME)
                                    GetProcAddress("NetGetDCName");
        m_pfnNetWkstaGetInfo = (PFN_NETAPI32_NET_WKSTA_GET_INFO)
                                    GetProcAddress("NetWkstaGetInfo");
        m_pfnNetGetAnyDCName = (PFN_NETAPI32_NET_GET_ANY_DC_NAME)
                                    GetProcAddress("NetGetAnyDCName");
        m_pfnNetServerEnum = (PFN_NETAPI32_NET_SERVER_ENUM)
                                    GetProcAddress("NetServerEnum");
        m_pfnNetUserModalsGet = (PFN_NETAPI32_NET_USER_MODALS_GET)
                                    GetProcAddress("NetUserModalsGet");
        m_pfnNetScheduleJobAdd = (PFN_NETAPI32_NET_SCHEDULE_JOB_ADD)
                                    GetProcAddress("NetScheduleJobAdd");
        m_pfnNetScheduleJobDel = (PFN_NETAPI32_NET_SCHEDULE_JOB_DEL)
                                    GetProcAddress("NetScheduleJobDel");
        m_pfnNetScheduleJobEnum = (PFN_NETAPI32_NET_SCHEDULE_JOB_ENUM)
                                    GetProcAddress("NetScheduleJobEnum");
        m_pfnNetScheduleJobGetInfo = (PFN_NETAPI32_NET_SCHEDULE_JOB_GET_INFO)
                                    GetProcAddress("NetScheduleJobGetInfo");
        m_pfnNetUseGetInfo = (PFN_NETAPI32_NET_USE_GET_INFO)
                                    GetProcAddress("NetUseGetInfo");

        // ******* BEGIN:  NT 4 and over only *******
        m_pfnNetEnumerateTrustedDomains = (PFN_NETAPI32_NET_ENUMERATE_TRUSTED_DOMAINS)
                                    GetProcAddress("NetEnumerateTrustedDomains");
#ifdef NTONLY
        m_pfnDsGetDcNameW = (PFN_NETAPI32_DS_GET_DC_NAME)
                                    GetProcAddress("DsGetDcNameW");
#else
		m_pfnDsGetDcNameA = (PFN_NETAPI32_DS_GET_DC_NAME)
                                    GetProcAddress("DsGetDcNameA");
#endif

        // ******* END: NT4 and over only ***********
        // ******* BEGIN:  NT 5 and over only *******
        m_pfnDsRoleGetPrimaryDomainInformation = (PFN_DS_ROLE_GET_PRIMARY_DOMAIN_INFORMATION)
                                    GetProcAddress("DsRoleGetPrimaryDomainInformation");
        m_pfnDsRoleFreeMemory = (PFN_DS_ROLE_FREE_MEMORY)
                                    GetProcAddress("DsRoleFreeMemory");
        m_pfnNetRenameMachineInDomain = (PFN_NET_RENAME_MACHINE_IN_DOMAIN)
                                    GetProcAddress("NetRenameMachineInDomain");
        m_pfnNetJoinDomain = (PFN_NET_JOIN_DOMAIN)
                                    GetProcAddress("NetJoinDomain");
        m_pfnNetUnjoinDomain = (PFN_NET_UNJOIN_DOMAIN)
                                    GetProcAddress("NetUnjoinDomain");
        // ******* END: NT5 and over only ***********



        // Note: Returns true as long as the core functions are there.  The
        // nt4 and nt5 and over functions are optionally present; users should
        // call the function GetDllVersion (inherrited from the base class)
        // to check if the function is expected to be present based on the
        // version of the dll. Or they can rely on the fact that the function
        // will return false if the pointer is invalid (see function definition
        // below).
        if(m_pfnNetGroupEnum == NULL ||
           m_pfnNetGroupGetInfo == NULL ||
		   m_pfnNetGroupSetInfo == NULL ||
           m_pfnNetLocalGroupGetInfo == NULL ||
           m_pfnNetLocalGroupSetInfo == NULL ||
           m_pfnNetGroupGetUsers == NULL ||
           m_pfnNetLocalGroupGetMembers == NULL ||
           m_pfnNetLocalGroupEnum == NULL ||
           m_pfnNetShareEnum == NULL ||
           m_pfnNetShareGetInfo == NULL ||
           m_pfnNetShareAdd == NULL ||
           m_pfnNetShareEnumSticky == NULL ||
           m_pfnNetShareSetInfo == NULL ||
           m_pfnNetShareDel == NULL ||
           m_pfnNetShareDelSticky == NULL ||
           m_pfnNetShareCheck == NULL ||
           m_pfnNetUserEnum == NULL ||
           m_pfnNetUserGetInfo == NULL ||
		   m_pfnNetUserSetInfo == NULL ||
           m_pfnNetApiBufferFree == NULL ||
           m_pfnNetQueryDisplayInformation == NULL ||
           m_pfnNetServerSetInfo == NULL ||
           m_pfnNetServerGetInfo == NULL ||
           m_pfnNetGetDCName == NULL ||
           m_pfnNetWkstaGetInfo == NULL ||
           m_pfnNetGetAnyDCName == NULL ||
           m_pfnNetServerEnum == NULL ||
           m_pfnNetUserModalsGet == NULL ||
           m_pfnNetScheduleJobAdd == NULL ||
           m_pfnNetScheduleJobDel == NULL ||
           m_pfnNetScheduleJobEnum == NULL ||
           m_pfnNetScheduleJobGetInfo == NULL ||
           m_pfnNetUseGetInfo == NULL)
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in NetApi32Api");
        }
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping NetApi32 api functions. Add new functions here
 * as required.
 ******************************************************************************/
NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGroupEnum
(
    LPCWSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    PDWORD_PTR  a_resume_handle
)
{
    return m_pfnNetGroupEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                             a_entriesread, a_totalentries, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGroupGetInfo
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetGroupGetInfo(a_servername, a_groupname, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGroupSetInfo
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE a_buf,
	LPDWORD parm_err
)
{
    return m_pfnNetGroupSetInfo(a_servername, a_groupname, a_level, a_buf, parm_err ) ;
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetLocalGroupGetInfo
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetLocalGroupGetInfo(a_servername, a_groupname,
                                     a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetLocalGroupSetInfo
(
	LPCWSTR a_servername,
	LPCWSTR a_groupname,
	DWORD a_level,
	LPBYTE a_buf,
	LPDWORD a_parm_err
)
{
    return m_pfnNetLocalGroupSetInfo(	a_servername,
										a_groupname,
										a_level,
										a_buf,
										a_parm_err ) ;
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGroupGetUsers
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    PDWORD_PTR a_ResumeHandle
)
{
    return m_pfnNetGroupGetUsers(a_servername, a_groupname, a_level, a_bufptr,
                                 a_prefmaxlen, a_entriesread, a_totalentries,
                                 a_ResumeHandle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetLocalGroupGetMembers
(
    LPCWSTR a_servername,
    LPCWSTR a_groupname,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    PDWORD_PTR a_ResumeHandle
)
{
    return m_pfnNetLocalGroupGetMembers(a_servername, a_groupname, a_level,
                                        a_bufptr, a_prefmaxlen, a_entriesread,
                                        a_totalentries, a_ResumeHandle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetLocalGroupEnum
(
    LPCWSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    PDWORD_PTR a_resumehandle
)
{
    return m_pfnNetLocalGroupEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                                  a_entriesread, a_totalentries,
                                  a_resumehandle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareEnum
(
    LPTSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    LPDWORD a_resume_handle
)
{
    return m_pfnNetShareEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                             a_entriesread, a_totalentries, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareGetInfo
(
    LPTSTR a_servername,
    LPTSTR a_netname,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetShareGetInfo(a_servername, a_netname, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareAdd
(
	LPTSTR  a_servername,
	DWORD   a_level,
	LPBYTE  a_buf,
	LPDWORD a_parm_err
)
{
    return m_pfnNetShareAdd(a_servername, a_level, a_buf , a_parm_err);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareEnumSticky
(
	LPTSTR      a_servername,
	DWORD       a_level,
	LPBYTE      *a_bufptr,
	DWORD       a_prefmaxlen,
	LPDWORD     a_entriesread,
	LPDWORD     a_totalentries,
	LPDWORD     a_resume_handle
)
{
    return m_pfnNetShareEnumSticky(a_servername, a_level, a_bufptr,
                                   a_prefmaxlen, a_entriesread,
                                   a_totalentries, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareSetInfo
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_level,
	LPBYTE  a_buf,
	LPDWORD a_parm_err
)
{
    return m_pfnNetShareSetInfo(a_servername, a_netname,
                                a_level, a_buf, a_parm_err);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareDel
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_reserved
)
{
    return m_pfnNetShareDel(a_servername, a_netname, a_reserved);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareDelSticky
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_reserved
)
{
    return m_pfnNetShareDelSticky(a_servername, a_netname, a_reserved);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetShareCheck
(
	LPTSTR  a_servername,
	LPTSTR  a_device,
	LPDWORD a_type
)
{
    return m_pfnNetShareCheck(a_servername, a_device, a_type);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUserEnum
(
    LPCWSTR a_servername,
    DWORD a_level,
    DWORD a_filter,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    LPDWORD a_resume_handle
)
{
    return m_pfnNetUserEnum(a_servername, a_level, a_filter,
                            a_bufptr, a_prefmaxlen, a_entriesread,
                            a_totalentries, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUserGetInfo
(
    LPCWSTR a_servername,
    LPCWSTR a_username,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetUserGetInfo(a_servername, a_username, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUserSetInfo(

  LPCWSTR a_servername,
  LPCWSTR a_username,
  DWORD a_level,
  LPBYTE a_buf,
  LPDWORD a_parm_err
)
{
	return m_pfnNetUserSetInfo( a_servername, a_username, a_level, a_buf, a_parm_err) ;
}


NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetApiBufferFree
(
    void *a_bufptr
)
{
    return m_pfnNetApiBufferFree(a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetQueryDisplayInformation
(
    LPWSTR a_ServerName,
    DWORD a_Level,
    DWORD a_Index,
    DWORD a_EntriesRequested,
    DWORD a_PreferredMaximumLength,
    LPDWORD a_ReturnedEntryCount,
    PVOID *a_SortedBuffer
)
{
    return m_pfnNetQueryDisplayInformation(a_ServerName, a_Level, a_Index,
                                           a_EntriesRequested,
                                           a_PreferredMaximumLength,
                                           a_ReturnedEntryCount,
                                           a_SortedBuffer);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetServerSetInfo
(
    LPTSTR  a_servername,
    DWORD a_level,
    LPBYTE  a_buf,
    LPDWORD a_ParmError
)
{
    return m_pfnNetServerSetInfo(a_servername, a_level, a_buf, a_ParmError);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetServerGetInfo
(
    LPTSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetServerGetInfo(a_servername, a_level, a_bufptr);
}


NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGetDCName
(	LPCWSTR a_servername,
    LPCWSTR a_domainname,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetGetDCName(a_servername, a_domainname, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetWkstaGetInfo
(
    LPWSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetWkstaGetInfo(a_servername, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetGetAnyDCName
(
    LPWSTR a_servername,
    LPWSTR a_domainname,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetGetAnyDCName(a_servername, a_domainname, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetServerEnum
(
    LPTSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr,
    DWORD a_prefmaxlen,
    LPDWORD a_entriesread,
    LPDWORD a_totalentries,
    DWORD a_servertype,
    LPTSTR a_domain,
    LPDWORD a_resume_handle
)
{
    return m_pfnNetServerEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                              a_entriesread, a_totalentries, a_servertype,
                              a_domain, a_resume_handle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUserModalsGet
(
    LPWSTR a_servername,
    DWORD a_level,
    LPBYTE *a_bufptr
)
{
    return m_pfnNetUserModalsGet(a_servername, a_level, a_bufptr);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetScheduleJobAdd
(
    LPCWSTR a_Servername,
    LPBYTE  a_Buffer,
    LPDWORD a_JobId
)
{
    return m_pfnNetScheduleJobAdd(a_Servername, a_Buffer, a_JobId);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetScheduleJobDel
(
    LPCWSTR a_Servername,
    DWORD   a_MinJobId,
    DWORD   a_MaxJobId
)
{
    return m_pfnNetScheduleJobDel(a_Servername, a_MinJobId , a_MaxJobId);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetScheduleJobEnum
(
    LPCWSTR  a_Servername,
    LPBYTE  *a_PointerToBuffer,
    DWORD    a_PrefferedMaximumLength,
    LPDWORD  a_EntriesRead,
    LPDWORD  a_TotalEntries,
    LPDWORD  a_ResumeHandle
)
{
    return m_pfnNetScheduleJobEnum(a_Servername, a_PointerToBuffer,
                                   a_PrefferedMaximumLength, a_EntriesRead,
                                   a_TotalEntries, a_ResumeHandle);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetScheduleJobGetInfo
(
    LPCWSTR  a_Servername,
    DWORD    a_JobId,
    LPBYTE  *a_PointerToBuffer
)
{
    return m_pfnNetScheduleJobGetInfo(a_Servername, a_JobId ,
                                      a_PointerToBuffer);
}

NET_API_STATUS NET_API_FUNCTION CNetApi32Api::NetUseGetInfo
(
    LPCWSTR  a_UncServerName,
    LPCWSTR  a_UseName,
    DWORD    a_Level,
    LPBYTE  *a_BufPtr
)
{
    return m_pfnNetUseGetInfo(a_UncServerName, a_UseName, a_Level, a_BufPtr);
}


// ******* BEGIN:  NT 4 and over only *******

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::NetEnumerateTrustedDomains
(
    LPCWSTR a_servername,
	LPWSTR *a_domainNames,
    NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnNetEnumerateTrustedDomains != NULL)
    {
        NET_API_STATUS t_nasTemp = m_pfnNetEnumerateTrustedDomains(a_servername,
                                                                   a_domainNames);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::DsGetDCName
(
    LPCTSTR a_ComputerName,
	LPCTSTR a_DomainName,
	GUID *a_DomainGuid,
	LPCTSTR a_SiteName,
	ULONG a_Flags,
	PDOMAIN_CONTROLLER_INFO *a_DomainControllerInfo,
    NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
	PVOID pfn = NULL ;

#ifdef NTONLY
	pfn = m_pfnDsGetDcNameW ;
#else
	pfn = m_pfnDsGetDcNameA ;
#endif

    if( pfn != NULL )
    {
#ifdef NTONLY
        NET_API_STATUS t_nasTemp = m_pfnDsGetDcNameW(a_ComputerName,
                            a_DomainName, a_DomainGuid, a_SiteName, a_Flags,
                            a_DomainControllerInfo);
#else
        NET_API_STATUS t_nasTemp = m_pfnDsGetDcNameA(a_ComputerName,
                            a_DomainName, a_DomainGuid, a_SiteName, a_Flags,
                            a_DomainControllerInfo);
#endif
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;
}
// ******* END: NT4 and over only ***********



// ******* BEGIN:  NT 5 and over only *******


// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::DSRoleGetPrimaryDomainInformation
(
    LPCWSTR a_servername,
    DSROLE_PRIMARY_DOMAIN_INFO_LEVEL a_level,
    LPBYTE *a_bufptr,
    NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnDsRoleGetPrimaryDomainInformation != NULL)
    {
        NET_API_STATUS t_nasTemp = m_pfnDsRoleGetPrimaryDomainInformation(
                                                  a_servername, a_level,
                                                  a_bufptr);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::DSRoleFreeMemory
(
    LPBYTE a_bufptr,
    NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnDsRoleFreeMemory != NULL)
    {
        NET_API_STATUS t_nasTemp = m_pfnDsRoleFreeMemory(a_bufptr);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::NetRenameMachineInDomain
(
  LPCWSTR a_lpServer,
  LPCWSTR a_lpNewMachineName,
  LPCWSTR a_lpAccount,
  LPCWSTR a_lpPassword,
  DWORD a_fRenameOptions,
  NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnNetRenameMachineInDomain != NULL)
    {
        CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
        NET_API_STATUS t_nasTemp = m_pfnNetRenameMachineInDomain(a_lpServer,
                                                                    a_lpNewMachineName,
                                                                    a_lpAccount,
                                                                    a_lpPassword,
                                                                    a_fRenameOptions                                                                 
                                                                    );
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }
    return t_fExists;

}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::NetJoinDomain
(
	LPCWSTR lpServer,
	LPCWSTR lpDomain,
	LPCWSTR lpAccountOU,
	LPCWSTR lpAccount,
	LPCWSTR lpPassword,
	DWORD fJoinOptions,
	NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnNetJoinDomain != NULL)
    {
        CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
        NET_API_STATUS t_nasTemp = m_pfnNetJoinDomain(lpServer,
														lpDomain,
														lpAccountOU,
														lpAccount,
														lpPassword,
														fJoinOptions);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }

    return t_fExists;
}

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.
bool NET_API_FUNCTION CNetApi32Api::NetUnjoinDomain
(
	LPCWSTR lpServer,
	LPCWSTR lpAccount,
	LPCWSTR lpPassword,
	DWORD   fUnjoinOptions,
	NET_API_STATUS *a_pnasRetval
)
{
    bool t_fExists = false;
    if(m_pfnNetUnjoinDomain != NULL)
    {
        CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
        NET_API_STATUS t_nasTemp = m_pfnNetUnjoinDomain(lpServer,
														lpAccount,
														lpPassword,
														fUnjoinOptions);
        t_fExists = true;

        if(a_pnasRetval != NULL)
        {
            *a_pnasRetval = t_nasTemp;
        }
    }

    return t_fExists;
}
// ******* END: NT5 and over only ***********
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\msacm32api.cpp ===
//=================================================================

//

// MsAcm32API.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cominit.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

#include "DllWrapperBase.h"
#include "MsAcm32Api.h"
#include "DllWrapperCreatorReg.h"

// {7D65D31E-0FB5-11d3-910C-00105AA630BE}
static const GUID g_guidMsAcm32Api =
{ 0x7d65d31e, 0xfb5, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrMsAcm32 [] = _T("MsAcm32.Dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CMsAcm32Api, &g_guidMsAcm32Api, g_tstrMsAcm32> MyRegisteredMsAcm32Wrapper;

/******************************************************************************
 * Constructor
 *****************************************************************************/
CMsAcm32Api::CMsAcm32Api(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnacmDriverDetails (NULL),
	m_pfnacmDriverEnum (NULL)
{
}

/******************************************************************************
 * Destructor
 *****************************************************************************/
CMsAcm32Api::~CMsAcm32Api()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CMsAcm32Api::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef UNICODE
		m_pfnacmDriverDetails = ( PFN_MsAcm32_acmDriverDetails ) GetProcAddress ( "acmDriverDetailsW" ) ;
#else
		m_pfnacmDriverDetails = ( PFN_MsAcm32_acmDriverDetails ) GetProcAddress ( "acmDriverDetailsA" ) ;

#endif
		m_pfnacmDriverEnum = ( PFN_MsAcm32_acmDriverEnum ) GetProcAddress ( "acmDriverEnum" ) ;
    }

    // We require these function for all versions of this dll.

	if ( m_pfnacmDriverDetails == NULL ||
		 m_pfnacmDriverEnum == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in msacm32api");
	}

    return fRet;
}

/******************************************************************************
 * Member functions wrapping Tapi api functions. Add new functions here
 * as required.
 *****************************************************************************/

#ifdef UNICODE
MMRESULT CMsAcm32Api :: MsAcm32acmDriverDetails (

	HACMDRIVERID            hadid,
	LPACMDRIVERDETAILSW     padd,
	DWORD                   fdwDetails
)
#else
MMRESULT CMsAcm32Api :: MsAcm32acmDriverDetails (

	HACMDRIVERID            hadid,
	LPACMDRIVERDETAILSA     padd,
	DWORD                   fdwDetails
)
#endif
{
	return m_pfnacmDriverDetails (

		hadid,
		padd,
		fdwDetails
	) ;
}

MMRESULT CMsAcm32Api :: MsAcm32acmDriverEnum (

	ACMDRIVERENUMCB         fnCallback,
	DWORD_PTR               dwInstance,
	DWORD                   fdwEnum
)
{
	return m_pfnacmDriverEnum (

		fnCallback,
		dwInstance,
		fdwEnum
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\mprapi.cpp ===
//=================================================================

//

// MprAPI.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <cominit.h>

#include <lmuse.h>
#include "DllWrapperBase.h"
#include "MprApi.h"
#include "DllWrapperCreatorReg.h"

// {EA6034F1-0FAD-11d3-910C-00105AA630BE}
static const GUID g_guidMprApi =
{ 0xea6034f1, 0xfad, 0x11d3, { 0x91, 0xc, 0x0, 0x10, 0x5a, 0xa6, 0x30, 0xbe } };

static const TCHAR g_tstrMpr [] = _T("Mpr.Dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CMprApi, &g_guidMprApi, g_tstrMpr> MyRegisteredMprWrapper;

/******************************************************************************
 * Constructor
 *****************************************************************************/
CMprApi::CMprApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnWNetEnumResource (NULL),
	m_pfnWNetOpenEnum(NULL),
	m_pfnWNetCloseEnum(NULL),
	m_pfnWNetGetUser(NULL),
	m_pfnWNetGetConnection(NULL)
{
}

/******************************************************************************
 * Destructor
 *****************************************************************************/
CMprApi::~CMprApi()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CMprApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
#ifdef UNICODE
		m_pfnWNetGetUser = ( PFN_Mpr_WNetGetUser ) GetProcAddress ( "WNetGetUserW" ) ;
		m_pfnWNetEnumResource = ( PFN_Mpr_WNetEnumResource ) GetProcAddress ( "WNetEnumResourceW" ) ;
		m_pfnWNetOpenEnum = ( PFN_Mpr_WNetOpenEnum ) GetProcAddress ( "WNetOpenEnumW" ) ;
		m_pfnWNetGetConnection = ( PFN_Mpr_WNetGetConnection ) GetProcAddress ( "WNetGetConnectionW" ) ;
#else
		m_pfnWNetGetUser = ( PFN_Mpr_WNetGetUser ) GetProcAddress ( "WNetGetUserA" ) ;
		m_pfnWNetEnumResource = ( PFN_Mpr_WNetEnumResource ) GetProcAddress ( "WNetEnumResourceA" ) ;
		m_pfnWNetOpenEnum = ( PFN_Mpr_WNetOpenEnum ) GetProcAddress ( "WNetOpenEnumA" ) ;
		m_pfnWNetGetConnection = ( PFN_Mpr_WNetGetConnection ) GetProcAddress ( "WNetGetConnectionA" ) ;
#endif
		m_pfnWNetCloseEnum = ( PFN_Mpr_WNetCloseEnum ) GetProcAddress ( "WNetCloseEnum" ) ;
    }

    // We require these function for all versions of this dll.

	if ( m_pfnWNetEnumResource == NULL ||
		 m_pfnWNetOpenEnum == NULL ||
		 m_pfnWNetCloseEnum == NULL ||
		 m_pfnWNetGetUser == NULL )
	{
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in MPRAPI");
	}

    return fRet;
}

/******************************************************************************
 * Member functions wrapping Tapi api functions. Add new functions here
 * as required.
 *****************************************************************************/

#ifdef UNICODE
DWORD CMprApi :: WNetEnumResource (

     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
)
#else
DWORD CMprApi :: WNetEnumResource (

     IN HANDLE  hEnum,
     IN OUT LPDWORD lpcCount,
     OUT LPVOID  lpBuffer,
     IN OUT LPDWORD lpBufferSize
)
#endif
{
	return m_pfnWNetEnumResource (

		hEnum,
		lpcCount,
		lpBuffer,
		lpBufferSize
	) ;
}

#ifdef UNICODE
DWORD CMprApi :: WNetOpenEnum (

     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEW lpNetResource,
     OUT LPHANDLE       lphEnum
)
#else
DWORD CMprApi :: WNetOpenEnum (

     IN DWORD          dwScope,
     IN DWORD          dwType,
     IN DWORD          dwUsage,
     IN LPNETRESOURCEA lpNetResource,
     OUT LPHANDLE       lphEnum
)
#endif
{
	return m_pfnWNetOpenEnum (

		dwScope,
		dwType,
		dwUsage,
		lpNetResource,
		lphEnum
	) ;
}

#ifdef UNICODE
DWORD CMprApi :: WNetGetUser (

     IN LPCWSTR  lpName,
     OUT LPWSTR   lpUserName,
     IN OUT LPDWORD   lpnLength
)
#else
DWORD CMprApi :: WNetGetUser (

     IN LPCSTR  lpName,
     OUT LPSTR   lpUserName,
     IN OUT LPDWORD   lpnLength
)
#endif
{
	return m_pfnWNetGetUser (

		lpName,
		lpUserName,
		lpnLength
	) ;
}

DWORD CMprApi :: WNetCloseEnum (

	IN HANDLE   hEnum
)
{
	return m_pfnWNetCloseEnum (

		hEnum
	) ;
}

#ifdef UNICODE
DWORD CMprApi :: WNetGetConnection (

	 IN LPCWSTR lpLocalName,
	 OUT LPWSTR  lpRemoteName,
	 IN OUT LPDWORD  lpnLength
)
#else
DWORD CMprApi :: WNetGetConnection (

	 IN LPCSTR lpLocalName,
	 OUT LPSTR  lpRemoteName,
	 IN OUT LPDWORD  lpnLength
)
#endif
{
	return m_pfnWNetGetConnection (

		lpLocalName,
		lpRemoteName,
		lpnLength
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\nt4svctoresmap.h ===
//=================================================================

//

// NT4SvcToResMap.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __NT4SVCTORESMAP_H__
#define __NT4SVCTORESMAP_H__

#ifdef NTONLY

#include <map>
#include "chwres.h"

typedef	std::map<CHString,CHPtrArray*>				NT4SvcToResourceMap;
typedef	std::map<CHString,CHPtrArray*>::iterator	NT4SvcToResourceMapIter;

class CNT4ServiceToResourceMap
{
	public:
		CNT4ServiceToResourceMap();
		~CNT4ServiceToResourceMap();

		DWORD NumServiceResources( LPCTSTR pszServiceName );
		LPRESOURCE_DESCRIPTOR GetServiceResource( LPCTSTR pszServiceName, DWORD dwIndex );

	private:

		BOOL InitializeMap( void );
		BOOL WalkResourceNodes( LPRESOURCE_DESCRIPTOR pResourceDescriptor );
		void Clear( void );

		NT4SvcToResourceMap		m_map;
	    CHWResource				m_HardwareResource;

};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ntdevtosvcsearch.h ===
//=================================================================

//

// NtDevToSvcSearch.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __NTDEVTOSVCSEARCH_H__
#define __NTDEVTOSVCSEARCH_H__

#define DEVTOSVC_BASEKEYPATH		_T("HARDWARE\\RESOURCEMAP")
#define	RAWVALUENAME_FMAT			_T("\\Device\\%s.Raw")
#define	TRANSLATEDVALUENAME_FMAT	_T("\\Device\\%s.Translated")

class CNTDeviceToServiceSearch : public CRegistrySearch
{

public:

	//Construction/Destruction
	CNTDeviceToServiceSearch();
	~CNTDeviceToServiceSearch();

	// Single method for finding an NT service name based off of a device name
	BOOL	Find( LPCTSTR pszDeviceName, CHString& strServiceName );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\netapi32api.h ===
//=================================================================

//

// NetApi32Api.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_NETAPI32API_H_
#define	_NETAPI32API_H_



#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmerr.h>
#include <ntsecapi.h>
#include <stack>
#include <comdef.h>
#include <dsrole.h> 
#include <dsgetdc.h>

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidNetApi32Api;
extern const TCHAR g_tstrNetApi32[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GROUP_ENUM)
(
    LPCWSTR servername, 
    DWORD level, 
    LPBYTE *bufptr,
    DWORD prefmaxlen, 
    LPDWORD entriesread,
    LPDWORD totalentries, 
    PDWORD_PTR  resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GROUP_GET_INFO)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GROUP_SET_INFO)
(
	LPCWSTR servername,
	LPCWSTR groupname,
	DWORD level,
	LPBYTE buf,
	LPDWORD parm_err
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_LOCAL_GROUP_GET_INFO)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_LOCAL_GROUP_SET_INFO)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE buf,
	LPDWORD a_parm_err
);
typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GROUP_GET_USERS)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    PDWORD_PTR ResumeHandle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_LOCAL_GROUP_GET_MEMBERS)
(
    LPCWSTR servername,
    LPCWSTR groupname,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    PDWORD_PTR ResumeHandle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_LOCAL_GROUP_ENUM)
(
    LPCWSTR servername,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    PDWORD_PTR resumehandle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_ENUM)
(
    LPTSTR servername,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    LPDWORD resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_GET_INFO)
(
    LPTSTR servername,
    LPTSTR netname,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_ADD) 
(
	IN  LPTSTR  servername,
	IN  DWORD   level,
	IN  LPBYTE  buf,
	OUT LPDWORD parm_err
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_ENUM_STICKY) 
(
	IN  LPTSTR      servername,
	IN  DWORD       level,
	OUT LPBYTE      *bufptr,
	IN  DWORD       prefmaxlen,
	OUT LPDWORD     entriesread,
	OUT LPDWORD     totalentries,
	IN OUT LPDWORD  resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_SET_INFO) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   level,
	IN  LPBYTE  buf,
	OUT LPDWORD parm_err
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_DEL) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_DEL_STICKY) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SHARE_CHECK) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  device,
	OUT LPDWORD type
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USER_ENUM)
(
    LPCWSTR servername,
    DWORD level,
    DWORD filter,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    LPDWORD resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USER_GET_INFO)
(
    LPCWSTR servername,
    LPCWSTR username,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USER_SET_INFO)
(
	LPCWSTR a_servername, 
	LPCWSTR a_username,   
	DWORD a_level,       
	LPBYTE a_buf,        
	LPDWORD a_parm_err
);
typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_API_BUFFER_FREE)
(
    void *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_QUERY_DISPLAY_INFORMATION)
(	
    LPWSTR ServerName,
    DWORD Level,
    DWORD Index,
    DWORD EntriesRequested,
    DWORD PreferredMaximumLength,
    LPDWORD ReturnedEntryCount,
    PVOID *SortedBuffer
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SERVER_SET_INFO)
(
    LPTSTR  servername,
    DWORD level,
    LPBYTE  buf,
    LPDWORD ParmError
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SERVER_GET_INFO)
(
    LPTSTR servername,
    DWORD level,
    LPBYTE *bufptr
);


typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GET_DC_NAME)
(	LPCWSTR servername,
    LPCWSTR domainname,
    LPBYTE *bufptr 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_WKSTA_GET_INFO)
(	
    LPWSTR servername,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_GET_ANY_DC_NAME)
(	
    LPWSTR servername,
    LPWSTR domainname,
    LPBYTE *bufptr 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SERVER_ENUM)
(	
    LPTSTR servername,
    DWORD level,
    LPBYTE *bufptr,
    DWORD prefmaxlen,
    LPDWORD entriesread,
    LPDWORD totalentries,
    DWORD servertype,
    LPTSTR domain,
    LPDWORD resume_handle 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USER_MODALS_GET)
(	
    LPWSTR servername,
    DWORD level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SCHEDULE_JOB_ADD) 
(
    IN      LPCWSTR         Servername          OPTIONAL,
    IN      LPBYTE          Buffer,
    OUT     LPDWORD         JobId
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SCHEDULE_JOB_DEL) 
(
    IN      LPCWSTR         Servername          OPTIONAL,
    IN      DWORD           MinJobId,
    IN      DWORD           MaxJobId
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SCHEDULE_JOB_ENUM) 
(
    IN      LPCWSTR         Servername          OPTIONAL,
    OUT     LPBYTE          *PointerToBuffer,
    IN      DWORD           PrefferedMaximumLength,
    OUT     LPDWORD         EntriesRead,
    OUT     LPDWORD         TotalEntries,
    IN OUT  LPDWORD         ResumeHandle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_SCHEDULE_JOB_GET_INFO) 
(
    IN      LPCWSTR         Servername          OPTIONAL,
    IN      DWORD           JobId,
    OUT     LPBYTE          *PointerToBuffer
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_USE_GET_INFO) 
(
    IN      LPCWSTR         UncServerName       OPTIONAL,
    IN      LPCWSTR         UseName,
    IN      DWORD           Level,
    OUT     LPBYTE          *BufPtr
);

// ******* BEGIN:  NT 4 and over only *******
typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_NET_ENUMERATE_TRUSTED_DOMAINS)
(	
    LPCWSTR servername,
	LPWSTR *domainNames 
) ;

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NETAPI32_DS_GET_DC_NAME)
(	
    LPCTSTR ComputerName, 
	LPCTSTR DomainName,
	GUID *DomainGuid, 
	LPCTSTR SiteName, 
	ULONG Flags,
	PDOMAIN_CONTROLLER_INFO *DomainControllerInfo 
);
// ******* END: NT4 and over only ***********



// ******* BEGIN:  NT 5 and over only *******
typedef NET_API_STATUS (NET_API_FUNCTION *PFN_DS_ROLE_GET_PRIMARY_DOMAIN_INFORMATION)
(
    LPCWSTR servername,
    DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level,
    LPBYTE *bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_DS_ROLE_FREE_MEMORY)
(
    LPBYTE bufptr
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NET_RENAME_MACHINE_IN_DOMAIN)
(
  LPCWSTR lpServer,
  LPCWSTR lpNewMachineName,
  LPCWSTR lpAccount,
  LPCWSTR lpPassword,
  DWORD fRenameOptions
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NET_JOIN_DOMAIN)
(
  LPCWSTR lpServer,
  LPCWSTR lpDomain,
  LPCWSTR lpAccountOU,
  LPCWSTR lpAccount,
  LPCWSTR lpPassword,
  DWORD fJoinOptions
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_NET_UNJOIN_DOMAIN)
(
  LPCWSTR lpServer,
  LPCWSTR lpAccount,
  LPCWSTR lpPassword,
  DWORD   fUnjoinOptions
);
    
// ******* END: NT5 and over only ***********



/******************************************************************************
 * Wrapper class for Kernel32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CNetApi32Api : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
    
    PFN_NETAPI32_NET_GROUP_ENUM                    m_pfnNetGroupEnum;
    PFN_NETAPI32_NET_GROUP_GET_INFO                m_pfnNetGroupGetInfo;
	PFN_NETAPI32_NET_GROUP_SET_INFO                m_pfnNetGroupSetInfo;
    PFN_NETAPI32_NET_LOCAL_GROUP_GET_INFO          m_pfnNetLocalGroupGetInfo;
    PFN_NETAPI32_NET_LOCAL_GROUP_SET_INFO          m_pfnNetLocalGroupSetInfo;
    PFN_NETAPI32_NET_GROUP_GET_USERS               m_pfnNetGroupGetUsers;
    PFN_NETAPI32_NET_LOCAL_GROUP_GET_MEMBERS       m_pfnNetLocalGroupGetMembers;
    PFN_NETAPI32_NET_LOCAL_GROUP_ENUM              m_pfnNetLocalGroupEnum;
    PFN_NETAPI32_NET_SHARE_ENUM                    m_pfnNetShareEnum;
    PFN_NETAPI32_NET_SHARE_GET_INFO                m_pfnNetShareGetInfo;
    PFN_NETAPI32_NET_SHARE_SET_INFO                m_pfnNetShareSetInfo;
    PFN_NETAPI32_NET_SHARE_ADD                     m_pfnNetShareAdd;
    PFN_NETAPI32_NET_SHARE_ENUM_STICKY             m_pfnNetShareEnumSticky;
    PFN_NETAPI32_NET_SHARE_DEL                     m_pfnNetShareDel;
    PFN_NETAPI32_NET_SHARE_DEL_STICKY              m_pfnNetShareDelSticky;
    PFN_NETAPI32_NET_SHARE_CHECK                   m_pfnNetShareCheck;
    PFN_NETAPI32_NET_USER_ENUM                     m_pfnNetUserEnum;
    PFN_NETAPI32_NET_USER_GET_INFO                 m_pfnNetUserGetInfo;
	PFN_NETAPI32_NET_USER_SET_INFO                 m_pfnNetUserSetInfo;
    PFN_NETAPI32_NET_API_BUFFER_FREE               m_pfnNetApiBufferFree;
    PFN_NETAPI32_NET_QUERY_DISPLAY_INFORMATION     m_pfnNetQueryDisplayInformation;
    PFN_NETAPI32_NET_SERVER_SET_INFO               m_pfnNetServerSetInfo;
    PFN_NETAPI32_NET_SERVER_GET_INFO               m_pfnNetServerGetInfo;
    PFN_NETAPI32_NET_GET_DC_NAME                   m_pfnNetGetDCName;
    PFN_NETAPI32_NET_WKSTA_GET_INFO                m_pfnNetWkstaGetInfo;
    PFN_NETAPI32_NET_GET_ANY_DC_NAME               m_pfnNetGetAnyDCName;
    PFN_NETAPI32_NET_SERVER_ENUM                   m_pfnNetServerEnum;
    PFN_NETAPI32_NET_USER_MODALS_GET               m_pfnNetUserModalsGet;
    PFN_NETAPI32_NET_SCHEDULE_JOB_ADD              m_pfnNetScheduleJobAdd;
    PFN_NETAPI32_NET_SCHEDULE_JOB_DEL              m_pfnNetScheduleJobDel;
    PFN_NETAPI32_NET_SCHEDULE_JOB_ENUM             m_pfnNetScheduleJobEnum;
    PFN_NETAPI32_NET_SCHEDULE_JOB_GET_INFO         m_pfnNetScheduleJobGetInfo;
    PFN_NETAPI32_NET_USE_GET_INFO                  m_pfnNetUseGetInfo;
// ******* BEGIN:  NT 4 and over only *******
    PFN_NETAPI32_NET_ENUMERATE_TRUSTED_DOMAINS     m_pfnNetEnumerateTrustedDomains;

#ifdef NTONLY    
	PFN_NETAPI32_DS_GET_DC_NAME                    m_pfnDsGetDcNameW ;
#else
	PFN_NETAPI32_DS_GET_DC_NAME                    m_pfnDsGetDcNameA ;
#endif

	// ******* END: NT4 and over only ***********
// ******* BEGIN:  NT 5 and over only *******
    PFN_DS_ROLE_GET_PRIMARY_DOMAIN_INFORMATION     m_pfnDsRoleGetPrimaryDomainInformation;
    PFN_DS_ROLE_FREE_MEMORY                        m_pfnDsRoleFreeMemory;
    PFN_NET_RENAME_MACHINE_IN_DOMAIN               m_pfnNetRenameMachineInDomain;
    PFN_NET_JOIN_DOMAIN                            m_pfnNetJoinDomain;
    PFN_NET_UNJOIN_DOMAIN                          m_pfnNetUnjoinDomain;
// ******* END: NT5 and over only ***********



public:

    // Constructor and destructor:
    CNetApi32Api(LPCTSTR a_tstrWrappedDllName);
    ~CNetApi32Api();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping kernel32 functions.
    // Add new functions here as required:
    NET_API_STATUS NET_API_FUNCTION NetGroupEnum
    (
        LPCWSTR a_servername, 
        DWORD a_level, 
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen, 
        LPDWORD a_entriesread,
        LPDWORD a_totalentries, 
        PDWORD_PTR  a_resume_handle
    );

    NET_API_STATUS NET_API_FUNCTION NetGroupGetInfo
    (
        LPCWSTR a_servername,
        LPCWSTR a_groupname,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

	NET_API_STATUS NET_API_FUNCTION NetGroupSetInfo
    (
        LPCWSTR servername,
		LPCWSTR groupname,
		DWORD level,
		LPBYTE buf,
		LPDWORD parm_err
    );

    NET_API_STATUS NET_API_FUNCTION NetLocalGroupGetInfo
    (
        LPCWSTR a_servername,
        LPCWSTR a_groupname,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

	NET_API_STATUS NET_API_FUNCTION NetLocalGroupSetInfo
	(  
		LPCWSTR a_servername,      
		LPCWSTR a_groupname,       
		DWORD a_level,             
		LPBYTE a_buf,              
		LPDWORD a_parm_err         
	);


    NET_API_STATUS NET_API_FUNCTION NetGroupGetUsers
    (
        LPCWSTR a_servername,
        LPCWSTR a_groupname,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        PDWORD_PTR a_ResumeHandle
    );

    NET_API_STATUS NET_API_FUNCTION NetLocalGroupGetMembers
    (
        LPCWSTR a_servername,
        LPCWSTR a_groupname,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        PDWORD_PTR a_ResumeHandle
    );

    NET_API_STATUS NET_API_FUNCTION NetLocalGroupEnum
    (
        LPCWSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        PDWORD_PTR a_resumehandle
    );

    NET_API_STATUS NET_API_FUNCTION NetShareEnum
    (
        LPTSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        LPDWORD a_resume_handle
    );

    NET_API_STATUS NET_API_FUNCTION NetShareGetInfo
    (
        LPTSTR a_servername,
        LPTSTR a_netname,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

    NET_API_STATUS NET_API_FUNCTION NetShareAdd 
    (
	    LPTSTR  a_servername,
	    DWORD   a_level,
	    LPBYTE  a_buf,
	    LPDWORD a_parm_err
    );

    NET_API_STATUS NET_API_FUNCTION NetShareEnumSticky 
    (
	    LPTSTR      a_servername,
	    DWORD       a_level,
	    LPBYTE      *a_bufptr,
	    DWORD       a_prefmaxlen,
	    LPDWORD     a_entriesread,
	    LPDWORD     a_totalentries,
	    LPDWORD     a_resume_handle
    );

    NET_API_STATUS NET_API_FUNCTION NetShareSetInfo 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_level,
	    LPBYTE  a_buf,
	    LPDWORD a_parm_err
    );

    NET_API_STATUS NET_API_FUNCTION NetShareDel 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_reserved
    );

    NET_API_STATUS NET_API_FUNCTION NetShareDelSticky 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_reserved
    );

    NET_API_STATUS NET_API_FUNCTION NetShareCheck 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_device,
	    LPDWORD a_type
    );

    NET_API_STATUS NET_API_FUNCTION NetUserEnum
    (
        LPCWSTR a_servername,
        DWORD a_level,
        DWORD a_filter,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        LPDWORD a_resume_handle
    );

    NET_API_STATUS NET_API_FUNCTION NetUserGetInfo
    (
        LPCWSTR a_servername,
        LPCWSTR a_username,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

	NET_API_STATUS NET_API_FUNCTION NetUserSetInfo(

		LPCWSTR a_servername, 
		LPCWSTR a_username,   
		DWORD a_level,       
		LPBYTE a_buf,        
		LPDWORD a_parm_err   
	);

    NET_API_STATUS NET_API_FUNCTION NetApiBufferFree
    (
        void *a_bufptr
    );

    NET_API_STATUS NET_API_FUNCTION NetQueryDisplayInformation
    (	
        LPWSTR a_ServerName,
        DWORD a_Level,
        DWORD a_Index,
        DWORD a_EntriesRequested,
        DWORD a_PreferredMaximumLength,
        LPDWORD a_ReturnedEntryCount,
        PVOID *a_SortedBuffer
    );

    NET_API_STATUS NET_API_FUNCTION NetServerSetInfo
    (
        LPTSTR  a_servername,
        DWORD a_level,
        LPBYTE  a_buf,
        LPDWORD a_ParmError
    );

    NET_API_STATUS NET_API_FUNCTION NetServerGetInfo
    (
        LPTSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr
    );


    NET_API_STATUS NET_API_FUNCTION NetGetDCName
    (	LPCWSTR a_servername,
        LPCWSTR a_domainname,
        LPBYTE *a_bufptr 
    );

    NET_API_STATUS NET_API_FUNCTION NetWkstaGetInfo
    (	
        LPWSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

    NET_API_STATUS NET_API_FUNCTION NetGetAnyDCName
    (	
        LPWSTR a_servername,
        LPWSTR a_domainname,
        LPBYTE *a_bufptr 
    );

    NET_API_STATUS NET_API_FUNCTION NetServerEnum
    (	
        LPTSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr,
        DWORD a_prefmaxlen,
        LPDWORD a_entriesread,
        LPDWORD a_totalentries,
        DWORD a_servertype,
        LPTSTR a_domain,
        LPDWORD a_resume_handle 
    );

    NET_API_STATUS NET_API_FUNCTION NetUserModalsGet
    (	
        LPWSTR a_servername,
        DWORD a_level,
        LPBYTE *a_bufptr
    );

    NET_API_STATUS NET_API_FUNCTION NetScheduleJobAdd 
    (
        LPCWSTR         a_Servername,
        LPBYTE          a_Buffer,
        LPDWORD         a_JobId
    );

    NET_API_STATUS NET_API_FUNCTION NetScheduleJobDel 
    (
        LPCWSTR         a_Servername,
        DWORD           a_MinJobId,
        DWORD           a_MaxJobId
    );

    NET_API_STATUS NET_API_FUNCTION NetScheduleJobEnum 
    (
        LPCWSTR         a_Servername,
        LPBYTE         *a_PointerToBuffer,
        DWORD           a_PrefferedMaximumLength,
        LPDWORD         a_EntriesRead,
        LPDWORD         a_TotalEntries,
        LPDWORD         a_ResumeHandle
    );

    NET_API_STATUS NET_API_FUNCTION NetScheduleJobGetInfo 
    (
        LPCWSTR         a_Servername,
        DWORD           a_JobId,
        LPBYTE         *a_PointerToBuffer
    );

    NET_API_STATUS NET_API_FUNCTION NetUseGetInfo 
    (
        LPCWSTR         a_UncServerName,
        LPCWSTR         a_UseName,
        DWORD           a_Level,
        LPBYTE         *a_BufPtr
    );

    // ******* BEGIN:  NT 4 and over only *******
    bool NET_API_FUNCTION NetEnumerateTrustedDomains
    (	
        LPCWSTR a_servername,
	    LPWSTR *a_domainNames,
        NET_API_STATUS *a_pnasRetval
    ) ;

    bool NET_API_FUNCTION DsGetDCName
    (	
        LPCTSTR a_ComputerName, 
	    LPCTSTR a_DomainName,
	    GUID *a_DomainGuid, 
	    LPCTSTR a_SiteName, 
	    ULONG a_Flags,
	    PDOMAIN_CONTROLLER_INFO *a_DomainControllerInfo,
        NET_API_STATUS *a_pnasRetval 
    );
    // ******* END: NT4 and over only ***********



    // ******* BEGIN:  NT 5 and over only *******
    bool NET_API_FUNCTION DSRoleGetPrimaryDomainInformation
    (
        LPCWSTR a_servername,
        DSROLE_PRIMARY_DOMAIN_INFO_LEVEL a_level,
        LPBYTE *a_bufptr,
        NET_API_STATUS *a_pnasRetval 
    );

    bool NET_API_FUNCTION DSRoleFreeMemory
    (
        LPBYTE a_bufptr,
        NET_API_STATUS *a_pnasRetval 
    );

    bool NET_API_FUNCTION NetRenameMachineInDomain
    (
        LPCWSTR a_lpServer,
        LPCWSTR a_lpNewMachineName,
        LPCWSTR a_lpAccount,
        LPCWSTR a_lpPassword,
        DWORD a_fRenameOptions,
        NET_API_STATUS *a_pnasRetval
    );

    bool NET_API_FUNCTION NetJoinDomain
	(
		LPCWSTR lpServer,
		LPCWSTR lpDomain,
		LPCWSTR lpAccountOU,
		LPCWSTR lpAccount,
		LPCWSTR lpPassword,
		DWORD fJoinOptions,
		NET_API_STATUS *a_pnasRetval
    );

    bool NET_API_FUNCTION NetUnjoinDomain(
		LPCWSTR lpServer,
		LPCWSTR lpAccount,
		LPCWSTR lpPassword,
		DWORD   fUnjoinOptions,
		NET_API_STATUS *a_pnasRetval
    );

    // ******* END: NT5 and over only ***********

};






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ntdevtosvcsearch.cpp ===
//=================================================================

//

// NTDEVTOSVCSEARCH.CPP -- Class to use the registry to find an

//							NT Service name based on a device name.

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    09/18/97    a-sanjes        Created
//
//=================================================================
#include "precomp.h"
#include <winerror.h>
#include <cregcls.h>
#include "ntdevtosvcsearch.h"

#ifdef NTONLY

//////////////////////////////////////////////////////////////////////////////
//
//	ntdevtosvcsearch.cpp - Class implementation of CNTDeviceToServiceSearch.
//
//	This class is intended to provide a way for an NT implementation to locate
//	an NT Service name based off of an owner device name given to it by the
//	HAL Layer.  For  example, we may be working with KeyboardPort0, but actually
//	need to report a service name of i8042prt (what scares me is that I
//	pulled "i8042prt" out of memory.  Someone shoot me now).
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CNTDeviceToServiceSearch::CNTDeviceToServiceSearch
//
//	DESCRIPTION :	Constructor
//
//	INPUTS      :	none.
//
//	OUTPUTS     :	none
//
//	RETURNS     :	nothing
//
//	COMMENTS    :	none.
//
//////////////////////////////////////////////////////////////////////////////

CNTDeviceToServiceSearch::CNTDeviceToServiceSearch( void )
:	CRegistrySearch()
{
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CNTDeviceToServiceSearch::~CNTDeviceToServiceSearch
//
//	DESCRIPTION :	Destructor
//
//	INPUTS      :	none
//
//	OUTPUTS     :	none
//
//	RETURNS     :	nothing
//
//	COMMENTS    :	Class destructor
//
//////////////////////////////////////////////////////////////////////////////

CNTDeviceToServiceSearch::~CNTDeviceToServiceSearch( void )
{
}

//////////////////////////////////////////////////////////////////////////////
//
//	FUNCTION    :	CNTDeviceToServiceSearch::Find
//
//	DESCRIPTION :	Traverses registry, looking for the supplied owner
//					device name (obtained from the HAL) and upon finding
//					it, stores the name in strServiceName.
//
//	INPUTS      :	LPCTSTR		pszOwnerDeviceName - Owner Device name to
//														locate.
//
//	OUTPUTS     :	CHString&	strServiceName - Service name found in
//													registry.
//
//	RETURNS     :	BOOL		TRUE/FALSE - Success/Failure
//
//	COMMENTS    :	Only applicable to Windows NT.  Searches the following key:
//					HKLM\HARDWARE\RESOURCEMAP.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CNTDeviceToServiceSearch::Find( LPCTSTR pszOwnerDeviceName, CHString& strServiceName )
{

	//////////////////////////////////////////////////////////////////////////
	//
	//	We will need to traverse the HKEY_LOCAL_MACHINE\HARDWARE\RESOURCE_MAP
	//	tree in order to locate the correct service name.
	//
	//	A SubKey Name will identify an owner if it:
	//
	//	a>	Matches the pszOwnerDeviceName that was passed in
	//	b>	We successfully query a value for the Raw
	//		or translated device name.  The Raw device
	//		name is something along the lines of
	//		\Device\PointerPort0.Raw and the Translated
	//		device name is something along the lines of
	//		\Device\PointerPort0.Translated.  In either
	//		case, replace "PointerPort0" with the value
	//		of pszOwnerDeviceName.
	//
	//////////////////////////////////////////////////////////////////////////

	CHString	strRawDeviceValue,
				strTranslatedDeviceValue,
				strServiceNamePath;

	LPCTSTR		ppszValueNames[2];

	strRawDeviceValue.Format( RAWVALUENAME_FMAT, pszOwnerDeviceName );
	strTranslatedDeviceValue.Format( TRANSLATEDVALUENAME_FMAT, pszOwnerDeviceName );

	ppszValueNames[0] = (LPCTSTR) strRawDeviceValue;
	ppszValueNames[1] = (LPCTSTR) strTranslatedDeviceValue;

	// We're all setup, so go ahead and traverse the registry

	return LocateKeyByNameOrValueName(	HKEY_LOCAL_MACHINE,
										DEVTOSVC_BASEKEYPATH,
										pszOwnerDeviceName,
										ppszValueNames,
										2,
										strServiceName,
										strServiceNamePath );

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\objaccessrights.cpp ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/





//=================================================================

//

// ObjAccessRights.CPP -- Class for obtaining effective access

//                      rights on an unspecified object for a particular

//                      user or group.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/29/99    a-kevhu         Created
//
//=================================================================



#include "precomp.h"

#ifdef NTONLY


#include <assertbreak.h>
#include "AdvApi32Api.h"
#include "accctrl.h"
#include "sid.h"
#include "AccessEntryList.h"
#include "AccessRights.h"
#include "ObjAccessRights.h"
#include "ImpLogonUser.h"
#include "aclapi.h"
#include "DACL.h"


// Default initialization...
CObjAccessRights::CObjAccessRights(bool fUseCurThrTok /* = false */)
: CAccessRights(fUseCurThrTok)
{
}

CObjAccessRights::CObjAccessRights(LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType, bool fUseCurThrTok /* = false */)
: CAccessRights(fUseCurThrTok)
{
    m_dwError = SetObj(wstrObjName, ObjectType);
}

CObjAccessRights::CObjAccessRights(const USER user, USER_SPECIFIER usp)
: CAccessRights(user, usp)
{
}

CObjAccessRights::CObjAccessRights(const USER user, LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType, USER_SPECIFIER usp)
: CAccessRights(user, usp)
{
    m_dwError = SetObj(wstrObjName, ObjectType);
}



// Members clean up after themselves. Nothing to do here.
CObjAccessRights::~CObjAccessRights()
{
}

// Extracts the Obj's acl, and stores a copy of it.
DWORD CObjAccessRights::SetObj(LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType)
{
    DWORD dwRet = E_FAIL;
    PACL pacl = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;
    CAdvApi32Api *pAdvApi32 = NULL;

    try
    {
        if(wcslen(wstrObjName) != 0)
        {
            pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
            if(pAdvApi32 != NULL)
            {
                if(pAdvApi32->GetNamedSecurityInfoW(_bstr_t(wstrObjName),
                                                    ObjectType,
                                                    DACL_SECURITY_INFORMATION,
                                                    NULL,
                                                    NULL,
                                                    &pacl,
                                                    NULL,
                                                    &psd,
                                                    &dwRet))
                {
                    if(dwRet == ERROR_SUCCESS && psd != NULL)
                    {
                        if(pacl != NULL) // might be null in the case of a null dacl!
                        {
                            if(!SetAcl(pacl))
                            {
                                dwRet = ERROR_INVALID_PARAMETER;
                            }
                            else
                            {
                                m_chstrObjName = wstrObjName;
                            }
                        }
                        else
                        {
                            // We have a security descriptor, we returned ERROR_SUCCESS from GetNamedSecurityInfo, so this
                            // means we have a null dacl.  In this case, we will create a NULL dacl using our security classes -
                            // more overhead, but will happen relatively infrequently.
                            CDACL newnulldacl;
                            if(newnulldacl.CreateNullDACL())
                            {
                                if((dwRet = newnulldacl.ConfigureDACL(pacl)) == ERROR_SUCCESS)
                                {
                                    if(pacl != NULL)  // might be null in the case of a null dacl!
                                    {
                                        if(!SetAcl(pacl))
                                        {
                                            dwRet = ERROR_INVALID_PARAMETER;
                                        }
                                        else
                                        {
                                            m_chstrObjName = wstrObjName;
                                        }
                                        // Since the memory we used for pacl, in this case, is not part of psd, and therefor
                                        // won't be freed via the call to LocalFree(psd), we free it here.
                                        free(pacl);
                                        pacl = NULL;
                                    }
                                }
                            }
                        }
                        LocalFree(psd);
                        psd = NULL;
                    }
                }
                CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
                pAdvApi32 = NULL;
            }
        }
    }
    catch(...)
    {
        if(psd != NULL)
        {
            LocalFree(psd);
            psd = NULL;
        }
        if(pAdvApi32 != NULL)
        {
            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, pAdvApi32);
            pAdvApi32 = NULL;
        }
        throw;
    }
    return dwRet;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ntdllapi.h ===
//=================================================================

//

// NTDllApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_NTDLLAPI_H_
#define	_NTDLLAPI_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidNtDllApi;
extern const TCHAR g_tstrNtDll[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef DWORD (WINAPI *PFN_NTDLL_RTL_INIT_UNICODE_STRING)
(
    UNICODE_STRING*, 
    LPCWSTR
);

typedef void ( NTAPI *PFN_NTDLL_RTL_FREE_UNICODE_STRING ) 
(
    PUNICODE_STRING UnicodeString
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_SET_SYSTEM_ENVIRONMENT_VALUE)
(
    UNICODE_STRING*, 
    UNICODE_STRING*
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_QUERY_SYSTEM_ENVIRONMENT_VALUE)
(
    PUNICODE_STRING,
    PWSTR,
    USHORT,
    PUSHORT
);

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)
typedef DWORD (WINAPI *PFN_NTDLL_NT_QUERY_BOOT_OPTIONS)
(
    PBOOT_OPTIONS,
    PULONG
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_SET_BOOT_OPTIONS)
(
    PBOOT_OPTIONS,
    ULONG
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_QUERY_BOOT_ENTRY_ORDER)
(
    PULONG,
    PULONG
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_SET_BOOT_ENTRY_ORDER)
(
    PULONG,
    ULONG
);

typedef DWORD (WINAPI *PFN_NTDLL_NT_ENUMERATE_BOOT_ENTRIES)
(
    PVOID,
    PULONG
);

#endif // defined(EFI_NVRAM_ENABLED)

typedef NTSTATUS (WINAPI *PFN_NTDLL_NT_CREATE_FILE)
( 
    HANDLE*, 
    ACCESS_MASK,
    POBJECT_ATTRIBUTES, 
    PIO_STATUS_BLOCK,
    PLARGE_INTEGER,
    ULONG, 
    ULONG, 
    ULONG, 
    ULONG, 
    PVOID, 
    ULONG 
);

typedef NTSTATUS (NTAPI *PFN_NT_QUERY_SYSTEM_INFORMATION)
(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NTQUERYINFORMATIONPROCESS)
(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NT_QUERY_DIRECTORY_OBJECT)
(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NT_QUERY_OBJECT)
(
    IN HANDLE Handle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS (NTAPI *PFN_NT_OPEN_DIRECTORY_OBJECT)
(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
);

typedef NTSTATUS ( NTAPI *PFN_NT_QUERY_INFORMATION_TOKEN )
(
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
);

typedef NTSTATUS ( NTAPI *PFN_NT_OPEN_FILE )
(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
);

typedef NTSTATUS ( NTAPI *PFN_NT_CLOSE )
(
	IN HANDLE Handle
);

typedef NTSTATUS ( NTAPI *PFN_NT_FS_CONTROL_FILE ) 
(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
);

typedef NTSTATUS ( NTAPI *PFN_NT_QUERY_VOLUME_INFORMATION_FILE )
(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
);

/******************************************************************************
 * Wrapper class for NtDll load/unload, for registration with CResourceManager. 
 *****************************************************************************/
class CNtDllApi : public CDllWrapperBase
{
private:

    // Member variables (function pointers) pointing to NtDll functions.
    // Add new functions here as required.

    PFN_NTDLL_RTL_INIT_UNICODE_STRING m_pfnRtlInitUnicodeString;
	PFN_NTDLL_RTL_FREE_UNICODE_STRING m_pfnRtlFreeUnicodeString;
    PFN_NTDLL_NT_SET_SYSTEM_ENVIRONMENT_VALUE m_pfnNtSetSystemEnvironmentValue;
    PFN_NTDLL_NT_QUERY_SYSTEM_ENVIRONMENT_VALUE m_pfnNtQuerySystemEnvironmentValue;
//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)
    PFN_NTDLL_NT_QUERY_BOOT_OPTIONS m_pfnNtQueryBootOptions;
    PFN_NTDLL_NT_SET_BOOT_OPTIONS m_pfnNtSetBootOptions;
    PFN_NTDLL_NT_QUERY_BOOT_ENTRY_ORDER m_pfnNtQueryBootEntryOrder;
    PFN_NTDLL_NT_SET_BOOT_ENTRY_ORDER m_pfnNtSetBootEntryOrder;
    PFN_NTDLL_NT_ENUMERATE_BOOT_ENTRIES m_pfnNtEnumerateBootEntries;
#endif // defined(EFI_NVRAM_ENABLED)
    PFN_NTDLL_NT_CREATE_FILE m_pfnNtCreateFile;
    PFN_NT_QUERY_SYSTEM_INFORMATION m_pfnNtQuerySystemInformation;
    PFN_NT_QUERY_DIRECTORY_OBJECT m_pfnNtQueryDirectoryObject;
    PFN_NT_QUERY_OBJECT m_pfnNtQueryObject;
    PFN_NT_OPEN_DIRECTORY_OBJECT m_pfnNtOpenDirectoryObject;
	PFN_NTQUERYINFORMATIONPROCESS m_pfnNtQueryInformationProcess ;
	PFN_NT_QUERY_INFORMATION_TOKEN m_pfnNtQueryInformationToken ;
	PFN_NT_OPEN_FILE m_pfnNtOpenFile ;
	PFN_NT_CLOSE m_pfnNtClose ;
	PFN_NT_FS_CONTROL_FILE m_pfnNtFsControlFile ;
    PFN_NT_QUERY_VOLUME_INFORMATION_FILE m_pfnNtQueryVolumeInformationFile;

public:

    // Constructor and destructor:
    CNtDllApi(LPCTSTR a_tstrWrappedDllName);
    ~CNtDllApi();

    // Initialization function to check function pointers.
    virtual bool Init();

    // Member functions wrapping NtDll functions.
    // Add new functions here as required:

    DWORD RtlInitUnicodeString (

        UNICODE_STRING* a_pustr, 
        LPCWSTR a_wstr
    );

	VOID RtlFreeUnicodeString (

		PUNICODE_STRING UnicodeString
	) ;

    DWORD NtSetSystemEnvironmentValue (

        UNICODE_STRING* a_pustr1, 
        UNICODE_STRING* a_pustr2
    );

    DWORD NtQuerySystemEnvironmentValue (

        PUNICODE_STRING a_pustr,
        PWSTR a_pwstr,
        USHORT a_us,
        PUSHORT a_pus
    );

//#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)

    DWORD NtQueryBootOptions (

        PBOOT_OPTIONS BootOptions,
        PULONG BootOptionsLength
    );

    DWORD NtSetBootOptions (

        PBOOT_OPTIONS BootOptions,
        ULONG FieldsToChange
    );

    DWORD NtQueryBootEntryOrder (

        PULONG Ids,
        PULONG Count
    );

    DWORD NtSetBootEntryOrder (

        PULONG Ids,
        ULONG Count
    );

    DWORD NtEnumerateBootEntries (

        PVOID Buffer,
        PULONG BufferLength
    );

#endif // defined(EFI_NVRAM_ENABLED)

    NTSTATUS NtCreateFile ( 

        HANDLE *a_ph, 
        ACCESS_MASK a_am,
        POBJECT_ATTRIBUTES a_pa, 
        PIO_STATUS_BLOCK a_sb,
        PLARGE_INTEGER a_pla,
        ULONG a_ul1, 
        ULONG a_ul2, 
        ULONG a_ul3, 
        ULONG a_ul4, 
        PVOID a_pv, 
        ULONG a_ul5 
    );

    NTSTATUS NtQuerySystemInformation
    (
        SYSTEM_INFORMATION_CLASS a_SystemInformationClass,
        PVOID a_SystemInformation,
        ULONG a_SystemInformationLength,
        PULONG a_ReturnLength 
    );

    NTSTATUS NtQueryDirectoryObject
    (
        HANDLE a_DirectoryHandle,
        PVOID a_Buffer,
        ULONG a_Length,
        BOOLEAN a_ReturnSingleEntry,
        BOOLEAN a_RestartScan,
        PULONG a_Context,
        PULONG a_ReturnLength 
    );

    NTSTATUS NtQueryObject
    (
        HANDLE a_Handle,
        OBJECT_INFORMATION_CLASS a_ObjectInformationClass,
        PVOID a_ObjectInformation,
        ULONG a_Length,
        PULONG a_ReturnLength 
    );

    NTSTATUS NtOpenDirectoryObject
    (
        PHANDLE a_DirectoryHandle,
        ACCESS_MASK a_DesiredAccess,
        POBJECT_ATTRIBUTES a_ObjectAttributes
    );

	NTSTATUS NtQueryInformationProcess (

		IN HANDLE ProcessHandle,
		IN PROCESSINFOCLASS ProcessInformationClass,
		OUT PVOID ProcessInformation,
		IN ULONG ProcessInformationLength,
		OUT PULONG ReturnLength OPTIONAL
    );

	NTSTATUS NtQueryInformationToken (

		IN HANDLE TokenHandle,
		IN TOKEN_INFORMATION_CLASS TokenInformationClass,
		OUT PVOID TokenInformation,
		IN ULONG TokenInformationLength,
		OUT PULONG ReturnLength
    ) ;

	NTSTATUS NtOpenFile (

		OUT PHANDLE FileHandle,
		IN ACCESS_MASK DesiredAccess,
		IN POBJECT_ATTRIBUTES ObjectAttributes,
		OUT PIO_STATUS_BLOCK IoStatusBlock,
		IN ULONG ShareAccess,
		IN ULONG OpenOptions
    );

	NTSTATUS NtClose (

	    IN HANDLE Handle
    );

	NTSTATUS NtFsControlFile (

		IN HANDLE FileHandle,
		IN HANDLE Event OPTIONAL,
		IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN PVOID ApcContext OPTIONAL,
		OUT PIO_STATUS_BLOCK IoStatusBlock,
		IN ULONG FsControlCode,
		IN PVOID InputBuffer OPTIONAL,
		IN ULONG InputBufferLength,
		OUT PVOID OutputBuffer OPTIONAL,
		IN ULONG OutputBufferLength
	);

    NTSTATUS NtQueryVolumeInformationFile(
        IN HANDLE FileHandle,
        OUT PIO_STATUS_BLOCK IoStatusBlock,
        OUT PVOID FsInformation,
        IN ULONG Length,
        IN FS_INFORMATION_CLASS FsInformationClass);

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\nt4svctoresmap.cpp ===
/////////////////////////////////////////////////////////////////////////

//

//  Nt4SvcToResMap.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj
//              10/17/97        jennymc     Moved things a tiny bit
//
/////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <assertbreak.h>
#include <cregcls.h>
#include "ntdevtosvcsearch.h"
#include "nt4svctoresmap.h"

#ifdef NTONLY
// The Map we use to back up this class is an STL Template, so make sure we have the
// std namespace available to us.

using namespace std;

CNT4ServiceToResourceMap::CNT4ServiceToResourceMap( void )
:	m_HardwareResource(),
	m_map()
{
	InitializeMap();
}

CNT4ServiceToResourceMap::~CNT4ServiceToResourceMap( void )
{
	Clear();
}

BOOL CNT4ServiceToResourceMap::InitializeMap( void )
{
	BOOL	fReturn = FALSE;

	//=======================================
	// Create hardware system resource list &
	// get the head of the list
	//=======================================
	m_HardwareResource.CreateSystemResourceLists();

	if ( WalkResourceNodes( m_HardwareResource._SystemResourceList.InterruptHead ) )
	{
		if ( WalkResourceNodes( m_HardwareResource._SystemResourceList.PortHead ) )
		{
			if ( WalkResourceNodes( m_HardwareResource._SystemResourceList.MemoryHead ) )
			{
				fReturn = WalkResourceNodes( m_HardwareResource._SystemResourceList.DmaHead );
			}
		}
	}

	return fReturn;
}

BOOL CNT4ServiceToResourceMap::WalkResourceNodes( LPRESOURCE_DESCRIPTOR pResourceDescriptor )
{
   	CNTDeviceToServiceSearch	devSearch;
	CHString					strOwnerServiceName;
	BOOL						fReturn = TRUE;
	NT4SvcToResourceMapIter		mapIter;

	// For each descriptor we find, get the resource owner, then convert the name (if
	// it is not a HAL resource) to an NT service name.  From there, if the name does
	// not already exist in the map, we need to allocate a new array, otherwise, get
	// the existing pointer.  Then add the resource descriptor to the array, so we end
	// up with a structure where a service name will get us to a list of resources owned
	// by said service.

	while ( NULL != pResourceDescriptor && fReturn )
	{
//		if	(	!strstr( pResourceDescriptor->Owner->Name,"HAL")
//			&&	devSearch.Find( pResourceDescriptor->Owner->Name, strOwnerServiceName ) )

//		{
			// Because the CHString compare is case sensitive, and the names
			// of our services as we retrieve them are not necessarily so,
			// we uppercase everything so we are theoretically forcing
			// case insensitivity.

        // Before we used to do an (expensive) scan of the registry.  Now,
        // I store the registry key in the resource structure.
        strOwnerServiceName.Empty();
        CHString sParse(pResourceDescriptor->Owner->KeyName);

        // Parse off the last part of the registry key name
        int iWhere = sParse.ReverseFind(_T('\\'));
        if (iWhere != -1)
        {
            strOwnerServiceName = sParse.Mid(iWhere + 1);
        }
        else
        {
            // If something went wrong, fall back to the other way
            devSearch.Find( pResourceDescriptor->Owner->Name, strOwnerServiceName);
            ASSERT_BREAK(0);
        }

        if (!strOwnerServiceName.IsEmpty())
        {

			strOwnerServiceName.MakeUpper();
			CHPtrArray*	pPtrArray = NULL;

			if( ( mapIter = m_map.find( strOwnerServiceName ) ) == m_map.end() )
			{
				pPtrArray = new CHPtrArray;
                if (pPtrArray == NULL)
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                try
                {
				    m_map[strOwnerServiceName] = pPtrArray;
                }
                catch ( ... )
                {
                    delete pPtrArray;
                    throw ;
                }
			}
			else
			{
				pPtrArray = mapIter->second;
			}

			if ( NULL != pPtrArray )
			{
				pPtrArray->Add( pResourceDescriptor );
			}
			else
			{
				fReturn = FALSE;
			}

		}	// If owner generated a valid service name

		pResourceDescriptor = pResourceDescriptor->NextSame;
	}

	return fReturn;

}

DWORD CNT4ServiceToResourceMap::NumServiceResources( LPCTSTR pszServiceName )
{
	DWORD						dwNumResources = 0;
	NT4SvcToResourceMapIter		mapIter;

	// Upper case for case-insensitivity
	CHString					strUpperCaseServiceName( pszServiceName );
	strUpperCaseServiceName.MakeUpper();

	if( ( mapIter = m_map.find( strUpperCaseServiceName ) ) != m_map.end() )
	{

		CHPtrArray*	pResources = mapIter->second;

		if ( NULL != pResources )
		{
			dwNumResources = pResources->GetSize();
		}

	}

	return dwNumResources;
}

LPRESOURCE_DESCRIPTOR CNT4ServiceToResourceMap::GetServiceResource( LPCTSTR pszServiceName, DWORD dwIndex )
{
	LPRESOURCE_DESCRIPTOR		pResourceDescriptor = NULL;
	NT4SvcToResourceMapIter		mapIter;

	// Upper case for case-insensitivity
	CHString					strUpperCaseServiceName( pszServiceName );
	strUpperCaseServiceName.MakeUpper();

	if( ( mapIter = m_map.find( strUpperCaseServiceName ) ) != m_map.end() )
	{

		CHPtrArray*	pResources = mapIter->second;

		if	(	NULL	!=	pResources
			&&	dwIndex	<	pResources->GetSize() )
		{
			pResourceDescriptor = (LPRESOURCE_DESCRIPTOR) pResources->GetAt( dwIndex );
		}

	}

	return pResourceDescriptor;

}

void CNT4ServiceToResourceMap::Clear( void )
{
	CHPtrArray*	pPtrArray = NULL;

	// Delete all list entries and then clear out the list.

	for (	NT4SvcToResourceMapIter	mapIter	=	m_map.begin();
			mapIter != m_map.end();
			mapIter++ )
	{
		pPtrArray = mapIter->second;
		if ( NULL != pPtrArray )
		{
			delete pPtrArray;
		}
	}

	m_map.erase( m_map.begin(), m_map.end() );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\ntdllapi.cpp ===
//=================================================================

//

// NtDllApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"
#include <ntseapi.h>
#include <cominit.h>

#include <ntsecapi.h>
#include "DllWrapperBase.h"
#include "NtDllApi.h"
#include "DllWrapperCreatorReg.h"


// {77609C22-CDAA-11d2-911E-0060081A46FD}
static const GUID g_guidNtDllApi =
{0x77609c22, 0xcdaa, 0x11d2, {0x91, 0x1e, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd}};

static const TCHAR g_tstrNtDll[] = _T("NTDLL.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CNtDllApi, &g_guidNtDllApi, g_tstrNtDll> MyRegisteredNtDllWrapper;


/******************************************************************************
 * Constructor
 *****************************************************************************/
CNtDllApi::CNtDllApi(LPCTSTR a_tstrWrappedDllName)
	: CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnRtlInitUnicodeString(NULL),
	m_pfnNtSetSystemEnvironmentValue(NULL),
	m_pfnNtQuerySystemEnvironmentValue(NULL),
#if defined(_IA64_) //EFI_NVRAM_ENABLED)
	m_pfnNtQueryBootOptions(NULL),
	m_pfnNtSetBootOptions(NULL),
	m_pfnNtQueryBootEntryOrder(NULL),
	m_pfnNtSetBootEntryOrder(NULL),
	m_pfnNtEnumerateBootEntries(NULL),
#endif // defined(EFI_NVRAM_ENABLED)
	m_pfnNtCreateFile(NULL),
	m_pfnNtQuerySystemInformation(NULL),
	m_pfnNtQueryDirectoryObject(NULL),
	m_pfnNtQueryObject(NULL),
	m_pfnNtOpenDirectoryObject(NULL) ,
	m_pfnNtQueryInformationProcess(NULL),
	m_pfnNtQueryInformationToken(NULL),
	m_pfnNtOpenFile(NULL),
	m_pfnNtClose(NULL),
	m_pfnNtFsControlFile(NULL)
{
}


/******************************************************************************
 * Destructor
 *****************************************************************************/
CNtDllApi::~CNtDllApi()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 ******************************************************************************/
bool CNtDllApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {


        m_pfnRtlInitUnicodeString = (PFN_NTDLL_RTL_INIT_UNICODE_STRING)
                                        GetProcAddress("RtlInitUnicodeString");

		m_pfnRtlFreeUnicodeString = (PFN_NTDLL_RTL_FREE_UNICODE_STRING)
										GetProcAddress("RtlFreeUnicodeString");

        m_pfnNtSetSystemEnvironmentValue =
                                    (PFN_NTDLL_NT_SET_SYSTEM_ENVIRONMENT_VALUE)
                                 GetProcAddress("NtSetSystemEnvironmentValue");

        m_pfnNtQuerySystemEnvironmentValue =
                                  (PFN_NTDLL_NT_QUERY_SYSTEM_ENVIRONMENT_VALUE)
                               GetProcAddress("NtQuerySystemEnvironmentValue");

#if defined(_IA64_)//EFI_NVRAM_ENABLED)
        m_pfnNtQueryBootOptions =
                                  (PFN_NTDLL_NT_QUERY_BOOT_OPTIONS)
                               GetProcAddress("NtQueryBootOptions");

        m_pfnNtSetBootOptions =
                                  (PFN_NTDLL_NT_SET_BOOT_OPTIONS)
                               GetProcAddress("NtSetBootOptions");

        m_pfnNtQueryBootEntryOrder =
                                  (PFN_NTDLL_NT_QUERY_BOOT_ENTRY_ORDER)
                               GetProcAddress("NtQueryBootEntryOrder");

        m_pfnNtSetBootEntryOrder =
                                  (PFN_NTDLL_NT_SET_BOOT_ENTRY_ORDER)
                               GetProcAddress("NtSetBootEntryOrder");

        m_pfnNtEnumerateBootEntries =
                                  (PFN_NTDLL_NT_ENUMERATE_BOOT_ENTRIES)
                               GetProcAddress("NtEnumerateBootEntries");
#endif // defined(EFI_NVRAM_ENABLED)

        m_pfnNtCreateFile = (PFN_NTDLL_NT_CREATE_FILE)
                                                GetProcAddress("NtCreateFile");

        m_pfnNtQuerySystemInformation = (PFN_NT_QUERY_SYSTEM_INFORMATION)
                                    GetProcAddress("NtQuerySystemInformation");

        m_pfnNtQueryDirectoryObject = (PFN_NT_QUERY_DIRECTORY_OBJECT)
                                      GetProcAddress("NtQueryDirectoryObject");

        m_pfnNtQueryObject = (PFN_NT_QUERY_OBJECT)
                                               GetProcAddress("NtQueryObject");

        m_pfnNtOpenDirectoryObject = (PFN_NT_OPEN_DIRECTORY_OBJECT)
                                       GetProcAddress("NtOpenDirectoryObject");

		m_pfnNtQueryInformationProcess = ( PFN_NTQUERYINFORMATIONPROCESS )
										GetProcAddress("NtQueryInformationProcess");

		m_pfnNtQueryInformationToken = ( PFN_NT_QUERY_INFORMATION_TOKEN )
										GetProcAddress("NtQueryInformationToken");

		m_pfnNtOpenFile = ( PFN_NT_OPEN_FILE ) GetProcAddress("NtOpenFile");
		
        m_pfnNtClose = ( PFN_NT_CLOSE ) GetProcAddress("NtClose");
		
        m_pfnNtFsControlFile = ( PFN_NT_FS_CONTROL_FILE ) GetProcAddress("NtFsControlFile") ;

        m_pfnNtQueryVolumeInformationFile = (PFN_NT_QUERY_VOLUME_INFORMATION_FILE)
                                        GetProcAddress("NtQueryVolumeInformationFile");

    }

    // We require these function for all versions of this dll.
    if (
			m_pfnRtlInitUnicodeString == NULL ||
			m_pfnNtSetSystemEnvironmentValue == NULL ||
			m_pfnNtQuerySystemEnvironmentValue == NULL ||
#if defined(_IA64_)//(EFI_NVRAM_ENABLED)
			m_pfnNtQueryBootOptions == NULL ||
			m_pfnNtSetBootOptions == NULL ||
			m_pfnNtQueryBootEntryOrder == NULL ||
			m_pfnNtSetBootEntryOrder == NULL ||
			m_pfnNtEnumerateBootEntries == NULL ||
#endif // defined(EFI_NVRAM_ENABLED)
			m_pfnNtCreateFile == NULL ||
			m_pfnNtQuerySystemInformation == NULL ||
			m_pfnNtQueryDirectoryObject == NULL ||
			m_pfnNtQueryObject == NULL ||
			m_pfnNtOpenDirectoryObject == NULL ||
			m_pfnNtQueryInformationProcess == NULL ||
			m_pfnNtQueryInformationToken == NULL ||
			m_pfnNtOpenFile == NULL ||
			m_pfnNtClose == NULL ||
			m_pfnNtFsControlFile == NULL ||
			m_pfnRtlFreeUnicodeString == NULL 
	)
    {
        fRet = false;
        LogErrorMessage(L"Failed find entrypoint in ntdllapi");
    }
    return fRet;
}

/******************************************************************************
 * Member functions wrapping NtDll api functions. Add new functions here
 * as required.
 *****************************************************************************/
DWORD CNtDllApi::RtlInitUnicodeString
(
    UNICODE_STRING* a_pustr,
    LPCWSTR a_wstr
)
{
    return m_pfnRtlInitUnicodeString(a_pustr,
                                     a_wstr);
}

VOID CNtDllApi::RtlFreeUnicodeString (

	PUNICODE_STRING UnicodeString
)
{
	m_pfnRtlFreeUnicodeString (

		UnicodeString
	) ;
}

DWORD CNtDllApi::NtSetSystemEnvironmentValue
(
    UNICODE_STRING* a_pustr1,
    UNICODE_STRING* a_pustr2
)
{
    return m_pfnNtSetSystemEnvironmentValue(a_pustr1,
                                            a_pustr2);
}

DWORD CNtDllApi::NtQuerySystemEnvironmentValue
(
    PUNICODE_STRING a_pustr,
    PWSTR a_pwstr,
    USHORT a_us,
    PUSHORT a_pus
)
{
    return m_pfnNtQuerySystemEnvironmentValue(a_pustr,
                                              a_pwstr,
                                              a_us,
                                              a_pus);
}

#if defined(_IA64_)//(EFI_NVRAM_ENABLED)

DWORD CNtDllApi::NtQueryBootOptions
(
    PBOOT_OPTIONS BootOptions,
    PULONG BootOptionsLength
)
{
    return m_pfnNtQueryBootOptions(BootOptions,
                                   BootOptionsLength);
}

DWORD CNtDllApi::NtSetBootOptions
(
    PBOOT_OPTIONS BootOptions,
    ULONG FieldsToChange
)
{
    return m_pfnNtSetBootOptions(BootOptions,
                                 FieldsToChange);
}

DWORD CNtDllApi::NtQueryBootEntryOrder
(
    PULONG Ids,
    PULONG Count
)
{
    return m_pfnNtQueryBootEntryOrder(Ids,
                                    Count);
}

DWORD CNtDllApi::NtSetBootEntryOrder
(
    PULONG Ids,
    ULONG Count
)
{
    return m_pfnNtSetBootEntryOrder(Ids,
                                    Count);
}

DWORD CNtDllApi::NtEnumerateBootEntries
(
    PVOID Buffer,
    PULONG BufferLength
)
{
    return m_pfnNtEnumerateBootEntries(Buffer,
                                       BufferLength);
}

#endif // defined(EFI_NVRAM_ENABLED)

NTSTATUS CNtDllApi::NtCreateFile
(
    HANDLE *a_ph,
    ACCESS_MASK a_am,
    POBJECT_ATTRIBUTES a_pa,
    PIO_STATUS_BLOCK a_sb,
    PLARGE_INTEGER a_pla,
    ULONG a_ul1,
    ULONG a_ul2,
    ULONG a_ul3,
    ULONG a_ul4,
    PVOID a_pv,
    ULONG a_ul5
)
{
    return m_pfnNtCreateFile(a_ph, a_am, a_pa, a_sb, a_pla, a_ul1, a_ul2,
                             a_ul3, a_ul4, a_pv, a_ul5);
}

NTSTATUS CNtDllApi::NtQuerySystemInformation
(
    SYSTEM_INFORMATION_CLASS a_SystemInformationClass,
    PVOID a_SystemInformation,
    ULONG a_SystemInformationLength,
    PULONG a_ReturnLength
)
{
    return m_pfnNtQuerySystemInformation(a_SystemInformationClass,
                                         a_SystemInformation,
                                         a_SystemInformationLength,
                                         a_ReturnLength);
}

NTSTATUS CNtDllApi::NtQueryDirectoryObject
(
    HANDLE a_DirectoryHandle,
    PVOID a_Buffer,
    ULONG a_Length,
    BOOLEAN a_ReturnSingleEntry,
    BOOLEAN a_RestartScan,
    PULONG a_Context,
    PULONG a_ReturnLength
)
{
    return m_pfnNtQueryDirectoryObject(a_DirectoryHandle,
                                       a_Buffer,
                                       a_Length,
                                       a_ReturnSingleEntry,
                                       a_RestartScan,
                                       a_Context,
                                       a_ReturnLength);
}

NTSTATUS CNtDllApi::NtQueryObject
(
    HANDLE a_Handle,
    OBJECT_INFORMATION_CLASS a_ObjectInformationClass,
    PVOID a_ObjectInformation,
    ULONG a_Length,
    PULONG a_ReturnLength
)
{
    return m_pfnNtQueryObject(a_Handle,
                              a_ObjectInformationClass,
                              a_ObjectInformation,
                              a_Length,
                              a_ReturnLength);
}

NTSTATUS CNtDllApi::NtOpenDirectoryObject
(
    PHANDLE a_DirectoryHandle,
    ACCESS_MASK a_DesiredAccess,
    POBJECT_ATTRIBUTES a_ObjectAttributes
)
{
    return m_pfnNtOpenDirectoryObject(a_DirectoryHandle,
                                      a_DesiredAccess,
                                      a_ObjectAttributes);
}

NTSTATUS CNtDllApi::NtQueryInformationProcess (

	IN HANDLE ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	OUT PVOID ProcessInformation,
	IN ULONG ProcessInformationLength,
	OUT PULONG ReturnLength OPTIONAL
)
{
	return m_pfnNtQueryInformationProcess (

		ProcessHandle,
		ProcessInformationClass,
		ProcessInformation,
		ProcessInformationLength,
		ReturnLength
	) ;
}

NTSTATUS CNtDllApi::NtQueryInformationToken (

	IN HANDLE TokenHandle,
	IN TOKEN_INFORMATION_CLASS TokenInformationClass,
	OUT PVOID TokenInformation,
	IN ULONG TokenInformationLength,
	OUT PULONG ReturnLength
)
{
	return m_pfnNtQueryInformationToken (

		TokenHandle,
		TokenInformationClass,
		TokenInformation,
		TokenInformationLength,
		ReturnLength
	) ;
}

NTSTATUS CNtDllApi::NtOpenFile (

	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG ShareAccess,
	IN ULONG OpenOptions
)
{
	return m_pfnNtOpenFile (

		FileHandle,
		DesiredAccess,
		ObjectAttributes,
		IoStatusBlock,
		ShareAccess,
		OpenOptions
	) ;
}

NTSTATUS CNtDllApi::NtClose (

	IN HANDLE Handle
)
{
	return m_pfnNtClose (

		Handle
	) ;
}

NTSTATUS CNtDllApi::NtFsControlFile (

	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG FsControlCode,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength
)
{
	return m_pfnNtFsControlFile (

		FileHandle,
		Event ,
		ApcRoutine ,
		ApcContext ,
		IoStatusBlock,
		FsControlCode,
		InputBuffer ,
		InputBufferLength,
		OutputBuffer ,
		OutputBufferLength
	) ;
}

NTSTATUS CNtDllApi::NtQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass)
{
    DWORD dwStatus = -1L;

    if(m_pfnNtQueryVolumeInformationFile)
    {
        dwStatus = m_pfnNtQueryVolumeInformationFile(
            FileHandle,
            IoStatusBlock,
            FsInformation,
            Length,
            FsInformationClass);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\perfdata.h ===
//============================================================

//

// PerfData.h - Performance Data helper class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 11/23/97     a-sanjes     created
//
//============================================================

#ifndef __PERFDATA_H__
#define __PERFDATA_H__

#include <winperf.h>

#ifdef NTONLY
class CPerformanceData
{
	public :

		CPerformanceData() ;
		~CPerformanceData() ;

		DWORD	Open( LPCTSTR pszValue, LPDWORD pdwType, LPBYTE *lppData, LPDWORD lpcbData );
//		void	Close( void );
      DWORD GetPerfIndex(LPCTSTR pszName);
      bool GetValue(DWORD dwObjIndex, DWORD dwCtrIndex, const WCHAR *szInstanceName, PBYTE pbData, unsigned __int64 *pTime);

	private:
		LONG RegQueryValueExExEx( HKEY hKey, LPTSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData ); 

		static bool m_fCloseKey;
        LPBYTE m_pBuff;
        
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\objaccessrights.h ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/





//=================================================================

//

// ObjAccessRights.CPP -- Class for obtaining effective access

//                      rights on a Obj.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/11/99    a-kevhu         Created
//
//=================================================================
#ifndef _COBJACCESSRIGHTS_H_
#define _COBJACCESSRIGHTS_H_


#ifdef NTONLY

class CObjAccessRights : public CAccessRights
{

    public:
        
        // Constructors and destructor...
        CObjAccessRights(bool fUseCurThrTok = false);
        CObjAccessRights(LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType, bool fUseCurThrTok = false);
        CObjAccessRights(const USER user, USER_SPECIFIER usp);
        CObjAccessRights(const USER user, LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType, USER_SPECIFIER usp);

        ~CObjAccessRights();

        // Useage functions...
        DWORD SetObj(LPCWSTR wstrObjName, SE_OBJECT_TYPE ObjectType);

    protected:


    private:

        CHString m_chstrObjName;

};


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\precomp.h ===
#pragma message("Precompiling header...")

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <fwcommon.h>
#include <smartptr.h>

#include <brodcast.h>
#include "dllutils.h"
#include "strings.h"
#include "ConfgMgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\perfdata.cpp ===
//=================================================================

//

// PerfData.CPP -- Performance Data Helper class

//

//  Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:   11/23/97    a-sanjes        Created
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "perfdata.h"
#include <cregcls.h>
#include <createmutexasprocess.h>

#ifdef NTONLY

// Static Initialization
bool    CPerformanceData::m_fCloseKey = false;

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::CPerformanceData
//
//  Default constructor
//
//  Inputs:
//              None
//
//  Outputs:
//              None
//
//  Returns:
//              None
//
//  Comments:
//
//////////////////////////////////////////////////////////

CPerformanceData::CPerformanceData( void )
{
    m_pBuff = NULL;
}

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::~CPerformanceData
//
//  Destructor
//
//  Inputs:
//              None
//
//  Outputs:
//              None
//
//  Returns:
//              None
//
//  Comments:
//
//////////////////////////////////////////////////////////

CPerformanceData::~CPerformanceData( void )
{
    if (m_pBuff != NULL)
    {
        delete [] m_pBuff;
    }
}


//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::RegQueryValueExExEx
//
//  Inputs: HKEY hKey handle of key to query
//          LPTSTR lpValueName, address of name of value to query
//          LPDWORD lpReserved reserved
//          LPDWORD lpType, address of buffer for value type
//          LPBYTE lpData address of data buffer
//          LPDWORD lpcbData address of data buffer size
//
//
//  Returns: everything documented by RegQueryValueEx AND ERROR_SEM_TIMEOUT or ERROR_OPEN_FAILED
//
//  Comments: passthrough to RegQueryValueEx except that it wraps a mutex around the call
//            currently unused - left in in case the problem ever reappears.
//
//////////////////////////////////////////////////////////
LONG CPerformanceData::RegQueryValueExExEx( HKEY hKey, LPTSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    LONG ret = -1;

    // need this mutex because we can deadlock with a performance data DLL loading up.
    // something to the effect that both dlls want the crit sect for the registry

    CreateMutexAsProcess createMutexAsProcess(WBEMPERFORMANCEDATAMUTEX);

    ret = RegQueryValueEx( hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    return ret;
}

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::Open
//
//  Opens and retrieves data from the performance data
//  registry key.
//
//  Inputs:
//              LPCTSTR pszValue    - Value to retrieve
//
//  Outputs:
//              LPDWORD pdwType     - Type returned
//              LPBYTE  lpData      - Buffer
//              LPDWORD lpcbData    - Amount of data returned
//
//  Returns:
//              ERROR_SUCCESS if successful
//
//  Comments:
//
//////////////////////////////////////////////////////////

DWORD CPerformanceData::Open( LPCTSTR pszValue, LPDWORD pdwType, LPBYTE *lppData, LPDWORD lpcbData )
{
    DWORD   dwReturn = ERROR_OUTOFMEMORY;
    BOOL    fStackTrashed = FALSE;
    LogMessage(_T("CPerformanceData::Open"));

    LPCTSTR     pszOldValue     =   pszValue;
    LPDWORD     pdwOldType      =   pdwType;
    LPBYTE*     lppOldData      =   lppData;
    LPDWORD     lpcbOldData     =   lpcbData;

    ASSERT_BREAK(*lppData == NULL);

    {

        // This brace is important for scoping the mutex.  Do not remove!
        {
            // need this mutex because we can deadlock with a performance data DLL loading up.
            // something to the effect that both dlls want the crit sect for the registry
            CreateMutexAsProcess createMutexAsProcess(WBEMPERFORMANCEDATAMUTEX);

            DWORD dwSize = 16384;
            *lpcbData = dwSize;
            *lppData = new byte [*lpcbData];

            if (*lppData == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            if (    pszOldValue     !=  pszValue
                ||  pdwOldType      !=  pdwType
                ||  lppOldData      !=  lppData
                ||  lpcbOldData     !=  lpcbData    )
            {
                LogErrorMessage(_T("CPerformanceData::stack trashed after malloc"));
                fStackTrashed = TRUE;
                ASSERT_BREAK(0);
            }
            else
            {

                try
                {
                    while ((*lppData != NULL) &&
                        // remember precedence & associativity?
                        ((dwReturn = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                        (LPTSTR)pszValue,
                        NULL,
                        pdwType,
                        (LPBYTE) *lppData,
                        lpcbData )) == ERROR_MORE_DATA)

                        )
                    {

                        if (    pszOldValue     !=  pszValue
                            ||  pdwOldType      !=  pdwType
                            ||  lppOldData      !=  lppData
                            ||  lpcbOldData     !=  lpcbData    )
                        {
                            LogErrorMessage(_T("CPerformanceData::stack trashed after RegQueryValueEx"));
                            fStackTrashed = TRUE;
                            ASSERT_BREAK(0);
                            break;
                        }

                        // Get a buffer that is big enough.
                        LogMessage(_T("CPerformanceData::realloc"));
                        dwSize += 16384;
                        *lpcbData = dwSize ;

                        if (    pszOldValue     !=  pszValue
                            ||  pdwOldType      !=  pdwType
                            ||  lppOldData      !=  lppData
                            ||  lpcbOldData     !=  lpcbData    )
                        {
                            LogErrorMessage(_T("CPerformanceData::stack trashed after size reset"));
                            fStackTrashed = TRUE;
                            ASSERT_BREAK(0);
                            break;
                        }
                        delete [] *lppData;
                        *lppData = new BYTE [*lpcbData];
                        if (*lppData == NULL)
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }

                        if (    pszOldValue     !=  pszValue
                            ||  pdwOldType      !=  pdwType
                            ||  lppOldData      !=  lppData
                            ||  lpcbOldData     !=  lpcbData    )
                        {
                            LogErrorMessage(_T("CPerformanceData::stack trashed after realloc"));
                            fStackTrashed = TRUE;
                            ASSERT_BREAK(0);
                            break;
                        }

                    }   // While
                }
                catch ( ... )
                {
                    if (*lppData != NULL)
                    {
                        delete [] *lppData;
                    }
                    throw ;
                }
            }

            if ( fStackTrashed )
            {
                dwReturn = ERROR_INVALID_FUNCTION;
            }
            else
            {
                // if we got here in an error condition, try to recoup
                if ((dwReturn != ERROR_SUCCESS)
                    &&
                    (*lppData != NULL))
                {
                    LogErrorMessage(_T("CPerformanceData::failed to alloc enough memory"));
                    delete [] *lppData;
                    *lppData = NULL;
                }

                if (!m_fCloseKey)
                {
                    m_fCloseKey = ( ERROR_SUCCESS == dwReturn );
                    if (m_fCloseKey)
                        LogMessage(_T("Opened perf counters"));
                }

                if ((dwReturn != ERROR_SUCCESS) && IsErrorLoggingEnabled())
                {
                    CHString sTemp;
                    sTemp.Format(_T("Performance RegQueryValueEx returned %d\n"), dwReturn);
                    LogErrorMessage(sTemp);
                }

                if (*lppData == NULL)
                {
                    dwReturn = ERROR_OUTOFMEMORY;
                }

            }
        }
    } // if we're on NT

    return dwReturn;

}

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::Close
//
//  Closes the performance data registry key if the
//  static value is TRUE.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
//  Per the KB, calling RegCloseKey on HKEY_PERFORMANCE_DATA
//  causes a memory leak, so you do NOT want to do lots of
//  these.
//
//////////////////////////////////////////////////////////
#if 0 // From raid 48395
void CPerformanceData::Close( void )
{

    // If we need to close the performance data, use a key to synchronize
    // the opens/closes.

    if ( m_fCloseKey )
    {
        // need this mutex because we can deadlock with a performance data DLL loading up.
        // something to the effect that both dlls want the crit sect for the registry
        CreateMutexAsProcess createMutexAsProcess(WBEMPERFORMANCEDATAMUTEX);

        if ( m_fCloseKey )
        {
            RegCloseKey( HKEY_PERFORMANCE_DATA );
            m_fCloseKey = FALSE;
            LogMessage(_T("Closed Perf Counters"));
        }
    }
}
#endif
//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::GetPerfIndex
//
//  Given a perf object name, this function returns
// the perf object number.
//
//  Inputs:
//              Object name
//
//  Outputs:
//              None
//
//  Returns:
//              Associated Number or 0 on error.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////
DWORD CPerformanceData::GetPerfIndex(LPCTSTR pszName)
{
    DWORD dwRetVal = 0;

    if (m_pBuff == NULL)
    {
        LONG lRet = ERROR_SUCCESS;

        if (m_pBuff == NULL)
        {
			CRegistry RegInfo;

            // Hardcoding 009 should be ok since according to the docs:
            // "The langid is the ASCII representation of the 3-digit hexadecimal language identifier. "
            // "For example, the U.S. English langid is 009. In a non-English version of Windows NT, "
            // "counters are stored in both the native language of the system and in English. "

            if ((lRet = RegInfo.Open(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009"), KEY_QUERY_VALUE)) == ERROR_SUCCESS)
            {
                // Get the size of the key
                DWORD dwSize;
                lRet = RegInfo.GetCurrentBinaryKeyValue(_T("Counter"), NULL, &dwSize);
                if (lRet == ERROR_SUCCESS)
                {
                    // Allocate a buffer to hold it
                    m_pBuff = new BYTE[dwSize];

                    if (m_pBuff != NULL)
                    {
                        // Get the actual data
                        if ((lRet = RegInfo.GetCurrentBinaryKeyValue(_T("Counter"), m_pBuff, &dwSize)) != ERROR_SUCCESS)
                        {
                            delete [] m_pBuff;
                            m_pBuff = NULL;
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }
            }
        }  // Exit the mutex

        if (lRet != ERROR_SUCCESS)
        {
            LogErrorMessage2(L"Failed to read Perflib key: %x", lRet);
        }
    }

    // If we got the registry key
    if (m_pBuff != NULL)
    {
        const TCHAR *pCounter;
        const TCHAR *ptemp;
        int stringlength;

        pCounter = (TCHAR *)m_pBuff;
        stringlength = _tcslen((LPCTSTR)pCounter);

        // Exit the loop when we hit the end
        while(stringlength)
        {
            // Strings are stored in the form <counternumber>\0<countername>\0.
            // What we want to return is the counter number.  ptemp will point to the name
            ptemp = pCounter + stringlength+1;
            stringlength = _tcslen((LPCTSTR)ptemp);

            if (stringlength > 0)
            {
                // Did we find it
                if (_tcscmp((TCHAR *)ptemp, pszName) != 0)
                {
                    // Nope, position to the next pair
                    pCounter = ptemp + stringlength+1;
                    stringlength = _tcslen((LPCTSTR)pCounter);
                }
                else
                {
                    // Yup, calculate the value to return
                    dwRetVal = _ttoi(pCounter);
                    break;
                }
            }
        }
    }

    ASSERT_BREAK(dwRetVal > 0);

    return dwRetVal;

}

//////////////////////////////////////////////////////////
//
//  Function:   CPerformanceData::GetValue
//
//  Given a perf object index, counter index, and optional
//      instance name, returns the value and the time.
//
//  Inputs:
//              Value, Time
//
//  Outputs:
//              Value, Time
//
//  Returns:
//              True if it finds the value
//
//  Comments:
//
//
//////////////////////////////////////////////////////////
bool CPerformanceData::GetValue(DWORD dwObjIndex, DWORD dwCtrIndex, const WCHAR *szInstanceName, PBYTE pbData, unsigned __int64 *pTime)
{
   PPERF_DATA_BLOCK PerfData = NULL;
   DWORD            dwBufferSize = 0;
   LONG             lReturn = 0;
   BOOL             fReturn = FALSE;
   TCHAR szBuff[MAXITOA];
   bool bFound = false;
   PPERF_INSTANCE_DEFINITION pInstBlock;
   DWORD dwInstances;
   unsigned __int64 *pbCounterData;

   // The subsequent close happens in our destructor (read comment there).
   lReturn = Open( _itot(dwObjIndex, szBuff, 10),
      NULL,
      (LPBYTE *) (&PerfData),
      &dwBufferSize );

   if ( NULL            !=  PerfData
      &&    ERROR_SUCCESS   ==  lReturn )
   {

       try
       {
          // Surf through the objects returned until we find the one we are looking for.
          PPERF_OBJECT_TYPE         pPerfObject = (PPERF_OBJECT_TYPE)((PBYTE)PerfData + PerfData->HeaderLength);

          for ( DWORD       dwObjectCtr = 0;

             dwObjectCtr    < PerfData->NumObjectTypes
             && pPerfObject->ObjectNameTitleIndex != dwObjIndex;

             dwObjectCtr++ );

          // Did we find the Object?
          if ( dwObjectCtr < PerfData->NumObjectTypes )
          {

             // Now surf through the Counter Definition Data until we locate the
             // counter we are hunting for.

             PPERF_COUNTER_DEFINITION   pPerfCtrDef = (PPERF_COUNTER_DEFINITION)((PBYTE) pPerfObject + pPerfObject->HeaderLength);

             for (  DWORD   dwCtr   =   0;

                dwCtr < pPerfObject->NumCounters
                &&  pPerfCtrDef->CounterNameTitleIndex != dwCtrIndex;

                dwCtr++,

                // Go to the next counter
                pPerfCtrDef = (PPERF_COUNTER_DEFINITION)((PBYTE) pPerfCtrDef + pPerfCtrDef->ByteLength )

                );

             // Did we find the counter?
             if ( dwCtr < pPerfObject->NumCounters )
             {
                // Finally go to the data offset we retrieved from the counter definitions
                // and access the data (finally).

                DWORD   dwCounterOffset = pPerfCtrDef->CounterOffset;
                PPERF_COUNTER_BLOCK pPerfCtrBlock = NULL;

                // If we are looking for an instance
                if ((szInstanceName == NULL) && (pPerfObject->NumInstances == PERF_NO_INSTANCES))
                {
                   pPerfCtrBlock = (PPERF_COUNTER_BLOCK) ((PBYTE) pPerfObject + pPerfObject->DefinitionLength);
                   bFound = true;
                }
                else if (pPerfObject->NumInstances != PERF_NO_INSTANCES)
                {
                   // Walk the instances looking for the requested one
                   pInstBlock = (PPERF_INSTANCE_DEFINITION) ((PBYTE)pPerfObject + pPerfObject->DefinitionLength);
                   dwInstances = 1;
                   while ((dwInstances <= pPerfObject->NumInstances) &&
                          (wcscmp((WCHAR *)((pInstBlock->NameOffset) + (PBYTE)pInstBlock), szInstanceName) != 0))
                   {
                         pPerfCtrBlock = (PPERF_COUNTER_BLOCK) ((PBYTE)pInstBlock + pInstBlock->ByteLength);
                         pInstBlock = (PPERF_INSTANCE_DEFINITION)((PBYTE) pInstBlock + (pInstBlock->ByteLength + pPerfCtrBlock->ByteLength));
                         dwInstances ++;
                   }

                   // Did we find it?
                   if (dwInstances <= pPerfObject->NumInstances)
                   {
                      bFound = true;
                      pPerfCtrBlock = (PPERF_COUNTER_BLOCK) ((PBYTE)pInstBlock + pInstBlock->ByteLength);
                   }
                }

                // Grab the appropriate time field based on the counter definition
                if (bFound) {
                   if (pPerfCtrDef->CounterType & PERF_TIMER_100NS)
                   {
                      *pTime = PerfData->PerfTime100nSec.QuadPart;
                   }
                   else
                   {
                      // Unverified
                      *pTime = PerfData->PerfTime.QuadPart;
                   }

                   // Get a pointer to the data, then copy in the correct number of bytes (based on counter def)
                   pbCounterData = (unsigned __int64 *)(((PBYTE) pPerfCtrBlock ) + dwCounterOffset);
                   if (pPerfCtrDef->CounterType & PERF_SIZE_DWORD)
                   {
                      memcpy(pbData, pbCounterData, 4);
                   }
                   else if (pPerfCtrDef->CounterType & PERF_SIZE_LARGE)
                   {
                      memcpy(pbData, pbCounterData, 8);
                   }
                }

             }  // If Counter Definition found

          } // If Object found

       }    // If memory allocated
       catch ( ... )
       {
          delete [] PerfData ;
          throw ;
       }
   }

   // Free up any transient memory
   if ( NULL != PerfData )
   {
      delete [] PerfData ;
   }

   ASSERT_BREAK(bFound);

   return bFound;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\poormansresource.h ===
/////////////////////////////////////////////////////////////////////////

//

//  poormansresource.h    

//  

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//				06/05/98		Sanj		Removed extraneous definitions.
//  
/////////////////////////////////////////////////////////////////////////


#ifndef __POORMANSRESOURCE_H__
#define __POORMANSRESOURCE_H__

#include "cfgmgr32.h"

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

struct	Mem_Des16_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des16_s 	MEM_DES16;

struct	IO_Des16_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des16_s 	IO_DES16;

struct	DMA_Des16_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des16_s 	DMA_DES16;

struct	IRQ_Des16_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des16_s 	IRQ_DES16;

typedef	MEM_DES16			*PMEM_DES16;
typedef	IO_DES16			*PIO_DES16;
typedef	DMA_DES16			*PDMA_DES16;
typedef	IRQ_DES16			*PIRQ_DES16;

// BUS Info structs from KBASE
typedef struct PnPAccess_s    {
       BYTE    bCSN;   // card slot number
       BYTE    bLogicalDevNumber;      // Logical Device #
       WORD    wReadDataPort;          // Read data port
} sPnPAccess;

typedef struct  PCIAccess_s     {
       BYTE    bBusNumber;     // Bus no 0-255
       BYTE    bDevFuncNumber; // Device # in bits 7:3 and
                               // Function # in bits 2:0
       WORD    wPCIReserved;   //
} sPCIAccess;

typedef struct EISAAccess_s     {
       BYTE    bSlotNumber;    // EISA board slot number
       BYTE    bFunctionNumber;
       WORD    wEisaReserved;
} sEISAAccess;

typedef struct PCMCIAAccess_s   {
       WORD    wLogicalSocket;     // Card socket #
       WORD    wPCMCIAReserved;    // Reserved
} sPCMCIAAccess;

typedef struct BIOSAccess_s     {
       BYTE    bBIOSNode;          // Node number
} sBIOSAccess;

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040

/*********************************************************************

  The following information was not copied, it is information I pieced
  together on my own.  It probably exists somewhere but I was too
  lazy to find it, so I pieced it together myself.

**********************************************************************/

// OKAY, Here's my definition of the header that precedes each and every resource
// descriptor as far as I can tell.

// This is the size (as far as I can tell) of the resource header that precedes
// each resource descriptor.  The header consists of a DWORD indicating the total
// size of the resource (including the header), a WORD which is the 16-bit Resource
// Id being described, and a byte of padding.

#pragma pack (1)
struct	POORMAN_RESDESC_HDR		// Hacked out with much pain and frustration
{
	DWORD	dwResourceSize;		// Size of resource including header
	DWORD	dwResourceId;		// Resource Id
};
#pragma pack()

typedef POORMAN_RESDESC_HDR*	PPOORMAN_RESDESC_HDR;

#define	SIZEOF_RESDESC_HDR		sizeof(POORMAN_RESDESC_HDR)

#define	FIRST_RESOURCE_OFFSET	8	// Offset off first resource

// Use to mask out all values other than Resource Type (first 5 bits)
#define	RESOURCE_TYPE_MASK		0x0000001F

// Use to mask out all values other than OEM Number
#define	OEM_NUMBER_MASK		0x00007FE0

/*XLATOFF*/
#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
/*XLATON*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\profilestring.h ===
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved

#ifndef	__PROFILE_STRING__
#define	__PROFILE_STRING__

#if	_MSC_VER > 1000
#pragma once
#endif

// MAPPINGS
#define MY_SHARED_PTR(TYPE_NAME) ULONG_PTR
#define MY_SHARED_STRING LPWSTR 

#define REGISTRY_MAPPING_WRITE_TO_INIFILE_TOO    0x00000001
#define REGISTRY_MAPPING_INIT_FROM_INIFILE       0x00000002
#define REGISTRY_MAPPING_READ_FROM_REGISTRY_ONLY 0x00000004
#define REGISTRY_MAPPING_APPEND_BASE_NAME        0x10000000
#define REGISTRY_MAPPING_APPEND_APPLICATION_NAME 0x20000000
#define REGISTRY_MAPPING_SOFTWARE_RELATIVE       0x40000000
#define REGISTRY_MAPPING_USER_RELATIVE           0x80000000

typedef struct _REGISTRY_MAPPING_TARGET
{
    MY_SHARED_PTR(struct _REGISTRY_MAPPING_TARGET *) Next;
    MY_SHARED_STRING RegistryPath;
} REGISTRY_MAPPING_TARGET, *PREGISTRY_MAPPING_TARGET;

typedef struct _REGISTRY_MAPPING_VARNAME
{
    MY_SHARED_PTR(struct _REGISTRY_MAPPING_VARNAME *) Next;
    MY_SHARED_STRING Name;
    ULONG MappingFlags;
    MY_SHARED_PTR(PREGISTRY_MAPPING_TARGET) MappingTarget;
} REGISTRY_MAPPING_VARNAME, *PREGISTRY_MAPPING_VARNAME;

typedef struct _REGISTRY_MAPPING_APPNAME
{
    MY_SHARED_PTR(struct _REGISTRY_MAPPING_APPNAME *) Next;
    MY_SHARED_STRING Name;
    MY_SHARED_PTR(PREGISTRY_MAPPING_VARNAME) VariableNames;
    MY_SHARED_PTR(PREGISTRY_MAPPING_VARNAME) DefaultVarNameMapping;
} REGISTRY_MAPPING_APPNAME, *PREGISTRY_MAPPING_APPNAME;

typedef struct _REGISTRY_MAPPING_NAME
{
    MY_SHARED_PTR(struct _REGISTRY_MAPPING_NAME *) Next;
    MY_SHARED_STRING Name;
    MY_SHARED_PTR(PREGISTRY_MAPPING_APPNAME) ApplicationNames;
    MY_SHARED_PTR(PREGISTRY_MAPPING_APPNAME) DefaultAppNameMapping;
} REGISTRY_MAPPING_NAME, *PREGISTRY_MAPPING_NAME;

typedef struct _REGISTRY_MAPPING
{
	MY_SHARED_PTR(PREGISTRY_MAPPING_NAME) MyRegistryMapping;
	ULONG Reserved;

} REGISTRY_MAPPING, *PREGISTRY_MAPPING;

// operation enum
typedef enum _REGISTRY_OPERATION
{
    Registry_None,
	Registry_ReadKeyValue,
    Registry_ReadKeyName,
    Registry_ReadSectionValue,
    Registry_ReadSectionName

} REGISTRY_OPERATION;

// parameters
typedef struct _REGISTRY_PARAMETERS
{
	#ifdef	WRITE_OPERATION
	BOOLEAN					WriteOperation;
	#endif	WRITE_OPERATION

	REGISTRY_OPERATION		Operation;
	BOOLEAN					MultiValueStrings;
	BOOLEAN					ValueBufferAllocated;
	PREGISTRY_MAPPING_NAME	Mapping;

	LPCWSTR					FileName;
	LPCWSTR					ApplicationName;
	LPCWSTR					VariableName;

	union
	{
		#ifdef	WRITE_OPERATION
		//
		// This structure filled in for write operations
		//
		struct
		{
			LPWSTR	ValueBuffer;
			ULONG	ValueLength;
		};
		#endif	WRITE_OPERATION

		//
		// This structure filled in for read operations
		//
		struct
		{
			ULONG	ResultChars;		// number of characters
			ULONG	ResultMaxChars;		// number of max characters
			LPWSTR	ResultBuffer;
		};
	};

} REGISTRY_PARAMETERS, *PREGISTRY_PARAMETERS;

#endif	__PROFILE_STRING__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\profilestringimpl.h ===
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved

#ifndef	__PROFILE_STRING_IMPL__
#define	__PROFILE_STRING_IMPL__

#if	_MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
// get profile string
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_PrivateProfileString	(
															LPCWSTR	lpAppName,
															LPCWSTR	lpKeyName,
															LPCWSTR	lpDefault,
															LPWSTR	lpReturnedString,
															DWORD	nSize,
															LPCWSTR	lpFileName
														);

DWORD	APIENTRY	WMIRegistry_ProfileString	(
													LPCWSTR lpAppName,
													LPCWSTR lpKeyName,
													LPCWSTR lpDefault,
													LPWSTR lpReturnedString,
													DWORD nSize
												);

///////////////////////////////////////////////////////////////////////////////
// get profile section
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_PrivateProfileSection	(
															LPCWSTR	lpAppName,
															LPWSTR	lpReturnedString,
															DWORD	nSize,
															LPCWSTR	lpFileName
														);

DWORD	APIENTRY	WMIRegistry_ProfileSection	(
													LPCWSTR lpAppName,
													LPWSTR lpReturnedString,
													DWORD nSize
												);

///////////////////////////////////////////////////////////////////////////////
// get profile integer
///////////////////////////////////////////////////////////////////////////////
UINT	APIENTRY	WMIRegistry_PrivateProfileInt	(
														LPCWSTR lpAppName,
														LPCWSTR lpKeyName,
														INT nDefault
													);

UINT	APIENTRY	WMIRegistry_ProfileInt	(
												LPCWSTR lpAppName,
												LPCWSTR lpKeyName,
												INT nDefault
											);

#endif	__PROFILE_STRING_IMPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\refptrlite.cpp ===
//=================================================================

//

// refptrlite.CPP - Implementation of CRefPtrLite class

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/15/97    a-sanjes        Created
//
//=================================================================

#include "precomp.h"
#include <assertbreak.h>
#include "refptrlite.h"

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::CRefPtrLite
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CRefPtrLite::CRefPtrLite( void )
:	m_lRefCount( 1 )	// Our initial ref count is always 1
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::~CRefPtrLite
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CRefPtrLite::~CRefPtrLite( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::OnFinalRelease
//
//	Virtual function called by Release() when our RefCount reaches 0.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	Override if you want, but always call down to the base
//				implementation and let it call delete on 'this'.
//
////////////////////////////////////////////////////////////////////////

void CRefPtrLite::OnFinalRelease( void )
{
	delete this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::AddRef
//
//	Increases our Reference count by one.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////

LONG CRefPtrLite::AddRef( void )
{
	LONG nRet = InterlockedIncrement(&m_lRefCount);

	return nRet;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtrLite::Release
//
//	Decreases our Reference count by one.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:
//
////////////////////////////////////////////////////////////////////////

LONG CRefPtrLite::Release( void )
{
	LONG nRet;

	BOOL	fFinalRelease = ( (nRet = InterlockedDecrement(&m_lRefCount)) == 0 );

    ASSERT_BREAK(nRet >= 0);

	if ( fFinalRelease )
	{
		OnFinalRelease();
	}

	return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\refptrlite.h ===
//=================================================================

//

// ThreadBase.h - Definition of Referenced Pointer class

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    10/15/97    Created
//
//=================================================================

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __REFPTRLITE_H__
#define __REFPTRLITE_H__

class CRefPtrLite
{
public:

	// Construction/Destruction
	CRefPtrLite();
	virtual ~CRefPtrLite();

	// Ref/Counting functions
	LONG	AddRef( void );
	LONG	Release( void );

protected:

	virtual void	OnFinalRelease( void );

private:

	LONG					m_lRefCount;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\profilestring.cpp ===
// Copyright (c) 2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include "profilestring.h"
#include "profilestringimpl.h"

/////////////////////////////////////////////////////////////////////////////////////////
// TOOLS
/////////////////////////////////////////////////////////////////////////////////////////
DWORD	WMIREG_GetBaseFileName ( IN LPCWSTR FileName, OUT LPWSTR* BaseFileName )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( FileName && BaseFileName )
	{
		*BaseFileName = NULL;

		LPWSTR wsz = NULL;
		wsz = const_cast < LPWSTR > ( FileName ) + wcslen ( FileName );

		while ( --wsz > FileName )
		{
			if ( *wsz == OBJ_NAME_PATH_SEPARATOR || *wsz == L'/' || *wsz == L':' )
			{
				wsz++;
				break;
			}
		}

		if ( wsz )
		{
			try
			{
				if ( ( *BaseFileName = new WCHAR [ wcslen ( wsz ) + 1 ] ) != NULL )
				{
					wcscpy ( *BaseFileName, wsz );
					Status = ERROR_SUCCESS;
				}
				else
				{
					Status = ERROR_NOT_ENOUGH_MEMORY;
				}
			}
			catch ( ... )
			{
				if ( *BaseFileName )
				{
					delete [] *BaseFileName;
					*BaseFileName = NULL;
				}

				Status = ERROR_GEN_FAILURE;
			}
		}
	}

	return Status;
}

BOOLEAN	WMIREG_GetApplicationName	(
										IN PREGISTRY_PARAMETERS a,
										OUT LPCWSTR *ApplicationNameU
									)
{
	if ( ApplicationNameU )
	{
		*ApplicationNameU = a->ApplicationName;
		return TRUE;
	}

    return FALSE;
}

BOOLEAN	WMIREG_GetVariableName	(
									IN PREGISTRY_PARAMETERS a,
									OUT LPCWSTR *VariableNameU
								)
{
	if ( VariableNameU )
	{
		*VariableNameU = a->VariableName;
		return TRUE;
	}

	return FALSE;
}

// get appname mapping
PREGISTRY_MAPPING_NAME	WMIREG_FindMapping	(
												IN PREGISTRY_MAPPING_NAME NameMapping,
												IN LPCWSTR MappingName
											)
{
    PREGISTRY_MAPPING_NAME Mapping	= NULL;
    Mapping = NameMapping;

    while ( Mapping != NULL )
	{
		try
		{
			if ( wcslen( Mapping->Name ) == wcslen( MappingName ) )
			{
				if ( _wcsnicmp ( Mapping->Name, MappingName, wcslen( MappingName ) ) == 0 )
				{
					break;
				}
			}

			Mapping = (PREGISTRY_MAPPING_NAME)Mapping->Next;
		}
		catch ( ... )
		{
			Mapping = NULL;
		}
    }

	return Mapping;
}

// get appname mapping
PREGISTRY_MAPPING_APPNAME	WMIREG_FindAppNameMapping	(
															IN PREGISTRY_MAPPING_NAME NameMapping,
															IN LPCWSTR ApplicationName
														)
{
    PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
    AppNameMapping = (PREGISTRY_MAPPING_APPNAME)NameMapping->ApplicationNames;

    while ( AppNameMapping != NULL )
	{
		try
		{
			if ( wcslen( AppNameMapping->Name ) == wcslen( ApplicationName ) )
			{
				if ( _wcsnicmp ( AppNameMapping->Name, ApplicationName, wcslen( ApplicationName ) ) == 0 )
				{
					break;
				}
			}

			AppNameMapping = (PREGISTRY_MAPPING_APPNAME)AppNameMapping->Next;
		}
		catch ( ... )
		{
			AppNameMapping = NULL;
		}
    }

	if ( !AppNameMapping )
	{
		AppNameMapping = (PREGISTRY_MAPPING_APPNAME)NameMapping->DefaultAppNameMapping;
	}

	return AppNameMapping;
}

//get varname mapping
PREGISTRY_MAPPING_VARNAME	WMIREG_FindVarNameMapping	(
															IN PREGISTRY_MAPPING_APPNAME AppNameMapping,
															IN LPCWSTR VariableName
														)
{
	PREGISTRY_MAPPING_VARNAME VarNameMapping	= NULL;
	VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->VariableNames;

	while ( VarNameMapping != NULL )
	{
		try
		{
			if ( wcslen ( VarNameMapping->Name ) == wcslen( VariableName ) )
			{
				if ( _wcsnicmp ( VarNameMapping->Name, VariableName, wcslen( VariableName ) ) == 0 )
				{
					break;
				}
			}

			VarNameMapping = (PREGISTRY_MAPPING_VARNAME)VarNameMapping->Next;
		}
		catch ( ... )
		{
			VarNameMapping = NULL;
		}
	}

	if ( !VarNameMapping )
	{
		VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
	}

	return VarNameMapping;
}

// get string representing user's registry
BOOL	WMIREG_UserPROFILE	( UNICODE_STRING * UserKeyPath )
{
	OBJECT_ATTRIBUTES ObjectAttributes;
	HANDLE Key	= NULL;

	if ( NT_SUCCESS ( RtlFormatCurrentUserKeyPath( UserKeyPath ) ) )
	{
		InitializeObjectAttributes	(	&ObjectAttributes,
										UserKeyPath,
										OBJ_CASE_INSENSITIVE,
										NULL,
										NULL
									);

		if ( NT_SUCCESS ( NtOpenKey( &Key, GENERIC_READ, &ObjectAttributes ) ) )
		{
			NtClose( Key );
		}
		else
		{
			RtlFreeUnicodeString( UserKeyPath );
			RtlInitUnicodeString( UserKeyPath, NULL );
		}
	}

	if ( UserKeyPath->Length == 0)
	{
		if ( !RtlCreateUnicodeString ( UserKeyPath, L"\\REGISTRY\\USER\\.DEFAULT"  ) )
		{
			return FALSE;
		}
	}

	return TRUE;
}

// open registry key
DWORD	WMIREG_OpenMappingTarget	(
										IN PREGISTRY_PARAMETERS a,
										IN PREGISTRY_MAPPING_VARNAME VarNameMapping,
										IN LPCWSTR ApplicationName,
										OUT PHANDLE Key
									)
{
	DWORD Status	= ERROR_INVALID_PARAMETER;

	PREGISTRY_MAPPING_TARGET	MappingTarget	= NULL;
	ULONG						MappingFlags	= 0L;

	BOOLEAN AppendApplicationName	= FALSE;

	OBJECT_ATTRIBUTES ObjectAttributes;

	PUNICODE_STRING RegistryPathPrefix = NULL;
	UNICODE_STRING RegistryPath;

	UNICODE_STRING UserKeyPath;
	UNICODE_STRING SoftwareKeyPath;

	// initialization of strings
    RtlInitUnicodeString( &UserKeyPath, NULL );
    RtlInitUnicodeString( &SoftwareKeyPath, L"\\Registry\\Machine\\Software" );

	// temporary unicode_string
	UNICODE_STRING temp;

	ULONG n	= 0L;	// size of reg key

	// init key
	*Key = INVALID_HANDLE_VALUE;

	// get mapping
	MappingTarget = (PREGISTRY_MAPPING_TARGET)VarNameMapping->MappingTarget;
	MappingFlags = VarNameMapping->MappingFlags &	(	REGISTRY_MAPPING_APPEND_BASE_NAME |
														REGISTRY_MAPPING_APPEND_APPLICATION_NAME |
														REGISTRY_MAPPING_SOFTWARE_RELATIVE |
														REGISTRY_MAPPING_USER_RELATIVE
													);

	if ( MappingTarget != NULL && MappingTarget->RegistryPath )
	{
		// everything's ok
		Status = ERROR_SUCCESS;

		if ( ApplicationName && ( MappingFlags & REGISTRY_MAPPING_APPEND_APPLICATION_NAME ) )
		{
			AppendApplicationName = TRUE;
		}
		else
		{
			AppendApplicationName = FALSE;
		}

		if ( MappingFlags & REGISTRY_MAPPING_USER_RELATIVE )
		{
			if ( WMIREG_UserPROFILE ( &UserKeyPath ) )
			{
				if ( UserKeyPath.Length == 0 )
				{
					Status = ERROR_ACCESS_DENIED;
				}
			}
			else
			{
				Status = ERROR_INVALID_PARAMETER;
			}

			if ( Status == ERROR_SUCCESS )
			{
				RegistryPathPrefix = &UserKeyPath;
			}
		}
		else
		if ( MappingFlags & REGISTRY_MAPPING_SOFTWARE_RELATIVE )
		{
			RegistryPathPrefix = &SoftwareKeyPath;
		}
		else
		{
			RegistryPathPrefix = NULL;
		}

		if ( Status == ERROR_SUCCESS )
		{
			LPWSTR BaseFileName = NULL;

			if ( MappingFlags & REGISTRY_MAPPING_APPEND_BASE_NAME )
			{
				Status = WMIREG_GetBaseFileName ( a->FileName, &BaseFileName );
			}

			if ( Status == ERROR_SUCCESS )
			{
				if ( RegistryPathPrefix )
				{
					n = RegistryPathPrefix->Length + sizeof( WCHAR );
				}

				n += sizeof( WCHAR ) + wcslen ( MappingTarget->RegistryPath ) * sizeof ( WCHAR );
				if ( MappingFlags & REGISTRY_MAPPING_APPEND_BASE_NAME )
				{
					n += sizeof( WCHAR ) + wcslen ( BaseFileName ) * sizeof ( WCHAR );
				}

				if (AppendApplicationName)
				{
					n += sizeof( WCHAR ) + wcslen ( ApplicationName ) * sizeof ( WCHAR );
				}

				n += sizeof( UNICODE_NULL );

				RegistryPath.Buffer = reinterpret_cast < LPWSTR > ( RtlAllocateHeap( RtlProcessHeap(), 0, n ) );
				if (RegistryPath.Buffer == NULL)
				{
					Status = ERROR_NOT_ENOUGH_MEMORY;
				}

				if ( Status == ERROR_SUCCESS )
				{
					RegistryPath.Length = 0;
					RegistryPath.MaximumLength = (USHORT)n;

					if (RegistryPathPrefix != NULL)
					{
						RtlAppendUnicodeStringToString( &RegistryPath, RegistryPathPrefix );
						RtlAppendUnicodeToString( &RegistryPath, L"\\" );
					}

					RtlInitUnicodeString( &temp, MappingTarget->RegistryPath );
					RtlAppendUnicodeStringToString( &RegistryPath, &temp );
					RtlInitUnicodeString( &temp, NULL );

					if (MappingFlags & REGISTRY_MAPPING_APPEND_BASE_NAME)
					{
						RtlAppendUnicodeToString( &RegistryPath, L"\\" );

						RtlInitUnicodeString( &temp, BaseFileName );
						RtlAppendUnicodeStringToString( &RegistryPath, &temp );
						RtlInitUnicodeString( &temp, NULL );
					}

					if (AppendApplicationName)
					{
						RtlAppendUnicodeToString( &RegistryPath, L"\\" );

						RtlInitUnicodeString( &temp, ApplicationName );
						RtlAppendUnicodeStringToString( &RegistryPath, &temp );
						RtlInitUnicodeString( &temp, NULL );
					}

					// open real registry
					InitializeObjectAttributes	(	&ObjectAttributes,
													&RegistryPath,
													OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
													NULL,
													NULL
												);

					Status = NtOpenKey	( Key, GENERIC_READ, &ObjectAttributes );

					// clear registry path
					RtlFreeHeap( RtlProcessHeap(), 0, RegistryPath.Buffer );
				}
			}

			// clear use string
			if ( UserKeyPath.Length )
			{
				RtlFreeUnicodeString ( &UserKeyPath );
			}

			if ( BaseFileName )
			{
				delete [] BaseFileName;
			}
		}
	}

	return Status;
}

// append string to result buffer
DWORD	REGISTRY_AppendBufferToResultBuffer	(
												IN PREGISTRY_PARAMETERS a,
												IN PUNICODE_STRING Buffer,
												IN BOOLEAN IncludeNull
											)
{
	DWORD OverflowStatus = ERROR_INVALID_PARAMETER;

	if ( Buffer )
	{
		ULONG Chars = Buffer->Length / sizeof( WCHAR );

		if ( a->ResultChars + Chars >= a->ResultMaxChars )
		{
			OverflowStatus = ERROR_MORE_DATA;

			Chars = a->ResultMaxChars - a->ResultChars;
			if ( Chars )
			{
				Chars -= 1;
			}
		}

		if ( Chars )
		{
			memcpy( reinterpret_cast < PBYTE > ( a->ResultBuffer ) + ( a->ResultChars * sizeof( WCHAR ) ), Buffer->Buffer, Chars * sizeof( WCHAR ) );
			a->ResultChars += Chars;
		}

		if ( OverflowStatus != ERROR_MORE_DATA )
		{
			OverflowStatus = ERROR_SUCCESS;
		}
	}

	if (IncludeNull)
	{
		if ( a->ResultChars + 1 >= a->ResultMaxChars )
		{
			OverflowStatus = ERROR_MORE_DATA;
		}
		else
		{
			a->ResultBuffer[ a->ResultChars ] = L'\0';
			a->ResultChars += 1;
		}
	}

	return OverflowStatus;
}

DWORD	REGISTRY_AppendNULLToResultBuffer ( IN PREGISTRY_PARAMETERS a )
{
    return REGISTRY_AppendBufferToResultBuffer( a, NULL, TRUE );
}

NTSTATUS	REGISTRY_CheckSubKeyNotEmpty ( IN HANDLE Key, IN PUNICODE_STRING SubKeyName )
{
	NTSTATUS Status = STATUS_SUCCESS;
	OBJECT_ATTRIBUTES ObjectAttributes;
	HANDLE SubKey	= INVALID_HANDLE_VALUE;
	KEY_VALUE_BASIC_INFORMATION KeyValueInformation;
	ULONG ResultLength;

	InitializeObjectAttributes( &ObjectAttributes,
								SubKeyName,
								OBJ_CASE_INSENSITIVE,
								Key,
								NULL
							  );

	Status = NtOpenKey( &SubKey, GENERIC_READ, &ObjectAttributes );
	if ( NT_SUCCESS ( Status ) )
	{
		Status = NtEnumerateValueKey	(	SubKey,
											0,
											KeyValueBasicInformation,
											&KeyValueInformation,
											sizeof( KeyValueInformation ),
											&ResultLength
										);

		if ( Status == STATUS_BUFFER_OVERFLOW )
		{
			Status = STATUS_SUCCESS;
		}

		NtClose( SubKey );
	}

	return Status;
}

/////////////////////////////////////////////////////////////////////////////////////////
// REAL REGISTRY FUNCTIONALITY
/////////////////////////////////////////////////////////////////////////////////////////
DWORD REGISTRY_ReadVariableValue	(
										IN PREGISTRY_PARAMETERS a,
										PREGISTRY_MAPPING_APPNAME AppNameMapping,
										PREGISTRY_MAPPING_VARNAME VarNameMapping,
										LPCWSTR VariableName
									)
{
	DWORD Status			= ERROR_INVALID_PARAMETER;
	LPCWSTR	ApplicationName	= NULL;

	BOOLEAN	OutputVariableName = FALSE;

	UNICODE_STRING EqualSign;

	if ( VariableName )
	{
		RtlInitUnicodeString ( &EqualSign, L"=" );
		OutputVariableName = TRUE;
	}

	if ( !VariableName )
	{
		if ( ! WMIREG_GetVariableName ( a, &VariableName ) )
		{
			VariableName = NULL;
		}
	}

	if ( VariableName != NULL )
	{
		if ( ! VarNameMapping )
		{
			VarNameMapping = WMIREG_FindVarNameMapping ( AppNameMapping, VariableName );
		}

		if ( VarNameMapping != NULL )
		{
			if ( WMIREG_GetApplicationName ( a, &ApplicationName ) )
			{
				HANDLE Key = INVALID_HANDLE_VALUE;

				Status = WMIREG_OpenMappingTarget	(	a,
														VarNameMapping,
														ApplicationName,
														&Key
													);

				if ( Status == ERROR_SUCCESS && Key != INVALID_HANDLE_VALUE )
				{
					NTSTATUS NtStatus;

					KEY_VALUE_PARTIAL_INFORMATION	KeyValueInformation;
					PKEY_VALUE_PARTIAL_INFORMATION	p = NULL;

					DWORD ResultLength = 0L;

					UNICODE_STRING temp;
					RtlInitUnicodeString ( &temp, VariableName );

					NtStatus = NtQueryValueKey	(	Key,
													&temp,
													KeyValuePartialInformation,
													&KeyValueInformation,
													sizeof( KeyValueInformation ),
													&ResultLength
												);

					if ( ! NT_SUCCESS ( NtStatus ) )
					{
						if ( NtStatus == STATUS_BUFFER_OVERFLOW )
						{
							p = reinterpret_cast < PKEY_VALUE_PARTIAL_INFORMATION > ( RtlAllocateHeap ( RtlProcessHeap(), HEAP_ZERO_MEMORY, ResultLength ) );
							if ( p != NULL )
							{
								NtStatus = NtQueryValueKey	(	Key,
																&temp,
																KeyValuePartialInformation,
																p,
																ResultLength,
																&ResultLength
															);

								Status = NtStatus;
							}
							else
							{
								Status = ERROR_NOT_ENOUGH_MEMORY;
							}
						}
						else
						{
							Status = NtStatus;
						}
					}
					else
					{
						p = &KeyValueInformation;
					}

					// create results
					if ( Status == ERROR_SUCCESS )
					{
						if ( OutputVariableName )
						{
							Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, FALSE );
							if ( Status == ERROR_SUCCESS )
							{
								Status = REGISTRY_AppendBufferToResultBuffer( a, &EqualSign, FALSE );
							}
						}

						if ( Status == ERROR_SUCCESS )
						{
							if ( p->Type == REG_SZ )
							{
								UNICODE_STRING	Value;
								LPWSTR			s = NULL;

								Value.Buffer = reinterpret_cast < LPWSTR > ( &p->Data[ 0 ] );
								if ( p->DataLength >= sizeof( UNICODE_NULL ) )
								{
									Value.Length = static_cast< USHORT > ( p->DataLength - sizeof ( UNICODE_NULL ) );
								}
								else
								{
									Value.Length = 0;
								}

								Value.MaximumLength = static_cast < USHORT > (p->DataLength);
								s = reinterpret_cast < LPWSTR > ( Value.Buffer );

								if (	a->Operation == Registry_ReadKeyValue &&
										Value.Length >= ( 2 * sizeof( WCHAR ) ) &&
										( s[ 0 ] == s[ ( Value.Length - sizeof( WCHAR ) ) / sizeof( WCHAR ) ] ) &&
										( s[ 0 ] == L'"' || s[ 0 ] == L'\'' )
								   )
								{
									Value.Buffer += 1;
									Value.Length -= (2 * sizeof( WCHAR ));
								}

								Status = REGISTRY_AppendBufferToResultBuffer( a, &Value, TRUE );
							}
							else
							{
								Status = STATUS_OBJECT_TYPE_MISMATCH;
							}
						}
					}

					// clear buffer
					if ( p && p != &KeyValueInformation )
					{
						RtlFreeHeap( RtlProcessHeap(), 0, p );
					}

					NtClose ( Key );
				}
			}
		}
	}

	return Status;
}

DWORD REGISTRY_ReadVariableName ( IN PREGISTRY_PARAMETERS a, PREGISTRY_MAPPING_APPNAME AppNameMapping )
{
	DWORD Status = ERROR_SUCCESS;

	PREGISTRY_MAPPING_VARNAME	VarNameMapping	= NULL;
	LPCWSTR						ApplicationName	= NULL;

	HANDLE Key = INVALID_HANDLE_VALUE;

	WCHAR Buffer[ 256 ];
	PKEY_VALUE_BASIC_INFORMATION KeyValueInformation = NULL;

	// temporary unicode strings
	UNICODE_STRING temp;

	VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->VariableNames;
	while ( VarNameMapping != NULL && Status == ERROR_SUCCESS )
	{
		RtlInitUnicodeString ( &temp, VarNameMapping->Name );
		Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, TRUE );

		if ( Status == ERROR_SUCCESS )
		{
			VarNameMapping = (PREGISTRY_MAPPING_VARNAME)VarNameMapping->Next;
		}
	}

	if ( Status == ERROR_SUCCESS )
	{
		VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
		if ( VarNameMapping != NULL )
		{
			if ( WMIREG_GetApplicationName ( a, &ApplicationName ) )
			{
				Status = WMIREG_OpenMappingTarget	(	a,
														VarNameMapping,
														ApplicationName,
														&Key
													);

				if ( Status == ERROR_SUCCESS && Key != INVALID_HANDLE_VALUE )
				{
					KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
					for ( ULONG ValueIndex = 0; Status == ERROR_SUCCESS; ValueIndex++ )
					{
						ULONG ResultLength	= 0L;

						Status = NtEnumerateValueKey( Key,
													  ValueIndex,
													  KeyValueBasicInformation,
													  KeyValueInformation,
													  sizeof( Buffer ),
													  &ResultLength
													);

						if ( Status == STATUS_NO_MORE_ENTRIES )
						{
							break;
						}

						if ( NT_SUCCESS ( Status ) )
						{
							temp.Buffer = KeyValueInformation->Name;
							temp.Length = (USHORT)KeyValueInformation->NameLength;
							temp.MaximumLength = (USHORT)KeyValueInformation->NameLength;

							Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, TRUE );
						}
					}

					if ( Status == STATUS_NO_MORE_ENTRIES )
					{
						Status = ERROR_SUCCESS;
					}

					NtClose ( Key );
				}
			}
			else
			{
				Status = ERROR_INVALID_PARAMETER;
			}
		}
	}

	return Status;
}

DWORD	REGISTRY_ReadSectionValue ( IN PREGISTRY_PARAMETERS a, PREGISTRY_MAPPING_APPNAME AppNameMapping )
{
	DWORD Status = ERROR_SUCCESS;

	PREGISTRY_MAPPING_VARNAME	VarNameMapping = NULL;
	LPCWSTR						ApplicationName= NULL;

	WCHAR Buffer[ 256 ];
	PKEY_VALUE_BASIC_INFORMATION KeyValueInformation = NULL;

	HANDLE Key = INVALID_HANDLE_VALUE;

	VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->VariableNames;
	while ( VarNameMapping != NULL && Status == ERROR_SUCCESS )
	{
		if ( VarNameMapping->Name )
		{
			Status = REGISTRY_ReadVariableValue ( a, AppNameMapping, VarNameMapping, VarNameMapping->Name );
			if ( Status != ERROR_SUCCESS )
			{
				if ( Status == STATUS_OBJECT_TYPE_MISMATCH )
				{
					Status = STATUS_SUCCESS;
				}
			}
		}

		if ( Status == ERROR_SUCCESS )
		{
			VarNameMapping = (PREGISTRY_MAPPING_VARNAME)VarNameMapping->Next;
		}
	}

	if ( Status == ERROR_SUCCESS )
	{
		VarNameMapping = (PREGISTRY_MAPPING_VARNAME)AppNameMapping->DefaultVarNameMapping;
		if ( VarNameMapping != NULL)
		{
			if ( WMIREG_GetApplicationName ( a, &ApplicationName ) )
			{
				Status = WMIREG_OpenMappingTarget	(	a,
														VarNameMapping,
														ApplicationName,
														&Key
													);

				if ( Status == ERROR_SUCCESS && Key != INVALID_HANDLE_VALUE )
				{
					KeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
					for ( ULONG ValueIndex = 0; Status == ERROR_SUCCESS; ValueIndex++ )
					{
						ULONG ResultLength = 0L;

						Status = NtEnumerateValueKey(	Key,
														ValueIndex,
														KeyValueBasicInformation,
														KeyValueInformation,
														sizeof( Buffer ),
														&ResultLength
													);

						if ( Status == STATUS_NO_MORE_ENTRIES )
						{
							break;
						}

						if ( NT_SUCCESS ( Status ) )
						{
							LPWSTR VariableName = NULL;

							try
							{
								if ( ( VariableName = new WCHAR [ KeyValueInformation->NameLength / sizeof ( WCHAR ) + 1 ] ) != NULL )
								{
									wcsncpy ( VariableName, (LPWSTR)&(KeyValueInformation->Name[0]), KeyValueInformation->NameLength / sizeof ( WCHAR ) );
									VariableName [ KeyValueInformation->NameLength / sizeof ( WCHAR ) ] = L'\0';
								}
								else
								{
									Status = ERROR_NOT_ENOUGH_MEMORY;
								}
							}
							catch ( ... )
							{
								if ( VariableName )
								{
									delete [] VariableName;
									VariableName = NULL;
								}

								Status = ERROR_GEN_FAILURE;
							}

							if ( Status == ERROR_SUCCESS )
							{
								Status = REGISTRY_ReadVariableValue( a, AppNameMapping, NULL, VariableName );

								delete [] VariableName;
								VariableName = NULL;

								if ( Status != ERROR_SUCCESS )
								{
									if ( Status == STATUS_OBJECT_TYPE_MISMATCH )
									{
										Status = STATUS_SUCCESS;
									}
								}
							}
						}
					}

					if ( Status == STATUS_NO_MORE_ENTRIES )
					{
						Status = ERROR_SUCCESS;
					}

					NtClose ( Key );
				}
			}
		}
	}

	return Status;
}

DWORD REGISTRY_ReadSectionName ( IN PREGISTRY_PARAMETERS a )
{
	DWORD Status = ERROR_SUCCESS;

	PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
	HANDLE Key									= INVALID_HANDLE_VALUE;

	WCHAR Buffer[ 256 ];
	PKEY_BASIC_INFORMATION KeyInformation		= NULL;

	// temporary unicode strings
	UNICODE_STRING temp;

	PREGISTRY_MAPPING_NAME Mapping = NULL;

	LPWSTR BaseFileName = NULL;
	Status = WMIREG_GetBaseFileName ( a->FileName, &BaseFileName );

	if ( Status == ERROR_SUCCESS && BaseFileName )
	{
		Mapping = WMIREG_FindMapping ( a->Mapping, BaseFileName );

		delete [] BaseFileName;
		BaseFileName = NULL;
	}

	if ( Mapping )
	{
		AppNameMapping = (PREGISTRY_MAPPING_APPNAME)Mapping->ApplicationNames;
		while ( AppNameMapping != NULL && Status == ERROR_SUCCESS )
		{
			RtlInitUnicodeString ( &temp, AppNameMapping->Name );
			Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, TRUE );

			if ( Status == ERROR_SUCCESS )
			{
				AppNameMapping = (PREGISTRY_MAPPING_APPNAME)AppNameMapping->Next;
			}
		}

		if ( Status == ERROR_SUCCESS )
		{
			AppNameMapping = (PREGISTRY_MAPPING_APPNAME)a->Mapping->DefaultAppNameMapping;
			if ( AppNameMapping != NULL )
			{
				Status = WMIREG_OpenMappingTarget	(	a,
														reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( AppNameMapping->DefaultVarNameMapping ),
														NULL,
														&Key
													);

				if ( Status == ERROR_SUCCESS && Key != INVALID_HANDLE_VALUE )
				{
					KeyInformation = (PKEY_BASIC_INFORMATION)Buffer;
					for ( ULONG SubKeyIndex = 0; Status == ERROR_SUCCESS; SubKeyIndex++ )
					{
						ULONG ResultLength	= 0L;

						Status = NtEnumerateKey( Key,
												  SubKeyIndex,
												  KeyBasicInformation,
												  KeyInformation,
												  sizeof( Buffer ),
												  &ResultLength
											   );

						if ( Status == STATUS_NO_MORE_ENTRIES )
						{
							break;
						}

						if ( NT_SUCCESS ( Status ) )
						{
							temp.Buffer = (PWSTR)&(KeyInformation->Name[0]);
							temp.Length = (USHORT)KeyInformation->NameLength;
							temp.MaximumLength = (USHORT)KeyInformation->NameLength;

							Status = REGISTRY_CheckSubKeyNotEmpty( Key, &temp );

							if ( NT_SUCCESS ( Status ) )
							{
								Status = REGISTRY_AppendBufferToResultBuffer( a, &temp, TRUE );
							}
							else
							if ( Status != STATUS_NO_MORE_ENTRIES )
							{
								break;
							}
							else
							{
								Status = STATUS_SUCCESS;
							}
						}
					}

					if ( Status == STATUS_NO_MORE_ENTRIES )
					{
						Status = ERROR_SUCCESS;
					}

					NtClose ( Key );
				}
			}
		}
	}

	return Status;
}

/////////////////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION
/////////////////////////////////////////////////////////////////////////////////////////

DWORD	WMIRegistry_Mapping	( IN PREGISTRY_PARAMETERS a )
{
    DWORD Status	= ERROR_INVALID_PARAMETER;

	if ( a )
	{
		if ( a->Operation == Registry_ReadSectionName )
		{
			Status = REGISTRY_ReadSectionName ( a );
		}
		else
		{
			LPCWSTR ApplicationName = NULL;
			if ( WMIREG_GetApplicationName ( a, &ApplicationName ) )
			{
				PREGISTRY_MAPPING_NAME Mapping = NULL;

				LPWSTR BaseFileName = NULL;
				Status = WMIREG_GetBaseFileName ( a->FileName, &BaseFileName );

				if ( Status == ERROR_SUCCESS && BaseFileName )
				{
					Mapping = WMIREG_FindMapping ( a->Mapping, BaseFileName );

					delete [] BaseFileName;
					BaseFileName = NULL;
				}

				if ( Mapping )
				{
					PREGISTRY_MAPPING_APPNAME AppNameMapping = NULL;
					AppNameMapping = WMIREG_FindAppNameMapping ( Mapping, ApplicationName );

					if ( AppNameMapping )
					{
						if ( a->Operation == Registry_ReadKeyValue )
						{
							Status = REGISTRY_ReadVariableValue ( a, AppNameMapping, NULL, NULL );
						}
						else
						if ( a->Operation == Registry_ReadKeyName )
						{
							Status = REGISTRY_ReadVariableName ( a, AppNameMapping );
						}
						else
						if ( a->Operation == Registry_ReadSectionValue )
						{
							Status = REGISTRY_ReadSectionValue ( a, AppNameMapping );
						}
						else
						{
							// not supported operation
							// possible write ?
							Status	= ERROR_INVALID_PARAMETER;
						}
					}
					else
					{
						// no registry for this section
						// you should use file function

						Status = STATUS_MORE_PROCESSING_REQUIRED;
					}
				}
			}
		}
	}

	return Status;
}

///////////////////////////////////////////////////////////////////////////////
// ALLOCATION of reg structures
///////////////////////////////////////////////////////////////////////////////

PREGISTRY_MAPPING_TARGET	MappingTargetAlloc	(
													IN LPCWSTR RegistryPath,
													OUT PULONG MappingFlags
												)
{
	BOOLEAN RelativePath = FALSE;
	UNICODE_STRING RegistryPathString;

	PREGISTRY_MAPPING_TARGET MappingTarget = NULL;

    LPCWSTR SaveRegistryPath = RegistryPath;
	ULONG Flags = 0L;

	// simulate result
	*MappingFlags = Flags;

	BOOLEAN	Continue = TRUE;

	while ( Continue )
	{
		try
		{
			if ( *RegistryPath == L'!' )
			{
				Flags |= REGISTRY_MAPPING_WRITE_TO_INIFILE_TOO;
				RegistryPath += 1;
			}
			else
			if ( *RegistryPath == L'#' )
			{
				Flags |= REGISTRY_MAPPING_INIT_FROM_INIFILE;
				RegistryPath += 1;
			}
			else
			if ( *RegistryPath == L'@' )
			{
				Flags |= REGISTRY_MAPPING_READ_FROM_REGISTRY_ONLY;
				RegistryPath += 1;
			}
			else
			if ( !_wcsnicmp ( RegistryPath, L"USR:", 4 ) )
			{
				Flags |= REGISTRY_MAPPING_USER_RELATIVE;
				RegistryPath += 4;
				break;
			}
			else
			if ( !_wcsnicmp ( RegistryPath, L"SYS:", 4 ) )
			{
				Flags |= REGISTRY_MAPPING_SOFTWARE_RELATIVE;
				RegistryPath += 4;
				break;
			}
			else
			{
				break;
			}
		}
		catch ( ... )
		{
			Continue = FALSE;
		}
	}

	if ( Continue )
	{
		if ( Flags & ( REGISTRY_MAPPING_USER_RELATIVE | REGISTRY_MAPPING_SOFTWARE_RELATIVE ) )
		{
			RelativePath = TRUE;
		}

		if ( ( RelativePath && *RegistryPath != OBJ_NAME_PATH_SEPARATOR ) ||
			 ( !RelativePath && *RegistryPath == OBJ_NAME_PATH_SEPARATOR )
		   )
		{
			RtlInitUnicodeString( &RegistryPathString, RegistryPath );
		}
		else
		if ( !RelativePath && *RegistryPath == UNICODE_NULL )
		{
			RtlInitUnicodeString( &RegistryPathString, NULL );
		}
		else
		{
			Continue = FALSE;
		}

		if ( Continue )
		{
			MappingTarget = reinterpret_cast < PREGISTRY_MAPPING_TARGET > ( RtlAllocateHeap( RtlProcessHeap (), HEAP_ZERO_MEMORY, sizeof( REGISTRY_MAPPING_TARGET ) ) );
			if ( MappingTarget != NULL )
			{
				*MappingFlags = Flags;

				MappingTarget->RegistryPath = NULL;
				if ( RegistryPathString.Length != 0 )
				{
					try
					{
						if ( ( MappingTarget->RegistryPath = new WCHAR [ RegistryPathString.Length / sizeof ( WCHAR ) + 1 ] ) != NULL )
						{
							wcsncpy ( MappingTarget->RegistryPath, RegistryPathString.Buffer, RegistryPathString.Length / sizeof ( WCHAR ) );
							MappingTarget->RegistryPath [RegistryPathString.Length / sizeof ( WCHAR )] = L'\0';
						}
					}
					catch ( ... )
					{
						if ( MappingTarget->RegistryPath )
						{
							delete [] MappingTarget->RegistryPath;
							MappingTarget->RegistryPath = NULL;
						}
					}
				}
			}
		}
	}

    return MappingTarget;
}

DWORD	MappingTargetFree	( IN PREGISTRY_MAPPING_TARGET MappingTarget )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( MappingTarget )
	{
		PREGISTRY_MAPPING_TARGET MappingTargetNext = NULL;
		MappingTargetNext = reinterpret_cast < PREGISTRY_MAPPING_TARGET > ( MappingTarget->Next );

		if ( MappingTargetNext )
		{
			MappingTargetFree ( MappingTargetNext );
		}
		if ( MappingTarget->RegistryPath )
		{
			delete [] MappingTarget->RegistryPath;
			MappingTarget->RegistryPath = NULL;
		}

		RtlFreeHeap( RtlProcessHeap(), 0, MappingTarget );

		// success
		Status = ERROR_SUCCESS;
	}

	return Status;
}

DWORD	MappingVarNameFree	( IN PREGISTRY_MAPPING_VARNAME VarNameMapping );
BOOLEAN	MappingVarNameAlloc	(
								PREGISTRY_MAPPING_NAME FileNameMapping,
								PREGISTRY_MAPPING_APPNAME AppNameMapping,
								PUNICODE_STRING VariableName,
								LPCWSTR RegistryPath,
								PREGISTRY_MAPPING_VARNAME *ReturnedVarNameMapping
							)
{
	PREGISTRY_MAPPING_TARGET MappingTarget	= NULL;;
	PREGISTRY_MAPPING_VARNAME VarNameMapping	= NULL;
	PREGISTRY_MAPPING_VARNAME  *pp;

	ULONG MappingFlags = 0L;

	BOOLEAN	Result = FALSE;
	BOOLEAN	Continue = TRUE;

	if ( VariableName->Length != 0 )
	{
		pp = reinterpret_cast < PREGISTRY_MAPPING_VARNAME* > ( &AppNameMapping->VariableNames );
		while ( VarNameMapping = *pp )
		{
			try
			{
				if ( VarNameMapping->Name )
				{
					if ( ! _wcsnicmp ( VariableName->Buffer, VarNameMapping->Name, VariableName->Length ) )
					{
						break;
					}
				}
			}
			catch ( ... )
			{
				Continue = FALSE;
				break;
			}

			pp = reinterpret_cast < PREGISTRY_MAPPING_VARNAME* > ( &VarNameMapping->Next );
		}
	}
	else
	{
		pp = reinterpret_cast < PREGISTRY_MAPPING_VARNAME* > ( &AppNameMapping->DefaultVarNameMapping );
		VarNameMapping = *pp;
	}

	if ( Continue && VarNameMapping == NULL )
	{
		MappingTarget = MappingTargetAlloc ( RegistryPath, &MappingFlags );
		if (MappingTarget != NULL)
		{
			VarNameMapping = reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( RtlAllocateHeap( RtlProcessHeap (), HEAP_ZERO_MEMORY, sizeof( REGISTRY_MAPPING_VARNAME ) ) );
			if (VarNameMapping != NULL)
			{
				VarNameMapping->MappingFlags	= MappingFlags;
				VarNameMapping->MappingTarget	= reinterpret_cast < ULONG_PTR > ( MappingTarget );

				if ( VariableName->Length != 0 )
				{
					try
					{
						if ( ( VarNameMapping->Name = new WCHAR [ VariableName->Length / sizeof ( WCHAR ) + 1 ] ) != NULL )
						{
							wcsncpy ( VarNameMapping->Name, VariableName->Buffer, VariableName->Length / sizeof ( WCHAR ) );
							VarNameMapping->Name [VariableName->Length / sizeof ( WCHAR )] = L'\0';

							Result = TRUE;
						}
					}
					catch ( ... )
					{
						if ( VarNameMapping->Name )
						{
							delete [] VarNameMapping->Name;
							VarNameMapping->Name = NULL;
						}

						MappingVarNameFree ( VarNameMapping );
						throw;
					}
				}
				else
				{
					Result = TRUE;
				}

				*pp = VarNameMapping;

				// return value
				*ReturnedVarNameMapping = VarNameMapping;
			}
		}
	}

    return Result;
}

DWORD	MappingVarNameFree	( IN PREGISTRY_MAPPING_VARNAME VarNameMapping )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( VarNameMapping )
	{
		PREGISTRY_MAPPING_VARNAME VarNameMappingNext = NULL;
		VarNameMappingNext = reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( VarNameMapping->Next );

		if ( VarNameMappingNext )
		{
			MappingVarNameFree ( VarNameMappingNext );
		}

		// return status from helper ?
		Status = MappingTargetFree ( reinterpret_cast < PREGISTRY_MAPPING_TARGET > ( VarNameMapping->MappingTarget ) );

		if ( VarNameMapping->Name )
		{
			delete [] VarNameMapping->Name;
			VarNameMapping->Name = NULL;
		}

		RtlFreeHeap( RtlProcessHeap(), 0, VarNameMapping );
		VarNameMapping = NULL;

		// success
		Status = ERROR_SUCCESS;
	}

	return Status;
}

DWORD	MappingAppNameFree	( IN PREGISTRY_MAPPING_APPNAME AppNameMapping );
BOOLEAN	MappingAppNameAlloc	(
								PREGISTRY_MAPPING_NAME FileNameMapping,
								PUNICODE_STRING ApplicationName,
								PREGISTRY_MAPPING_APPNAME *ReturnedAppNameMapping
							)
{
	PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
	PREGISTRY_MAPPING_APPNAME *pp;

	BOOLEAN	Result = FALSE;
	BOOLEAN	Continue = TRUE;

	if ( ApplicationName->Length != 0 )
	{
		pp = reinterpret_cast < PREGISTRY_MAPPING_APPNAME* > ( &FileNameMapping->ApplicationNames );
		while ( AppNameMapping = *pp )
		{
			try
			{
				if ( AppNameMapping->Name )
				{
					if ( ! _wcsnicmp ( ApplicationName->Buffer, AppNameMapping->Name, ApplicationName->Length ) )
					{
						break;
					}
				}
			}
			catch ( ... )
			{
				Continue = FALSE;
				break;
			}

			pp = reinterpret_cast < PREGISTRY_MAPPING_APPNAME* > ( &AppNameMapping->Next );
		}
	}
	else
	{
		pp = reinterpret_cast < PREGISTRY_MAPPING_APPNAME* > ( &FileNameMapping->DefaultAppNameMapping );
		AppNameMapping = *pp;
	}

	if ( Continue && AppNameMapping == NULL)
	{
		AppNameMapping = reinterpret_cast < PREGISTRY_MAPPING_APPNAME > ( RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof( REGISTRY_MAPPING_APPNAME ) ) );
		if (AppNameMapping != NULL)
		{
			if (ApplicationName->Length != 0)
			{
				try
				{
					if ( ( AppNameMapping->Name = new WCHAR [ ApplicationName->Length / sizeof ( WCHAR ) + 1 ] ) != NULL )
					{
						wcsncpy ( AppNameMapping->Name, ApplicationName->Buffer, ApplicationName->Length / sizeof ( WCHAR ) );
						AppNameMapping->Name [ApplicationName->Length / sizeof ( WCHAR )] = L'\0';

						Result = TRUE;
					}
				}
				catch ( ... )
				{
					if ( AppNameMapping->Name )
					{
						delete [] AppNameMapping->Name;
						AppNameMapping->Name = NULL;
					}

					MappingAppNameFree ( AppNameMapping );
					throw;
				}
			}
			else
			{
				Result = TRUE;
			}

			*pp = AppNameMapping;

			// return value
			*ReturnedAppNameMapping = AppNameMapping;
		}
	}

    return Result;
}

DWORD	MappingAppNameFree	( IN PREGISTRY_MAPPING_APPNAME AppNameMapping )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( AppNameMapping )
	{
		PREGISTRY_MAPPING_APPNAME AppNameMappingNext = NULL;
		AppNameMappingNext = reinterpret_cast < PREGISTRY_MAPPING_APPNAME > ( AppNameMapping->Next );

		if ( AppNameMappingNext )
		{
			MappingAppNameFree ( AppNameMappingNext );
		}

		MappingVarNameFree( reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( AppNameMapping->VariableNames ) );
		MappingVarNameFree( reinterpret_cast < PREGISTRY_MAPPING_VARNAME > ( AppNameMapping->DefaultVarNameMapping ) );

		if ( AppNameMapping->Name )
		{
			delete [] AppNameMapping->Name;
			AppNameMapping->Name = NULL;
		}

		RtlFreeHeap( RtlProcessHeap(), 0, AppNameMapping );
		AppNameMapping = NULL;

		// success
		Status = ERROR_SUCCESS;
	}

	return Status;
}

BOOLEAN	MappingNameAlloc	(
								IN PUNICODE_STRING FileName,
								OUT PREGISTRY_MAPPING_NAME *ReturnedFileNameMapping
							)
{
    PREGISTRY_MAPPING_NAME FileNameMapping = NULL;

	BOOLEAN Result = FALSE;

	FileNameMapping = reinterpret_cast < PREGISTRY_MAPPING_NAME > ( RtlAllocateHeap( RtlProcessHeap (), HEAP_ZERO_MEMORY, sizeof( REGISTRY_MAPPING_NAME ) ) );
	if ( FileNameMapping != NULL)
	{
		if (FileName->Length != 0)
		{
			try
			{
				if ( ( FileNameMapping->Name = new WCHAR [ FileName->Length / sizeof ( WCHAR ) + 1 ] ) != NULL )
				{
					wcsncpy ( FileNameMapping->Name, FileName->Buffer, FileName->Length / sizeof ( WCHAR ) );
					FileNameMapping->Name [FileName->Length / sizeof ( WCHAR )] = L'\0';

					Result = TRUE;
				}
			}
			catch ( ... )
			{
				if ( FileNameMapping->Name )
				{
					delete [] FileNameMapping->Name;
					FileNameMapping->Name = NULL;
				}
			}
		}
		else
		{
			Result = TRUE;
		}

		// return value
		*ReturnedFileNameMapping = FileNameMapping;
	}

    return Result;
}

DWORD	MappingNameFree	( IN PREGISTRY_MAPPING_NAME FileNameMapping )
{
	DWORD Status = ERROR_INVALID_PARAMETER;

	if ( FileNameMapping )
	{
		PREGISTRY_MAPPING_NAME FileNameMappingNext = NULL;
		FileNameMappingNext = reinterpret_cast < PREGISTRY_MAPPING_NAME > ( FileNameMapping->Next );

		if ( FileNameMappingNext )
		{
			MappingNameFree ( FileNameMappingNext );
		}

		MappingAppNameFree( reinterpret_cast < PREGISTRY_MAPPING_APPNAME > ( FileNameMapping->ApplicationNames ) );
		MappingAppNameFree( reinterpret_cast < PREGISTRY_MAPPING_APPNAME > ( FileNameMapping->DefaultAppNameMapping ) );

		if ( FileNameMapping->Name )
		{
			delete [] FileNameMapping->Name;
			FileNameMapping->Name = NULL;
		}

		RtlFreeHeap( RtlProcessHeap(), 0, FileNameMapping );
		FileNameMapping = NULL;

		// success
		Status = ERROR_SUCCESS;
	}

	return Status;
}

NTSTATUS	IniFileMapping	(
								IN PREGISTRY_MAPPING_NAME FileNameMapping,
								IN HANDLE Key,

								IN LPCWSTR MyApplicationName,
								IN LPCWSTR MyVariableName
							)
{
	NTSTATUS Status	= STATUS_SUCCESS;
	WCHAR Buffer[ 512 ];
	PKEY_BASIC_INFORMATION		KeyInformation		= NULL;
	PKEY_VALUE_FULL_INFORMATION	KeyValueInformation	= NULL;

	OBJECT_ATTRIBUTES ObjectAttributes;

	PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
	PREGISTRY_MAPPING_VARNAME VarNameMapping = NULL;

	HANDLE SubKeyHandle = INVALID_HANDLE_VALUE;
	ULONG SubKeyIndex;
	UNICODE_STRING ValueName;
	UNICODE_STRING SubKeyName;

	UNICODE_STRING NullString;
    RtlInitUnicodeString( &NullString, NULL );

    //
    // Enumerate node
    //

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;
	for ( ULONG ValueIndex = 0; TRUE; ValueIndex++ )
	{
		ULONG ResultLength = 0L;
		Status = NtEnumerateValueKey	(	Key,
											ValueIndex,
											KeyValueFullInformation,
											KeyValueInformation,
											sizeof( Buffer ),
											&ResultLength
										);

		if ( Status == STATUS_NO_MORE_ENTRIES )
		{
			Status = STATUS_SUCCESS;
			break;
		}
		else
		if ( !NT_SUCCESS( Status ) )
		{
			break;
		}

		ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
		ValueName.Length = (USHORT)KeyValueInformation->NameLength;
		ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;

		if ( KeyValueInformation->Type == REG_SZ )
		{
			BOOL Continue = TRUE;
			if ( MyApplicationName && MyVariableName )
			{
				if ( _wcsnicmp ( ValueName.Buffer, MyVariableName, ValueName.Length / sizeof ( WCHAR ) ) )
				{
					Continue = FALSE;
				}
			}

			if ( Continue )
			{
				if ( MappingAppNameAlloc ( FileNameMapping, &ValueName, &AppNameMapping ) )
				{
					if ( MappingVarNameAlloc	(	FileNameMapping,
													AppNameMapping,
													&NullString,
													(PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset),
													&VarNameMapping
												)
					   )
					{
						if (ValueName.Length == 0)
						{
							VarNameMapping->MappingFlags |= REGISTRY_MAPPING_APPEND_APPLICATION_NAME;
						}
					}
				}
			}
		}
	}

    //
    // Enumerate node's children and apply ourselves to each one
    //

	KeyInformation = (PKEY_BASIC_INFORMATION)Buffer;
	for ( ULONG SubKeyIndex = 0; TRUE; SubKeyIndex++ )
	{
		ULONG ResultLength = 0L;
		Status = NtEnumerateKey	(	Key,
									SubKeyIndex,
									KeyBasicInformation,
									KeyInformation,
									sizeof( Buffer ),
									&ResultLength
								);

		if ( Status == STATUS_NO_MORE_ENTRIES)
		{
			Status = STATUS_SUCCESS;
			break;
		}
		else
		if ( !NT_SUCCESS ( Status ) )
		{
			break;
		}

		SubKeyName.Buffer = (PWSTR)&(KeyInformation->Name[0]);
		SubKeyName.Length = (USHORT)KeyInformation->NameLength;
		SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;

		InitializeObjectAttributes (	&ObjectAttributes,
										&SubKeyName,
										OBJ_CASE_INSENSITIVE,
										Key,
										NULL
									);

		BOOL Continue = TRUE;
		if ( MyApplicationName )
		{
			if ( _wcsnicmp ( SubKeyName.Buffer, MyApplicationName, SubKeyName.Length / sizeof ( WCHAR ) ) )
			{
				Continue = FALSE;
			}
		}

		if ( Continue )
		{
			Status = NtOpenKey( &SubKeyHandle, GENERIC_READ, &ObjectAttributes );

			try
			{
				if ( NT_SUCCESS( Status ) && SubKeyHandle != INVALID_HANDLE_VALUE && MappingAppNameAlloc( FileNameMapping, &SubKeyName, &AppNameMapping ) )
				{
					KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;
					for ( ULONG ValueIndex = 0; AppNameMapping != NULL; ValueIndex++ )
					{
						Status = NtEnumerateValueKey	(	SubKeyHandle,
															ValueIndex,
															KeyValueFullInformation,
															KeyValueInformation,
															sizeof( Buffer ),
															&ResultLength
														);

						if ( Status == STATUS_NO_MORE_ENTRIES )
						{
							Status = STATUS_SUCCESS;
							break;
						}
						else
						if ( !NT_SUCCESS ( Status ) )
						{
							break;
						}

						ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
						ValueName.Length = (USHORT)KeyValueInformation->NameLength;
						ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;

						BOOL ContinueValue = TRUE;
						if ( MyApplicationName && MyVariableName )
						{
							if ( _wcsnicmp ( ValueName.Buffer, MyVariableName, ValueName.Length / sizeof ( WCHAR ) ) )
							{
								ContinueValue = FALSE;
							}
						}

						if ( ContinueValue )
						{
							if ( KeyValueInformation->Type == REG_SZ )
							{
								MappingVarNameAlloc	(	FileNameMapping,
														AppNameMapping,
														&ValueName,
														(PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset),
														&VarNameMapping
													);
							}
						}
					}

					NtClose( SubKeyHandle );
					SubKeyHandle = INVALID_HANDLE_VALUE;
				}
			}
			catch ( ... )
			{
				if ( SubKeyHandle && SubKeyHandle != INVALID_HANDLE_VALUE )
				{
					NtClose( SubKeyHandle );
					SubKeyHandle = INVALID_HANDLE_VALUE;
				}

				throw;
			}
		}
	}

    return Status;
}

DWORD	WMIRegistry_InitMapping	( PREGISTRY_PARAMETERS a )
{
    DWORD					Status			= ERROR_INVALID_PARAMETER;
    PREGISTRY_MAPPING_NAME	RegistryMapping = NULL;

	if ( a )
	{
		// prepare mapping
		a->Mapping = NULL;

		NTSTATUS NtStatus = STATUS_SUCCESS;

		PREGISTRY_MAPPING_NAME	DefaultFileNameMapping	= NULL;
		PREGISTRY_MAPPING_NAME	FileNames				= NULL;

		PREGISTRY_MAPPING_APPNAME AppNameMapping	= NULL;
		PREGISTRY_MAPPING_VARNAME VarNameMapping	= NULL;

		OBJECT_ATTRIBUTES ObjectAttributes;

		HANDLE IniFileMappingRoot	= INVALID_HANDLE_VALUE;

		PKEY_VALUE_PARTIAL_INFORMATION	KeyValueInformation	= NULL;
		PKEY_BASIC_INFORMATION			KeyInformation		= NULL;

		WCHAR Buffer[ 512 ];

		LPWSTR BaseFileName = NULL;
		Status = WMIREG_GetBaseFileName ( a->FileName, &BaseFileName );

		if ( Status == ERROR_SUCCESS && BaseFileName )
		{
			UNICODE_STRING	FullKeyName;

			FullKeyName.Length = 0;
			FullKeyName.MaximumLength = ( wcslen ( L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\" ) + wcslen ( BaseFileName ) + 1 ) * sizeof ( WCHAR );
			FullKeyName.Buffer = reinterpret_cast < PWSTR > ( RtlAllocateHeap( RtlProcessHeap(), 0, FullKeyName.MaximumLength ) );

			if ( FullKeyName.Buffer != NULL )
			{
				RtlAppendUnicodeToString ( &FullKeyName, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\" );
				RtlAppendUnicodeToString ( &FullKeyName, BaseFileName );

				InitializeObjectAttributes	(	&ObjectAttributes,
												&FullKeyName,
												OBJ_CASE_INSENSITIVE,
												NULL,
												NULL
											);

				NtStatus = NtOpenKey	(	&IniFileMappingRoot,
											GENERIC_READ,
											&ObjectAttributes
										);

				if ( NT_SUCCESS ( NtStatus ) && IniFileMappingRoot != INVALID_HANDLE_VALUE )
				{
					UNICODE_STRING BaseFile;
					RtlInitUnicodeString ( &BaseFile, BaseFileName );

					if ( ! MappingNameAlloc( &BaseFile, &FileNames ) )
					{
						NtStatus = STATUS_NO_MEMORY;
					}
					else
					{
						try
						{
							NtStatus = IniFileMapping( FileNames, IniFileMappingRoot, a->ApplicationName, a->VariableName );
						}
						catch ( ... )
						{
							MappingNameFree ( FileNames );
							FileNames = NULL;

							NtStatus = STATUS_NO_MEMORY;
						}

						if ( ! NT_SUCCESS ( NtStatus ) )
						{
							if ( FileNames )
							{
								RtlFreeHeap( RtlProcessHeap(), 0, FileNames );
								FileNames = NULL;
							}
						}
					}

					if ( NT_SUCCESS ( NtStatus ) )
					{
						a->Mapping = FileNames;
					}

					// close main root
					if ( IniFileMappingRoot && IniFileMappingRoot != INVALID_HANDLE_VALUE )
					{
						NtClose ( IniFileMappingRoot );
						IniFileMappingRoot = NULL;
					}
				}

				// clear buffer
				RtlFreeHeap ( RtlProcessHeap (), 0, FullKeyName.Buffer );
			}
			else
			{
				NtStatus = STATUS_NO_MEMORY;
			}

			// we are done with looking for 
			delete [] BaseFileName;
			BaseFileName = NULL;
		}

		// name has not found ( get ready for default )
		if ( NT_SUCCESS ( NtStatus ) && a->Mapping == NULL )
		{
			UNICODE_STRING	KeyName;
			RtlInitUnicodeString	(	&KeyName,
										L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping"
									);

			InitializeObjectAttributes	(	&ObjectAttributes,
											&KeyName,
											OBJ_CASE_INSENSITIVE,
											NULL,
											NULL
										);

			NtStatus = NtOpenKey	(	&IniFileMappingRoot,
										GENERIC_READ,
										&ObjectAttributes
									);

			if ( NT_SUCCESS ( NtStatus ) && IniFileMappingRoot != INVALID_HANDLE_VALUE )
			{
				ULONG ResultLength = 0L;

				UNICODE_STRING NullString;
				RtlInitUnicodeString( &NullString, NULL );

				UNICODE_STRING ValueName;
				RtlInitUnicodeString( &ValueName, NULL );

				NtStatus = NtQueryValueKey	(	IniFileMappingRoot,
												&ValueName,
												KeyValuePartialInformation,
												KeyValueInformation,
												sizeof( Buffer ),
												&ResultLength
											);

				try
				{
					if ( NT_SUCCESS ( NtStatus ) )
					{
						if ( MappingNameAlloc( &NullString, &DefaultFileNameMapping ) )
						{
							if ( MappingAppNameAlloc ( DefaultFileNameMapping, &NullString, &AppNameMapping ) )
							{
								if ( MappingVarNameAlloc ( DefaultFileNameMapping, AppNameMapping, &NullString, (PWSTR)(KeyValueInformation->Data), &VarNameMapping ) )
								{
									VarNameMapping->MappingFlags |= REGISTRY_MAPPING_APPEND_BASE_NAME | REGISTRY_MAPPING_APPEND_APPLICATION_NAME;

									// assign proper mapping
									a->Mapping = DefaultFileNameMapping;
								}
							}
						}
					}
				}
				catch ( ... )
				{
					MappingNameFree ( DefaultFileNameMapping );
					DefaultFileNameMapping = NULL;

					a->Mapping = NULL;

					NtStatus = STATUS_NO_MEMORY;
				}

				// close main root
				if ( IniFileMappingRoot && IniFileMappingRoot != INVALID_HANDLE_VALUE )
				{
					NtClose ( IniFileMappingRoot );
					IniFileMappingRoot = NULL;
				}
			}
		}

		if ( a->Mapping )
		{
			// return success
			Status = ERROR_SUCCESS;
		}
		else
		{
			if ( NT_SUCCESS ( NtStatus ) )
			{
				// we do not have mapping
				Status = STATUS_MORE_PROCESSING_REQUIRED;
			}
			else
			{
				Status = NtStatus;
			}
		}
	}

    return Status;
}

DWORD	WMIRegistry_ParametersInit	(
										#ifdef	WRITE_OPERATION
										BOOLEAN WriteOperation,
										#endif	WRITE_OPERATION

										REGISTRY_OPERATION Operation,
										BOOLEAN MultiValueStrings,

										LPCWSTR FileName,
										LPCWSTR	ApplicationName,
										LPCWSTR	VariableName,
										LPWSTR	VariableValue,
										PULONG ResultMaxChars,

										PREGISTRY_PARAMETERS *ReturnedParameterBlock
									)
{
    DWORD					Status	= ERROR_SUCCESS;
	PREGISTRY_PARAMETERS	a		= NULL;

	if ( ! ReturnedParameterBlock )
	{
		Status = ERROR_INVALID_PARAMETER;
	}

	if ( Status == ERROR_SUCCESS )
	{
		try
		{
			a = new REGISTRY_PARAMETERS();
			if ( a== NULL )
			{
				Status = ERROR_NOT_ENOUGH_MEMORY;
			}
		}
		catch ( ... )
		{
			if ( a )
			{
				delete a;
				a = NULL;
			}

			Status = ERROR_NOT_ENOUGH_MEMORY;
		}
	}

	if ( Status == ERROR_SUCCESS )
	{
		#ifdef	WRITE_OPERATION
		a->WriteOperation		= WriteOperation;
		#endif	WRITE_OPERATION

		a->ValueBufferAllocated	= FALSE;

		a->Operation			= Operation;
		a->MultiValueStrings	= MultiValueStrings;

		if ( FileName )
		{
			a->FileName = FileName;
		}
		else
		{
			a->FileName = L"win.ini";
		}

		// section name
		if ( ApplicationName )
		{
			a->ApplicationName = ApplicationName;
		}
		else
		{
			a->ApplicationName = NULL;
		}

		// key name
		if ( VariableName )
		{
			a->VariableName= VariableName;
		}
		else
		{
			a->VariableName= NULL;
		}

		Status = WMIRegistry_InitMapping ( a );
		if ( Status != ERROR_SUCCESS )
		{
			delete a;
			a = NULL;
		}
		else
		{
			// key value
			if ( VariableValue )
			{
				#ifdef	WRITE_OPERATION
				if (a->WriteOperation)
				{
					a->ValueBuffer	= VariableValue;
					a->ValueLength	= wcslen ( VariableValue );
				}
				else
				#endif	WRITE_OPERATION
				{
					if ( ResultMaxChars )
					{
						a->ResultMaxChars = *ResultMaxChars;
					}
					else
					{
						a->ResultMaxChars = 0;
					}

					a->ResultChars	= 0;
					a->ResultBuffer	= VariableValue;
				}
			}
			else
			{
				#ifdef	WRITE_OPERATION
				if ( a->WriteOperation )
				{
					a->ValueBuffer	= NULL;
					a->ValueLength	= 0;
				}
				else
				#endif	WRITE_OPERATION
				{
					a->ResultMaxChars	= 0;
					a->ResultChars		= 0;
					a->ResultBuffer		= NULL;
				}
			}
		}
	}

	if ( ReturnedParameterBlock )
	{
		*ReturnedParameterBlock = a;
	}

	return Status;
}

DWORD	WMIRegistry_ParametersClear	(
										PREGISTRY_PARAMETERS ParameterBlock
									)
{
    DWORD Status	= ERROR_SUCCESS;

	if ( ! ParameterBlock )
	{
		Status = ERROR_INVALID_PARAMETER;
	}

	if ( Status == ERROR_SUCCESS )
	{
		if ( ParameterBlock->Mapping )
		{
			MappingNameFree ( ParameterBlock->Mapping );
			ParameterBlock->Mapping = NULL;
		}

		delete ParameterBlock;
		ParameterBlock = NULL;
	}

	return Status;
}

///////////////////////////////////////////////////////////////////////////////
// read function
///////////////////////////////////////////////////////////////////////////////
DWORD	WMIRegistry	(
						#ifdef	WRITE_OPERATION
						IN BOOLEAN WriteOperation,
						#endif	WRITE_OPERATION

						IN BOOLEAN SectionOperation,
						IN LPCWSTR FileName,
						IN LPCWSTR ApplicationName,
						IN LPCWSTR VariableName,
						IN OUT LPWSTR VariableValue,
						IN OUT PULONG VariableValueLength
					)
{
	// variables
	DWORD				Status				= ERROR_INVALID_PARAMETER;
    REGISTRY_OPERATION	Operation			= Registry_None;
    BOOLEAN				MultiValueStrings	= FALSE;

	if ( SectionOperation )
	{
		VariableName = NULL;
	}

	if ( ApplicationName )
	{
		if ( VariableValue )
		{
			if ( VariableName )
			{
				Operation = Registry_ReadKeyValue;
			}
			else
			{
				if ( SectionOperation )
				{
					Operation = Registry_ReadSectionValue;
					MultiValueStrings = TRUE;
				}
				else
				{
					Operation = Registry_ReadKeyName;
					MultiValueStrings = TRUE;
				}
			}
		}
	}
	else
	{
		if ( ! ( SectionOperation || ! VariableValue ) )
		{
			Operation = Registry_ReadSectionName;
			MultiValueStrings = TRUE;
		}
	}

	// real operation
	if ( Operation != Registry_None )
	{
		PREGISTRY_PARAMETERS a = NULL;

		Status = WMIRegistry_ParametersInit	(
												#ifdef	WRITE_OPERATION
												WriteOperation,
												#endif	WRITE_OPERATION

												Operation,
												MultiValueStrings,
												FileName,
												ApplicationName,
												VariableName,
												VariableValue,
												VariableValueLength,
												&a
											);

		if ( Status == ERROR_SUCCESS )
		{
			if ( a->Mapping != NULL )
			{
				Status = WMIRegistry_Mapping( a );

				if ( Status == ERROR_SUCCESS || Status == ERROR_MORE_DATA )
				{
					if (	a->Operation == Registry_ReadKeyName ||
							a->Operation == Registry_ReadSectionName ||
							a->Operation == Registry_ReadSectionValue
					   )
					{
						REGISTRY_AppendNULLToResultBuffer ( a );
					}

					if ( VariableValueLength )
					{
						*VariableValueLength = a->ResultChars;
					}
				}
			}
			else
			{
				Status = ERROR_INVALID_PARAMETER;

				if ( VariableValueLength )
				{
					*VariableValueLength = 0;
				}
			}
		}

		WMIRegistry_ParametersClear ( a );
	}

	::SetLastError ( Status );
	return Status;
}

///////////////////////////////////////////////////////////////////////////////
// get profile string
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_PrivateProfileString	(
															LPCWSTR	lpAppName,
															LPCWSTR	lpKeyName,
															LPCWSTR	lpDefault,
															LPWSTR	lpReturnedString,
															DWORD	nSize,
															LPCWSTR	lpFileName
														)
{
    DWORD Status	= ERROR_SUCCESS;
    ULONG n			= nSize;

    if ( lpDefault == NULL )
	{
        lpDefault = L"";
    }

    Status = WMIRegistry	(
								#ifdef	WRITE_OPERATION
								FALSE,		// Write operation
								#endif	WRITE_OPERATION

								FALSE,		// SectionOperation
								lpFileName,
								lpAppName,
								lpKeyName,
								lpReturnedString,
								&n
							);

	if ( n && ( Status == ERROR_SUCCESS || Status == STATUS_BUFFER_OVERFLOW ) )
	{
		if ( Status == ERROR_SUCCESS )
		{
			n--;
		}
		else
		{
			if ( !lpAppName || !lpKeyName )
			{
				if ( nSize >= 2 )
				{
					n = nSize - 2;
					lpReturnedString[ n+1 ] = L'\0';
				}
				else
				{
					n = 0;
				}
			}
			else
			{
				if ( nSize >= 1 )
				{
					n = nSize - 1;
				}
				else
				{
					n = 0;
				}
			}
		}
	}
	else
	{
		n = wcslen( lpDefault );
		while ( n > 0 && lpDefault[n-1] == L' ')
		{
			n -= 1;
		}

		if (n >= nSize)
		{
			n = nSize;
		}

		wcsncpy ( lpReturnedString, lpDefault, n );
	}

	if ( n < nSize )
	{
		lpReturnedString[ n ] = L'\0';
	} 
	else
	{
		if ( nSize > 0 )
		{
			lpReturnedString[ nSize-1 ] = L'\0';
		}
	}

	return n;
}

///////////////////////////////////////////////////////////////////////////////
// get profile section
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_PrivateProfileSection	(
															LPCWSTR	lpAppName,
															LPWSTR	lpReturnedString,
															DWORD	nSize,
															LPCWSTR	lpFileName
														)
{
    NTSTATUS Status;
    ULONG n;

    n = nSize;
    Status = WMIRegistry	(
								#ifdef	WRITE_OPERATION
								FALSE,		// Write operation
								#endif	WRITE_OPERATION

								TRUE,		// SectionOperation
								lpFileName,
								lpAppName,
								NULL,
								lpReturnedString,
								&n
							);

	if ( Status == ERROR_SUCCESS || Status == STATUS_BUFFER_OVERFLOW )
	{
		if ( Status == ERROR_SUCCESS )
		{
			n--;
		}
		else
		{
			if ( nSize >= 2 )
			{
				n = nSize - 2;
				lpReturnedString[ n+1 ] = L'\0';
			}
			else
			{
				n = 0;
			}
		}
	}
	else
	{
		n = 0;
	}

	if ( n < nSize )
	{
		lpReturnedString[ n ] = L'\0';
	} 
	else
	{
		if ( nSize > 0 )
		{
			lpReturnedString[ nSize-1 ] = L'\0';
		}
	}

	return n;
}

///////////////////////////////////////////////////////////////////////////////
// get profile integer
///////////////////////////////////////////////////////////////////////////////
UINT	APIENTRY	WMIRegistry_PrivateProfileInt	(
														LPCWSTR lpAppName,
														LPCWSTR lpKeyName,
														INT nDefault
													)
{
    WCHAR ValueBuffer[ 256 ];

    ULONG ReturnValue	= nDefault;
    ULONG cb			= 0;

    cb = WMIRegistry_PrivateProfileString	(	lpAppName,
												lpKeyName,
												NULL,
												ValueBuffer,
												sizeof( ValueBuffer ) / sizeof( WCHAR ),
												NULL
											);
    if ( cb )
	{
		// convert value to integer
		_wtoi ( ValueBuffer );
    }

    return ReturnValue;
}

///////////////////////////////////////////////////////////////////////////////
// get profile integer caller
///////////////////////////////////////////////////////////////////////////////
UINT	APIENTRY	WMIRegistry_ProfileInt	(
												LPCWSTR lpAppName,
												LPCWSTR lpKeyName,
												INT nDefault
											)
{
    return( WMIRegistry_PrivateProfileInt	(	lpAppName,
												lpKeyName,
												nDefault
											)
          );
}

///////////////////////////////////////////////////////////////////////////////
// get profile section caller
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_ProfileSection	(
													LPCWSTR lpAppName,
													LPWSTR lpReturnedString,
													DWORD nSize
												)
{
    return( WMIRegistry_PrivateProfileSection	(	lpAppName,
													lpReturnedString,
													nSize,
													NULL
												)
          );
}

///////////////////////////////////////////////////////////////////////////////
// get profile string caller
///////////////////////////////////////////////////////////////////////////////
DWORD	APIENTRY	WMIRegistry_ProfileString	(
													LPCWSTR lpAppName,
													LPCWSTR lpKeyName,
													LPCWSTR lpDefault,
													LPWSTR lpReturnedString,
													DWORD nSize
												)
{
    return( WMIRegistry_PrivateProfileString	(	lpAppName,
													lpKeyName,
													lpDefault,
													lpReturnedString,
													nSize,
													NULL
												)
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\refptr.h ===
//

// RefPtr.h -- definition of TRefPtr template

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//
//=================================================================

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __TREFPTR_H__
#define __TREFPTR_H__

#include <chptrarr.h>

// Enumeration helpers
typedef	DWORD	REFPTR_POSITION;
#define	REFPTR_START	0xFFFFFFFF;

template <class TYPED_PTR> class TRefPtr
{
public:

	// Construction/Destruction
	TRefPtr();
	~TRefPtr();

	// Allows addition and enumeration of collection
	BOOL	Add( TYPED_PTR* ptr );
    BOOL    Remove( DWORD dwElement );

	BOOL		BeginEnum( REFPTR_POSITION& pos );
	TYPED_PTR*	GetNext( REFPTR_POSITION& pos );
	void		EndEnum( void );

	// Allows for direct access
	TYPED_PTR*	GetAt( DWORD dwElement );
	void		Empty( void );
	DWORD		GetSize( void );

	const TRefPtr<TYPED_PTR>& Append( const TRefPtr<TYPED_PTR>& );

protected:

	// Allows easy and quick transference of data (it was =, but
	// because we'll inherit classes off the template, we won't
	// inherit that particular overload (some C++ thingie)

	const TRefPtr<TYPED_PTR>& Copy( const TRefPtr<TYPED_PTR>& );


private:

	CHPtrArray		m_ptrArray;

};

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::TRefPtr
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPtr<TYPED_PTR>::TRefPtr( void ):	m_ptrArray()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPtr::~CRefPtr
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPtr<TYPED_PTR>::~TRefPtr( void )
{
	Empty();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Add
//
//	Adds a new referenced pointer to the collection.
//
//	Inputs:		T*				ptr - Pointer to add.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of Add.
//
//	Comments:	AddRefs the pointer, then adds it to the array.  We
//				will need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPtr<TYPED_PTR>::Add( TYPED_PTR* ptr )
{
	BOOL	fReturn = FALSE;

	if ( NULL != ptr )
	{
		if ( m_ptrArray.Add( (void*) ptr ) >= 0 )
		{
			// Corresponding Release() is in Empty().
			ptr->AddRef();
			fReturn = TRUE;
		}
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Remove
//
//	Removes an element based on an index.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of remove.
//
//	Comments:	
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPtr<TYPED_PTR>::Remove( DWORD dwElement )
{
	BOOL	fReturn = FALSE;
	TYPED_PTR*	ptr = NULL;

	if ( dwElement < m_ptrArray.GetSize() )
	{
		ptr = (TYPED_PTR*) m_ptrArray[dwElement];

		if ( NULL != ptr )
		{
			// Clean up our pointer
			ptr->Release();
		}

		m_ptrArray.RemoveAt( dwElement );
		fReturn = TRUE;
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::BeginEnum
//
//	Gains Read Access to the collection, then returns an appropriate
//	REFPTR_POSITION to get the first index in the array.
//
//	Inputs:		None.
//
//	Outputs:	REFPTR_POSITION&	pos - Position we retrieved.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	We need Read Access to do this.  This can effectively
//				lock out other threads.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPtr<TYPED_PTR>::BeginEnum( REFPTR_POSITION& pos )
{
	BOOL	fReturn	=	FALSE;

	pos = REFPTR_START;
	fReturn = TRUE;
	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::EndEnum
//
//	Signals the end of an enumeration.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	Place Holder should we make Begin do something that
//				needs cleaning up.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPtr<TYPED_PTR>::EndEnum( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::GetNext
//
//	Uses the REFPTR_POSITION to get the next index in the
//	collection.
//
//	Inputs:		None.
//
//	Outputs:	REFPTR_POSITION&	pos - Position we retrieved.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TYPED_PTR* TRefPtr<TYPED_PTR>::GetNext( REFPTR_POSITION& pos )
{
	TYPED_PTR*	ptr = NULL;

	if ( ++pos < (DWORD) m_ptrArray.GetSize() )
	{
		ptr = (TYPED_PTR*) m_ptrArray.GetAt( pos );

		if ( NULL != ptr )
		{
			ptr->AddRef();
		}
	}


	return ptr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::GetAt
//
//	Gets at the requested member of the device list.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////
template <class TYPED_PTR>
TYPED_PTR*	TRefPtr<TYPED_PTR>::GetAt( DWORD dwElement )
{
	TYPED_PTR*	ptr = NULL;

	if ( dwElement < m_ptrArray.GetSize() )
	{
		ptr = (TYPED_PTR*) m_ptrArray.GetAt( dwElement );

		if ( NULL != ptr )
		{
			ptr->AddRef();
		}
	}

	return ptr;
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Empty
//
//	Empties out the collection, Releasing Pointers as it does do.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPtr<TYPED_PTR>::Empty( void )
{
	// By default this is an infinite wait, so it best come back

    int				nSize	=	m_ptrArray.GetSize();

	// Only empty it if it is not empty
	if ( nSize > 0 )
	{
		TYPED_PTR*	ptr		=	NULL;

		for ( int nCtr = 0; nCtr < nSize; nCtr++ )
		{
			ptr = (TYPED_PTR*) m_ptrArray[nCtr];

			if ( NULL != ptr )
			{
				// Clean up our pointers (not AddRef/Releasing so delete)
				ptr->Release();
			}
		}

		// Now dump the array
		m_ptrArray.RemoveAll();

	}	// IF nSize > 0
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::GetSize
//
//	Returns the size of the collection
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		DWORD	Number of elements
//
//	Comments:	We need Read Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
DWORD TRefPtr<TYPED_PTR>::GetSize( void )
{
    return m_ptrArray.GetSize();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Copy
//
//	Empties out the collection, copies in another one, addrefing
//	pointers as we go.
//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPtr<TYPED_PTR>& TRefPtr<TYPED_PTR>::Copy( const TRefPtr<TYPED_PTR>& collection )
{
	// Dump out the array
	Empty();

	int	nSize = collection.m_ptrArray.GetSize();

	for ( int nCount = 0; nCount < nSize; nCount++ )
	{
		TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		// Add will automatically AddRef the pointer again.
		Add( ptr );
	}

	return *this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPtr::Append
//
//	Appends the supplied collection to this one.
	//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPtr<TYPED_PTR>& TRefPtr<TYPED_PTR>::Append( const TRefPtr<TYPED_PTR>& collection )
{

	int	nSize = collection.m_ptrArray.GetSize();

	for ( int nCount = 0; nCount < nSize; nCount++ )
	{
		TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		// Add will automatically AddRef the pointer again.
		Add( ptr );
	}

	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\resourcedesc.h ===
/////////////////////////////////////////////////////////////////////////

//

//  resourcedesc.h    

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj     
//              10/17/97        jennymc     Moved things a tiny bit
//  
/////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCEDESC_H__
#define __RESOURCEDESC_H__
#include "refptr.h"
#include "refptrlite.h"

#define	ResType_DeviceMgr_Ignored_Bit	0x00000040	// Don't know the exact reason for this but Device manager ignores them, so we will also ignore.

// Forward Class Definitions
class CConfigMgrDevice;

class 
__declspec(uuid("CD545F0E-D350-11d2-B35E-00104BC97924")) 
CResourceDescriptor : public CRefPtrLite
{
	
public:

	// Construction/Destruction
	CResourceDescriptor( PPOORMAN_RESDESC_HDR pResDescHdr, CConfigMgrDevice* pDevice );
	CResourceDescriptor( DWORD dwResourceId, LPVOID pResource, DWORD dwResourceSize, CConfigMgrDevice* pOwnerDevice );\
	CResourceDescriptor( const CResourceDescriptor& resource );
	~CResourceDescriptor();

	// Must be overridden by derived class, since we will only know
	// about the resource header.  From there, we assume that a class
	// derived off of us knows what to do with the remainder (if any)
	// of the data.

	virtual void * GetResource();

	BOOL	GetOwnerDeviceID( CHString& str );
	BOOL	GetOwnerHardwareKey( CHString& str );
	BOOL	GetOwnerName( CHString& str );
	CConfigMgrDevice*	GetOwner( void );

	DWORD	GetOEMNumber( void );
	DWORD	GetResourceType( void );
	BOOL	IsIgnored( void );

protected:

	BYTE*	m_pbResourceDescriptor;
	DWORD	m_dwResourceSize;

private:

	DWORD				m_dwResourceId;
	CConfigMgrDevice*	m_pOwnerDevice;
};

_COM_SMARTPTR_TYPEDEF(CResourceDescriptor, __uuidof(CResourceDescriptor));

inline DWORD CResourceDescriptor::GetOEMNumber( void )
{
	return ( m_dwResourceId & OEM_NUMBER_MASK );
}

inline DWORD CResourceDescriptor::GetResourceType( void )
{
	return ( m_dwResourceId & RESOURCE_TYPE_MASK );
}

inline BOOL CResourceDescriptor::IsIgnored( void )
{
	return ( (m_dwResourceId & ResType_Ignored_Bit) || (m_dwResourceId & ResType_DeviceMgr_Ignored_Bit) );
}

// A collection of Resource Descriptors
class CResourceCollection : public TRefPtr<CResourceDescriptor>
{
public:

	// Construction/Destruction
	CResourceCollection();
	~CResourceCollection();

	// Because we're inheriting, we need to declare this here
	// (= operator is not inherited).

	const CResourceCollection& operator = ( const CResourceCollection& srcCollection );

};

inline const CResourceCollection& CResourceCollection::operator = ( const CResourceCollection& srcCollection )
{
	// Call into the templated function
	Copy( srcCollection );
	return *this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\resourcemanager.cpp ===
//=================================================================

//

// ResourceManager.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

/*
 * Currently  the implementations of std::_Lockit::_Lockit() are in framedyn.dll
 * If this class is being used outside the scope of win32providers then an implementation of std::_Lockit::_Lockit() has to be provided
 * by the client ( I think!) .
 */

#include "precomp.h"

#include <assertbreak.h>
#include "ResourceManager.h"
#include "ProvExce.h"
#include <comdef.h>
#include "TimerQueue.h"

//initialize statics
/*
 * All the resources not released by clients or cached in the ResourceManager are forcibly freed in the ResourceManager destructor.
 * When a resource is freed , the resource tries to deregister the timeout rule from the TimerQueue, which means that the TimerQueue
 * has to be present when the ResourceManager destructor is fired,else we'll have a crash on Win9x. --RAID 50454
 */
//CTimerQueue CTimerQueue :: s_TimerQueue ;
//CResourceManager CResourceManager::sm_TheResourceManager ;

CResourceManager :: CResourceManager ()
{
   InitializeCriticalSection ( &m_csResourceManager ) ;
}

CResourceManager :: ~CResourceManager ()
{
	std::list < CResourceList* >::iterator pInstanceList ;
/*
 * Ideally, at this point of time when the global destructors get fired there should not be any resources in the resource manager,
 * but if there are any , we've to forcibly delete them. We're safe in doing this becuase the scheduler thread would've exited already
 * in DllCanUnloadNow & no other thread would be calling into the resource manager
 */
	LogMessage ( L"Entering ~CResourceManager" ) ;
	EnterCriticalSection ( &m_csResourceManager ) ;
	while ( !m_Resources.empty () )
	{
		delete m_Resources.front() ;
		m_Resources.pop_front() ;
	}
	LeaveCriticalSection ( &m_csResourceManager ) ;
	DeleteCriticalSection ( &m_csResourceManager ) ;
	LogMessage ( L"Leaving ~CResourceManager" ) ;
}


/*
 * This method checks if we've any resource leak
 */
void CResourceManager :: ForcibleCleanUp ()
{
	LogMessage ( L"Entering CResourceManager :: ForcibleCleanUp" ) ;
	std::list < CResourceList* >::iterator pInstanceList ;

	EnterCriticalSection ( &m_csResourceManager ) ;
	for ( pInstanceList = m_Resources.begin () ; pInstanceList != m_Resources.end () ; pInstanceList++ )
	{
		 ( *pInstanceList )->ShutDown () ;
	}
	LeaveCriticalSection ( &m_csResourceManager ) ;
	LogMessage  ( L"Leaving CResourceManager :: ForcibleCleanUp" ) ;
}


CResource* CResourceManager :: GetResource ( GUID ResourceId, PVOID pData )
{
	std::list < CResourceList* >::iterator pInstanceList ;
	for ( pInstanceList = m_Resources.begin () ; pInstanceList != m_Resources.end () ; pInstanceList++ )
	{
		if ( IsEqualGUID ( (*pInstanceList)->guidResourceId, ResourceId ) )
		{
			return (*pInstanceList)->GetResource ( pData ) ;
		}
	}
	return NULL ;
}

ULONG CResourceManager :: ReleaseResource ( GUID ResourceId, CResource* pResource )
{
	std::list < CResourceList* >::iterator pInstanceList ;
	for ( pInstanceList = m_Resources.begin () ; pInstanceList != m_Resources.end () ; pInstanceList++ )
	{
		if ( IsEqualGUID ( (*pInstanceList)->guidResourceId, ResourceId ) )
		{
			return (*pInstanceList)->ReleaseResource ( pResource ) ;
		}
	}
	return ULONG ( -1 )  ;
}

BOOL CResourceManager :: AddInstanceCreator ( GUID ResourceId, PFN_RESOURCE_INSTANCE_CREATOR pfnResourceInstanceCreator )
{
	EnterCriticalSection ( &m_csResourceManager ) ;

	//create a node & add it
	CResourceList *stResourceInstances = new CResourceList ;
	if ( stResourceInstances == NULL )
	{
		LeaveCriticalSection ( &m_csResourceManager ) ;
		throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
	}
	stResourceInstances->guidResourceId = ResourceId ;
	stResourceInstances->m_pfnInstanceCreator = pfnResourceInstanceCreator ;
	m_Resources.push_back ( stResourceInstances ) ;

	LeaveCriticalSection ( &m_csResourceManager ) ;
	return TRUE ;
}


CResourceList :: CResourceList ()
{
	m_bShutDown = FALSE ;
	InitializeCriticalSection( &m_csList );
}

CResourceList :: ~CResourceList ()
{
	m_bShutDown = TRUE ;
	ShutDown () ;
	DeleteCriticalSection( &m_csList );
}

CResource* CResourceList :: GetResource ( LPVOID pData )
{
	CResource* pTmpInstance = NULL ;
	tagInstances::iterator ppInstance ;
	BOOL bRet ;

	//check if we're shutting down
	if ( m_bShutDown )
	{
		return NULL ;
	}

	//Lock the list
	LockList () ;

	//check if we're shutting down
	if ( m_bShutDown )
	{
		UnLockList () ;
		return NULL ;
	}

	//go thru all the instances of this resource & hand out the first valid one
	for ( ppInstance  = m_Instances.begin(); ppInstance != m_Instances.end (); ppInstance++ )
	{
		//Check out if we've cached a similar instance
		if ( ( *ppInstance )->IsOneOfMe ( pData ) )
		{
			//try to acquire the resource...this will up the refcount.
			bRet = ( *ppInstance )->Acquire () ;

			if ( bRet )
			{
				pTmpInstance = *ppInstance ;
				break ;		//got the instance so break
			}
		}
	}

	//if we haven't got a cached instance to hand out, create a new instance
	if ( !pTmpInstance )
	{
		//this will create a new instance but the ref-count is still zero
		pTmpInstance = m_pfnInstanceCreator ( pData ) ;

		//Try to acquire the instance for the client ..which will up the ref-count
		if ( pTmpInstance )
		{
            try
            {
			    pTmpInstance->SetParent ( this ) ;
			    bRet = pTmpInstance->Acquire () ;

			    //if the acquire succeeded on the instance, add it to our list of cached instances
			    if ( bRet )
			    {
				    m_Instances.insert ( m_Instances.begin (), pTmpInstance ) ;
			    }
			    else
			    {
				    delete pTmpInstance ;
				    pTmpInstance = NULL ;
			    }
            }
            catch ( ... )
            {
				delete pTmpInstance ;
				pTmpInstance = NULL ;
                throw ;
            }
		}
	}
	UnLockList () ;
	return pTmpInstance ;
}

ULONG CResourceList :: ReleaseResource ( CResource* pResource )
{
	CResource* pTmpInstance = NULL ;
	tagInstances::iterator ppInstance ;
	LONG lCount = -1 ;

	//check if we're shutting down
	if ( m_bShutDown )
	{
		return NULL ;
	}


	//Lock the list
	LockList () ;

	//check if we're shutting down
	if ( m_bShutDown )
	{
		UnLockList () ;
		return lCount ;
	}

	//Go thru the list & release the resource
	for ( ppInstance  = m_Instances.begin(); ppInstance != m_Instances.end (); ppInstance++ )
	{
		if ( *ppInstance == pResource )
		{
			lCount = pResource->Release () ;
			break ;
		}
	}
	UnLockList () ;
	return lCount ;
}


//This function will be called by the CResource to remove it's entry from the list of instances. The resource should have a
//lock on the list before it attempts to do this
void CResourceList :: RemoveFromList ( CResource* pResource )
{
	tagInstances::iterator ppInstance ;

	//Go thru the list & remove the link to the resource
	for ( ppInstance  = m_Instances.begin(); ppInstance != m_Instances.end (); ppInstance++ )
	{
		if ( *ppInstance == pResource )
		{
			m_Instances.erase ( ppInstance ) ;
			break ;
		}
	}
}

BOOL CResourceList :: LockList ()
{
	EnterCriticalSection ( &m_csList ) ;
	return TRUE ;
}

BOOL CResourceList :: UnLockList ()
{
	LeaveCriticalSection ( &m_csList ) ;
	return TRUE ;
}

void CResourceList :: ShutDown ()
{
	LockList () ;

	LPOLESTR t_pOleStr = NULL ;
	CHString t_chsListGuid ;
	if ( StringFromCLSID ( guidResourceId , &t_pOleStr ) == S_OK )
	{
		t_chsListGuid = t_pOleStr ;
		CoTaskMemFree ( t_pOleStr ) ;
	}

	tagInstances::iterator ppInstance ;

	//Go thru the list & remove the link to the resource
	while ( !m_Instances.empty () )
	{
#if (defined DEBUG || defined _DEBUG)
        // Note that this COULD be because there is a timer rule, and the time hasn't expired
        // before the DllCanUnloadNow function is called by com (that's who calls this function).
		LogErrorMessage3 ( L"%s%s" , L"Resource not released before shutdown = " , t_chsListGuid ) ;
#endif
		m_Instances.pop_front() ;
	}

	UnLockList () ;
}

CResource :: CResource ()
{
	m_pRules = NULL ;
	m_lRef = 0 ;
	m_pResources = NULL ;
}

CResource :: ~CResource ()
{
}

//This function increments ref-count of the object & calls into the virtual overridables OnAcquire or OnInitialAcquire
//The derived class should override these functions if it wants to & decrement the ref-count if it wants the Acquire
//operation to fail
BOOL CResource::Acquire ()
{
	BOOL bRet ;
	++m_lRef ;
	if ( m_lRef == 1 )
	{
		bRet = OnInitialAcquire () ;
	}
	else
	{
		bRet = OnAcquire () ;
	}

	if ( m_lRef == 0 )
	{
		m_pResources->RemoveFromList ( this ) ;
		if ( m_pRules )
		{
			//since we're going away, we detach ourselves from the rule so that the rules don't call into us
			m_pRules->Detach () ;
			m_pRules->Release () ;
			m_pRules = NULL ;
		}
		delete this ;
	}

	return bRet ;
}

ULONG CResource::Release ()
{
	BOOL bRet ;
	ULONG lCount = 0 ;
	--m_lRef ;
	if ( m_lRef == 0 )
	{
		bRet = OnFinalRelease () ;
	}
	else
	{
		bRet = OnRelease () ;
	}

	if ( bRet )
	{
		if ( m_lRef == 0 )
		{
			m_pResources->RemoveFromList ( this ) ;
			if ( m_pRules )
			{
				//since we're going away, we detach ourselves from the rule so that the rules don't call into us
				m_pRules->Detach () ;
				m_pRules->Release () ;
				m_pRules = NULL ;
			}
			delete this ;
			return lCount ;
		}
	}

	return m_lRef ;
}
/*
void CResource :: RuleEvaluated ( const CRule *a_RuleEvaluated )
{
	if ( m_pRules )
	{
		return m_pRules->CheckRule () ;
	}
	else
	{
		return FALSE ;
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\resourcedesc.cpp ===
/////////////////////////////////////////////////////////////////////////

//

//  ResourceDesc.cpp

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  History:    10/15/97        Sanj        Created by Sanj
//              10/17/97        jennymc     Moved things a tiny bit
//
/////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "refptr.h"
#include "poormansresource.h"

#include "resourcedesc.h"
#include "cfgmgrdevice.h"

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::CResourceDescriptor
//
//	Class Constructor.
//
//	Inputs:		PPOORMAN_RESDESC_HDR	pResDescHdr - Resource Descriptor
//										header used to get resource info
//										plus the raw bytes following.
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceDescriptor::CResourceDescriptor(	PPOORMAN_RESDESC_HDR	pResDescHdr,
											CConfigMgrDevice*		pOwnerDevice )
:	CRefPtrLite(),
	m_pbResourceDescriptor( NULL ),
	m_dwResourceSize( 0 ),
	m_dwResourceId( 0 ),
	m_pOwnerDevice( pOwnerDevice )
{
	// At least try to validate the pointer first

	if ( NULL != pResDescHdr )
	{
		m_dwResourceSize = pResDescHdr->dwResourceSize;

		if ( 0 != m_dwResourceSize )
		{
			m_dwResourceId = pResDescHdr->dwResourceId;

			// Now axe the size of the resource descriptor, since we have
			// stored the necessary information therein.
			m_dwResourceSize -= SIZEOF_RESDESC_HDR;

			BYTE*	pbData = new BYTE[m_dwResourceSize];

			if ( NULL != pbData )
			{
				// The header tells us how long the block of data including the
				// header is.

                try
                {
				    CopyMemory( pbData, ( ( (PBYTE) pResDescHdr ) + SIZEOF_RESDESC_HDR ), m_dwResourceSize );
                }
                catch ( ... )
                {
                    delete [] pbData;
                    throw ;
                }

				// A derived class will interpret the raw bytes pointed to by this
				// value.

				m_pbResourceDescriptor = pbData;
			}
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }


		}	// IF 0 != m_dwSizeOfData

	}	// IF NULL != pResDescHdr

	// AddRef the owner device
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->AddRef();
	}
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::CResourceDescriptor
//
//	Class Constructor.
//
//	Inputs:		DWORD					dwResourceId - Type of Resource
//				LPVOID					pResource - Data Buffer containing
//										resource specific data.
//				DWORD					dwResourceSize - Size of Buffer
//				CConfigMgrDevice*		pOwnerDevice - Pointer to the
//										owner config manager device.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceDescriptor::CResourceDescriptor(	DWORD					dwResourceId,
											LPVOID					pResource,
											DWORD					dwResourceSize,
											CConfigMgrDevice*		pOwnerDevice )
:	CRefPtrLite(),
	m_pbResourceDescriptor( NULL ),
	m_dwResourceSize( dwResourceSize ),
	m_dwResourceId( dwResourceId ),
	m_pOwnerDevice( pOwnerDevice )
{

	if	(	0		!=	m_dwResourceSize
		&&	NULL	!=	pResource			)
	{
		BYTE*	pbData = new BYTE[m_dwResourceSize];

		if ( NULL != pbData )
		{
			// The header tells us how long the block of data including the
			// header is.

			CopyMemory( pbData, pResource, m_dwResourceSize );

			// A derived class will interpret the raw bytes pointed to by this
			// value.

			m_pbResourceDescriptor = pbData;

		}	// IF NULL != pbData

	}	// IF 0 != m_dwResourceSize && pResource

	// AddRef the owner device
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->AddRef();
	}

}

CResourceDescriptor::CResourceDescriptor( const CResourceDescriptor& resource )
:	CRefPtrLite(),
	m_pbResourceDescriptor( NULL ),
	m_dwResourceSize( 0 ),
	m_dwResourceId( 0 ),
	m_pOwnerDevice( NULL )
{
	m_dwResourceSize = resource.m_dwResourceSize;
	m_dwResourceId = resource.m_dwResourceId;
	m_pbResourceDescriptor = new BYTE[m_dwResourceSize];

	if ( NULL != m_pbResourceDescriptor )
	{
		CopyMemory( m_pbResourceDescriptor, resource.m_pbResourceDescriptor, m_dwResourceSize );
	}

	m_pOwnerDevice = resource.m_pOwnerDevice;

	// AddRef the owner device
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->AddRef();
	}

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::~CResourceDescriptor
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceDescriptor::~CResourceDescriptor( void )
{
	if ( NULL != m_pbResourceDescriptor )
	{
		delete [] m_pbResourceDescriptor;
	}

	// Owner device should be released now.
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->Release();
	}

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetResource()
//
//	Returns a string representation of the associated resource value.
//	This value may be a number, a range or whatever the overriding
//	implementation returns.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		None.
//
//	Comments:	Derived classes MUST implement this function to get
//				a useful value.  This base implementation just empties
//				the string.
//
////////////////////////////////////////////////////////////////////////

void *CResourceDescriptor::GetResource()
{
	return NULL;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetOwnerHardwareKey
//
//	Queries the owner device for its hardware key.
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CResourceDescriptor::GetOwnerHardwareKey( CHString& str )
{
	BOOL	fReturn = ( NULL != m_pOwnerDevice );

	if ( NULL != m_pOwnerDevice )
	{
		str = m_pOwnerDevice->GetHardwareKey();
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetOwnerDeviceID
//
//	Queries the owner device for its Device ID
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CResourceDescriptor::GetOwnerDeviceID( CHString& str )
{
	BOOL	fReturn = ( NULL != m_pOwnerDevice );

	if ( NULL != m_pOwnerDevice )
	{
		fReturn = m_pOwnerDevice->GetDeviceID( str );
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetOwnerName
//
//	Queries the owner device for its Name (DeviceDesc).
//
//	Inputs:		None.
//
//	Outputs:	CHString&		str - Storage for string.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

BOOL CResourceDescriptor::GetOwnerName( CHString& str )
{
	BOOL	fReturn = ( NULL != m_pOwnerDevice );

	if ( NULL != m_pOwnerDevice )
	{
		fReturn = m_pOwnerDevice->GetDeviceDesc( str );
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceDescriptor::GetOwner
//
//	Returns an AddRef'd pointer to the owner device
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		CConfigMgrDevice*	NULL if no pointer
//
//	Comments:	Caller MUST call release on the returned
//				pointer.
//
////////////////////////////////////////////////////////////////////////

CConfigMgrDevice *CResourceDescriptor::GetOwner( void )
{
	if ( NULL != m_pOwnerDevice )
	{
		m_pOwnerDevice->AddRef();
	}

	return m_pOwnerDevice;
}

//
//	Constructor and Destructor for the Resource Descriptor Collection
//	object.
//

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceCollection::CResourceCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceCollection::CResourceCollection( void )
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CResourceCollection::~CResourceCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

CResourceCollection::~CResourceCollection( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\securefile.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CSecureFile.h - header file for CSecureFile class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSECUREFILE_H__
#define __CSECUREFILE_H__

		


////////////////////////////////////////////////////////////////
//
//	Class:	CSecureFile
//
//	This class is intended to encapsulate the security of an
//	NT File or Directory.  It inherits off of CSecurityDescriptor
//	and it is that class to which it passes Security Descriptors
//	it obtains, and from which it receives previously built
//	security descriptors to apply.  It supplies implementations
//	for AllAccessMask(), WriteOwner() and WriteAcls().
//
////////////////////////////////////////////////////////////////

class CSecureFile : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CSecureFile();
		CSecureFile( LPCTSTR pszFileName, BOOL fGetSACL = TRUE );
        CSecureFile
        (   
            LPCTSTR a_pszFileName,
            CSid* a_psidOwner,
            bool a_fOwnerDefaulted,
            CSid* a_psidGroup,
            bool a_fGroupDefaulted,
            CDACL* a_pDacl,
            bool a_fDaclDefaulted,
            bool a_fDaclAutoInherited,
            CSACL* a_pSacl,
            bool a_fSaclDefaulted,
            bool a_fSaclAutoInherited
        );
		CSecureFile( LPCTSTR pszFileName, PSECURITY_DESCRIPTOR pSD ) ;
		~CSecureFile();

		DWORD	SetFileName( LPCTSTR pszFileName, BOOL fGetSACL = TRUE );

		virtual DWORD AllAccessMask( void );
		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD );
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD , SECURITY_INFORMATION securityinfo  );

	private:
		CHString	m_strFileName;

};

#endif // __CSecureFile_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\sacl.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CSACL.h - header file for CSACL class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSACL_H__
#define __CSACL_H__

#include "AccessEntryList.h"



enum SACL_Types
{
    ENUM_SYSTEM_AUDIT_OBJECT_ACE_TYPE = 0,
/********************************* type not yet supported under w2k ********************************************
    ENUM_SYSTEM_ALARM_OBJECT_ACE_TYPE,
/**************************************************************************************************************/
    ENUM_SYSTEM_AUDIT_ACE_TYPE,
/********************************* type not yet supported under w2k ********************************************
    ENUM_SYSTEM_ALARM_ACE_TYPE,
/**************************************************************************************************************/
    // Keep this as the last entry in this enum:
    NUM_SACL_TYPES
};

#define SACLTYPE short


//////////////////////////////////////////////////////////////////
//
//	Class: CSACL
//
//	Class encapsulates a Win32 SACL, by providing public methods
//	for manipulating System Auditing entries only.
//
//////////////////////////////////////////////////////////////////

class CSACL
{
	// Constructors and destructor
	public:
		CSACL();
		~CSACL( void );

        DWORD Init(PACL	pSACL);

		bool AddSACLEntry( PSID psid, 
                           SACLTYPE SaclType, 
                           DWORD dwAccessMask, 
                           BYTE bAceFlags,
                           GUID *pguidObjGuid, 
                           GUID *pguidInhObjGuid );

        bool RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, DWORD dwIndex = 0  );
		bool RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid ); 
        

		bool CopySACL ( CSACL & dacl );
		bool AppendSACL ( CSACL & dacl );
        bool IsEmpty();
        bool GetMergedACL(CAccessEntryList& a_aclIn);

        DWORD ConfigureSACL( PACL& pSACL );
		DWORD FillSACL( PACL pSACL );
		BOOL CalculateSACLSize( LPDWORD pdwSACLLength );

        // Override of functions of same name from CAccessEntry
        virtual bool Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );
        virtual bool Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace );
        void Clear();

        void DumpSACL(LPCWSTR wstrFilename = NULL);
    
    private:

        CAccessEntryList* m_SACLSections;  // at the moment, sacl's only have one section, so this is not an array as it is in DACL.CPP
};





inline bool CSACL::CopySACL ( CSACL& sacl )
{
	bool fRet = true;

    if(m_SACLSections != NULL)
    {
        delete m_SACLSections;
        m_SACLSections = NULL;
    }

    try
    {
        m_SACLSections = new CAccessEntryList;   
    }
    catch(...)
    {
        if(m_SACLSections != NULL)
        {
            delete m_SACLSections;
            m_SACLSections = NULL;
        }
        throw;
    }

    if(m_SACLSections != NULL)
    {
        fRet = m_SACLSections->Copy(*(sacl.m_SACLSections));
    }
    else
    {
        fRet = false;
    }
    
    return fRet;
}

inline bool CSACL::AppendSACL ( CSACL& sacl )
{
	bool fRet = FALSE;

    if(m_SACLSections == NULL)
    {
        try
        {
            m_SACLSections = new CAccessEntryList;   
        }
        catch(...)
        {
            if(m_SACLSections != NULL)
            {
                delete m_SACLSections;
                m_SACLSections = NULL;
            }
            throw;
        }
    }

    if(m_SACLSections != NULL)
    {
        fRet = m_SACLSections->AppendList(*(sacl.m_SACLSections));
    }
    else
    {
        fRet = false;
    }
    
    return fRet;
}

inline bool CSACL::IsEmpty()
{
    bool fIsEmpty = true;
    if(m_SACLSections != NULL)
    {
        fIsEmpty = m_SACLSections->IsEmpty();
    }
    return fIsEmpty;
}


#endif // __CAccessEntry_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\resourcemanager.h ===
//=================================================================

//

// ResourceManager.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __RESOURCEMANAGER_H__
#define __RESOURCEMANAGER_H__
#include <windows.h>
#include <list>
#include <BrodCast.h>
#include <fwcommon.h>
#include <assertbreak.h>

#define DUPLICATE_RELEASE FALSE

class CResourceManager ;
class CResourceList ;
class CResource ;
class CRule ;
class CBinaryRule ;
class CAndRule ;
class COrRule ;

typedef CResource* (*PFN_RESOURCE_INSTANCE_CREATOR) ( PVOID pData ) ;

class CResourceList
{
friend class CResourceManager ;

protected:

	CResource* GetResource ( LPVOID pData ) ;
	ULONG ReleaseResource ( CResource* pResource ) ;
	void ShutDown () ;

protected:

	typedef std::list<CResource*>  tagInstances ;
	tagInstances m_Instances ;	
	PFN_RESOURCE_INSTANCE_CREATOR m_pfnInstanceCreator ;
	GUID guidResourceId ;
	
	CRITICAL_SECTION m_csList ; 

public:	

	CResourceList () ;
	~CResourceList () ;

	void RemoveFromList ( CResource* pResource ) ;
	
	BOOL LockList () ;		
	BOOL UnLockList () ;		

public:

	BOOL m_bShutDown ;
} ;

class CResourceManager 
{
protected:

	std::list < CResourceList* > m_Resources ;
	CRITICAL_SECTION m_csResourceManager ;

public:

	CResourceManager () ;
	~CResourceManager () ;

	CResource* GetResource ( GUID ResourceId, LPVOID pData ) ;
	ULONG ReleaseResource ( GUID ResourceId, CResource* pResource ) ;	

	BOOL AddInstanceCreator ( GUID ResourceId, PFN_RESOURCE_INSTANCE_CREATOR pfnResourceInstanceCreator ) ;
	void CResourceManager :: ForcibleCleanUp () ;

	static CResourceManager sm_TheResourceManager ;
};

class CResource
{
protected:

	CRule *m_pRules ;
	CResourceList *m_pResources ; //pointer to container
	LONG m_lRef ;

protected:

	virtual BOOL OnAcquire ()			{ return TRUE ; } ;
	virtual BOOL OnRelease ()			{ return TRUE ; } ;
	virtual BOOL OnInitialAcquire ()	{ return TRUE ; } ;
	virtual BOOL OnFinalRelease()		{ return TRUE ; } ;

public:

	CResource () ;
	virtual ~CResource () ;

	//returns true on success & increments ref-count
	virtual void RuleEvaluated ( const CRule *a_RuleEvaluated ) = 0 ;

	BOOL Acquire () ;
	ULONG Release () ;
	void SetParent ( CResourceList *pList ) { m_pResources = pList ; }

	virtual BOOL IsOneOfMe ( LPVOID pData ) { return TRUE ; } 
	
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//													Rules
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CRule
{
protected:	

	CResource* m_pResource ;
	LONG m_lRef ;

public:

	CRule ( CResource* pResource ) : m_pResource ( pResource ), m_lRef ( 0 ) {}
	virtual ~CRule () {} ;
	
	virtual ULONG AddRef () 
	{
		return ( InterlockedIncrement ( &m_lRef ) ) ;
	}
	
	virtual ULONG Release () 
	{
		LONG lCount ;

		lCount = InterlockedDecrement ( &m_lRef );
		try
		{
			if (IsVerboseLoggingEnabled())
			{
				LogMessage2(L"CRule::Release, count is (approx) %d", m_lRef);
			}
		}
		catch ( ... )
		{
		}

		if ( lCount == 0 )
		{
		   try
		   {
				LogMessage(L"CRule Ref Count = 0");
		   }
		   catch ( ... )
		   {
		   }
		   delete this;
		}
		else if (lCount > 0x80000000)
		{
			ASSERT_BREAK(DUPLICATE_RELEASE);
			LogErrorMessage(L"Duplicate CRule Release()");
		}

		return lCount ;
	}

	virtual void Detach ()
	{
		if ( m_pResource )
		{
			m_pResource = NULL ;
		}
	}

	//Checkrule returns true if rule is satisfied
	virtual BOOL CheckRule () { return FALSE ; } 
} ;

class CBinaryRule : public CRule
{
protected:

	CRule *pLeft ;
	CRule *pRight ;

public:

	CBinaryRule ( CResource* pResource ) : CRule ( pResource )
	{
		pLeft = pRight = 0 ;
	}
	
	~CBinaryRule() {}

	ULONG AddRef () 
	{
		LONG lCount = CRule::AddRef () ;
		if ( pLeft )
		{
			pLeft->AddRef () ;
		}
		if ( pRight )
		{
			pRight->AddRef () ;
		}
		return lCount ;
	}
	
	ULONG Release () 
	{
		if ( pLeft )
		{
			pLeft->Release () ;
		}
		if ( pRight )
		{
			pRight->Release () ;
		}

		LONG lCount  = CRule::Release () ;
		return lCount ;
	}

	void Detach ()
	{
		CRule::Detach () ;
		if ( pLeft )
		{
			pLeft->Detach () ;
		}

		if ( pRight )
		{
			pRight->Detach () ;
		}
	}
	
} ;

class CAndRule : public CBinaryRule
{
public:

	CAndRule ( CResource* pResource ) : CBinaryRule ( pResource ) {}
	~CAndRule() {}

	BOOL CheckRule ()
	{
		BOOL bRet = pLeft->CheckRule () ;
		if ( bRet )
		{
			bRet = pRight->CheckRule () ;
		}

		return bRet ;
	}

} ;

class COrRule : public CBinaryRule
{
public:

	COrRule ( CResource* pResource ) : CBinaryRule ( pResource ) {}
	~COrRule () {}

	BOOL CheckRule ()
	{
		BOOL bRet = pLeft->CheckRule () ;
		if ( !bRet )
		{
			bRet = pRight->CheckRule () ;
		}

		return bRet ;
	}
} ;

#endif //__RESOURCEMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\sacl.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	CSACL.cpp - implementation file for CAccessEntry class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include "aclapi.h"
#include "AccessEntryList.h"
#include "SACL.h"
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::CSACL
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSACL::CSACL( void )
 : m_SACLSections(NULL)
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::~CSACL
//
//	Class destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSACL::~CSACL( void )
{
    Clear();
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSCL::Init
//
//	Initializes the SACL member list.
//
//	Inputs:
//
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD CSACL::Init(PACL	a_pSACL)
{
    DWORD t_dwRes = E_FAIL;
    if(a_pSACL == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(m_SACLSections != NULL)
    {
        delete m_SACLSections;
        m_SACLSections = NULL;
    }

    try
    {
        m_SACLSections = new CAccessEntryList;
    }
    catch(...)
    {
        if(m_SACLSections != NULL)
        {
            delete m_SACLSections;
            m_SACLSections = NULL;
        }
        throw;
    }

    t_dwRes = m_SACLSections->InitFromWin32ACL(a_pSACL);

    return t_dwRes;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::AddSACLEntry
//
//	Adds a System Audit entry to the ACL.  By default, these go
//	to the front of the list.
//
//	Inputs:
//				PSID		psid - PSID
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSACL::AddSACLEntry( PSID psid, SACLTYPE SaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool fReturn = true;
    BYTE bACEType;

	// Sid must be valid
	if ( (psid != NULL) && IsValidSid( psid ) )
	{
		switch(SaclType)
        {
            case ENUM_SYSTEM_AUDIT_ACE_TYPE:
                bACEType = SYSTEM_AUDIT_ACE_TYPE;
                break;
/********************************* type not yet supported under w2k ********************************************
            case ENUM_SYSTEM_ALARM_ACE_TYPE:
                bACEType = SYSTEM_ALARM_ACE_TYPE;
                break;
/********************************* type not yet supported under w2k ********************************************/
            case ENUM_SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                bACEType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
                break;
/********************************* type not yet supported under w2k ********************************************
            case ENUM_SYSTEM_ALARM_OBJECT_ACE_TYPE:
                bACEType = SYSTEM_ALARM_OBJECT_ACE_TYPE;
                break;
/********************************* type not yet supported under w2k ********************************************/
            default:
                fReturn = false;
                break;
        }

        // We will overwrite the Access Mask of a duplicate entry.
		if(fReturn)
        {
            if(m_SACLSections == NULL)
            {
                try
                {
                    m_SACLSections = new CAccessEntryList;
                }
                catch(...)
                {
                    if(m_SACLSections != NULL)
                    {
                        delete m_SACLSections;
                        m_SACLSections = NULL;
                    }
                    throw;
                }
                if(m_SACLSections != NULL)
                {
                    fReturn = m_SACLSections->AppendNoDup( psid, bACEType, bAceFlags, dwAccessMask, pguidObjGuid, pguidInhObjGuid );
                }
            }
            else
            {
                fReturn = m_SACLSections->AppendNoDup( psid, bACEType, bAceFlags, dwAccessMask, pguidObjGuid, pguidInhObjGuid );
            }
        }
	}
    else
    {
        fReturn = true;
    }

	return fReturn;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::RemoveSACLEntry
//
//	Removes a system audit entry from the ACL.
//
//	Inputs:
//				CSid&		sid - PSID
//				DWORD		dwAccessMask - Access Mask
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST match the supplied parameters.
//
///////////////////////////////////////////////////////////////////

bool CSACL::RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, DWORD dwAccessMask, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool	fReturn = false;

	// We need an ACE to compare
	CAccessEntry	ACE( &sid, SYSTEM_AUDIT_ACE_TYPE, bAceFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask );
	ACLPOSITION		pos;

	if ( m_SACLSections->BeginEnum( pos ) )
	{
		CAccessEntry*	pACE = NULL;
        try
        {
            // For loop will try to find a matching ACE in the list
		    for (	CAccessEntry*	pACE = m_SACLSections->GetNext( pos );
				    NULL != pACE
			    ||	ACE == *pACE;
				    pACE = m_SACLSections->GetNext( pos ) );
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }

		// If we got a match, delete the ACE.
		if ( NULL != pACE )
		{
			m_SACLSections->Remove( pACE );
			delete pACE;
			fReturn = true;
		}

		m_SACLSections->EndEnum( pos );

	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::RemoveSACLEntry
//
//	Removes a system audit entry from the ACL.
//
//	Inputs:
//				CSid&		sid - PSID
//				BYTE		bAceFlags - Flags
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removed entry MUST match the supplied parameters.
//
///////////////////////////////////////////////////////////////////

bool CSACL::RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, BYTE bAceFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool	fReturn = false;

	// We need an ACE to compare
	ACLPOSITION		pos;

	if ( m_SACLSections->BeginEnum( pos ) )
	{
		// For loop will try to find a matching ACE in the list
        CAccessEntry*	pACE = NULL;
        try
        {
		    for (	pACE = m_SACLSections->GetNext( pos );
				    NULL != pACE;
				    pACE = m_SACLSections->GetNext( pos ) )
		    {
                CAccessEntry caeTemp(sid, SaclType, bAceFlags, pguidObjGuid, pguidInhObjGuid, pACE->GetAccessMask());
			    // If we got a match, delete the ACE.
			    if (*pACE == caeTemp)
			    {
				    m_SACLSections->Remove( pACE );
				    fReturn = true;
				    break;
			    }
                delete pACE;
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }
		m_SACLSections->EndEnum( pos );
	}
	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::RemoveSACLEntry
//
//	Removes a system audit entry from the ACL.
//
//	Inputs:
//				CSid&		sid - PSID
//				DWORD		dwIndex - Index to remove.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		Success/Failure
//
//	Comments:
//
//	Removes dwIndex entry matching sid.
//
///////////////////////////////////////////////////////////////////

bool CSACL::RemoveSACLEntry( CSid& sid, SACLTYPE SaclType, DWORD dwIndex /*= 0*/ )
{
	bool	fReturn = false;

	// We need an ACE to compare
	CSid			tempsid;
	ACLPOSITION		pos;
	DWORD			dwCtr = 0;

	if ( m_SACLSections->BeginEnum( pos ) )
	{

		// For each ACE we find, see if it is an SYSTEM_AUDIT_ACE_TYPE,
		// and if the Sid matches the one passed in.  If it does, increment
		// the counter, then if we're on the right index remove the ACE,
		// delete it and quit.
        CAccessEntry*	pACE = NULL;
        try
        {
		    for (	pACE = m_SACLSections->GetNext( pos );
				    NULL != pACE;
				    pACE = m_SACLSections->GetNext( pos ) )
		    {
			    if ( SYSTEM_AUDIT_ACE_TYPE == pACE->GetACEType() )
			    {
				    pACE->GetSID( tempsid );

				    if ( sid == tempsid )
				    {
					    if ( dwCtr == dwIndex )
					    {
						    m_SACLSections->Remove( pACE );
						    fReturn = true;
						    break;
					    }
					    else
					    {
						    ++dwCtr;
					    }
				    }
                    delete pACE;
			    }
		    }
        }
        catch(...)
        {
            if(pACE != NULL)
            {
                delete pACE;
                pACE = NULL;
            }
            throw;
        }

		m_SACLSections->EndEnum( pos );

	}
	return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::Find
//
//	Finds the specified ace in the dacl
//
//
//	Returns:
//				true if found it.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////
bool CSACL::Find( const CSid& sid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
     return m_SACLSections->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::Find
//
//	Finds the specified ace in the dacl
//
//
//	Returns:
//				true if found it.
//
//	Comments:
//
//	Helps support NT 5 canonical order in DACLs.
//
///////////////////////////////////////////////////////////////////
bool CSACL::Find( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace )
{
    return m_SACLSections->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::::ConfigureSACL
//
//	Configures a Win32 PACL with SACL information.
//
//	Inputs:
//				None.
//
//	Outputs:
//				PACL&			pSacl - Pointer to a SACL.
//
//	Returns:
//				DWORD			ERROR_SUCCESS if successful.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSACL::ConfigureSACL( PACL& pSacl )
{
	DWORD		dwReturn		=	ERROR_SUCCESS,
				dwSACLLength	=	0;

	if ( CalculateSACLSize( &dwSACLLength ) )
	{

		if ( 0 != dwSACLLength )
		{
            pSacl = NULL;
            try
            {
			    pSacl = (PACL) malloc( dwSACLLength );

			    if ( NULL != pSacl )
			    {
				    if ( !InitializeAcl( (PACL) pSacl, dwSACLLength, ACL_REVISION ) )
				    {
					    dwReturn = ::GetLastError();
				    }

			    }	// If NULL != pSACL
            }
            catch(...)
            {
                if(pSacl != NULL)
                {
                    free(pSacl);
                    pSacl = NULL;
                }
                throw;
            }

		}	// If 0 != dwSACLLength

	}	// If Calcaulate SACL Size
	else
	{
		dwReturn = ERROR_INVALID_PARAMETER;	// One or more of the SACLs is bad
	}

	if ( ERROR_SUCCESS == dwReturn )
	{
		dwReturn = FillSACL( pSacl );
	}

	if ( ERROR_SUCCESS != dwReturn )
	{
		free( pSacl );
		pSacl = NULL;
	}

	return dwReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::::CalculateSACLSize
//
//	Obtains the size necessary to populate a SACL.
//
//	Inputs:
//				None.
//
//	Outputs:
//				LPDWORD			pdwSACLLength - Calculated Length.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CSACL::CalculateSACLSize( LPDWORD pdwSACLLength )
{
	BOOL			fReturn			=	FALSE;

	*pdwSACLLength = 0;

	if ( NULL != m_SACLSections )
	{
		fReturn = m_SACLSections->CalculateWin32ACLSize( pdwSACLLength );
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSACL::FillSACL
//
//	Fills out a SACL.
//
//	Inputs:
//				PACL			pSacl - Sacl to fill out.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSACL::FillSACL( PACL pSACL )
{
	DWORD	dwReturn = ERROR_SUCCESS;

	if ( NULL != m_SACLSections )
	{
		dwReturn = m_SACLSections->FillWin32ACL( pSACL );
	}

	return dwReturn;

}


void CSACL::Clear()
{
	if ( NULL != m_SACLSections )
	{
		delete m_SACLSections;
        m_SACLSections = NULL;
	}
}


bool CSACL::GetMergedACL
(
    CAccessEntryList& a_aclIn
)
{
    // Actually somewhat of a misnomer for the time being (until the
    // day when the sacl ordering matters, and we have multiple sections
    // as we do in dacl for that reason).  We just hand back our
    // member acl, if it is not null:
    bool fRet = false;
    if(m_SACLSections != NULL)
    {
        fRet = a_aclIn.Copy(*m_SACLSections);
    }
    return fRet;
}

void CSACL::DumpSACL(LPCWSTR wstrFilename)
{
    Output(L"SACL contents follow...", wstrFilename);
    if(m_SACLSections != NULL)
    {
        m_SACLSections->DumpAccessEntryList(wstrFilename);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\securekernelobj.h ===
/*****************************************************************************/

/*  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	SecureKernelObj.h - header file for CSecureKernelObj class.
 *
 *	Created:	11-27-00 by Kevin Hughes
 *				
 */

#pragma once

		


////////////////////////////////////////////////////////////////
//
//	Class:	CSecureKernelObj
//
//	This class is intended to encapsulate the security of an
//	NT kernel securable object.  It inherits off of CSecurityDescriptor
//	and it is that class to which it passes Security Descriptors
//	it obtains, and from which it receives previously built
//	security descriptors to apply.  It supplies implementations
//	for AllAccessMask(), WriteOwner() and WriteAcls().
//
////////////////////////////////////////////////////////////////

class CSecureKernelObj : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CSecureKernelObj();

		CSecureKernelObj(
            HANDLE hObject,
            BOOL fGetSACL = TRUE);


		CSecureKernelObj(
            HANDLE hObject,
            PSECURITY_DESCRIPTOR pSD);

		virtual ~CSecureKernelObj();

		DWORD SetObject(
            HANDLE hObject, 
            BOOL fGetSACL = TRUE);

		virtual DWORD AllAccessMask(void);
		virtual DWORD WriteOwner(PSECURITY_DESCRIPTOR pAbsoluteSD);
		virtual DWORD WriteAcls(
            PSECURITY_DESCRIPTOR pAbsoluteSD, 
            SECURITY_INFORMATION securityinfo);

	private:

        HANDLE m_hObject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\securekernelobj.cpp ===
/*****************************************************************************/

/*  Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	SecurityDescriptor.cpp - implementation file for CSecureKernelObj class.
 *
 *	Created:	11-27-00 by Kevin Hughes
 */

#include "precomp.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class


#include "SecurityDescriptor.h"
#include "securefile.h"
#include "tokenprivilege.h"
#include "ImpersonateConnectedUser.h"
#include "ImpLogonUser.h"
#include "AdvApi32Api.h"
#include "smartptr.h"
#include "SecureKernelObj.h"


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::CSecureKernelObj
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureKernelObj::CSecureKernelObj()
:	CSecurityDescriptor()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::CSecureKernelObj
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCWSTR		wszObjName - The kernel object to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureKernelObj::CSecureKernelObj(
    HANDLE hObject, 
    BOOL fGetSACL /*= TRUE*/ )
:	CSecurityDescriptor()
{
	SetObject(hObject, fGetSACL);
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::CSecureKernelObj
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCWSTR					wszObjName	-	The object name to handle
//														security for.
//
//				PSECURITY_DESCRIPTOR	pSD			-	The Security Descriptor to associate with this object
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureKernelObj::CSecureKernelObj(
    HANDLE hObject, 
    PSECURITY_DESCRIPTOR pSD)
:	CSecurityDescriptor()
{
	if(InitSecurity(pSD))
	{
		// we just get a copy - we don't take ownership.
        m_hObject = hObject;
	}
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::~CSecureKernelObj
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureKernelObj::~CSecureKernelObj(void)
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::SetObject
//
//	Public Entry point to set which object this instance
//	of the class is to supply security for.
//
//	Inputs:
//				HANDLE		hObject - The object to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
//	This will clear any previously set filenames and/or security
//	information.
//
///////////////////////////////////////////////////////////////////

DWORD CSecureKernelObj::SetObject(
    HANDLE hObject, 
    BOOL fGetSACL /*= TRUE*/ )
{
	DWORD					dwError = ERROR_SUCCESS;
	SECURITY_INFORMATION	siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;


    // We must have the security privilege enabled in order to access the object's SACL
    CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( fGetSACL )
	{
		fDisablePrivilege = (securityPrivilege.Enable() == ERROR_SUCCESS);
		siFlags |= SACL_SECURITY_INFORMATION;
	}


	// Determine the length needed for self-relative SD
	DWORD dwLengthNeeded = 0;

    BOOL fSuccess = ::GetKernelObjectSecurity(
        hObject,
		siFlags,
		NULL,
		0,
		&dwLengthNeeded);

    dwError = ::GetLastError();

    // It is possible that the user lacked the permissions required to obtain the SACL,
    // even though we set the token's SE_SECURITY_NAME privilege.  So if we obtained an
    // access denied error, try it again, this time without requesting the SACL.
    if(dwError == ERROR_ACCESS_DENIED  || dwError == ERROR_PRIVILEGE_NOT_HELD)
    {
        siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
        fSuccess = ::GetKernelObjectSecurity(
            hObject,
			siFlags,
			NULL,
			0,
			&dwLengthNeeded);
		
        dwError = ::GetLastError();
    }

	// The only expected error at this point is insuficient buffer
	if(!fSuccess && ERROR_INSUFFICIENT_BUFFER == dwError)
	{
        PSECURITY_DESCRIPTOR pSD = NULL;
        try
        {
		    pSD = new BYTE[dwLengthNeeded];
		    if(pSD)
		    {
			    // Now obtain security descriptor
			    if(::GetKernelObjectSecurity(
                        hObject,
						siFlags,
						pSD,
						dwLengthNeeded,
						&dwLengthNeeded))
			    {

				    dwError = ERROR_SUCCESS;

				    if(InitSecurity(pSD))
				    {
					    m_hObject = hObject;
				    }
				    else
				    {
					    dwError = ERROR_INVALID_PARAMETER;
				    }
			    }
			    else
			    {
				    dwError = ::GetLastError();
			    }

			    // free up the security descriptor
			    delete pSD;
		    }	
        }
        catch(...)
        {
            delete pSD;
            throw;
        }

	}	

	// Cleanup the Name Privilege as necessary.
	if(fDisablePrivilege)
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwError;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::WriteAcls
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the DACL and/or SACL.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the object.
//				SECURITY_INFORMATION	securityinfo - Flags
//										indicating which ACL(s)
//										to set.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureKernelObj::WriteAcls( 
    PSECURITY_DESCRIPTOR pAbsoluteSD, 
    SECURITY_INFORMATION securityinfo)
{
	DWORD dwError = ERROR_SUCCESS;

	// We must have the security privilege enabled in order to access the object's SACL
	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL fDisablePrivilege = FALSE;

	if(securityinfo & SACL_SECURITY_INFORMATION || 
        securityinfo & PROTECTED_SACL_SECURITY_INFORMATION || 
        securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
	{
		fDisablePrivilege = (securityPrivilege.Enable() == ERROR_SUCCESS);
	}
    
    if(!::SetKernelObjectSecurity(
        m_hObject,
        securityinfo,
        pAbsoluteSD))
    {
        dwError = ::GetLastError();
    }


	// Cleanup the Name Privilege as necessary.
	if(fDisablePrivilege)
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwError;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureKernelObj::WriteOwner
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the owner.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the object.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureKernelObj::WriteOwner(PSECURITY_DESCRIPTOR pAbsoluteSD)
{
	DWORD		dwError = ERROR_SUCCESS;

	// Open with the appropriate access, set the security and leave
	if(!::SetKernelObjectSecurity(
        m_hObject,
		OWNER_SECURITY_INFORMATION,
		pAbsoluteSD))
	{
		dwError = ::GetLastError();
	}

	return dwError;
}



DWORD CSecureKernelObj::AllAccessMask(void)
{
	// File specific All Access Mask
	return TOKEN_ALL_ACCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\securefile.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/


/*
 *	SecurityDescriptor.cpp - implementation file for CSecureFile class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class


#include "SecurityDescriptor.h"
#include "securefile.h"
#include "tokenprivilege.h"
#include "ImpersonateConnectedUser.h"
#include "ImpLogonUser.h"
#include "AdvApi32Api.h"


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::CSecureFile
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureFile::CSecureFile()
:	CSecurityDescriptor(),
	m_strFileName()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::CSecureFile
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCTSTR		pszFileName - The FileName to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureFile::CSecureFile( LPCTSTR pszFileName, BOOL fGetSACL /*= TRUE*/ )
:	CSecurityDescriptor(),
	m_strFileName()
{
	SetFileName( pszFileName );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::CSecureFile
//
//	Alternate Class CTOR
//
//	Inputs:
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
CSecureFile::CSecureFile
(
    LPCTSTR a_pszFileName,
    CSid* a_psidOwner,
    bool a_fOwnerDefaulted,
    CSid* a_psidGroup,
    bool a_fGroupDefaulted,
    CDACL* a_pDacl,
    bool a_fDaclDefaulted,
    bool a_fDaclAutoInherited,
    CSACL* a_pSacl,
    bool a_fSaclDefaulted,
    bool a_fSaclAutoInherited
)
:  CSecurityDescriptor(a_psidOwner,
                       a_fOwnerDefaulted,
                       a_psidGroup,
                       a_fGroupDefaulted,
                       a_pDacl,
                       a_fDaclDefaulted,
                       a_fDaclAutoInherited,
                       a_pSacl,
                       a_fSaclDefaulted,
                       a_fSaclAutoInherited)
{
    m_strFileName = a_pszFileName;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::CSecureFile
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCTSTR					pszFileName	-	The FileName to handle
//														security for.
//
//				PSECURITY_DESCRIPTOR	pSD			-	The Security Descriptor to associate with this file
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureFile::CSecureFile( LPCTSTR pszFileName, PSECURITY_DESCRIPTOR pSD )
:	CSecurityDescriptor(),
	m_strFileName()
{
	if ( InitSecurity( pSD ) )
	{
		m_strFileName = pszFileName;
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::~CSecureFile
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureFile::~CSecureFile( void )
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::SetFileName
//
//	Public Entry point to set which file/directory this instance
//	of the class is to supply security for.
//
//	Inputs:
//				LPCTSTR		pszFileName - The FileName to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
//	This will clear any previously set filenames and/or security
//	information.
//
///////////////////////////////////////////////////////////////////

DWORD CSecureFile::SetFileName( LPCTSTR pszFileName, BOOL fGetSACL /*= TRUE*/ )
{
	DWORD					dwError = ERROR_SUCCESS;
	SECURITY_INFORMATION	siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;

    // GetFileSecurity uses DCOM long logon ids.  If we are connected from a remote machine,
    // even though we might be the same user as the local logged on user, the long id will be
    // different, and GetFileSecurity will give an access denied.  Hence the following
    // impersonation of the connected user.  Note also that this impersonation must be
    // done prior to setting the SE_SECURITY_NAME privilage, otherwise we would set that
    // privilage for one person, then impersonate another, who probably wouldn't have it!
	// This phenomenon can be observed most easily when asking to see an instance of
	// win32_logicalfilesecuritysetting of a root directory of a mapped drive, on a machine
	// that we have remoted into via wbem.

#ifdef NTONLY
    // NOTE: THE FOLLOWING PRESENTS A SECURITY BREACH, AND SHOULD BE REMOVED.
    bool fImp = false;
    //CImpersonateConnectedUser icu;
    CImpersonateLoggedOnUser icu;
    if(icu.Begin())
    {
        fImp = true;
    }
#endif

    // We must have the security privilege enabled in order to access the object's SACL
    CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( fGetSACL )
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
		siFlags |= SACL_SECURITY_INFORMATION;
	}


	// Determine the length needed for self-relative SD
	DWORD dwLengthNeeded = 0;

	BOOL	fSuccess = ::GetFileSecurity( pszFileName,
										siFlags,
										NULL,
										0,
										&dwLengthNeeded );

	dwError = ::GetLastError();

    // It is possible that the user lacked the permissions required to obtain the SACL,
    // even though we set the token's SE_SECURITY_NAME privilege.  So if we obtained an
    // access denied error, try it again, this time without requesting the SACL.
    if(dwError == ERROR_ACCESS_DENIED  || dwError == ERROR_PRIVILEGE_NOT_HELD)
    {
        siFlags = OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
        fSuccess = ::GetFileSecurity(pszFileName,
									 siFlags,
									 NULL,
									 0,
									 &dwLengthNeeded);
		dwError = ::GetLastError();
    }

	// The only expected error at this point is insuficient buffer
	if ( !fSuccess && ERROR_INSUFFICIENT_BUFFER == dwError )
	{
        PSECURITY_DESCRIPTOR	pSD = NULL;
        try
        {
		    pSD = malloc( dwLengthNeeded );

		    if ( NULL != pSD )
		    {

			    // Now obtain security descriptor
			    if ( ::GetFileSecurity( pszFileName,
							    siFlags,
							    pSD,
							    dwLengthNeeded,
							    &dwLengthNeeded ) )
			    {

				    dwError = ERROR_SUCCESS;

				    if ( InitSecurity( pSD ) )
				    {
					    m_strFileName = pszFileName;
				    }
				    else
				    {
					    dwError = ERROR_INVALID_PARAMETER;
				    }

			    }
			    else
			    {
				    dwError = ::GetLastError();
			    }

			    // free up the security descriptor
			    free( pSD );

		    }	// IF NULL != pSD
        }
        catch(...)
        {
            if(pSD != NULL)
            {
                free(pSD);
                pSD = NULL;
            }
            throw;
        }

	}	// IF INSUFFICIENTBUFFER

	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

#ifdef NTONLY
    if(fImp)
    {
        icu.End();
    }
#endif

	return dwError;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::WriteAcls
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the DACL and/or SACL.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//				SECURITY_INFORMATION	securityinfo - Flags
//										indicating which ACL(s)
//										to set.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureFile::WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo )
{
	DWORD		dwError = ERROR_SUCCESS;

	// We must have the security privilege enabled in order to access the object's SACL

	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( securityinfo & SACL_SECURITY_INFORMATION || securityinfo & PROTECTED_SACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
	}

#if NTONLY >= 5
//    CAdvApi32Api *t_pAdvApi32 = NULL;
//    CActrl t_actrlAccess;
//    CActrl t_actrlAudit;
//
//
//    if((dwError = ConfigureActrlAudit(t_actrlAudit, pAbsoluteSD)) == ERROR_SUCCESS && (dwError = ConfigureActrlAccess(t_actrlAccess, pAbsoluteSD)) == ERROR_SUCCESS)
//    {
//        t_pAdvApi32 = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL);
//        if(t_pAdvApi32 != NULL)
//        {
//            t_pAdvApi32->SetNamedSecurityInfoEx(m_strFileName,
//                                                SE_FILE_OBJECT,
//                                                securityinfo,
//                                                NULL,
//                                                t_actrlAccess,
//                                                t_actrlAudit,
//                                                NULL,           //owner (not specified in securityinfo)
//                                                NULL,           //group (not specified in securityinfo)
//                                                NULL,           //callback function
//                                                &dwError);
//            CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_pAdvApi32);
//            t_pAdvApi32 = NULL;
//        }
//    }

    // This is new new and improved (hah!) NT5 way.  The following is more efficient (although more lines of
    // code in *this* module) than making use of our CSecurityDescriptor class to extract all this stuff.

    // Need to see if the control flags specify dacl/sacl protection.  If so, impacts what we set in the securityinfo structure.


// NEXT FEW LINES AND RELATED LINES NOT REQUIRED AS THE NEW APPROACH, WITH THE NEW PROTECTED_DACL_SECURITY_INFORMATION flag in the SECURITY_INFORMATION
// structure is to not have to, ever, touch or get the control flags (hence, for instance, the call to SetSecurityDescriptorControl in SecurityDescriptor.cpp
// is now superfluous.
//
//    SECURITY_DESCRIPTOR_CONTROL Control;
//    DWORD dwRevision = 0;
//
//    if(GetSecurityDescriptorControl(pAbsoluteSD, &Control, &dwRevision))
//    {
//        // We got the control structure; now see about dacl/sacl protection, and alter securityinfo accordingly...
//        if(Control & SE_DACL_PROTECTED)
//        {
//            securityinfo |= PROTECTED_DACL_SECURITY_INFORMATION;
//        }
//        if(Control & SE_SACL_PROTECTED)
//        {
//            securityinfo |= PROTECTED_SACL_SECURITY_INFORMATION;
//        }

        PACL pDACL = NULL;
        BOOL fDACLPresent = FALSE;
		BOOL fDACLDefaulted = FALSE;
        // Need to get the PDACL and PSACL if they exist...
        if(::GetSecurityDescriptorDacl(pAbsoluteSD, &fDACLPresent, &pDACL, &fDACLDefaulted))
        {
            PACL pSACL = NULL;
            BOOL fSACLPresent = FALSE;
		    BOOL fSACLDefaulted = FALSE;
            if(::GetSecurityDescriptorSacl(pAbsoluteSD, &fSACLPresent, &pSACL, &fSACLDefaulted))
            {
                // Now need the owner...
                PSID psidOwner = NULL;
                BOOL bTemp;
                if(::GetSecurityDescriptorOwner(pAbsoluteSD, &psidOwner, &bTemp))
                {
                    PSID psidGroup = NULL;
                    // Now need the group...
                    if(::GetSecurityDescriptorGroup(pAbsoluteSD, &psidGroup, &bTemp))
                    {
                        dwError = ::SetNamedSecurityInfo((LPWSTR)(LPCWSTR)m_strFileName,
                                                         SE_FILE_OBJECT,
                                                         securityinfo,
                                                         psidOwner,
                                                         psidGroup,
                                                         pDACL,
                                                         pSACL);
                    }
                    else // couldn't get group
                    {
                        dwError = ::GetLastError();
                    }
                }
                else // couldn't get owner
                {
                    dwError = ::GetLastError();
                }
            } // couldn't get sacl
            else
            {
                dwError = ::GetLastError();
            }
        } // couldn't get dacl
        else
        {
            dwError = ::GetLastError();
        }
//    } // couldn't get control
//    else
//    {
//        dwError = ::GetLastError();
//    }


#else

	if(!::SetFileSecurity(TOBSTRT(m_strFileName),
						  securityinfo,
						  pAbsoluteSD))
	{
		dwError = ::GetLastError();
	}

#endif


	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

	return dwError;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureFile::WriteOwner
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the owner.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureFile::WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD )
{
	DWORD		dwError = ERROR_SUCCESS;

#if NTONLY >= 5
    SECURITY_INFORMATION securityinfo = OWNER_SECURITY_INFORMATION;
    PSID psidOwner = NULL;
    BOOL bTemp;
    if(::GetSecurityDescriptorOwner(pAbsoluteSD, &psidOwner, &bTemp))
    {
        dwError = ::SetNamedSecurityInfo((LPWSTR)(LPCWSTR)m_strFileName,
                                                         SE_FILE_OBJECT,
                                                         securityinfo,
                                                         psidOwner,
                                                         NULL,
                                                         NULL,
                                                         NULL);
    }
    else
    {
        dwError = ::GetLastError();
    }
#else
	// Open with the appropriate access, set the security and leave
	if ( !::SetFileSecurity(TOBSTRT(m_strFileName),
							OWNER_SECURITY_INFORMATION,
							pAbsoluteSD))
	{
		dwError = ::GetLastError();
	}
#endif
	return dwError;
}

DWORD CSecureFile::AllAccessMask( void )
{
	// File specific All Access Mask
	return FILE_ALL_ACCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\secureshare.h ===
/*

 *	CSecureShare.h - header file for CSecureShare class.

 *

*  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
 *
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSECURESHARE_H__
#define __CSECURESHARE_H__

#include "SecurityDescriptor.h"			// CSid class


////////////////////////////////////////////////////////////////
//
//	Class:	CSecureShare
//
//	This class is intended to encapsulate the security of an
//	NT File or Directory.  It inherits off of CSecurityDescriptor
//	and it is that class to which it passes Security Descriptors
//	it obtains, and from which it receives previously built
//	security descriptors to apply.  It supplies implementations
//	for AllAccessMask(), WriteOwner() and WriteAcls().
//
////////////////////////////////////////////////////////////////

#ifdef NTONLY
class CSecureShare : public CSecurityDescriptor
{
	// Constructors and destructor
	public:
		CSecureShare();
		CSecureShare(PSECURITY_DESCRIPTOR pSD);
		~CSecureShare();

		CSecureShare( CHString& chsShareName);
		DWORD	SetShareName( const CHString& chsShareName);

		virtual DWORD AllAccessMask( void );

	protected:

		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD  );
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD , SECURITY_INFORMATION securityinfo  );

	private:
		CHString	m_strFileName;

};
#endif

#endif // __CSecureShare_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\secureshare.cpp ===
/*

 *	SecurityDescriptor.cpp - implementation file for CSecureShare class.

 *

*  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
 *
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "securitydescriptor.h"
#include "secureshare.h"
#include "tokenprivilege.h"
#include <windef.h>
#include <lmcons.h>
#include <lmshare.h>
#include "wbemnetapi32.h"


#ifdef NTONLY
///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::CSecureShare
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureShare::CSecureShare()
:	CSecurityDescriptor(),
	m_strFileName()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::CSecureShare
//
//	Alternate Class CTOR
//
//	Inputs:
//				LPCTSTR		pszFileName - The FileName to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureShare::CSecureShare( PSECURITY_DESCRIPTOR pSD)
:	CSecurityDescriptor(pSD)
{
//	SetFileName( pszFileName );
}


CSecureShare::CSecureShare( CHString& chsShareName)
:	CSecurityDescriptor()
{
	SetShareName( chsShareName);
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::~CSecureShare
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecureShare::~CSecureShare( void )
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::SetFileName
//
//	Public Entry point to set which file/directory this instance
//	of the class is to supply security for.
//
//	Inputs:
//				LPCTSTR		pszFileName - The FileName to handle
//							security for.
//				BOOL		fGetSACL - Should we get the SACL?
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
//	This will clear any previously set filenames and/or security
//	information.
//
///////////////////////////////////////////////////////////////////

DWORD CSecureShare::SetShareName( const CHString& chsShareName)
{
#ifdef WIN9XONLY
    return WBEM_E_FAILED;
#endif

#ifdef NTONLY

	_bstr_t bstrName ( chsShareName.AllocSysString(), false ) ;
	SHARE_INFO_502 *pShareInfo502 = NULL ;
	DWORD dwError = ERROR_INVALID_PARAMETER ;

	CNetAPI32 NetAPI;
	try
	{
	if(	NetAPI.Init() == ERROR_SUCCESS			&&
		NetAPI.NetShareGetInfo(	NULL,
								(LPTSTR) bstrName,
								502,
								(LPBYTE *) &pShareInfo502) == NERR_Success )
	{

		//Sec. Desc. is not returned for IPC$ ,C$ ...shares for Admin purposes
		if(pShareInfo502->shi502_security_descriptor)
		{
			if(InitSecurity(pShareInfo502->shi502_security_descriptor) )
			{
				dwError = ERROR_SUCCESS ;
			}
		}

		NetAPI.NetApiBufferFree(pShareInfo502) ;
		pShareInfo502 = NULL ;
	}

	return dwError ;
	}
	catch ( ... )
	{
		if ( pShareInfo502 )
		{
			NetAPI.NetApiBufferFree(pShareInfo502) ;
			pShareInfo502 = NULL ;
		}

		throw ;
	}
#endif
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::WriteAcls
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the DACL and/or SACL.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//				SECURITY_INFORMATION	securityinfo - Flags
//										indicating which ACL(s)
//										to set.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

#ifdef NTONLY
DWORD CSecureShare::WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo )
{
	DWORD		dwError = ERROR_SUCCESS;

	// We must have the security privilege enabled in order to access the object's SACL
/*	CTokenPrivilege	securityPrivilege( SE_SECURITY_NAME );
	BOOL			fDisablePrivilege = FALSE;

	if ( securityinfo & SACL_SECURITY_INFORMATION )
	{
		fDisablePrivilege = ( securityPrivilege.Enable() == ERROR_SUCCESS );
	}

	if  ( !::SetFileSecurity( m_strFileName,
							securityinfo,
							pAbsoluteSD ) )
	{
		dwError = ::GetLastError();
	}

	// Cleanup the Name Privilege as necessary.
	if ( fDisablePrivilege )
	{
		securityPrivilege.Enable(FALSE);
	}

*/	return dwError;
}
#endif

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecureShare::WriteOwner
//
//	Protected entry point called by CSecurityDescriptor when
//	a user Applies Security and wants to apply security for
//	the owner.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security
//										descriptor to apply to
//										the file.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if successful
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecureShare::WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD )
{
	DWORD		dwError = ERROR_SUCCESS;

	// Open with the appropriate access, set the security and leave

/*	if ( !::SetFileSecurity( m_strFileName,
								OWNER_SECURITY_INFORMATION,
								pAbsoluteSD ) )
	{
		dwError = ::GetLastError();
	}

*/	return dwError;
}

DWORD CSecureShare::AllAccessMask( void )
{
	// File specific All Access Mask
	return FILE_ALL_ACCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\securityapi.h ===
//=================================================================

//

// SecurityApi.h

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_SECUR_H_
#define	_SECUR_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
extern const GUID g_guidSecurApi;
extern const TCHAR g_tstrSecur[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

#define SECURITY_WIN32
#include <sspi.h>
#include <schnlsp.h> //for UNISP_NAME_A

/******************************************************************************
 * Wrapper class for Ws2_32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CSecurityApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to CSecur functions.
    // Add new functions here as required.
    PSecurityFunctionTableW (WINAPI *m_pfnInitSecurityInterface)();
	PSecurityFunctionTableW m_pSecFuncTable;


public:

    // Constructor and destructor:
    CSecurityApi( LPCTSTR a_tstrWrappedDllName ) ;
    ~CSecurityApi();

    // Inherrited initialization function.
    virtual bool Init();

    // suppoorted APIs
    SECURITY_STATUS AcquireCredentialsHandleW 
    (
		SEC_WCHAR SEC_FAR * pszPrincipal,    // Name of principal
		SEC_WCHAR SEC_FAR * pszPackage,      // Name of package
		unsigned long fCredentialUse,       // Flags indicating use
		void SEC_FAR * pvLogonId,           // Pointer to logon ID
		void SEC_FAR * pAuthData,           // Package specific data
		SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
		void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
		PCredHandle phCredential,           // (out) Cred Handle
		PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

	SECURITY_STATUS QueryCredentialsAttributesW(
		PCredHandle phCredential,             // Credential to query
		unsigned long ulAttribute,          // Attribute to query
		void SEC_FAR * pBuffer              // Buffer for attributes
		);

	SECURITY_STATUS FreeCredentialsHandle(
		PCredHandle phCredential            // Handle to free
		);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\securityapi.cpp ===
//=================================================================

//

// Ws2_32Api.cpp

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>


#include "DllWrapperBase.h"

#include "SecurityApi.h"
#include "DllWrapperCreatorReg.h"


// {C9369990-F3A8-4bac-A360-47BAA0EC47A0}
static const GUID g_guidSecurApi =
{ 0xc9369990, 0xf3a8, 0x4bac, { 0xa3, 0x60, 0x47, 0xba, 0xa0, 0xec, 0x47, 0xa0 } };

#if NTONLY >= 5
		static const TCHAR g_tstrSecur[] = _T("SECURITY.DLL");
#else
		static const TCHAR g_tstrSecur[] = _T("SECUR32.DLL");
#endif


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CSecurityApi, &g_guidSecurApi, g_tstrSecur> g_RegisteredCSecurityWrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CSecurityApi::CSecurityApi( LPCTSTR a_tstrWrappedDllName )
 : CDllWrapperBase( a_tstrWrappedDllName ),
   m_pfnInitSecurityInterface(NULL),
   m_pSecFuncTable(NULL)
{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CSecurityApi::~CSecurityApi()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CSecurityApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnInitSecurityInterface =
			(PSecurityFunctionTableW(WINAPI *)())GetProcAddress( "InitSecurityInterfaceW" );

		m_pSecFuncTable = (PSecurityFunctionTableW)((*m_pfnInitSecurityInterface)());


        // Check that we have function pointers to functions that should be
        // present in all versions of this dll...
        if(m_pfnInitSecurityInterface == NULL ||
           m_pSecFuncTable == NULL )
        {
            fRet = false;
            LogErrorMessage(L"Failed find entrypoint in securityapi");
        }
		else
		{
			fRet = true;
		}
    }
    return fRet;
}


/******************************************************************************
 * Member functions wrapping Ws2_32 api functions. Add new functions here
 * as required.
 ******************************************************************************/

//
SECURITY_STATUS CSecurityApi::AcquireCredentialsHandleW
(
SEC_WCHAR SEC_FAR	*a_pszPrincipal,    // Name of principal
SEC_WCHAR SEC_FAR	*a_pszPackage,      // Name of package
unsigned long		a_fCredentialUse,       // Flags indicating use
void SEC_FAR		*a_pvLogonId,           // Pointer to logon ID
void SEC_FAR		*a_pAuthData,           // Package specific data
SEC_GET_KEY_FN		a_pGetKeyFn,           // Pointer to GetKey() func
void SEC_FAR		*a_pvGetKeyArgument,    // Value to pass to GetKey()
PCredHandle			a_phCredential,           // (out) Cred Handle
PTimeStamp			a_ptsExpiry                // (out) Lifetime (optional)
)
{
	if( m_pSecFuncTable && m_pSecFuncTable->AcquireCredentialsHandleW )
	{
		return (*m_pSecFuncTable->AcquireCredentialsHandleW)(
								a_pszPrincipal,
								a_pszPackage,
								a_fCredentialUse,
								a_pvLogonId,
								a_pAuthData,
								a_pGetKeyFn,
								a_pvGetKeyArgument,
								a_phCredential,
								a_ptsExpiry ) ;
	}
	else
	{
		return E_POINTER ;
	}
}

//
SECURITY_STATUS CSecurityApi::QueryCredentialsAttributesW(
PCredHandle		a_phCredential,             // Credential to query
unsigned long	a_ulAttribute,          // Attribute to query
void SEC_FAR	*a_pBuffer              // Buffer for attributes
)
{
	if( m_pSecFuncTable && m_pSecFuncTable->QueryCredentialsAttributesW )
	{
		return (*m_pSecFuncTable->QueryCredentialsAttributesW)(
									a_phCredential,
									a_ulAttribute,
									a_pBuffer ) ;
	}
	else
	{
		return E_POINTER ;
	}
}

//
SECURITY_STATUS CSecurityApi::FreeCredentialsHandle(
PCredHandle a_phCredential            // Handle to free
)
{
	if( m_pSecFuncTable && m_pSecFuncTable->FreeCredentialsHandle )
	{
		return (*m_pSecFuncTable->FreeCredentialsHandle)(
									a_phCredential ) ;
	}
	else
	{
		return E_POINTER ;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\securitydescriptor.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	SecurityDescriptor.cpp - implementation file for CSecurityDescriptor class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include <assertbreak.h>

#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "aclapi.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"					// CSACL class


#include "SecurityDescriptor.h"
#include "TokenPrivilege.h"
#include "AdvApi32Api.h"
#include "accctrl.h"
#include "wbemnetapi32.h"
#include "SecUtils.h"


/*
 *	This constructor is the default
 */

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::CSecurityDescriptor
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecurityDescriptor::CSecurityDescriptor()
:	m_pOwnerSid( NULL ),
	m_pGroupSid( NULL ),
	m_pSACL( NULL ),
    m_pDACL(NULL),
    m_fOwnerDefaulted( false ),
    m_fGroupDefaulted( false ),
    m_fDACLDefaulted( false ),
    m_fSACLDefaulted( false ),
    m_fDaclAutoInherited( false ),
    m_fSaclAutoInherited( false ),
    m_SecurityDescriptorControl(0)
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::CSecurityDescriptor
//
//	Alternate class constructor.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	psd - descriptor to initialize
//										from.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecurityDescriptor::CSecurityDescriptor( PSECURITY_DESCRIPTOR psd )
:	m_pOwnerSid( NULL ),
	m_pGroupSid( NULL ),
	m_pSACL( NULL ),
    m_pDACL(NULL),
    m_fOwnerDefaulted( false ),
    m_fGroupDefaulted( false ),
    m_fDACLDefaulted( false ),
    m_fSACLDefaulted( false ),
    m_fDaclAutoInherited( false ),
    m_fSaclAutoInherited( false ),
    m_SecurityDescriptorControl(0)
{
	InitSecurity( psd );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::CSecurityDescriptor
//
//	Alternate class constructor.
//
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
CSecurityDescriptor::CSecurityDescriptor
(
    CSid* a_psidOwner,
    bool a_fOwnerDefaulted,
    CSid* a_psidGroup,
    bool a_fGroupDefaulted,
    CDACL* a_pDacl,
    bool a_fDaclDefaulted,
    bool a_fDaclAutoInherited,
    CSACL* a_pSacl,
    bool a_fSaclDefaulted,
    bool a_fSaclAutoInherited
)
:   m_pOwnerSid( NULL ),
	m_pGroupSid( NULL ),
	m_pSACL( NULL ),
    m_pDACL(NULL),
    m_fOwnerDefaulted( false ),
    m_fGroupDefaulted( false ),
    m_fDACLDefaulted( false ),
    m_fSACLDefaulted( false ),
    m_fDaclAutoInherited( false ),
    m_fSaclAutoInherited( false ),
    m_SecurityDescriptorControl(0)
{
	try
	{
		bool fRet = true;
		if(a_psidOwner != NULL )
		{
			fRet = (SetOwner(*a_psidOwner) == ERROR_SUCCESS);
			if(fRet)
			{
				m_fOwnerDefaulted = a_fOwnerDefaulted;
			}
		}

		if(fRet)
		{
			if(a_psidGroup != NULL )
			{
				fRet = (SetGroup(*a_psidGroup) == ERROR_SUCCESS);
				if(fRet)
				{
					m_fGroupDefaulted = a_fGroupDefaulted;
				}
			}
		}

		if(fRet)
		{
			// Handle the DACL
			if(a_pDacl != NULL)
			{
				fRet = InitDACL(a_pDacl);
				if(fRet)
				{
					m_fDACLDefaulted = a_fDaclDefaulted;
					m_fDaclAutoInherited = a_fDaclAutoInherited;
				}
			}
		}

		// Handle the SACL
		if(fRet)
		{
			if(a_pSacl != NULL)
			{
				fRet = InitSACL(a_pSacl);
				if(fRet)
				{
					m_fSACLDefaulted = a_fSaclDefaulted;
					m_fSaclAutoInherited = a_fSaclAutoInherited;
				}
			}
		}

		// Clean us up if something beefed
		if(!fRet)
		{
			Clear();
		}
	}
	catch(...)
	{
		Clear();
		throw;
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::~CSecurityDescriptor
//
//	Class Destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSecurityDescriptor::~CSecurityDescriptor( void )
{
	Clear();
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::IsNT5
//
//	Tells us if we're running on NT 5 or not, in which case
//	we need to do some special handling.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL			TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::InitSecurity
//
//	Initializes the class with data from the supplied security
//	descriptor.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	psd - Security Descriptor
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE				Success/Failure.
//
//	Comments:
//
//	Keep this function protected so only derived classes have
//	access to laying waste to our internals.
//
///////////////////////////////////////////////////////////////////

BOOL CSecurityDescriptor::InitSecurity( PSECURITY_DESCRIPTOR psd )
{
	BOOL	fReturn = FALSE;
	PSID	psid = NULL;
	DWORD 	dwRevision = 0;
	SECURITY_DESCRIPTOR_CONTROL Control;
    BOOL bTemp;

	// Clean up existing values.
	Clear();

	// Get the security descriptor Owner Sid.
	fReturn = GetSecurityDescriptorOwner( psd, &psid, &bTemp );
	if ( fReturn )
	{
		// As long as we have a psid, intialize the owner member
		if ( NULL != psid )
		{
			if(SetOwner(CSid(psid)) != ERROR_SUCCESS)
            {
                fReturn = FALSE;
            }
		}
	}
	else
	{
		bTemp = FALSE;
	}

    bTemp ? m_fOwnerDefaulted = true : m_fOwnerDefaulted = false;

	fReturn = GetSecurityDescriptorGroup (psd, &psid, &bTemp );
	if ( fReturn )
	{
		// as long as we have a psid, initialize the group member
		if ( NULL != psid )
		{
            if(SetGroup(CSid(psid)) != ERROR_SUCCESS)
            {
                fReturn = FALSE;
            }
		}
	}
	else
	{
		bTemp = FALSE;
	}

    bTemp ? m_fGroupDefaulted = true : m_fGroupDefaulted = false;

	fReturn = GetSecurityDescriptorControl( psd, &Control, &dwRevision);
	if (fReturn)
	{
		SetControl( &Control );
		// BAD, BAD, BAD, BAD
	}

	// Handle the DACL and then the SACL
	if ( fReturn )
	{
		fReturn = InitDACL( psd );
	}

	if ( fReturn )
	{
		fReturn = InitSACL( psd );
	}

	// Clean us up if something beefed
	if ( !fReturn )
	{
		Clear();
	}

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::InitDACL
//
//	Initializes the DACL data member.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	psd - Security Descriptor
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE				Success/Failure.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CSecurityDescriptor::InitDACL ( PSECURITY_DESCRIPTOR psd )
{
	BOOL	fReturn			=	FALSE,
			fDACLPresent	=	FALSE,
			fDACLDefaulted	=	FALSE;

	PACL	pDACL = NULL;

	if ( GetSecurityDescriptorDacl( psd, &fDACLPresent, &pDACL,	&fDACLDefaulted ) )
	{
		ACE_HEADER*	pACEHeader	=	NULL;
		DWORD		dwAceIndex	=	0;
		BOOL		fGotACE		=	FALSE;

		// Be optimistic.  Shut up, be happy, etc.
		fReturn = TRUE;

		// Note that although fDACLPresent is SUPPOSED to tell us whether or not the
		// DACL is there, I'm seeing cases when this is returning TRUE, but the pDACL
		// value is NULL.  Not what the documenetation sez, but I'll take reality.

		if (fDACLPresent && (pDACL != NULL))
		{
			// Create a working dacl and initialize it with all ace entries...
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }

            try
            {
                m_pDACL = new CDACL;
            }
            catch(...)
            {
                if(m_pDACL != NULL)
                {
                    delete m_pDACL;
                    m_pDACL = NULL;
                }
                throw;
            }

            if(m_pDACL != NULL)
            {
                if(m_pDACL->Init(pDACL) == ERROR_SUCCESS)
                {
                    fReturn = TRUE;
                    // Allocated a dacl for that type only if an entry of that type was present.

                    // If we had an empty dacl (dacl present, yet empty), we won't have allocated
                    // any dacls in the array m_rgDACLPtrArray.  This won't be confused with a NULL
                    // DACL, as this module knows that it always represents a NULL DACL as all of
                    // the elements of m_rgDACLPtrArray as null except for ACCESS_ALLOWED_OBJECT,
                    // which will have one entry - namely, the Everyone ace.
                }
            }
		}	// IF fDACL Present
		else
		{
			if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }

            try
            {
                m_pDACL = new CDACL;
            }
            catch(...)
            {
                if(m_pDACL != NULL)
                {
                    delete m_pDACL;
                    m_pDACL = NULL;
                }
                throw;
            }

            if(m_pDACL != NULL)
            {
                fReturn = m_pDACL->CreateNullDACL();	// No DACL, so gin up an Empty Dacl
            }
		}

	}	// IF Got DACL

	return fReturn;
}

// Another version
bool CSecurityDescriptor::InitDACL( CDACL* a_pDACL )
{
    bool fRet = false;
    if (a_pDACL != NULL)
	{
		// Create a working dacl and initialize it with all ace entries...
        if(m_pDACL != NULL)
        {
            delete m_pDACL;
            m_pDACL = NULL;
        }

        try
        {
            m_pDACL = new CDACL;
        }
        catch(...)
        {
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }
            throw;
        }

        if(m_pDACL != NULL)
        {
            if(m_pDACL->CopyDACL(*a_pDACL))
            {
                fRet = true;
                // Allocated a dacl for that type only if an entry of that type was present.

                // If we had an empty dacl (dacl present, yet empty), we won't have allocated
                // any dacls in the array m_rgDACLPtrArray.  This won't be confused with a NULL
                // DACL, as this module knows that it always represents a NULL DACL as all of
                // the elements of m_rgDACLPtrArray as null except for ACCESS_ALLOWED_OBJECT,
                // which will have one entry - namely, the Everyone ace.
            }
        }
	}	// IF fDACL Present
	else
	{
		if(m_pDACL != NULL)
        {
            delete m_pDACL;
            m_pDACL = NULL;
        }

        try
        {
            m_pDACL = new CDACL;
        }
        catch(...)
        {
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }
            throw;
        }

        if(m_pDACL != NULL)
        {
            fRet = m_pDACL->CreateNullDACL();	// No DACL, so gin up an Empty Dacl
        }
	}
    return fRet;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::InitSACL
//
//	Initializes the SACL data member.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	psd - Security Descriptor
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE				Success/Failure.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CSecurityDescriptor::InitSACL ( PSECURITY_DESCRIPTOR psd )
{
	BOOL	fReturn			=	FALSE,
			fSACLPresent	=	FALSE,
			fSACLDefaulted	=	FALSE;

	PACL	pSACL = NULL;

	if ( GetSecurityDescriptorSacl( psd, &fSACLPresent, &pSACL,	&fSACLDefaulted ) )
	{

		// Be optimistic.  Shut up, be happy, etc.
		fReturn = TRUE;

		// Note that although fSACLPresent is SUPPOSED to tell us whether or not the
		// SACL is there, I'm seeing cases when this is returning TRUE, but the pSACL
		// value is NULL.  Not what the documenetation sez, but I'll take reality
		// for a thousand, Alex.

		if (	fSACLPresent
			&&	NULL != pSACL )
		{
			// Allocate SACL although it may stay empty
            if(m_pSACL != NULL)
            {
                delete m_pSACL;
                m_pSACL = NULL;
            }

            try
            {
                m_pSACL = new CSACL;
            }
            catch(...)
            {
                if(m_pSACL != NULL)
                {
                    delete m_pSACL;
                    m_pSACL = NULL;
                }
                throw;
            }

            if(m_pSACL != NULL)
            {
                if(m_pSACL->Init(pSACL) == ERROR_SUCCESS)
                {
                    fReturn = TRUE;
                }
            }

		}	// IF fSACL Present
		else
		{
			fReturn = TRUE;	// No SACL, so no worries
		}

	}	// IF Got SACL

	return fReturn;
}

// Another version...
bool CSecurityDescriptor::InitSACL( CSACL* a_pSACL )
{
    bool fRet = false;

    if (a_pSACL != NULL)
	{
		// Allocate SACL although it may stay empty
        if(m_pSACL != NULL)
        {
            delete m_pSACL;
            m_pSACL = NULL;
        }

        try
        {
            m_pSACL = new CSACL;
        }
        catch(...)
        {
            if(m_pSACL != NULL)
            {
                delete m_pSACL;
                m_pSACL = NULL;
            }
            throw;
        }

        if(m_pSACL != NULL)
        {
            if(m_pSACL->CopySACL(*a_pSACL))
            {
                fRet = true;
            }
        }

	}	// IF fSACL Present
	else
	{
		fRet = true;	// No SACL, so no worries
	}

    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::SecureObject
//
//	Private entry point function which takes an Absolute Security
//	Descriptor, and depending on the user supplied security
//	information flags, divvies the actual object security handling
//	out to the appropriate WriteOwner() and WriteAcls() virtual
//	functions.
//
//	Inputs:
//				PSECURITY_DESCRIPTOR	pAbsoluteSD - Security Descriptor
//				SECURITY_INFORMATION	securityinfo - Security flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD					ERROR_SUCCESS if ok.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::SecureObject( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo )
{
	DWORD	dwReturn = ERROR_SUCCESS;

	// We might need this guy to handle some special access stuff
	CTokenPrivilege	restorePrivilege( SE_RESTORE_NAME );

    //try to set the owner first, since setting the dacl may preclude setting the owner, depending on what access we set
	if ( securityinfo & OWNER_SECURITY_INFORMATION )
	{
		dwReturn = WriteOwner( pAbsoluteSD ) ;

        if ( ERROR_INVALID_OWNER == dwReturn )
		{
			// If we enable the privilege, retry setting the owner info
			if ( ERROR_SUCCESS == restorePrivilege.Enable() )
			{
				dwReturn = WriteOwner( pAbsoluteSD );

				// Clear the privilege
				restorePrivilege.Enable( FALSE );
			}
		}
	}

	// If we need to write sacl/dacl information, try to write that piece now
	if ( dwReturn == ERROR_SUCCESS && ( securityinfo & DACL_SECURITY_INFORMATION ||
                                        securityinfo & SACL_SECURITY_INFORMATION ||
                                        securityinfo & PROTECTED_DACL_SECURITY_INFORMATION ||
                                        securityinfo & PROTECTED_SACL_SECURITY_INFORMATION ||
                                        securityinfo & UNPROTECTED_DACL_SECURITY_INFORMATION ||
                                        securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION) )
	{
	    SECURITY_INFORMATION	daclsecinfo = 0;

	    // Fill out security information with only the appropriate DACL/SACL values.
	    if ( securityinfo & DACL_SECURITY_INFORMATION )
	    {
		    daclsecinfo |= DACL_SECURITY_INFORMATION;
	    }

	    if ( securityinfo & SACL_SECURITY_INFORMATION )
	    {
		    daclsecinfo |= SACL_SECURITY_INFORMATION;
	    }

#if NTONLY >= 5
        if(securityinfo & PROTECTED_DACL_SECURITY_INFORMATION)
        {
            daclsecinfo |= PROTECTED_DACL_SECURITY_INFORMATION;
        }
        if(securityinfo & PROTECTED_SACL_SECURITY_INFORMATION)
        {
            daclsecinfo |= PROTECTED_SACL_SECURITY_INFORMATION;
        }
        if(securityinfo & UNPROTECTED_DACL_SECURITY_INFORMATION)
        {
            daclsecinfo |= UNPROTECTED_DACL_SECURITY_INFORMATION;
        }
        if(securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
        {
            daclsecinfo |= UNPROTECTED_SACL_SECURITY_INFORMATION;
        }
#endif


        dwReturn = WriteAcls( pAbsoluteSD, daclsecinfo );
	}
	return dwReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::SetOwner
//
//	Sets the owner data member to the supplied SID.
//
//	Inputs:
//				CSid&		sid - New Owner.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD					ERROR_SUCCESS if ok.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::SetOwner( CSid& sid )
{
	DWORD	dwError = ERROR_SUCCESS;

	// Make sure the new sid is valid
	if ( sid.IsValid() )
	{

		// We will write in the sid, if the Owner is NULL, or the
		// sids are not equal.

		if (	NULL == m_pOwnerSid
			||	!( *m_pOwnerSid == sid ) )
		{

			if ( NULL != m_pOwnerSid )
			{
				delete m_pOwnerSid;
			}

            m_pOwnerSid = NULL;
            try
            {
			    m_pOwnerSid = new CSid( sid );
            }
            catch(...)
            {
                if(m_pOwnerSid != NULL)
                {
                    delete m_pOwnerSid;
                    m_pOwnerSid = NULL;
                }
                throw;
            }

			if ( NULL == m_pOwnerSid )
			{
				dwError = ERROR_NOT_ENOUGH_MEMORY;
			}
			else
			{
				m_fOwnerDefaulted = FALSE;
			}

		}	// IF NULL == m_pOwnerSid || !SidsEqual

	}	// IF IsValidSid
	else
	{
		dwError = ::GetLastError();
	}

	return dwError;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::SetGroup
//
//	Sets the group data member to the supplied SID.
//
//	Inputs:
//				CSid&		sid - New Group.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD					ERROR_SUCCESS if ok.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::SetGroup( CSid& sid )
{
	DWORD	dwError = ERROR_SUCCESS;

	// Make sure the new sid is valid
	if ( sid.IsValid() )
	{

		// We will write in the sid, if the Owner is NULL, or the
		// sids are not equal.

		if (	NULL == m_pGroupSid
			||	!( *m_pGroupSid == sid ) )
		{

			if ( NULL != m_pGroupSid )
			{
				delete m_pGroupSid;
			}

            m_pGroupSid = NULL;
            try
            {
			    m_pGroupSid = new CSid( sid );
            }
            catch(...)
            {
                if(m_pGroupSid != NULL)
                {
                    delete m_pGroupSid;
                    m_pGroupSid = NULL;
                }
                throw;
            }


			if ( NULL == m_pGroupSid )
			{
				dwError = ERROR_NOT_ENOUGH_MEMORY;
			}
			else
			{
				m_fGroupDefaulted = FALSE;
			}

		}	// IF NULL == m_pOwnerSid || !SidsEqual

	}	// IF IsValidSid
	else
	{
		dwError = ::GetLastError();
	}

	return dwError;

}




///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::AddDACLEntry
//
//	Adds an entry to our DACL.  Replaces an
//	existing entry if it meets the matching criteria.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwAccessMask - The access mask
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::AddDACLEntry( CSid& sid, DACL_Types DaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool fReturn = false;

    if(m_pDACL == NULL)
    {
        try
        {
            m_pDACL = new CDACL;
        }
        catch(...)
        {
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }
            throw;
        }
        if(m_pDACL != NULL)
        {
            fReturn = m_pDACL->AddDACLEntry(sid.GetPSid(), DaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid);
        }
    }
    else
    {
        fReturn = m_pDACL->AddDACLEntry(sid.GetPSid(), DaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid);
    }

    return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::AddSACLEntry
//
//	Adds an entry to our SACL.  Replaces an
//	existing entry if it meets the matching criteria.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwAccessMask - The access mask
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::AddSACLEntry( CSid& sid, SACL_Types SaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool fReturn = false;

    if(m_pSACL == NULL)
    {
        try
        {
            m_pSACL = new CSACL;
        }
        catch(...)
        {
            if(m_pSACL != NULL)
            {
                delete m_pSACL;
                m_pSACL = NULL;
            }
            throw;
        }
        if(m_pSACL != NULL)
        {
            fReturn = m_pSACL->AddSACLEntry(sid.GetPSid(), SaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid);
        }
    }
    else
    {
        fReturn = m_pSACL->AddSACLEntry(sid.GetPSid(), SaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid);
    }

    return fReturn;
}




///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveDACLEntry
//
//	Removes a DACL entry from our DACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwAccessMask - The access mask
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	The entry that is removed must match all specified criteria.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveDACLEntry( CSid& sid, DACL_Types DaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool			fReturn = false;

	if ( NULL != m_pDACL )
	{
		fReturn = m_pDACL->RemoveDACLEntry( sid, DaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveDACLEntry
//
//	Removes a DACL entry from our DACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	The entry that is removed must match only the specified criteria.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveDACLEntry( CSid& sid, DACL_Types DaclType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool			fReturn = false;

	if ( NULL != m_pDACL )
	{
		fReturn = m_pDACL->RemoveDACLEntry( sid, DaclType, bACEFlags, pguidObjGuid, pguidInhObjGuid );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveDACLEntry
//
//	Removes a DACL entry from our DACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwIndex - Index of entry.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Removes the dwIndex instance of a SID in the SACL.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveDACLEntry( CSid& sid, DACL_Types DaclType, DWORD dwIndex   )
{
	bool			fReturn = false;

	if ( NULL != m_pDACL )
	{
		fReturn = m_pDACL->RemoveDACLEntry( sid, DaclType, dwIndex );
	}

	return fReturn;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveSACLEntry
//
//	Removes a SACL entry from our SACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwAccessMask - The access mask
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	The entry that is removed must match all specified criteria.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveSACLEntry( CSid& sid, SACL_Types SaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool			fReturn = false;

	if ( NULL != m_pSACL )
	{
		fReturn = m_pSACL->RemoveSACLEntry( sid, SaclType, dwAccessMask, bACEFlags, pguidObjGuid, pguidInhObjGuid );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveSACLEntry
//
//	Removes a SACL entry from our SACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				BOOL		bACEFlags - ACE Flags.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	The entry that is removed must match only the specified criteria.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveSACLEntry( CSid& sid, SACL_Types SaclType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid )
{
	bool			fReturn = false;

	if ( NULL != m_pSACL )
	{
		fReturn = m_pSACL->RemoveSACLEntry( sid, SaclType, bACEFlags, pguidObjGuid, pguidInhObjGuid );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::RemoveSACLEntry
//
//	Removes a SACL entry from our SACL.
//
//	Inputs:
//				CSid&		sid - Sid for the entry.
//				DWORD		dwIndex - Index of entry.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Removes the dwIndex instance of a SID in the SACL.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::RemoveSACLEntry( CSid& sid, SACL_Types SaclType, DWORD dwIndex   )
{
	bool			fReturn = false;

	if ( NULL != m_pSACL )
	{
		fReturn = m_pSACL->RemoveSACLEntry( sid, SaclType, dwIndex );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::FindACE
//
//	Locates an ACE in either the SACL or DACL based on the supplied
//	criteria.
//
//	Inputs:
//				const CSid&		sid - Sid for the entry.
//				BYTE			bACEType - ACE Type
//				DWORD			dwMask - Access Mask
//				BYTE			bACEFlags - Flags
//
//	Outputs:
//				CAccessEntry&	ace - Filled out with located values.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Locates an ACE that matches ALL supplied criteria
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::FindACE( const CSid& sid, BYTE bACEType, DWORD dwMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, CAccessEntry& ace  )
{
	bool fReturn = false;

	if ( SYSTEM_AUDIT_ACE_TYPE        == bACEType ||
         SYSTEM_AUDIT_OBJECT_ACE_TYPE == bACEType /*   ||
         SYSTEM_ALARM_ACE_TYPE        == bACEType      ||  <- ALARM ACE TYPES NOT YET SUPPORTED UNDER W2K
         SYSTEM_ALARM_OBJECT_ACE_TYPE == bACEType */ )
	{
		if ( NULL != m_pSACL )
		{
			fReturn = m_pSACL->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask, ace );
		}
	}
	else
	{
        if ( NULL != m_pDACL )
		{
			fReturn = m_pDACL->Find( sid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwMask, ace );
		}
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::FindACE
//
//	Locates an ACE in either the SACL or DACL based on the supplied
//	criteria.
//
//	Inputs:
//				const CSid&		sid - Sid for the entry.
//				BYTE			bACEType - ACE Type
//				BYTE			bACEFlags - Flags
//
//	Outputs:
//				CAccessEntry&	ace - Filled out with located values.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Locates an ACE that matches ALL supplied criteria
//
///////////////////////////////////////////////////////////////////
bool CSecurityDescriptor::FindACE( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask, CAccessEntry& ace  )
{
	bool fReturn = false;

	if ( SYSTEM_AUDIT_ACE_TYPE        == bACEType ||
         SYSTEM_AUDIT_OBJECT_ACE_TYPE == bACEType ||
         SYSTEM_ALARM_ACE_TYPE        == bACEType ||
         SYSTEM_ALARM_OBJECT_ACE_TYPE == bACEType)
	{
		if ( NULL != m_pSACL )
		{
			fReturn = m_pSACL->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
		}
	}
	else
	{
        if ( NULL != m_pDACL )
		{
			fReturn = m_pDACL->Find( psid, bACEType, bACEFlags, pguidObjGuid, pguidInhObjGuid, dwAccessMask, ace );
		}
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::ApplySecurity
//
//	Using the user specified flags, builds an appropriate descriptor
//	and loads it with the necessary information, then passes this
//	descriptor off to SecureObject() which will farm out the
//	actual setting of security to the virtual Write functions.
//
//	Inputs:
//				SECURITY_INFORMATION	securityinfo	- flags to control
//										how the descriptor is used.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD					ERROR_SUCCESS if successful.
//
//	Comments:
//
//	This should be the only public method for applying security
//	to an object.
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::ApplySecurity( SECURITY_INFORMATION securityinfo )
{
	DWORD	dwError		=	ERROR_SUCCESS;

	PSID	pOwnerSid	=	NULL;
	PACL	pDacl		=	NULL,
			pSacl		=	NULL;

	// Allocate and initialize the security descriptor
	PSECURITY_DESCRIPTOR	pAbsoluteSD = NULL;
    try
    {
        pAbsoluteSD = new SECURITY_DESCRIPTOR;
    }
    catch(...)
    {
        if(pAbsoluteSD != NULL)
        {
            delete pAbsoluteSD;
            pAbsoluteSD = NULL;
        }
        throw;
    }

	if ( NULL != pAbsoluteSD )
	{
		if ( !InitializeSecurityDescriptor( pAbsoluteSD, SECURITY_DESCRIPTOR_REVISION ) )
		{
			dwError = ::GetLastError();
		}
	}
	else
	{
		dwError = ERROR_NOT_ENOUGH_MEMORY;
	}

	// If we're supposed to set the owner, place the sid from the internal
	// value in the absoluteSD.

	if (	ERROR_SUCCESS == dwError
		&&	securityinfo & OWNER_SECURITY_INFORMATION )
	{
		if ( NULL != m_pOwnerSid )
		{
			pOwnerSid = m_pOwnerSid->GetPSid();
		}

		if ( !SetSecurityDescriptorOwner( pAbsoluteSD, pOwnerSid, m_fOwnerDefaulted ) )
		{
			dwError = ::GetLastError();
		}
	}

	// If we're supposed to set the DACL, this is a non-trivial operation so
	// call out for reinforcements.

	if (	ERROR_SUCCESS == dwError
		&&	securityinfo & DACL_SECURITY_INFORMATION || securityinfo & PROTECTED_DACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_DACL_SECURITY_INFORMATION
        &&  m_pDACL != NULL)
	{

		if ( ( dwError = m_pDACL->ConfigureDACL( pDacl ) ) == ERROR_SUCCESS )
		{

			if ( !SetSecurityDescriptorDacl( pAbsoluteSD,
											( NULL != pDacl ),	// Set Dacl present flag
											pDacl,
											m_fDACLDefaulted ) )
			{
				dwError = ::GetLastError();
			}

		}

	}

	// If we're supposed to set the SACL, this also is a non-trivial operation so
	// call out for reinforcements.

	if (ERROR_SUCCESS == dwError)
    {
        if((securityinfo & SACL_SECURITY_INFORMATION || securityinfo & PROTECTED_SACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
           &&  (m_pSACL != NULL))
	    {

		    if ( ( dwError = m_pSACL->ConfigureSACL( pSacl ) ) == ERROR_SUCCESS )
		    {

			    if ( !SetSecurityDescriptorSacl( pAbsoluteSD,
											    ( NULL != pSacl ),	// Set Sacl present flag
											    pSacl,
											    m_fSACLDefaulted ) )
			    {
				    dwError = ::GetLastError();
			    }

		    }
        }
	}


	// If we're OK, let the object try to secure itself, the default implementation
	// fails with ERROR_INVALID_FUNCTION.

	if ( ERROR_SUCCESS == dwError )
	{
		ASSERT_BREAK( IsValidSecurityDescriptor( pAbsoluteSD ) );
		dwError = SecureObject( pAbsoluteSD, securityinfo );
	}

	// Clean up allocated memory
	if ( NULL != pAbsoluteSD )
	{
		delete pAbsoluteSD;
	}

	if ( NULL != pDacl )
	{
		// This guy gets malloced in ConfigureDACL
		free( pDacl );
	}

	if ( NULL != pSacl )
	{
		// This guy gets malloced in ConfigureSACL
		free( pSacl );
	}

	return dwError;
}




///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::Clear
//
//	Empties out our class, freeing up all allocated memory.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CSecurityDescriptor::Clear( void )
{
	if ( NULL != m_pOwnerSid )
	{
		delete m_pOwnerSid;
		m_pOwnerSid = NULL;
	}

	m_fOwnerDefaulted = FALSE;

    if ( NULL != m_pDACL )
	{
		delete m_pDACL;
		m_pDACL = NULL;
	}

	if ( NULL != m_pSACL )
	{
		delete m_pSACL;
		m_pSACL = NULL;
	}

	if ( NULL != m_pGroupSid )
	{
		delete m_pGroupSid;
		m_pGroupSid = NULL;
	}

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::GetDACL
//
//	Makes a copy of our DACL entries and places them in the supplied
//	DACL, in proper canonical order.
//
//	Inputs:
//				None.
//
//	Outputs:
//				CDACL&		DACL - Dacl to copy into.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::GetDACL ( CDACL&	DACL )
{
    bool fRet = false;
    if(m_pDACL != NULL)
    {
        fRet = DACL.CopyDACL( *m_pDACL );
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::GetSACL
//
//	Makes a copy of our SACL entries and places them in the supplied
//	SACL.
//
//	Inputs:
//				None.
//
//	Outputs:
//				CSACL&		SACL - Sacl to copy into.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::GetSACL ( CSACL&	SACL )
{
    bool fRet = false;
    if(m_pSACL != NULL)
    {
        fRet = SACL.CopySACL( *m_pSACL );
    }
    return fRet;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::EmptyDACL
//
//	Clears our DACL lists, allocating them if they DO NOT exist.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, an empty DACL is different from a NULL DACL, in that
//	empty means nobody has access and NULL means everyone has
//	full control.
//
///////////////////////////////////////////////////////////////////

void CSecurityDescriptor::EmptyDACL()
{
    if(m_pDACL != NULL)
    {
        m_pDACL->Clear();
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::EmptySACL
//
//	Clears our SACL lists, allocating it if it DOES NOT exist
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	In the case of a sacl, there is no distinction between a NULL
//  and an Empty. So we will consider this sacl Empty if its data
//  member is NULL.
//
///////////////////////////////////////////////////////////////////

void CSecurityDescriptor::EmptySACL()
{
    if(m_pSACL != NULL)
    {
        m_pSACL->Clear();
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::ClearSACL
//
//	Deletes our SACL list.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	In the case of a sacl, there is no distinction between a NULL
//  and an Empty. So we will consider this sacl Empty if its data
//  member is NULL.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::MakeSACLNull()
{
	bool fReturn = false;
    if(m_pSACL == NULL)
    {
        try
        {
            m_pSACL = new CSACL;
        }
        catch(...)
        {
            if(m_pSACL != NULL)
            {
                delete m_pSACL;
                m_pSACL = NULL;
            }
            throw;
        }
        if(m_pSACL != NULL)
        {
            m_pSACL->Clear();
            fReturn = true;
        }
    }
    else
    {
        m_pSACL->Clear();
        m_pSACL->Clear();
        fReturn = true;
    }

	return fReturn;

}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::MakeDACLNull
//
//	NULLs out our DACL Lists except for the ACCESS_ALLOWED_ACE_TYPE
//  list, which it clears, then enters an Everybody ace into.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, an empty DACL is different from a NULL DACL, in that
//	empty means nobody has access and NULL means everyone has
//	full control.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::MakeDACLNull( void )
{
	bool fReturn = false;
    if(m_pDACL == NULL)
    {
        try
        {
            m_pDACL = new CDACL;
        }
        catch(...)
        {
            if(m_pDACL != NULL)
            {
                delete m_pDACL;
                m_pDACL = NULL;
            }
            throw;
        }
        if(m_pDACL != NULL)
        {
            m_pDACL->CreateNullDACL();
            fReturn = true;
        }
    }
    else
    {
        m_pDACL->Clear();
        fReturn = m_pDACL->CreateNullDACL();
        fReturn = true;
    }

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::IsNULLDACL
//
//	Checks our DACL Lists to see if we have a NULL DACL.  Which
//  means that all our lists are NULL, except for the
//  ACCESS_ALLOWED_ACE_TYPE list, which will have exactly one entry
//  in it - namely, an ACE for Everyone.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, a NULL DACL is the same as "Everyone" has Full Control,
//	so if a single Access Allowed entry exists that meets these
//	criteria, we consider ourselves to be NULL.
//
///////////////////////////////////////////////////////////////////

bool CSecurityDescriptor::IsNULLDACL()
{
	bool fRet = false;
    if(m_pDACL != NULL)
    {
        fRet = m_pDACL->IsNULLDACL();
    }
    return fRet;
}


void CSecurityDescriptor::DumpDescriptor(LPCWSTR wstrFilename)
{
    CHString chstrTemp;

    Output(L"Security descriptor contents follow...", wstrFilename);
    // Output the control flags
    chstrTemp.Format(L"Control Flags (hex): %x", m_SecurityDescriptorControl);
    Output(chstrTemp, wstrFilename);

    // Ouput the owner
    Output(L"Owner contents: ", wstrFilename);
    if(m_pOwnerSid != NULL)
    {
        m_pOwnerSid->DumpSid(wstrFilename);
    }
    else
    {
        Output(L"(Owner is null)", wstrFilename);
    }


    // Output the group
    Output(L"Group contents: ", wstrFilename);
    if(m_pGroupSid != NULL)
    {
        m_pGroupSid->DumpSid(wstrFilename);
    }
    else
    {
        Output(L"(Group is null)", wstrFilename);
    }

    // Output the DACL
    Output(L"DACL contents: ", wstrFilename);
    if(m_pDACL != NULL)
    {
        m_pDACL->DumpDACL(wstrFilename);
    }
    else
    {
        Output(L"(DACL is null)", wstrFilename);
    }

    // Output the SACL
    Output(L"SACL contents: ", wstrFilename);
    if(m_pSACL != NULL)
    {
        m_pSACL->DumpSACL(wstrFilename);
    }
    else
    {
        Output(L"(SACL is null)", wstrFilename);
    }
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSecurityDescriptor::GetPSD
//
//	Takes our internal members and constructs a PSECURITY_DESCRIPTOR,
//      which the caller must free.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				BOOL		TRUE/FALSE
//
//	Comments:
//
//	Remember, a NULL DACL is the same as "Everyone" has Full Control,
//	so if a single Access Allowed entry exists that meets these
//	criteria, we consider ourselves to be NULL.
//
///////////////////////////////////////////////////////////////////

DWORD CSecurityDescriptor::GetSelfRelativeSD(
	SECURITY_INFORMATION securityinfo,
	PSECURITY_DESCRIPTOR psd)
{
	DWORD	dwError		=	ERROR_SUCCESS;

	PSID	pOwnerSid	=	NULL;
	PACL	pDacl		=	NULL,
			pSacl		=	NULL;

	// Allocate and initialize the security descriptor
	PSECURITY_DESCRIPTOR	pAbsoluteSD = NULL;
    try
    {
        pAbsoluteSD = new SECURITY_DESCRIPTOR;
    }
    catch(...)
    {
        if(pAbsoluteSD != NULL)
        {
            delete pAbsoluteSD;
            pAbsoluteSD = NULL;
        }
        throw;
    }

	if ( NULL != pAbsoluteSD )
	{
		if ( !::InitializeSecurityDescriptor( pAbsoluteSD, SECURITY_DESCRIPTOR_REVISION ) )
		{
			dwError = ::GetLastError();
		}
	}
	else
	{
		dwError = ERROR_NOT_ENOUGH_MEMORY;
	}

	// If we're supposed to set the owner, place the sid from the internal
	// value in the absoluteSD.

	if (	ERROR_SUCCESS == dwError
		&&	securityinfo & OWNER_SECURITY_INFORMATION )
	{
		if ( NULL != m_pOwnerSid )
		{
			pOwnerSid = m_pOwnerSid->GetPSid();
		}

		if ( !::SetSecurityDescriptorOwner( pAbsoluteSD, pOwnerSid, m_fOwnerDefaulted ) )
		{
			dwError = ::GetLastError();
		}
	}

	// If we're supposed to set the DACL, this is a non-trivial operation so
	// call out for reinforcements.

	if (	ERROR_SUCCESS == dwError
		&&	securityinfo & DACL_SECURITY_INFORMATION || securityinfo & PROTECTED_DACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_DACL_SECURITY_INFORMATION
        &&  m_pDACL != NULL)
	{

		if ( ( dwError = m_pDACL->ConfigureDACL( pDacl ) ) == ERROR_SUCCESS )
		{

			if ( !::SetSecurityDescriptorDacl( pAbsoluteSD,
											( NULL != pDacl ),	// Set Dacl present flag
											pDacl,
											m_fDACLDefaulted ) )
			{
				dwError = ::GetLastError();
			}

		}

	}

	// If we're supposed to set the SACL, this also is a non-trivial operation so
	// call out for reinforcements.

	if (ERROR_SUCCESS == dwError)
    {
        if((securityinfo & SACL_SECURITY_INFORMATION || securityinfo & PROTECTED_SACL_SECURITY_INFORMATION || securityinfo & UNPROTECTED_SACL_SECURITY_INFORMATION)
           &&  (m_pSACL != NULL))
	    {

		    if ( ( dwError = m_pSACL->ConfigureSACL( pSacl ) ) == ERROR_SUCCESS )
		    {

				if ( !::SetSecurityDescriptorSacl( pAbsoluteSD,
											    ( NULL != pSacl ),	// Set Sacl present flag
											    pSacl,
											    m_fSACLDefaulted ) )
			    {
				    dwError = ::GetLastError();
			    }

		    }
        }
	}


	// If we're OK, let the object try to secure itself, the default implementation
	// fails with ERROR_INVALID_FUNCTION.

	if ( ERROR_SUCCESS == dwError )
	{
		ASSERT_BREAK( ::IsValidSecurityDescriptor( pAbsoluteSD ) );

		// Now make it self relative... Caller frees this...
		DWORD dwSize = 0L;
		if(!::MakeSelfRelativeSD(
			pAbsoluteSD,
			NULL,
			&dwSize) &&
			(dwError = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
		{
			PSECURITY_DESCRIPTOR pSelfRelSD = NULL;
			pSelfRelSD = new BYTE[dwSize];

			if(pSelfRelSD && 
				!::MakeSelfRelativeSD(
				pAbsoluteSD,
				pSelfRelSD,
				&dwSize))
			{
				dwError = ::GetLastError();
			}
			else
			{
				psd = pSelfRelSD;
				dwError = ERROR_SUCCESS;
			}
		}
	}

	// Clean up allocated memory
	if ( NULL != pAbsoluteSD )
	{
		delete pAbsoluteSD;
	}

	if ( NULL != pDacl )
	{
		// This guy gets malloced in ConfigureDACL
		free( pDacl );
	}

	if ( NULL != pSacl )
	{
		// This guy gets malloced in ConfigureSACL
		free( pSacl );
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\secutils.h ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/



//=================================================================

//

// SecUtils.cpp -- Security utilities useful to wbem mof classes

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/9/99    a-kevhu        Created
//
//=================================================================
#ifndef _SECUTILS_H_
#define _SECUTILS_H_

// Forward class declarations...
class CDACL;
class CSACL;
class CSid;


void FillTrusteeFromSid (CInstance *pInstance, CSid &sid);

void FillInstanceDACL(CInstance *pInstance, CDACL &dacl);

void FillInstanceSACL(CInstance *pInstance, CSACL &sacl);

DWORD FillDACLFromInstance(CInstance *pInstance, 
                           CDACL &dacl, 
                           MethodContext *pMethodContext);

DWORD FillSACLFromInstance(CInstance *pInstance, 
                           CSACL &sacl, 
                           MethodContext *pMethodContext);

bool GetArray(IWbemClassObject *piClassObject, 
              const CHString &name, 
              VARIANT &v, 
              VARTYPE eVariantType);

DWORD FillSIDFromTrustee(CInstance *pTrustee, CSid &sid);

#ifdef NTONLY
void DumpWin32Descriptor(PSECURITY_DESCRIPTOR psd, LPCWSTR wstrFilename = NULL);
void Output(LPCWSTR wstrOut, LPCWSTR wstrFilename = NULL);

bool AmIAnOwner(const CHString &chstrName, SE_OBJECT_TYPE ObjectType);
bool IsUserInGroup(const CSid &csidUser, 
                   const CSid &csidGroup, 
                   SID_NAME_USE snuGroup);
bool RecursiveFindUserInGroup(CNetAPI32 &netapi, 
                              const CHString &chstrDomainName,
                              const CHString &chstrGroupName, 
                              SID_NAME_USE snuGroup,
                              const CSid &csidUser);
#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\session.cpp ===
//=============================================================================

// session.cpp -- implementation of session collection class.

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//=============================================================================



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#pragma warning (disable: 4786)


#include "precomp.h"
#include <map>
#include <vector>
#include <comdef.h>
#include "chstring.h"
#include "session.h"
#include <ProvExce.h>
#include <AssertBreak.h>
#include <wbemcli.h>
#include <ntsecapi.h>

#ifdef _WIN32_WINNT
#define SECURITY_WIN32
#else
#define SECURITY_WIN16
#endif

#include <sspi.h>



typedef SECURITY_STATUS (SEC_ENTRY *PFN_LSA_ENUMERATE_LOGON_SESSIONS)
(
    OUT PULONG  LogonSessionCount,
    OUT PLUID*  LogonSessionList
);


typedef SECURITY_STATUS (SEC_ENTRY *PFN_LSA_GET_LOGON_SESSION_DATA)
(
    IN   PLUID                           LogonId,
    OUT  PSECURITY_LOGON_SESSION_DATA*   ppLogonSessionData
);


typedef NTSTATUS (*PFN_LSA_FREE_RETURN_BUFFER)
(
    IN PVOID Buffer
);



//*****************************************************************************
// CUserSessionCollection functions
//*****************************************************************************

CUserSessionCollection::CUserSessionCollection()
{
    Refresh();
}


CUserSessionCollection::CUserSessionCollection(
    const CUserSessionCollection& sescol)
{
    m_usr2ses.clear();

    USER_SESSION_ITERATOR sourceIter;

    for(sourceIter = sescol.m_usr2ses.begin();
        sourceIter != sescol.m_usr2ses.end();
        sourceIter++)
    {
        m_usr2ses.insert(
            USER_SESSION_MAP::value_type(        
                sourceIter->first,
                sourceIter->second));
    }

}



DWORD CUserSessionCollection::Refresh()
{
    DWORD dwRet = ERROR_SUCCESS;

    // Empty out previous contents...
    m_usr2ses.clear();

    dwRet = CollectSessions();

    return dwRet;
}



DWORD CUserSessionCollection::CollectSessions()
{
    DWORD dwRet = ERROR_SUCCESS;
    std::vector<CProcess> vecProcesses;
    SmartCloseHANDLE hProcess;
    SmartCloseHANDLE hToken;
    TOKEN_STATISTICS tokstats;
    PTOKEN_USER ptokusr = NULL;
    DWORD dwRetSize = 0L;
    PSID psidUsr = NULL;
    CHString chstrUsr;
    LUID luidSes;


    try
    {
        // Enable the debug privilege...
        EnablePrivilegeOnCurrentThread(SE_DEBUG_NAME);

        // Get a list of all running processes...
        dwRet = GetProcessList(vecProcesses);

        if(dwRet == ERROR_SUCCESS)
        {
            // For each member of the process list...
            for(long m = 0L; 
                m < vecProcesses.size(); 
                m++)
            {
                // open the process...
                ::SetLastError(ERROR_SUCCESS);
                dwRet = ERROR_SUCCESS;

                hProcess = ::OpenProcess(
                    PROCESS_QUERY_INFORMATION,
                    FALSE,
                    vecProcesses[m].GetPID());

                if(hProcess == NULL)
                {
                    dwRet = ::GetLastError();
                }

                // get the process token...
                if(hProcess != NULL &&
                   dwRet == ERROR_SUCCESS)
                {
                    ::SetLastError(ERROR_SUCCESS);
                    dwRet = ERROR_SUCCESS;

                    if(!::OpenProcessToken(
                        hProcess,
                        TOKEN_QUERY,
                        &hToken))
                    {
                        dwRet = ::GetLastError();
                    }
                }

                // get the token statistics...
                if(hToken != NULL &&
                   dwRet == ERROR_SUCCESS)
                {
                    ::SetLastError(ERROR_SUCCESS);
                    dwRet = ERROR_SUCCESS;
                    if(!::GetTokenInformation(
                        hToken,
                        TokenStatistics,
                        &tokstats,
                        sizeof(TOKEN_STATISTICS),
                        &dwRetSize))
                    {
                        dwRet = ::GetLastError();
                    }
                }

                // get the token user sid...
                if(dwRet == ERROR_SUCCESS)
                {
                    ::SetLastError(ERROR_SUCCESS);
                    dwRet = ERROR_SUCCESS;
                    // the token user struct varries
                    // in size depending on the size
                    // of the sid in the SID_AND_ATTRIBUTES
                    // structure, so need to allocate
                    // it dynamically.
                    if(!::GetTokenInformation(
                        hToken,
                        TokenUser,
                        NULL,
                        0L,
                        &dwRetSize))
                    {
                        dwRet = ::GetLastError();
                    }
                    if(dwRet == ERROR_INSUFFICIENT_BUFFER)
                    {
                        // now get it for real...
                        ::SetLastError(ERROR_SUCCESS);
                        dwRet = ERROR_SUCCESS;
                        ptokusr = (PTOKEN_USER) new BYTE[dwRetSize];
                        DWORD dwTmp = dwRetSize;
                        if(ptokusr != NULL)
                        {
                            if(!::GetTokenInformation(
                                hToken,
                                TokenUser,
                                ptokusr,
                                dwTmp,
                                &dwRetSize))
                            {
                                dwRet = ::GetLastError();
                            }
                        }
                        else
                        {
                            dwRet = ::GetLastError();
                        }
                    }
                }
            
                if(ptokusr != NULL)
                {
                    if(dwRet == ERROR_SUCCESS)
                    {
                        psidUsr = (ptokusr->User).Sid;

                        // from the token statistics, get 
                        // the TokenID LUID of the session...
                        luidSes.LowPart = tokstats.AuthenticationId.LowPart;
                        luidSes.HighPart = tokstats.AuthenticationId.HighPart; 

                        // try to find the session of the 
                        // process in the multimap...
                        USER_SESSION_ITERATOR usiter;
                        
                        if(FindSessionInternal(
                            luidSes,
                            usiter))
                        {
                            // try to find the process id in the 
                            // session's process vector...
                            CSession sesTmp(usiter->second);
                            CProcess* procTmp = NULL;
                            bool fFoundIt = false;

                            for(long z = 0L; 
                                z < sesTmp.m_vecProcesses.size() && !fFoundIt;
                                z++)
                            {
                                if((DWORD)(sesTmp.m_vecProcesses[z].GetPID()) == 
                                    vecProcesses[m].GetPID())
                                {
                                    fFoundIt = true;
                                }
                            }
                        
                            // If we didn't find the process in the
                            // session's list of processes, add it in...
                            if(!fFoundIt)
                            {
                                (usiter->second).m_vecProcesses.push_back(
                                    CProcess(vecProcesses[m]));
                            }
                        }
                        else // no such session in the map, so add an entry
                        {
                            // Create new CSession(tokenid LUID), and 
                            // add process to the session's process vector...         
                            CSession sesNew(luidSes);
                            sesNew.m_vecProcesses.push_back(
                                vecProcesses[m]);

                            // add CUser(user sid) to map.first and the 
                            // CSession just created to map.second...
                            CUser cuTmp(psidUsr);
                            if(cuTmp.IsValid())
                            {
                                m_usr2ses.insert(
                                    USER_SESSION_MAP::value_type(
                                        cuTmp,
                                        sesNew));
                            }
                            else
                            {
                                LogErrorMessage2(
                                    L"Token of process %d contains an invalid sid", 
                                    vecProcesses[m].GetPID());
                            }
                        }
                    }
                    delete ptokusr; 
                    ptokusr = NULL;
                }
            } // next process

        }

        // There may have been sessions not associated
        // with any processes.  To get these, we will
        // use LSA.
        CollectNoProcessesSessions();
    }
    catch(...)
    {
        if(ptokusr != NULL)
        {
            delete ptokusr; ptokusr = NULL;
        }
        throw;
    }

    return dwRet;
}


void CUserSessionCollection::Copy(
    CUserSessionCollection& out) const
{
    out.m_usr2ses.clear();

    USER_SESSION_ITERATOR meIter;

    for(meIter = m_usr2ses.begin();
        meIter != m_usr2ses.end();
        meIter++)
    {
        out.m_usr2ses.insert(
            USER_SESSION_MAP::value_type(        
                meIter->first,
                meIter->second));
    }
}


// Support enumeration of users.  Returns
// a newly allocated copy of what was in
// the map (caller must free).
CUser* CUserSessionCollection::GetFirstUser(
    USER_SESSION_ITERATOR& pos)
{
    CUser* cusrRet = NULL;

    if(!m_usr2ses.empty())
    {
        pos = m_usr2ses.begin();
        cusrRet = new CUser(pos->first);
    }
    
    return cusrRet;
}

// Returns a newly allocated CUser*, which
// the caller must free.
CUser* CUserSessionCollection::GetNextUser(
    USER_SESSION_ITERATOR& pos)
{
    // Users are the non-unique part of 
    // the map, so we need to go through
    // the map until the next user entry
    // comes up.
    CUser* usrRet = NULL;

    while(pos != m_usr2ses.end())
    {
        CHString chstrSidCur;
        pos->first.GetSidString(chstrSidCur);
    
        pos++;

        if(pos != m_usr2ses.end())
        {
            CHString chstrSidNext;
            pos->first.GetSidString(chstrSidNext);

            // Return the first instance where
            // the next user is different from 
            // the current one.
            if(chstrSidNext.CompareNoCase(chstrSidCur) != 0)
            {
                usrRet = new CUser(pos->first);
                break;
            }
        }
    }

    return usrRet;        
}


// Support enumeration of sessions
// belonging to a particular user.
CSession* CUserSessionCollection::GetFirstSessionOfUser(
    CUser& usr,
    USER_SESSION_ITERATOR& pos)
{
    CSession* csesRet = NULL;

    if(!m_usr2ses.empty())
    {
        pos = m_usr2ses.find(usr);
        if(pos != m_usr2ses.end())
        {
            csesRet = new CSession(pos->second);
        }
    }
    return csesRet;
}


CSession* CUserSessionCollection::GetNextSessionOfUser(
    USER_SESSION_ITERATOR& pos)
{
    // Sessions are the unique part of 
    // the map, so we just need to get 
    // the next one as long as pos.first
    // matches usr...
    CSession* sesRet = NULL;

    if(pos != m_usr2ses.end())
    {
        CHString chstrUsr1;
        CHString chstrUsr2;
        
        (pos->first).GetSidString(chstrUsr1);

        pos++;
        
        if(pos != m_usr2ses.end())
        {
            (pos->first).GetSidString(chstrUsr2);
            if(chstrUsr1.CompareNoCase(chstrUsr2) == 0)
            {
                sesRet = new CSession(pos->second);
            }
        }
    }

    return sesRet;
}



// Support enumeration of all sessions.  Returns a 
// newly allocated CSession*, which the caller
// must free.
CSession* CUserSessionCollection::GetFirstSession(
    USER_SESSION_ITERATOR& pos)
{
    CSession* csesRet = NULL;

    if(!m_usr2ses.empty())
    {
        pos = m_usr2ses.begin();
        csesRet = new CSession(pos->second);
    }
    return csesRet;
}

// Returns a newly allocated CSession* that the
// caller must free.
CSession* CUserSessionCollection::GetNextSession(
    USER_SESSION_ITERATOR& pos)
{
    // Sessions are the unique part of 
    // the map, so we just need to get 
    // the next one...
    CSession* sesRet = NULL;

    if(pos != m_usr2ses.end())
    {
        pos++;
        if(pos != m_usr2ses.end())
        {
            sesRet = new CSession(pos->second);
        }
    }

    return sesRet;
}


// Support finding a particular session.
// This internal version hands back an iterator
// on our member map that points to the found
// instance if found (when the function returns
// true.  If the function returns
// false, the iterator points to the end of our
// map.
bool CUserSessionCollection::FindSessionInternal(
    LUID& luidSes,
    USER_SESSION_ITERATOR& usiOut)
{
    bool fFoundIt = false;

    for(usiOut = m_usr2ses.begin();
        usiOut != m_usr2ses.end();
        usiOut++)
    {
        LUID luidTmp = (usiOut->second).GetLUID();
        if(luidTmp.HighPart == luidSes.HighPart &&
           luidTmp.LowPart == luidSes.LowPart)
        {
            fFoundIt = true;
            break;
        }
    }

    return fFoundIt;
}


// Support finding a particular session - external
// callers can call this one, and are given a new
// CSession* they can play with.
CSession* CUserSessionCollection::FindSession(
    LUID& luidSes)
{
    CSession* psesRet = NULL;
    USER_SESSION_ITERATOR pos;
    
    if(FindSessionInternal(
        luidSes,
        pos))
    {
        psesRet = new CSession(pos->second);
    }

    return psesRet;
}

CSession* CUserSessionCollection::FindSession(
    __int64 i64luidSes)
{
    LUID luidSes = *((LUID*)(&i64luidSes));
    return FindSession(luidSes);
}


// Support enumeration of processes
// belonging to a particular user.  Returns
// newly allocated CProcess* which the caller
// must free.
CProcess* CUserSessionCollection::GetFirstProcessOfUser(
    CUser& usr,
    USER_SESSION_PROCESS_ITERATOR& pos)
{
    CProcess* cprocRet = NULL;
    CHString chstrUsrSidStr;
    CHString chstrTmp;

    if(!m_usr2ses.empty())
    {
        usr.GetSidString(chstrUsrSidStr);
        pos.usIter = m_usr2ses.find(usr);
        while(pos.usIter != m_usr2ses.end())
        {
            // Get the sid string of the user we
            // are at and see whether the strings
            // are the same (e.g., whether this is a
            // session associated with the specified
            // user)...
            (pos.usIter)->first.GetSidString(chstrTmp);
            if(chstrUsrSidStr.CompareNoCase(chstrTmp) == 0)
            {
                // Now check that the session of the user
                // we are on has processes...
                if(!(((pos.usIter)->second).m_vecProcesses.empty()))
                {
                    pos.procIter = 
                        ((pos.usIter)->second).m_vecProcesses.begin();
                    cprocRet = new CProcess(*(pos.procIter));
                }
                else
                {
                    // the session for this user has
                    // no processes, so go to the next 
                    // session...
                    (pos.usIter)++;
                }
            }
        }
    }

    return cprocRet;
}


// Returns a newly allocated CProcess* that the
// caller must free.
CProcess* CUserSessionCollection::GetNextProcessOfUser(
    USER_SESSION_PROCESS_ITERATOR& pos)
{
    CProcess* cprocRet = NULL;
    CHString chstrCurUsr;
    CHString chstrNxtSesUsr;

    if(pos.usIter != m_usr2ses.end())
    {
        (pos.usIter)->first.GetSidString(chstrCurUsr);

        while(pos.usIter != m_usr2ses.end())
        {
            // First try to get the next process
            // within the current session.  If we
            // were at the end of the list of processes
            // for the current session, go to the
            // next session...
            (pos.procIter)++;

            // Of course, if we have moved on
            // to a different user, then stop.
            (pos.usIter)->first.GetSidString(chstrNxtSesUsr);
            if(chstrCurUsr.CompareNoCase(chstrNxtSesUsr) == 0)
            {
                if(pos.procIter == 
                    ((pos.usIter)->second).m_vecProcesses.end())
                {
                    (pos.usIter)++;
                }
                else
                {    
                    cprocRet = new CProcess(*(pos.procIter));    
                }
            }
        }
    }

    return cprocRet;
}



// Support enumeration of all processes.  Returns
// newly allocated CProcess* which the caller
// must free.
CProcess* CUserSessionCollection::GetFirstProcess(
    USER_SESSION_PROCESS_ITERATOR& pos)
{
    CProcess* cprocRet = NULL;

    if(!m_usr2ses.empty())
    {
        pos.usIter = m_usr2ses.begin();
        while(pos.usIter != m_usr2ses.end())
        {
            if(!(((pos.usIter)->second).m_vecProcesses.empty()))
            {
                pos.procIter = 
                    ((pos.usIter)->second).m_vecProcesses.begin();
                cprocRet = new CProcess(*(pos.procIter));
            }
            else
            {
                (pos.usIter)++;
            }
        }
    }

    return cprocRet;
}


// Returns a newly allocated CProcess* that the
// caller must free.
CProcess* CUserSessionCollection::GetNextProcess(
    USER_SESSION_PROCESS_ITERATOR& pos)
{
    CProcess* cprocRet = NULL;

    while(pos.usIter != m_usr2ses.end())
    {
        // First try to get the next process
        // within the current session.  If we
        // were at the end of the list of processes
        // for the current session, go to the
        // next session...
        (pos.procIter)++;
        if(pos.procIter == 
            ((pos.usIter)->second).m_vecProcesses.end())
        {
            (pos.usIter)++;
        }
        else
        {    
            cprocRet = new CProcess(*(pos.procIter));    
        }
    }

    return cprocRet;
}


// This helper enumerates the current set of processes
// and ads each process id as a DWORD in the vector.
DWORD CUserSessionCollection::GetProcessList(
    std::vector<CProcess>& vecProcesses) const
{
    DWORD dwRet = ERROR_SUCCESS;

    // First, load up ntdll...
    HMODULE hLib = NULL;
    PFN_NT_QUERY_SYSTEM_INFORMATION pfnNtQuerySystemInformation = NULL;

    try
    {
        hLib = LoadLibraryW(L"NTDLL.DLL");
        if(hLib != NULL)
        {
            // Get proc address of NtQuerySystemInformation...
            pfnNtQuerySystemInformation = (PFN_NT_QUERY_SYSTEM_INFORMATION)
                                    GetProcAddress(
                                        hLib,
                                        "NtQuerySystemInformation");
            
            if(pfnNtQuerySystemInformation != NULL)
            {
                // Ready to rock.  Enable debug priv...
                EnablePrivilegeOnCurrentThread(SE_DEBUG_NAME);
                
                DWORD dwProcessInformationSize = 0;
	            SYSTEM_PROCESS_INFORMATION* ProcessInformation = NULL;
                try
                {
                    // Get the process information...

                    BOOL fRetry = TRUE;
			        while(fRetry)
			        {
				        dwRet = pfnNtQuerySystemInformation(
					        SystemProcessInformation,
					        ProcessInformation,
					        dwProcessInformationSize,
					        NULL);

				        if(dwRet == STATUS_INFO_LENGTH_MISMATCH)
				        {
					        SetLastError(ERROR_SUCCESS);
                            delete [] ProcessInformation;
					        ProcessInformation = NULL;
					        dwProcessInformationSize += 32768;
					        ProcessInformation = 
                                (SYSTEM_PROCESS_INFORMATION*) 
                                    new BYTE[dwProcessInformationSize];
					        if(!ProcessInformation)
					        {
						        dwRet = ::GetLastError();
                                fRetry = FALSE;
					        }
				        }
				        else
				        {
					        fRetry = FALSE;
					        if(!NT_SUCCESS(dwRet))
					        {
						        if(ProcessInformation != NULL)
                                {
                                    delete ProcessInformation;
                                    ProcessInformation = NULL;
                                }
					        }
				        }
			        }

                    // If we got the process information, process it...
                    if(ProcessInformation != NULL &&
                       dwRet == ERROR_SUCCESS)
                    {
                        SYSTEM_PROCESS_INFORMATION* CurrentInformation = NULL;
                        DWORD dwNextOffset;
                        CurrentInformation = ProcessInformation;
                        bool fContinue = true;
                        while(CurrentInformation != NULL &&
                              fContinue)
                        {
                            {
                                CProcess cptmp(
                                    HandleToUlong(CurrentInformation->UniqueProcessId),
                                    (CurrentInformation->ImageName).Buffer);

                                vecProcesses.push_back(cptmp);
                            }

                            dwNextOffset = CurrentInformation->NextEntryOffset;
                            if(dwNextOffset)
                            {
                                CurrentInformation = (SYSTEM_PROCESS_INFORMATION*) 
                                    (((BYTE*) CurrentInformation) + dwNextOffset);
                            }
                            else
                            {
                                fContinue = false;
                            }
                        }
                    }

                    // Clean ourselves up...
                    if(ProcessInformation != NULL)
                    {
                        delete ProcessInformation;
                        ProcessInformation = NULL;
                    }
                }
                catch(...)
                {
                    if(ProcessInformation != NULL)
                    {
                        delete ProcessInformation;
                        ProcessInformation = NULL;
                    }
                    throw;
                }
            }

            FreeLibrary(hLib); hLib = NULL;
        }
        else
        {
            LogErrorMessage(L"Failed to load library ntdll.dll");
        }
    }
    catch(...)
    {
        FreeLibrary(hLib); hLib = NULL;
        throw;
    }

    return dwRet;
}

// Implementation lifted from dllutils.cpp.
DWORD CUserSessionCollection::EnablePrivilegeOnCurrentThread(
    LPCTSTR szPriv) const
{
    SmartCloseHANDLE    hToken = NULL;
    TOKEN_PRIVILEGES    tkp;
    BOOL                bLookup = FALSE;
    DWORD               dwLastError = ERROR_SUCCESS;

    // Try to open the thread token.  
    if (::OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
            FALSE, 
            &hToken))
    {

        {
            //CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
            bLookup = ::LookupPrivilegeValue(
                NULL, 
                szPriv, 
                &tkp.Privileges[0].Luid);
        }
        if (bLookup)
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Clear the last error.
            SetLastError(0);

            // Turn it on
            ::AdjustTokenPrivileges(
                hToken, 
                FALSE, 
                &tkp, 
                0,
                (PTOKEN_PRIVILEGES) NULL, 
                0);

            dwLastError = GetLastError();
        }
    }
	else
	{
		dwLastError = ::GetLastError();
	}

    // We have to check GetLastError() because 
    // AdjustTokenPrivileges lies about
    // its success but GetLastError() doesn't.
    return dwLastError;
}



bool CUserSessionCollection::IsSessionMapped(
    LUID& luidSes)
{
    bool fRet = false;

    USER_SESSION_ITERATOR usiter;
    usiter = m_usr2ses.begin();
    for(usiter = m_usr2ses.begin(); 
        usiter != m_usr2ses.end() && !fRet;
        usiter++)
    {
        LUID luidTmp = (usiter->second).GetLUID();
        if(luidTmp.HighPart == luidSes.HighPart &&
           luidTmp.LowPart == luidSes.LowPart)
        {
            fRet = true;
        }
    }

    return fRet;                                                   
}


bool CUserSessionCollection::IsSessionMapped(
    __int64 i64luidSes)
{
    LUID luidSes = *((LUID*)(&i64luidSes));
    return IsSessionMapped(luidSes);
}


// Collects sessions that have no associated
// process.  Uses LSA to enumerate sessions,
// then checks to see if we have each session
// already.  If we don't, adds it to our map.

DWORD CUserSessionCollection::CollectNoProcessesSessions()
{
    DWORD dwRet = ERROR_SUCCESS;
    ULONG ulLogonSessionCount = 0L;
    PLUID pluidLogonSessions = NULL;
    HMODULE hLib = NULL;
    PFN_LSA_ENUMERATE_LOGON_SESSIONS pfnEnumLogonSessions = NULL;
    PFN_LSA_GET_LOGON_SESSION_DATA pfnGetLogonSessionData = NULL;
    PFN_LSA_FREE_RETURN_BUFFER pfnLsaFreeReturnBuffer = NULL;

    try
    {
        // Doing a load library here rather than using the
        // resource manager, as SECURITYAPI.CPP defines us
        // to point to SECURITY.DLL, not SECUR32.DLL for the
        // W2K case.  

        hLib = ::LoadLibraryW(L"SECUR32.DLL");
        if(hLib)
        {
            pfnEnumLogonSessions = 
                (PFN_LSA_ENUMERATE_LOGON_SESSIONS) ::GetProcAddress(
                    hLib,
                    "LsaEnumerateLogonSessions");

            pfnGetLogonSessionData = 
                (PFN_LSA_GET_LOGON_SESSION_DATA) ::GetProcAddress(
                    hLib,
                    "LsaGetLogonSessionData");

            pfnLsaFreeReturnBuffer = 
                (PFN_LSA_FREE_RETURN_BUFFER) ::GetProcAddress(
                    hLib,
                    "LsaFreeReturnBuffer");

            if(pfnEnumLogonSessions &&
                pfnGetLogonSessionData &&
                pfnLsaFreeReturnBuffer)
            {    
                dwRet = pfnEnumLogonSessions(
                    &ulLogonSessionCount,
                    &pluidLogonSessions);
        
                if(dwRet == ERROR_SUCCESS &&
                    pluidLogonSessions)
                {
                    for(ULONG u = 0L;
                        u < ulLogonSessionCount && dwRet == ERROR_SUCCESS;
                        u++)
                    {
                        PSECURITY_LOGON_SESSION_DATA pSessionData = NULL;
                        dwRet = pfnGetLogonSessionData(
                            &pluidLogonSessions[u], 
                            &pSessionData);

                        if(dwRet == ERROR_SUCCESS &&
                            pSessionData)
                        {
                            // See if we have the session already...
                            if(!IsSessionMapped(pSessionData->LogonId))
                            {
                                // and if not, add it to the map.
                                CSession sesNew(pSessionData->LogonId);
                                CUser cuTmp(pSessionData->Sid);
                                CHString chstrTmp;
                                
                                if(cuTmp.IsValid())
                                {
                                    cuTmp.GetSidString(chstrTmp);
                    
                                    m_usr2ses.insert(
                                        USER_SESSION_MAP::value_type(
                                            cuTmp,
                                            sesNew));
                                }
                                else
                                {
                                    LUID luidTmp = sesNew.GetLUID();
                                    LogMessage3(
                                        L"GetLogonSessionData returned logon data for session "
                                        L"luid %d (highpart) %u (lowpart) containing an invalid SID", 
                                        luidTmp.HighPart,
                                        luidTmp.LowPart);
                                }
                            }

                            // While we are here, add in various
                            // session properties lsa has been kind
                            // enough to provide for us.
                            USER_SESSION_ITERATOR usiter;
                            usiter = m_usr2ses.begin();
                            bool fFound = false;
                            while(usiter != m_usr2ses.end() &&
                                !fFound)
                            {
                                LUID luidTmp = pSessionData->LogonId;
                                __int64 i64Tmp = *((__int64*)(&luidTmp));

                                if((usiter->second).GetLUIDint64() ==
                                    i64Tmp)
                                {
                                    fFound = true;
                                }
                                else
                                {
                                    usiter++;
                                }
                            }
                            if(fFound)
                            {
                                WCHAR wstrTmp[_MAX_PATH] = { '\0' };
                                if((pSessionData->AuthenticationPackage).Length < (_MAX_PATH - 1))
                                {
                                    wcsncpy(
                                        wstrTmp, 
                                        (pSessionData->AuthenticationPackage).Buffer, 
                                        (pSessionData->AuthenticationPackage).Length);

                                    (usiter->second).m_chstrAuthPkg = wstrTmp;
                                }
                               
                                (usiter->second).m_ulLogonType = 
                                    pSessionData->LogonType;

                                (usiter->second).i64LogonTime = 
                                    *((__int64*)(&(pSessionData->LogonTime)));
                            }

                            // Clean up buffer allocated by GetLogonSessionData...
                            pfnLsaFreeReturnBuffer(pSessionData);
                       }
                    }                
                    pfnLsaFreeReturnBuffer(pluidLogonSessions);
                    pluidLogonSessions = NULL;
                }
            }
            ::FreeLibrary(hLib);
            hLib = NULL;
        }
        else
        {
            LogErrorMessage(L"Failed to load library SECUR32.dll");
        }
    }
    catch(...)
    {
        if(pluidLogonSessions)
        {
            pfnLsaFreeReturnBuffer(pluidLogonSessions);
            pluidLogonSessions = NULL;
        }

        if(hLib)
        {
            ::FreeLibrary(hLib);
            hLib = NULL;
        }
        throw;
    }
    return dwRet; 
}


//*****************************************************************************
// CSession functions
//*****************************************************************************

CSession::CSession(
    const LUID& luidSessionID)
{
    m_luid.LowPart = luidSessionID.LowPart;
    m_luid.HighPart = luidSessionID.HighPart;
    m_ulLogonType = 0;
    i64LogonTime = 0;
}

CSession::CSession(
    const CSession& ses)
{
    m_luid.LowPart = ses.m_luid.LowPart;
    m_luid.HighPart = ses.m_luid.HighPart;
    m_chstrAuthPkg = ses.m_chstrAuthPkg;
    m_ulLogonType = ses.m_ulLogonType;
    i64LogonTime = ses.i64LogonTime;

    m_vecProcesses.clear();
    for(long lPos = 0; 
        lPos < ses.m_vecProcesses.size(); 
        lPos++)
    {
        m_vecProcesses.push_back(
            ses.m_vecProcesses[lPos]);

    }
}


LUID CSession::GetLUID() const
{
    return m_luid;   
}

__int64 CSession::GetLUIDint64() const
{
    __int64 i64LuidSes = *((__int64*)(&m_luid));
    return i64LuidSes;    
}

CHString CSession::GetAuthenticationPkg() const
{
    return m_chstrAuthPkg;
}


ULONG CSession::GetLogonType() const
{
    return m_ulLogonType;
}


__int64 CSession::GetLogonTime() const
{
    return i64LogonTime;
}




// Functions to support enumeration of
// processes associated with this session.
// Returns a newly allocated CProcess* that
// the caller must free.
CProcess* CSession::GetFirstProcess(
    PROCESS_ITERATOR& pos)
{
    CProcess* procRet = NULL;
    if(!m_vecProcesses.empty())
    {
        pos = m_vecProcesses.begin();
        procRet = new CProcess(*pos);
    }
    return procRet;
}


// Returns a newly allocated CProcess* that
// the caller must free.
CProcess* CSession::GetNextProcess(
    PROCESS_ITERATOR& pos)
{
    CProcess* procRet = NULL;

    if(pos >= m_vecProcesses.begin() &&
       pos < m_vecProcesses.end())
    {
        pos++;
        if(pos != m_vecProcesses.end())
        {
            procRet = new CProcess(*pos);
        }
    }

    return procRet;
}



void CSession::Copy(
    CSession& sesCopy) const
{
    sesCopy.m_luid.LowPart = m_luid.LowPart;
    sesCopy.m_luid.HighPart = m_luid.HighPart;
    sesCopy.m_chstrAuthPkg = m_chstrAuthPkg;
    sesCopy.m_ulLogonType = m_ulLogonType;
    sesCopy.i64LogonTime = i64LogonTime;

    sesCopy.m_vecProcesses.clear();
    for(long lPos = 0; 
        lPos < m_vecProcesses.size(); 
        lPos++)
    {
        sesCopy.m_vecProcesses.push_back(
            m_vecProcesses[lPos]);

    }
}


// This function impersonates the 
// explorer process in the session's
// process array, if it is present.
// (If it isn't, impersonates the
// first process in the process array.)
// Returns the handle of token of the  
// thread we started from for easy  
// reversion, orINVALID_HANDLE_VALUE if  
// we couldn't impersonate.  The caller  
// must close that handle.
HANDLE CSession::Impersonate()
{
    HANDLE hCurToken = INVALID_HANDLE_VALUE;

    // Find the explorer process...
    DWORD dwImpProcPID = GetImpProcPID();
    if(dwImpProcPID != -1L)
    {
        try  // Make sure we don't leave current thread token open
        {    // unless all went well.
            bool fOK = false;

            SmartCloseHANDLE hCurThread = 
                ::GetCurrentThread();

            if(::OpenThreadToken(
                hCurThread, 
                TOKEN_IMPERSONATE, 
                TRUE, 
                &hCurToken))
            {
                SmartCloseHANDLE hProcess;
                hProcess = ::OpenProcess(
                    PROCESS_QUERY_INFORMATION,
                    FALSE,
                    dwImpProcPID);

                if(hProcess)
                {
                    // now open its token...
                    SmartCloseHANDLE hExplorerToken;
                    if(::OpenProcessToken(
                            hProcess,
                            TOKEN_QUERY | TOKEN_DUPLICATE,
                            &hExplorerToken))
                    {
                        // Duplicate the token...
                        SmartCloseHANDLE hDupExplorerToken; 
                        if(::DuplicateTokenEx(
                            hExplorerToken,
                            MAXIMUM_ALLOWED,
                            NULL,  
                            SecurityImpersonation,
                            TokenImpersonation,
                            &hDupExplorerToken))
                        {
                            // Set the thread token...
                            if(::SetThreadToken(
                                &hCurThread,
                                hDupExplorerToken))
                            {
                                fOK = true;                        
                            }
                        }
                    }
                }
            }

            if(!fOK)
            {
                if(hCurToken != INVALID_HANDLE_VALUE)
                {
                    ::CloseHandle(hCurToken);
                    hCurToken = INVALID_HANDLE_VALUE;
                }    
            }
        }
        catch(...)
        {
            if(hCurToken != INVALID_HANDLE_VALUE)
            {
                ::CloseHandle(hCurToken);
                hCurToken = INVALID_HANDLE_VALUE;
            }
            throw;
        }
    }

    return hCurToken;
}


DWORD CSession::GetImpProcPID()
{
    DWORD dwRet = -1L;

    if(!m_vecProcesses.empty())
    {
        bool fFoundExplorerExe = false;

        for(long m = 0;
            m < m_vecProcesses.size() && 
             !fFoundExplorerExe;)
        {
            if(m_vecProcesses[m].GetImageName().CompareNoCase(
                L"explorer.exe") == 0)
            {
                fFoundExplorerExe = true;
                break;
            }
            else
            {
                m++;
            }
        }

        if(!fFoundExplorerExe)
        {
            m = 0;
        }

        dwRet = m_vecProcesses[m].GetPID();
    }

    return dwRet;
}



bool CSession::IsSessionIDValid(
        LPCWSTR wstrSessionID)
{
    bool fRet = true;
    
    if(wstrSessionID != NULL &&
        *wstrSessionID != L'\0')
    {
        for(const WCHAR* pwc = wstrSessionID;
            *pwc != NULL && fRet;
            pwc++)
        {
            fRet = iswdigit(*pwc);
        } 
    }
    else
    {
        fRet = false;
    }
            
    return fRet;
}


//*****************************************************************************
// CProcess functions
//*****************************************************************************

CProcess::CProcess() 
  :  m_dwPID(0) 
{
}


CProcess::CProcess(
    DWORD dwPID,
    LPCWSTR wstrImageName)
  :  m_dwPID(dwPID)
{
    m_chstrImageName = wstrImageName;
}


CProcess::CProcess(
    const CProcess& process)
{
    m_dwPID = process.m_dwPID;
    m_chstrImageName = process.m_chstrImageName;
}

CProcess::~CProcess()
{
}


DWORD CProcess::GetPID() const
{
    return m_dwPID;
}

CHString CProcess::GetImageName() const
{
    return m_chstrImageName;
}


void CProcess::Copy(
        CProcess& out) const
{
    out.m_dwPID = m_dwPID;
    out.m_chstrImageName = m_chstrImageName;
}




//*****************************************************************************
// CUser functions
//*****************************************************************************


CUser::CUser(
    PSID pSid)
  :  m_sidUser(NULL),
     m_fValid(false)
{
    if(::IsValidSid(pSid))
    {
        DWORD dwSize = ::GetLengthSid(pSid);
        m_sidUser = NULL;
        m_sidUser = malloc(dwSize);
        if(m_sidUser == NULL)
        {
		    throw CHeap_Exception(
                CHeap_Exception::E_ALLOCATION_ERROR);
        }
        else
        {
	        ::CopySid(
                dwSize, 
                m_sidUser, 
                pSid);

            m_fValid = true;
        }
    }
}



CUser::CUser(
    const CUser& user)
{
    DWORD dwSize = ::GetLengthSid(user.m_sidUser);
    m_sidUser = malloc(dwSize);

    if(m_sidUser == NULL)
    {
		throw CHeap_Exception(
            CHeap_Exception::E_ALLOCATION_ERROR);
    }

	::CopySid(
        dwSize, 
        m_sidUser, 
        user.m_sidUser);

    m_fValid = user.m_fValid;

}



CUser::~CUser()
{
    if(m_sidUser) 
    {
        free(m_sidUser);
        m_sidUser = NULL;
    }
}


bool CUser::IsValid()
{
    return m_fValid;
}


void CUser::Copy(
    CUser& out) const
{
    if(out.m_sidUser) 
    {
        free(out.m_sidUser);
        out.m_sidUser = NULL;
    }

    DWORD dwSize = ::GetLengthSid(m_sidUser);
    out.m_sidUser = malloc(dwSize);

    if(out.m_sidUser == NULL)
    {
		throw CHeap_Exception(
            CHeap_Exception::E_ALLOCATION_ERROR);
    }

	::CopySid(
        dwSize, 
        out.m_sidUser, 
        m_sidUser);

    out.m_fValid = m_fValid;
}


// Implementation lifted from sid.cpp.
void CUser::GetSidString(CHString& str) const
{
    ASSERT_BREAK(m_fValid);

    if(m_fValid)
    {
        // Initialize m_strSid - human readable form of our SID
	    SID_IDENTIFIER_AUTHORITY *psia = NULL;
        psia = ::GetSidIdentifierAuthority( m_sidUser );

	    // We assume that only last byte is used (authorities between 0 and 15).
	    // Correct this if needed.
	    ASSERT_BREAK( psia->Value[0] == psia->Value[1] == 
                      psia->Value[2] == psia->Value[3] == 
                      psia->Value[4] == 0 );

	    DWORD dwTopAuthority = psia->Value[5];

	    str.Format( L"S-1-%u", dwTopAuthority );
	    CHString strSubAuthority;
	    int iSubAuthorityCount = *( GetSidSubAuthorityCount( m_sidUser ) );
	    for ( int i = 0; i < iSubAuthorityCount; i++ ) {

		    DWORD dwSubAuthority = *( GetSidSubAuthority( m_sidUser, i ) );
		    strSubAuthority.Format( L"%u", dwSubAuthority );
		    str += _T("-") + strSubAuthority;
	    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\securitydescriptor.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CSecurityDescriptor.h - header file for CSecurityDescriptor class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSECURITYDESCRIPTOR_H__
#define __CSECURITYDESCRIPTOR_H__



#define ALL_ACCESS_WITHOUT_GENERIC	0x01FFFFFF	// all possible access rights
												// without generic

////////////////////////////////////////////////////////////////
//
//	Class:	CSecurityDescriptor
//
//	This class is intended to provide a wrapper for Windows NT
//	Security Dscriptors.  The idea here is that a client class
//	would inherit from this class, obtain a security descriptor
//	from an as yet to be determined object, and pass said
//	descriptor into this class via InitSecurity(), at which
//	point we will take apart the descriptor and store the
//	data internally.  A user may then change security as needed
//	then call the ApplySecurity() function which will call
//	a couple of virtual functions, WriteAcls() and WriteOwner()
//	that must be implemented by a derived class, supplying
//	said class with an appropriately filled out Win32 Security
//	Descriptor.  Derived classes should also provide an
//	implementation for AllAccessMask() in order to provide
//	a mask specific to the object they are securing, that
//	indicates Full Control access.
//
////////////////////////////////////////////////////////////////

/*
 *	Class CSecurityDescriptor is a helper class. It groups user CSid together with its access mask.
 */ 

class CSecurityDescriptor
{
	// Constructors and destructor
	public:

		CSecurityDescriptor();
		CSecurityDescriptor( PSECURITY_DESCRIPTOR psd );
        CSecurityDescriptor
        (
            CSid* a_psidOwner,
            bool a_fOwnerDefaulted,
            CSid* a_psidGroup,
            bool a_fGroupDefaulted,
            CDACL* a_pDacl,
            bool a_fDaclDefaulted,
            bool a_fDaclAutoInherited,
            CSACL* a_pSacl,
            bool a_fSaclDefaulted,
            bool a_fSaclAutoInherited
        );

		virtual ~CSecurityDescriptor();

		// public entry to specify which attributes to set.
		DWORD ApplySecurity( SECURITY_INFORMATION securityinfo );

		// Allows setting various entries
		DWORD SetOwner( CSid& sid );
		DWORD SetGroup( CSid& sid );
		DWORD SetControl ( PSECURITY_DESCRIPTOR_CONTROL pControl );

        bool AddDACLEntry( CSid& sid, DACL_Types DaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid);
        bool AddSACLEntry( CSid& sid, SACL_Types SaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid);
        
        bool RemoveDACLEntry(  CSid& sid, DACL_Types DaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveDACLEntry(  CSid& sid, DACL_Types DaclType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveDACLEntry(  CSid& sid, DACL_Types DaclType, DWORD dwIndex = 0 );
        bool RemoveSACLEntry(  CSid& sid, SACL_Types SaclType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveSACLEntry(  CSid& sid, SACL_Types SaclType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid );
		bool RemoveSACLEntry(  CSid& sid, SACL_Types SaclType, DWORD dwIndex = 0 );


		// ACE Location methods
		bool FindACE( const CSid& sid, BYTE bACEType, DWORD dwAccessMask, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, CAccessEntry& ace );
		bool FindACE( PSID psid, BYTE bACEType, BYTE bACEFlags, GUID *pguidObjGuid, GUID *pguidInhObjGuid, DWORD dwAccessMask,   CAccessEntry& ace );

		// Empty the ACLs (creates Empty if NULL).
		void EmptyDACL();
		void EmptySACL();

		// Clear (NULL) the ACLs (for DACL, this means a NULL or empty Denied Access,
		// DACL and a single entry of "Everyone", "Full Control" for Allowed Access DACL.

		bool MakeDACLNull();
		bool MakeSACLNull();

		// Checks our DACL objects for a NULL DACL condition
		bool IsNULLDACL();

		// Get owner and ACLs
		void GetOwner( CSid& sid );
		void GetGroup( CSid& sid );
		bool GetDACL( CDACL& DACL );
		bool GetSACL( CSACL& SACL );
		void GetControl ( PSECURITY_DESCRIPTOR_CONTROL pControl );

		// Derived classes should override, and this is called with the appropriate values set
		// Derived classes MUST NOT mess with the values in pAbsoluteSD!
		virtual DWORD WriteOwner( PSECURITY_DESCRIPTOR pAbsoluteSD ) { return E_FAIL; }
		virtual DWORD WriteAcls( PSECURITY_DESCRIPTOR pAbsoluteSD , SECURITY_INFORMATION securityinfo  ) { return E_FAIL; }

        void DumpDescriptor(LPCWSTR wstrFilename = NULL);
		DWORD GetSelfRelativeSD(
				SECURITY_INFORMATION securityinfo, 
				PSECURITY_DESCRIPTOR psd);

	protected:

		BOOL InitSecurity( PSECURITY_DESCRIPTOR psd );

	private:
		CSid*	m_pOwnerSid;
		CSid* 	m_pGroupSid;
		bool	m_fOwnerDefaulted;
        bool    m_fGroupDefaulted;
        bool    m_fDACLDefaulted;
        bool    m_fSACLDefaulted;
        bool    m_fDaclAutoInherited;
        bool    m_fSaclAutoInherited;

        // As of NT5, it is no longer sufficient to just maintain two lists for the dacls, since
        // we now have five, not two, types of ACEs that can go into a DACL. Double that since we
        // have inherited and non-inherited...
		//CDACL*	m_pAccessAllowedDACL;
		//CDACL*	m_pAccessDeniedDACL;
        CDACL* m_pDACL;
		CSACL* m_pSACL;
		SECURITY_DESCRIPTOR_CONTROL m_SecurityDescriptorControl;

		void Clear( void );
		DWORD SecureObject( PSECURITY_DESCRIPTOR pAbsoluteSD, SECURITY_INFORMATION securityinfo );
		BOOL InitDACL( PSECURITY_DESCRIPTOR psd );
		BOOL InitSACL( PSECURITY_DESCRIPTOR psd );
        bool InitDACL( CDACL* a_pDACL );
		bool InitSACL( CSACL* a_pSACL );
		
};

inline void CSecurityDescriptor::GetOwner( CSid& sid )
{
	if ( NULL != m_pOwnerSid )
	{
		sid = *m_pOwnerSid;
	}
}

inline void CSecurityDescriptor::GetGroup( CSid& sid )
{
	if (NULL != m_pGroupSid )
	{
		sid = *m_pGroupSid;
	}
}

inline void CSecurityDescriptor::GetControl ( PSECURITY_DESCRIPTOR_CONTROL pControl )
{
	//pControl = &m_SecurityDescriptorControl;
	
	//changed to copy the Sec. Desc. Control properly
	if(pControl)
	{
		*pControl = m_SecurityDescriptorControl;
	}
	
}

inline DWORD CSecurityDescriptor::SetControl (PSECURITY_DESCRIPTOR_CONTROL pControl )
{
	m_SecurityDescriptorControl = *pControl;
	return (ERROR_SUCCESS);
}

#endif // __CSecurityDescriptor_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\secutils.cpp ===
/*****************************************************************************/



/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /

/*****************************************************************************/



//=================================================================

//

// SecUtils.cpp -- Security utilities useful to wbem mof classes

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
// Revisions:    6/9/99    a-kevhu        Created
//
//=================================================================


#include "precomp.h"
#include <assertbreak.h>
#include "AccessEntry.h"			// CAccessEntry class
#include "AccessEntryList.h"
#include "DACL.h"					// CDACL class
#include "SACL.h"
#include "SecurityDescriptor.h"
#include <accctrl.h>
#include "AccessRights.h"
#include "SecureFile.h"
#include "SecureShare.h"
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	FillTrusteeFromSid
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
void FillTrusteeFromSid (CInstance *pInstance, CSid &sid)
{
	if (pInstance)
	{
		PSID pSid;
		CHString chstrName;
		CHString chstrDomain;
		VARIANT vValue;


		if (sid.IsValid())
		{
			pSid = sid.GetPSid();
			chstrName = sid.GetAccountName();
			chstrDomain = sid.GetDomainName();

			// set the UINT8 array for the pSid
			DWORD dwSidLength = sid.GetLength();
 //			BYTE bByte;
			SAFEARRAY* sa;
			SAFEARRAYBOUND rgsabound[1];
            VariantInit(&vValue);
			rgsabound[0].cElements = dwSidLength;

			PSID pSidTrustee = NULL ;

			rgsabound[0].lLbound = 0;
			sa = SafeArrayCreate(VT_UI1, 1, rgsabound);

 		     // Get a pointer to read the data into
      		SafeArrayAccessData(sa, &pSidTrustee);
      		memcpy(pSidTrustee, pSid, rgsabound[0].cElements);
      		SafeArrayUnaccessData(sa);

			// Put the safearray into a variant, and send it off
			V_VT(&vValue) = VT_UI1 | VT_ARRAY; V_ARRAY(&vValue) = sa;
			pInstance->SetVariant(IDS_Sid, vValue);

			VariantClear(&vValue);

			// fill in the rest of the stuff.
			if(!chstrName.IsEmpty())
			{
				pInstance->SetCHString(IDS_Name, chstrName);
			}

			if(!chstrDomain.IsEmpty())
			{
				pInstance->SetCHString(IDS_Domain, chstrDomain);
			}

            pInstance->SetDWORD(IDS_SidLength, dwSidLength);

            // Fill in the SIDString property...
            pInstance->SetCHString(IDS_SIDString, sid.GetSidString());

		}
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	FillInstanceDACL
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
void FillInstanceDACL(CInstance *pInstance, CDACL &dacl)
{
	CAccessEntry ace;
	SAFEARRAY* saDACL;
	SAFEARRAYBOUND rgsabound[1];
	VARIANT vValue;


	if ( pInstance && !dacl.IsEmpty() )
	{
		// First need merged list...
        CAccessEntryList t_cael;
        if(dacl.GetMergedACL(t_cael))
        {
		    DWORD dwSize;
		    long ix[1];
		    dwSize = t_cael.NumEntries();

            rgsabound[0].cElements = dwSize;
		    rgsabound[0].lLbound = 0;
		    saDACL = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		    ix[0] = 0;

		    ACLPOSITION pos;

		    t_cael.BeginEnum(pos);
		    while (t_cael.GetNext(pos, ace))
		    {
			    CInstancePtr pAce;
	            CInstancePtr pTrustee;
                // now that we have the ACE, let's create a Win32_ACE object so we can
			    // add it to the embedded object list.
			    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Ace", &pAce, IDS_CimWin32Namespace ) ) )
			    {
				    // fill trustee from SID
				    CSid sid;
				    ace.GetSID(sid);
				    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrustee, IDS_CimWin32Namespace )))
				    {

					    FillTrusteeFromSid(pTrustee, sid);
					    pAce->SetEmbeddedObject(IDS_Trustee, *pTrustee);
//					    pTrustee->Release() ;
				    }	// end if

				    DWORD dwAceType = ace.GetACEType();
				    DWORD dwAceFlags = ace.GetACEFlags();
				    DWORD dwAccessMask = ace.GetAccessMask ();

				    pAce->SetDWORD(IDS_AceType, dwAceType);
				    pAce->SetDWORD(IDS_AceFlags, dwAceFlags);
				    pAce->SetDWORD(IDS_AccessMask, dwAccessMask);

#ifdef NTONLY
#if NTONLY > 5
					// fill Guids
                    GUID guidObjType, guidInhObjType;
                    if(ace.GetObjType(guidObjType))
                    {
                        WCHAR wstrGuid[39];
                        if(::StringFromGUID2(&guidObjType, wstrGuid, 39))
                        {
                            pAce->SetWCHARSplat(IDS_GuidObjectType, wstrGuid);
                        }
                    }

                    if(ace.GetInhObjType(guidInhObjType))
                    {
                        WCHAR wstrGuid[39];
                        if(::StringFromGUID2(&guidInhObjType, wstrGuid, 39))
                        {
                            pAce->SetWCHARSplat(IDS_GuidInheritedObjectType, wstrGuid);
                        }
                    }
#endif
#endif

				    // Get the IUnknown of the Win32_ACE object.   Convert it to a
				    // variant of type VT_UNKNOWN.  Then, add the variant to the
				    // SafeArray.   Eventually, to add the list to the actual
				    // Win32_SecurityDescriptor object, we will be using SetVariant.
                    // Note: it is intentional that we are not decrementing the Addref
                    // done on pAce by the following call.
				    IWbemClassObjectPtr pClassObject(pAce->GetClassObjectInterface());
				    if ( pClassObject )
				    {

					    VARIANT v;
					    VariantInit(&v);

					    v.vt   = VT_UNKNOWN;
					    v.punkVal = pClassObject ;


					    SafeArrayPutElement(saDACL, ix, pClassObject);

					    VariantClear(&v);
				    }	// end if
			    }	// end if

			    ix[0]++ ;
		    }	// end while
            VariantInit(&vValue);
		    V_VT(&vValue) = VT_UNKNOWN | VT_ARRAY; V_ARRAY(&vValue) = saDACL;
		    pInstance->SetVariant(IDS_DACL, vValue);
		    VariantClear(&vValue);
		    t_cael.EndEnum(pos);
        }
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	FillInstanceSACL
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
void FillInstanceSACL(CInstance *pInstance, CSACL &sacl)
{
	CAccessEntry ace;
	CInstancePtr pAce;
	CInstancePtr pTrustee;
	SAFEARRAY* saSACL;
	SAFEARRAYBOUND rgsabound[1];
	VARIANT vValue;


	if ( pInstance && !sacl.IsEmpty() )
	{
        // First need merged list...
        CAccessEntryList t_cael;
        if(sacl.GetMergedACL(t_cael))
        {
		    DWORD dwSize;
		    long ix[1];
		    dwSize = t_cael.NumEntries();

		    rgsabound[0].cElements = dwSize;
		    rgsabound[0].lLbound = 0;
		    saSACL = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
		    ix[0] = 0;

		    ACLPOSITION pos;

		    t_cael.BeginEnum(pos);
		    while (t_cael.GetNext(pos, ace))
		    {
			    // now that we have the ACE, let's create a Win32_ACE object so we can
			    // add it to the embedded object list.
			    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Ace", &pAce, IDS_CimWin32Namespace)))
			    {
				    // fill trustee from SID
				    CSid sid;
				    ace.GetSID(sid);
				    if (SUCCEEDED(CWbemProviderGlue::GetEmptyInstance(pInstance->GetMethodContext(), L"Win32_Trustee", &pTrustee, IDS_CimWin32Namespace )))
				    {

					    FillTrusteeFromSid(pTrustee, sid);
					    pAce->SetEmbeddedObject(IDS_Trustee, *pTrustee);
				    }	// end if

				    DWORD dwAceType = ace.GetACEType();
				    DWORD dwAceFlags = ace.GetACEFlags();
				    DWORD dwAccessMask = ace.GetAccessMask ();

				    pAce->SetDWORD(IDS_AceType, dwAceType);
				    pAce->SetDWORD(IDS_AceFlags, dwAceFlags);
				    pAce->SetDWORD(IDS_AccessMask, dwAccessMask);

#ifdef NTONLY
#if NTONLY > 5
					// fill Guids
                    GUID guidObjType, guidInhObjType;
                    if(ace.GetObjType(guidObjType))
                    {
                        WCHAR wstrGuid[39];
                        if(::StringFromGUID2(&guidObjType, wstrGuid, 39))
                        {
                            pAce->SetWCHARSplat(IDS_GuidObjectType, wstrGuid);
                        }
                    }

                    if(ace.GetInhObjType(guidInhObjType))
                    {
                        WCHAR wstrGuid[39];
                        if(::StringFromGUID2(&guidInhObjType, wstrGuid, 39))
                        {
                            pAce->SetWCHARSplat(IDS_GuidInheritedObjectType, wstrGuid);
                        }
                    }
#endif
#endif

				    // Get the IUnknown of the Win32_ACE object.   Convert it to a
				    // variant of type VT_UNKNOWN.  Then, add the variant to the
				    // SafeArray.   Eventually, to add the list to the actual
				    // Win32_SecurityDescriptor object, we will be using SetVariant
				    IWbemClassObjectPtr pClassObject(pAce->GetClassObjectInterface());
				    if ( pClassObject )
				    {

					    VARIANT v;
					    VariantInit(&v);

					    v.vt   = VT_UNKNOWN;
					    v.punkVal = pClassObject ;


					    SafeArrayPutElement(saSACL, ix, pClassObject);

					    VariantClear(&v);
				    }	// end if
			    }	// end if
			    ix[0]++ ;
		    }	// end while
            VariantInit(&vValue);
		    V_VT(&vValue) = VT_UNKNOWN | VT_ARRAY; V_ARRAY(&vValue) = saSACL;
		    pInstance->SetVariant(IDS_SACL, vValue);
		    VariantClear(&vValue);
		    t_cael.EndEnum(pos);
        }
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	FillDACLFromInstance
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD FillDACLFromInstance(CInstance *pInstance,
                           CDACL &dacl,
                           MethodContext *pMethodContext)
{
	IWbemClassObjectPtr piClassObject;
    piClassObject.Attach(pInstance->GetClassObjectInterface());
	DWORD dwStatus = ERROR_SUCCESS ;

	if(piClassObject)
	{
		VARIANT vDacl ;
		if(GetArray(piClassObject,IDS_DACL, vDacl, VT_UNKNOWN|VT_ARRAY) )
		{

			if( vDacl.vt != VT_NULL && vDacl.parray != NULL )
			{
				// walk DACL
				LONG lDimension = 1 ;
				LONG lLowerBound ;
				SafeArrayGetLBound ( vDacl.parray , lDimension , &lLowerBound ) ;
				LONG lUpperBound ;
				SafeArrayGetUBound ( vDacl.parray , lDimension , &lUpperBound ) ;

				for ( LONG lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex++ )
				{
					if( dwStatus != ERROR_SUCCESS )
					{
						break ;
					}
					IWbemClassObjectPtr pACEObject;
					SafeArrayGetElement ( vDacl.parray , &lIndex , &pACEObject ) ;
					// take out IWbemClassObject and cast it to a Win32_ACE object.
					if(pACEObject)
					{
						CInstance ACEInstance(pACEObject, pMethodContext);

						// create an AccessEntry object from the Win32_ACE object.

						bool bExists =false ;
						VARTYPE eType ;
						// get Win32_Trustee object from Win32_ACE ...& decipher the ACE
						if ( ACEInstance.GetStatus ( IDS_Trustee, bExists , eType ) && bExists && eType == VT_UNKNOWN )
						{
							CInstancePtr pTrustee;
							if ( ACEInstance.GetEmbeddedObject ( IDS_Trustee, &pTrustee, ACEInstance.GetMethodContext() ) )
							{
								CSid sid ;
								if((dwStatus = FillSIDFromTrustee(pTrustee, sid)) == ERROR_SUCCESS)
								{
									DWORD dwAceType, dwAceFlags, dwAccessMask ;
                                    CHString chstrInhObjGuid;
                                    GUID *pguidInhObjGuid = NULL;
                                    CHString chstrObjGuid;
                                    GUID *pguidObjGuid = NULL;

									ACEInstance.GetDWORD(IDS_AceType, dwAceType);
									ACEInstance.GetDWORD(IDS_AceFlags, dwAceFlags);
									ACEInstance.GetDWORD(IDS_AccessMask, dwAccessMask);

                                    // The OS doesn't seem to support 0x01000000 or 0x02000000, so we won't either.  We
                                    // will translate 0x02000000 into FILE_ALL_ACCESS, however (seems like the nice thing to do)
                                    // but only if that is the exact value they set.
                                    if(dwAccessMask == 0x02000000)
                                    {
                                        dwAccessMask = FILE_ALL_ACCESS;
                                    }

#if NTONLY >= 5
                                    // On NT5 and greater, if the user specified an ACE with the Ace Flag bit INHERIT_ACE set,
                                    // the OS will make these local, not inherited ACE entries.  However, the OS will not reorder
                                    // the DACL, possibly resulting in a situation in which denied ACEs (that had been inherited)
                                    // follow allowed ACEs.

                                    // So if the Ace flags specify INHERITED_ACE, we need to turn
                                    // off this bit...
                                    dwAceFlags &= ~INHERITED_ACE;
#endif
                                    if(!(dwAceFlags & INHERITED_ACE))
                                    {
									    switch (dwAceType)
									    {
									    case ACCESS_DENIED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_DENIED_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
											    break;
										    }
									    case ACCESS_ALLOWED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
											    break;
										    }
#if NTONLY >= 5
                                        // Not yet supported under W2K
                                        //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
										//    {
										//	    dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_COMPOUND_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
										//	    break;
										//    }
                                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                                {
                                                    if(chstrObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidObjGuid != NULL)
                                                            {
                                                                delete pguidObjGuid;
                                                                pguidObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                    }
                                                }
                                                if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                                {
                                                    if(chstrInhObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidInhObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidInhObjGuid != NULL)
                                                            {
                                                                delete pguidInhObjGuid;
                                                                pguidInhObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                    }
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_DENIED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid);
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
											    break;
										    }
                                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
										    {
                                                // Need to get the guids for this type...
                                                if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                                {
                                                    if(chstrObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidObjGuid != NULL)
                                                            {
                                                                delete pguidObjGuid;
                                                                pguidObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                    }
                                                }
                                                if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                                {
                                                    if(chstrInhObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidInhObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidInhObjGuid != NULL)
                                                            {
                                                                delete pguidInhObjGuid;
                                                                pguidInhObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                    }
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_ACCESS_ALLOWED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid);
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
											    break;
										    }
#endif
									    default:
										    {
											    dwStatus = ERROR_INVALID_PARAMETER ;
											    break ;
										    }
									    }
                                    }
                                    else
                                    {
                                        switch (dwAceType)
									    {
									    case ACCESS_DENIED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_DENIED_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
											    break;
										    }
									    case ACCESS_ALLOWED_ACE_TYPE:
										    {
											    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
											    break;
										    }
#if NTONLY >= 5
                                        // Not yet supported under W2K
                                        //case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
										//    {
										//	    dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_COMPOUND_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
										//	    break;
										//    }
                                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                                {
                                                    if(chstrObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidObjGuid != NULL)
                                                            {
                                                                delete pguidObjGuid;
                                                                pguidObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                    }
                                                }
                                                if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                                {
                                                    if(chstrInhObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidInhObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidInhObjGuid != NULL)
                                                            {
                                                                delete pguidInhObjGuid;
                                                                pguidInhObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                    }
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_DENIED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
											    break;
										    }
                                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
										    {
											    // Need to get the guids for this type...
                                                if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                                {
                                                    if(chstrObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidObjGuid != NULL)
                                                            {
                                                                delete pguidObjGuid;
                                                                pguidObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                    }
                                                }
                                                if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                                {
                                                    if(chstrInhObjGuid.GetLength() != 0)
                                                    {
                                                        try
                                                        {
                                                            pguidInhObjGuid = new GUID;
                                                        }
                                                        catch(...)
                                                        {
                                                            if(pguidInhObjGuid != NULL)
                                                            {
                                                                delete pguidInhObjGuid;
                                                                pguidInhObjGuid = NULL;
                                                            }
                                                        }
                                                        CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                    }
                                                }
                                                dacl.AddDACLEntry( sid.GetPSid(), ENUM_INH_ACCESS_ALLOWED_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                                if(pguidObjGuid != NULL) delete pguidObjGuid;
                                                if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
											    break;
										    }
#endif
									    default:
										    {
											    dwStatus = ERROR_INVALID_PARAMETER ;
											    break ;
										    }
									    }
                                    }
								}
                                else
				                {
                                    dwStatus = ERROR_INVALID_PARAMETER;
				                }

                                //pTrustee->Release();  // smartpointer already releases when goes out of scope
							}
						}  // get Win32_Trustee object from Win32_ACE ...& decipher the ACE
					}
				} // end for loop
                if(lLowerBound == 0 && lUpperBound == -1L)
                {
                    // DACL was EMPTY - not necessarily wrong
                    dwStatus = STATUS_EMPTY_DACL;
                }
			}
			VariantClear( &vDacl ) ;
		}
		else //DACL was NULL - not nescessarily wrong.
		{
			 dwStatus = STATUS_NULL_DACL ;
		}
	}
	return dwStatus ;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	FillSACLFromInstance
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD FillSACLFromInstance(CInstance *pInstance,
                           CSACL &sacl,
                           MethodContext *pMethodContext)
{
	IWbemClassObjectPtr piClassObject;
    piClassObject.Attach(pInstance->GetClassObjectInterface());
	DWORD dwStatus = ERROR_SUCCESS ;

	if(piClassObject)
	{
		VARIANT vSacl ;
		if(GetArray(piClassObject, IDS_SACL, vSacl, VT_UNKNOWN|VT_ARRAY ) )
		{

			if( vSacl.vt != VT_NULL && vSacl.parray != NULL )
			{

				// walk DACL
				LONG lDimension = 1 ;
				LONG lLowerBound ;
				SafeArrayGetLBound ( vSacl.parray , lDimension , &lLowerBound ) ;
				LONG lUpperBound ;
				SafeArrayGetUBound ( vSacl.parray , lDimension , &lUpperBound ) ;

				for ( LONG lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex++ )
				{
					if( dwStatus != ERROR_SUCCESS )
					{
						break ;
					}
					IWbemClassObjectPtr pACEObject;
					SafeArrayGetElement ( vSacl.parray , &lIndex , &pACEObject ) ;
					// take out IWbemClassObject and cast it to a Win32_ACE object.
					if(pACEObject)
					{
						CInstance ACEInstance(pACEObject, pMethodContext);

						// create an AccessEntry object from the Win32_ACE object.

						bool bExists =false ;
						VARTYPE eType ;
						// get Win32_Trustee object from Win32_ACE ...& decipher the ACE
						if ( ACEInstance.GetStatus ( IDS_Trustee, bExists , eType ) && bExists && eType == VT_UNKNOWN )
						{

							CInstancePtr pTrustee;
							if ( ACEInstance.GetEmbeddedObject ( IDS_Trustee, &pTrustee, ACEInstance.GetMethodContext() ) )
							{

								CSid sid ;
								if(FillSIDFromTrustee(pTrustee, sid) == ERROR_SUCCESS)
								{

									DWORD dwAceType, dwAceFlags, dwAccessMask ;
                                    CHString chstrInhObjGuid;
                                    GUID *pguidInhObjGuid = NULL;
                                    CHString chstrObjGuid;
                                    GUID *pguidObjGuid = NULL;

									ACEInstance.GetDWORD(IDS_AceType, dwAceType);
									ACEInstance.GetDWORD(IDS_AceFlags, dwAceFlags);
									ACEInstance.GetDWORD(IDS_AccessMask, dwAccessMask);

									switch(dwAceType)
									{
                                    case SYSTEM_AUDIT_ACE_TYPE:
									    {
										    sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_AUDIT_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
                                            break;
									    }
#if NTONLY >= 5
                                    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
									    {
										    // Need to get the guids for this type...
                                            if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                            {
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                            }
                                            if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                            {
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                            }
                                            sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_AUDIT_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            if(pguidObjGuid != NULL) delete pguidObjGuid;
                                            if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************
                                    case SYSTEM_ALARM_ACE_TYPE:
									    {
										    sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_ALARM_ACE_TYPE, dwAccessMask, dwAceFlags, NULL, NULL );
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************

/********************************* type not yet supported under w2k ********************************************
                                    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
									    {
										    // Need to get the guids for this type...
                                            if(!ACEInstance.IsNull(IDS_ObjectTypeGUID) && ACEInstance.GetCHString(IDS_ObjectTypeGUID, chstrObjGuid))
                                            {
                                                if(chstrObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidObjGuid != NULL)
                                                        {
                                                            delete pguidObjGuid;
                                                            pguidObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrObjGuid, pguidObjGuid);
                                                }
                                            }
                                            if(!ACEInstance.IsNull(IDS_InheritedObjectGUID) && ACEInstance.GetCHString(IDS_InheritedObjectGUID, chstrInhObjGuid))
                                            {
                                                if(chstrInhObjGuid.GetLength() != 0)
                                                {
                                                    try
                                                    {
                                                        pguidInhObjGuid = new GUID;
                                                    }
                                                    catch(...)
                                                    {
                                                        if(pguidInhObjGuid != NULL)
                                                        {
                                                            delete pguidInhObjGuid;
                                                            pguidInhObjGuid = NULL;
                                                        }
                                                    }
                                                    CLSIDFromString((LPWSTR)(LPCWSTR)chstrInhObjGuid, pguidInhObjGuid);
                                                }
                                            }
                                            sacl.AddSACLEntry( sid.GetPSid(), ENUM_SYSTEM_ALARM_OBJECT_ACE_TYPE, dwAccessMask, dwAceFlags, pguidObjGuid, pguidInhObjGuid );
                                            if(pguidObjGuid != NULL) delete pguidObjGuid;
                                            if(pguidInhObjGuid != NULL) delete pguidInhObjGuid;
                                            break;
									    }
/********************************* type not yet supported under w2k ********************************************/

#endif
									default:
									    {
										    dwStatus = ERROR_INVALID_PARAMETER ;
                                            break;
									    }
                                    }
								}
                                else
				                {
                                    dwStatus = ERROR_INVALID_PARAMETER;
				                }
                                //pTrustee->Release(); // smartpointer already releases when goes out of scope
							}

						}  // get Win32_Trustee object from Win32_ACE ...& decipher the ACE

					} //if(pACEObject)

				} //for
			}	//if(pSACL)

			VariantClear( &vSacl ) ;
		}
		else
		{
			dwStatus = ERROR_INVALID_PARAMETER ;
		}

	}

	return dwStatus ;
}

bool GetArray(IWbemClassObject *piClassObject,
              const CHString &name,
              VARIANT &v,
              VARTYPE eVariantType)
{
	bool bRet = FALSE;
	VariantInit(&v);

	if (piClassObject)
	{
		BSTR pName = NULL;
		HRESULT hr;
        try
        {
            pName = name.AllocSysString();


		    hr = piClassObject->Get(pName, 0, &v, NULL, NULL);
		    SysFreeString(pName);
        }
        catch(...)
        {
            if(pName != NULL)
            {
                SysFreeString(pName);
                pName = NULL;
            }
            throw;
        }

		ASSERT_BREAK((SUCCEEDED(hr)) && ((v.vt == VT_NULL) || (v.vt == eVariantType )));

		if (bRet = (bool)SUCCEEDED(hr))
		{
			if ( v.vt != VT_NULL && v.parray != NULL )
			{
                if (v.vt == eVariantType )
                {
					bRet = TRUE ;
                }
                else
                {
                    bRet = FALSE;
                }
			}
			else
			{
				bRet = FALSE;
			}
		}
	}


	if (!bRet)
	{
		VariantClear(&v);
	}

	return bRet;
}


DWORD FillSIDFromTrustee(CInstance *pTrustee, CSid &sid)
{
	IWbemClassObjectPtr m_piClassObject;
    DWORD dwStatus = ERROR_SUCCESS ;

    if(pTrustee)
    {
        m_piClassObject.Attach(pTrustee->GetClassObjectInterface());

	    VARIANT vtmp ;
        bool fSidObtained = false;
    
	    if(GetArray(m_piClassObject,IDS_SID,  vtmp, VT_UI1|VT_ARRAY ) )
	    {
		    if( vtmp.vt != VT_NULL && vtmp.parray != NULL )
		    {
			    if ( ::SafeArrayGetDim ( vtmp.parray ) == 1 )
			    {
				    long lLowerBound , lUpperBound = 0 ;

				    ::SafeArrayGetLBound ( vtmp.parray, 1, & lLowerBound ) ;
				    ::SafeArrayGetUBound ( vtmp.parray, 1, & lUpperBound ) ;

				    PSID pSid = NULL ;
				    PVOID pTmp = NULL ;
				    if(SUCCEEDED(::SafeArrayAccessData(vtmp.parray, &pTmp) ) )
				    {
					    pSid = (PSID) malloc(lUpperBound - lLowerBound + 1) ;
                        if(pSid)
                        {
                            try
                            {
					            memcpy(pSid,pTmp,lUpperBound - lLowerBound + 1) ;
					            ::SafeArrayUnaccessData(vtmp.parray) ;
					            sid = CSid(pSid);
					            free(pSid) ;
                                pSid = NULL;
                                fSidObtained = true;
                            }
                            catch(...)
                            {
                                free(pSid) ;
                                pSid = NULL;
                                throw;
                            }
                        }
                        else
                        {
                            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                        }
				    }
				    else
				    {
					    dwStatus = ERROR_INVALID_PARAMETER ;
				    }
			    }
			    else
			    {
				    dwStatus = ERROR_INVALID_PARAMETER ;
			    }
		    }
		    ::VariantClear( &vtmp ) ;
	    }
	    
        if(!fSidObtained && (dwStatus == ERROR_SUCCESS))
        {
            // If we couldn't obtain the sid from the binary
            // representation, try to do so from the sid string
            // representation (the SIDString property)...
            CHString chstrSIDString;

            if(pTrustee->GetCHString(IDS_SIDString, chstrSIDString) &&
                chstrSIDString.GetLength() > 0)
            {    
                PSID pSid = NULL;
                pSid = StrToSID(chstrSIDString);
                if(pSid)
                {
                    try
                    {
                        sid = CSid(pSid);
					    ::FreeSid(pSid); 
                        pSid = NULL;
                        fSidObtained = true;
                    }
                    catch(...)
                    {
                        ::FreeSid(pSid); 
                        pSid = NULL;
                        throw;
                    }
                }
                else
                {
                    dwStatus = ERROR_INVALID_PARAMETER;
                }
            }

            // If we couldn't obtain the sid from either the binary
            // representation or the SIDString representation, try to 
            // do so from the Domain and Name properties (attempting
            // resolution on the local machine for lack of a better
            // choice)...
            if(!fSidObtained && (dwStatus == ERROR_SUCCESS))
            {
                CHString chstrDomain, chstrName;

                pTrustee->GetCHString(IDS_Domain, chstrDomain);

                // Although we don't care whether we were able
                // to get the Domain above, we must at least have
                // a Name property specified...
                if(pTrustee->GetCHString(IDS_Name, chstrName) &&
                    chstrName.GetLength() > 0)
                {
                    CSid csTmp(chstrDomain, chstrName, NULL);
                    if(csTmp.IsOK() && csTmp.IsValid())
                    {
                        sid = csTmp;
                        fSidObtained = true;
                    }
                }
            }
        }

        if(!fSidObtained && (dwStatus == ERROR_SUCCESS))
	    {
		    dwStatus = ERROR_INVALID_PARAMETER ;
	    }
    }
    else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

	return dwStatus ;
}

#ifdef NTONLY
// Handy utility to dump the contents of a descriptor to
// our log file.
void DumpWin32Descriptor(PSECURITY_DESCRIPTOR psd, LPCWSTR wstrFilename)
{
    CSecurityDescriptor csd(psd);
    csd.DumpDescriptor();
}
#endif

#ifdef NTONLY
void Output(LPCWSTR wstrOut, LPCWSTR wstrFilename)
{
    // Single point where we can control where output from
    // all security utility class Dump routines goes...
    if(wstrFilename == NULL)
    {
        LogMessage(wstrOut);
    }
    else
    {
        FILE *fp = NULL;
        if((fp = _wfopen(wstrFilename, L"at")) != NULL)
        {
            fwprintf(fp, wstrOut);
            fwprintf(fp,L"\r\n");
			fclose(fp);
        }
        fp = NULL;
    }
}
#endif


// Returns true if the user associated with the current
// thread is either the owner or is a member of the group
// that is the owner - e.g., it returns true if said user
// has ownership of the object specified by chstrName.
#ifdef NTONLY
bool AmIAnOwner(const CHString &chstrName, SE_OBJECT_TYPE ObjectType)
{
    bool fRet = false;

    // ALGORITHM OVERVIEW
    // 1) Get the sid of the user associated with the current thread.

    // 2) Get the owner of the object.

    // 3a) Compare the sid from #2 to that from #1.  fRet is true if they are equal.

    // 3b) If not, owner's sid may be that of a group, and the user might be a
    //     member of that group, or of a group (which would have to be a global group)
    //     within that group.  Fortunately that doesnt't recurse indefinitely, since
    //     local groups can contain only global groups, and global groups can contain
    //     only users (they can't be a container for other global or local groups) - see
    //     "Windows NT Security" (Nik Okuntseff), pp. 34-35.

    // So here we go...


    // 1) Get the sid of the user associated with the current thread.  Also filter out only object types we are equiped to deal with...
    if(ObjectType == SE_FILE_OBJECT || ObjectType == SE_LMSHARE)
    {
        CAccessRights car(true);    // true tells car to use the user associated with the current thread token
        CSid csidCurrentUser;
        if(car.GetCSid(csidCurrentUser, true)) // true signals that we want car to be initialized with the domain and name looked up
        {
        // 2) Get the owner of the object.
            CSid csidOwner;
            switch(ObjectType)
            {
                case SE_FILE_OBJECT:
                {
                    CSecureFile csf;
                    if(csf.SetFileName(chstrName, FALSE) == ERROR_SUCCESS) //FALSE means we don't need the SACL
                    {
                        csf.GetOwner(csidOwner);
                    }
                    break;
                }
                case SE_LMSHARE:
                {
                    CSecureShare css;
                    if(css.SetShareName(chstrName) == ERROR_SUCCESS)
                    {
                        css.GetOwner(csidOwner);
                    }
                    break;
                }
                default:
                {
                    ASSERT_BREAK(0);
                }
            }

            //  Proceed as long as the owner sid is valid and 'ok'...
            if(csidOwner.IsValid() && csidOwner.IsOK())
            {
                // 3a) Compare the sid from #2 to that from #1.  fRet is true if they are equal.
                if(csidCurrentUser == csidOwner)
                {
                    fRet = true;
                }
                else // owner might be a group...
                {
                    // 3b) If not, owner's sid may be that of a group, and the user might be a
                    //     member of that group, or of a group (which would have to be a global group)
                    //     within that group.  Fortunately that doesnt't recurse indefinitely, since
                    //     local groups can contain only global groups, and global groups can contain
                    //     only users (they can't be a container for other global or local groups) - see
                    //     "Windows NT Security" (Nik Okuntseff), pp. 34-35.

                    // Since this could be a pain, call a friendly helper...
                    SID_NAME_USE snuOwner = csidOwner.GetAccountType();
                    if(snuOwner == SidTypeGroup || snuOwner == SidTypeAlias || snuOwner == SidTypeWellKnownGroup)
                    {
                        if(IsUserInGroup(csidCurrentUser, csidOwner, snuOwner))
                        {
                            fRet = true;
                        }
                    }
                }
            }
        }  // we got the thread sid
    } // its an object we like

    return fRet;
}
#endif


// Helper to determine if a particular is a member of a group, or of one of the
// (global) groups that might be a member of that group.
#ifdef NTONLY
bool IsUserInGroup(const CSid &csidUser,
                   const CSid &csidGroup,
                   SID_NAME_USE snuGroup)
{
    bool fRet = false;
    CNetAPI32 netapi ;
    if(netapi.Init() == ERROR_SUCCESS)
    {
        fRet = RecursiveFindUserInGroup(netapi,
                                        csidGroup.GetDomainName(),
                                        csidGroup.GetAccountName(),
                                        snuGroup,
                                        csidUser);
    }
    return fRet;
}
#endif



#ifdef NTONLY
bool RecursiveFindUserInGroup(CNetAPI32 &netapi,
                              const CHString &chstrDomainName,
                              const CHString &chstrGroupName,
                              SID_NAME_USE snuGroup,
                              const CSid &csidUser)
{
    bool fRet = false;
    NET_API_STATUS stat;
    DWORD dwNumReturnedEntries = 0, dwIndex = 0, dwTotalEntries = 0;
	DWORD_PTR dwptrResume = NULL;

    // Domain Groups
    if (snuGroup == SidTypeGroup)
    {
        GROUP_USERS_INFO_0 *pGroupMemberData = NULL;
        CHString chstrDCName;
        if (netapi.GetDCName(chstrDomainName, chstrDCName) == ERROR_SUCCESS)
        {
            do
            {
                // Accept up to 256k worth of data.
                stat = netapi.NetGroupGetUsers(chstrDCName,
                                               chstrGroupName,
                                               0,
                                               (LPBYTE *)&pGroupMemberData,
                                               262144,
                                               &dwNumReturnedEntries,
                                               &dwTotalEntries,
                                               &dwptrResume);

                // If we got some data
                if(ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat)
                {
                    try
                    {
                        // Walk through all the returned entries...
                        for(DWORD dwCtr = 0; dwCtr < dwNumReturnedEntries; dwCtr++)
                        {
                            // Get the sid type for this object...
                            CSid sid(chstrDomainName, CHString(pGroupMemberData[dwCtr].grui0_name), NULL);
                            if(sid == csidUser)
                            {
                                fRet = true;
                            }
                        }
                    }
                    catch ( ... )
                    {
                        netapi.NetApiBufferFree( pGroupMemberData );
                        throw ;
                    }
                    netapi.NetApiBufferFree( pGroupMemberData );
                }	// IF stat OK

            } while ( ERROR_MORE_DATA == stat && !fRet);
        }

    // Local Groups
    }
    else if(snuGroup == SidTypeAlias || snuGroup == SidTypeWellKnownGroup)
    {
        LOCALGROUP_MEMBERS_INFO_1 *pGroupMemberData = NULL;
        do
        {
            // Accept up to 256k worth of data.
            stat = netapi.NetLocalGroupGetMembers(NULL,
                                                  chstrGroupName,
                                                  1,
                                                  (LPBYTE *)&pGroupMemberData,
                                                  262144,
                                                  &dwNumReturnedEntries,
                                                  &dwTotalEntries,
                                                  &dwptrResume);

            // If we got some data
            if ( ERROR_SUCCESS == stat || ERROR_MORE_DATA == stat )
            {
                try
                {
                    // Walk through all the returned entries
                    for(DWORD dwCtr = 0; dwCtr < dwNumReturnedEntries && !fRet; dwCtr++)
                    {
                        // If this is a recognized type...
                        CSid sid(pGroupMemberData[dwCtr].lgrmi1_sid);

                        switch(pGroupMemberData[dwCtr].lgrmi1_sidusage)
                        {
                            case SidTypeUser:
                            {
                                if(sid == csidUser)
                                {
                                    fRet = true;
                                }
                                break;
                            }
                            case SidTypeGroup:
                            {
                                // If the group contained a group (would be a global group),
                                // we need to recurse.
                                fRet = RecursiveFindUserInGroup(netapi,
                                                                sid.GetDomainName(),
                                                                sid.GetAccountName(),
                                                                pGroupMemberData[dwCtr].lgrmi1_sidusage,
                                                                csidUser);
                                break;
                            }
                            case SidTypeWellKnownGroup:
                            {
                                // If the group contained a group (would be a global group),
                                // we need to recurse.
                                fRet = RecursiveFindUserInGroup(netapi,
                                                                sid.GetDomainName(),
                                                                sid.GetAccountName(),
                                                                pGroupMemberData[dwCtr].lgrmi1_sidusage,
                                                                csidUser);
                                break;
                            }
                            default:
                            {
                                ASSERT_BREAK(0);
                                break;
                            }
                        }
                    }
                }
                catch ( ... )
                {
                    netapi.NetApiBufferFree( pGroupMemberData );
                    throw ;
                }

                netapi.NetApiBufferFree( pGroupMemberData );
            }	// IF stat OK
        } while ( ERROR_MORE_DATA == stat && !fRet);
    }
	else
    {
        // Unrecognized Group type
        ASSERT_BREAK(0);
    }
    return fRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\sid.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CSid.cpp - implementation file for CSid class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include <assertbreak.h>
#include <CreateMutexAsProcess.h>
#include "Sid.h"
#include <comdef.h>
#include <accctrl.h>
#include "wbemnetapi32.h"
#include "SecUtils.h"

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Default class constructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::CSid( void )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class constructor.
//
//	Inputs:
//				PSID		pSid - SID to validate and get account
//							info for.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::CSid( PSID pSid, LPCTSTR pszComputerName )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    InitFromSid( pSid, pszComputerName );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Initializes the object from a PSid, with an indicator as to whether
//  we should lookup and initialize the associated domain and account.
//
//	Inputs:
//				PSID		pSid - PSid to look up.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//              bool        fLookup - indicates whether to determine
//                          the domain and account associated with
//                          the sid at this time.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if OK.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
CSid::CSid( PSID pSid, LPCTSTR pszComputerName, bool fLookup )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    InitFromSid(pSid, pszComputerName, fLookup);
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class constructor.
//
//	Inputs:
//				LPCTSTR		pszAccountName - Account name to validate
//							and obtain info for.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::CSid( LPCTSTR pszAccountName, LPCTSTR pszComputerName )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    InitFromAccountName( pszAccountName, pszComputerName );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class constructor.
//
//	Inputs:
//				LPCTSTR		pszDomainName - Domain to combine with
//							account name.
//				LPCTSTR		pszName - Name to combine with domain.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	This flavor of the constructor combines a domain and account
//	name in "DOMAIN\NAME" format and then initializes our data
//	from there.
//
///////////////////////////////////////////////////////////////////

CSid::CSid( LPCTSTR pszDomainName, LPCTSTR pszName, LPCTSTR pszComputerName )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    CHString	strName;

	if ( NULL == pszDomainName || *pszDomainName == '\0' )
	{
		strName = pszName;
	}
	else
	{
		strName = pszDomainName;
		strName += '\\';
		strName += pszName;
	}

	InitFromAccountName(TOBSTRT(strName), pszComputerName );
}

#ifndef UNICODE
///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class constructor - this is used for wide char support when
//                      UNICODE is not defined.
//
//	Inputs:
//				LPCWSTR		wstrDomainName - Domain to combine with
//							account name.
//				LPCWSTR		wstrName - Name to combine with domain.
//				LPCWSTR		wstrComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	This flavor of the constructor combines a domain and account
//	name in "DOMAIN\NAME" format and then initializes our data
//	from there.  Again, this is used for wide char support when
//  UNICODE is not defined.
//
///////////////////////////////////////////////////////////////////

CSid::CSid(LPCWSTR wstrDomainName, LPCWSTR wstrName, LPCWSTR wstrComputerName)
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    LONG lTempNameLen = 0L;
    if(wstrDomainName==NULL && wstrName!=NULL)
    {
        lTempNameLen = wcslen(wstrName)+2;
    }
    else if(wstrDomainName!=NULL && wstrName==NULL)
    {
        lTempNameLen = wcslen(wstrDomainName)+2;
    }
    else if(wstrDomainName!=NULL && wstrName!=NULL)
    {
        lTempNameLen = wcslen(wstrName)+wcslen(wstrDomainName)+2;
    }

	WCHAR* wstrTempName = NULL;
    try
    {
        wstrTempName = (WCHAR*) new WCHAR[lTempNameLen];
        if(wstrTempName == NULL)
        {
            m_dwLastError = ::GetLastError();
        }
        else
        {
            ZeroMemory(wstrTempName,lTempNameLen * sizeof(WCHAR));
	        if ( NULL == wstrDomainName || *wstrDomainName == '\0' )
	        {
		        wcscpy(wstrTempName,wstrName);
	        }
	        else
	        {
		        wcscpy(wstrTempName,wstrDomainName);
                wcscat(wstrTempName,L"\\");
                if(wstrName!=NULL)
                {
                    wcscat(wstrTempName,wstrName);
                }
	        }
	        InitFromAccountNameW(wstrTempName, wstrComputerName);
            delete wstrTempName;
        }
    }
    catch(...)
    {
        if(wstrTempName != NULL)
        {
            delete wstrTempName;
            wstrTempName = NULL;
        }
        throw;
    }
}
#endif


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::CSid
//
//	Class copy constructor.
//
//	Inputs:
//				const CSid	r_Sid - CSid to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::CSid( const CSid &r_Sid )
:	m_pSid( NULL ),
	m_snuAccountType( SidTypeUnknown ),
	m_dwLastError( ERROR_SUCCESS )
{
    // Handle WINNT SID pointer first

	// pSid should be valid...
	ASSERT_BREAK( r_Sid.IsValid() );

	// Allocate a new SID and copy data into it.
	DWORD dwSize = ::GetLengthSid( r_Sid.m_pSid );
    m_pSid = malloc( dwSize );
    if (m_pSid != NULL)
    {
	    try
        {
	        BOOL bResult = ::CopySid( dwSize, m_pSid, r_Sid.m_pSid );
	        ASSERT_BREAK( bResult );

	        // Now copy all other members
	        m_snuAccountType	=	r_Sid.m_snuAccountType;
            m_dwLastError		=	r_Sid.m_dwLastError;
	        //m_strSid			=	r_Sid.m_strSid;
	        //m_strAccountName	=	r_Sid.m_strAccountName;
	        //m_strDomainName		=	r_Sid.m_strDomainName;

            m_bstrtSid			=	r_Sid.m_bstrtSid;
	        m_bstrtAccountName	=	r_Sid.m_bstrtAccountName;
	        m_bstrtDomainName	=	r_Sid.m_bstrtDomainName;
        }
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            throw;
        }
    }
    else
    {
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::~CSid
//
//	Class destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid::~CSid( void )
{
	if ( m_pSid != NULL )
		free ( m_pSid );
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::operator=
//
//	Equals operator.
//
//	Inputs:
//				const CSid	r_Sid - CSid to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

CSid &	CSid::operator= ( const CSid &r_Sid )
{
	free( m_pSid );
	m_pSid = NULL;
	// Handle WINNT SID pointer first

	// pSid should be valid...
	ASSERT_BREAK( r_Sid.IsValid( ) );

	// if we do not
	if (r_Sid.IsValid( ))
	{
		// Allocate a new SID and copy data into it.
		DWORD dwSize = ::GetLengthSid( r_Sid.m_pSid );
		try
        {
            m_pSid = malloc( dwSize );
		    ASSERT_BREAK( m_pSid != NULL );
            if (m_pSid != NULL)
            {
		        BOOL bResult = ::CopySid( dwSize, m_pSid, r_Sid.m_pSid );
		        ASSERT_BREAK( bResult );
            }
            else
            {
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

        }
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            throw;
        }
	}	// end if

	// Now copy all other members
	m_snuAccountType	=	r_Sid.m_snuAccountType;
    m_dwLastError		=	r_Sid.m_dwLastError;
	m_bstrtSid			=	r_Sid.m_bstrtSid;
	m_bstrtAccountName	=	r_Sid.m_bstrtAccountName;
	m_bstrtDomainName	=	r_Sid.m_bstrtDomainName;

	return ( *this );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::operator==
//
//	Is Equal To comparison operator.
//
//	Inputs:
//				const CSid	r_Sid - CSid to compare.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

BOOL CSid::operator== ( const CSid &r_Sid ) const
{
	BOOL	fReturn = FALSE;

	// Call Equal SID only if both sids are non-NULL
	if (IsValid()
		&&
        r_Sid.IsValid() )
	{
		fReturn = EqualSid( m_pSid, r_Sid.m_pSid );
	}
	else
	{
		fReturn = ( m_pSid == r_Sid.m_pSid );
	}

	return fReturn;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::GetDomainAccountName
//
//	Obtains account name in "DOMAIN\NAME" format.
//
//	Inputs:
//				const CSid	r_Sid - CSid to compare.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	If Domain Name is empty, the return value will be only NAME.
//
///////////////////////////////////////////////////////////////////

void CSid::GetDomainAccountName( CHString& strName ) const
{
	if ( m_bstrtDomainName.length() == 0 )
	{
		strName = (wchar_t*)m_bstrtAccountName;
	}
	else
	{
		strName = (wchar_t*)m_bstrtDomainName;
		strName += _T('\\');
		strName += (wchar_t*)m_bstrtAccountName;
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::StringFromSid
//
//	Static helper function to convert a PSID value into a human
//	readable string.
//
//	Inputs:
//				PSID		psid - SID to convert.
//
//	Outputs:
//				CHString&	str - Storage for converted PSID
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

void CSid::StringFromSid( PSID psid, CHString& str )
{
	// Initialize m_strSid - human readable form of our SID
	SID_IDENTIFIER_AUTHORITY *psia = NULL;
    psia = ::GetSidIdentifierAuthority( psid );

	// We assume that only last byte is used (authorities between 0 and 15).
	// Correct this if needed.
	ASSERT_BREAK( psia->Value[0] == psia->Value[1] == psia->Value[2] == psia->Value[3] == psia->Value[4] == 0 );
	DWORD dwTopAuthority = psia->Value[5];

	str.Format( L"S-1-%u", dwTopAuthority );
	CHString strSubAuthority;
	int iSubAuthorityCount = *( GetSidSubAuthorityCount( psid ) );
	for ( int i = 0; i < iSubAuthorityCount; i++ ) {

		DWORD dwSubAuthority = *( GetSidSubAuthority( psid, i ) );
		strSubAuthority.Format( L"%u", dwSubAuthority );
		str += _T("-") + strSubAuthority;
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::StringFromSid
//
//	Static helper function to convert a PSID value into a human
//	readable string.
//
//	Inputs:
//				PSID		psid - SID to convert.
//
//	Outputs:
//				CHString&	str - Storage for converted PSID
//
//	Returns:
//				None.
//
//	Comments: This version supports wide chars when UNICODE isn't
//            defined.
//
///////////////////////////////////////////////////////////////////

void CSid::StringFromSidW( PSID psid, WCHAR** wstr )
{
	if(wstr!=NULL)
    {
        // Initialize m_strSid - human readable form of our SID
	    SID_IDENTIFIER_AUTHORITY *psia = ::GetSidIdentifierAuthority( psid );

	    // We assume that only last byte is used (authorities between 0 and 15).
	    // Correct this if needed.
	    ASSERT_BREAK( psia->Value[0] == psia->Value[1] == psia->Value[2] == psia->Value[3] == psia->Value[4] == 0 );
	    DWORD dwTopAuthority = psia->Value[5];

        _bstr_t bstrtTempSid(L"S-1-");
        WCHAR wstrAuth[32];
        ZeroMemory(wstrAuth,sizeof(wstrAuth));
        _ultow(dwTopAuthority,wstrAuth,10);
        bstrtTempSid+=wstrAuth;
	    int iSubAuthorityCount = *( GetSidSubAuthorityCount( psid ) );
	    for ( int i = 0; i < iSubAuthorityCount; i++ )
        {

		    DWORD dwSubAuthority = *( GetSidSubAuthority( psid, i ) );
		    ZeroMemory(wstrAuth,sizeof(wstrAuth));
            _ultow(dwSubAuthority,wstrAuth,10);
            bstrtTempSid += L"-";
            bstrtTempSid += wstrAuth;
	    }
        // Now allocate the passed in wstr:
        WCHAR* wstrtemp = NULL;
        try
        {
            wstrtemp = (WCHAR*) new WCHAR[bstrtTempSid.length() + 1];
            if(wstrtemp!=NULL)
            {
                ZeroMemory(wstrtemp, bstrtTempSid.length() + 1);
                wcscpy(wstrtemp,(WCHAR*)bstrtTempSid);
            }
            *wstr = wstrtemp;
        }
        catch(...)
        {
            if(wstrtemp!=NULL)
            {
                delete wstrtemp;
                wstrtemp = NULL;
            }
            throw;
        }
    }
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::GetLength
//
//	Returns the length of the internal PSID value.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSid::GetLength( void ) const
{
	DWORD	dwLength = 0;

	if ( IsValid() )
	{
		dwLength = GetLengthSid( m_pSid );
	}

	return dwLength;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::InitFromAccountName
//
//	Initializes the object from an account name.
//
//	Inputs:
//				LPCTSTR		pszAccountName - Account name to validate
//							and obtain info for.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if OK.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CSid::InitFromAccountName( LPCTSTR pszAccountName, LPCTSTR pszComputerName )
{
	CHString strAccountName = pszAccountName;
	CHString strComputerName = pszComputerName;

	// Account name should not be empty...
	ASSERT_BREAK( !strAccountName.IsEmpty() );

	// We need to obtain a SID first
	DWORD dwSidSize = 0;
	DWORD dwDomainNameStrSize = 0;
	LPTSTR pszDomainName = NULL;
	BOOL bResult;
	{
		// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
		CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

		// This call should fail
		bResult = ::LookupAccountName( TOBSTRT(strComputerName),
												TOBSTRT(strAccountName),
												m_pSid,
												&dwSidSize,
												pszDomainName,
												&dwDomainNameStrSize,
												&m_snuAccountType );
		m_dwLastError = ::GetLastError();

	}

	ASSERT_BREAK( bResult == FALSE );
//	ASSERT_BREAK( ERROR_INSUFFICIENT_BUFFER == m_dwLastError );

	if ( ERROR_INSUFFICIENT_BUFFER == m_dwLastError )
	{
		// Allocate buffers
		m_pSid = NULL;
        pszDomainName = NULL;
        try
        {
            m_pSid = (PSID) malloc( dwSidSize );
		    pszDomainName = (LPTSTR) malloc( dwDomainNameStrSize * sizeof(TCHAR) );
            if ((m_pSid == NULL) || (pszDomainName == NULL))
            {
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

		    {
			    // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
			    CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

			    // Make the second call
			    bResult = ::LookupAccountName( TOBSTRT(strComputerName),
											    TOBSTRT(strAccountName),
											    m_pSid,
											    &dwSidSize,
											    pszDomainName,
											    &dwDomainNameStrSize,
											    &m_snuAccountType );
		    }

		    if ( bResult )
		    {

			    CHString chsSidTemp;
                StringFromSid( m_pSid, chsSidTemp );
                m_bstrtSid = chsSidTemp;

			    // Initialize account name and domain name

			    // If the account name begins with "Domain\", remove that piece.

			    CHString	strDomain(pszDomainName);

			    strDomain += _T('\\');

			    if ( 0 == strAccountName.Find( strDomain ) )
			    {
				    m_bstrtAccountName = strAccountName.Right( strAccountName.GetLength() - strDomain.GetLength() );
			    }
			    else
			    {
				    m_bstrtAccountName = strAccountName;
			    }

			    m_bstrtDomainName = pszDomainName;

			    m_dwLastError = ERROR_SUCCESS;	// We are good to go.
		    }
		    else
		    {
			    // Now what went wrong?
			    m_dwLastError = ::GetLastError();
		    }




		    ASSERT_BREAK( ERROR_SUCCESS == m_dwLastError );

		    // Free the sid buffer if we didn't get our data
		    if ( !IsOK() && NULL != m_pSid )
		    {
			    free ( m_pSid );
			    m_pSid = NULL;
		    }

		    if ( NULL != pszDomainName )
		    {
			    free ( pszDomainName );
		    }
        }
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            if(pszDomainName != NULL)
            {
                free(pszDomainName);
                pszDomainName = NULL;
            }
            throw;
        }

	}	// IF ERROR_INSUFFICIENT_BUFFER

	return m_dwLastError;
}


///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::InitFromAccountNameW
//
//	Initializes the object from an account name.
//
//	Inputs:
//				LPCTSTR		pszAccountName - Account name to validate
//							and obtain info for.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if OK.
//
//	Comments: This flavor is used for wide char support when
//  UNICODE is not defined.
//
///////////////////////////////////////////////////////////////////

DWORD CSid::InitFromAccountNameW(LPCWSTR wstrAccountName, LPCWSTR wstrComputerName )
{
	// Account name should not be empty...
	ASSERT_BREAK(wcslen(wstrAccountName)!=0);

	// We need to obtain a SID first
	DWORD dwSidSize = 0;
	DWORD dwDomainNameStrSize = 0;
	WCHAR* wstrDomainName = NULL;
	BOOL bResult;
	// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
	{
        CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
	    // This call should fail
	    bResult = ::LookupAccountNameW(wstrComputerName,
     							       wstrAccountName,
								       m_pSid,
								       &dwSidSize,
								       wstrDomainName,
								       &dwDomainNameStrSize,
								       &m_snuAccountType );
	}
    m_dwLastError = ::GetLastError();

	ASSERT_BREAK( bResult == FALSE );

	if (m_dwLastError == ERROR_INSUFFICIENT_BUFFER)
	{
		// Allocate buffers
        m_pSid = NULL;
        try
        {
		    m_pSid = (PSID) malloc( dwSidSize );
		    wstrDomainName = (WCHAR*) new WCHAR[dwDomainNameStrSize];
            if (( m_pSid == NULL ) || ( wstrDomainName == NULL ) )
            {
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

		    {
			    // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
			    CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
			    // Make the second call
			    bResult = ::LookupAccountNameW(wstrComputerName,
										       wstrAccountName,
										       m_pSid,
										       &dwSidSize,
										       wstrDomainName,
										       &dwDomainNameStrSize,
										       &m_snuAccountType );
		    }
		    if(bResult)
		    {
			    WCHAR* pwch = NULL;
                WCHAR* pwchSid = NULL;
                try
                {
                    StringFromSidW( m_pSid, &pwchSid );
                    m_bstrtSid = (LPCWSTR)pwchSid;
                    if(pwchSid != NULL)
                    {
                        delete pwchSid;
                    }
                }
                catch(...)
                {
                    if(pwchSid != NULL)
                    {
                        delete pwchSid;
                    }
                    throw;
                }

			    // Initialize account name and domain name
			    // If the account name begins with "Domain\", remove that piece.

                _bstr_t bstrtDomain(wstrDomainName);
                bstrtDomain += L"\\";

			    if((pwch = wcsstr(wstrAccountName,bstrtDomain)) != NULL)
			    {
                    m_bstrtAccountName = wstrAccountName + bstrtDomain.length();
			    }
			    else
			    {
				    m_bstrtAccountName = wstrAccountName;
			    }
			    m_bstrtDomainName = wstrDomainName;
			    m_dwLastError = ERROR_SUCCESS;	// We are good to go.
		    }
		    else
		    {
			    // Now what went wrong?
			    m_dwLastError = ::GetLastError();
		    }


		    ASSERT_BREAK( ERROR_SUCCESS == m_dwLastError );

		    // Free the sid buffer if we didn't get our data
		    if ( !IsOK() && NULL != m_pSid )
		    {
			    free ( m_pSid );
			    m_pSid = NULL;
		    }

		    if ( NULL != wstrDomainName )
		    {
			    delete wstrDomainName;
		    }
        }
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            if ( NULL != wstrDomainName )
		    {
			    delete wstrDomainName;
                wstrDomainName = NULL;
		    }
            throw;
        }


	}	// IF ERROR_INSUFFICIENT_BUFFER

	return m_dwLastError;
}



///////////////////////////////////////////////////////////////////
//
//	Function:	CSid::InitFromSid
//
//	Initializes the object from a PSid
//
//	Inputs:
//				PSID		pSid - PSid to look up.
//				LPCTSTR		pszComputerName - Remote computer to
//							execute on.
//                bool        fLookup - indicates whether to determine
//                          the domain and account associated with
//                          the sid at this time.
//
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD		ERROR_SUCCESS if OK.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////
DWORD CSid::InitFromSid( PSID pSid, LPCTSTR pszComputerName, bool fLookup )
{
	// pSid should be valid...
	ASSERT_BREAK( (pSid != NULL) && ::IsValidSid( pSid ) );

	if ( (pSid != NULL) && ::IsValidSid( pSid ) )
	{
		// Allocate a new SID and copy data into it.
		DWORD dwSize = ::GetLengthSid( pSid );
        m_pSid = NULL;
        try
        {
		    m_pSid = malloc( dwSize );
            if (m_pSid == NULL)
            {
				throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

		    BOOL bResult = ::CopySid( dwSize, m_pSid, pSid );
		    ASSERT_BREAK( bResult );

            //StringFromSid( pSid, m_strSid );
            WCHAR* pwstrSid = NULL;
            try
            {
                StringFromSidW( pSid, &pwstrSid );
                m_bstrtSid = pwstrSid;
                delete pwstrSid;
            }
            catch(...)
            {
                if(pwstrSid != NULL)
                {
                    delete pwstrSid;
                    pwstrSid = NULL;
                }
                throw;
            }
            if(fLookup)
            {
		        // Initialize account name and domain name
		        LPTSTR pszAccountName = NULL;
		        LPTSTR pszDomainName = NULL;
		        DWORD dwAccountNameSize = 0;
		        DWORD dwDomainNameSize = 0;
		        try
                {
		            {
			            // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
			            CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

			            // This call should fail
			            bResult = ::LookupAccountSid( pszComputerName,
											            pSid,
											            pszAccountName,
											            &dwAccountNameSize,
											            pszDomainName,
											            &dwDomainNameSize,
											            &m_snuAccountType );
			            m_dwLastError = ::GetLastError();
		            }

		            // Why were we breaking on these when we are expecting them to
                    // always happend?
                    //ASSERT_BREAK( bResult == FALSE );
		            //ASSERT_BREAK( ERROR_INSUFFICIENT_BUFFER == m_dwLastError );

		            if ( ERROR_INSUFFICIENT_BUFFER == m_dwLastError )
		            {

			            // Allocate buffers
			            if ( dwAccountNameSize != 0 )
                        {
				            pszAccountName = (LPTSTR) malloc( dwAccountNameSize * sizeof(TCHAR));
                            if (pszAccountName == NULL)
                            {
            				    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                            }
                        }

			            if ( dwDomainNameSize != 0 )
                        {
				            pszDomainName = (LPTSTR) malloc( dwDomainNameSize * sizeof(TCHAR));
                            if (pszDomainName == NULL)
                            {
            				    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                            }
                        }

			            {
				            // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
				            CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

				            // Make second call
				            bResult = ::LookupAccountSid( pszComputerName,
												            pSid,
												            pszAccountName,
												            &dwAccountNameSize,
												            pszDomainName,
												            &dwDomainNameSize,
												            &m_snuAccountType );
			            }


			            if ( bResult == TRUE )
			            {
				            m_bstrtAccountName = pszAccountName;
				            m_bstrtDomainName = pszDomainName;

				            // We're OKAY
				            m_dwLastError = ERROR_SUCCESS;
			            }
			            else
			            {

				            // There are some accounts that do not have names, such as Logon Ids,
				            // for example S-1-5-X-Y. So this is still legal
				            m_bstrtAccountName = _T("Unknown Account");
				            m_bstrtDomainName = _T("Unknown Domain");

				            // Log the error
				            m_dwLastError = ::GetLastError();

			            }

			            ASSERT_BREAK( ERROR_SUCCESS == m_dwLastError );

			            if ( NULL != pszAccountName )
			            {
				            free ( pszAccountName );
                            pszAccountName = NULL;
			            }

			            if ( NULL != pszDomainName )
			            {
				            free ( pszDomainName );
                            pszDomainName = NULL;
			            }

		            }	// If ERROR_INSUFFICIENT_BUFFER
                } // try
                catch(...)
                {
                    if ( NULL != pszAccountName )
			        {
				        free ( pszAccountName );
                        pszAccountName = NULL;
			        }

			        if ( NULL != pszDomainName )
			        {
				        free ( pszDomainName );
                        pszDomainName = NULL;
			        }
                    throw;
                }
            }  // fLookup
        }  //try
        catch(...)
        {
            if(m_pSid != NULL)
            {
                free(m_pSid);
                m_pSid = NULL;
            }
            throw;
        }

	}	// IF IsValidSid
	else
	{
		m_dwLastError = ERROR_INVALID_PARAMETER;
	}

	return m_dwLastError;

}

#ifdef NTONLY
void CSid::DumpSid(LPCWSTR wstrFilename)
{
    CHString chstrTemp1((LPCWSTR)m_bstrtSid);
    CHString chstrTemp2;

    Output(L"SID contents follow...", wstrFilename);
    // Output the sid string:
    chstrTemp2.Format(L"SID string: %s", (LPCWSTR)chstrTemp1);
    Output(chstrTemp2, wstrFilename);

    // Output the name:
    if(m_bstrtAccountName.length() > 0)
    {
        chstrTemp2.Format(L"SID account name: %s", (LPCWSTR)m_bstrtAccountName);
        Output(chstrTemp2, wstrFilename);
    }
    else
    {
        chstrTemp2.Format(L"SID account name was not available");
        Output(chstrTemp2, wstrFilename);
    }

    // Output the domain:
    if(m_bstrtDomainName.length() > 0)
    {
        chstrTemp2.Format(L"SID domain name: %s", (LPCWSTR)m_bstrtDomainName);
        Output(chstrTemp2, wstrFilename);
    }
    else
    {
        chstrTemp2.Format(L"SID domain name was not available");
        Output(chstrTemp2, wstrFilename);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\sms95lanexp.h ===
//=================================================================

//

// Sms95lanexp.h

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __SMS95LANEXP_H__
#define __SMS95LANEXP_H__

typedef ULONG* LPULONG;
typedef DWORD CMBUSTYPE;
typedef CMBUSTYPE* PCMBUSTYPE;

// Function prototypes for dynamic linking
typedef DWORD (WINAPI* PCIM32THK_CM_LOCATE_DEVNODE) ( PDEVNODE pdn, LPSTR HardwareKey, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_CHILD) ( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_SIBLING) ( PDEVNODE pdn, DEVNODE dnParent, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_READ_REGISTRY_VALUE) ( DEVNODE dnDevNode, LPSTR pszSubKey, LPSTR pszValueName, ULONG ulExpectedType, LPVOID Buffer, LPULONG pulLength, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_DEVNODE_STATUS) ( LPULONG pulStatus, LPULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_DEVICE_ID) ( DEVNODE dnDevNode, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_DEVICE_ID_SIZE) ( LPULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_FIRST_LOG_CONF) ( PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_NEXT_RES_DES) ( PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_RES_DES_DATA_SIZE) ( LPULONG pulSize, RES_DES rdResDes, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_RES_DES_DATA) ( RES_DES rdResDes, LPVOID Buffer, ULONG BufferLen, ULONG ulFlags );
typedef DWORD (WINAPI* PCIM32THK_CM_GET_BUS_INFO) (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, LPULONG pulSizeOfInfo, LPVOID pInfo, ULONG ulFlags);
typedef DWORD (WINAPI* PCIM32THK_CM_GET_PARENT) ( PDEVNODE pdn, DEVNODE dnChild, ULONG ulFlags );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\sid.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CSid.h - header file for CSid class
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CSID_H__
#define __CSID_H__

#include <comdef.h>

////////////////////////////////////////////////////////////////
//
//	Class:	CSid
//
//	This class is intended to provide a wrapper for basic
//	Windows NT SIDs (Security Identifiers).  There is a
//	possibility of a slight performance hit when instantiating
//	one of these as it uses LookupAccountName and LookupAccountSid
//	to initialize account information, and those calls can go
//	out over the network to get their data.
//
////////////////////////////////////////////////////////////////

class CSid
{
	// Constructors and destructor
	public:
		CSid();
		CSid( PSID pSid, LPCTSTR pszComputerName = NULL );
        CSid( PSID pSid, LPCTSTR pszComputerName, bool fLookup );
		CSid( LPCTSTR pszDomainName, LPCTSTR pszName, LPCTSTR pszComputerName );
#ifndef UNICODE
        CSid( LPCWSTR wstrDomainName, LPCWSTR wstrName, LPCWSTR wstrComputerName );
#endif
		CSid( LPCTSTR pszAccountName, LPCTSTR pszComputerName = NULL );
		CSid( const CSid &r_Sid );
		~CSid( void );

	// Public functions
	public:
		CSid &	operator= ( const CSid & );
		BOOL	operator== ( const CSid & ) const;

		void	  GetDomainAccountName( CHString& strName ) const;
		CHString  GetAccountName( void ) const;
        WCHAR*    GetAccountNameW( void ) const;
		CHString  GetDomainName( void ) const;
        WCHAR*    GetDomainNameW( void ) const;
		CHString  GetSidString( void ) const;
        WCHAR*    GetSidStringW( void ) const;
		SID_NAME_USE GetAccountType( void ) const;
		PSID	  GetPSid( void ) const;
		DWORD	  GetLength( void ) const;

		BOOL	  IsOK( void ) const;
		BOOL	  IsValid( void ) const;
		BOOL	  IsAccountTypeValid( void ) const;
		DWORD	  GetError( void ) const;

		static void StringFromSid( PSID psid, CHString& str );
        static void StringFromSidW( PSID psid, WCHAR** pwstr );

#ifdef NTONLY
        void DumpSid(LPCWSTR wstrFilename = NULL);
#endif

	// Private data members
	private:
		PSID			m_pSid;				// Pointer to standard Win32 SID
		SID_NAME_USE	m_snuAccountType;	// Type of SID
		//CHString		m_strSid;			// Wind32 SID in human readable form
        //WCHAR*          m_wstrSid;          // As above, for wchar support when UNICODE not defined
        //WCHAR*          m_wstrAccountName;  // ibid.
        //WCHAR*          m_wstrDomainName;   // ibid.
		//CHString		m_strAccountName;	// Name of the account
		//CHString		m_strDomainName;	// Domain name the account belongs to
        _bstr_t         m_bstrtSid;
        _bstr_t         m_bstrtAccountName;
        _bstr_t         m_bstrtDomainName;
		DWORD			m_dwLastError;		// Last Error in the Sid;

		DWORD InitFromAccountName( LPCTSTR pszAccountName, LPCTSTR pszComputerName );
        DWORD InitFromAccountNameW( LPCWSTR wstrAccountName, LPCWSTR wstrComputerName );
		DWORD InitFromSid( PSID pSid, LPCTSTR pszComputerName, bool fLookup = true );
};

inline BOOL CSid::IsOK( void ) const
{
	return ( ERROR_SUCCESS == m_dwLastError );
}

inline DWORD CSid::GetError( void ) const
{
	return m_dwLastError;
}

// Lets us know if the Sid is Valid

inline BOOL CSid::IsValid( void ) const
{
	// If m_pSid is NULL, this will return FALSE.
   // dw: However, doing it this way causes a first chance exception, so...
   if (m_pSid != NULL)
	   return ::IsValidSid( m_pSid );
   return FALSE;
}

inline BOOL CSid::IsAccountTypeValid( void ) const
{
	// SID may be valid, and Lookup succeeded, but it may be of a type that isn't
	// necessarily a user/group/alias.

	return ( m_snuAccountType >= SidTypeUser && m_snuAccountType < SidTypeDeletedAccount );
}

inline SID_NAME_USE CSid::GetAccountType( void ) const
{
	return m_snuAccountType;
}

inline CHString CSid::GetAccountName( void ) const
{
	return ( CHString((LPCWSTR)m_bstrtAccountName) );
}

inline WCHAR* CSid::GetAccountNameW( void ) const
{
	return ( m_bstrtAccountName );
}

inline CHString CSid::GetDomainName( void ) const
{
	return ( CHString((LPCWSTR)m_bstrtDomainName) );
}

inline WCHAR* CSid::GetDomainNameW( void ) const
{
	return ( m_bstrtDomainName );
}

inline CHString CSid::GetSidString( void ) const
{
	return ( CHString((LPCWSTR)m_bstrtSid) );
}

inline WCHAR* CSid::GetSidStringW( void ) const
{
	return ( m_bstrtSid );
}

inline PSID CSid::GetPSid( void ) const
{
	return ( m_pSid );
}


#endif // __CSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\sources.inc ===
############################################################################

#

# Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################
WMIPRECOMPSHARED=1
!include ..\..\..\..\common\makefile.cmn
SOURCES_USED=..\..\..\..\common\makefile.cmn

TARGETNAME=Cimwin32Library
TARGETPATH=obj
TARGETTYPE=LIBRARY

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
        $(CIMWIN32_LIB_INC); \
	$(FRAMEDYN_PRIVATE); \
	$(WMIIDL_INC); \
	$(CRT_INC_PATH); \
	$(NET_INC_PATH); \
	$(BASE_INC_PATH)

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.

MISCSOURCES= \
	..\confgmgr.cpp

PRESOURCES= \
	..\assoc.cpp \
	..\binding.cpp \
        ..\AdvApi32Api.cpp \
	..\cfgmgrdevice.cpp \
 	..\chwres.cpp \
	..\Cim32NetApi.cpp \
	..\configmgrapi.cpp \
	..\CAutoLock.cpp \
	..\CachedConfigMgrData.cpp \
	..\CCriticalSec.cpp \
	..\CEvent.cpp \
	..\CGlobal.cpp \
	..\CKernel.cpp \
	..\CMutex.cpp \
	..\CThread.cpp \
	..\CThreadPool.cpp \
	..\devdesc.cpp \
	..\dllcommon.cpp \
	..\dllutils.cpp \
	..\dllunreg.cpp \
	..\DllWrapperbase.cpp \
	..\DMADesc.cpp	\
	..\EventProvider.cpp \
	..\FactoryRouter.cpp \
	..\iodesc.cpp \
	..\irqdesc.cpp \
	..\ImpersonateConnectedUser.cpp \
	..\implogonuser.cpp \
        ..\Kernel32Api.cpp \
	..\RefPtrLite.cpp \
	..\ResourceDesc.cpp 	\
 	..\ResourceManager.cpp \
	..\secureshare.cpp \
	..\securityApi.cpp \
        ..\strings.cpp \
	..\Sid.cpp	\
	..\SvrApiApi.cpp \
        ..\TimerQueue.cpp	\
        ..\TimedDllResource.cpp	\
	..\TimeOutRule.cpp	\
	..\NetApi32Api.cpp \
        ..\Nt4SvcToResMap.cpp	\
        ..\NtDevToSvcSearch.cpp \
	..\perfdata.cpp \
	..\UserEnvApi.cpp \
	..\userhive.cpp \
	..\WbemPsApi.cpp \
	..\WmiApi.cpp \
	..\Ws2_32Api.cpp \
	..\Wsock32Api.cpp \
	..\wbemnetapi32.cpp


NTSOURCES=$(NTSOURCES) \
	..\WMI_FilePrivateProfile.cpp \
	..\profilestring.cpp \
	..\session.cpp \
	..\MprApi.cpp \
	..\MsAcm32Api.cpp \
	..\NtDllApi.cpp \
	..\WinmmApi.cpp \
#	..\WinSpoolApi.cpp \

# Next, specify options for the compiler using C_DEFINES. 
C_DEFINES=$(C_DEFINES) /D__WINNT_BUILD__
WIN32_WINNT_VERSION=0x0400
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1

!ifdef USE_FRAMEDYD
DEBUG_CRTS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\session.h ===
//=============================================================================

// session.h -- definition of session collection class.

//

//  Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved
//=============================================================================



typedef NTSTATUS (NTAPI *PFN_NT_QUERY_SYSTEM_INFORMATION)
(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);




class CProcess;
class CSession;
class CUser;
class CUserComp;
class CUserSessionCollection;


class CUser
{
public:
	CUser() : m_sidUser(NULL) {}

    CUser(
        PSID psidUser);

    CUser(
        const CUser& user);

 	virtual ~CUser();

    bool IsValid();

    PSID GetPSID() const
    {
        return m_sidUser;
    }

    void GetSidString(
        CHString& str) const;

	

private:
    void Copy(
        CUser& out) const;

    PSID m_sidUser;
    bool m_fValid;
};


// Comparison class required for multimap
// costructor involving non-standard key
// type (i.e., a CUser) in the map.
class CUserComp
{
public:
    CUserComp() {}
    virtual ~CUserComp() {}

    bool operator()(
        const CUser& userFirst,
        const CUser& userSecond) const
    {
        bool fRet;
        CHString chstr1, chstr2;

        userFirst.GetSidString(chstr1);
        userSecond.GetSidString(chstr2);
         
        long lcmp = chstr1.CompareNoCase(chstr2);  
        (lcmp < 0) ? fRet = true : fRet = false;

        return fRet;
    }
};



class CProcess
{
public:
    // Constructors and destructors
    CProcess();

    CProcess(
        DWORD dwPID,
        LPCWSTR wstrImageName);

    CProcess(
        const CProcess& process);

    virtual ~CProcess();

    // Accessor functions
    DWORD GetPID() const;
    CHString GetImageName() const;
    
private:
    DWORD m_dwPID;
    CHString m_chstrImageName;

    void Copy(
        CProcess& process) const;
};


// vector and iterator for getting a session's processes... 
typedef std::vector<CProcess> PROCESS_VECTOR;
typedef PROCESS_VECTOR::iterator PROCESS_ITERATOR;


class CSession
{
public:
	// Constructors and destructors
    CSession() {}

	CSession(
        const LUID& luidSessionID);

    CSession(
        const CSession& ses);

	virtual ~CSession() {}
	

    // Accessor functions
	LUID GetLUID() const;
    __int64 GetLUIDint64() const;
    CHString GetAuthenticationPkg() const;
    ULONG GetLogonType() const;
    __int64 GetLogonTime() const;


    // Enumerate list of processes
    CProcess* GetFirstProcess(
        PROCESS_ITERATOR& pos);

	CProcess* GetNextProcess(
        PROCESS_ITERATOR& pos);

    // Allow easy impersonation of
    // the session's first process
    HANDLE Impersonate();
    DWORD GetImpProcPID();

    friend CUserSessionCollection;

    // Checks a string representation
    // of a session id for validity
    bool IsSessionIDValid(
        LPCWSTR wstrSessionID);

private:
    void Copy(
        CSession& sesCopy) const;

    CHString m_chstrAuthPkg;
    ULONG m_ulLogonType;
    __int64 i64LogonTime;
    LUID m_luid;
    PROCESS_VECTOR m_vecProcesses;
};



// map and iterator for relating users and sessions...
typedef std::multimap<CUser, CSession, CUserComp> USER_SESSION_MAP;
typedef USER_SESSION_MAP::iterator USER_SESSION_ITERATOR;

// Custom iterator used in enumerating processes from 
// CUserSessionCollection.
struct USER_SESSION_PROCESS_ITERATOR
{
    friend CUserSessionCollection;
private:
    USER_SESSION_ITERATOR usIter;
    PROCESS_ITERATOR procIter;
};


class CUserSessionCollection
{
public:
	// Constructors and destructors
    CUserSessionCollection();

    CUserSessionCollection(
        const CUserSessionCollection& sescol);

	virtual ~CUserSessionCollection() {}


    // Method to refresh map
    DWORD Refresh();

    // Methods to check whether a particular
    // session is in the map
    bool IsSessionMapped(
        LUID& luidSes);

    bool CUserSessionCollection::IsSessionMapped(
        __int64 i64luidSes);

    // Support enumeration of users
    CUser* GetFirstUser(
        USER_SESSION_ITERATOR& pos);

	CUser* GetNextUser(
        USER_SESSION_ITERATOR& pos);


    // Support enumeration of sessions
    // belonging to a particular user.
    CSession* GetFirstSessionOfUser(
        CUser& usr,
        USER_SESSION_ITERATOR& pos);

	CSession* GetNextSessionOfUser(
        USER_SESSION_ITERATOR& pos);


    // Support enumeration of all sessions
    CSession* GetFirstSession(
        USER_SESSION_ITERATOR& pos);

	CSession* GetNextSession(
        USER_SESSION_ITERATOR& pos);

    // Support finding a particular session
    CSession* FindSession(
        LUID& luidSes);

    CSession* FindSession(
        __int64 i64luidSes);


    // Support enumeration of processes
    // belonging to a particular user
    CProcess* GetFirstProcessOfUser(
        CUser& usr,
        USER_SESSION_PROCESS_ITERATOR& pos);

	CProcess* GetNextProcessOfUser(
        USER_SESSION_PROCESS_ITERATOR& pos);


    // Support enumeration of all processes
    CProcess* GetFirstProcess(
        USER_SESSION_PROCESS_ITERATOR& pos);

	CProcess* GetNextProcess(
        USER_SESSION_PROCESS_ITERATOR& pos);



private:
    DWORD CollectSessions();
    DWORD CollectNoProcessesSessions();

    void Copy(
        CUserSessionCollection& out) const;

    DWORD GetProcessList(
        std::vector<CProcess>& vecProcesses) const;

    DWORD EnablePrivilegeOnCurrentThread(
        LPCTSTR szPriv) const;

    bool FindSessionInternal(
        LUID& luidSes,
        USER_SESSION_ITERATOR& usiOut);

    USER_SESSION_MAP m_usr2ses;
};



// Helper for cleanup of handles...
class SmartCloseHANDLE
{
private:
	HANDLE m_h;

public:
	SmartCloseHANDLE() 
      : m_h(INVALID_HANDLE_VALUE) {}

	SmartCloseHANDLE(
        HANDLE h) 
      : m_h(h) {}

    virtual ~SmartCloseHANDLE()
    {
        if (m_h!=INVALID_HANDLE_VALUE) 
        {
            CloseHandle(m_h);
        }
    }

	HANDLE operator =(HANDLE h) 
    {
        if (m_h != INVALID_HANDLE_VALUE)
        { 
            CloseHandle(m_h);
        } 
        m_h=h; 
        return h;
    }

	operator HANDLE() const 
    {
        return m_h;
    }

	HANDLE* operator &() 
    {
        if (m_h!=INVALID_HANDLE_VALUE) 
        {
            CloseHandle(m_h);
        } 
        m_h = INVALID_HANDLE_VALUE; 
        return &m_h;
    }
};


// This version is a smart handle
// for use with thread tokens we
// are impersonating.  On destruction,
// it reverts to the handle it
// encapsulates.
class SmartRevertTokenHANDLE
{
private:
	HANDLE m_h;

public:
	SmartRevertTokenHANDLE() 
      : m_h(INVALID_HANDLE_VALUE) {}

	SmartRevertTokenHANDLE(
        HANDLE h) 
      : m_h(h) {}

    ~SmartRevertTokenHANDLE()
    {
        if (m_h != INVALID_HANDLE_VALUE)
        {
            HANDLE hCurThread = ::GetCurrentThread();
            if(!::SetThreadToken(
                &hCurThread,
                m_h))
            {
                LogMessage2(
                L"Failed to SetThreadToken in ~SmartRevertTokenHANDLE with error %d", 
                ::GetLastError());
            }
            CloseHandle(m_h);
        }
    }

	HANDLE operator =(HANDLE h) 
    {
        if (m_h != INVALID_HANDLE_VALUE)
        { 
            HANDLE hCurThread = ::GetCurrentThread();
            if(!::SetThreadToken(
                &hCurThread,
                m_h))
            {
                LogMessage2(
                L"Failed to SetThreadToken in SmartRevertTokenHANDLE::operator = ,with error %d", 
                ::GetLastError());
            }
            CloseHandle(m_h);
        } 
        m_h = h; 
        return h;
    }

	operator HANDLE() const 
    {
        return m_h;
    }

	HANDLE* operator &() 
    {
        if (m_h != INVALID_HANDLE_VALUE) 
        {
            HANDLE hCurThread = ::GetCurrentThread();
            if(!::SetThreadToken(
                &hCurThread,
                m_h))
            {
                LogMessage2(
                L"Failed to SetThreadToken in SmartRevertTokenHANDLE::operator &, with error %d", 
                ::GetLastError());
            };
            CloseHandle(m_h);
        } 
        m_h = INVALID_HANDLE_VALUE; 
        return &m_h;
    }
};



// Helper for automatic cleanup of
// pointers returned from the various
// enumeration functions.
template<class T>
class SmartDelete
{
private:
	T* m_ptr;

public:
	SmartDelete() 
      : m_ptr(NULL) {}

	SmartDelete(
        T* ptr) 
      : m_ptr(hptr) {}

    virtual ~SmartDelete()
    {
        if(m_ptr != NULL) 
        {
            delete m_ptr;
            m_ptr = NULL;
        }
    }

	T* operator =(T* ptrRight) 
    {
        if(m_ptr != NULL) 
        {
            delete m_ptr;
            m_ptr = NULL;
        } 
        m_ptr = ptrRight; 
        return ptrRight;
    }

	operator T*() const 
    {
        return m_ptr;
    }

	T* operator &() 
    {
        if(m_ptr != NULL) 
        {
            delete m_ptr;
            m_ptr = NULL;
        } 
        m_ptr = NULL; 
        return m_ptr;
    }

    T* operator->() const
    {
        return m_ptr;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\strings.cpp ===
//=================================================================

//

// Strings.cpp

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

// Needed to fix warning message.  I believe this is fixed in vc6.
#if ( _MSC_VER <= 1100 )
void strings_cpp(void) { ; };
#endif

// registry strings
//
///////////////////////////////////////////////////////////

// LOGGING MESSAGES
LPCWSTR IDS_LogImpersonationFailed = L"Failed to impersonate logged on user.\n";
LPCWSTR IDS_LogImpersonationRevertFailed = L"Unable to revert back from impersonated user.\n";
LPCWSTR IDS_LogOutOfMemory = L"Out of Memory";

// SHARE DISPOSITIONS
LPCWSTR IDS_SDDeviceExclusive = L"DeviceExclusive";
LPCWSTR IDS_SDDriverExclusive = L"DriverExclusive";
LPCWSTR IDS_SDShared = L"Shared";
LPCWSTR IDS_SDUndetermined = L"Undetermined";

//      MEMORY TYPES
LPCWSTR IDS_MTReadWrite = L"ReadWrite";
LPCWSTR IDS_MTReadOnly = L"ReadOnly";
LPCWSTR IDS_MTWriteOnly = L"WriteOnly";
LPCWSTR IDS_MTPrefetchable = L"Prefetchable";

//      MEDIA TYPES
LPCWSTR IDS_MDT_RandomAccess = L"Random Access";
LPCWSTR IDS_MDT_SupportsWriting = L"Supports Writing";
LPCWSTR IDS_MDT_Removable = L"Removable Media";
LPCWSTR IDS_MDT_CD = L"CD-ROM";

// Processor Architectures
LPCWSTR IDS_ProcessorX86 = L"X86-based PC";
LPCWSTR IDS_ProcessorX86Nec98 = L"X86-Nec98 PC";
LPCWSTR IDS_ProcessorMIPS = L"MIPS-based PC";
LPCWSTR IDS_ProcessorALPHA = L"ALPHA-based PC";
LPCWSTR IDS_ProcessorPowerPC = L"Power PC";
LPCWSTR IDS_ProcessorIA64 = L"Itanium (TM) -based System";
LPCWSTR IDS_ProcessorAMD64 = L"AMD64-based PC";
LPCWSTR IDS_ProcessorUnknown = L"Unknown";


// COMMON STRINGS
LPCWSTR IDS_Unknown     = L"UNKNOWN";
LPCWSTR IDS_OK = L"OK";
LPCWSTR IDS_Degraded = L"Degraded";
LPCWSTR IDS_Error    = L"Error";
LPCWSTR IDS_WINNT_SHELLNAME_EXPLORER = L"EXPLORER.EXE";
LPCWSTR IDS_WINNT_SHELLNAME_PROGMAN = L"PROGMAN.EXE";

// Win32_Bios
LPCWSTR IDS_RegBiosSystem       = L"HARDWARE\\Description\\System";
LPCWSTR IDS_RegSystemBiosDate   = L"SystemBiosDate";
LPCWSTR IDS_RegSystemBiosVersion        = L"SystemBiosVersion";
LPCWSTR IDS_RegEnumRootBios = L"Enum\\Root\\*PNP0C01\\0000";
LPCWSTR IDS_RegBIOSName = L"BIOSName";
LPCWSTR IDS_RegBIOSDate = L"BIOSDate";
LPCWSTR IDS_RegBIOSVersion = L"BIOSVersion";
LPCWSTR IDS_BIOS_NAME_VALUE  = L"Default System BIOS";

//      Win32_BootConfiguration
LPCWSTR IDS_BOOT_CONFIG_NAME = L"BootConfiguration";
LPCWSTR IDS_RegSetupLog = L"\\Repair\\Setup.Log";
LPCWSTR IDS_Paths = L"Paths";
LPCWSTR IDS_TargetDirectory = L"TargetDirectory";
LPCWSTR IDS_EnvBootDirectory = L"WinBootDir";
LPCWSTR IDS_Temp = L"Temp";
LPCWSTR IDS_Environment = L"Environment";

//  Win32_Bus
LPCWSTR IDS_Win32_Bus = L"Win32_Bus";
LPCWSTR IDS_Bus = L"Bus";
LPCWSTR IDS_BusType = L"BusType";
LPCWSTR IDS_BusNum  = L"BusNum";
LPCWSTR IDS_BUS_DEVICEID_TAG = L"_BUS_";
LPCWSTR IDS_WIN98_USB_REGISTRY_KEY = L"System\\CurrentControlSet\\Services\\Class\\USB";
LPCWSTR IDS_NT5_USB_REGISTRY_KEY = L"System\\CurrentControlSet\\Services\\usbhub";
LPCWSTR IDS_USB_Bus_Tag = L"USB";

//      Win32_CDRom
LPCWSTR IDS_RegSCSICDDevice = L"HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target Id %d\\Logical Unit Id %d";
LPCWSTR IDS_RegIdentifier = L"Identifier";
LPCWSTR IDS_RegEnumSCSI = L"Enum\\SCSI";
LPCWSTR IDS_RegCurrentDriveLetterKey = L"CurrentDriveLetterAssignment";
LPCWSTR IDS_RegProductIDKey = L"ProductId";
LPCWSTR IDS_RegClassKey = L"Class";
LPCWSTR IDS_RegHardwareIDKey = L"HardwareID";
LPCWSTR IDS_RegRevisionLevelKey = L"RevisionLevel";
LPCWSTR IDS_RegSCSITargetIDKey = L"SCSITargetId";
LPCTSTR IDT_REG_KEY_CD_CACHE = _T("System\\CurrentControlSet\\Control\\FileSystem\\CDFS");
LPCTSTR IDT_REG_VAL_CD_CACHE = _T("CacheSize");
LPCWSTR IDS_DriveIntegrity = L"DriveIntegrity";
LPCWSTR IDS_TransferRate = L"TransferRate";


//      Win32_ComputerSystemn
LPCWSTR IDS_Win32ComputerSystem = L"Win32_ComputerSystem";
LPCWSTR IDS_DefaultSystemName = L"DEFAULT";
LPCWSTR IDS_RegInfrared = L"Infrared";
LPCWSTR IDS_Workstation = L"Workstation";
LPCWSTR IDS_PrimaryOwnerName = L"PrimaryOwnerName";
LPCWSTR IDS_SystemStartupSetting = L"SystemStartupSetting";
LPCWSTR IDS_SystemStartupOptions = L"SystemStartupOptions";
LPCWSTR IDS_OEMLogoBitmap = L"OEMLogoBitmap";
LPCWSTR IDS_RegCrashControl = L"SYSTEM\\CurrentControlSet\\Control\\CrashControl";
LPCWSTR IDS_RegAutoRebootKey = L"AutoReboot";
LPCWSTR IDS_RegCurrentNTVersion = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
LPCWSTR IDS_RegCurrent95Version = L"Software\\Microsoft\\Windows\\CurrentVersion";
LPCWSTR IDS_RegRegisteredOwnerKey = L"RegisteredOwner";
LPCWSTR IDS_RegProductOptions = L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions";
LPCWSTR IDS_RegProductTypeKey = L"ProductType";
LPCWSTR IDS_RegNetworkLogon = L"Network\\Logon";
LPCWSTR IDS_RegPrimaryProvider = L"PrimaryProvider";
LPCWSTR IDS_RegNetworkProvider = L"System\\CurrentControlSet\\Services\\MSNP32\\NetworkProvider";
LPCWSTR IDS_RegAuthenticatingAgent = L"AuthenticatingAgent";
LPCWSTR IDS_MicrosoftNetwork = L"Microsoft Network";
LPCWSTR IDS_LanmanNT = L"LanmanNT";
LPCWSTR IDS_ServerNT = L"ServerNT";
LPCWSTR IDS_Server = L"Server";
LPCWSTR IDS_RegCurrentNTVersionSetup = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup";
LPCWSTR IDS_RegBootDirKey = L"BootDir";
LPCWSTR IDS_BootIni = L"boot.ini";
LPCWSTR IDS_CBootIni = L"c:\\boot.ini";
LPCTSTR IDT_BootLoader = _T("Boot Loader");
LPCTSTR IDT_Timeout = _T("timeout");
LPCTSTR IDT_OperatingSystems = _T("Operating Systems");
LPCTSTR IDT_OemLogoBmp = _T("OemLogo.Bmp");
LPCTSTR IDT_Line = _T("Line");
LPCTSTR IDT_SupportInformation = _T("Support Information");
LPCTSTR IDT_General = _T("General");
LPCTSTR IDT_OEMInfoIni = _T("OemInfo.Ini");
LPCWSTR IDS_RegCSEnumRootKey = L"Enum\\Root\\*PNP0C01\\0000";
LPCWSTR IDS_RegPowerManagementKey = L"Enum\\Root\\*PNP0C05\\0000";
LPCWSTR IDS_ATDescription = L"AT/AT COMPATIBLE";
LPCWSTR IDS_RegIdentifierKey = L"Identifier";
LPCWSTR IDS_EnableDaylightSavingsTime = L"EnableDaylightSavingsTime";
LPCWSTR IDS_LargeSystemCache = L"LargeSystemCache";

	// boot states
LPCWSTR IDS_BootupStateNormal = L"Normal boot";
LPCWSTR IDS_BootupStateFailSafe = L"Fail-safe boot";
LPCWSTR IDS_BootupStateFailSafeWithNetBoot = L"Fail-safe with network boot";
        // log messages
LPCWSTR IDS_LogNoAPMForNT5 = L"APM not returned for NT 5+";

//      Win32_Desktop
LPCWSTR IDS_RegNTProfileList = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
LPCWSTR IDS_RegControlPanelDesktop = L"\\Control Panel\\Desktop";
LPCWSTR IDS_RegControlPanelAppearance = L"\\Control Panel\\Appearance";
LPCWSTR IDS_RegControlPanelDesktop95 = L"%s\\Control Panel\\Desktop";
LPCWSTR IDS_RegScreenSaveActive = L"ScreenSaveActive";
LPCWSTR IDS_RegSCRNSAVEEXE      = L"SCRNSAVE.EXE";
LPCWSTR IDS_RegScreenSaverIsSecure = L"ScreenSaverIsSecure";
LPCWSTR IDS_RegScreenSaveTimeOut = L"ScreenSaveTimeOut";
LPCWSTR IDS_RegTileWallpaper = L"TileWallpaper";
LPCWSTR IDS_RegWindowMetricsKey = L"\\WindowMetrics";
LPCWSTR IDS_RegScreenSaveUsePassword = L"ScreenSaveUsePassword";

//      Win32_DeviceMemory
LPCWSTR IDS_RegAddressRange = L"0x%8.8I64lX-0x%8.8I64lX";
LPCWSTR IDS_RegStartingAddress = L"0x%4.4X-0x%4.4X";

// Win32_Directory

// Win32_SerialPort
LPCWSTR IDS_NT4_PortKey = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Ports";
LPCWSTR IDS_WIN9XCurCtlSet_Svcs_Class = L"System\\CurrentControlSet\\Services\\Class";

//      Win32_DiskPartition
LPCWSTR IDS_Bootable = L"Bootable";
LPCWSTR IDS_PhysicalDrive = L"\\\\.\\PHYSICALDRIVE%d";
LPCWSTR IDS_PartitionDescUnused = L"Unused";
LPCWSTR IDS_PartitionDesc12bitFAT = L"12-bit FAT";
LPCWSTR IDS_PartitionDescXenixOne = L"Xenix Type 1";
LPCWSTR IDS_PartitionDescXenixTwo = L"Xenix Type 2";
LPCWSTR IDS_PartitionDesc16bitFAT = L"16-bit FAT";
LPCWSTR IDS_PartitionDescExtPartition = L"Extended Partition";
LPCWSTR IDS_PartitionDescDOSV4Huge = L"MS-DOS V4 Huge";
LPCWSTR IDS_PartitionDescInstallable = L"Installable File System";
LPCWSTR IDS_PartitionDescPowerPCRef = L"PowerPC Reference Platform";
LPCWSTR IDS_PartitionDescUnix = L"UNIX";
LPCWSTR IDS_PartitionDescNTFT = L"NTFT";
LPCWSTR IDS_PartitionDescWin95Ext = L"Win95 w/Extended Int 13";
LPCWSTR IDS_PartitionDescExt13 = L"Extended w/Extended Int 13";
LPCWSTR IDS_PartitionDescUnknown = L"Unknown";
LPCWSTR IDS_PartitionDescGPTUnused = L"GPT: Unused";
LPCWSTR IDS_PartitionDescGPTSystem = L"GPT: System";
LPCWSTR IDS_PartitionDescGPTMSFTReserved = L"GPT: Microsoft Reserved";
LPCWSTR IDS_PartitionDescGPTBasicData = L"GPT: Basic Data";
LPCWSTR IDS_PartitionDescGPTLDMMetaData = L"GPT: Logical Disk Manager Metadata";
LPCWSTR IDS_PartitionDescGPTLDMData = L"GPT: Logical Disk Manager Data";
LPCWSTR IDS_PartitionDescGPTUnknown = L"GPT: Unknown";

// Win32_DisplayControlConfiguration
LPCWSTR IDS_AdapterConfiguredIncorrect = L"Display Adapter Not Configured Correctly";

// Win32_Environment
LPCWSTR IDS_SystemUser = L"<SYSTEM>";
LPCWSTR IDS_DefaultUser = L"<DEFAULT>";
LPCWSTR IDS_RegEnvironmentNT = L"System\\CurrentControlSet\\Control\\Session Manager\\Environment";
LPCWSTR IDS_RegEnvironmentKey = L"\\Environment";
LPCWSTR IDS_LogInvalidEnvFlags = L"Invalid lFlags to Environment::PutInstance (0x%x)";
LPCWSTR IDS_LogUserSystemMismatch = L"Username and SystemVariable mismatch.";
LPCWSTR IDS_LogInvalidEnvDelFlags = L"Invalid lFlags to Environment::DeleteInstance (0x%x)";

// Win32_Keyboard
LPCWSTR IDS_PCXT = L"PC/XT or compatible (83-key)";
LPCWSTR IDS_ICO = L"\"ICO\" (102-key)";
LPCWSTR IDS_PCAT = L"PC/AT or similar (84-key)";
LPCWSTR IDS_ENHANCED101102 = L"Enhanced (101- or 102-key)";
LPCWSTR IDS_NOKIA1050 = L"Nokia 1050 or similar";
LPCWSTR IDS_NOKIA9140 = L"Nokia 9140 or similar";
LPCWSTR IDS_UnknownKeyboard = L"Unknown keyboard";
LPCWSTR IDS_Japanese = L"Japanese";

// Win32_LogicalDisk
LPCWSTR IDS_SupportsFileBasedCompression = L"SupportsFileBasedCompression";

// CIM_LogicalFile
LPCWSTR IDS_Filename = L"Filename";
LPCWSTR IDS_Filesize = L"FileSize";
LPCWSTR IDS_Directory = L"Directory";
LPCWSTR IDS_EightDotThreeFileName = L"EightDotThreeFileName";
LPCWSTR IDS_Archive = L"Archive";
LPCWSTR IDS_Hidden = L"Hidden";
LPCWSTR IDS_System = L"System";
LPCWSTR IDS_LocalDisk = L"Local Disk";
LPCWSTR IDS_FileFolder = L"File Folder";
LPCWSTR IDS_FileTypeKeyNT4 = L"Software\\Classes\\";
LPCWSTR IDS_File = L"File";
LPCWSTR IDS_CompressionMethod = L"CompressionMethod";
LPCWSTR IDS_EncryptionMethod = L"EncryptionMethod";

// CIM_LogicalDevice_CIMDataFile
LPCWSTR IDS___Path = L"__PATH";
LPCWSTR IDS___Class = L"__CLASS";
LPCWSTR IDS___Relpath = L"__RELPATH";
LPCWSTR IDS_NT_CurCtlSetEnum = L"System\\CurrentControlSet\\Enum\\";
LPCWSTR IDS_NT_CurCtlSetSvcs = L"System\\CurrentControlSet\\Services\\";
LPCWSTR IDS_ImagePath = L"ImagePath";
LPCWSTR IDS_98_CurCtlSetSvcCls = L"System\\CurrentControlSet\\Services\\Class\\";
LPCWSTR IDS_DevLoader = L"DevLoader";
LPCWSTR IDS_98_Vmm32Files = L"System\\CurrentControlSet\\Control\\VMM32Files";
LPCWSTR IDS_CIMDataFile = L"CIM_DataFile";
LPCWSTR IDS_DriversSubdir = L"Drivers";
LPCWSTR IDS_Extension_sys = L".sys";
LPCWSTR IDS_DeviceVxDs = L"DeviceVxDs";
LPCWSTR IDS_Enum = L"Enum";
LPCWSTR IDS_Count = L"Count";
LPCWSTR IDS_Purpose = L"Purpose";

// Win32_ShortcutFile
LPCWSTR IDS_Target = L"Target";

// Win32_Win32LogicalProgramGroup
LPCWSTR IDS_BASE_REG_KEY = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager";


// Win32_Win32ProgramGroup_CIMDataFile
LPCWSTR IDS_Start_MenuWhackPrograms = L"Start Menu\\Programs";
LPCWSTR IDS_Default_User = L"Default User";
LPCWSTR IDS_All_Users = L"All Users";
LPCWSTR IDS_Profiles = L"Profiles";
LPCWSTR IDS_Start_Menu = L"Start Menu";



LPCWSTR IDS_Caption     = L"Caption";
LPCWSTR IDS_Device     = L"Device";
LPCWSTR IDS_CreationClassName = L"CreationClassName";
LPCWSTR IDS_CSCreationClassName = L"CSCreationClassName";
LPCWSTR IDS_Description = L"Description";
LPCWSTR IDS_HotSwappable = L"HotSwappable";
LPCWSTR IDS_Installed   = L"Installed";
LPCWSTR IDS_XOnXMitThreshold = L"XOnXMitThreshold";
LPCWSTR IDS_XOffXMitThreshold = L"XOffXMitThreshold";
LPCWSTR IDS_Name = L"Name";
LPCWSTR IDS_WorkingSetSize = L"WorkingSetSize";
LPCWSTR IDS_Manufacturer    = L"Manufacturer";
LPCWSTR IDS_FSCreationClassName = L"FSCreationClassName";
LPCWSTR IDS_CSName = L"CSName";
LPCWSTR IDS_Handle = L"Handle";
LPCWSTR IDS_OSCreationClassName = L"OSCreationClassName";
LPCWSTR IDS_OSName = L"OSName";
LPCWSTR IDS_FSName = L"FSName";
LPCWSTR IDS_CreationDate = L"CreationDate";
LPCWSTR IDS_InstallDate = L"InstallDate";
LPCTSTR IDT_Model           = _T("Model");
LPCWSTR IDS_Model           = L"Model";
LPCWSTR IDS_PowerState      = L"PowerState";
LPCWSTR IDS_SerialNumber    = L"SerialNumber";
LPCWSTR IDS_SKU             = L"SKU";
LPCWSTR IDS_Tag             = L"Tag";
LPCWSTR IDS_Version         = L"Version";
LPCWSTR IDS_Control             = L"Control";
LPCWSTR IDS_InUse           = L"InUse";
LPCWSTR IDS_PrimaryOwner    = L"PrimaryOwnerName";
LPCWSTR IDS_MaxTransmissionSpeed = L"MaxBaudRateToSerialPort";
LPCWSTR IDS_MaxTransmissionSpeedToPhone = L"MaxBaudRateToPhone";
LPCWSTR IDS_AnswerMode          = L"AnswerMode";
LPCWSTR IDS_LINEANSWERMODENODE = L"No effect on line";
LPCWSTR IDS_LINEANSWERMODEDROP = L"Drops current call";
LPCWSTR IDS_LINEANSWERMODEHOLD = L"Holds current call";
LPCWSTR IDS_BasePriority    = L"Priority";
LPCWSTR IDS_ProcessID       = L"ProcessID";
LPCWSTR IDS_JobCount = L"JobCount";
LPCWSTR IDS_JobCountSinceLastReset = L"JobCountSinceLastReset";
LPCWSTR IDS_BuildNumber         = L"BuildNumber";
LPCWSTR IDS_BuildType           = L"BuildType";
LPCWSTR IDS_CodeSet             = L"CodeSet";
LPCWSTR IDS_Installable         = L"Installable";
LPCWSTR IDS_InstallationDate    = L"InstallDate";
LPCWSTR IDS_InUseCount          = L"InUseCount";
LPCWSTR IDS_Locale              = L"Locale";
LPCWSTR IDS_CasePreserved   = L"CasePreserved";
LPCWSTR IDS_CaseSensitive   = L"CaseSensitive";
LPCWSTR IDS_Unicode         = L"Unicode";
LPCWSTR IDS_Archived        = L"Archive";
LPCWSTR IDS_Compressed      = L"Compressed";
LPCWSTR IDS_Created         = L"Created";
LPCWSTR IDS_Extension       = L"Extension";
LPCWSTR IDS_FileType        = L"FileType";
LPCWSTR IDS_LastAccessed    = L"LastAccessed";
LPCWSTR IDS_LastModified    = L"LastModified";
LPCWSTR IDS_Open            = L"Open";
LPCWSTR IDS_Path            = L"Path";
LPCWSTR IDS_Readable        = L"Readable";
LPCWSTR IDS_Size            = L"Size";
LPCWSTR IDS_Writeable       = L"Writeable";
LPCWSTR IDS_ServiceType = L"ServiceType";
LPCWSTR IDS_State       = L"State";
LPCWSTR IDS_ServiceName     = L"ServiceName";
LPCWSTR IDS_Status          = L"Status";
LPCWSTR IDS_StatusInfo      = L"StatusInfo";
LPCWSTR IDS_MaxNumberControlled = L"MaxNumberControlled";
LPCWSTR IDS_TimeOfLastReset     = L"TimeOfLastReset";
LPCWSTR IDS_ProtocolSupported    = L"ProtocolSupported";
LPCWSTR IDS_BatteryChargeStatus         = L"BatteryChargeStatus";
LPCWSTR IDS_BatteryInstalled            = L"BatteryInstalled";
LPCWSTR IDS_BatteryLifeLeft             = L"BatteryLifeLeft";
LPCWSTR IDS_BatteryLifetime             = L"BatteryLifetime";
LPCWSTR IDS_CanTurnOffRemotely          = L"CanTurnOffRemotely";
LPCWSTR IDS_CommandFile                 = L"CommandFile";
LPCWSTR IDS_FirstMessageDelay           = L"FirstMessageDelay";
LPCWSTR IDS_LowBatterySignal            = L"LowBatterySignal";
LPCWSTR IDS_MessageInterval             = L"MessageInterval";
LPCWSTR IDS_RemainingCapacityStatus     = L"RemainingCapacityStatus";
LPCWSTR IDS_EstimatedChargeRemaining    = L"EstimatedChargeRemaining";
LPCWSTR IDS_EstimatedRunTime            = L"EstimatedRunTime";
LPCWSTR IDS_PowerFailSignal             = L"PowerFailSignal";
LPCWSTR IDS_RechargeRate                = L"RechargeRate";
LPCWSTR IDS_Type                        = L"Type";
LPCWSTR IDS_UPSPort                     = L"UPSPort";
LPCWSTR IDS_VoltageCapability           = L"VoltageCapability";
LPCWSTR IDS_FreeSpace                                   = L"FreeSpace";
LPCWSTR IDS_PeakUsage                                   = L"PeakUsage";
LPCWSTR IDS_LastBootupTime                              = L"LastBootupTime";
LPCWSTR IDS_SupportContact                              = L"SupportContact";
LPCWSTR IDS_SupportContactDescription   = L"SupportContactDescription";
LPCWSTR IDS_SystemTime                                  = L"SystemTime";
LPCWSTR IDS_ConnectionlessService       = L"ConnectionlessService";
LPCWSTR IDS_GuaranteesDelivery          = L"GuaranteesDelivery";
LPCWSTR IDS_GuaranteesSequencing        = L"GuaranteesSequencing";
LPCWSTR IDS_MaximumAddressSize          = L"MaximumAddressSize";
LPCWSTR IDS_MaximumMessageSize          = L"MaximumMessageSize";
LPCWSTR IDS_MessageOriented             = L"MessageOriented";
LPCWSTR IDS_MinimumAddressSize          = L"MinimumAddressSize";
LPCWSTR IDS_PseudoStreamOriented        = L"PseudoStreamOriented";
LPCWSTR IDS_SupportsBroadcasting        = L"SupportsBroadcasting";
LPCWSTR IDS_SupportsConnectData         = L"SupportsConnectData";
LPCWSTR IDS_SupportsDisconnectData      = L"SupportsDisconnectData";
LPCWSTR IDS_SupportsEncryption          = L"SupportsEncryption";
LPCWSTR IDS_SupportsExpeditedData       = L"SupportsExpeditedData";
LPCWSTR IDS_SupportsFragmentation       = L"SupportsFragmentation";
LPCWSTR IDS_SupportsGracefulClosing     = L"SupportsGracefulClosing";
LPCWSTR IDS_SupportsGuaranteedBandwidth = L"SupportsGuaranteedBandwidth";
LPCWSTR IDS_SupportsMulticasting        = L"SupportsMulticasting";
LPCWSTR IDS_SupportsQualityofService    = L"SupportsQualityofService";
LPCWSTR IDS_ExecutableType  = L"ExecutableType";
LPCWSTR IDS_DeviceIsBusy = L"DeviceIsBusy";
LPCWSTR IDS_DeviceID    = L"DeviceID";
LPCWSTR IDS_AdapterType     = L"AdapterType";
LPCWSTR IDS_AdapterTypeID   = L"AdapterTypeID";
LPCWSTR IDS_Index           = L"Index";
LPCWSTR IDS_IOPortAddress   = L"IOPortAddress";
LPCWSTR IDS_MACAddress      = L"MACAddress";
LPCWSTR IDS_Baud            = L"Baud";
LPCWSTR IDS_ByteSize        = L"ByteSize";
LPCWSTR IDS_DSRSensitivity  = L"DSRSensitivity";
LPCWSTR IDS_DTRControl      = L"DTRControl";
LPCWSTR IDS_OutTxCTSFlow    = L"OutTxCtsFlow";
LPCWSTR IDS_OutTxDSRFlow    = L"OutTxDsrFlow";
LPCWSTR IDS_Parity          = L"Parity";
LPCWSTR IDS_SIDType         = L"SIDType";
LPCWSTR IDS_SID             = L"SID";
LPCWSTR IDS_GroupComponent  = L"GroupComponent";
LPCWSTR IDS_PartComponent   = L"PartComponent";
LPCWSTR IDS_ParityEnabled   = L"ParityEnabled";
LPCWSTR IDS_StopBits        = L"StopBits";
LPCWSTR IDS_MaxClockSpeed   = L"MaxClockSpeed";
LPCWSTR IDS_CurrentClockSpeed   = L"CurrentClockSpeed";
LPCWSTR IDS_Family          = L"Family";
LPCWSTR IDS_Role            = L"Role";
LPCWSTR IDS_Architecture    = L"Architecture";
LPCWSTR IDS_Stepping            = L"Stepping";
LPCWSTR IDS_Revision        = L"Revision";
LPCWSTR IDS_L2CacheSize     = L"L2CacheSize";
LPCWSTR IDS_L2CacheSpeed    = L"L2CacheSpeed";
LPCWSTR IDS_UpgradeMethod   = L"UpgradeMethod";
LPCWSTR IDS_Layout                  = L"Layout";
LPCWSTR IDS_NumberOfFunctionKeys    = L"NumberOfFunctionKeys";
LPCWSTR IDS_ConnectionMode              = L"ConnectionMode";
LPCWSTR IDS_HardwareID                  = L"HardwareID";
LPCWSTR IDS_MaximumTransmissionSpeed    = L"MaximumTransmissionSpeed";
LPCWSTR IDS_Mode                        = L"Mode";
LPCWSTR IDS_TransmissionSpeed           = L"TransmissionSpeed";
LPCWSTR IDS_ButtonsSwapped          = L"ButtonsSwapped";
LPCWSTR IDS_ConnectMultiplePorts    = L"ConnectMultiplePorts";
LPCWSTR IDS_DataQueueSize           = L"DataQueueSize";
LPCWSTR IDS_DriverName              = L"DriverName";
LPCWSTR IDS_DeviceInterface         = L"DeviceInterface";
LPCWSTR IDS_HardwareType            = L"HardwareType";
LPCWSTR IDS_HorizontalMickeys       = L"HorizontalMickeys";
LPCWSTR IDS_MaximumPortsServiced    = L"MaximumPortsServiced";
LPCWSTR IDS_NumberOfButtons         = L"NumberOfButtons";
LPCWSTR IDS_PointerType             = L"PointerType";
LPCWSTR IDS_Resolution              = L"Resolution";
LPCWSTR IDS_Speed                   = L"Speed";
LPCWSTR IDS_Synch                   = L"Synch";
LPCWSTR IDS_VerticalMickeys         = L"VerticalMickeys";
LPCWSTR IDS_XThreshold              = L"XThreshold";
LPCWSTR IDS_YThreshold              = L"YThreshold";
LPCWSTR IDS_ZThreshold              = L"ZThreshold";
LPCWSTR IDS_AveragePagesPerMinute       = L"AveragePagesPerMinute";
LPCWSTR IDS_PrintProcessorParameters    = L"PrintProcessorParameters";
LPCWSTR IDS_SpoolEnabled                        = L"SpoolEnabled";
LPCWSTR IDS_Processor                   = L"Processor";
LPCWSTR IDS_ElapsedTime     = L"ElapsedTime";
LPCWSTR IDS_JobDestination  = L"JobDestination";
LPCWSTR IDS_Notify          = L"Notify";
LPCWSTR IDS_Owner           = L"Owner";
LPCWSTR IDS_Priority        = L"Priority";
LPCWSTR IDS_StartTime       = L"StartTime";
LPCWSTR IDS_TimeSubmitted   = L"TimeSubmitted";
LPCWSTR IDS_UntilTime       = L"UntilTime";
LPCWSTR IDS_MediaLoaded         = L"MediaLoaded";
LPCWSTR IDS_MediaType           = L"MediaType";
LPCWSTR IDS_MediaRemovable      = L"MediaRemovable";
LPCWSTR IDS_Compression             = L"Compression";
LPCWSTR IDS_DefaultBlockSize        = L"DefaultBlockSize";
LPCWSTR IDS_ECC                     = L"ECC";
LPCWSTR IDS_EndOfTapeWarningZoneSize      = L"EOTWarningZoneSize";
LPCWSTR IDS_FeaturesHigh            = L"FeaturesHigh";
LPCWSTR IDS_FeaturesLow             = L"FeaturesLow";
LPCWSTR IDS_MaximumBlockSize        = L"MaxBlockSize";
LPCWSTR IDS_MaximumPartitionCount   = L"MaxPartitionCount";
LPCWSTR IDS_MinimumBlockSize        = L"MinBlockSize";
LPCWSTR IDS_Padding                 = L"Padding";
LPCWSTR IDS_ReportSetMarks          = L"ReportSetMarks";
LPCWSTR IDS_BytesPerSector          = L"BytesPerSector";
LPCWSTR IDS_InterfaceType           = L"InterfaceType";
LPCWSTR IDS_Partitions              = L"Partitions";
LPCWSTR IDS_Signature               = L"Signature";
LPCWSTR IDS_TotalCylinders          = L"TotalCylinders";
LPCWSTR IDS_TotalSectors            = L"TotalSectors";
LPCWSTR IDS_TotalTracks             = L"TotalTracks";
LPCWSTR IDS_TracksPerCylinder       = L"TracksPerCylinder";
LPCWSTR IDS_SectorsPerTrack         = L"SectorsPerTrack";
LPCWSTR IDS_TotalBadSectors         = L"TotalBadSectors";
LPCWSTR IDS_LandingZoneCylinder     = L"LandingZoneCylinder";
LPCWSTR IDS_WritePrecompCylinder    = L"WritePrecompCylinder";
LPCWSTR IDS_TotalHeads              = L"TotalHeads";
LPCWSTR IDS_BootDirectory        = L"BootDirectory";
LPCWSTR IDS_ConfigurationPath    = L"ConfigurationPath";
LPCWSTR IDS_LastDrive            = L"LastDrive";
LPCWSTR IDS_ScratchDirectory     = L"ScratchDirectory";
LPCWSTR IDS_TempDirectory        = L"TempDirectory";
LPCWSTR IDS_BorderWidth              = L"BorderWidth";
LPCWSTR IDS_CoolSwitch               = L"CoolSwitch";
LPCWSTR IDS_CursorBlinkRate          = L"CursorBlinkRate";
LPCWSTR IDS_DragFullWindows          = L"DragFullWindows";
LPCWSTR IDS_GridGranularity          = L"GridGranularity";
LPCWSTR IDS_IconSpacing              = L"IconSpacing";
LPCWSTR IDS_IconTitleFaceName        = L"IconTitleFaceName";
LPCWSTR IDS_IconTitleSize            = L"IconTitleSize";
LPCWSTR IDS_IconTitleWrap            = L"IconTitleWrap";
LPCWSTR IDS_IconFont                 = L"IconFont";
LPCWSTR IDS_Pattern                  = L"Pattern";
LPCWSTR IDS_ScreenSaverActive        = L"ScreenSaverActive";
LPCWSTR IDS_ScreenSaverExecutable    = L"ScreenSaverExecutable";
LPCWSTR IDS_ScreenSaverSecure        = L"ScreenSaverSecure";
LPCWSTR IDS_ScreenSaverTimeout       = L"ScreenSaverTimeout";
LPCWSTR IDS_Wallpaper                = L"Wallpaper";
LPCWSTR IDS_WallpaperTiled           = L"WallpaperTiled";
LPCWSTR IDS_AvailableVirtualMemory   = L"AvailableVirtualMemory";
LPCWSTR IDS_TotalPageFileSpace       = L"TotalPageFileSpace";
LPCWSTR IDS_TotalPhysicalMemory      = L"TotalPhysicalMemory";
LPCWSTR IDS_TotalVirtualMemory       = L"TotalVirtualMemory";
LPCWSTR IDS_GroupName = L"GroupName";
LPCWSTR IDS_AccountExpires       = L"AccountExpires";
LPCWSTR IDS_AuthorizationFlags   = L"AuthorizationFlags";
LPCWSTR IDS_BadPasswordCount     = L"BadPasswordCount";
LPCWSTR IDS_CodePage             = L"CodePage";
LPCWSTR IDS_Comment              = L"Comment";
LPCWSTR IDS_CountryCode          = L"CountryCode";
LPCWSTR IDS_Flags                = L"Flags";
LPCWSTR IDS_FullName             = L"FullName";
LPCWSTR IDS_HomeDirectory        = L"HomeDirectory";
LPCWSTR IDS_HomeDirectoryDrive   = L"HomeDirectoryDrive";
LPCWSTR IDS_LastLogoff           = L"LastLogoff";
LPCWSTR IDS_LastLogon            = L"LastLogon";
LPCWSTR IDS_LogonHours           = L"LogonHours";
LPCWSTR IDS_LogonServer          = L"LogonServer";
LPCWSTR IDS_MaximumStorage       = L"MaximumStorage";
LPCWSTR IDS_NumberOfLogons       = L"NumberOfLogons";
LPCWSTR IDS_Parms                = L"Parameters";
LPCWSTR IDS_Password             = L"Password";
LPCWSTR IDS_PasswordAge          = L"PasswordAge";
LPCWSTR IDS_PasswordExpired      = L"PasswordExpired";
LPCWSTR IDS_PrimaryGroupId       = L"PrimaryGroupId";
LPCWSTR IDS_Privileges           = L"Privileges";
LPCWSTR IDS_Profile              = L"Profile";
LPCWSTR IDS_ScriptPath           = L"ScriptPath";
LPCWSTR IDS_UnitsPerWeek         = L"UnitsPerWeek";
LPCWSTR IDS_UserComment          = L"UserComment";
LPCWSTR IDS_UserId               = L"UserId";
LPCWSTR IDS_UserType             = L"UserType";
LPCWSTR IDS_Workstations         = L"Workstations";
LPCWSTR IDS_DefaultIPGateway     = L"DefaultIPGateway";
LPCWSTR IDS_DHCPEnabled          = L"DHCPEnabled";
LPCWSTR IDS_DHCPLeaseExpires     = L"DHCPLeaseExpires";
LPCWSTR IDS_DHCPLeaseObtained    = L"DHCPLeaseObtained";
LPCWSTR IDS_DHCPServer           = L"DHCPServer";
LPCWSTR IDS_IOAddress            = L"IOAddress";
LPCWSTR IDS_IPAddress            = L"IPAddress";
LPCWSTR IDS_IPSubnet             = L"IPSubnet";
LPCWSTR IDS_IPXAddress           = L"IPXAddress";
LPCWSTR IDS_IRQ                  = L"IRQ";
LPCWSTR IDS_AbortReadOrWriteOnError = L"AbortReadOrWriteOnError";
LPCWSTR IDS_BaudRate                = L"BaudRate";
LPCWSTR IDS_BinaryModeEnabled       = L"BinaryModeEnabled";
LPCWSTR IDS_BitsPerByte             = L"BitsPerByte";
LPCWSTR IDS_ContinueTransmitOnXOff  = L"ContinueTransmitOnXOff";
LPCWSTR IDS_CTSOutflowControl       = L"CTSOutflowControl";
LPCWSTR IDS_DiscardNULLBytes        = L"DiscardNULLBytes";
LPCWSTR IDS_DSROutflowControl       = L"DSROutflowControl";
LPCWSTR IDS_DTRFlowControlType      = L"DTRFlowControlType";
LPCWSTR IDS_EndOfFileCharacter      = L"EOFCharacter";
LPCWSTR IDS_ContinueXMitOnXOff            = L"ContinueXMitOnXOff";
LPCWSTR IDS_AbortReadWriteOnError         = L"AbortReadWriteOnError";
LPCWSTR IDS_ErrorReplaceCharacter   = L"ErrorReplaceCharacter";
LPCWSTR IDS_ErrorReplacementEnabled = L"ErrorReplacementEnabled";
LPCWSTR IDS_EventCharacter          = L"EventCharacter";
LPCWSTR IDS_IsBusy                  = L"IsBusy";
LPCWSTR IDS_ParityCheckEnabled      = L"ParityCheckEnabled";
LPCWSTR IDS_RTSFlowControlType      = L"RTSFlowControlType";
LPCWSTR IDS_XOffCharacter           = L"XOffCharacter";
LPCWSTR IDS_XOffTransmitThreshold   = L"XOffTransmitThreshold";
LPCWSTR IDS_XOnCharacter            = L"XOnCharacter";
LPCWSTR IDS_XOnTransmitThreshold    = L"XOnTransmitThreshold";
LPCWSTR IDS_XOnXOffInflowControl    = L"XOnXOffInflowControl";
LPCWSTR IDS_XOnXOffOutflowControl   = L"XOnXOffOutflowControl";
LPCWSTR IDS_DaylightInEffect     = L"DaylightInEffect";
LPCWSTR IDS_Bias                 = L"Bias";
LPCWSTR IDS_StandardName         = L"StandardName";
LPCWSTR IDS_StandardYear         = L"StandardYear";
LPCWSTR IDS_StandardMonth        = L"StandardMonth";
LPCWSTR IDS_StandardDayOfWeek    = L"StandardDayOfWeek";
LPCWSTR IDS_StandardDay          = L"StandardDay";
LPCWSTR IDS_StandardHour         = L"StandardHour";
LPCWSTR IDS_StandardMinute       = L"StandardMinute";
LPCWSTR IDS_StandardSecond       = L"StandardSecond";
LPCWSTR IDS_StandardMillisecond  = L"StandardMillisecond";
LPCWSTR IDS_StandardBias         = L"StandardBias";
LPCWSTR IDS_DaylightName         = L"DaylightName";
LPCWSTR IDS_DaylightYear         = L"DaylightYear";
LPCWSTR IDS_DaylightMonth        = L"DaylightMonth";
LPCWSTR IDS_DaylightDayOfWeek    = L"DaylightDayOfWeek";
LPCWSTR IDS_DaylightDay          = L"DaylightDay";
LPCWSTR IDS_DaylightHour         = L"DaylightHour";
LPCWSTR IDS_DaylightMinute       = L"DaylightMinute";
LPCWSTR IDS_DaylightSecond       = L"DaylightSecond";
LPCWSTR IDS_DaylightMillisecond  = L"DaylightMillisecond";
LPCWSTR IDS_DaylightBias         = L"DaylightBias";
LPCWSTR IDS_ConnectionType   = L"ConnectionType";
LPCWSTR IDS_RemotePath       = L"RemotePath";
LPCWSTR IDS_LocalName        = L"LocalName";
LPCWSTR IDS_RemoteName       = L"RemoteName";
LPCWSTR IDS_ProviderName     = L"ProviderName";
LPCWSTR IDS_DisplayType      = L"DisplayType";
LPCWSTR IDS_ResourceType     = L"ResourceType";
LPCWSTR IDS_GroupOrder = L"GroupOrder";
LPCWSTR IDS_CommandLine      = L"CommandLine";
LPCWSTR IDS_Dependencies     = L"Dependencies";
LPCWSTR IDS_DisplayName      = L"DisplayName";
LPCWSTR IDS_ErrorControl     = L"ErrorControl";
LPCWSTR IDS_LoadOrderGroup   = L"LoadOrderGroup";
LPCWSTR IDS_PathName         = L"PathName";
LPCWSTR IDS_StartName        = L"StartName";
LPCWSTR IDS_StartType        = L"StartType";
LPCWSTR IDS_TagId            = L"TagId";
LPCWSTR IDS_AcceptStop       = L"AcceptStop";
LPCWSTR IDS_AcceptPause      = L"AcceptPause";
LPCWSTR IDS_AutomaticResetBootOption     = L"AutomaticResetBootOption";
LPCWSTR IDS_AutomaticResetCapability     = L"AutomaticResetCapability";
LPCWSTR IDS_AutomaticResetStatus         = L"AutomaticResetStatus";
LPCWSTR IDS_AutomaticResetTimerInterval  = L"AutomaticResetTimerInterval";
LPCWSTR IDS_AutomaticResetTimerReset     = L"AutomaticResetTimerReset";
LPCWSTR IDS_BootRomSupported             = L"BootROMSupported";
LPCWSTR IDS_BootupState                  = L"BootupState";
LPCWSTR IDS_ConditionalReboot            = L"ConditionalReboot";
LPCWSTR IDS_InfraredSupported            = L"InfraredSupported";
LPCWSTR IDS_LockKeyboardAndMouse         = L"LockKeyboardAndMouse";
LPCWSTR IDS_LockPCPowerOnAndResetButtons = L"LockPCPowerOnAndResetButtons";
LPCWSTR IDS_LockSystem                   = L"LockSystem";
LPCWSTR IDS_NetworkServerModeEnabled     = L"NetworkServerModeEnabled";
LPCWSTR IDS_PowerManagementSupported     = L"PowerManagementSupported";
LPCWSTR IDS_PowerManagementCapabilities  = L"PowerManagementCapabilities";
LPCWSTR IDS_PowerManagementEnabled               = L"PowerManagementEnabled";
LPCWSTR IDS_ResetBootOption              = L"ResetBootOption";
LPCWSTR IDS_ResetTimeout                 = L"ResetTimeout";
LPCWSTR IDS_SystemCreationClassName              = L"SystemCreationClassName";
LPCWSTR IDS_SystemName                                           = L"SystemName";
LPCWSTR IDS_SystemFilesNotModified       = L"SystemFilesNotModified";
LPCWSTR IDS_SystemRole                   = L"SystemRole";
LPCWSTR IDS_SystemType                   = L"SystemType";
LPCWSTR IDS_NumberOfProcessors           = L"NumberOfProcessors";
LPCWSTR IDS_UnconditionalReboot          = L"UnconditionalReboot";
LPCWSTR IDS_UserName                     = L"UserName";
LPCWSTR IDS_ExecutablePath               = L"ExecutablePath";
LPCWSTR IDS_Exited                       = L"Exited";
LPCWSTR IDS_MaximumWorkingSetSize        = L"MaximumWorkingSetSize";
LPCWSTR IDS_MinimumWorkingSetSize        = L"MinimumWorkingSetSize";
LPCWSTR IDS_PageFaults                   = L"PageFaults";
LPCWSTR IDS_PageFileUsage                = L"PageFileUsage";
LPCWSTR IDS_PeakPageFileUsage            = L"PeakPageFileUsage";
LPCWSTR IDS_PeakWorkingSetSize           = L"PeakWorkingSetSize";
LPCWSTR IDS_QuotaNonPagedPoolUsage       = L"QuotaNonPagedPoolUsage";
LPCWSTR IDS_QuotaPagedPoolUsage          = L"QuotaPagedPoolUsage";
LPCWSTR IDS_QuotaPeakNonPagedPoolUsage   = L"QuotaPeakNonPagedPoolUsage";
LPCWSTR IDS_QuotaPeakPagedPoolUsage      = L"QuotaPeakPagedPoolUsage";
LPCWSTR IDS_ThreadCount                  = L"ThreadCount";
LPCWSTR IDS_KernelModeTime                               = L"KernelModeTime";
LPCWSTR IDS_UserModeTime                                 = L"UserModeTime";
LPCWSTR IDS_WindowsVersion               = L"WindowsVersion";
LPCWSTR IDS_Characteristics  = L"Characteristics[]";
LPCWSTR IDS_EndingAddress    = L"EndingAddress";
LPCWSTR IDS_PrimaryBIOS      = L"PrimaryBIOS";
LPCWSTR IDS_ReleaseDate      = L"ReleaseDate";
LPCWSTR IDS_StartingAddress  = L"StartingAddress";
LPCWSTR IDS_Verify           = L"Verify";
LPCWSTR IDS_BootDevice           = L"BootDevice";
LPCWSTR IDS_CSDVersion           = L"CSDVersion";
LPCWSTR IDS_Primary              = L"Primary";
LPCWSTR IDS_SystemDirectory      = L"SystemDirectory";
LPCWSTR IDS_SystemStartOptions   = L"SystemStartOptions";
LPCWSTR IDS_WindowsDirectory     = L"WindowsDirectory";
LPCWSTR IDS_EnforcesACLs   = L"EnforcesACLs";
LPCWSTR IDS_DeviceType          = L"DeviceType";
LPCWSTR IDS_Length              = L"Length";
LPCWSTR IDS_ShareDisposition    = L"ShareDisposition";
LPCWSTR IDS_Start               = L"Start";
LPCWSTR IDS_DeviceDescriptorBlock    = L"DeviceDescriptorBlock";
LPCWSTR IDS_IdentiferNumber          = L"IdentiferNumber";
LPCWSTR IDS_PM_API                   = L"PM_API";
LPCWSTR IDS_ServiceTableSize         = L"ServiceTableSize";
LPCWSTR IDS_V86_API                  = L"V86_API";
LPCWSTR IDS_AccountDisabled              = L"AccountDisabled";
LPCWSTR IDS_AccountLockout               = L"AccountLockout";
LPCWSTR IDS_CannotChangePassword         = L"CannotChangePassword";
LPCWSTR IDS_ChangePasswordOnNextLogon    = L"ChangePasswordOnNextLogon";
LPCWSTR IDS_Domain                       = L"Domain";
LPCWSTR IDS_Organization                 = L"Organization";
LPCWSTR IDS_Phone                        = L"Phone";
LPCWSTR IDS_AddressRange     = L"AddressRange";
LPCWSTR IDS_MemoryType       = L"MemoryType";
LPCWSTR IDS_BurstMode    = L"BurstMode";
LPCWSTR IDS_DMAChannel   = L"DMAChannel";
LPCWSTR IDS_ChannelWidth = L"ChannelWidth";
LPCWSTR IDS_Port         = L"Port";
LPCWSTR IDS_AffinityMask     = L"AffinityMask";
LPCWSTR IDS_Availability     = L"Availability";
LPCWSTR IDS_InterruptType    = L"InterruptType";
LPCWSTR IDS_IRQNumber        = L"IRQNumber";
LPCWSTR IDS_Level            = L"Level";
LPCWSTR IDS_Shareable        = L"Shareable";
LPCWSTR IDS_TriggerType      = L"TriggerType";
LPCWSTR IDS_Vector           = L"Vector";
LPCWSTR IDS_Address = L"Address";
LPCWSTR IDS_ProductName = L"ProductName";
LPCWSTR IDS_Binary                   = L"Binary";
LPCWSTR IDS_MaximumBaudRate          = L"MaxBaudRate";
LPCWSTR IDS_MaximumInputBufferSize   = L"MaximumInputBufferSize";
LPCWSTR IDS_MaximumOutputBufferSize  = L"MaximumOutputBufferSize";
LPCWSTR IDS_ProviderType             = L"ProviderType";
LPCWSTR IDS_SettableBaudRate         = L"SettableBaudRate";
LPCWSTR IDS_SettableDataBits         = L"SettableDataBits";
LPCWSTR IDS_SettableFlowControl      = L"SettableFlowControl";
LPCWSTR IDS_SettableParity           = L"SettableParity";
LPCWSTR IDS_SettableParityCheck      = L"SettableParityCheck";
LPCWSTR IDS_SettableRLSD             = L"SettableRLSD";
LPCWSTR IDS_SettableStopBits         = L"SettableStopBits";
LPCWSTR IDS_Supports16BitMode        = L"Supports16BitMode";
LPCWSTR IDS_SupportsDTRDSR           = L"SupportsDTRDSR";
LPCWSTR IDS_SupportsIntervalTimeouts = L"SupportsIntTimeouts";
LPCWSTR IDS_SupportsParityCheck      = L"SupportsParityCheck";
LPCWSTR IDS_SupportsRLSD             = L"SupportsRLSD";
LPCWSTR IDS_SupportsRTSCTS           = L"SupportsRTSCTS";
LPCWSTR IDS_SupportsSettableXOnXOff  = L"SupportsXOnXOffSet";
LPCWSTR IDS_SupportsSpecialChars     = L"SupportsSpecialCharacters";
LPCWSTR IDS_SupportsElapsedTimeouts  = L"SupportsElapsedTimeouts";
LPCWSTR IDS_SupportsXOnXOff          = L"SupportsXOnXOff";
LPCWSTR IDS_Capabilities    = L"Capabilities";
LPCWSTR IDS_DmaSupport      = L"DmaSupport";
LPCWSTR IDS_DeviceMap           = L"DeviceMap";
LPCWSTR IDS_HardwareVersion     = L"HardwareVersion";
LPCWSTR IDS_InterruptNumber  = L"InterruptNumber";
LPCWSTR IDS_AttachedTo         = L"AttachedTo";
LPCWSTR IDS_BlindOff           = L"BlindOff";
LPCWSTR IDS_BlindOn            = L"BlindOn";
LPCWSTR IDS_CallSetupFailTimer = L"CallSetupFailTimer";
LPCWSTR IDS_CompatibilityFlags = L"CompatibilityFlags";
LPCWSTR IDS_CompressionOff     = L"CompressionOff";
LPCWSTR IDS_CompressionOn      = L"CompressionOn";
LPCWSTR IDS_ConfigurationDialog= L"ConfigurationDialog";
LPCWSTR IDS_DCB                = L"DCB";
LPCWSTR IDS_Default            = L"Default";
LPCTSTR IDT_Default            = _T("Default");
LPCWSTR IDS_DeviceLoader       = L"DeviceLoader";
LPCWSTR IDS_DialPrefix         = L"DialPrefix";
LPCWSTR IDS_DialSuffix         = L"DialSuffix";
LPCWSTR IDS_DriverDate         = L"DriverDate";
LPCWSTR IDS_ErrorControlForced = L"ErrorControlForced";
LPCWSTR IDS_ErrorControlOff    = L"ErrorControlOff";
LPCWSTR IDS_ErrorControlOn     = L"ErrorControlOn";
LPCWSTR IDS_FlowControlHard    = L"FlowControlHard";
LPCWSTR IDS_FlowControlSoft    = L"FlowControlSoft";
LPCWSTR IDS_FlowControlOff     = L"FlowControlOff";
LPCWSTR IDS_InactivityScale    = L"InactivityScale";
LPCWSTR IDS_InactivityTimeout  = L"InactivityTimeout";
LPCWSTR IDS_ModemInfPath       = L"ModemInfPath";
LPCWSTR IDS_ModemInfSection    = L"ModemInfSection";
LPCWSTR IDS_ModulationBell     = L"ModulationBell";
LPCWSTR IDS_ModulationCCITT    = L"ModulationCCITT";
LPCWSTR IDS_PortSubClass       = L"PortSubClass";
LPCWSTR IDS_Prefix             = L"Prefix";
LPCWSTR IDS_Properties         = L"Properties";
LPCWSTR IDS_Pulse              = L"Pulse";
LPCWSTR IDS_Reset              = L"Reset";
LPCWSTR IDS_Alias              = L"Alias";
LPCWSTR IDS_ResponsesKeyName   = L"ResponsesKeyName";
LPCWSTR IDS_SpeakerModeDial    = L"SpeakerModeDial";
LPCWSTR IDS_SpeakerModeOff     = L"SpeakerModeOff";
LPCWSTR IDS_SpeakerModeOn      = L"SpeakerModeOn";
LPCWSTR IDS_SpeakerModeSetup   = L"SpeakerModeSetup";
LPCWSTR IDS_SpeakerVolumeHigh  = L"SpeakerVolumeHigh";
LPCWSTR IDS_SpeakerVolumeLow   = L"SpeakerVolumeLow";
LPCWSTR IDS_SpeakerVolumeMed   = L"SpeakerVolumeMed";
LPCWSTR IDS_StringFormat       = L"StringFormat";
LPCWSTR IDS_Terminator         = L"Terminator";
LPCWSTR IDS_Tone               = L"Tone";
LPCWSTR IDS_VoiceSwitchFeature = L"VoiceSwitchFeature";
LPCWSTR IDS_PrimaryBusType   = L"PrimaryBusType";
LPCWSTR IDS_SecondaryBusType = L"SecondaryBusType";
LPCWSTR IDS_RevisionNumber   = L"RevisionNumber";
LPCWSTR IDS_EnableWheelDetection = L"EnableWheelDetection";
LPCWSTR IDS_InfFileName          = L"InfFileName";
LPCWSTR IDS_InfSection           = L"InfSection";
LPCWSTR IDS_SampleRate           = L"SampleRate";
LPCWSTR IDS_Attributes           = L"Attributes";
LPCWSTR IDS_DefaultPriority      = L"DefaultPriority";
LPCWSTR IDS_PortName             = L"PortName";
LPCWSTR IDS_PrintJobDataType     = L"PrintJobDataType";
LPCWSTR IDS_SeparatorFile        = L"SeparatorFile";
LPCWSTR IDS_ServerName           = L"ServerName";
LPCWSTR IDS_ShareName            = L"ShareName";
LPCWSTR IDS_DataType         = L"DataType";
LPCWSTR IDS_Document         = L"Document";
LPCWSTR IDS_HostPrintQueue   = L"HostPrintQueue";
LPCWSTR IDS_JobId            = L"JobId";
LPCWSTR IDS_PagesPrinted     = L"PagesPrinted";
LPCWSTR IDS_Parameters       = L"Parameters";
LPCWSTR IDS_PrintProcessor   = L"PrintProcessor";
LPCWSTR IDS_TotalPages       = L"TotalPages";
LPCWSTR IDS_Drive                    = L"Drive";
LPCWSTR IDS_FileSystemFlags          = L"FileSystemFlags";
LPCWSTR IDS_FileSystemFlagsEx        = L"FileSystemFlagsEx";
LPCWSTR IDS_Id                       = L"Id";
LPCWSTR IDS_MaximumComponentLength   = L"MaximumComponentLength";
LPCWSTR IDS_RevisionLevel            = L"RevisionLevel";
LPCWSTR IDS_SCSILun                  = L"SCSILun";
LPCWSTR IDS_SCSITargetId             = L"SCSITargetId";
LPCWSTR IDS_VolumeName               = L"VolumeName";
LPCWSTR IDS_VolumeSerialNumber       = L"VolumeSerialNumber";
LPCWSTR IDS_Disabled                 = L"Disabled";
LPCWSTR IDS_PasswordRequired         = L"PasswordRequired";
LPCWSTR IDS_PasswordChangeable       = L"PasswordChangeable";
LPCWSTR IDS_Lockout                  = L"Lockout";
LPCWSTR IDS_PasswordExpires          = L"PasswordExpires";
LPCWSTR IDS_AccountType              = L"AccountType";
LPCWSTR IDS_SCSIBus         = L"SCSIBus";
LPCWSTR IDS_SCSIPort        = L"SCSIPort";
LPCWSTR IDS_SCSILogicalUnit = L"SCSILogicalUnit";
LPCWSTR IDS_SCSITargetID    = L"SCSITargetID";
LPCWSTR IDS_FileSystem = L"FileSystem";
LPCWSTR IDS_BootPartition    = L"BootPartition";
LPCWSTR IDS_DiskIndex        = L"DiskIndex";
LPCWSTR IDS_Encrypted        = L"Encrypted";
LPCWSTR IDS_HiddenSectors    = L"HiddenSectors";
LPCWSTR IDS_RewritePartition = L"RewritePartition";
LPCWSTR IDS_StartingOffset   = L"StartingOffset";
LPCWSTR IDS_BitsPerPel       = L"BitsPerPel";
LPCWSTR IDS_DeviceName       = L"DeviceName";
LPCWSTR IDS_DisplayFlags     = L"DisplayFlags";
LPCWSTR IDS_DisplayFrequency = L"DisplayFrequency";
LPCWSTR IDS_DitherType       = L"DitherType";
LPCWSTR IDS_DriverVersion    = L"DriverVersion";
LPCWSTR IDS_ICMIntent        = L"ICMIntent";
LPCWSTR IDS_ICMMethod        = L"ICMMethod";
LPCWSTR IDS_LogPixels        = L"LogPixels";
LPCWSTR IDS_PelsHeight       = L"PelsHeight";
LPCWSTR IDS_PelsWidth        = L"PelsWidth";
LPCWSTR IDS_SpecificationVersion = L"SpecificationVersion";
LPCWSTR IDS_TTOption         = L"TTOption";
LPCWSTR IDS_BitsPerPixel                 = L"BitsPerPixel";
LPCWSTR IDS_ColorPlanes                  = L"ColorPlanes";
LPCWSTR IDS_DeviceEntriesInAColorTable   = L"DeviceEntriesInAColorTable";
LPCWSTR IDS_ColorTableEntries            = L"ColorTableEntries";
LPCWSTR IDS_DeviceSpecificPens           = L"DeviceSpecificPens";
LPCWSTR IDS_HorizontalResolution         = L"HorizontalResolution";
LPCWSTR IDS_RefreshRate                  = L"RefreshRate";
LPCWSTR IDS_ReservedSystemPaletteEntries = L"ReservedSystemPaletteEntries";
LPCWSTR IDS_SystemPaletteEntries         = L"SystemPaletteEntries";
LPCWSTR IDS_VerticalResolution           = L"VerticalResolution";
LPCWSTR IDS_VideoMode                    = L"VideoMode";
LPCWSTR IDS_ActualColorResolution        = L"ActualColorResolution";
LPCWSTR IDS_AdapterChipType              = L"AdapterChipType";
LPCWSTR IDS_AdapterCompatibility         = L"AdapterCompatibility";
LPCWSTR IDS_AdapterDACType               = L"AdapterDACType";
LPCWSTR IDS_AdapterDescription           = L"AdapterDescription";
LPCWSTR IDS_AdapterLocale                = L"AdapterLocale";
LPCWSTR IDS_AdapterRAM                   = L"AdapterRAM";
LPCWSTR IDS_InstalledDisplayDrivers      = L"InstalledDisplayDrivers";
LPCWSTR IDS_MonitorManufacturer          = L"MonitorManufacturer";
LPCWSTR IDS_MonitorType                  = L"MonitorType";
LPCWSTR IDS_PixelsPerXLogicalInch        = L"PixelsPerXLogicalInch";
LPCWSTR IDS_PixelsPerYLogicalInch        = L"PixelsPerYLogicalInch";
LPCWSTR IDS_ScanMode                     = L"ScanMode";
LPCWSTR IDS_ScreenHeight                 = L"ScreenHeight";
LPCWSTR IDS_ScreenWidth                  = L"ScreenWidth";
LPCWSTR IDS_Collate          = L"Collate";
LPCWSTR IDS_Color            = L"Color";
LPCWSTR IDS_Copies           = L"Copies";
LPCWSTR IDS_Duplex           = L"Duplex";
LPCWSTR IDS_FormName         = L"FormName";
LPCWSTR IDS_Orientation      = L"Orientation";
LPCWSTR IDS_PaperLength      = L"PaperLength";
LPCWSTR IDS_PaperSize        = L"PaperSize";
LPCWSTR IDS_PaperWidth       = L"PaperWidth";
LPCWSTR IDS_PrintQuality     = L"PrintQuality";
LPCWSTR IDS_Scale            = L"Scale";
LPCWSTR IDS_YResolution      = L"YResolution";
LPCWSTR IDS_VariableName     = L"VariableName";
LPCWSTR IDS_VariableValue    = L"VariableValue";
LPCWSTR IDS_MaximumSize                 = L"MaximumSize";
LPCWSTR IDS_InitialSize                 = L"InitialSize";
LPCWSTR IDS_AllocatedBaseSize   = L"AllocatedBaseSize";
LPCWSTR IDS_CurrentUsage                = L"CurrentUsage";
LPCWSTR IDS_AllowMaximum     = L"AllowMaximum";
LPCWSTR IDS_MaximumAllowed   = L"MaximumAllowed";
LPCWSTR IDS_Location            = L"Location";
LPCWSTR IDS_Unsupported         = L"Unsupported";
LPCWSTR IDS_SupportsDiskQuotas = L"SupportsDiskQuotas";
LPCWSTR IDS_QuotasIncomplete = L"QuotasIncomplete";
LPCWSTR IDS_QuotasRebuilding = L"QuotasRebuilding";
LPCWSTR IDS_QuotasDisabled = L"QuotasDisabled";
LPCWSTR IDS_VolumeDirty = L"VolumeDirty";
LPCWSTR IDS_SessionID = L"SessionID";
LPCWSTR IDS_PerformAutochk = L"PerformAutochk";
LPCWSTR IDS_AuthenticationPackage = L"AuthenticationPackage"; 
LPCWSTR IDS_LogonType = L"LogonType";             
LPCWSTR IDS_LogonTime = L"LogonTime"; 
LPCWSTR IDS_LocalAccount = L"LocalAccount";
            


LPCWSTR IDS_Antecedent  =       L"Antecedent";
LPCWSTR IDS_Dependent   =       L"Dependent";
LPCWSTR IDS_Adapter             =       L"Adapter";
LPCWSTR IDS_Protocol    =       L"Protocol";
LPCWSTR IDS_Service             =       L"Service";
LPCWSTR IDS_Element             =       L"Element";
LPCWSTR IDS_Setting             =       L"Setting";
LPCWSTR IDS_DriveType   =   L"DriveType";
LPCWSTR IDS_LogonId             =   L"LogonId" ;

LPCWSTR  IDS_GETLASTERROR   = L"GetLastError() reports %d (%X)";


LPCWSTR IDS_CimWin32Namespace   =       L"root\\cimv2";

LPCWSTR IDS_CfgMgrDeviceStatus_OK       =       L"OK";
LPCWSTR IDS_CfgMgrDeviceStatus_ERR      =       L"Error";

WCHAR szBusType[KNOWN_BUS_TYPES][20] = {

    { L"Internal"         },
    { L"Isa"              },
    { L"Eisa"             },
    { L"MicroChannel"     },
    { L"TurboChannel"     },
    { L"PCI"              },
    { L"VME"              },
    { L"Nu"               },
    { L"PCMCIA"           },
    { L"C"                },
    { L"MPI"              },
    { L"MPSA"             },
    { L"ProcessorInternal"},
    { L"InternalPower"    },
    { L"PNPISA"           },
    { L"PNP"              }/*,
    { "USB"              }*/  // USB busses are PNP busses
} ;

LPCWSTR IDS_CurrentTimeZone = L"CurrentTimeZone";
LPCWSTR IDS_NameFormat = L"NameFormat";
LPCWSTR IDS_Roles = L"Roles";
LPCWSTR IDS_DomainRole = L"DomainRole";
LPCWSTR IDS_PrimaryOwnerContact = L"PrimaryOwnerContact";
LPCWSTR IDS_SystemStartupDelay = L"SystemStartupDelay";
LPCWSTR IDS_SystemVariable = L"SystemVariable";

LPCWSTR IDS_PRINTER_STATUS_PAUSED                       = L"Paused";
LPCWSTR IDS_PRINTER_STATUS_PENDING_DELETION = L"Pending Deletion";
LPCWSTR IDS_PRINTER_STATUS_BUSY                         = L"Busy";
LPCWSTR IDS_PRINTER_STATUS_DOOR_OPEN            = L"Door Open";
LPCWSTR IDS_PRINTER_STATUS_ERROR                        = L"Error";
LPCWSTR IDS_PRINTER_STATUS_INITIALIZING         = L"Initializing";
LPCWSTR IDS_PRINTER_STATUS_IO_ACTIVE            = L"I/O Active";
LPCWSTR IDS_PRINTER_STATUS_MANUAL_FEED          = L"Manual Feed";
LPCWSTR IDS_PRINTER_STATUS_NO_TONER                     = L"No Toner";
LPCWSTR IDS_PRINTER_STATUS_NOT_AVAILABLE        = L"Not Available";
LPCWSTR IDS_PRINTER_STATUS_OFFLINE                      = L"Offline";
LPCWSTR IDS_PRINTER_STATUS_OUT_OF_MEMORY        = L"Out of Memory";
LPCWSTR IDS_PRINTER_STATUS_OUTPUT_BIN_FULL      = L"Output Bin Full";
LPCWSTR IDS_PRINTER_STATUS_PAGE_PUNT            = L"Page Punt";
LPCWSTR IDS_PRINTER_STATUS_PAPER_JAM            = L"Paper Jam";
LPCWSTR IDS_PRINTER_STATUS_PAPER_OUT            = L"Paper Out";
LPCWSTR IDS_PRINTER_STATUS_PAPER_PROBLEM        = L"Paper Problem";
LPCWSTR IDS_PRINTER_STATUS_PRINTING                     = L"Printing";
LPCWSTR IDS_PRINTER_STATUS_PROCESSING           = L"Processing";
LPCWSTR IDS_PRINTER_STATUS_TONER_LOW            = L"Toner Low";
LPCWSTR IDS_PRINTER_STATUS_UNAVAILABLE          = L"Unavailable";
LPCWSTR IDS_PRINTER_STATUS_USER_INTERVENTION = L"User Intervention";
LPCWSTR IDS_PRINTER_STATUS_WAITING                      = L"Waiting";
LPCWSTR IDS_PRINTER_STATUS_WARMING_UP           = L"Warming Up";
LPCWSTR IDS_DetectedErrorState              = L"DetectedErrorState";
LPCWSTR IDS_Ready = L"Ready";

LPCWSTR IDS_STATUS_OK                   = L"OK";
LPCWSTR IDS_STATUS_Degraded     = L"Degraded";
LPCWSTR IDS_STATUS_Error                = L"Error";
LPCWSTR IDS_STATUS_Unknown      = L"Unknown";
LPCWSTR IDS_PrinterStatus       = L"PrinterStatus";
LPCWSTR IDS_PaperSizeSupported  = L"PaperSizeSupported";
LPCWSTR IDS_Persistent  = L"Persistent Connection";
LPCWSTR IDS_Resource_Remembered = L"RESOURCE REMEMBERED";
LPCWSTR IDS_Current     = L"Current Connection";
LPCWSTR IDS_Resource_Connected = L"RESOURCE CONNECTED";

LPCWSTR IDS_LM_Workstation = L"LM_Workstation";
LPCWSTR IDS_LM_Server = L"LM_Server";
LPCWSTR IDS_SQLServer = L"SQLServer";
LPCWSTR IDS_Domain_Controller = L"Primary_Domain_Controller";
LPCWSTR IDS_Domain_Backup_Controller = L"Backup_Domain_Controller";
LPCWSTR IDS_Timesource = L"Timesource";
LPCWSTR IDS_AFP = L"Apple_File_Protocol";
LPCWSTR IDS_Novell = L"Novell";
LPCWSTR IDS_Domain_Member = L"Domain_Member";
LPCWSTR IDS_Local_List_Only = L"Local_List_Only";
LPCWSTR IDS_Print = L"Print";
LPCWSTR IDS_DialIn = L"DialIn";
LPCWSTR IDS_Xenix_Server = L"Xenix_Server";
LPCWSTR IDS_MFPN = L"MFPN";
LPCWSTR IDS_NT = L"NT";
LPCWSTR IDS_WFW = L"Windows_For_Workgroups";
LPCWSTR IDS_Server_NT = L"Server_NT";
LPCWSTR IDS_Potential_Browser = L"Potential_Browser";
LPCWSTR IDS_Backup_Browser = L"Backup_Browser";
LPCWSTR IDS_Master_Browser = L"Master_Browser";
LPCWSTR IDS_Domain_Master = L"Domain_Master";
LPCWSTR IDS_Domain_Enum = L"Domain_Enum";
LPCWSTR IDS_Windows_9x = L"Windows_9x";
LPCWSTR IDS_DFS = L"DFS";
LPCWSTR IDS_JobStatus = L"JobStatus";

LPCWSTR IDS_UPSName = L"Uninterruptible Power Supply";
LPCWSTR IDS_UPSBatteryName = L"Uninterruptible Power Supply Battery";
LPCWSTR IDS_BatteryName = L"Internal Battery";

LPCWSTR IDS_PNPDeviceID = L"PNPDeviceID";
LPCWSTR IDS_ClassGuid = L"ClassGuid";
LPCWSTR IDS_ConfigManagerErrorCode = L"ConfigManagerErrorCode";
LPCWSTR IDS_ConfigManagerUserConfig = L"ConfigManagerUserConfig";

LPCWSTR IDS_ProcessCreationClassName    = L"ProcessCreationClassName";
LPCWSTR IDS_ProcessHandle                               = L"ProcessHandle";
LPCWSTR IDS_ExecutionState                              = L"ExecutionState";
LPCWSTR IDS_PriorityBase                                = L"PriorityBase";
LPCWSTR IDS_StartAddress                                = L"StartAddress";
LPCWSTR IDS_ThreadState                                 = L"ThreadState";
LPCWSTR IDS_ThreadWaitReason                    = L"ThreadWaitReason";

LPCWSTR IDS_OSAutoDiscovered                    = L"OSAutoDiscovered";

// Security provider related strings:
LPCWSTR IDS_SecuredObject     = L"SecuredObject";
LPCWSTR IDS_Account = L"Account";
LPCWSTR IDS_AccountName = L"AccountName";
LPCWSTR IDS_ReferencedDomainName = L"ReferencedDomainName";
LPCWSTR IDS_AceType = L"AceType";
LPCWSTR IDS_AceFlags = L"AceFlags";
LPCWSTR IDS_AccessMask = L"AccessMask";
LPCWSTR IDS_OwnedObject = L"ownedObject";
LPCWSTR IDS_InheritedObjectGUID = L"GuidInheritedObjectType";
LPCWSTR IDS_ObjectTypeGUID      = L"GuidObjectType";
LPCWSTR IDS_Sid = L"Sid";
LPCWSTR IDS_Trustee = L"Trustee";
LPCWSTR IDS_ControlFlags = L"ControlFlags";
LPCWSTR IDS_Group = L"Group";
LPCWSTR IDS_DACL = L"DACL";
LPCWSTR IDS_SACL = L"SACL";
LPCWSTR IDS_SidLength = L"SidLength";
LPCWSTR IDS_SecuritySetting = L"SecuritySetting";
LPCWSTR IDS_BinaryRepresentation = L"BinaryRepresentation";
LPCWSTR IDS_Inheritance = L"Inheritance";
LPCWSTR IDS_SIDString = L"SIDString";
LPCWSTR IDS_OwnerPermissions = L"OwnerPermissions";
/////////////////////////////////////////////////////////////////////////////////////
//added for ComCatalog classes

LPCWSTR IDS_Category                                    = L"Category";
LPCWSTR IDS_Component                                   = L"Component";
LPCWSTR IDS_ComponentId                                 = L"ComponentId";
LPCWSTR IDS_CategoryId                                  = L"CategoryId";
LPCWSTR IDS_Insertable                                  = L"Insertable";
LPCWSTR IDS_JavaClass                                   = L"JavaClass";
LPCWSTR IDS_InprocServer32                              = L"InprocServer32";
LPCWSTR IDS_InprocServer                                = L"InprocServer";
LPCWSTR IDS_LocalServer32                               = L"LocalServer32";
LPCWSTR IDS_LocalServer                                 = L"LocalServer";
LPCWSTR IDS_ThreadingModel                              = L"ThreadingModel";
LPCWSTR IDS_InprocHandler32                             = L"InprocHandler32";
LPCWSTR IDS_InprocHandler                               = L"InprocHandler";
LPCWSTR IDS_TreatAsClsid                                = L"TreatAsClsid";
LPCWSTR IDS_AutoTreatAsClsid                    = L"AutoTreatAsClsid";
LPCWSTR IDS_ProgId                                              = L"ProgId";
LPCWSTR IDS_VersionIndependentProgId    = L"VersionIndependentProgId";
LPCWSTR IDS_TypeLibraryId                               = L"TypeLibraryId";
LPCWSTR IDS_AppID                                               = L"AppID";
LPCWSTR IDS_UseSurrogate                                = L"UseSurrogate";
LPCWSTR IDS_CustomSurrogate                             = L"CustomSurrogate";
LPCWSTR IDS_RemoteServerName                    = L"RemoteServerName";
LPCWSTR IDS_RunAsUser                                   = L"RunAsUser";
LPCWSTR IDS_AuthenticationLevel                 = L"AuthenticationLevel";
LPCWSTR IDS_LocalService                                = L"LocalService";
LPCWSTR IDS_EnableAtStorageActivation   = L"EnableAtStorageActivation";
LPCWSTR IDS_OldVersion                                  = L"OldVersion";
LPCWSTR IDS_NewVersion                                  = L"NewVersion";
LPCWSTR IDS_AutoConvertToClsid                  = L"AutoConvertToClsid";
LPCWSTR IDS_DefaultIcon                                 = L"DefaultIcon";
LPCWSTR IDS_ToolBoxBitmap32                             = L"ToolBoxBitmap32";
LPCWSTR IDS_ServiceParameters                   = L"ServiceParameters";
LPCWSTR IDS_ShortDisplayName                    = L"ShortDisplayName";
LPCWSTR IDS_LongDisplayName                             = L"LongDisplayName";
LPCWSTR IDS_Client                                              = L"Client";
LPCWSTR IDS_Application                                 = L"Application";

LPCWSTR IDS_Started                     = L"Started";
LPCWSTR IDS_ProcessId                   = L"ProcessId";
LPCWSTR IDS_ExitCode                    = L"ExitCode";
LPCWSTR IDS_ServiceSpecificExitCode     = L"ServiceSpecificExitCode";
LPCWSTR IDS_CheckPoint                  = L"CheckPoint";
LPCWSTR IDS_WaitHint                    = L"WaitHint";
LPCWSTR IDS_DesktopInteract             = L"DesktopInteract";
LPCWSTR IDS_StartMode                   = L"StartMode";

LPCWSTR IDS_BlockSize                   = L"BlockSize";
LPCWSTR IDS_NumberOfBlocks              = L"NumberOfBlocks";
LPCWSTR IDS_PrimaryPartition            = L"PrimaryPartition";

LPCWSTR IDS_Handedness                  = L"Handedness";
LPCWSTR IDS_DoubleSpeedThreshold        = L"DoubleSpeedThreshold";
LPCWSTR IDS_QuadSpeedThreshold          = L"QuadSpeedThreshold";
LPCWSTR IDS_PurposeDescription          = L"PurposeDescription";

LPCWSTR IDS_SameElement                 = L"SameElement";
LPCWSTR IDS_SystemElement               = L"SystemElement";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\strings.h ===
//=================================================================

//

// Strings.h

//

//  Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _STRINGS_H_INC_
#define _STRINGS_H_INC_

// general messages and strings
//=============================
/*
#define ERR_PLATFORM_NOT_SUPPORTED  "Platform not supported"
#define ERR_INVALID_PROCESSOR_ARCHITECTURE  "Invalid processor architecture"
#define ERR_GET_COMPUTER_NAME "Error 0x%lX in getting computer name"
#define ERR_GET_USER_NAME "Error <0x%lX> in getting user name"
#define ERR_GET_MOUSE_INFO "Error <0x%lX> in retrieving Mouse information"
*/

#define ERR_OPEN_REGISTRY L"Error opening registry with subkey <%s>"

/*
#define ERR_INSUFFICIENT_BUFFER "Insufficient buffer"
#define ERR_SYSTEM_PARAMETERS_INFO "Error <0x%lX> in getting system parameters info"
#define ERR_INVALID_SSF_TEXT_EFFECT "Invalid Soundsentry Feature - Text effect"
#define ERR_INVALID_GRAPHICS_EFFECT "Invalid Soundsentry Feature - graphics effect"
#define ERR_INVALID_WINDOWS_EFFECT "Invalid Soundsentry Feature - Windows effect"
#define ERR_INVALID_SHARE_DISPOSITION "Invalid share disposition value"
#define ERR_INVALID_MEMORY_TYPE "Invalid memory type"
#define ERR_INVALID_INTERRUPT_TYPE "Invalid interrupt type"

#define ERR_UNKNOWN_AC_POWER_STATUS "Unknown AC power status"
#define ERR_UNKNOWN_BATTERY_STATUS "Unknown battery charge status"
#define ERR_INVALID_BATTERY_STATUS "Invalid battery charge status"
#define ERR_UNKNOWN_BATTERY_LIFE_PERCENT "Unknown percentage of full battery charge remaining"
#define ERR_INVALID_BATTERY_LIFE_PERCENT "Invalid percentage of full battery charge remaining"
#define ERR_INVALID_BATTERY_LIFE_TIME "Battery life remaining unknown/invalid"
#define ERR_INVALID_BATTERY_FULL_LIFE_TIME "Battery life when at full charge unknown/invalid"

#define ERR_SERVICE_CONTROLLER_OPEN "Error in opening service controller"
#define ERR_UPS_SERVICE_OPEN    "Error in opening UPS service"
#define ERR_QUERY_UPS_SERVICE_STATUS "Error in querying UPS service status"
#define ERR_UPS_SERVICE_NOT_RUNNING "UPS service not running"
#define ERR_INVALID_RECHARGE_RATE "Invalid Battery recharge rate"
#define ERR_INVALID_MESSAGE_INTERVAL "Invalid power failure message delay value"
#define ERR_INVALID_FIRST_MESSAGE_DELAY "Invalid first power failure message delay value"

#define ERR_WNET_GET_CONNECTION     "Error <0x%lX> in getting network connection information"
#define ERR_NETWORK_SPECIFIC        "Error <0x%lX> - A network specific error"

#define ERR_WNETOPENENUM    "Error <0x%lx> with WNetOpenEnum"
#define ERR_WNETENUMRESOURCE    "Error <0x%lx> with WNetEnumResource"
#define ERR_WNETCLOSEENUM    "Error <0x%lx> with WNetCloseEnum"

#define ERR_REGISTRY_OPEN   "Error in opening <%s> under <%s> in registry"
#define ERR_REGISTRY_ENUM_VALUE   "Error <0x%X> in enumerating values under <%s> in registry"
*/

#define ERR_REGISTRY_ENUM_VALUE_FOR_KEY L"Error enumerating values under <%s> in registry for key <%s>"

/*
#define ERR_REGISTRY_ENUM_KEY     "Error <0x%X> in enumerating keys under <%s> in registry"

#define ERR_INVALID_SERVICE_STATE "Invalid Service state"
#define ERR_GET_SERVICE_CONFIG_STATUS "Error in getting config status of service"
#define ERR_INVALID_SERVICE_TYPE "Invalid Service type"
#define ERR_INVALID_START_TYPE "Invalid Start type"
#define ERR_INVALID_ERROR_CONTROL "Invalid Error Control"
#define ERR_NUMBER_OF_SERVICES_MISMATCH "System and computed number of services mismatch"

#define ERR_GET_SYSTEM_DIRECTORY "Error <0x%lX> in calling GetSystemDirectory."
#define ERR_GET_WINDOWS_DIRECTORY "Error <0x%lX> in calling GetWindowsDirectory."
#define ERR_GET_VERSIONEX "Error in calling GetVersionEx."
#define  ERR_GET_SYSTEM_INFO    "Error in calling GetSystemInfo."

#define  ERR_UNKNOWN_POWER_PC_TYPE    "Unknown/Invalid Power PC processor type"
#define  ERR_UNKNOWN_MIPS_TYPE    "Unknown/Invalid MIPS processor type"
#define  ERR_UNKNOWN_ALPHA_TYPE    "Unknown/Invalid DEC Alpha processor type"
#define  ERR_UNKNOWN_INTEL_TYPE    "Unknown/Invalid Intel processor type"

// Boolean values
//===============

#define TRUE_STR    "True"
#define FALSE_STR   "False"

// Soundsentry feature - text mode visual signal
//==============================================

#define SSF_TEXT_EFFECT_BORDER "Flash the screen border"
#define SSF_TEXT_EFFECT_CHARS  "Flash characters in the corner of screen"
#define SSF_TEXT_EFFECT_DISPLAY "Flash the entire display"
#define SSF_TEXT_EFFECT_NONE "No visual signal"

// Soundsentry feature - graphics mode visual signal
//==================================================

#define SSF_GRAPHICS_EFFECT_DISPLAY SSF_TEXT_EFFECT_DISPLAY
#define SSF_GRAPHICS_EFFECT_NONE SSF_TEXT_EFFECT_NONE 

// Soundsentry feature - Windows effect
//=====================================

#define SSF_WINDOWS_EFFECT_DISPLAY SSF_TEXT_EFFECT_DISPLAY
#define SSF_WINDOWS_EFFECT_NONE    SSF_TEXT_EFFECT_NONE
#define SSF_WINDOWS_EFFECT_WINDOW  "Flash the active window"
#define SSF_WINDOWS_EFFECT_TITLE  "Flash the title bar of the active window"
#define SSF_WINDOWS_EFFECT_CUSTOM  "Custom flashing"

*/

// SerialKeys feature - port state values
//=======================================

#define IGNORE_IP_PORT_STATE L"Port input ignored"
#define WATCH_IP_PORT_STATE  L"Port input watched for serial keys activation sequences"
#define COMPLETE_IP_PORT_STATE L"Complete port input treated as serial keys commands"

// system type strings
//====================

#define SYS_TYPE_X86_PC                       L"X86-based PC"
#define SYS_TYPE_MAC                          L"Macintosh"
#define SYS_TYPE_ALPHA                        L"ALPHA-based PC"
#define SYS_TYPE_MIPS                         L"MIPS-based PC"
#define SYS_TYPE_PPC                          L"Power PC"

// system role strings
//====================

#define SYS_ROLE_WORKSTATION                  L"Workstation"
#define SYS_ROLE_SERVER                       L"Server"

// AC power status strings
//========================

#define AC_POWER_STATUS_ONLINE                 L"AC power On line"
#define AC_POWER_STATUS_OFFLINE                 L"AC power Off line"

// Battery charge status strings
//==============================

#define BATTERY_STATUS_HIGH                 L"High"
#define BATTERY_STATUS_LOW                  L"Low"
#define BATTERY_STATUS_CRITICAL             L"Critical"
#define BATTERY_STATUS_CHARGING             L"Charging"
#define BATTERY_STATUS_NO_BATTERY           L"No system battery"

// the following are system defined values for UPS options
// they should not be changed
//========================================================

#define UPS_INSTALLED                   0x1
#define UPS_POWER_FAIL_SIGNAL           0x2
#define UPS_LOW_BATTERY_SIGNAL          0x4
#define UPS_CAN_TURN_OFF                0x8
#define UPS_POSITIVE_POWER_FAIL_SIGNAL  0x10
#define UPS_POSITIVE_LOW_BATTERY_SIGNAL 0x20
#define UPS_POSITIVE_SHUT_OFF_SIGNAL    0x40
#define UPS_COMMAND_FILE                0x80

#define POSITIVE_UPS_INTERFACE_VOLTAGE L"Positive interface voltage"
#define NEGATIVE_UPS_INTERFACE_VOLTAGE L"Negative interface voltage"
#define NO_LOW_BATTERY_SIGNAL          L"No low battery signal"
#define NO_POWER_FAIL_SIGNAL           L"No power fail signal"
#define UPS_CANNOT_TURN_OFF            L"cannot do remote turn off"

// The following are  related * Net connection propertyset
//========================================================

#define NET_RESOURCE_TYPE_DISK  L"Disk"
#define NET_RESOURCE_TYPE_PRINT L"Print"

#define NET_DISPLAY_TYPE_DOMAIN L"Domain"
#define NET_DISPLAY_TYPE_GENERIC L"Generic"
#define NET_DISPLAY_TYPE_SERVER L"Server"
#define NET_DISPLAY_TYPE_SHARE L"Share"

// service propertyset related strings
//=====================================

// Service state
//==============

#define RUNNING_STR                         L"Running"
#define STOPPED_STR                         L"Stopped"
#define STARTED_STR                                                                                                     L"Started"

// Service Type
//=============

#define KERNEL_DRIVER_STR                   L"Kernel Driver"
#define FILE_SYSTEM_DRIVER_STR              L"File System Driver"
#define ADAPTER_STR                         L"Adapter"
#define WIN32_OWN_PROCESS_STR               L"Own Process"
#define WIN32_SHARE_PROCESS_STR             L"Shared Process"
#define RECOGNIZER_DRIVER_STR               L"Recognizer driver"
#define INTERACTIVE_PROCESS_STR             L"Interactive process"

// Start Type
//===========

#define BOOT_START_STR                      L"Boot"
#define SYSTEM_START_STR                    L"System"
#define AUTO_START_STR                      L"Automatic"
#define DEMAND_START_STR                    L"Demand"
#define DISABLED_STR                        L"Disabled"

// Error control type
//===================

#define ERROR_IGNORE_STR                    L"Ignore"
#define ERROR_NORMAL_STR                    L"Normal"
#define ERROR_SEVERE_STR                    L"Severe"
#define ERROR_CRITICAL_STR                  L"Critical"

// Processor property set related defines
//=======================================

#define PROCESSOR_FAMILY_INTEL  L"Intel"
#define PROCESSOR_FAMILY_MIPS  L"Mips"
#define PROCESSOR_FAMILY_ALPHA  L"Alpha"
#define PROCESSOR_FAMILY_POWER_PC  L"Power PC"

#define PROCESSOR_TYPE_80386        L"80386"
#define PROCESSOR_TYPE_80486        L"80486"
#define PROCESSOR_TYPE_80486SX      L"80486SX"
#define PROCESSOR_TYPE_80486DX      L"80486DX"
#define PROCESSOR_TYPE_PENTIUM      L"Pentium"
#define PROCESSOR_TYPE_R2000        L"MIPS R2000"
#define PROCESSOR_TYPE_R3000        L"MIPS R3000"
#define PROCESSOR_TYPE_R6000        L"MIPS R6000"
#define PROCESSOR_TYPE_R4000        L"MIPS R4000"
#define PROCESSOR_TYPE_R6000A       L"MIPS R6000A"
#define PROCESSOR_TYPE_21064        L"DEC Alpha 21064"
#define PROCESSOR_TYPE_21066        L"DEC Alpha 21066"
#define PROCESSOR_TYPE_21164        L"DEC Alpha 21164"
#define PROCESSOR_TYPE_601          L"Power PC 601"
#define PROCESSOR_TYPE_603          L"Power PC 603"
#define PROCESSOR_TYPE_603_PLUS     L"Power PC 603+"
#define PROCESSOR_TYPE_604          L"Power PC 604"
#define PROCESSOR_TYPE_604_PLUS     L"Power PC 604+"

#define PROCESSOR_ROLE_CPU          L"CPU"

#define PROCESSOR_MODEL_STRING         L"Model"
#define PROCESSOR_STEPPING_STRING      L"Stepping"
#define PROCESSOR_REVISION_STRING      L"Revision"
#define PROCESSOR_PASS_STRING          L"Pass"

#define OS_NT_ADV_SRVR                                  L"Microsoft Windows NT Advanced Server"
#define OS_NT_SRV                                               L"Microsoft Windows NT Server"
#define OS_NT_WKS                                               L"Microsoft Windows NT Workstation"
#define OS_NT                                                   L"Microsoft Windows NT"
#define OS_95                                                   L"Microsoft Windows 95"

#define MICROSOFT_COMPANY                               L"Microsoft"

#define KNOWN_BUS_TYPE_SIZE  256
#define KNOWN_BUS_TYPES     0x10
#define UNKNOWN_BUS_TYPE    0xFF


//
///////////////////////////////////////////
//
//      LOGGING STRINGS
//
///////////////////////////////////////////
extern LPCWSTR IDS_LogImpersonationFailed;
extern LPCWSTR IDS_LogImpersonationRevertFailed;
extern LPCWSTR IDS_LogOutOfMemory;

//
///////////////////////////////////////////
//
//      SHARE DISPOSITIONS
//
///////////////////////////////////////////
extern LPCWSTR IDS_SDDeviceExclusive;
extern LPCWSTR IDS_SDDriverExclusive;
extern LPCWSTR IDS_SDShared;
extern LPCWSTR IDS_SDUndetermined;

//
///////////////////////////////////////////
//
//      MEMORY TYPES
//
///////////////////////////////////////////
extern LPCWSTR IDS_MTReadWrite;
extern LPCWSTR IDS_MTReadOnly;
extern LPCWSTR IDS_MTWriteOnly;
extern LPCWSTR IDS_MTPrefetchable;

//
///////////////////////////////////////////
//
//      MEDIA TYPES
//
///////////////////////////////////////////
extern LPCWSTR IDS_MDT_RandomAccess;
extern LPCWSTR IDS_MDT_SupportsWriting;
extern LPCWSTR IDS_MDT_Removable;
extern LPCWSTR IDS_MDT_CD;

// Processor Architectures
extern LPCWSTR IDS_ProcessorX86;
extern LPCWSTR IDS_ProcessorX86Nec98;
extern LPCWSTR IDS_ProcessorMIPS;
extern LPCWSTR IDS_ProcessorALPHA;
extern LPCWSTR IDS_ProcessorPowerPC;
extern LPCWSTR IDS_ProcessorIA64;
extern LPCWSTR IDS_ProcessorAMD64;
extern LPCWSTR IDS_ProcessorUnknown;

//
///////////////////////////////////////////
//
//      COMMON STRINGS
//
///////////////////////////////////////////
extern LPCWSTR IDS_Unknown;
extern LPCWSTR IDS_OK;
extern LPCWSTR IDS_WINNT_SHELLNAME_EXPLORER;
extern LPCWSTR IDS_WINNT_SHELLNAME_PROGMAN;
extern LPCWSTR IDS_Degraded; 
extern LPCWSTR IDS_Error;    
//
///////////////////////////////////////////
//
//      Win32_BIOS
//
///////////////////////////////////////////
extern LPCWSTR IDS_RegBiosSystem;
extern LPCWSTR IDS_RegSystemBiosDate;
extern LPCWSTR IDS_RegSystemBiosVersion;
extern LPCWSTR IDS_RegEnumRootBios;
extern LPCWSTR IDS_RegBIOSName;
extern LPCWSTR IDS_RegBIOSDate;
extern LPCWSTR IDS_RegBIOSVersion;
extern LPCWSTR IDS_BIOS_NAME_VALUE;

//
///////////////////////////////////////////
//
//      Win32_BootConfiguration
//
///////////////////////////////////////////
extern LPCWSTR IDS_BOOT_CONFIG_NAME;
extern LPCWSTR IDS_RegSetupLog;
extern LPCWSTR IDS_Paths;
extern LPCWSTR IDS_TargetDirectory;
extern LPCWSTR IDS_EnvBootDirectory;
extern LPCWSTR IDS_Temp;
extern LPCWSTR IDS_Environment;

//
///////////////////////////////////////////
//
//      Win32_Bus
//
///////////////////////////////////////////
extern LPCWSTR IDS_Win32_Bus;
extern LPCWSTR IDS_Bus;
extern LPCWSTR IDS_BusType;
extern LPCWSTR IDS_BusNum;
extern LPCWSTR IDS_BUS_DEVICEID_TAG;
extern LPCWSTR IDS_WIN98_USB_REGISTRY_KEY;
extern LPCWSTR IDS_NT5_USB_REGISTRY_KEY;
extern LPCWSTR IDS_USB_Bus_Tag;

//
///////////////////////////////////////////
//
//      Win32_CDRom
//
///////////////////////////////////////////
extern LPCWSTR IDS_RegSCSICDDevice;
extern LPCWSTR IDS_RegIdentifier;
extern LPCWSTR IDS_RegEnumSCSI;
extern LPCWSTR IDS_RegCurrentDriveLetterKey;
extern LPCWSTR IDS_RegProductIDKey;
extern LPCWSTR IDS_RegClassKey;
extern LPCWSTR IDS_RegHardwareIDKey;
extern LPCWSTR IDS_RegRevisionLevelKey;
extern LPCWSTR IDS_RegSCSITargetIDKey;
extern LPCTSTR IDT_REG_KEY_CD_CACHE;
extern LPCTSTR IDT_REG_VAL_CD_CACHE;
extern LPCWSTR IDS_DriveIntegrity;
extern LPCWSTR IDS_TransferRate;


//
///////////////////////////////////////////
//
//      Win32_ComputerSystem
//
///////////////////////////////////////////
extern LPCWSTR IDS_Win32ComputerSystem;
extern LPCWSTR IDS_DefaultSystemName;
extern LPCWSTR IDS_RegInfrared;
extern LPCWSTR IDS_Workstation;
extern LPCWSTR IDS_PrimaryOwnerName;
extern LPCWSTR IDS_SystemStartupSetting;
extern LPCWSTR IDS_SystemStartupOptions;
extern LPCWSTR IDS_OEMLogoBitmap;
extern LPCWSTR IDS_BootupStateNormal;       
extern LPCWSTR IDS_BootupStateFailSafe;
extern LPCWSTR IDS_BootupStateFailSafeWithNetBoot;
extern LPCWSTR IDS_LogNoAPMForNT5;
extern LPCWSTR IDS_RegCrashControl;
extern LPCWSTR IDS_RegAutoRebootKey;
extern LPCWSTR IDS_RegCurrentNTVersion;
extern LPCWSTR IDS_RegCurrent95Version;
extern LPCWSTR IDS_RegRegisteredOwnerKey;
extern LPCWSTR IDS_RegProductOptions;
extern LPCWSTR IDS_RegProductTypeKey;
extern LPCWSTR IDS_RegNetworkLogon;
extern LPCWSTR IDS_RegPrimaryProvider;
extern LPCWSTR IDS_RegNetworkProvider;
extern LPCWSTR IDS_RegAuthenticatingAgent;
extern LPCWSTR IDS_MicrosoftNetwork;
extern LPCWSTR IDS_LanmanNT;
extern LPCWSTR IDS_ServerNT;
extern LPCWSTR IDS_Server;
extern LPCWSTR IDS_RegCurrentNTVersionSetup;
extern LPCWSTR IDS_RegBootDirKey;
extern LPCWSTR IDS_BootIni;
extern LPCWSTR IDS_CBootIni;
extern LPCTSTR IDT_BootLoader;
extern LPCTSTR IDT_Timeout;
extern LPCTSTR IDT_OperatingSystems;
extern LPCTSTR IDT_OemLogoBmp;
extern LPCTSTR IDT_Line;
extern LPCTSTR IDT_SupportInformation;
extern LPCTSTR IDT_General;
extern LPCTSTR IDT_OEMInfoIni;
extern LPCWSTR IDS_RegCSEnumRootKey;
extern LPCWSTR IDS_RegPowerManagementKey;
extern LPCWSTR IDS_ATDescription;
extern LPCWSTR IDS_RegIdentifierKey;
extern LPCWSTR IDS_EnableDaylightSavingsTime;
extern LPCWSTR IDS_LargeSystemCache;

//
///////////////////////////////////////////
//
//      Win32_Desktop
//
///////////////////////////////////////////
extern LPCWSTR IDS_RegNTProfileList;
extern LPCWSTR IDS_RegControlPanelDesktop;
extern LPCWSTR IDS_RegControlPanelAppearance;
extern LPCWSTR IDS_RegControlPanelDesktop95;
extern LPCWSTR IDS_RegScreenSaveActive;
extern LPCWSTR IDS_RegSCRNSAVEEXE;
extern LPCWSTR IDS_RegScreenSaverIsSecure;
extern LPCWSTR IDS_RegScreenSaveTimeOut;
extern LPCWSTR IDS_RegTileWallpaper;
extern LPCWSTR IDS_RegWindowMetricsKey;
extern LPCWSTR IDS_RegScreenSaveUsePassword;

//
///////////////////////////////////////////
//
//      Win32_DeviceMemory
//
///////////////////////////////////////////
extern LPCWSTR IDS_RegAddressRange;
extern LPCWSTR IDS_RegStartingAddress;

//
///////////////////////////////////////////
//
//      Win32_Directory
//
///////////////////////////////////////////


//
///////////////////////////////////////////
//
//Win32_DiskPartition
//
///////////////////////////////////////////
extern LPCWSTR IDS_Bootable;
extern LPCWSTR IDS_PhysicalDrive;
extern LPCWSTR IDS_PartitionDescUnused;
extern LPCWSTR IDS_PartitionDesc12bitFAT;
extern LPCWSTR IDS_PartitionDescXenixOne;
extern LPCWSTR IDS_PartitionDescXenixTwo;
extern LPCWSTR IDS_PartitionDesc16bitFAT;
extern LPCWSTR IDS_PartitionDescExtPartition;
extern LPCWSTR IDS_PartitionDescDOSV4Huge;
extern LPCWSTR IDS_PartitionDescInstallable;
extern LPCWSTR IDS_PartitionDescPowerPCRef;
extern LPCWSTR IDS_PartitionDescUnix;
extern LPCWSTR IDS_PartitionDescNTFT;
extern LPCWSTR IDS_PartitionDescWin95Ext;
extern LPCWSTR IDS_PartitionDescExt13;
extern LPCWSTR IDS_PartitionDescUnknown;
extern LPCWSTR IDS_PartitionDescGPTUnused;
extern LPCWSTR IDS_PartitionDescGPTSystem;
extern LPCWSTR IDS_PartitionDescGPTMSFTReserved;
extern LPCWSTR IDS_PartitionDescGPTBasicData;
extern LPCWSTR IDS_PartitionDescGPTLDMMetaData;
extern LPCWSTR IDS_PartitionDescGPTLDMData;
extern LPCWSTR IDS_PartitionDescGPTUnknown;


//
///////////////////////////////////////////
//
//      Win32_DisplayControlConfiguration
//
///////////////////////////////////////////
extern LPCWSTR IDS_AdapterConfiguredIncorrect;

//
///////////////////////////////////////////
//
//      Win32_Environment
//
///////////////////////////////////////////
extern LPCWSTR IDS_SystemUser;
extern LPCWSTR IDS_DefaultUser;
extern LPCWSTR IDS_RegEnvironmentNT;
extern LPCWSTR IDS_RegEnvironmentKey;
extern LPCWSTR IDS_LogInvalidEnvFlags;
extern LPCWSTR IDS_LogUserSystemMismatch;
extern LPCWSTR IDS_LogInvalidEnvDelFlags;


//
///////////////////////////////////////////
//
//      Win32_Keyboard
//
///////////////////////////////////////////
extern LPCWSTR IDS_PCXT;
extern LPCWSTR IDS_ICO;
extern LPCWSTR IDS_PCAT;
extern LPCWSTR IDS_ENHANCED101102;
extern LPCWSTR IDS_NOKIA1050;
extern LPCWSTR IDS_NOKIA9140;
extern LPCWSTR IDS_Japanese;
extern LPCWSTR IDS_UnknownKeyboard;


//
///////////////////////////////////////////
//
//      Win32_LogicalDisk
//
///////////////////////////////////////////
extern LPCWSTR IDS_SupportsFileBasedCompression;


//
///////////////////////////////////////////
//
//      CIM_LogicalFile
//
///////////////////////////////////////////
extern LPCWSTR IDS_Filename;
extern LPCWSTR IDS_Filesize;
extern LPCWSTR IDS_Directory;
extern LPCWSTR IDS_EightDotThreeFileName;
extern LPCWSTR IDS_Archive;
extern LPCWSTR IDS_Hidden;
extern LPCWSTR IDS_System;
extern LPCWSTR IDS_LocalDisk;
extern LPCWSTR IDS_FileFolder;
extern LPCWSTR IDS_FileTypeKeyNT4;
extern LPCWSTR IDS_File;
extern LPCWSTR IDS_CompressionMethod;
extern LPCWSTR IDS_EncryptionMethod;


//
///////////////////////////////////////////
//
//      CIM_LogicalDevice_CIMDataFile   
//
///////////////////////////////////////////
extern LPCWSTR IDS___Path;
extern LPCWSTR IDS___Class;
extern LPCWSTR IDS___Relpath;
extern LPCWSTR IDS_NT_CurCtlSetEnum;
extern LPCWSTR IDS_NT_CurCtlSetSvcs;
extern LPCWSTR IDS_ImagePath;
extern LPCWSTR IDS_98_CurCtlSetSvcCls;
extern LPCWSTR IDS_DevLoader;
extern LPCWSTR IDS_98_Vmm32Files;
extern LPCWSTR IDS_CIMDataFile;
extern LPCWSTR IDS_DriversSubdir;
extern LPCWSTR IDS_Extension_sys;
extern LPCWSTR IDS_DeviceVxDs;
extern LPCWSTR IDS_Enum;
extern LPCWSTR IDS_Count;
extern LPCWSTR IDS_Purpose;


//
///////////////////////////////////////////
//
//      Win32_ShortcutFile   
//
///////////////////////////////////////////
extern LPCWSTR IDS_Target;


//
///////////////////////////////////////////
//
//      Win32_Win32LogicalProgramGroup
//
///////////////////////////////////////////
extern LPCWSTR IDS_BASE_REG_KEY;

//
///////////////////////////////////////////
//
//      Win32_Win32ProgramGroup_CIMDataFile   
//
///////////////////////////////////////////
extern LPCWSTR IDS_Start_MenuWhackPrograms;
extern LPCWSTR IDS_Default_User;
extern LPCWSTR IDS_All_Users;
extern LPCWSTR IDS_Profiles;
extern LPCWSTR IDS_Start_Menu;


//
///////////////////////////////////////////
//
//  Win32_SerialPort
extern LPCWSTR IDS_NT4_PortKey;
extern LPCWSTR IDS_WIN9XCurCtlSet_Svcs_Class;
//
///////////////////////////////////////////


extern WCHAR szBusType[KNOWN_BUS_TYPES][20];
extern LPCWSTR IDS_Caption      ;
extern LPCWSTR IDS_Bus;
extern LPCWSTR IDS_BusNum;
extern LPCWSTR IDS_BusType;
extern LPCWSTR IDS_CreationClassName    ;
extern LPCWSTR IDS_CSCreationClassName  ;
extern LPCWSTR IDS_CSName       ;
extern LPCWSTR IDS_Handle       ;
extern LPCWSTR IDS_OSCreationClassName;
extern LPCWSTR IDS_WorkingSetSize;
extern LPCWSTR IDS_OSName;
extern LPCWSTR IDS_Description  ;
extern LPCWSTR IDS_DeviceID;
extern LPCWSTR IDS_HotSwappable ;
extern LPCWSTR IDS_XOnXMitThreshold     ;
extern LPCWSTR IDS_MaxTransmissionSpeed ;
extern LPCWSTR IDS_MaxTransmissionSpeedToPhone ;
extern LPCWSTR IDS_AnswerMode;
extern LPCWSTR IDS_Control;
extern LPCWSTR IDS_LINEANSWERMODENODE;
extern LPCWSTR IDS_LINEANSWERMODEDROP;
extern LPCWSTR IDS_LINEANSWERMODEHOLD;
extern LPCWSTR IDS_XOffXMitThreshold    ;
extern LPCWSTR IDS_Unsupported;
extern LPCWSTR IDS_ContinueXMitOnXOff;
extern LPCWSTR IDS_AbortReadWriteOnError;
extern LPCWSTR IDS_Installed    ;
extern LPCWSTR IDS_Name  ;
extern LPCWSTR IDS_Manufacturer     ;
extern LPCTSTR IDT_Model            ;
extern LPCWSTR IDS_PowerState       ;
extern LPCWSTR IDS_SerialNumber     ;
extern LPCWSTR IDS_SKU              ;
extern LPCWSTR IDS_Tag              ;
extern LPCWSTR IDS_Version          ;
extern LPCWSTR IDS_InUse            ;
extern LPCWSTR IDS_PrimaryOwner     ;
extern LPCWSTR IDS_BasePriority     ;
extern LPCWSTR IDS_ProcessID        ;
extern LPCWSTR IDS_JobCountSinceLastReset ;
extern LPCWSTR IDS_BuildNumber          ;
extern LPCWSTR IDS_FSCreationClassName;
extern LPCWSTR IDS_FSName;
extern LPCWSTR IDS_CreationDate;
extern LPCWSTR IDS_InstallDate;
extern LPCWSTR IDS_BuildType            ;
extern LPCWSTR IDS_CodeSet              ;
extern LPCWSTR IDS_Installable          ;
extern LPCWSTR IDS_InstallationDate     ;
extern LPCWSTR IDS_InUseCount           ;
extern LPCWSTR IDS_Locale               ;
extern LPCWSTR IDS_CasePreserved    ;
extern LPCWSTR IDS_CaseSensitive    ;
extern LPCWSTR IDS_Unicode          ;
extern LPCWSTR IDS_Archived         ;
extern LPCWSTR IDS_Compressed       ;
extern LPCWSTR IDS_Created          ;
extern LPCWSTR IDS_Extension        ;
extern LPCWSTR IDS_FileType         ;
extern LPCWSTR IDS_LastAccessed     ;
extern LPCWSTR IDS_LastModified     ;
extern LPCWSTR IDS_Open             ;
extern LPCWSTR IDS_Path             ;
extern LPCWSTR IDS_Readable         ;
extern LPCWSTR IDS_Size             ;
extern LPCWSTR IDS_Writeable        ;
extern LPCWSTR IDS_ServiceType  ;
extern LPCWSTR IDS_State        ;
extern LPCWSTR IDS_ServiceName      ;
extern LPCWSTR IDS_Status           ;
extern LPCWSTR IDS_StatusInfo ;
extern LPCWSTR IDS_MaxNumberControlled ;
extern LPCWSTR IDS_TimeOfLastReset;
extern LPCWSTR IDS_ProtocolSupported;
extern LPCWSTR IDS_BatteryChargeStatus          ;
extern LPCWSTR IDS_BatteryInstalled             ;
extern LPCWSTR IDS_BatteryLifeLeft              ;
extern LPCWSTR IDS_BatteryLifetime              ;
extern LPCWSTR IDS_CanTurnOffRemotely           ;
extern LPCWSTR IDS_CommandFile                  ;
extern LPCWSTR IDS_FirstMessageDelay            ;
extern LPCWSTR IDS_LowBatterySignal             ;
extern LPCWSTR IDS_MessageInterval              ;
extern LPCWSTR IDS_RemainingCapacityStatus      ;
extern LPCWSTR IDS_EstimatedChargeRemaining     ;
extern LPCWSTR IDS_EstimatedRunTime             ;
extern LPCWSTR IDS_PowerFailSignal              ;
extern LPCWSTR IDS_RechargeRate                 ;
extern LPCWSTR IDS_Type                         ;
extern LPCWSTR IDS_UPSPort                      ;
extern LPCWSTR IDS_VoltageCapability            ;
extern LPCWSTR IDS_FreeSpace  ;
extern LPCWSTR IDS_PeakUsage  ;
extern LPCWSTR IDS_LastBootupTime   ;
extern LPCWSTR IDS_SupportContact   ;
extern LPCWSTR IDS_SystemTime       ;
extern LPCWSTR IDS_ConnectionlessService        ;
extern LPCWSTR IDS_GuaranteesDelivery           ;
extern LPCWSTR IDS_GuaranteesSequencing         ;
extern LPCWSTR IDS_MaximumAddressSize           ;
extern LPCWSTR IDS_MaximumMessageSize           ;
extern LPCWSTR IDS_MessageOriented              ;
extern LPCWSTR IDS_MinimumAddressSize           ;
extern LPCWSTR IDS_PseudoStreamOriented         ;
extern LPCWSTR IDS_SupportsBroadcasting         ;
extern LPCWSTR IDS_SupportsConnectData          ;
extern LPCWSTR IDS_SupportsDisconnectData       ;
extern LPCWSTR IDS_SupportsEncryption           ;
extern LPCWSTR IDS_SupportsExpeditedData        ;
extern LPCWSTR IDS_SupportsFragmentation        ;
extern LPCWSTR IDS_SupportsGracefulClosing      ;
extern LPCWSTR IDS_SupportsGuaranteedBandwidth  ;
extern LPCWSTR IDS_SupportsMulticasting         ;
extern LPCWSTR IDS_SupportsQualityofService             ;
extern LPCWSTR IDS_ExecutableType   ;
extern LPCWSTR IDS_DeviceIsBusy  ;
extern LPCWSTR IDS_AdapterType      ;
extern LPCWSTR IDS_AdapterTypeID    ;
extern LPCWSTR IDS_Index            ;
extern LPCWSTR IDS_IOPortAddress    ;
extern LPCWSTR IDS_MACAddress       ;
extern LPCWSTR IDS_Baud             ;
extern LPCWSTR IDS_ByteSize         ;
extern LPCWSTR IDS_DSRSensitivity   ;
extern LPCWSTR IDS_DTRControl       ;
extern LPCWSTR IDS_OutTxCTSFlow     ;
extern LPCWSTR IDS_OutTxDSRFlow     ;
extern LPCWSTR IDS_Parity           ;
extern LPCWSTR IDS_ParityEnabled    ;
extern LPCWSTR IDS_StopBits         ;
extern LPCWSTR IDS_MaxClockSpeed    ;
extern LPCWSTR IDS_CurrentClockSpeed;
extern LPCWSTR IDS_Family           ;
extern LPCWSTR IDS_Role             ;
extern LPCWSTR IDS_Architecture    ;
extern LPCWSTR IDS_Stepping    ;
extern LPCWSTR IDS_Level           ;
extern LPCWSTR IDS_Revision        ;
extern LPCWSTR IDS_L2CacheSize     ;
extern LPCWSTR IDS_L2CacheSpeed    ;
extern LPCWSTR IDS_UpgradeMethod    ;
extern LPCWSTR IDS_Layout                   ;
extern LPCWSTR IDS_NumberOfFunctionKeys     ;
extern LPCWSTR IDS_ConnectionMode               ;
extern LPCWSTR IDS_HardwareID                   ;
extern LPCWSTR IDS_MaximumTransmissionSpeed     ;
extern LPCWSTR IDS_Mode                         ;
extern LPCWSTR IDS_TransmissionSpeed            ;
extern LPCWSTR IDS_ButtonsSwapped           ;
extern LPCWSTR IDS_ConnectMultiplePorts     ;
extern LPCWSTR IDS_DataQueueSize            ;
extern LPCWSTR IDS_DriverName               ;
extern LPCWSTR IDS_DeviceInterface          ;
extern LPCWSTR IDS_HardwareType             ;
extern LPCWSTR IDS_HorizontalMickeys        ;
extern LPCWSTR IDS_MaximumPortsServiced     ;
extern LPCWSTR IDS_NumberOfButtons          ;
extern LPCWSTR IDS_PointerType              ;
extern LPCWSTR IDS_Resolution               ;
extern LPCWSTR IDS_Speed                    ;
extern LPCWSTR IDS_Synch                    ;
extern LPCWSTR IDS_VerticalMickeys          ;
extern LPCWSTR IDS_XThreshold               ;
extern LPCWSTR IDS_YThreshold               ;
extern LPCWSTR IDS_ZThreshold               ;
extern LPCWSTR IDS_AveragePagesPerMinute        ;
extern LPCWSTR IDS_Comment                      ;
extern LPCWSTR IDS_PrintProcessorParameters     ;
extern LPCWSTR IDS_SpoolEnabled     ;
extern LPCWSTR IDS_Processor                    ;
extern LPCWSTR IDS_ElapsedTime      ;
extern LPCWSTR IDS_JobDestination   ;
extern LPCWSTR IDS_Notify           ;
extern LPCWSTR IDS_Owner            ;
extern LPCWSTR IDS_Priority         ;
extern LPCWSTR IDS_StartTime        ;
extern LPCWSTR IDS_TimeSubmitted    ;
extern LPCWSTR IDS_UntilTime        ;
extern LPCWSTR IDS_MediaLoaded          ;
extern LPCWSTR IDS_MediaType            ;
extern LPCWSTR IDS_MediaRemovable       ;
extern LPCWSTR IDS_Compression              ;
extern LPCWSTR IDS_DefaultBlockSize         ;
extern LPCWSTR IDS_ECC                      ;
extern LPCWSTR IDS_EndOfTapeWarningZoneSize       ;
extern LPCWSTR IDS_FeaturesHigh             ;
extern LPCWSTR IDS_FeaturesLow              ;
extern LPCWSTR IDS_MaximumBlockSize         ;
extern LPCWSTR IDS_MaximumPartitionCount    ;
extern LPCWSTR IDS_MinimumBlockSize         ;
extern LPCWSTR IDS_Padding                  ;
extern LPCWSTR IDS_ReportSetMarks           ;
extern LPCWSTR IDS_BytesPerSector           ;
extern LPCWSTR IDS_InterfaceType            ;
extern LPCWSTR IDS_Partitions               ;
extern LPCWSTR IDS_Signature                ;
extern LPCWSTR IDS_TotalCylinders           ;
extern LPCWSTR IDS_TotalSectors             ;
extern LPCWSTR IDS_TotalTracks              ;
extern LPCWSTR IDS_TracksPerCylinder        ;
extern LPCWSTR IDS_SectorsPerTrack          ;
extern LPCWSTR IDS_TotalBadSectors          ;
extern LPCWSTR IDS_LandingZoneCylinder      ;
extern LPCWSTR IDS_WritePrecompCylinder     ;
extern LPCWSTR IDS_TotalHeads               ;
extern LPCWSTR IDS_BootDirectory         ;
extern LPCWSTR IDS_ConfigurationPath     ;
extern LPCWSTR IDS_LastDrive             ;
extern LPCWSTR IDS_ScratchDirectory      ;
extern LPCWSTR IDS_TempDirectory         ;
extern LPCWSTR IDS_BorderWidth               ;
extern LPCWSTR IDS_CoolSwitch                ;
extern LPCWSTR IDS_CursorBlinkRate           ;
extern LPCWSTR IDS_DragFullWindows           ;
extern LPCWSTR IDS_GridGranularity           ;
extern LPCWSTR IDS_IconSpacing               ;
extern LPCWSTR IDS_IconFont                  ;
extern LPCWSTR IDS_IconTitleFaceName         ;
extern LPCWSTR IDS_IconTitleSize             ;
extern LPCWSTR IDS_IconTitleWrap             ;
extern LPCWSTR IDS_Pattern                   ;
extern LPCWSTR IDS_ScreenSaverActive         ;
extern LPCWSTR IDS_ScreenSaverExecutable     ;
extern LPCWSTR IDS_ScreenSaverSecure         ;
extern LPCWSTR IDS_ScreenSaverTimeout        ;
extern LPCWSTR IDS_Wallpaper                 ;
extern LPCWSTR IDS_WallpaperTiled            ;
extern LPCWSTR IDS_AvailableVirtualMemory    ;
extern LPCWSTR IDS_TotalPageFileSpace        ;
extern LPCWSTR IDS_TotalPhysicalMemory       ;
extern LPCWSTR IDS_TotalVirtualMemory        ;
extern LPCWSTR IDS_GroupName  ;
extern LPCWSTR IDS_AccountExpires        ;
extern LPCWSTR IDS_AuthorizationFlags    ;
extern LPCWSTR IDS_BadPasswordCount      ;
extern LPCWSTR IDS_CodePage              ;
extern LPCWSTR IDS_Comment               ;
extern LPCWSTR IDS_CountryCode           ;
extern LPCWSTR IDS_Flags                 ;
extern LPCWSTR IDS_FullName              ;
extern LPCWSTR IDS_HomeDirectory         ;
extern LPCWSTR IDS_HomeDirectoryDrive    ;
extern LPCWSTR IDS_LastLogoff            ;
extern LPCWSTR IDS_LastLogon             ;
extern LPCWSTR IDS_LogonHours            ;
extern LPCWSTR IDS_LogonServer           ;
extern LPCWSTR IDS_MaximumStorage        ;
extern LPCWSTR IDS_NumberOfLogons        ;
extern LPCWSTR IDS_Parms                 ;
extern LPCWSTR IDS_Password              ;
extern LPCWSTR IDS_PasswordAge           ;
extern LPCWSTR IDS_PasswordExpired       ;
extern LPCWSTR IDS_PrimaryGroupId        ;
extern LPCWSTR IDS_Privileges            ;
extern LPCWSTR IDS_Profile               ;
extern LPCWSTR IDS_ScriptPath            ;
extern LPCWSTR IDS_UnitsPerWeek          ;
extern LPCWSTR IDS_UserComment           ;
extern LPCWSTR IDS_UserId                ;
extern LPCWSTR IDS_UserType              ;
extern LPCWSTR IDS_Workstations          ;
extern LPCWSTR IDS_DefaultIPGateway      ;
extern LPCWSTR IDS_DHCPEnabled           ;
extern LPCWSTR IDS_DHCPLeaseExpires      ;
extern LPCWSTR IDS_DHCPLeaseObtained     ;
extern LPCWSTR IDS_DHCPServer            ;
extern LPCWSTR IDS_IOAddress             ;
extern LPCWSTR IDS_IPAddress             ;
extern LPCWSTR IDS_IPSubnet              ;
extern LPCWSTR IDS_IPXAddress            ;
extern LPCWSTR IDS_IRQ                   ;
extern LPCWSTR IDS_MACAddress            ;
extern LPCWSTR IDS_AbortReadOrWriteOnError  ;
extern LPCWSTR IDS_BaudRate                 ;
extern LPCWSTR IDS_BinaryModeEnabled        ;
extern LPCWSTR IDS_BitsPerByte              ;
extern LPCWSTR IDS_ContinueTransmitOnXOff   ;
extern LPCWSTR IDS_CTSOutflowControl        ;
extern LPCWSTR IDS_DiscardNULLBytes         ;
extern LPCWSTR IDS_DSROutflowControl        ;
extern LPCWSTR IDS_DSRSensitivity           ;
extern LPCWSTR IDS_DTRFlowControlType       ;
extern LPCWSTR IDS_EndOfFileCharacter       ;
extern LPCWSTR IDS_ErrorReplaceCharacter    ;
extern LPCWSTR IDS_ErrorReplacementEnabled  ;
extern LPCWSTR IDS_EventCharacter           ;
extern LPCWSTR IDS_IsBusy                   ;
extern LPCWSTR IDS_Parity                   ;
extern LPCWSTR IDS_ParityCheckEnabled       ;
extern LPCWSTR IDS_RTSFlowControlType       ;
extern LPCWSTR IDS_StopBits                 ;
extern LPCWSTR IDS_XOffCharacter            ;
extern LPCWSTR IDS_XOffTransmitThreshold    ;
extern LPCWSTR IDS_XOnCharacter             ;
extern LPCWSTR IDS_XOnTransmitThreshold     ;
extern LPCWSTR IDS_XOnXOffInflowControl     ;
extern LPCWSTR IDS_XOnXOffOutflowControl    ;
extern LPCWSTR IDS_DaylightInEffect      ;
extern LPCWSTR IDS_Bias                  ;
extern LPCWSTR IDS_StandardName          ;
extern LPCWSTR IDS_StandardYear          ;
extern LPCWSTR IDS_StandardMonth         ;
extern LPCWSTR IDS_StandardDayOfWeek     ;
extern LPCWSTR IDS_StandardDay           ;
extern LPCWSTR IDS_StandardHour          ;
extern LPCWSTR IDS_StandardMinute        ;
extern LPCWSTR IDS_StandardSecond        ;
extern LPCWSTR IDS_StandardMillisecond   ;
extern LPCWSTR IDS_StandardBias          ;
extern LPCWSTR IDS_DaylightName          ;
extern LPCWSTR IDS_DaylightYear          ;
extern LPCWSTR IDS_DaylightMonth         ;
extern LPCWSTR IDS_DaylightDayOfWeek     ;
extern LPCWSTR IDS_DaylightDay           ;
extern LPCWSTR IDS_DaylightHour          ;
extern LPCWSTR IDS_DaylightMinute        ;
extern LPCWSTR IDS_DaylightSecond        ;
extern LPCWSTR IDS_DaylightMillisecond   ;
extern LPCWSTR IDS_DaylightBias          ;
extern LPCWSTR IDS_ConnectionType    ;
extern LPCWSTR IDS_RemotePath        ;
extern LPCWSTR IDS_LocalName         ;
extern LPCWSTR IDS_RemoteName        ;
extern LPCWSTR IDS_ProviderName      ;
extern LPCWSTR IDS_DisplayType       ;
extern LPCWSTR IDS_ResourceType      ;
extern LPCWSTR IDS_GroupOrder  ;
extern LPCWSTR IDS_CommandLine       ;
extern LPCWSTR IDS_Dependencies      ;
extern LPCWSTR IDS_DisplayName       ;
extern LPCWSTR IDS_ErrorControl      ;
extern LPCWSTR IDS_LoadOrderGroup    ;
extern LPCWSTR IDS_PathName          ;
extern LPCWSTR IDS_StartName         ;
extern LPCWSTR IDS_StartType         ;
extern LPCWSTR IDS_TagId             ;
extern LPCWSTR IDS_AcceptStop        ;
extern LPCWSTR IDS_AcceptPause       ;
extern LPCWSTR IDS_AutomaticResetBootOption      ;
extern LPCWSTR IDS_AutomaticResetCapability      ;
extern LPCWSTR IDS_AutomaticResetStatus          ;
extern LPCWSTR IDS_AutomaticResetTimerInterval   ;
extern LPCWSTR IDS_AutomaticResetTimerReset      ;
extern LPCWSTR IDS_BootRomSupported              ;
extern LPCWSTR IDS_BootupState                   ;
extern LPCWSTR IDS_ConditionalReboot             ;
extern LPCWSTR IDS_InfraredSupported             ;
extern LPCWSTR IDS_InstallationDate              ;
extern LPCWSTR IDS_Locale                        ;
extern LPCWSTR IDS_LockKeyboardAndMouse          ;
extern LPCWSTR IDS_LockPCPowerOnAndResetButtons  ;
extern LPCWSTR IDS_LockSystem                    ;
extern LPCWSTR IDS_NetworkServerModeEnabled      ;
extern LPCWSTR IDS_PowerManagementSupported      ;
extern LPCWSTR IDS_PowerManagementCapabilities    ;
extern LPCWSTR IDS_PowerManagementEnabled             ;
extern LPCWSTR IDS_SystemCreationClassName                ;
extern LPCWSTR IDS_SystemName                                     ;
extern LPCWSTR IDS_ResetBootOption               ;
extern LPCWSTR IDS_ResetTimeout                  ;
extern LPCWSTR IDS_SystemFilesNotModified        ;
extern LPCWSTR IDS_SystemRole                    ;
extern LPCWSTR IDS_SystemType                    ;
extern LPCWSTR IDS_NumberOfProcessors            ;
extern LPCWSTR IDS_UnconditionalReboot           ;
extern LPCWSTR IDS_UserName                      ;
extern LPCWSTR IDS_Created                       ;
extern LPCWSTR IDS_ExecutablePath                ;
extern LPCWSTR IDS_Exited                        ;
extern LPCWSTR IDS_MaximumWorkingSetSize         ;
extern LPCWSTR IDS_MinimumWorkingSetSize         ;
extern LPCWSTR IDS_PageFaults                    ;
extern LPCWSTR IDS_PageFileUsage                 ;
extern LPCWSTR IDS_PeakPageFileUsage             ;
extern LPCWSTR IDS_PeakWorkingSetSize            ;
extern LPCWSTR IDS_QuotaNonPagedPoolUsage        ;
extern LPCWSTR IDS_QuotaPagedPoolUsage           ;
extern LPCWSTR IDS_QuotaPeakNonPagedPoolUsage    ;
extern LPCWSTR IDS_QuotaPeakPagedPoolUsage       ;
extern LPCWSTR IDS_ThreadCount                   ;
extern LPCWSTR IDS_KernelModeTime                ;
extern LPCWSTR IDS_UserModeTime                                  ;
extern LPCWSTR IDS_WindowsVersion                ;
extern LPCWSTR IDS_Characteristics   ;
extern LPCWSTR IDS_EndingAddress     ;
extern LPCWSTR IDS_PrimaryBIOS       ;
extern LPCWSTR IDS_ReleaseDate       ;
extern LPCWSTR IDS_SerialNumber      ;
extern LPCWSTR IDS_StartingAddress   ;
extern LPCWSTR IDS_Verify            ;
extern LPCWSTR IDS_BootDevice            ;
extern LPCWSTR IDS_CSDVersion            ;
extern LPCWSTR IDS_Primary               ;
extern LPCWSTR IDS_SystemDirectory       ;
extern LPCWSTR IDS_SystemStartOptions    ;
extern LPCWSTR IDS_WindowsDirectory      ;
extern LPCWSTR IDS_EnforcesACLs    ;
extern LPCWSTR IDS_DeviceType           ;
extern LPCWSTR IDS_Length               ;       
extern LPCWSTR IDS_ShareDisposition     ;
extern LPCWSTR IDS_Start                ;
extern LPCWSTR IDS_DeviceDescriptorBlock     ;
extern LPCWSTR IDS_IdentiferNumber           ;
extern LPCWSTR IDS_PM_API                    ;
extern LPCWSTR IDS_ServiceTableSize          ;
extern LPCWSTR IDS_V86_API                   ;
extern LPCWSTR IDS_AccountDisabled               ;
extern LPCWSTR IDS_AccountLockout                ;
extern LPCWSTR IDS_CannotChangePassword          ;
extern LPCWSTR IDS_ChangePasswordOnNextLogon     ;
extern LPCWSTR IDS_Domain                        ;
extern LPCWSTR IDS_Organization                  ;
extern LPCWSTR IDS_Phone                         ;
extern LPCWSTR IDS_AddressRange      ;
extern LPCWSTR IDS_MemoryType        ;
extern LPCWSTR IDS_Owner             ;
extern LPCWSTR IDS_BurstMode     ;
extern LPCWSTR IDS_DMAChannel    ;
extern LPCWSTR IDS_ChannelWidth  ;
extern LPCWSTR IDS_Port          ;
extern LPCWSTR IDS_AffinityMask      ;
extern LPCWSTR IDS_Availability      ;
extern LPCWSTR IDS_InterruptType     ;
extern LPCWSTR IDS_IRQNumber         ;
extern LPCWSTR IDS_Level             ;
extern LPCWSTR IDS_Shareable         ;
extern LPCWSTR IDS_TriggerType       ;
extern LPCWSTR IDS_Vector            ;
extern LPCWSTR IDS_Address  ;
extern LPCWSTR IDS_ProductName  ;
extern LPCWSTR IDS_Binary                    ;
extern LPCWSTR IDS_MaximumBaudRate           ;
extern LPCWSTR IDS_MaximumInputBufferSize    ;
extern LPCWSTR IDS_MaximumOutputBufferSize   ;
extern LPCWSTR IDS_ProviderType              ;
extern LPCWSTR IDS_SettableBaudRate          ;
extern LPCWSTR IDS_SettableDataBits          ;
extern LPCWSTR IDS_SettableFlowControl       ;
extern LPCWSTR IDS_SettableParity            ;
extern LPCWSTR IDS_SettableParityCheck       ;
extern LPCWSTR IDS_SettableRLSD              ;
extern LPCWSTR IDS_SettableStopBits          ;
extern LPCWSTR IDS_Supports16BitMode         ;
extern LPCWSTR IDS_SupportsDTRDSR            ;
extern LPCWSTR IDS_SupportsIntervalTimeouts  ;
extern LPCWSTR IDS_SupportsParityCheck       ;
extern LPCWSTR IDS_SupportsRLSD              ;
extern LPCWSTR IDS_SupportsRTSCTS            ;
extern LPCWSTR IDS_SupportsSettableXOnXOff   ;
extern LPCWSTR IDS_SupportsSpecialChars      ;
extern LPCWSTR IDS_SupportsElapsedTimeouts   ;
extern LPCWSTR IDS_SupportsXOnXOff           ;
extern LPCWSTR IDS_Capabilities     ;
extern LPCWSTR IDS_DmaSupport       ;
extern LPCWSTR IDS_DriverName        ;
extern LPCWSTR IDS_DeviceMap             ;
extern LPCWSTR IDS_HardwareVersion       ;
extern LPCWSTR IDS_InterruptNumber   ;
extern LPCWSTR IDS_AttachedTo         ;
extern LPCWSTR IDS_BlindOff           ;
extern LPCWSTR IDS_BlindOn            ;
extern LPCWSTR IDS_CallSetupFailTimer ;
extern LPCWSTR IDS_CompatibilityFlags ;
extern LPCWSTR IDS_CompressionOff     ;
extern LPCWSTR IDS_CompressionOn      ;
extern LPCWSTR IDS_ConfigurationDialog;
extern LPCWSTR IDS_DCB                ;
extern LPCWSTR IDS_Default            ;
extern LPCTSTR IDT_Default            ;
extern LPCWSTR IDS_DeviceLoader       ;
extern LPCWSTR IDS_DialPrefix         ;
extern LPCWSTR IDS_DialSuffix         ;
extern LPCWSTR IDS_DriverDate          ;
extern LPCWSTR IDS_ErrorControlForced ;
extern LPCWSTR IDS_ErrorControlOff    ;
extern LPCWSTR IDS_ErrorControlOn     ;
extern LPCWSTR IDS_FlowControlHard    ;
extern LPCWSTR IDS_FlowControlSoft    ;
extern LPCWSTR IDS_FlowControlOff     ;
extern LPCWSTR IDS_InactivityScale    ;
extern LPCWSTR IDS_InactivityTimeout  ;
extern LPCWSTR IDS_ModemInfPath       ;
extern LPCWSTR IDS_ModemInfSection    ;
extern LPCWSTR IDS_Model              ;
extern LPCWSTR IDS_ModulationBell     ;
extern LPCWSTR IDS_ModulationCCITT    ;
extern LPCWSTR IDS_PortSubClass       ;
extern LPCWSTR IDS_Prefix             ;
extern LPCWSTR IDS_Properties         ;
extern LPCWSTR IDS_Pulse              ;
extern LPCWSTR IDS_Reset              ;
extern LPCWSTR IDS_ResponsesKeyName   ;
extern LPCWSTR IDS_SpeakerModeDial    ;
extern LPCWSTR IDS_SpeakerModeOff     ;
extern LPCWSTR IDS_SpeakerModeOn      ;
extern LPCWSTR IDS_SpeakerModeSetup   ;
extern LPCWSTR IDS_SpeakerVolumeHigh  ;
extern LPCWSTR IDS_SpeakerVolumeLow   ;
extern LPCWSTR IDS_SpeakerVolumeMed   ;
extern LPCWSTR IDS_StringFormat       ;
extern LPCWSTR IDS_Terminator         ;
extern LPCWSTR IDS_Tone               ;
extern LPCWSTR IDS_VoiceSwitchFeature ;
extern LPCWSTR IDS_PrimaryBusType    ;
extern LPCWSTR IDS_SecondaryBusType  ;
extern LPCWSTR IDS_RevisionNumber    ;
extern LPCWSTR IDS_EnableWheelDetection  ;
extern LPCWSTR IDS_InfFileName           ;
extern LPCWSTR IDS_InfSection            ;
extern LPCWSTR IDS_SampleRate            ;
extern LPCWSTR IDS_Attributes            ;
extern LPCWSTR IDS_DefaultPriority      ;
extern LPCWSTR IDS_JobCount              ;
extern LPCWSTR IDS_PortName              ;
extern LPCWSTR IDS_PrintJobDataType      ;
extern LPCWSTR IDS_Priority             ;
extern LPCWSTR IDS_SeparatorFile         ;
extern LPCWSTR IDS_ServerName            ;
extern LPCWSTR IDS_ShareName             ;
extern LPCWSTR IDS_StartTime            ;
extern LPCWSTR IDS_UntilTime            ;
extern LPCWSTR IDS_Disabled             ;
extern LPCWSTR IDS_PasswordRequired     ;
extern LPCWSTR IDS_PasswordChangeable   ;
extern LPCWSTR IDS_Lockout              ;
extern LPCWSTR IDS_PasswordExpires      ;
extern LPCWSTR IDS_AccountType          ;
extern LPCWSTR IDS_SIDType              ;
extern LPCWSTR IDS_SID                  ;
extern LPCWSTR IDS_GroupComponent       ;
extern LPCWSTR IDS_PartComponent        ;
extern LPCWSTR IDS_DataType          ;
extern LPCWSTR IDS_Document         ;
extern LPCWSTR IDS_HostPrintQueue    ;
extern LPCWSTR IDS_JobId             ;
extern LPCWSTR IDS_PagesPrinted      ;
extern LPCWSTR IDS_Parameters        ;
extern LPCWSTR IDS_PrintProcessor    ;
extern LPCWSTR IDS_Size              ;
extern LPCWSTR IDS_TotalPages        ;
extern LPCWSTR IDS_Drive                    ;
extern LPCWSTR IDS_FileSystemFlags          ;
extern LPCWSTR IDS_FileSystemFlagsEx        ;
extern LPCWSTR IDS_Id                       ;
extern LPCWSTR IDS_MaximumComponentLength   ;
extern LPCWSTR IDS_RevisionLevel            ;
extern LPCWSTR IDS_SCSILun                  ;
extern LPCWSTR IDS_SCSITargetId             ;
extern LPCWSTR IDS_VolumeName               ;
extern LPCWSTR IDS_VolumeSerialNumber       ;
extern LPCWSTR IDS_SCSIBus          ;
extern LPCWSTR IDS_SCSIPort         ;
extern LPCWSTR IDS_SCSILogicalUnit  ; 
extern LPCWSTR IDS_SCSITargetID     ;
extern LPCWSTR IDS_FileSystem  ;
extern LPCWSTR IDS_BootPartition     ;
extern LPCWSTR IDS_Compressed        ;
extern LPCWSTR IDS_DiskIndex         ;
extern LPCWSTR IDS_Encrypted         ;
extern LPCWSTR IDS_HiddenSectors     ;
extern LPCWSTR IDS_RewritePartition  ;
extern LPCWSTR IDS_StartingOffset    ;
extern LPCWSTR IDS_BitsPerPel        ;
extern LPCWSTR IDS_DeviceName        ;
extern LPCWSTR IDS_DisplayFlags      ;
extern LPCWSTR IDS_DisplayFrequency  ;
extern LPCWSTR IDS_DitherType        ;
extern LPCWSTR IDS_DriverVersion     ;
extern LPCWSTR IDS_ICMIntent         ;
extern LPCWSTR IDS_ICMMethod         ;
extern LPCWSTR IDS_LogPixels         ;
extern LPCWSTR IDS_PelsHeight        ;
extern LPCWSTR IDS_PelsWidth         ;
extern LPCWSTR IDS_SpecificationVersion  ;
extern LPCWSTR IDS_TTOption          ;
extern LPCWSTR IDS_BitsPerPixel                  ;
extern LPCWSTR IDS_ColorPlanes                   ;
extern LPCWSTR IDS_DeviceEntriesInAColorTable    ;
extern LPCWSTR IDS_ColorTableEntries             ;
extern LPCWSTR IDS_DeviceSpecificPens            ;
extern LPCWSTR IDS_HorizontalResolution          ;
extern LPCWSTR IDS_RefreshRate                   ;
extern LPCWSTR IDS_ReservedSystemPaletteEntries  ;
extern LPCWSTR IDS_SystemPaletteEntries          ;
extern LPCWSTR IDS_VerticalResolution            ;
extern LPCWSTR IDS_VideoMode                     ;
extern LPCWSTR IDS_ActualColorResolution        ;
extern LPCWSTR IDS_AdapterChipType              ;
extern LPCWSTR IDS_AdapterCompatibility         ;
extern LPCWSTR IDS_AdapterDACType               ;
extern LPCWSTR IDS_AdapterDescription           ;
extern LPCWSTR IDS_AdapterLocale                ;
extern LPCWSTR IDS_AdapterRAM                   ;
extern LPCWSTR IDS_AdapterType                  ;
extern LPCWSTR IDS_InstalledDisplayDrivers      ;
extern LPCWSTR IDS_MonitorManufacturer          ;
extern LPCWSTR IDS_MonitorType                  ;
extern LPCWSTR IDS_PixelsPerXLogicalInch        ;
extern LPCWSTR IDS_PixelsPerYLogicalInch        ;
extern LPCWSTR IDS_ScanMode                     ;
extern LPCWSTR IDS_ScreenHeight                 ;
extern LPCWSTR IDS_ScreenWidth                  ;
extern LPCWSTR IDS_Collate           ;
extern LPCWSTR IDS_Color             ;
extern LPCWSTR IDS_Copies            ;
extern LPCWSTR IDS_Duplex            ;
extern LPCWSTR IDS_FormName          ;
extern LPCWSTR IDS_MediaType         ;
extern LPCWSTR IDS_Orientation       ;
extern LPCWSTR IDS_PaperLength       ;
extern LPCWSTR IDS_PaperSize         ;
extern LPCWSTR IDS_PaperWidth        ;
extern LPCWSTR IDS_PrintQuality      ;
extern LPCWSTR IDS_Scale             ;
extern LPCWSTR IDS_YResolution       ;
extern LPCWSTR IDS_VariableName      ;
extern LPCWSTR IDS_VariableValue     ;
extern LPCWSTR IDS_MaximumSize  ;
extern LPCWSTR IDS_InitialSize ;
extern LPCWSTR IDS_AllocatedBaseSize  ;
extern LPCWSTR IDS_CurrentUsage  ;
extern LPCWSTR IDS_AllowMaximum      ;
extern LPCWSTR IDS_MaximumAllowed    ;
extern LPCWSTR IDS_Location          ;
extern LPCWSTR IDS_DriveType         ;
extern LPCWSTR  IDS_Antecedent  ;
extern LPCWSTR  IDS_Dependent   ;
extern LPCWSTR  IDS_Adapter             ;
extern LPCWSTR  IDS_Protocol    ;
extern LPCWSTR  IDS_Service             ;
extern LPCWSTR  IDS_Element             ;
extern LPCWSTR  IDS_Setting             ;
extern LPCWSTR IDS_SupportsDiskQuotas;
extern LPCWSTR IDS_QuotasIncomplete;
extern LPCWSTR IDS_QuotasRebuilding;
extern LPCWSTR IDS_QuotasDisabled;
extern LPCWSTR IDS_VolumeDirty;
extern LPCWSTR IDS_SessionID;
extern LPCWSTR IDS_LocalAccount;

extern LPCWSTR IDS_CurrentTimeZone;
extern LPCWSTR IDS_NameFormat;
extern LPCWSTR IDS_Roles;
extern LPCWSTR IDS_DomainRole;
extern LPCWSTR IDS_PrimaryOwnerContact;
extern LPCWSTR IDS_SupportContactDescription;
extern LPCWSTR IDS_SystemStartupDelay;
extern LPCWSTR IDS_SystemVariable;

extern LPCWSTR  IDS_CimWin32Namespace           ;
extern LPCWSTR  IDS_GETLASTERROR;

extern LPCWSTR  IDS_CfgMgrDeviceStatus_OK       ;
extern LPCWSTR  IDS_CfgMgrDeviceStatus_ERR      ;

extern LPCWSTR  IDS_PRINTER_STATUS_PAUSED;
extern LPCWSTR  IDS_PRINTER_STATUS_PENDING_DELETION;
extern LPCWSTR  IDS_PRINTER_STATUS_BUSY;
extern LPCWSTR  IDS_PRINTER_STATUS_DOOR_OPEN;
extern LPCWSTR  IDS_PRINTER_STATUS_ERROR;
extern LPCWSTR  IDS_PRINTER_STATUS_INITIALIZING;
extern LPCWSTR  IDS_PRINTER_STATUS_IO_ACTIVE;
extern LPCWSTR  IDS_PRINTER_STATUS_MANUAL_FEED;
extern LPCWSTR  IDS_PRINTER_STATUS_NO_TONER;
extern LPCWSTR  IDS_PRINTER_STATUS_NOT_AVAILABLE;
extern LPCWSTR  IDS_PRINTER_STATUS_OFFLINE;
extern LPCWSTR  IDS_PRINTER_STATUS_OUT_OF_MEMORY;
extern LPCWSTR  IDS_PRINTER_STATUS_OUTPUT_BIN_FULL;
extern LPCWSTR  IDS_PRINTER_STATUS_PAGE_PUNT;
extern LPCWSTR  IDS_PRINTER_STATUS_PAPER_JAM;
extern LPCWSTR  IDS_PRINTER_STATUS_PAPER_OUT;
extern LPCWSTR  IDS_PRINTER_STATUS_PAPER_PROBLEM;
extern LPCWSTR  IDS_PRINTER_STATUS_PAUSED;
extern LPCWSTR  IDS_PRINTER_STATUS_PENDING_DELETION;
extern LPCWSTR  IDS_PRINTER_STATUS_PRINTING;
extern LPCWSTR  IDS_PRINTER_STATUS_PROCESSING;
extern LPCWSTR  IDS_PRINTER_STATUS_TONER_LOW;
extern LPCWSTR  IDS_PRINTER_STATUS_UNAVAILABLE;
extern LPCWSTR  IDS_PRINTER_STATUS_USER_INTERVENTION;
extern LPCWSTR  IDS_PRINTER_STATUS_WAITING;
extern LPCWSTR  IDS_PRINTER_STATUS_WARMING_UP; 

extern LPCWSTR  IDS_DetectedErrorState;
extern LPCWSTR  IDS_Ready;

extern LPCWSTR  IDS_STATUS_OK;
extern LPCWSTR  IDS_STATUS_Degraded;
extern LPCWSTR  IDS_STATUS_Error;
extern LPCWSTR  IDS_STATUS_Unknown;
extern LPCWSTR  IDS_PrinterStatus;

extern LPCWSTR  IDS_PaperSizeSupported;
extern LPCWSTR  IDS_Persistent;
extern LPCWSTR  IDS_Resource_Remembered;

extern LPCWSTR IDS_Device;
extern LPCWSTR  IDS_Current;
extern LPCWSTR  IDS_Resource_Connected;

extern LPCWSTR IDS_LM_Workstation;
extern LPCWSTR IDS_LM_Server;
extern LPCWSTR IDS_SQLServer;
extern LPCWSTR IDS_Domain_Controller;
extern LPCWSTR IDS_Domain_Backup_Controller;
extern LPCWSTR IDS_Timesource;
extern LPCWSTR IDS_AFP;
extern LPCWSTR IDS_Novell;
extern LPCWSTR IDS_Domain_Member;
extern LPCWSTR IDS_Local_List_Only;
extern LPCWSTR IDS_Print;
extern LPCWSTR IDS_DialIn;
extern LPCWSTR IDS_Xenix_Server;
extern LPCWSTR IDS_MFPN;
extern LPCWSTR IDS_NT;
extern LPCWSTR IDS_WFW;
extern LPCWSTR IDS_Server_NT;
extern LPCWSTR IDS_Potential_Browser;
extern LPCWSTR IDS_Backup_Browser;
extern LPCWSTR IDS_Master_Browser;
extern LPCWSTR IDS_Domain_Master;
extern LPCWSTR IDS_Domain_Enum;
extern LPCWSTR IDS_Windows_9x;
extern LPCWSTR IDS_DFS;
extern LPCWSTR IDS_Alias;
extern LPCWSTR IDS_JobStatus;

extern LPCWSTR IDS_UPSName;
extern LPCWSTR IDS_UPSBatteryName;
extern LPCWSTR IDS_BatteryName;

extern LPCWSTR IDS_PNPDeviceID;
extern LPCWSTR IDS_ClassGuid;
extern LPCWSTR IDS_ConfigManagerErrorCode;
extern LPCWSTR IDS_ConfigManagerUserConfig;

extern LPCWSTR IDS_ProcessCreationClassName;
extern LPCWSTR IDS_ProcessHandle;
extern LPCWSTR IDS_ExecutionState;
extern LPCWSTR IDS_PriorityBase;
extern LPCWSTR IDS_StartAddress;
extern LPCWSTR IDS_ThreadState;
extern LPCWSTR IDS_ThreadWaitReason;

extern LPCWSTR IDS_OSAutoDiscovered;
extern LPCWSTR IDS_LogonId;
extern LPCWSTR IDS_AuthenticationPackage;
extern LPCWSTR IDS_LogonType;
extern LPCWSTR IDS_LogonTime;


// Security provider related strings:
extern LPCWSTR IDS_SecuredObject;
extern LPCWSTR IDS_Account;
extern LPCWSTR IDS_AccountName;
extern LPCWSTR IDS_ReferencedDomainName;
extern LPCWSTR IDS_AceType;
extern LPCWSTR IDS_AceFlags;
extern LPCWSTR IDS_AccessMask;
extern LPCWSTR IDS_OwnedObject;
extern LPCWSTR IDS_InheritedObjectGUID;
extern LPCWSTR IDS_ObjectTypeGUID;
extern LPCWSTR IDS_Sid;
extern LPCWSTR IDS_Trustee;
extern LPCWSTR IDS_ControlFlags;
extern LPCWSTR IDS_Group;
extern LPCWSTR IDS_DACL;
extern LPCWSTR IDS_SACL;
extern LPCWSTR IDS_SidLength;
extern LPCWSTR IDS_SecuritySetting;
extern LPCWSTR IDS_BinaryRepresentation;
extern LPCWSTR IDS_Inheritance;
extern LPCWSTR IDS_SIDString;
extern LPCWSTR IDS_OwnerPermissions;
/////////////////////////////////////////////////////////////////////////////////////
//added for ComCatalog classes

extern LPCWSTR IDS_Category ;
extern LPCWSTR IDS_Component ;
extern LPCWSTR IDS_ComponentId ;
extern LPCWSTR IDS_CategoryId ;
extern LPCWSTR IDS_Insertable ;
extern LPCWSTR IDS_JavaClass ;
extern LPCWSTR IDS_InprocServer ;
extern LPCWSTR IDS_InprocServer32 ;
extern LPCWSTR IDS_LocalServer ;
extern LPCWSTR IDS_LocalServer32 ;
extern LPCWSTR IDS_ThreadingModel ;
extern LPCWSTR IDS_InprocHandler ;
extern LPCWSTR IDS_InprocHandler32 ;
extern LPCWSTR IDS_TreatAsClsid ;
extern LPCWSTR IDS_AutoTreatAsClsid ;
extern LPCWSTR IDS_ProgId ;
extern LPCWSTR IDS_VersionIndependentProgId ;
extern LPCWSTR IDS_TypeLibraryId ;
extern LPCWSTR IDS_AppID ;
extern LPCWSTR IDS_UseSurrogate ;
extern LPCWSTR IDS_CustomSurrogate ;
extern LPCWSTR IDS_RemoteServerName ;
extern LPCWSTR IDS_RunAsUser ;
extern LPCWSTR IDS_AuthenticationLevel ;
extern LPCWSTR IDS_LocalService ;
extern LPCWSTR IDS_EnableAtStorageActivation ;
extern LPCWSTR IDS_OldVersion ;
extern LPCWSTR IDS_NewVersion ;
extern LPCWSTR IDS_AutoConvertToClsid ;                 
extern LPCWSTR IDS_DefaultIcon ;
extern LPCWSTR IDS_ToolBoxBitmap32 ;
extern LPCWSTR IDS_ServiceParameters ;                  
extern LPCWSTR IDS_ShortDisplayName ;
extern LPCWSTR IDS_LongDisplayName ;
extern LPCWSTR IDS_Client ;
extern LPCWSTR IDS_Application ;

extern LPCWSTR IDS_Started;
extern LPCWSTR IDS_ProcessId;
extern LPCWSTR IDS_ExitCode;
extern LPCWSTR IDS_ServiceSpecificExitCode;
extern LPCWSTR IDS_CheckPoint;
extern LPCWSTR IDS_WaitHint;
extern LPCWSTR IDS_DesktopInteract;
extern LPCWSTR IDS_StartMode;
extern LPCWSTR IDS_State;

extern LPCWSTR IDS_BlockSize;
extern LPCWSTR IDS_NumberOfBlocks;
extern LPCWSTR IDS_PrimaryPartition;
extern LPCWSTR IDS_Handedness;
extern LPCWSTR IDS_DoubleSpeedThreshold;
extern LPCWSTR IDS_QuadSpeedThreshold;
extern LPCWSTR IDS_PurposeDescription;
extern LPCWSTR IDS_SameElement;
extern LPCWSTR IDS_SystemElement;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\timeddllresource.cpp ===
//=================================================================

//

// TimedDllResource.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include "ResourceManager.h"
#include "TimerQueue.h"
#include "TimedDllResource.h"
#include "TimeOutRule.h"
#include "ProvExce.h"

#define CACHED_DLL_TIMEOUT	300000
CTimedDllResource::~CTimedDllResource ()
{
	LogMessage ( L"Entering ~CTimedDllResource" ) ;
	if ( m_pRules )
	{
		m_pRules->Detach () ;
		m_pRules->Release () ;
		m_pRules = NULL ;
	}
	LogMessage ( L"Leaving ~CTimedDllResource" ) ;
}

BOOL CTimedDllResource :: OnFinalRelease()
{
	if ( m_pRules )
	{
		m_pRules->Detach () ;
		m_pRules->Release () ;
		m_pRules = NULL ;
		return TRUE ;
	}
	else
	{
/*
 * Add an unload rule
 */
		m_pRules = new CTimeOutRule ( CACHED_DLL_TIMEOUT, this, m_pResources ) ;

		if( !m_pRules )
		{
			throw CHeap_Exception( CHeap_Exception::E_ALLOCATION_ERROR ) ;
		}

		m_pRules->AddRef () ;
/*
 * Up the reference count to wait for the callback to come
 */
		++m_lRef ;
		return FALSE ;
	}
}

BOOL CTimedDllResource :: OnAcquire ()
{
/*
 * somebody tried to acquire us, so we don't want the unload rule hanging around
 */

	if ( m_pRules )
	{
		m_pRules->Detach () ;
		m_pRules->Release () ;
		m_pRules = NULL ;
/*
 * decrement the ref count which we'd added to wait for the callback
 */
		--m_lRef ;
	}

	return TRUE ;
}

void CTimedDllResource :: RuleEvaluated ( const CRule *a_Rule )
{
	if ( m_pRules->CheckRule () )
	{
/*
 * Decrement the Refcount which we'd added to wait for the callback & check if we've to delete ourselves
 */
		Release () ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\svrapiapi.cpp ===
//=================================================================

//

// SvrApiApi.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "SvrApiApi.h"
#include "DllWrapperCreatorReg.h"



// {C77B8EE2-D02A-11d2-911F-0060081A46FD}
static const GUID g_guidSvrApiApi =
{ 0xc77b8ee2, 0xd02a, 0x11d2, { 0x91, 0x1f, 0x0, 0x60, 0x8, 0x1a, 0x46, 0xfd } };


static const TCHAR g_tstrSvrApi[] = _T("SVRAPI.DLL");


/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CSvrApiApi, &g_guidSvrApiApi, g_tstrSvrApi> MyRegisteredSvrApiWrapper;


/******************************************************************************
 * Constructor
 ******************************************************************************/
CSvrApiApi::CSvrApiApi(LPCTSTR a_tstrWrappedDllName)
 : CDllWrapperBase(a_tstrWrappedDllName),

#ifdef NTONLY
	m_pfnNetShareEnumSticky(NULL),
	m_pfnNetShareDelSticky(NULL),
	m_pfnNetShareCheck(NULL),
#endif
	m_pfnNetShareEnum(NULL),
	m_pfnNetShareGetInfo(NULL),
	m_pfnNetServerGetInfo(NULL),
   	m_pfnNetShareSetInfo(NULL),
	m_pfnNetShareAdd(NULL),
	m_pfnNetShareDel(NULL)

{
}


/******************************************************************************
 * Destructor
 ******************************************************************************/
CSvrApiApi::~CSvrApiApi()
{
}


/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CSvrApiApi::Init()
{
    bool fRet = LoadLibrary();
    if(fRet)
    {
        m_pfnNetShareEnum = (PFN_SVRAPI_NET_SHARE_ENUM)
                                    GetProcAddress("NetShareEnum");
        m_pfnNetShareGetInfo = (PFN_SVRAPI_NET_SHARE_GET_INFO)
                                    GetProcAddress("NetShareGetInfo");
        m_pfnNetServerGetInfo = (PFN_SVRAPI_NET_SERVER_GET_INFO)
                                    GetProcAddress("NetServerGetInfo");
        m_pfnNetShareSetInfo = (PFN_SVRAPI_NET_SHARE_SET_INFO)
                                    GetProcAddress("NetShareSetInfo");
        m_pfnNetShareAdd = (PFN_SVRAPI_NET_SHARE_ADD)
                                    GetProcAddress("NetShareAdd");
        m_pfnNetShareDel = (PFN_SVRAPI_NET_SHARE_DEL)
                                    GetProcAddress("NetShareDel");
	#ifdef NTONLY
		m_pfnNetShareEnumSticky = (PFN_SVRAPI_NET_SHARE_ENUM_STICKY)
                                    GetProcAddress("NetShareEnumSticky");
		m_pfnNetShareDelSticky = (PFN_SVRAPI_NET_SHARE_DEL_STICKY)
                                    GetProcAddress("NetShareDelSticky");
        m_pfnNetShareCheck = (PFN_SVRAPI_NET_SHARE_CHECK)
                                    GetProcAddress("NetShareCheck");
	#endif

        // All these functions are considered required for all versions of
        // this dll.  Hence return false if didn't get one or more of them.
        if(

	#ifdef NTONLY
            m_pfnNetShareEnumSticky == NULL ||
			m_pfnNetShareDelSticky == NULL ||
			m_pfnNetShareCheck == NULL ||
	#endif
			m_pfnNetShareEnum == NULL ||
			m_pfnNetShareGetInfo == NULL ||
			m_pfnNetServerGetInfo == NULL ||

			m_pfnNetShareSetInfo == NULL ||
			m_pfnNetShareAdd == NULL ||
			m_pfnNetShareDel == NULL )
        {
            fRet = false;
        }
    }
    return fRet;
}




/******************************************************************************
 * Member functions wrapping SvrApi api functions. Add new functions here
 * as required.
 ******************************************************************************/
NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareEnum
(
    char FAR *a_servername,
    short a_level,
    char FAR *a_bufptr,
    unsigned short a_prefmaxlen,
    unsigned short FAR *a_entriesread,
    unsigned short FAR *a_totalentries
)
{
    return m_pfnNetShareEnum(a_servername, a_level, a_bufptr, a_prefmaxlen,
                             a_entriesread, a_totalentries);
}

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareGetInfo
(
    char FAR *a_servername,
    char FAR *a_netname,
    short a_level,
    char FAR *a_bufptr,
    unsigned short a_buflen,
    unsigned short FAR *a_totalavail
)
{
    return m_pfnNetShareGetInfo(a_servername, a_netname, a_level,
                                a_bufptr, a_buflen, a_totalavail);
}

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetServerGetInfo
(
    char FAR *a_servername,
    short a_level,
    char FAR *a_bufptr,
    unsigned short a_buflen,
    unsigned short FAR *a_totalavail
)
{
    return m_pfnNetServerGetInfo(a_servername, a_level, a_bufptr, a_buflen,
                                 a_totalavail);
}

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareEnumSticky
(
	LPTSTR      a_servername,
	DWORD       a_level,
	LPBYTE      *a_bufptr,
	DWORD       a_prefmaxlen,
	LPDWORD     a_entriesread,
	LPDWORD     a_totalentries,
	LPDWORD     a_resume_handle
)
{
    return m_pfnNetShareEnumSticky(a_servername, a_level, a_bufptr,
                                   a_prefmaxlen,a_entriesread,
                                   a_totalentries, a_resume_handle);
}
#endif

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareSetInfo
(
	const char FAR *a_servername,
	const char FAR *a_netname,
	short			a_level,
	const char FAR *a_buf,
	unsigned short a_cbBuffer,
	short          a_sParmNum
)
{
    return m_pfnNetShareSetInfo(a_servername, a_netname, a_level,
                                a_buf, a_cbBuffer, a_sParmNum);
}

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareAdd
(
	const char FAR *a_servername,
	short			a_level,
	const char FAR *a_buf,
	unsigned short	a_cbBuffer
)
{
    return m_pfnNetShareAdd(a_servername, a_level, a_buf , a_cbBuffer);
}

NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareDel
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_reserved
)
{
    return m_pfnNetShareDel(a_servername, a_netname, a_reserved);
}

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareDelSticky
(
	LPTSTR  a_servername,
	LPTSTR  a_netname,
	DWORD   a_reserved
)
{
    return m_pfnNetShareDelSticky(a_servername, a_netname, a_reserved);
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CSvrApiApi::NetShareCheck
(
	LPTSTR  a_servername,
	LPTSTR  a_device,
	LPDWORD a_type
)
{
    return m_pfnNetShareCheck(a_servername, a_device, a_type);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\timeddllresource.h ===
//=================================================================

//

// TimedDllResource.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef __TIMEDDLLRESOURCE_H__
#define __TIMEDDLLRESOURCE_H__

class CTimedDllResource : public CResource
{
protected:

	BOOL OnFinalRelease() ;
	BOOL OnAcquire () ;

	void RuleEvaluated ( const CRule *a_RuleEvaluated ) ;

public:

	CTimedDllResource() : CResource () {}
	~CTimedDllResource() ;
} ;

#endif //__TIMEDDLLRESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\timeoutrule.h ===
//=================================================================

//

// TimeOutRule.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================


class CTimeOutRule : public CRule , public CTimerEvent
{
protected:

	CResourceList *m_pResources ;
	BOOL m_bTimeOut ;
	virtual ULONG AddRef () ;
	virtual ULONG Release () ;
	void OnTimer () ;

public:

	CTimeOutRule ( DWORD dwTimeOut, CResource * pResource, CResourceList * pResources ) ;
	~CTimeOutRule  () ;
	
	void Detach () ;
	BOOL CheckRule () ;


//	void Enable () ;
//	void Disable () ;

} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\svrapiapi.h ===
//=================================================================

//

// SvrApiApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_SVRAPIAPI_H_
#define	_SVRAPIAPI_H_


#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmerr.h>
#include <ntsecapi.h>
#include <stack>
#include <comdef.h>
#include <dsrole.h> 
#include <dsgetdc.h>



/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidSvrApiApi;
extern const TCHAR g_tstrSvrApi[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_ENUM)
(
    char FAR *servername,
    short level,
    char FAR *bufptr,
    unsigned short prefmaxlen,
    unsigned short FAR *entriesread,
    unsigned short FAR *totalentries
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_GET_INFO)
(
    char FAR *servername,
    char FAR *netname,
    short level,
    char FAR *bufptr,
    unsigned short buflen,
    unsigned short FAR *totalavail
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SERVER_GET_INFO)
(
    char FAR *servername,
    short level,
    char FAR *bufptr,
    unsigned short buflen,
    unsigned short FAR *totalavail
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_ENUM_STICKY) 
(
	IN  LPTSTR      servername,
	IN  DWORD       level,
	OUT LPBYTE      *bufptr,
	IN  DWORD       prefmaxlen,
	OUT LPDWORD     entriesread,
	OUT LPDWORD     totalentries,
	IN OUT LPDWORD  resume_handle
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_SET_INFO) 
(
	IN const char FAR *	servername,
	IN const char FAR *	netname,
	IN short			level,
	IN const char FAR*	buf,
	IN unsigned short   cbBuffer,
	IN short            sParmNum 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_ADD) 
(
	IN  const char FAR *	servername,
	IN  short				level,
	IN  const char FAR *	buf,
	unsigned short			cbBuffer 
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_DEL) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_DEL_STICKY) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
);

typedef NET_API_STATUS (NET_API_FUNCTION *PFN_SVRAPI_NET_SHARE_CHECK) 
(
	IN  LPTSTR  servername,
	IN  LPTSTR  device,
	OUT LPDWORD type
);


/******************************************************************************
 * Wrapper class for Kernel32 load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class CSvrApiApi : public CDllWrapperBase
{
private:
    // Member variables (function pointers) pointing to kernel32 functions.
    // Add new functions here as required.
	PFN_SVRAPI_NET_SHARE_ENUM        m_pfnNetShareEnum;
    PFN_SVRAPI_NET_SHARE_GET_INFO    m_pfnNetShareGetInfo;
    PFN_SVRAPI_NET_SERVER_GET_INFO   m_pfnNetServerGetInfo;
    
    PFN_SVRAPI_NET_SHARE_SET_INFO    m_pfnNetShareSetInfo;
    PFN_SVRAPI_NET_SHARE_ADD         m_pfnNetShareAdd;
    PFN_SVRAPI_NET_SHARE_DEL         m_pfnNetShareDel;

#ifdef NTONLY 
	PFN_SVRAPI_NET_SHARE_ENUM_STICKY m_pfnNetShareEnumSticky;
	PFN_SVRAPI_NET_SHARE_DEL_STICKY  m_pfnNetShareDelSticky;
    PFN_SVRAPI_NET_SHARE_CHECK       m_pfnNetShareCheck;
#endif



public:

    // Constructor and destructor:
    CSvrApiApi(LPCTSTR a_tstrWrappedDllName);
    ~CSvrApiApi();

    // Inherrited initialization function.
    virtual bool Init();

    // Member functions wrapping kernel32 functions.
    // Add new functions here as required:
    NET_API_STATUS NET_API_FUNCTION NetShareEnum
    (
        char FAR *a_servername,
        short a_level,
        char FAR *a_bufptr,
        unsigned short a_prefmaxlen,
        unsigned short FAR *a_entriesread,
        unsigned short FAR *a_totalentries
    );

    NET_API_STATUS NET_API_FUNCTION NetShareGetInfo
    (
        char FAR *a_servername,
        char FAR *a_netname,
        short a_level,
        char FAR *a_bufptr,
        unsigned short a_buflen,
        unsigned short FAR *a_totalavail
    );

    NET_API_STATUS NET_API_FUNCTION NetServerGetInfo
    (
        char FAR *a_servername,
        short a_level,
        char FAR *a_bufptr,
        unsigned short a_buflen,
        unsigned short FAR *a_totalavail
    );

 
    NET_API_STATUS NET_API_FUNCTION NetShareSetInfo 
    (
	    const char FAR *a_servername,
	    const char FAR *a_netname,
	    short			a_level,
	    const char FAR *a_buf,
	    unsigned short a_cbBuffer,
	    short          a_sParmNum 
    );

    NET_API_STATUS NET_API_FUNCTION NetShareAdd 
    (
	    const char FAR *a_servername,
	    short			a_level,
	    const char FAR *a_buf,
	    unsigned short	a_cbBuffer 
    );

    NET_API_STATUS NET_API_FUNCTION NetShareDel 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_reserved
    );

#ifdef NTONLY 

   NET_API_STATUS NET_API_FUNCTION NetShareEnumSticky 
    (
	    LPTSTR      a_servername,
	    DWORD       a_level,
	    LPBYTE      *a_bufptr,
	    DWORD       a_prefmaxlen,
	    LPDWORD     a_entriesread,
	    LPDWORD     a_totalentries,
	    LPDWORD     a_resume_handle
    );


    NET_API_STATUS NET_API_FUNCTION NetShareDelSticky 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_netname,
	    DWORD   a_reserved
    );

    NET_API_STATUS NET_API_FUNCTION NetShareCheck 
    (
	    LPTSTR  a_servername,
	    LPTSTR  a_device,
	    LPDWORD a_type
    );
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\timeoutrule.cpp ===
//=================================================================

//

// TimeOutRule.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include "ResourceManager.h"
#include "TimerQueue.h"
#include "TimeOutRule.h"

CTimeOutRule :: CTimeOutRule (

	DWORD dwTimeOut,
	CResource *pResource,
	CResourceList *pResources

) : CRule ( pResource ) ,
	CTimerEvent ( dwTimeOut , FALSE )
{
	m_pResources = pResources ;
	m_bTimeOut = FALSE ;

	this->Enable () ;
}

CTimeOutRule :: ~CTimeOutRule  ()
{
}

void CTimeOutRule :: Detach ()
{
	CRule :: Detach () ;
	Disable () ;
}

BOOL CTimeOutRule :: CheckRule ()
{
	if ( m_bTimeOut )
	{
		m_bTimeOut = FALSE ;
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

void CTimeOutRule :: OnTimer ()
{
	CRule::AddRef () ;

	try
	{
		if ( m_pResource )
		{
	/*
	 * check if the cache manager is being unloaded
	 */
			if ( ! m_pResources->m_bShutDown )
			{
	/*
	 * wait for a lock on res. list
	 */
				m_pResources->LockList () ;
	/*
	 * check if the cache manager is being unloaded
	 */
				if ( ! m_pResources->m_bShutDown )
				{
					if ( m_pResource )
					{
						m_bTimeOut = TRUE ;
						m_pResource->RuleEvaluated ( this ) ;
					}
				}
				m_pResources->UnLockList () ;
			}
		}
	}
	catch( ... )
	{
		CRule::Release () ;
		throw ;
	}

	CRule::Release () ;
}

ULONG CTimeOutRule :: AddRef ()
{
	return CRule::AddRef () ;
}

ULONG CTimeOutRule :: Release ()
{
	return CRule::Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\timerqueue.h ===
//=================================================================

//

// TimerQueue.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include <windows.h>
#include <deque>

class CTimerEvent
{
public:

	CTimerEvent () : m_bEnabled ( FALSE ) , m_dwMilliseconds ( 1000 ) , m_bRepeating ( FALSE ) {} ;

	CTimerEvent ( DWORD dwTimeOut, BOOL fRepeat ) ;
	CTimerEvent ( const CTimerEvent &rTimerEvent ) ;

	virtual ~CTimerEvent () {} ;	

	virtual void OnTimer () {} ;

	virtual ULONG AddRef () = 0 ; 
	virtual ULONG Release () = 0 ; 

	DWORD GetMilliSeconds () ;
	BOOL Repeating () ;
	BOOL Enabled () ;

	__int64		int64Time;						// Scheduled callback as an offset of the system clock. 
protected:

	BOOL		m_bEnabled ;
	DWORD	 	m_dwMilliseconds;				// Scheduled callback time in milliseconds
	BOOL		m_bRepeating;					// indicates a one shot or repeating callback 


	void Disable () ;
	void Enable () ;

};
/*
class CRuleTimerEvent : public CTimerEvent
{
protected:

	CRule *m_pRule ;			// argument for the timed callback

protected:

	CRuleTimerEvent ( CRule *a_Rule ) : m_Rule ( a_Rule ) { if ( m_Rule ) m_Rule->AddRef () } ;

	CRuleTimerEvent ( CRule *a_Rule , BOOL a_Enable , DWORD dwTimeOut, BOOL fRepeat ) ;
	CRuleTimerEvent ( const CRuleTimerEvent &rTimerEvent ) ;

public:

	~CRuleTimerEvent () {} ;	

	CRule *GetRule () ;
} ;
*/
class CTimerQueue
{
public:

	static CTimerQueue s_TimerQueue ;

public:

		CTimerQueue();
		~CTimerQueue();

		void OnShutDown();
		void Init();
		
		BOOL QueueTimer( CTimerEvent *pTimerEntry );
		BOOL DeQueueTimer( CTimerEvent *pTimerEntry );

protected:

	void	vUpdateScheduler();
	__int64 int64Clock(); // System clock in milliseconds
	
	// pure virtual
//	virtual DWORD OnTimer( const CTimerEntry *pTimerEntry ) = 0;

private:

	DWORD	m_dwThreadID; 
	HANDLE	m_hSchedulerHandle;
	HANDLE	m_hScheduleEvent;
	HANDLE	m_hThreadExitEvent ;
	HANDLE	m_hInitEvent;
	BOOL	m_bInit;
	BOOL	m_fShutDown;

	CRITICAL_SECTION m_oCS;
	
	typedef std::deque<CTimerEvent*>  Timer_Ptr_Queue;
	Timer_Ptr_Queue m_oTimerQueue;

private:

	static DWORD WINAPI dwThreadProc( LPVOID lpParameter );

	BOOL			fScheduleEvent( CTimerEvent* pTimerEvent );

	CTimerEvent*	pGetNextTimerEvent();
	DWORD			dwProcessSchedule();
	DWORD			dwNextTimerEvent();	
	
	void vEmptyList();
	BOOL ShutDown();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\timerqueue.cpp ===
//=================================================================

//

// TimerQueue.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"

#include <time.h>
#include "TimerQueue.h"
#include <cautolock.h>

CTimerEvent :: CTimerEvent (

	DWORD dwTimeOut,
	BOOL fRepeat

) : m_dwMilliseconds ( dwTimeOut ) ,
	m_bRepeating ( fRepeat )
{
	m_bEnabled = FALSE ;
/*	if ( a_Enable )
	{
		Enable ();
	}
*/
}

CTimerEvent :: CTimerEvent (

	const CTimerEvent &rTimerEvent

) : //m_bEnabled ( rTimerEvent.m_bEnabled ) ,
	m_dwMilliseconds ( rTimerEvent.m_dwMilliseconds ) ,
	m_bRepeating ( rTimerEvent.m_bRepeating )
{
//	if ( m_bEnabled )
//	{
//		Enable () ;
//	}
//	if ( m_Rule )
//		m_Rule->AddRef () ;
}

void CTimerEvent :: Enable ()
{
	// we might not be able to enable timer
	m_bEnabled = CTimerQueue :: s_TimerQueue.QueueTimer ( this ) ;
}

void CTimerEvent :: Disable ()
{
	// enabled is oposite of returned
	m_bEnabled = !( CTimerQueue :: s_TimerQueue.DeQueueTimer ( this ) );
}

BOOL CTimerEvent :: Enabled ()
{
	return m_bEnabled ;
}

BOOL CTimerEvent :: Repeating ()
{
	return m_bRepeating ;
}

DWORD CTimerEvent :: GetMilliSeconds ()
{
	return m_dwMilliseconds ;
}
/*
CRuleTimerEvent :: CRuleTimerEvent (

	CRule *a_Rule ,
	BOOL a_Enable ,
	DWORD dwTimeOut,
	BOOL fRepeat ,
	BOOL bMarkedForDequeue

) : CTimerEvent ( a_Enable , dwTimeOut , fRepeat, bMarkedForDequeue ) ,
	m_Rule ( a_Rule )
{
	if ( m_Rule )
	{
		m_Rule->AddRef () ;
	}
}

CRuleTimerEvent :: CRuleTimerEvent (

	const CRuleTimerEvent &rTimerEvent

) : CTimerEvent ( rTimerEvent ) ,
	m_Rule ( rTimerEvent.m_Rule )
{
	if ( m_Rule )
	{
		m_Rule->AddRef () ;
	}
}

CRuleTimerEvent :: ~CRuleTimerEvent ()
{
	if ( m_Rule )
	{
		m_Rule->Release () ;
	}
}
*/
// CTimerQueue construction creates the worker thread and a event handle
CTimerQueue::CTimerQueue() : m_hInitEvent(NULL)
{
	InitializeCriticalSection( &m_oCS );
	m_fShutDown = FALSE;
	m_bInit = FALSE;

	m_hScheduleEvent = NULL;
	m_hThreadExitEvent = NULL;
    // Scheduler thread
	m_hSchedulerHandle = NULL;

	// when this event has not created there is very very small possibility of
	// having crash when shutdown is in progress and we step into init function
	m_hInitEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
}

void CTimerQueue::Init()
{
	// every thread may try to get it initialized couple times
	DWORD dwTry = 0L;

	EnterCriticalSection ( &m_oCS );

	while ( !m_bInit && dwTry < 3 )
	{
		if (m_fShutDown)
		{
			LeaveCriticalSection ( &m_oCS );

			if ( m_hInitEvent )
			{
				WaitForSingleObjectEx ( m_hInitEvent, INFINITE, FALSE );
			}

			EnterCriticalSection ( &m_oCS );
		}
		else
		{
			try
			{
				if ( ! m_hThreadExitEvent )
				{
					m_hThreadExitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
				}

				if ( m_hThreadExitEvent )
				{
					if ( ! m_hScheduleEvent )
					{
						m_hScheduleEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
					}

					if ( m_hScheduleEvent )
					{
						if ( ! m_hSchedulerHandle )
						{
							// Scheduler thread
							LogMessage ( L"CreateThread for Scheduler called" );
							m_hSchedulerHandle = CreateThread(
											  NULL,						// pointer to security attributes
											  0L,						// initial thread stack size
											  dwThreadProc,				// pointer to thread function
											  this,						// argument for new thread
											  0L,						// creation flags
											  &m_dwThreadID);
						}

						if ( m_hSchedulerHandle )
						{
							m_bInit = TRUE;
						}
					}
				}

				dwTry++;
			}
			catch(...)
			{
				// not much we can do in here

				if( m_hSchedulerHandle )
				{
					CloseHandle( m_hSchedulerHandle );
					m_hSchedulerHandle = NULL;
				}

				if( m_hScheduleEvent )
				{
					CloseHandle( m_hScheduleEvent );
					m_hScheduleEvent = NULL;
				}

				if( m_hThreadExitEvent )
				{
					CloseHandle ( m_hThreadExitEvent );
					m_hThreadExitEvent = NULL ;
				}

				LeaveCriticalSection ( &m_oCS );
				throw;
			}
		}
	}

	LeaveCriticalSection ( &m_oCS );
}

//
CTimerQueue::~CTimerQueue()
{
	LogMessage ( L"Entering ~CTimerQueue" ) ;

	if (m_hInitEvent)
	{
		CloseHandle(m_hInitEvent);
		m_hInitEvent = NULL;
	}

	DeleteCriticalSection( &m_oCS );

	LogMessage ( L"Leaving ~CTimerQueue" ) ;
}

// worker thread pump
DWORD WINAPI CTimerQueue::dwThreadProc( LPVOID lpParameter )
{
	CTimerQueue* pThis = (CTimerQueue*)lpParameter;

	BOOL bTerminate = FALSE;
	BOOL bTerminateShutdown = FALSE;

	try
	{
		while( !bTerminate )
		{
			DWORD dwWaitResult = WAIT_OBJECT_0;
			dwWaitResult = WaitForSingleObjectEx( pThis->m_hScheduleEvent, pThis->dwProcessSchedule(), 0L );

			switch ( dwWaitResult )
			{
				case WAIT_OBJECT_0:
				{
					if( pThis->ShutDown() )
					{
						SetEvent ( pThis->m_hThreadExitEvent ) ;
						bTerminateShutdown = TRUE;

						LogMessage ( L"Scheduler thread exiting" ) ;
					}
				}
				break;

				case WAIT_ABANDONED:
				{
					// we are probably not initialized properly
					bTerminate = TRUE;
				}
				break;
			}

			if ( bTerminateShutdown )
			{
				// terminate loop
				bTerminate = TRUE;
			}
			else
			{
				if ( bTerminate )
				{
					// we are somehow not initialized properly
					// need to re-initialise this thread for next time...
					CAutoLock cal(&pThis->m_oCS);
					pThis->m_bInit = FALSE;

					if ( pThis->ShutDown() )
					{
						SetEvent ( pThis->m_hThreadExitEvent ) ;
					}
				}
			}
		}
	}
	catch(...)
	{
		try
		{
			//need to re-initialise this thread for next time...
			CAutoLock cal(&pThis->m_oCS);
			pThis->m_bInit = FALSE;

			if ( pThis->ShutDown() )
			{
				SetEvent ( pThis->m_hThreadExitEvent ) ;
			}
		}
		catch(...)
		{
		}
	}

	return bTerminateShutdown;
}

// signals for a pump cycle, checking the updated queue
void CTimerQueue::vUpdateScheduler()
{
	SetEvent ( m_hScheduleEvent );
}

// Public function: Queues a timer entry for a scheduled callback
BOOL CTimerQueue::QueueTimer( CTimerEvent* pTimerEvent )
{
	BOOL fRc = FALSE;
/*
 * Init the scheduler thread if it's not there . The thread should not be created if we're
 * in the middle of shutdown as this may cause a deadlock if one resource caches another resource pointer.
 */
	CAutoLock cal(&m_oCS);
	if ( !m_fShutDown )
	{
		if( !m_bInit )
		{
			Init() ;
		}
		if( m_bInit )
		{
			fRc = fScheduleEvent( pTimerEvent );
		}
	}
	
	return fRc;
}

// Public function: Dequeues a timer event
BOOL CTimerQueue::DeQueueTimer( CTimerEvent* pTimerEvent )
{
	BOOL fRemoved = FALSE;
	CTimerEvent* pTE = pTimerEvent;

	//scope of critsec locked
	{
		CAutoLock cal(&m_oCS);
		Timer_Ptr_Queue::iterator pQueueElement;

		for( pQueueElement  = m_oTimerQueue.begin();
			 pQueueElement != m_oTimerQueue.end();
			 pQueueElement++)	{

			if(pTE == *pQueueElement)
			{
				m_oTimerQueue.erase( pQueueElement );
				pTE->Release ();
				fRemoved = TRUE;
				break ;
			}
		}
	}

	if( fRemoved )
	{
		vUpdateScheduler();
	}

	return fRemoved;
}

//
BOOL CTimerQueue::fScheduleEvent( CTimerEvent* pNewTE )
{
	// system clock offset
	pNewTE->int64Time = int64Clock() + pNewTE->GetMilliSeconds () ;

	// slot the event into the ordered list, scope for CS
	{
		CAutoLock cal(&m_oCS);
		BOOL fInserted = FALSE;

		Timer_Ptr_Queue::iterator pQueueElement;

		for( pQueueElement  = m_oTimerQueue.begin();
			 pQueueElement != m_oTimerQueue.end();
			 pQueueElement++)	{

			if( pNewTE->int64Time < (*pQueueElement)->int64Time )
			{
				m_oTimerQueue.insert( pQueueElement, pNewTE );
				fInserted = TRUE;
				pNewTE->AddRef () ;
				break;
			}
		}
		if( !fInserted )
		{
			m_oTimerQueue.push_back( pNewTE );
			pNewTE->AddRef () ;
		}
	}

	vUpdateScheduler();

	return TRUE;
}

// This work is done on the Scheduler thread
DWORD CTimerQueue::dwProcessSchedule()
{
	CTimerEvent* pTE;
	LogMessage ( L"Entering CTimerQueue::dwProcessSchedule" ) ;

	while( pTE = pGetNextTimerEvent() )
	{
		// process the request
		LogMessage ( L"CTimerEvent::OnTimer called" ) ;
		pTE->OnTimer () ;
		LogMessage ( L"CTimerEvent::OnTimer returned" ) ;

		// reschedule a repeatable event
		if( pTE->Repeating() && pTE->Enabled() && fScheduleEvent( pTE ) )
		{
		}

		pTE->Release () ;
	}

	return dwNextTimerEvent();
}

// returns the time for the next scheduled event in milliseconds
DWORD CTimerQueue::dwNextTimerEvent()
{
	DWORD dwNextEvent = INFINITE;

	//scope of CS
	{
		CAutoLock cal(&m_oCS);

		if( m_fShutDown )
		{
			return 0;
		}

		if( !m_oTimerQueue.empty() )
		{
			CTimerEvent* pTE = m_oTimerQueue.front();
			dwNextEvent = max((DWORD)(pTE->int64Time - int64Clock()), 0);
		}
	}

	LogMessage ( L"Leaving CTimerQueue::dwNextTimerEvent" ) ;
	return dwNextEvent;
}

// Returns the next scheduled and ready timer event (from an ordered list) or NULL
CTimerEvent* CTimerQueue::pGetNextTimerEvent()
{
	CAutoLock cal(&m_oCS);

	if( m_fShutDown )
	{
		return NULL;
	}

	CTimerEvent* pTE = NULL;

	if( !m_oTimerQueue.empty() )
	{
		pTE = m_oTimerQueue.front();

		if( int64Clock() >= pTE->int64Time )
			m_oTimerQueue.pop_front();
		else
			pTE = NULL;
	}

	return pTE;
}

BOOL CTimerQueue::ShutDown()
{
	CAutoLock cal(&m_oCS);
	BOOL retVal = m_fShutDown;
	return retVal;
}

//
void CTimerQueue::OnShutDown()
{
	LogMessage ( L"Entering CTimerQueue::OnShutDown" ) ;
	EnterCriticalSection(&m_oCS);

	if( m_bInit )
	{
		if ( m_hInitEvent )
		{
			ResetEvent ( m_hInitEvent );
		}

		m_fShutDown = TRUE;
		m_bInit = FALSE;

		// unguarded section ---
		// No TimerQueue global is modified in this frame block.
		//
		// To avoid a deadlock we unnest this CS from the
		// embedded CResourceList mutex accessed through
		// vEmptyList(). This avoids the situation where a
		// a normal resource request locks the list then locking
		// the TimerQueue to schedule a timed resource release.
		//
		LeaveCriticalSection(&m_oCS);
		{
			if ( m_hSchedulerHandle )
			{
				DWORD t_dwExitCode = 0 ;
				BOOL t_bRet = GetExitCodeThread (	m_hSchedulerHandle,	// handle to the thread
													&t_dwExitCode		// address to receive termination status
												);
				/*
				 * If the worker thread has not exited , we've to wait till it exits
				 */
				if ( t_bRet && t_dwExitCode == STILL_ACTIVE )
				{
/*
					//error logging starts here...delete this after finding the cause of shutdown crash
					CHString chsMsg ;
					chsMsg.Format ( L"Threadid=%x ThreadHandle = %x", GetCurrentThreadId (), GetCurrentThread () ) ;
					LogMessage ( CHString ( "TimerQueue Current Thread: " ) +chsMsg ) ;
					chsMsg.Format ( L"Threadid=%x ThreadHandle = %x", m_dwThreadID, m_hSchedulerHandle ) ;
					LogMessage ( CHString ( "TimerQueue Waiting on Thread: " ) +chsMsg ) ;
					//error logging stops here
*/
					vUpdateScheduler();

					if ( m_hThreadExitEvent )
					{
						// wait for the Scheduler thread to shut down
						WaitForSingleObjectEx( m_hThreadExitEvent, INFINITE, 0L );
					}
					else
					{
						// this should not happen, although there is still way to survive
						// wait for the Scheduler thread handle itself
						WaitForSingleObjectEx( m_hSchedulerHandle, INFINITE, 0L );
					}
				}

				vEmptyList() ;
			}
		}
		EnterCriticalSection(&m_oCS);

		if( m_hSchedulerHandle )
		{
			CloseHandle( m_hSchedulerHandle );
			m_hSchedulerHandle = NULL;
		}

		if( m_hScheduleEvent )
		{
			CloseHandle( m_hScheduleEvent );
			m_hScheduleEvent = NULL;
		}

		if( m_hThreadExitEvent )
		{
			CloseHandle ( m_hThreadExitEvent );
			m_hThreadExitEvent = NULL ;
		}

		m_fShutDown = FALSE;

		if ( m_hInitEvent )
		{
			SetEvent(m_hInitEvent);
		}
	}

	LeaveCriticalSection(&m_oCS);
	LogMessage ( L"Leaving CTimerQueue::OnShutDown" ) ;
}

//
void CTimerQueue::vEmptyList()
{
	EnterCriticalSection(&m_oCS);
	BOOL t_fCS = TRUE ;

	{
		try
		{
			while(!m_oTimerQueue.empty())
			{
				CTimerEvent* pTE = m_oTimerQueue.front() ;
				m_oTimerQueue.pop_front();

				LeaveCriticalSection(&m_oCS);
				t_fCS = FALSE ;

				LogMessage ( L"CTimerQueue::vEmptyList--->CTimerEvent::OnTimer called" ) ;
				pTE->OnTimer () ;

				LogMessage ( L"CTimerQueue::vEmptyList--->CTimerEvent::OnTimer returned" ) ;
				pTE->Release();

				EnterCriticalSection(&m_oCS);
				t_fCS = TRUE ;
			}
		}
		catch( ... )
		{
			if( t_fCS )
			{
				LeaveCriticalSection(&m_oCS);
			}
			throw ;
		}
	}
	LeaveCriticalSection(&m_oCS);
}

__int64 CTimerQueue::int64Clock()
{
	FILETIME t_FileTime ;
	__int64 t_i64Tmp ;

	GetSystemTimeAsFileTime ( &t_FileTime ) ;
	t_i64Tmp = t_FileTime.dwHighDateTime ;
	t_i64Tmp = ( t_i64Tmp << 32 ) | t_FileTime.dwLowDateTime ;
/*
 * Convert the FILETIME ( in units of 100 ns ) into milliseconds
 */
	return t_i64Tmp / 10000 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\tokenprivilege.cpp ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CTokenPrivilege.cpp - implementation file for CTokenPrivilege class.
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#include "precomp.h"
#include "TokenPrivilege.h"
#include "CreateMutexAsProcess.h"


///////////////////////////////////////////////////////////////////
//
//	Function:	CTokenPrivilege::CTokenPrivilege
//
//	Class constructor.
//
//	Inputs:
//				LPCTSTR		pszPrivilegeName - The name of the privilege
//							this instance will be responsible for.
//				HANDLE		hAccessToken - User supplied access token.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	If the user does NOT supply an access token, we try to open
//	a thread token, and if that fails, then the process token.
//
///////////////////////////////////////////////////////////////////

CTokenPrivilege::CTokenPrivilege( LPCTSTR pszPrivilegeName, HANDLE hAccessToken /*=INVALID_HANDLE_VALUE*/, LPCTSTR pszSystemName /*=NULL*/ )
:	m_strPrivilegeName( pszPrivilegeName ),
	m_strSystemName( pszSystemName ),
	m_hAccessToken( NULL ),
	m_fClearToken( FALSE )
{

	// If we weren't passed in a valid handle, open the current process token, acknowledging
	// that if we do so, we must also clear the token if we opened it.

	DWORD dwError = ERROR_SUCCESS;

	if ( INVALID_HANDLE_VALUE == hAccessToken )
	{
		// First try to get a thread token.  If this fails because there is no token,
		// then grab the process token.

		if ( OpenThreadToken( GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &m_hAccessToken ) )
		{
			m_fClearToken = TRUE;
		}
		else
		{
			if ( ( dwError = ::GetLastError() ) == ERROR_NO_TOKEN )
			{
				if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &m_hAccessToken ) )
				{
					m_fClearToken = TRUE;
				}
			}
		}
	}
	else
	{
		m_hAccessToken = hAccessToken;
	}

	// Now, get the LUID for the privilege from the local system
	ZeroMemory( &m_luid, sizeof(m_luid) );

	{
		// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
		CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

		LookupPrivilegeValue( pszSystemName, pszPrivilegeName, &m_luid );
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CTokenPrivilege::~CTokenPrivilege
//
//	Class destructor.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:
//
//	Cleans up our token only if we Opened it ourselves.
//
///////////////////////////////////////////////////////////////////

CTokenPrivilege::~CTokenPrivilege( void )
{
	if ( m_fClearToken )
	{
		CloseHandle( m_hAccessToken );
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CTokenPrivilege::GetPrivilegeDisplayName
//
//	Returns a Human readable name for the the token privilege the
//	class is handling.
//
//	Inputs:
//				None.
//
//	Outputs:
//				CHString&		strDisplayName - Display name.
//				LPDWORD			pdwLanguageId - Language Id of the
//								display name.
//
//	Returns:
//				DWORD			ERROR_SUCCESS if successful.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CTokenPrivilege::GetPrivilegeDisplayName( CHString& strDisplayName, LPDWORD pdwLanguageId )
{
	DWORD	dwError				=	ERROR_SUCCESS;
	DWORD	dwDisplayNameSize	=	0;

	// First, find out how big the buffer in strDisplayName needs to be
	LookupPrivilegeDisplayNameW(	( m_strSystemName.IsEmpty() ? NULL : (LPCWSTR) m_strSystemName ),
								m_strPrivilegeName,
								NULL,
								&dwDisplayNameSize,
								pdwLanguageId );

	{
		// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
		CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

		if ( !LookupPrivilegeDisplayNameW(	( m_strSystemName.IsEmpty() ? NULL : (LPCWSTR) m_strSystemName ),
											m_strPrivilegeName,
											strDisplayName.GetBuffer( dwDisplayNameSize + 1 ),
											&dwDisplayNameSize,
											pdwLanguageId ) )
		{
			dwError = ::GetLastError();
		}
	}

	strDisplayName.ReleaseBuffer();

	return dwError;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CTokenPrivilege::Enable
//
//	Attempts to enable/disable the privilege we are managing, in
//	our token data member.
//
//	Inputs:
//				BOOL			fEnable - Enable/Disable flag.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD			ERROR_SUCCESS if successful.
//
//	Comments:
//
///////////////////////////////////////////////////////////////////

DWORD CTokenPrivilege::Enable( bool fEnable/*=TRUE*/ )
{
	DWORD				dwError = ERROR_SUCCESS;
	TOKEN_PRIVILEGES	tokenPrivileges;

	tokenPrivileges.PrivilegeCount = 1;
	tokenPrivileges.Privileges[0].Luid = m_luid;
	tokenPrivileges.Privileges[0].Attributes = ( fEnable ? SE_PRIVILEGE_ENABLED : 0 );

	{
		// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
		CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

		AdjustTokenPrivileges(m_hAccessToken, FALSE, &tokenPrivileges, 0, NULL, NULL);
        dwError = ::GetLastError();
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\tokenprivilege.h ===
/*****************************************************************************/

/*  Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved            /
/*****************************************************************************/

/*
 *	CTokenPrivilege.h - header file for CTokenPrivilege class
 *
 *	Created:	12-14-1997 by Sanjeev Surati
 *				(based on classes from Windows NT Security by Nik Okuntseff)
 */

#if !defined __CTOKENPRIVILEGE_H__
#define __CTOKENPRIVILEGE_H__

////////////////////////////////////////////////////////////////
//
//	Class:	CTokenPrivilege
//
//	This class is intended to provide a wrapper for basic
//	Windows NT token privilege enabling/disabling.  In order
//	to perform certain operations on a Windows NT box, it is
//	often necessary to not only have certain privileges, but
//	to turn those privileges on and off as needed (as certain
//	privileges may be available but not enabled by default).
//	The class needs an access token to work correctly.  A
//	user can either pass us one, or we will try to obtain one.
//	First, we try to open a thread token (set by Impersonation),
//	and if that fails, then we attempt to get the process
//	level token.
//
////////////////////////////////////////////////////////////////


class CTokenPrivilege
{
	// Constructors and destructor
	public:
		CTokenPrivilege( LPCTSTR pszPrivilegeName, HANDLE hAccessToken = INVALID_HANDLE_VALUE, LPCTSTR pszSystemName = NULL );
		~CTokenPrivilege( void );

		void	GetPrivilegeName( CHString& strPrivilegeName );
		DWORD	GetPrivilegeDisplayName( CHString& strDisplayName, LPDWORD pdwLanguageId );
		DWORD	Enable( bool fEnable = TRUE );

	// Private data members
	private:
		CHString			m_strPrivilegeName;
		CHString			m_strSystemName;
		HANDLE			m_hAccessToken;
		bool			m_fClearToken;
		LUID			m_luid;

};

inline void CTokenPrivilege::GetPrivilegeName( CHString& strPrivilegeName )
{
	m_strPrivilegeName = strPrivilegeName;
}

#endif // __CTokenPrivilege_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\userenvapi.cpp ===
//=================================================================

//

// UserEnvAPI.cpp

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#include "precomp.h"
#include <cominit.h>
#include "UserEnvApi.h"
#include "DllWrapperCreatorReg.h"

// {C2BB0B38-8549-48a6-A58E-E704DFC19D80}
static const GUID g_guidUserEnvApi =
{ 0xc2bb0b38, 0x8549, 0x48a6, { 0xa5, 0x8e, 0xe7, 0x4, 0xdf, 0xc1, 0x9d, 0x80 } };

static const TCHAR g_tstrUserEnv[] = _T("userenv.dll");

/******************************************************************************
 * Register this class with the CResourceManager.
 *****************************************************************************/
CDllApiWraprCreatrReg<CUserEnvApi, &g_guidUserEnvApi, g_tstrUserEnv> MyRegisteredUserEnvWrapper;

/******************************************************************************
 * Constructor
 ******************************************************************************/
CUserEnvApi :: CUserEnvApi (

	LPCTSTR a_tstrWrappedDllName

) : CDllWrapperBase(a_tstrWrappedDllName),
	m_pfnDestroyEnvironmentBlock(NULL),
	m_pfnCreateEnvironmentBlock(NULL)
{
}

/******************************************************************************
 * Destructor
 ******************************************************************************/
CUserEnvApi :: ~CUserEnvApi ()
{
}

/******************************************************************************
 * Initialization function to check that we obtained function addresses.
 * Init should fail only if the minimum set of functions was not available;
 * functions added in later versions may or may not be present - it is the
 * client's responsibility in such cases to check, in their code, for the
 * version of the dll before trying to call such functions.  Not doing so
 * when the function is not present will result in an AV.
 *
 * The Init function is called by the WrapperCreatorRegistation class.
 ******************************************************************************/
bool CUserEnvApi :: Init ()
{
    bool fRet = LoadLibrary () ;
    if ( fRet )
    {
#ifdef NTONLY

		m_pfnDestroyEnvironmentBlock = ( PFN_UserEnv_DESTROYENVIRONMENTBLOCK ) GetProcAddress ( "DestroyEnvironmentBlock" ) ;
		m_pfnCreateEnvironmentBlock = ( PFN_UserEnv_CREATEENVIRONMENTBLOCK ) GetProcAddress ( "CreateEnvironmentBlock" ) ;

		if ( m_pfnDestroyEnvironmentBlock == NULL ||
			m_pfnCreateEnvironmentBlock == NULL )
		{
            fRet = false ;
            LogErrorMessage(L"Failed find entrypoint in userenvapi");
		}
#endif

        // Check that we have function pointers to functions that should be
        // present in all versions of this dll...
        // ( in this case, ALL these are functions that may or may not be
        //   present, so don't bother)
    }

    return fRet;
}

/******************************************************************************
 * Member functions wrapping UserEnv api functions. Add new functions here
 * as required.
 ******************************************************************************/

// This member function's wrapped pointer has not been validated as it may
// not exist on all versions of the dll.  Hence the wrapped function's normal
// return value is returned via the last parameter, while the result of the
// function indicates whether the function existed or not in the wrapped dll.

BOOL CUserEnvApi :: CreateEnvironmentBlock (

	OUT LPVOID *lpEnvironment,
	IN HANDLE hToken,
	IN BOOL bInherit
)
{
	return m_pfnCreateEnvironmentBlock (

		lpEnvironment,
		hToken,
		bInherit

	) ;
}

BOOL CUserEnvApi :: DestroyEnvironmentBlock (

	IN LPVOID lpEnvironment
)
{
	return m_pfnDestroyEnvironmentBlock (

		lpEnvironment
	) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\userhive.h ===
//============================================================

//

// UserHive.h - Class to load/unload specified user's profile

//              hive from registry

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/03/97     a-jmoon     created
//
//============================================================

#ifndef __USERHIVE_INC__
#define __USERHIVE_INC__

class CRegistry;

class CUserHive
{
    public:
    
        CUserHive() ;
       ~CUserHive() ;

        DWORD Load(LPCWSTR pszUserName, LPWSTR pszKeyName) ;
        DWORD LoadProfile( LPCWSTR pszProfile, CHString& strUserName );
        DWORD Unload(LPCWSTR pszKeyName) ;
        DWORD UserAccountFromProfile( CRegistry& reg, CHString& strUserName );

    private:

        OSVERSIONINFO    OSInfo ;
        TOKEN_PRIVILEGES* m_pOriginalPriv ;
        HKEY m_hKey;
        DWORD m_dwSize;
		
#ifdef NTONLY
		DWORD LoadNT(LPCWSTR pszUserName, LPWSTR pszKeyName);
        DWORD AcquirePrivilege() ;
        void  RestorePrivilege() ;
#endif
#ifdef WIN9XONLY
		DWORD Load95(LPCWSTR pszUserName, LPWSTR pszKeyName);
#endif

		// using threadbase - that way we don't have to jump through any hoops
		// to make sure that the global critical section is initialized properly
		// this is mostly to serialize access to the NT User.dat file.
		static CThreadBase m_criticalSection;
} ;

#endif // file inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\userenvapi.h ===
//=================================================================

//

// UserEnvApi.h

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//=================================================================

#ifndef	_UserEnvAPI_H_
#define	_UserEnvAPI_H_

/******************************************************************************
 * #includes to Register this class with the CResourceManager. 
 *****************************************************************************/
#include "DllWrapperBase.h"

extern const GUID g_guidUserEnvApi;
extern const TCHAR g_tstrUserEnv[];


/******************************************************************************
 * Function pointer typedefs.  Add new functions here as required.
 *****************************************************************************/
typedef BOOL (WINAPI *PFN_UserEnv_GET_DISK_FREE_SPACE_EX)
(
	LPCTSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
);

typedef BOOL ( WINAPI *PFN_UserEnv_CREATEENVIRONMENTBLOCK )
(
	OUT LPVOID *lpEnvironment,
	IN HANDLE hToken,
	IN BOOL bInherit
);

typedef BOOL ( WINAPI *PFN_UserEnv_DESTROYENVIRONMENTBLOCK )
(
	IN LPVOID lpEnvironment
);

/******************************************************************************
 * Wrapper class for UserEnv load/unload, for registration with CResourceManager. 
 ******************************************************************************/
class __declspec(uuid("3CA401C6-D477-11d2-B35E-00104BC97924")) CUserEnvApi : public CDllWrapperBase
{
private:

    // Member variables (function pointers) pointing to UserEnv functions.
    // Add new functions here as required.

	PFN_UserEnv_DESTROYENVIRONMENTBLOCK m_pfnDestroyEnvironmentBlock ;
	PFN_UserEnv_CREATEENVIRONMENTBLOCK m_pfnCreateEnvironmentBlock ;

public:

    // Constructor and destructor:
    CUserEnvApi ( LPCTSTR a_tstrWrappedDllName ) ;
    ~CUserEnvApi () ;

    // Inherrited initialization function.

    virtual bool Init();

    // Member functions wrapping UserEnv functions.
    // Add new functions here as required:

	BOOL CreateEnvironmentBlock (

		OUT LPVOID *lpEnvironment,
		IN HANDLE hToken,
		IN BOOL bInherit
	);

	BOOL DestroyEnvironmentBlock (

		IN LPVOID lpEnvironment
	);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wbemnetapi32.h ===
//============================================================

//

// WBEMNetAPI32.h - NetAPI32.DLL access class definition

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
//
//============================================================

#ifndef __WBEMNETAPI32__
#define __WBEMNETAPI32__

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmerr.h>
#include <ntsecapi.h>
#include <stack>
#include <comdef.h>
#include <dsrole.h> // KMH 32414
#include <dsgetdc.h>

#include "netapi32api.h"
#include "svrapiapi.h"
#include "AdvApi32Api.h"


class CNetAPI32
{
    public :

        CNetAPI32() ;
       ~CNetAPI32() ;
        
        LONG Init() ;

#ifdef NTONLY
        // Use this version for all NT platforms.  It properly gets a DC rather than
        // requiring that the PDC be obtained.
        DWORD GetDCName(
            LPCWSTR wstrDomain,
            CHString& chstrDCName);
        
        // Determines if the specified server is a DC.  NULL means current machine
        BOOL IsDomainController(LPTSTR Server);

        // Returns an array of Trusted domains.  Includes the current domain.
        BOOL GetTrustedDomainsNT(CHStringArray& achsTrustList);
        // Overload, returns same, but as a stack of _bstr_t's
        BOOL GetTrustedDomainsNT(std::vector<_bstr_t>& vectorTrustList);

        NET_API_STATUS NET_API_FUNCTION NetGroupEnum(LPCWSTR servername, 
                                                     DWORD level, 
                                                     LPBYTE *bufptr,
                                                     DWORD prefmaxlen, 
                                                     LPDWORD entriesread,
                                                     LPDWORD totalentries, 
                                                     PDWORD_PTR resume_handle) ;

        NET_API_STATUS NET_API_FUNCTION NetLocalGroupEnum(LPCWSTR servername,
                                                          DWORD level,
                                                          LPBYTE *bufptr,
                                                          DWORD prefmaxlen,
                                                          LPDWORD entriesread,
                                                          LPDWORD totalentries,
                                                          PDWORD_PTR resumehandle) ;

        NET_API_STATUS NET_API_FUNCTION NetGroupGetInfo(LPCWSTR servername,
                                                        LPCWSTR groupname,
                                                        DWORD level,
                                                        LPBYTE *bufptr) ;

		NET_API_STATUS NET_API_FUNCTION NetGroupSetInfo(LPCWSTR servername,
                                                        LPCWSTR groupname,
                                                        DWORD level,
                                                        LPBYTE buf,
														LPDWORD parm_err) ;

        NET_API_STATUS NET_API_FUNCTION NetLocalGroupGetInfo(LPCWSTR servername,
                                                        LPCWSTR groupname,
                                                        DWORD level,
                                                        LPBYTE *bufptr) ;
	
		NET_API_STATUS NET_API_FUNCTION NetLocalGroupSetInfo(LPCWSTR servername,
                                                        LPCWSTR groupname,
                                                        DWORD level,
                                                        LPBYTE buf,
														LPDWORD a_parm_err ) ;

        NET_API_STATUS NET_API_FUNCTION NetGroupGetUsers(LPCWSTR servername,
                                                         LPCWSTR groupname,
                                                         DWORD level,
                                                         LPBYTE *bufptr,
                                                         DWORD prefmaxlen,
                                                         LPDWORD entriesread,
                                                         LPDWORD totalentries,
                                                         PDWORD_PTR ResumeHandle) ;
        
        NET_API_STATUS NET_API_FUNCTION NetLocalGroupGetMembers(LPCWSTR servername,
                                                         LPCWSTR groupname,
                                                         DWORD level,
                                                         LPBYTE *bufptr,
                                                         DWORD prefmaxlen,
                                                         LPDWORD entriesread,
                                                         LPDWORD totalentries,
                                                         PDWORD_PTR ResumeHandle) ;
        
        NET_API_STATUS NET_API_FUNCTION NetShareEnum(LPTSTR servername,
                                                     DWORD level,
                                                     LPBYTE *bufptr,
                                                     DWORD prefmaxlen,
                                                     LPDWORD entriesread,
                                                     LPDWORD totalentries,
                                                     LPDWORD resume_handle) ;

        NET_API_STATUS NET_API_FUNCTION NetShareGetInfo(LPTSTR servername,
                                                        LPTSTR netname,
                                                        DWORD level,
                                                        LPBYTE *bufptr) ;


		NET_API_STATUS NET_API_FUNCTION NetShareAdd (

			IN  LPTSTR  servername,
			IN  DWORD   level,
			IN  LPBYTE  buf,
			OUT LPDWORD parm_err
		);

		NET_API_STATUS NET_API_FUNCTION NetShareEnumSticky (

			IN  LPTSTR      servername,
			IN  DWORD       level,
			OUT LPBYTE      *bufptr,
			IN  DWORD       prefmaxlen,
			OUT LPDWORD     entriesread,
			OUT LPDWORD     totalentries,
			IN OUT LPDWORD  resume_handle
		);

		NET_API_STATUS NET_API_FUNCTION NetShareSetInfo (

			IN  LPTSTR  servername,
			IN  LPTSTR  netname,
			IN  DWORD   level,
			IN  LPBYTE  buf,
			OUT LPDWORD parm_err
		);

		NET_API_STATUS NET_API_FUNCTION NetShareDel (

			IN  LPTSTR  servername,
			IN  LPTSTR  netname,
			IN  DWORD   reserved
		);

		NET_API_STATUS NET_API_FUNCTION NetShareDelSticky (

			IN  LPTSTR  servername,
			IN  LPTSTR  netname,
			IN  DWORD   reserved
		);

		NET_API_STATUS NET_API_FUNCTION NetShareCheck (

			IN  LPTSTR  servername,
			IN  LPTSTR  device,
			OUT LPDWORD type
		);

		BOOL DsRolepGetPrimaryDomainInformationDownlevel (

			DSROLE_MACHINE_ROLE &a_rMachineRole,
			DWORD &a_rdwWin32Err
		) ;
#endif

#ifdef WIN9XONLY
        NET_API_STATUS NET_API_FUNCTION NetShareEnum95(char FAR *servername,
                                                     short level,
                                                     char FAR *bufptr,
                                                     unsigned short prefmaxlen,
                                                     unsigned short FAR *entriesread,
                                                     unsigned short FAR *totalentries);

        NET_API_STATUS NET_API_FUNCTION NetShareGetInfo95(char FAR *servername,
                                                        char FAR *netname,
                                                        short level,
                                                        char FAR *bufptr,
                                                        unsigned short buflen,
                                                        unsigned short FAR *totalavail) ;
		//svrapi.h
		NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareAdd95 (

			IN  const char FAR *	servername,
			IN  short				level,
			IN  const char FAR *	buf,
			unsigned short			cbBuffer 
		);

		NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareSetInfo95 (

			IN const char FAR *	servername,
			IN const char FAR *	netname,
			IN short			level,
			IN const char FAR*	buf,
			IN unsigned short   cbBuffer,
			IN short            sParmNum 
		) ;



		NET_API_STATUS NET_API_FUNCTION NetShareDel95 (

			IN  LPTSTR  servername,
			IN  LPTSTR  netname,
			IN  DWORD   reserved
		);

        NET_API_STATUS NET_API_FUNCTION NetServerGetInfo95(
            char FAR *servername,
            short level,
            char FAR *bufptr,
            unsigned short buflen,
            unsigned short FAR *totalavail);

#endif

#ifdef NTONLY
        NET_API_STATUS NET_API_FUNCTION NetUserEnum(LPCWSTR servername,
                                                    DWORD level,
                                                    DWORD filter,
                                                    LPBYTE *bufptr,
                                                    DWORD prefmaxlen,
                                                    LPDWORD entriesread,
                                                    LPDWORD totalentries,
                                                    LPDWORD resume_handle) ;

        NET_API_STATUS NET_API_FUNCTION NetUserGetInfo(LPCWSTR servername,
                                                       LPCWSTR username,
                                                       DWORD level,
                                                       LPBYTE *bufptr) ;

		NET_API_STATUS NET_API_FUNCTION NetUserSetInfo(  
														  
														LPCWSTR a_servername, 
														LPCWSTR a_username,   
														DWORD a_level,       
														LPBYTE a_buf,        
														LPDWORD a_parm_err
														) ;

        NET_API_STATUS NET_API_FUNCTION NetApiBufferFree(void *bufptr) ;

		NET_API_STATUS NET_API_FUNCTION NetQueryDisplayInformation(	LPWSTR ServerName,
																	DWORD Level,
																	DWORD Index,
																	DWORD EntriesRequested,
																	DWORD PreferredMaximumLength,
																	LPDWORD ReturnedEntryCount,
																	PVOID *SortedBuffer);

	    NET_API_STATUS NET_API_FUNCTION NetServerSetInfo(LPTSTR servername,
										      DWORD level,
										      LPBYTE  bufptr,
										      LPDWORD ParmError);

        NET_API_STATUS NET_API_FUNCTION NetServerGetInfo(LPTSTR servername,
                                            DWORD level,
                                            LPBYTE *bufptr);

        //KMH 32414
	    NET_API_STATUS NET_API_FUNCTION DSRoleGetPrimaryDomainInfo(LPCWSTR servername,
													      DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level,
													      LPBYTE *bufptr);
	    NET_API_STATUS NET_API_FUNCTION DSRoleFreeMemory(LPBYTE bufptr);

		NET_API_STATUS NET_API_FUNCTION NetGetDCName(	LPCWSTR ServerName,
														LPCWSTR DomainName,
														LPBYTE* bufptr );

		// NT5 entry
		NET_API_STATUS NET_API_FUNCTION DsGetDcName(	LPCTSTR ComputerName, 
														LPCTSTR DomainName,
														GUID *DomainGuid, 
														LPCTSTR SiteName, 
														ULONG Flags,
														PDOMAIN_CONTROLLER_INFO *DomainControllerInfo );

        NET_API_STATUS NET_API_FUNCTION NetRenameMachineInDomain(   LPCWSTR a_lpServer,
                                                                    LPCWSTR a_lpNewMachineName,
                                                                    LPCWSTR a_lpAccount,
                                                                    LPCWSTR a_lpPassword,
                                                                    DWORD a_fRenameOptions);

		NET_API_STATUS NET_API_FUNCTION NetUnjoinDomain(	LPCWSTR lpServer,
															LPCWSTR lpAccount,
															LPCWSTR lpPassword,
															DWORD   fUnjoinOptions);

		NET_API_STATUS NET_API_FUNCTION NetJoinDomain( LPCWSTR lpServer,
														LPCWSTR lpDomain,
														LPCWSTR lpAccountOU,
														LPCWSTR lpAccount,
														LPCWSTR lpPassword,
														DWORD fJoinOptions);

		NET_API_STATUS NET_API_FUNCTION NetWkstaGetInfo(	LPWSTR ServerName,
															DWORD level,
															LPBYTE *bufptr );

		NET_API_STATUS NET_API_FUNCTION NetGetAnyDCName(LPWSTR ServerName,
														LPWSTR DomainName,
														LPBYTE* bufptr );

		NET_API_STATUS NET_API_FUNCTION NetServerEnum(	LPTSTR servername,
														DWORD level,
														LPBYTE *bufptr,
														DWORD prefmaxlen,
														LPDWORD entriesread,
														LPDWORD totalentries,
														DWORD servertype,
														LPTSTR domain,
														LPDWORD resume_handle );

		NET_API_STATUS NET_API_FUNCTION	NetEnumerateTrustedDomains(	LPWSTR servername,
																	LPWSTR* domainNames ) ;

		NET_API_STATUS NET_API_FUNCTION NetUserModalsGet(	LPWSTR servername,
															DWORD level,
															LPBYTE *bufptr );


		NET_API_STATUS NET_API_FUNCTION	NetScheduleJobAdd (

			IN      LPCWSTR         Servername  OPTIONAL,
			IN      LPBYTE          Buffer,
			OUT     LPDWORD         JobId
		);

		NET_API_STATUS NET_API_FUNCTION	NetScheduleJobDel (

			IN      LPCWSTR         Servername  OPTIONAL,
			IN      DWORD           MinJobId,
			IN      DWORD           MaxJobId
		);

		NET_API_STATUS NET_API_FUNCTION	NetScheduleJobEnum (

			IN      LPCWSTR         Servername              OPTIONAL,
			OUT     LPBYTE *        PointerToBuffer,
			IN      DWORD           PrefferedMaximumLength,
			OUT     LPDWORD         EntriesRead,
			OUT     LPDWORD         TotalEntries,
			IN OUT  LPDWORD         ResumeHandle
		);

		NET_API_STATUS NET_API_FUNCTION	NetScheduleJobGetInfo (

			IN      LPCWSTR         Servername              OPTIONAL,
			IN      DWORD           JobId,
			OUT     LPBYTE *        PointerToBuffer
		);

        NET_API_STATUS NET_API_FUNCTION NetUseGetInfo (

            IN LPCWSTR UncServerName OPTIONAL,
            IN LPCWSTR UseName,
            IN DWORD Level,
            OUT LPBYTE *BufPtr
        );
#endif

    private :
#ifdef NTONLY
        CNetApi32Api *m_pnetapi;
#endif
#ifdef WIN9XONLY
        CSvrApiApi   *m_psvrapi;
#endif

      NTSTATUS OpenPolicy( CAdvApi32Api * a_padvapi , LPWSTR ServerName, DWORD DesiredAccess, PLSA_HANDLE PolicyHandle);
      void InitLsaString(PLSA_UNICODE_STRING LsaString, LPWSTR String );
      BOOL EnumTrustedDomains(LSA_HANDLE PolicyHandle, CHStringArray &achsTrustList);
      // Overload of above to accept stl stack instead of a CHStringArray.
      BOOL EnumTrustedDomains(LSA_HANDLE PolicyHandle, std::vector<_bstr_t>& vectorTrustList);
      bool AlreadyAddedToList(std::vector<_bstr_t> &vecchsList, _bstr_t &bstrtItem);

#ifdef NTONLY
/*
 * This enumerated type taken from ntdef.h
 */
	  typedef enum _NT_PRODUCT_TYPE {
										NtProductWinNt = 1,
										NtProductLanManNt,
										NtProductServer
									} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

		BOOL DsRolepGetProductTypeForServer (
			
			NT_PRODUCT_TYPE &a_rProductType ,
			DWORD &a_rdwWin32Err
		) ;
#endif

} ;

#endif // File inclusion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wbempsapi.cpp ===
//============================================================

//

// WBEMPSAPI.cpp - implementation of PSAPI.DLL access class

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
//
//============================================================

#include "precomp.h"
#include <winerror.h>
#include "WBEMPSAPI.h"

#ifdef NTONLY

/**********************************************************************************************************
 * Register this class with the CResourceManager.
 **********************************************************************************************************/

// {A8CFDD23-C2D2-11d2-B352-00105A1F8569}
const GUID guidPSAPI =
{ 0xa8cfdd23, 0xc2d2, 0x11d2, { 0xb3, 0x52, 0x0, 0x10, 0x5a, 0x1f, 0x85, 0x69 } };


class CPSAPICreatorRegistration
{
public:
	CPSAPICreatorRegistration ()
	{
		CResourceManager::sm_TheResourceManager.AddInstanceCreator ( guidPSAPI, CPSAPICreator ) ;
	}
	~CPSAPICreatorRegistration	()
	{}

	static CResource * CPSAPICreator ( PVOID pData )
	{
		CPSAPI *t_pPsapi = new CPSAPI ;
		if ( !t_pPsapi )
		{
			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
		}
		return t_pPsapi ;
	}
};

CPSAPICreatorRegistration MyCPSAPICreatorRegistration ;
/**********************************************************************************************************/


/*****************************************************************************
 *
 *  FUNCTION    : CPSAPI::CPSAPI
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CPSAPI::CPSAPI() : CTimedDllResource () {

    hLibHandle  = NULL ;
	Init () ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CPSAPI::~CPSAPI
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CPSAPI::~CPSAPI() {

    if(hLibHandle != NULL) {

        FreeLibrary(hLibHandle) ;
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CPSAPI::Init
 *
 *  DESCRIPTION : Loads CSAPI.DLL, locates entry points
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : ERROR_SUCCESS or windows error code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

LONG CPSAPI::Init() {

    LONG lRetCode = ERROR_SUCCESS ;

    // Try to load CSAPI.DLL
    //======================

    if(hLibHandle == NULL) {

        hLibHandle = LoadLibrary(_T("PSAPI.DLL")) ;
        if(hLibHandle == NULL) {

            lRetCode = ERROR_DLL_NOT_FOUND ;
            LogErrorMessage(L"Failed to load library psapi.dll");
        }
        else {

            // Find the entry points
            //======================
            pEnumProcesses           = (PSAPI_ENUM_PROCESSES)   GetProcAddress(hLibHandle, "EnumProcesses") ;
            pEnumDeviceDrivers       = (PSAPI_ENUM_DRIVERS)     GetProcAddress(hLibHandle, "EnumDeviceDrivers") ;
            pEnumProcessModules      = (PSAPI_ENUM_MODULES)     GetProcAddress(hLibHandle, "EnumProcessModules") ;
            pGetProcessMemoryInfo    = (PSAPI_GET_MEMORY_INFO)  GetProcAddress(hLibHandle, "GetProcessMemoryInfo") ;

#ifdef UNICODE
            pGetDeviceDriverBaseName = (PSAPI_GET_DRIVER_NAME)  GetProcAddress(hLibHandle, "GetDeviceDriverBaseNameW") ;
            pGetModuleBaseName       = (PSAPI_GET_MODULE_NAME)  GetProcAddress(hLibHandle, "GetModuleBaseNameW") ;
            pGetDeviceDriverFileName = (PSAPI_GET_DRIVER_EXE)   GetProcAddress(hLibHandle, "GetDeviceDriverFileNameW") ;
            pGetModuleFileNameEx     = (PSAPI_GET_MODULE_EXE)   GetProcAddress(hLibHandle, "GetModuleFileNameExW") ;
#else
            pGetDeviceDriverBaseName = (PSAPI_GET_DRIVER_NAME)  GetProcAddress(hLibHandle, "GetDeviceDriverBaseNameA") ;
            pGetModuleBaseName       = (PSAPI_GET_MODULE_NAME)  GetProcAddress(hLibHandle, "GetModuleBaseNameA") ;
            pGetDeviceDriverFileName = (PSAPI_GET_DRIVER_EXE)   GetProcAddress(hLibHandle, "GetDeviceDriverFileNameA") ;
            pGetModuleFileNameEx     = (PSAPI_GET_MODULE_EXE)   GetProcAddress(hLibHandle, "GetModuleFileNameExA") ;
#endif

            if(pEnumProcesses           == NULL ||
               pEnumDeviceDrivers       == NULL ||
               pEnumProcessModules      == NULL ||
               pGetDeviceDriverBaseName == NULL ||
               pGetModuleBaseName       == NULL ||
               pGetDeviceDriverFileName == NULL ||
               pGetModuleFileNameEx     == NULL ||
               pGetProcessMemoryInfo    == NULL) {

                // Couldn't get one or more entry points
                //======================================

                FreeLibrary(hLibHandle) ;
                hLibHandle = NULL ;
                lRetCode = ERROR_PROC_NOT_FOUND ;
                LogErrorMessage(L"Failed find entrypoint in wbempsapi");
            }
        }
    }

    return lRetCode ;
}

/*****************************************************************************
 *
 *  FUNCTION    : CPSAPI::EnumProcesses
 *                CPSAPI::EnumDeviceDrivers
 *                CPSAPI::EnumProcessModules
 *                CPSAPI::GetDeviceDriverBaseName
 *                CPSAPI::GetModuleBaseName
 *                CPSAPI::GetDeviceDriverFileName
 *                CPSAPI::GetModuleFileNameEx
 *                CPSAPI::GetProcessMemoryInfo
 *
 *  DESCRIPTION : CSAPI function wrappers
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : CSAPI return codes
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

BOOL CPSAPI::EnumProcesses(DWORD *pdwPIDList, DWORD dwListSize, DWORD *pdwByteCount) {

    if(hLibHandle == NULL) {

        return FALSE ;
    }

    return pEnumProcesses(pdwPIDList, dwListSize, pdwByteCount) ;
}

BOOL CPSAPI::EnumDeviceDrivers(LPVOID pImageBaseList, DWORD dwListSize, DWORD *pdwByteCount) {

    if(hLibHandle == NULL) {

        return FALSE ;
    }

    return pEnumDeviceDrivers(pImageBaseList, dwListSize, pdwByteCount) ;
}

BOOL CPSAPI::EnumProcessModules(HANDLE hProcess, HMODULE *ModuleList,
                                DWORD dwListSize, DWORD *pdwByteCount) {

    if(hLibHandle == NULL) {

        return FALSE ;
    }

    return pEnumProcessModules(hProcess, ModuleList, dwListSize, pdwByteCount) ;
}

DWORD CPSAPI::GetDeviceDriverBaseName(LPVOID pImageBase, LPTSTR pszName, DWORD dwNameSize) {

    if(hLibHandle == NULL) {

        return 0 ;
    }

    return pGetDeviceDriverBaseName(pImageBase, pszName, dwNameSize) ;
}

DWORD CPSAPI::GetModuleBaseName(HANDLE hProcess, HMODULE hModule,
                                LPTSTR pszName, DWORD dwNameSize) {

    if(hLibHandle == NULL) {

        return 0 ;
    }

    return pGetModuleBaseName(hProcess, hModule, pszName, dwNameSize) ;
}

DWORD CPSAPI::GetDeviceDriverFileName(LPVOID pImageBase, LPTSTR pszName, DWORD dwNameSize) {

    if(hLibHandle == NULL) {

        return 0 ;
    }

    return pGetDeviceDriverFileName(pImageBase, pszName, dwNameSize) ;
}

DWORD CPSAPI::GetModuleFileNameEx(HANDLE hProcess, HMODULE hModule,
                                  LPTSTR pszName, DWORD dwNameSize)
{
    if (hLibHandle == NULL)
        return 0;

    DWORD dwRet = pGetModuleFileNameEx(hProcess, hModule, pszName, dwNameSize);

    if (dwRet)
    {
        // GetModuleFileNameEx sometimes returns some funky things like:
        // \\??\\C:\\blah\\...
        // \\SystemRoot\\system32\\blah\\..
        CHString strFilename = pszName;

        // If it starts with "\\??\\" get rid of it.
        if (strFilename.Find(_T("\\??\\")) == 0)
            lstrcpy(pszName, strFilename.Mid(sizeof(_T("\\??\\"))/sizeof(TCHAR) - 1));
        else if (strFilename.Find(_T("\\SystemRoot\\")) == 0)
        {
            GetWindowsDirectory(pszName, dwNameSize/sizeof(TCHAR));

            // Leave off that last '\\' so we seperate c:\\winnt from the
            // rest of the path.
            lstrcat(pszName, strFilename.Mid(sizeof(_T("\\SystemRoot"))/sizeof(TCHAR) - 1));
        }
    }

    return dwRet;
}

BOOL CPSAPI::GetProcessMemoryInfo(HANDLE hProcess,
                                  PROCESS_MEMORY_COUNTERS *pMemCtrs,
                                  DWORD dwByteCount) {

    if(hLibHandle == NULL) {

        return 0 ;
    }

    return pGetProcessMemoryInfo(hProcess, pMemCtrs, dwByteCount) ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\wbemnetapi32.cpp ===
//============================================================

//

// WBEMNetAPI32.cpp - implementation of NetAPI32.DLL access class

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/21/97     a-jmoon     created
//
//============================================================

#include "precomp.h"
#include <winerror.h>
#include <CreateMutexAsProcess.h>
#include "WBEMNETAPI32.h"

/*****************************************************************************
 *
 *  FUNCTION    : CNetAPI32::CNetAPI32
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CNetAPI32::CNetAPI32()
#ifdef NTONLY
:   m_pnetapi(NULL)
#endif
#ifdef WIN9XONLY
:   m_psvrapi(NULL)
#endif
{
}

/*****************************************************************************
 *
 *  FUNCTION    : CNetAPI32::~CNetAPI32
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CNetAPI32::~CNetAPI32()
{
#ifdef NTONLY
    if(m_pnetapi != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidNetApi32Api, m_pnetapi);
    }
#endif
#ifdef WIN9XONLY
    if(m_psvrapi != NULL)
    {
        CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidSvrApiApi, m_psvrapi);
    }
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CNetAPI32::Init
 *
 *  DESCRIPTION : Loads CSAPI.DLL, locates entry points
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : ERROR_SUCCESS or windows error code
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

LONG CNetAPI32::Init()
{
    LONG lRetCode = ERROR_SUCCESS;

#ifdef WIN9XONLY
    m_psvrapi = (CSvrApiApi*) CResourceManager::sm_TheResourceManager.GetResource(g_guidSvrApiApi, NULL);
    if(m_psvrapi == NULL)
    {
        // Couldn't get one or more entry points
        //======================================
        lRetCode = ERROR_PROC_NOT_FOUND;
    }
#endif

#ifdef NTONLY
    m_pnetapi = (CNetApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidNetApi32Api, NULL);
    if(m_pnetapi == NULL)
    {
        // Couldn't get one or more entry points
        //======================================
        lRetCode = ERROR_PROC_NOT_FOUND;
    }
#endif

    return lRetCode;
}


/*****************************************************************************
 *
 *  SVRAPIAPI.DLL WRAPPERS
 *
 *****************************************************************************/

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareEnum95(char FAR *servername,
                                                     short level,
                                                     char FAR *bufptr,
                                                     unsigned short prefmaxlen,
                                                     unsigned short FAR *entriesread,
                                                     unsigned short FAR *totalentries)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareEnum(servername, level, bufptr, prefmaxlen,
                                   entriesread, totalentries);
    }
    return ns;
}
#endif


#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareGetInfo95(char FAR *servername,
                                                        char FAR *netname,
                                                        short level,
                                                        char FAR *bufptr,
                                                        unsigned short buflen,
                                                        unsigned short FAR *totalavail)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareGetInfo(servername, netname, level,
                                      bufptr, buflen, totalavail);
    }
    return ns;
}
#endif

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareAdd95 (

	IN  const char FAR *	servername,
	IN  short				level,
	IN  const char FAR *	buf,
	unsigned short			cbBuffer
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareAdd(servername, level, buf , cbBuffer);
    }
    return ns;
}
#endif

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareSetInfo95 (

	IN const char FAR *	servername,
	IN const char FAR *	netname,
	IN short			level,
	IN const char FAR*	buf,
	IN unsigned short   cbBuffer,
	IN short            sParmNum
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareSetInfo(servername, netname, level,
                                      buf, cbBuffer, sParmNum);
    }
    return ns;
}
#endif

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareDel95 (

	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetShareDel(servername, netname, reserved);
    }
    return ns;
}
#endif

#ifdef WIN9XONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetServerGetInfo95(char FAR *servername,
                                          short level,
                                          char FAR *bufptr,
                                          unsigned short buflen,
                                          unsigned short FAR *totalavail)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_psvrapi != NULL)
    {
        ns = m_psvrapi->NetServerGetInfo(servername, level, bufptr, buflen,
                                       totalavail);
    }
    return ns;
}
#endif


/*****************************************************************************
 *
 *  NETAPI32API.DLL WRAPPERS
 *
 *****************************************************************************/

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGroupEnum(LPCWSTR servername,
                                                        DWORD level,
                                                        LPBYTE *bufptr,
                                                        DWORD prefmaxlen,
                                                        LPDWORD entriesread,
                                                        LPDWORD totalentries,
                                                        PDWORD_PTR resume_handle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGroupEnum(servername, level, bufptr, prefmaxlen,
                                   entriesread, totalentries, resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGroupGetInfo(LPCWSTR servername,
                                                           LPCWSTR groupname,
                                                           DWORD level,
                                                           LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGroupGetInfo(servername, groupname, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGroupSetInfo(

LPCWSTR servername,
LPCWSTR groupname,
DWORD level,
LPBYTE buf,
LPDWORD parm_err
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGroupSetInfo( servername, groupname, level, buf, parm_err) ;
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetLocalGroupGetInfo(LPCWSTR servername,
                                                           LPCWSTR groupname,
                                                           DWORD level,
                                                           LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetLocalGroupGetInfo(servername, groupname, level,
                                           bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetLocalGroupSetInfo(

LPCWSTR a_servername,
LPCWSTR a_groupname,
DWORD a_level,
LPBYTE a_buf,
LPDWORD a_parm_err
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetLocalGroupSetInfo(	a_servername,
												a_groupname,
												a_level,
												a_buf,
												a_parm_err);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGroupGetUsers(LPCWSTR servername,
                                                            LPCWSTR groupname,
                                                            DWORD level,
                                                            LPBYTE *bufptr,
                                                            DWORD prefmaxlen,
                                                            LPDWORD entriesread,
                                                            LPDWORD totalentries,
                                                            PDWORD_PTR ResumeHandle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGroupGetUsers(servername, groupname, level, bufptr,
                                       prefmaxlen, entriesread, totalentries,
                                       ResumeHandle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetLocalGroupGetMembers(LPCWSTR servername,
                                                            LPCWSTR groupname,
                                                            DWORD level,
                                                            LPBYTE *bufptr,
                                                            DWORD prefmaxlen,
                                                            LPDWORD entriesread,
                                                            LPDWORD totalentries,
                                                            PDWORD_PTR ResumeHandle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetLocalGroupGetMembers(servername, groupname, level,
                                              bufptr, prefmaxlen, entriesread,
                                              totalentries, ResumeHandle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetLocalGroupEnum(LPCWSTR servername,
                                                             DWORD level,
                                                             LPBYTE *bufptr,
                                                             DWORD prefmaxlen,
                                                             LPDWORD entriesread,
                                                             LPDWORD totalentries,
                                                             PDWORD_PTR resume_handle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetLocalGroupEnum(servername, level, bufptr, prefmaxlen,
                                        entriesread, totalentries,
                                        resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareEnum(LPTSTR servername,
                                                        DWORD level,
                                                        LPBYTE *bufptr,
                                                        DWORD prefmaxlen,
                                                        LPDWORD entriesread,
                                                        LPDWORD totalentries,
                                                        LPDWORD resume_handle)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareEnum(servername, level, bufptr, prefmaxlen,
                                   entriesread, totalentries, resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareGetInfo(LPTSTR servername,
                                                           LPTSTR netname,
                                                           DWORD level,
                                                           LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareGetInfo(servername, netname, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareAdd (

	IN  LPTSTR  servername,
	IN  DWORD   level,
	IN  LPBYTE  buf,
	OUT LPDWORD parm_err
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareAdd(servername, level, buf , parm_err);
    }
    return ns;
}
#endif


#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareEnumSticky (

	IN  LPTSTR      servername,
	IN  DWORD       level,
	OUT LPBYTE      *bufptr,
	IN  DWORD       prefmaxlen,
	OUT LPDWORD     entriesread,
	OUT LPDWORD     totalentries,
	IN OUT LPDWORD  resume_handle
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareEnumSticky(servername, level, bufptr, prefmaxlen,
                                         entriesread, totalentries,
                                         resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareSetInfo (

	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   level,
	IN  LPBYTE  buf,
	OUT LPDWORD parm_err
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareSetInfo(servername, netname,level,buf,parm_err);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareDel (

	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareDel(servername, netname, reserved);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareDelSticky (

	IN  LPTSTR  servername,
	IN  LPTSTR  netname,
	IN  DWORD   reserved
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareDelSticky(servername, netname, reserved);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetShareCheck (

	IN  LPTSTR  servername,
	IN  LPTSTR  device,
	OUT LPDWORD type
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetShareCheck(servername, device, type);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUserEnum(LPCWSTR servername,
                                                       DWORD level,
                                                       DWORD filter,
                                                       LPBYTE *bufptr,
                                                       DWORD prefmaxlen,
                                                       LPDWORD entriesread,
                                                       LPDWORD totalentries,
                                                       LPDWORD resume_handle)
{
	NET_API_STATUS ns = NERR_NetworkError;
	if(m_pnetapi != NULL)
    {
        int i = 1;
	    // try with longer preferred lengths if it fails
	    // might only be germaine to NT 3.51, dunno but it works.
	    do
	    {
		    ns = m_pnetapi->NetUserEnum(servername, level, filter, bufptr,
                                      prefmaxlen * i, entriesread, totalentries,
                                      resume_handle);
		    i *= 2;
	    } while (ns == NERR_BufTooSmall && i <= 16);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUserGetInfo(LPCWSTR servername,
                                                          LPCWSTR username,
                                                          DWORD level,
                                                          LPBYTE *bufptr)

{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
        ns = m_pnetapi->NetUserGetInfo(servername, username, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUserSetInfo(

LPCWSTR a_servername,
LPCWSTR a_username,
DWORD a_level,
LPBYTE a_buf,
LPDWORD a_parm_err
)
{
    NET_API_STATUS t_ns = NERR_NetworkError;
    if( m_pnetapi != NULL )
    {
        CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
        t_ns = m_pnetapi->NetUserSetInfo( a_servername, a_username, a_level, a_buf, a_parm_err ) ;
    }
    return t_ns ;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetApiBufferFree(void *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetApiBufferFree(bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetQueryDisplayInformation(	LPWSTR ServerName,
																		DWORD Level,
																		DWORD Index,
																		DWORD EntriesRequested,
																		DWORD PreferredMaximumLength,
																		LPDWORD ReturnedEntryCount,
																		PVOID *SortedBuffer)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
        ns = m_pnetapi->NetQueryDisplayInformation(ServerName, Level, Index,
                                          EntriesRequested,
                                          PreferredMaximumLength,
                                          ReturnedEntryCount, SortedBuffer);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetServerSetInfo(LPTSTR servername,
										  DWORD level,
										  LPBYTE  bufptr,
										  LPDWORD ParmError)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetServerSetInfo(servername, level, bufptr, ParmError);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetServerGetInfo(LPTSTR servername,
                                          DWORD level,
                                          LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetServerGetInfo(servername, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::DSRoleGetPrimaryDomainInfo(LPCWSTR servername,
											  DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level,
											  LPBYTE *bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->DSRoleGetPrimaryDomainInformation(servername,
                                                                level, bufptr, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetRenameMachineInDomain(LPCWSTR a_lpServer,
                                                LPCWSTR a_lpNewMachineName,
                                                LPCWSTR a_lpAccount,
                                                LPCWSTR a_lpPassword,
                                                DWORD a_fRenameOptions)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->NetRenameMachineInDomain(a_lpServer, a_lpNewMachineName,
                                                a_lpAccount, a_lpPassword,
                                                a_fRenameOptions, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION  CNetAPI32::NetUnjoinDomain(	LPCWSTR lpServer,
															LPCWSTR lpAccount,
															LPCWSTR lpPassword,
															DWORD   fUnjoinOptions)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->NetUnjoinDomain(lpServer, lpAccount, lpPassword, fUnjoinOptions, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION  CNetAPI32::NetJoinDomain( LPCWSTR lpServer,
														LPCWSTR lpDomain,
														LPCWSTR lpAccountOU,
														LPCWSTR lpAccount,
														LPCWSTR lpPassword,
														DWORD fJoinOptions)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->NetJoinDomain(lpServer, lpDomain, lpAccountOU, lpAccount, lpPassword, fJoinOptions, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif


#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::DSRoleFreeMemory(LPBYTE bufptr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->DSRoleFreeMemory(bufptr, &ns))
        {
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif


#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGetDCName(	LPCWSTR ServerName,
															LPCWSTR DomainName,
															LPBYTE* bufptr )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
        ns = m_pnetapi->NetGetDCName(ServerName, DomainName, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetWkstaGetInfo(	LPWSTR ServerName,
																DWORD level,
																LPBYTE *bufptr )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetWkstaGetInfo(ServerName, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetGetAnyDCName(	LPWSTR ServerName,
															LPWSTR DomainName,
															LPBYTE* bufptr )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetGetAnyDCName(ServerName, DomainName, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetServerEnum(	LPTSTR servername,
														DWORD level,
														LPBYTE *bufptr,
														DWORD prefmaxlen,
														LPDWORD entriesread,
														LPDWORD totalentries,
														DWORD servertype,
														LPTSTR domain,
														LPDWORD resume_handle )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetServerEnum(servername, level, bufptr, prefmaxlen,
                                    entriesread, totalentries, servertype,
                                    domain, resume_handle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetEnumerateTrustedDomains(	LPWSTR servername,
																		LPWSTR* domainNames )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->NetEnumerateTrustedDomains(servername, domainNames, &ns))
        {   // The function doesn't exist.
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::DsGetDcName(	LPCTSTR ComputerName,
														LPCTSTR DomainName,
														GUID *DomainGuid,
														LPCTSTR SiteName,
														ULONG Flags,
														PDOMAIN_CONTROLLER_INFO *DomainControllerInfo )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        // Check if the machine is running an NT5 version of netapi32.dll...
        if(!m_pnetapi->DsGetDCName(ComputerName, DomainName, DomainGuid,
								  SiteName, Flags, DomainControllerInfo, &ns))
        {   // The function does not exist.
            ns = NERR_InternalError;
        }
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUserModalsGet(	LPWSTR servername,
																DWORD level,
																LPBYTE *bufptr )
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetUserModalsGet(servername, level, bufptr);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION	CNetAPI32::NetScheduleJobAdd (

	IN      LPCWSTR         Servername  OPTIONAL,
	IN      LPBYTE          Buffer,
	OUT     LPDWORD         JobId
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetScheduleJobAdd(Servername, Buffer, JobId);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION	CNetAPI32::NetScheduleJobDel (

	IN      LPCWSTR         Servername  OPTIONAL,
	IN      DWORD           MinJobId,
	IN      DWORD           MaxJobId
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetScheduleJobDel(Servername, MinJobId , MaxJobId);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION	CNetAPI32::NetScheduleJobEnum (

	IN      LPCWSTR         Servername              OPTIONAL,
	OUT     LPBYTE *        PointerToBuffer,
	IN      DWORD           PrefferedMaximumLength,
	OUT     LPDWORD         EntriesRead,
	OUT     LPDWORD         TotalEntries,
	IN OUT  LPDWORD         ResumeHandle
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetScheduleJobEnum(Servername, PointerToBuffer,
                                         PrefferedMaximumLength, EntriesRead,
                                         TotalEntries, ResumeHandle);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION	CNetAPI32::NetScheduleJobGetInfo (

	IN      LPCWSTR         Servername             OPTIONAL,
	IN      DWORD           JobId,
	OUT     LPBYTE *        PointerToBuffer
)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetScheduleJobGetInfo(Servername, JobId , PointerToBuffer);
    }
    return ns;
}
#endif

#ifdef NTONLY
NET_API_STATUS NET_API_FUNCTION CNetAPI32::NetUseGetInfo(
    IN LPCWSTR UncServerName OPTIONAL,
    IN LPCWSTR UseName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr)
{
    NET_API_STATUS ns = NERR_NetworkError;
    if(m_pnetapi != NULL)
    {
        ns = m_pnetapi->NetUseGetInfo(UncServerName, UseName, Level, BufPtr);
    }
    return ns;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetTrustedDomainsNT
//
//	Obtains Names of trusted domains and stuffs them in a user supplied
//	CHStringArray.
//
//	Inputs:
//
//	Outputs:	CHStringArray&	strarrayTrustedDomains;
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:
//
/////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CNetAPI32::GetTrustedDomainsNT(CHStringArray& achsTrustList)
{
    LSA_HANDLE PolicyHandle  = INVALID_HANDLE_VALUE;
    NTSTATUS Status =0;

    NET_API_STATUS nas = NERR_Success; // assume success

    BOOL bSuccess = FALSE; // assume this function will fail

    CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;
	if( t_padvapi == NULL)
	{
        return FALSE;
    }

    try
    {
        PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain = NULL;
        //
        // open the policy on the specified machine
        //
        {
            // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
            CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

            Status = OpenPolicy(

				t_padvapi ,
				NULL,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

            if(Status != STATUS_SUCCESS)
			{
                SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
                if ( t_padvapi )
				{
					CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
					t_padvapi = NULL ;
					return FALSE;
				}
            }

            //
            // obtain the AccountDomain, which is common to all three cases
            //
            Status = t_padvapi->LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                (PVOID *)&AccountDomain
                );
        }

        if(Status == STATUS_SUCCESS)
        {

            try
            {
                //
                // Note: AccountDomain->DomainSid will contain binary Sid
                //
                achsTrustList.Add(CHString(AccountDomain->DomainName.Buffer));
            }
            catch ( ... )
            {
                t_padvapi->LsaFreeMemory(AccountDomain);
                throw ;
            }

            //
            // free memory allocated for account domain
            //
            t_padvapi->LsaFreeMemory(AccountDomain);

            //
            // find out if the target machine is a domain controller
            //

            if(!IsDomainController(NULL))
            {
                PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain;
                CHString sPrimaryDomainName;

                //
                // get the primary domain
                //
                {
                    // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
                    CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
                    Status = t_padvapi->LsaQueryInformationPolicy(
                        PolicyHandle,
                        PolicyPrimaryDomainInformation,
                        (PVOID *)&PrimaryDomain
                        );
                }

                if(Status == STATUS_SUCCESS)
                {

                    //
                    // if the primary domain Sid is NULL, we are a non-member, and
                    // our work is done.
                    //
                    if(PrimaryDomain->Sid == NULL)
                    {
                        t_padvapi->LsaFreeMemory(PrimaryDomain);
                        bSuccess = TRUE;
                    }
                    else
                    {
                        try
                        {

                            achsTrustList.Add(CHString(PrimaryDomain->Name.Buffer));

                            //
                            // build a copy of what we just added.  This is necessary in order
                            // to lookup the domain controller for the specified domain.
                            // the Domain name must be NULL terminated for NetGetDCName(),
                            // and the LSA_UNICODE_STRING buffer is not necessarilly NULL
                            // terminated.  Note that in a practical implementation, we
                            // could just extract the element we added, since it ends up
                            // NULL terminated.
                            //

                            sPrimaryDomainName = CHString(PrimaryDomain->Name.Buffer);

                        }
                        catch ( ... )
                        {
                            t_padvapi->LsaFreeMemory(PrimaryDomain);
                            throw ;
                        }

                        t_padvapi->LsaFreeMemory(PrimaryDomain);

                        //
                        // get the primary domain controller computer name
                        //
                        LPWSTR DomainController = NULL;
                        nas = NetGetDCName(
                            NULL,
                            sPrimaryDomainName,
                            (LPBYTE *)&DomainController
                            );

                        if(nas == NERR_Success)
                        {
                            try
                            {

                                //
                                // close the policy handle, because we don't need it anymore
                                // for the workstation case, as we open a handle to a DC
                                // policy below
                                //
                                {
                                    // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
                                    CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

                                    t_padvapi->LsaClose(PolicyHandle);
                                    PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

                                    //
                                    // open the policy on the domain controller
                                    //
                                    Status = OpenPolicy(

										t_padvapi ,
                                        DomainController,
                                        POLICY_VIEW_LOCAL_INFORMATION,
                                        &PolicyHandle
                                        );
                                }
                            }
                            catch ( ... )
                            {
                                NetApiBufferFree(DomainController);
                                throw ;
                            }

                            //
                            // free the domaincontroller buffer
                            //
                            NetApiBufferFree(DomainController);

                            if(Status != STATUS_SUCCESS)
                            {
                                PolicyHandle = INVALID_HANDLE_VALUE;
                            }
                        }

                        //
                        // build additional trusted domain(s) list and indicate if successful
                        //
                        // doublecheck, I'm scared of the spaghetti...
                        if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
                        {
                            bSuccess = EnumTrustedDomains(PolicyHandle, achsTrustList);
                        }
                    }
                }
                else
                {
                     PolicyHandle = INVALID_HANDLE_VALUE;
                }

             }
         }
         else
         {
             PolicyHandle = INVALID_HANDLE_VALUE;
         }

		 // close the policy handle
		 // policy handle is actually a pointer (per comments in the header)
		 // will check for NULL case
		 {
			 // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
			 CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
			 if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
			 {
				 t_padvapi->LsaClose(PolicyHandle);
				 PolicyHandle = INVALID_HANDLE_VALUE ;
			 }
		 }

		 if(!bSuccess)
		 {
			 if(Status != STATUS_SUCCESS)
			 {
				 SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
			 }
			 else if(nas != NERR_Success)
			 {
				 SetLastError( nas );
			 }
		 }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
			t_padvapi = NULL ;
		}

		return bSuccess;
	 }
     catch ( ... )
     {
         if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
         {
             CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
			 t_padvapi->LsaClose(PolicyHandle);
             PolicyHandle = INVALID_HANDLE_VALUE;
         }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
			t_padvapi = NULL ;
		}
		throw ;
     }
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Function:	CWin32UserAccount::GetTrustedDomainsNT
//
//	Obtains Names of trusted domains and stuffs them in a user supplied
//	standard template library stack of _bstr_t's.
//
//	Inputs:		reference to stack of _bstr_t's
//
//	Outputs:	CHStringArray&	strarrayTrustedDomains;
//
//	Returns:	TRUE/FALSE		Success/Failure
//
//	Comments:
//
/////////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CNetAPI32::GetTrustedDomainsNT(std::vector<_bstr_t>& vectorTrustList)
{
    LSA_HANDLE PolicyHandle  = INVALID_HANDLE_VALUE;
    NTSTATUS Status =0;

    NET_API_STATUS nas = NERR_Success; // assume success

    BOOL bSuccess = FALSE; // assume this function will fail

    CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;

	if( t_padvapi == NULL)
	{
        return FALSE;
    }

    try
    {
        PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain = NULL;
        //
        // open the policy on the specified machine
        //
        {
            // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
            CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

            Status = OpenPolicy(

				t_padvapi,
				NULL,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

            if(Status != STATUS_SUCCESS)
			{
                SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
				CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
				t_padvapi = NULL ;
                return FALSE;
            }

            //
            // obtain the AccountDomain, which is common to all three cases
            //
            Status = t_padvapi->LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                (PVOID *)&AccountDomain
                );
        }

        if(Status == STATUS_SUCCESS)
        {

            try
            {
                //
                // Note: AccountDomain->DomainSid will contain binary Sid
                //
            //    achsTrustList.Add(CHString(AccountDomain->DomainName.Buffer));
                _bstr_t t_bstrtTemp(AccountDomain->DomainName.Buffer);
                if(!AlreadyAddedToList(vectorTrustList, t_bstrtTemp))
                {
                    vectorTrustList.push_back(t_bstrtTemp);
                }
            }
            catch ( ... )
            {
                t_padvapi->LsaFreeMemory(AccountDomain);
                throw ;
            }

            //
            // free memory allocated for account domain
            //
            t_padvapi->LsaFreeMemory(AccountDomain);

            //
            // find out if the target machine is a domain controller
            //

            if(!IsDomainController(NULL))
            {
                PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain;
                CHString sPrimaryDomainName;

                //
                // get the primary domain
                //
                {
                    // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
                    CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
                    Status = t_padvapi->LsaQueryInformationPolicy(
                        PolicyHandle,
                        PolicyPrimaryDomainInformation,
                        (PVOID *)&PrimaryDomain
                        );
                }

                if(Status == STATUS_SUCCESS)
                {

                    //
                    // if the primary domain Sid is NULL, we are a non-member, and
                    // our work is done.
                    //
                    if(PrimaryDomain->Sid == NULL)
                    {
                        t_padvapi->LsaFreeMemory(PrimaryDomain);
                        bSuccess = TRUE;
                    }
                    else
                    {
                        try
                        {

//                                achsTrustList.Add(CHString(PrimaryDomain->Name.Buffer));
                            _bstr_t t_bstrtTemp(PrimaryDomain->Name.Buffer) ;
                            if(!AlreadyAddedToList(vectorTrustList, t_bstrtTemp))
                            {
                                vectorTrustList.push_back(t_bstrtTemp);
                            }

                            //
                            // build a copy of what we just added.  This is necessary in order
                            // to lookup the domain controller for the specified domain.
                            // the Domain name must be NULL terminated for NetGetDCName(),
                            // and the LSA_UNICODE_STRING buffer is not necessarilly NULL
                            // terminated.  Note that in a practical implementation, we
                            // could just extract the element we added, since it ends up
                            // NULL terminated.
                            //

                            sPrimaryDomainName = PrimaryDomain->Name.Buffer;
                        }
                        catch ( ... )
                        {
                            t_padvapi->LsaFreeMemory(PrimaryDomain);
                            throw ;
                        }

                        t_padvapi->LsaFreeMemory(PrimaryDomain);

                        //
                        // get the primary domain controller computer name
                        //
                        LPWSTR DomainController = NULL;
                        nas = NetGetDCName(
                            NULL,
                            sPrimaryDomainName,
                            (LPBYTE *)&DomainController
                            );

                        if(nas == NERR_Success)
                        {
                            try
                            {

                                //
                                // close the policy handle, because we don't need it anymore
                                // for the workstation case, as we open a handle to a DC
                                // policy below
                                //
                                {
                                    // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
                                    CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

                                    t_padvapi->LsaClose(PolicyHandle);
                                    PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

                                    //
                                    // open the policy on the domain controller
                                    //
                                    Status = OpenPolicy(

										t_padvapi ,
										DomainController,
                                        POLICY_VIEW_LOCAL_INFORMATION,
                                        &PolicyHandle
                                        );
                                }
                            }
                            catch ( ... )
                            {
                                NetApiBufferFree(DomainController);
                                throw ;
                            }

                            //
                            // free the domaincontroller buffer
                            //
                            NetApiBufferFree(DomainController);

                            if(Status != STATUS_SUCCESS)
                            {
                                PolicyHandle = INVALID_HANDLE_VALUE;
                            }
                        }

                        //
                        // build additional trusted domain(s) list and indicate if successful
                        //
                        // doublecheck, I'm scared of the spaghetti...
                        if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
                        {
                            bSuccess = EnumTrustedDomains(PolicyHandle, vectorTrustList);
                        }
                    }
                }
                else
                {
                     PolicyHandle = INVALID_HANDLE_VALUE;
                }

             }
         }
         else
         {
             PolicyHandle = INVALID_HANDLE_VALUE;
         }

		 // close the policy handle
		 // policy handle is actually a pointer (per comments in the header)
		 // will check for NULL case
		 {
			 // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
			 CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
			 if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
			 {
				 t_padvapi->LsaClose(PolicyHandle);
				PolicyHandle = INVALID_HANDLE_VALUE ;
			 }

		 }

		 if(!bSuccess)
		 {
			 if(Status != STATUS_SUCCESS)
			 {
				 SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
			 }
			 else if(nas != NERR_Success)
			 {
				 SetLastError( nas );
			 }
		 }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
			t_padvapi = NULL ;
		}

		return bSuccess;
     }
     catch ( ... )
     {

         if ((PolicyHandle != INVALID_HANDLE_VALUE) && (PolicyHandle != NULL))
         {
             CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
			 t_padvapi->LsaClose(PolicyHandle);
             PolicyHandle = INVALID_HANDLE_VALUE;
         }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource (g_guidAdvApi32Api , t_padvapi ) ;
			t_padvapi = NULL ;
		}
		throw;
     }

}
#endif

///////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CNetAPI32::EnumTrustedDomains(LSA_HANDLE PolicyHandle, CHStringArray &achsTrustList)
{
    LSA_ENUMERATION_HANDLE lsaEnumHandle=0; // start an enum
    PLSA_TRUST_INFORMATION TrustInfo = NULL ;
    ULONG ulReturned;               // number of items returned
    ULONG ulCounter;                // cunter for items returned
    NTSTATUS Status;

    CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;
	if( t_padvapi == NULL)
    {
       return FALSE;
    }

    try
	{
		do
		{
			Status = t_padvapi->LsaEnumerateTrustedDomains(
							PolicyHandle,   // open policy handle
							&lsaEnumHandle, // enumeration tracker
							(PVOID *)&TrustInfo,     // buffer to receive data
							32000,          // recommended buffer size
							&ulReturned     // number of items returned
							);
			//
			// get out if an error occurred
			//
			if( (Status != STATUS_SUCCESS) &&
				(Status != STATUS_MORE_ENTRIES) &&
				(Status != STATUS_NO_MORE_ENTRIES)
				)
			{
				SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
				if ( t_padvapi )
				{
					CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
					t_padvapi = NULL ;
				}
				return FALSE;
			}

			//
			// Display results
			// Note: Sids are in TrustInfo[ulCounter].Sid
			//
			for(ulCounter = 0 ; ulCounter < ulReturned ; ulCounter++)
			{
			   achsTrustList.Add(CHString(TrustInfo[ulCounter].Name.Buffer));
			}

			//
			// free the buffer
			//
			if ( TrustInfo )
			{
				t_padvapi->LsaFreeMemory ( TrustInfo ) ;
				TrustInfo = NULL ;
			}

		} while (Status != STATUS_NO_MORE_ENTRIES);

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}
		return TRUE;
	}
	catch ( ... )
	{
		if ( TrustInfo )
		{
			t_padvapi->LsaFreeMemory ( TrustInfo ) ;
			TrustInfo = NULL ;
		}
		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
		}
		throw ;
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////
#ifdef NTONLY
BOOL CNetAPI32::EnumTrustedDomains(LSA_HANDLE PolicyHandle, std::vector<_bstr_t>& vectorTrustList)
{
    LSA_ENUMERATION_HANDLE lsaEnumHandle=0; // start an enum
    PLSA_TRUST_INFORMATION TrustInfo = NULL ;
    ULONG ulReturned;               // number of items returned
    ULONG ulCounter;                // counter for items returned
    NTSTATUS Status;

    CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;
	if( t_padvapi == NULL )
    {
       return FALSE;
    }

	try
	{
		do {
			Status = t_padvapi->LsaEnumerateTrustedDomains(
							PolicyHandle,   // open policy handle
							&lsaEnumHandle, // enumeration tracker
							(PVOID *)&TrustInfo,     // buffer to receive data
							32000,          // recommended buffer size
							&ulReturned     // number of items returned
							);
			//
			// get out if an error occurred
			//
			if( (Status != STATUS_SUCCESS) &&
				(Status != STATUS_MORE_ENTRIES) &&
				(Status != STATUS_NO_MORE_ENTRIES)
				)
			{
				SetLastError( t_padvapi->LsaNtStatusToWinError(Status) );
				if ( t_padvapi )
				{
					CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
					t_padvapi = NULL ;
				}
				return FALSE;
			}

			//
			// Display results
			// Note: Sids are in TrustInfo[ulCounter].Sid
			//
			for(ulCounter = 0 ; ulCounter < ulReturned ; ulCounter++)
			{
				_bstr_t t_bstrtTemp(TrustInfo[ulCounter].Name.Buffer);
				if(!AlreadyAddedToList(vectorTrustList, t_bstrtTemp))
				{
					vectorTrustList.push_back(t_bstrtTemp);
				}
			}
			//
			// free the buffer
			//
			if ( TrustInfo )
			{
				t_padvapi->LsaFreeMemory(TrustInfo);
				TrustInfo = NULL ;
			}

		} while (Status != STATUS_NO_MORE_ENTRIES);

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}

		return TRUE;
	}
	catch ( ... )
	{
		if ( TrustInfo )
		{
			t_padvapi->LsaFreeMemory ( TrustInfo ) ;
			TrustInfo = NULL ;
		}
		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}
		throw ;
	}
}
#endif
///////////////////////////////////////////////////////////////////////////////

#ifdef NTONLY
BOOL CNetAPI32::IsDomainController(LPTSTR Server)
{
    PSERVER_INFO_101 si101;
    BOOL bRet = FALSE;  // Gotta return something

    if (NetServerGetInfo(
        Server,
        101,    // info-level
        (LPBYTE *)&si101
        ) == NERR_Success) {

        if( (si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
            (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ) {
            //
            // we are dealing with a DC
            //
            bRet = TRUE;
        } else {
            bRet = FALSE;
        }

        NetApiBufferFree(si101);
    }

    return bRet;
}
#endif

#ifdef NTONLY
void CNetAPI32::InitLsaString(PLSA_UNICODE_STRING LsaString, LPWSTR String )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;

        return;
    }

    StringLength = lstrlenW(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
}
#endif

#ifdef NTONLY
NTSTATUS CNetAPI32::OpenPolicy( CAdvApi32Api * a_padvapi , LPWSTR ServerName, DWORD DesiredAccess, PLSA_HANDLE PolicyHandle)
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if(ServerName != NULL)
	{
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);

        Server = &ServerString;
    }
	else
	{
        Server = NULL;
    }

    //
    // Attempt to open the policy
    //
    return a_padvapi->LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}
#endif


bool CNetAPI32::AlreadyAddedToList(std::vector<_bstr_t> &vecbstrtList, _bstr_t &bstrtItem)
{
    _bstr_t t_bstrtTemp1;
    _bstr_t t_bstrtTemp2;

    for(LONG m = 0; m < vecbstrtList.size(); m++)
    {
        t_bstrtTemp1 = _tcsupr((LPTSTR)vecbstrtList[m]);
        t_bstrtTemp2 = _tcsupr((LPTSTR)bstrtItem);
        if(t_bstrtTemp1 == t_bstrtTemp2)
        {
            return TRUE;
        }
    }
    return FALSE;
}


#ifdef NTONLY
BOOL CNetAPI32::DsRolepGetPrimaryDomainInformationDownlevel
(
    DSROLE_MACHINE_ROLE &a_rMachineRole,
	DWORD &a_rdwWin32Err
)
{
    a_rdwWin32Err = ERROR_SUCCESS ;
	BOOL t_bRet = FALSE ;
    NTSTATUS t_Status ;
    LSA_HANDLE t_hPolicyHandle					= NULL ;
    PPOLICY_PRIMARY_DOMAIN_INFO t_pPDI			= NULL ;
    PPOLICY_LSA_SERVER_ROLE_INFO t_pServerRole	= NULL ;
    PPOLICY_ACCOUNT_DOMAIN_INFO t_pADI			= NULL ;
	NT_PRODUCT_TYPE t_ProductType ;

    a_rMachineRole = DsRole_RoleStandaloneServer ;

	CAdvApi32Api *t_padvapi = (CAdvApi32Api*) CResourceManager::sm_TheResourceManager.GetResource(g_guidAdvApi32Api, NULL) ;
	if( t_padvapi == NULL)
    {
       return FALSE;
    }

	try
	{
		if ( !DsRolepGetProductTypeForServer ( t_ProductType , a_rdwWin32Err ) )
		{
			if ( a_rdwWin32Err == ERROR_SUCCESS )
			{
				a_rdwWin32Err = ERROR_UNKNOWN_PRODUCT ;
			}
			return t_bRet ;
		}

		{
			// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
			CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

			t_Status = OpenPolicy (

							t_padvapi ,
							NULL ,
							POLICY_VIEW_LOCAL_INFORMATION ,
							&t_hPolicyHandle
						);
		}

		if ( NT_SUCCESS( t_Status ) )
		{
			{
				// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
				CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

				t_Status = t_padvapi->LsaQueryInformationPolicy (

											t_hPolicyHandle ,
											PolicyPrimaryDomainInformation ,
											( PVOID * ) &t_pPDI
										) ;
			}

			if ( NT_SUCCESS ( t_Status ) )
			{
				switch ( t_ProductType )
				{
					case NtProductWinNt:
						{
							t_bRet = TRUE ;
							if ( t_pPDI->Sid == NULL )
							{
								a_rMachineRole = DsRole_RoleStandaloneWorkstation ;
							}
							else
							{
								a_rMachineRole = DsRole_RoleMemberWorkstation ;

							}
							break;
						}


					case NtProductServer:
						{
							t_bRet = TRUE ;
							if ( t_pPDI->Sid == NULL )
							{
								a_rMachineRole = DsRole_RoleStandaloneServer ;
							}
							else
							{
								a_rMachineRole = DsRole_RoleMemberServer ;
							}
							break;
						}

					case NtProductLanManNt:
						{
							{
								// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
								CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

								t_Status = t_padvapi->LsaQueryInformationPolicy (

															t_hPolicyHandle ,
															PolicyLsaServerRoleInformation ,
															( PVOID * )&t_pServerRole
														) ;
							}
							if ( NT_SUCCESS( t_Status ) )
							{
								if ( t_pServerRole->LsaServerRole == PolicyServerRolePrimary )
								{
									{
										// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
										CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

										//
										// If we think we're a primary domain controller, we'll need to
										// guard against the case where we're actually standalone during setup
										//
										t_Status = t_padvapi->LsaQueryInformationPolicy (

															t_hPolicyHandle,
															PolicyAccountDomainInformation ,
															( PVOID * )&t_pADI
													) ;
									}

									if ( NT_SUCCESS( t_Status ) )
									{
										t_bRet = TRUE ;
										if (	t_pPDI->Sid == NULL			||
												t_pADI->DomainSid == NULL	||
												! EqualSid ( t_pADI->DomainSid, t_pPDI->Sid )
											)
										{
											a_rMachineRole = DsRole_RoleStandaloneServer ;
										}
										else
										{
											a_rMachineRole = DsRole_RolePrimaryDomainController ;
										}
									}
								}
								else
								{
									t_bRet = TRUE ;
									a_rMachineRole = DsRole_RoleBackupDomainController;
								}
							}
							break;
						}

					default:
						{
							t_Status = STATUS_INVALID_PARAMETER;
							break;
						}
				}
			}

			if ( t_hPolicyHandle )
			{
				// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
				CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
				t_padvapi->LsaClose ( t_hPolicyHandle ) ;
				t_hPolicyHandle = NULL ;
			}

			if ( t_pPDI )
			{
				t_padvapi->LsaFreeMemory ( t_pPDI ) ;
				t_pPDI = NULL ;
			}

			if ( t_pADI != NULL )
			{
				t_padvapi->LsaFreeMemory( t_pADI ) ;
				t_pADI = NULL ;
			}

			if ( t_pServerRole != NULL )
			{
				t_padvapi->LsaFreeMemory( t_pServerRole ) ;
			}
		}

		a_rdwWin32Err = t_padvapi->LsaNtStatusToWinError( t_Status ) ;

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}

		return t_bRet ;
	}

	catch ( ... )
	{
		if ( t_hPolicyHandle )
		{
			// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
			CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);
			t_padvapi->LsaClose ( t_hPolicyHandle ) ;
			t_hPolicyHandle = NULL ;
		}

        if ( t_pPDI )
		{
			t_padvapi->LsaFreeMemory ( t_pPDI ) ;
			t_pPDI = NULL ;
		}

        if ( t_pADI != NULL )
		{
            t_padvapi->LsaFreeMemory( t_pADI ) ;
			t_pADI = NULL ;
        }

        if ( t_pServerRole != NULL )
		{
            t_padvapi->LsaFreeMemory( t_pServerRole ) ;
        }

		if ( t_padvapi )
		{
			CResourceManager::sm_TheResourceManager.ReleaseResource(g_guidAdvApi32Api, t_padvapi ) ;
			t_padvapi = NULL ;
		}

		throw ;
	}
}


/*
 * This function will return true if it succeeds. If the return value is false & the Win32 error code in a_rdwWin32Err parameter
 * is ERROR_SUCCESS, that means we don't know what the product type is
 */
BOOL CNetAPI32::DsRolepGetProductTypeForServer
(
	NT_PRODUCT_TYPE &a_rProductType ,
	DWORD &a_rdwWin32Err
)
{
    HKEY t_hProductKey	= NULL ;
    PBYTE t_pBuffer		= NULL;
    ULONG t_lType, t_lSize = 0;
	BOOL t_bRet = FALSE ;

	try
	{
		a_rdwWin32Err = RegOpenKeyEx (

						HKEY_LOCAL_MACHINE,
						L"system\\currentcontrolset\\control\\productoptions",
						0,
						KEY_READ,
						&t_hProductKey
					) ;

		if ( a_rdwWin32Err == ERROR_SUCCESS )
		{
			a_rdwWin32Err = RegQueryValueEx (

							t_hProductKey,
							L"ProductType",
							0,
							&t_lType,
							0,
							&t_lSize
						) ;

			if ( a_rdwWin32Err == ERROR_SUCCESS )
			{
				t_pBuffer = new BYTE [t_lSize] ;

				if ( t_pBuffer )
				{
					a_rdwWin32Err = RegQueryValueEx(

										t_hProductKey,
										L"ProductType",
										0,
										&t_lType,
										t_pBuffer,
										&t_lSize
									) ;

					if ( a_rdwWin32Err == ERROR_SUCCESS )
					{
						t_bRet = TRUE ;
						if ( !_wcsicmp( ( PWSTR )t_pBuffer, L"LanmanNt" ) )
						{
							a_rProductType = NtProductLanManNt;
						}
						else if ( !_wcsicmp( ( PWSTR )t_pBuffer, L"ServerNt" ) )
						{
							a_rProductType = NtProductServer;
						}
						else if ( !_wcsicmp( ( PWSTR )t_pBuffer, L"WinNt" ) )
						{
							a_rProductType = NtProductWinNt;
						}
						else
						{
							t_bRet = FALSE ;
						}
					}

					delete [] t_pBuffer;
					t_pBuffer = NULL ;
				}
				else
				{
					throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
				}
			}

			RegCloseKey ( t_hProductKey ) ;
			t_hProductKey = NULL ;
		}

		return t_bRet ;
	}

	catch ( ... )
	{
		if ( t_hProductKey )
		{
			RegCloseKey ( t_hProductKey ) ;
			t_hProductKey = NULL ;
		}

		if ( t_pBuffer )
		{
			delete [] t_pBuffer ;
			t_pBuffer = NULL ;
		}

		throw ;
	}
}
#endif


#ifdef NTONLY
DWORD CNetAPI32::GetDCName(
    LPCWSTR wstrDomain,
    CHString& chstrDCName)
{
    DWORD dwRet = ERROR_SUCCESS;

#if NTONLY < 5
    LPBYTE lpbBuff = NULL;

    dwRet = NetGetDCName(
        NULL, 
        wstrDomain, 
        &lpbBuff);

    if(dwRet == NO_ERROR)
    {
        try
        {
            chstrDCName = (LPCWSTR)lpbBuff;
        }
        catch(...)
        {
            NetApiBufferFree(lpbBuff);
            lpbBuff = NULL;
            throw;
        }

        NetApiBufferFree(lpbBuff);
        lpbBuff = NULL;
    }
    else
    {
        dwRet = NetGetAnyDCName(
            NULL,
            _bstr_t(wstrDomain),
            &lpbBuff);

        if(dwRet == NO_ERROR)
        {
            try
            {
                chstrDCName = (LPCWSTR)lpbBuff;
            }
            catch(...)
            {
                NetApiBufferFree(lpbBuff);
                lpbBuff = NULL;
                throw;
            }

            NetApiBufferFree(lpbBuff);
            lpbBuff = NULL;
        }
    }

#else
    PDOMAIN_CONTROLLER_INFO pDomInfo = NULL;
    
    dwRet = DsGetDcName(
        NULL, 
        wstrDomain, 
        NULL, 
        NULL, 
        /*DS_PDC_REQUIRED*/ 0, 
        &pDomInfo);

    if(dwRet != NO_ERROR)
    {
        dwRet = DsGetDcName(
            NULL, 
            wstrDomain, 
            NULL, 
            NULL, 
            /*DS_PDC_REQUIRED | */ DS_FORCE_REDISCOVERY, 
            &pDomInfo);
    }
    
    if(dwRet == NO_ERROR)
    {
        try
        {
            chstrDCName = pDomInfo->DomainControllerName;
        }
        catch(...)
        {
            NetApiBufferFree(pDomInfo);
            pDomInfo = NULL;
            throw;
        }

        NetApiBufferFree(pDomInfo);
        pDomInfo = NULL;
    }
    
#endif

    return dwRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\win32provider\common\userhive.cpp ===
//============================================================

//

// UserHive.cpp - Class to load/unload specified user's profile

//                hive from registry

//

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
// 01/03/97     a-jmoon     created
//
//============================================================

#include "precomp.h"
#include <assertbreak.h>
#include <cregcls.h>
#include "sid.h"
#include "UserHive.h"
#include <cominit.h>
#include <CreateMutexAsProcess.h>

CThreadBase CUserHive::m_criticalSection;

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::CUserHive
 *
 *  DESCRIPTION : Constructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CUserHive::CUserHive()
{
    OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;
    GetVersionEx(&OSInfo) ;
	m_pOriginalPriv = NULL;
    m_dwSize = NULL;
    m_hKey = NULL;
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::~CUserHive
 *
 *  DESCRIPTION : Destructor
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

CUserHive::~CUserHive()
{
#ifdef NTONLY
	if (m_pOriginalPriv)
		RestorePrivilege();
#endif

    // NOTE: The destructor does not unload the key.  Nor does doing a load unload
    // a previously loaded key;
    ASSERT_BREAK(m_hKey == NULL);

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::AcquirePrivilege
 *
 *  DESCRIPTION : Acquires SeRestorePrivilege for calling thread
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD CUserHive::AcquirePrivilege()
{
	// are you calling in twice?  Shouldn't.
    // at worst, it would cause a leak, so I'm going with it anyway.
    ASSERT_BREAK(m_pOriginalPriv == NULL);

    BOOL bRetCode = FALSE;
    SmartCloseHandle hToken;
    TOKEN_PRIVILEGES TPriv ;
    LUID LUID ;

    // Validate the platform
    //======================

    // Try getting the thread token.  
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES |
        TOKEN_QUERY, FALSE, &hToken)) 
    {

        GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &m_dwSize);
        if (m_dwSize > 0)
        {
            // This is cleaned in the destructor, so no try/catch required
            m_pOriginalPriv = (TOKEN_PRIVILEGES*) new BYTE[m_dwSize];
            if (m_pOriginalPriv == NULL)
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

        }

        if (m_pOriginalPriv && GetTokenInformation(hToken, TokenPrivileges, m_pOriginalPriv, m_dwSize, &m_dwSize))
        {
			// DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
			CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

			bRetCode = LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &LUID) ;
			if(bRetCode)
            {
				TPriv.PrivilegeCount = 1 ;
				TPriv.Privileges[0].Luid = LUID ;
				TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;

				bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv, sizeof(TOKEN_PRIVILEGES), NULL, NULL) ;
		    }
			bRetCode = LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &LUID) ;
			if(bRetCode)
            {
				TPriv.PrivilegeCount = 1 ;
				TPriv.Privileges[0].Luid = LUID ;
				TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;

				bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv, sizeof(TOKEN_PRIVILEGES), NULL, NULL) ;
		    }
		}
    }

    if(!bRetCode)
    {
        return GetLastError() ;
    }

    return ERROR_SUCCESS ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::RestorePrivilege
 *
 *  DESCRIPTION : Restores original status of SeRestorePrivilege
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    :
 *
 *****************************************************************************/

#ifdef NTONLY
void CUserHive::RestorePrivilege()
{
    ASSERT_BREAK(m_pOriginalPriv != NULL);

    if (m_pOriginalPriv != NULL)
    {
        SmartCloseHandle hToken;

        try
        {
            if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TRUE, &hToken))
            {
                AdjustTokenPrivileges(hToken, FALSE, m_pOriginalPriv, m_dwSize, NULL, NULL);
            }
        }
        catch ( ... )
        {
            delete m_pOriginalPriv;
            m_pOriginalPriv = NULL;
            m_dwSize = 0;

            throw;
        }

        delete m_pOriginalPriv;
        m_pOriginalPriv = NULL;
        m_dwSize = 0;
    }
}
#endif

DWORD CUserHive::Load(LPCWSTR pszUserName, LPWSTR pszKeyName)
{
    // NOTE: The destructor does not unload the key.  Nor does doing a load unload
    // a previously loaded key;
    ASSERT_BREAK(m_hKey == NULL);

#ifdef NTONLY
		return LoadNT(pszUserName, pszKeyName);
#endif
#ifdef WIN9XONLY
		return Load95(pszUserName, pszKeyName);
#endif
}

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::LoadNT
 *
 *  DESCRIPTION : Locates user's hive & loads into registry if not already
 *                present
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : pszKeyName receives the expanded SID of the user's
 *                registry key under HKEY_USERS
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Hive will remain in registry unless unloaded
 *
 *****************************************************************************/

#ifdef NTONLY
DWORD CUserHive::LoadNT(LPCTSTR pszUserName, LPTSTR pszKeyName)
{
    DWORD i, dwSIDSize, dwRetCode, dwDomainNameSize,  dwSubAuthorities ;
	char SIDBuffer[_MAX_PATH];
    TCHAR szDomainName[_MAX_PATH], szSID[_MAX_PATH], szTemp[_MAX_PATH]  ;
    SID *pSID = (SID *) SIDBuffer ;
    PSID_IDENTIFIER_AUTHORITY pSIA ;
    SID_NAME_USE AccountType ;
    CHString sTemp ;
    CRegistry Reg ;

    // Set the necessary privs
    //========================
    dwRetCode = AcquirePrivilege() ;
    if(dwRetCode != ERROR_SUCCESS)
    {
        return dwRetCode ;
    }

    // Look up the user's account info
    //================================
    dwSIDSize = sizeof(SIDBuffer) ;
    dwDomainNameSize = sizeof(szDomainName) ;

	bool bLookup;
	{
		CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

		bLookup = LookupAccountName(NULL, pszUserName, pSID, &dwSIDSize,
		                      szDomainName, &dwDomainNameSize, &AccountType);
    }

	if(!bLookup)
    {
	    RestorePrivilege() ;
        return ERROR_BAD_USERNAME ;
    }



    // Translate the SID into text (a la PSS article Q131320)
    //=======================================================

    pSIA = GetSidIdentifierAuthority(pSID) ;
    dwSubAuthorities = *GetSidSubAuthorityCount(pSID) ;
    dwSIDSize = _stprintf(szSID, _T("S-%lu-"), (DWORD) SID_REVISION) ;

    if((pSIA->Value[0] != 0) || (pSIA->Value[1] != 0) )
    {
        dwSIDSize += _stprintf(szSID + _tcslen(szSID), _T("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                             (USHORT) pSIA->Value[0],
                             (USHORT) pSIA->Value[1],
                             (USHORT) pSIA->Value[2],
                             (USHORT) pSIA->Value[3],
                             (USHORT) pSIA->Value[4],
                             (USHORT) pSIA->Value[5]) ;
    }
    else
    {
        dwSIDSize += _stprintf(szSID + _tcslen(szSID), _T("%lu"),
                             (ULONG)(pSIA->Value[5]      ) +
                             (ULONG)(pSIA->Value[4] <<  8) +
                             (ULONG)(pSIA->Value[3] << 16) +
                             (ULONG)(pSIA->Value[2] << 24));
    }

    for(i = 0 ; i < dwSubAuthorities ; i++)
    {
        dwSIDSize += _stprintf(szSID + dwSIDSize, _T("-%lu"),
                             *GetSidSubAuthority(pSID, i)) ;
    }

    // See if the key already exists
    //==============================
    dwRetCode = Reg.Open(HKEY_USERS, szSID, KEY_READ) ;

    // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
//    Reg.Close();

    if(dwRetCode != ERROR_SUCCESS)
    {
        // Try to locate user's registry hive
        //===================================

        _stprintf(szTemp, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s"), szSID) ;
        dwRetCode = Reg.Open(HKEY_LOCAL_MACHINE, szTemp, KEY_READ) ;
        if(dwRetCode == ERROR_SUCCESS)
        {

            dwRetCode = Reg.GetCurrentKeyValue(_T("ProfileImagePath"), sTemp) ;
            Reg.Close() ;
            if(dwRetCode == ERROR_SUCCESS)
            {

                // NT 4 doesn't include the file name in the registry
                //===================================================

                if(OSInfo.dwMajorVersion >= 4)
                {

                    sTemp += _T("\\NTUSER.DAT") ;
                }

                ExpandEnvironmentStrings(LPCTSTR(sTemp), szTemp, sizeof(szTemp) / sizeof(TCHAR)) ;

				// Try it three times, another process may have the file open
				bool bTryTryAgain = false;
				int  nTries = 0;
				do
				{
					// need to serialize access, using "write" because RegLoadKey wants exclusive access
					// even though it is a read operation
					m_criticalSection.BeginWrite();

                    try
                    {
	                    dwRetCode = (DWORD) RegLoadKey(HKEY_USERS, szSID, szTemp) ;
                    }
                    catch ( ... )
                    {
    					m_criticalSection.EndWrite();
                        throw;
                    }

					m_criticalSection.EndWrite();

					if ((dwRetCode == ERROR_SHARING_VIOLATION)
						&& (++nTries < 11))
					{
						Sleep(20 * nTries);
						bTryTryAgain = true;
					}
					else
                    {
						bTryTryAgain = false;
                    }

				} while (bTryTryAgain);
                // if we still can't get in, tell somebody.
                if (dwRetCode == ERROR_SHARING_VIOLATION)
    			    LogErrorMessage(_T("Sharing violation on NTUSER.DAT (Load)"));

			}
        }
    }

    if(dwRetCode == ERROR_SUCCESS)
    {
        _tcscpy(pszKeyName, szSID) ;

        LONG lRetVal;
        CHString sKey(szSID);

        sKey += _T("\\Software");
        lRetVal = RegOpenKeyEx(HKEY_USERS, sKey, 0, KEY_QUERY_VALUE, &m_hKey);

        ASSERT_BREAK(lRetVal == ERROR_SUCCESS);
    }

    // Restore original privilege level & end self-impersonation
    //==========================================================

    RestorePrivilege() ;

    return dwRetCode ;
}
#endif
/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::Load95
 *
 *  DESCRIPTION : Locates user's hive & loads into registry if not already
 *                present
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : pszKeyName receives the expanded SID of the user's
 *                registry key under HKEY_USERS
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Hive will remain in registry unless unloaded
 *
 *****************************************************************************/
#ifdef WIN9XONLY
DWORD CUserHive::Load95(LPCWSTR pszUserName, LPWSTR pszKeyName)
{
    DWORD dwRetCode;
    WCHAR wszTemp[_MAX_PATH];
    TCHAR szTemp[_MAX_PATH];
    CHString sTemp ;
    CRegistry Reg ;

	wcscpy(pszKeyName, pszUserName);

    // See if the key already exists
    //==============================
    dwRetCode = Reg.Open(HKEY_USERS, pszKeyName, KEY_READ) ;
    // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
//    Reg.Close() ;

    if(dwRetCode == ERROR_SUCCESS)
    {

        // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
//        Reg.Close() ;
    }
    else
    {
        // Try to locate user's registry hive
        //===================================
        swprintf(wszTemp, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProfileList\\%s", pszUserName) ;
        dwRetCode = Reg.Open(HKEY_LOCAL_MACHINE, wszTemp, KEY_READ);
        if(dwRetCode == ERROR_SUCCESS) {

            dwRetCode = Reg.GetCurrentKeyValue(L"ProfileImagePath", sTemp) ;
            Reg.Close() ;
            if(dwRetCode == ERROR_SUCCESS)
			{
				sTemp += _T("\\USER.DAT") ;

                ExpandEnvironmentStrings(TOBSTRT(sTemp), szTemp, sizeof(szTemp) / sizeof(TCHAR)) ;

				// Try it three times, another process may have the file open
				bool bTryTryAgain = false;
				int  nTries = 0;
				do
				{
					// need to serialize access, using "write" because RegLoadKey wants exclusive access
					// even though it is a read operation
					m_criticalSection.BeginWrite();

                    try
                    {
	                    dwRetCode = (DWORD) RegLoadKey(HKEY_USERS, TOBSTRT(pszUserName), szTemp) ;
                    }
                    catch ( ... )
                    {
    					m_criticalSection.EndWrite();
                        throw;
                    }

					m_criticalSection.EndWrite();

					if ((dwRetCode == ERROR_SHARING_VIOLATION)
						&& (++nTries < 11))
					{
						LogErrorMessage(L"Sharing violation on USER.DAT (Load)");
						Sleep(15 * nTries);
						bTryTryAgain = true;
					}
					else
						bTryTryAgain = false;

				} while (bTryTryAgain);
			}
        }
    }

    if (dwRetCode == ERROR_SUCCESS)
    {
        LONG lRetVal;
        CHString sKey(pszUserName);

        sKey += L"\\Software";
        lRetVal = RegOpenKeyEx(HKEY_USERS, TOBSTRT(sKey), 0, KEY_QUERY_VALUE, &m_hKey);
        ASSERT_BREAK(lRetVal == ERROR_SUCCESS);
    }


    return dwRetCode ;
}
#endif

/*****************************************************************************
 *
 *  FUNCTION    : CUserHive::LoadProfile
 *
 *  DESCRIPTION : Locates user's hive & loads into registry if not already
 *                present
 *
 *  INPUTS      : none
 *
 *  OUTPUTS     : none.
 *
 *  RETURNS     : nothing
 *
 *  COMMENTS    : Hive will remain in registry unless unloaded
 *				  NT Only.
 *
 *****************************************************************************/

DWORD CUserHive::LoadProfile( LPCWSTR pszSID, CHString& strUserName )
{
    // NOTE: The destructor does not unload the key.  Nor does doing a load unload
    // a previously loaded key;
    ASSERT_BREAK(m_hKey == NULL);

    DWORD dwRetCode = ERROR_SUCCESS;
    WCHAR szTemp[_MAX_PATH] ;
    CHString sTemp ;
    CRegistry Reg ;

    strUserName = L"";

    // Set the necessary privs
    //========================

#ifdef NTONLY
    dwRetCode = AcquirePrivilege() ;
#endif
    if(dwRetCode != ERROR_SUCCESS) 
    {
        return dwRetCode ;
    }

    // See if the key already exists
    //==============================

    dwRetCode = Reg.Open(HKEY_USERS, pszSID, KEY_READ) ;
    // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
//    Reg.Close() ;

	// If we got the profile, make sure we can get account information regarding
	// the SID.
    if(dwRetCode == ERROR_SUC